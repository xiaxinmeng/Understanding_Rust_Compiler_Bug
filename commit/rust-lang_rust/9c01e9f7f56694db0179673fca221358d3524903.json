{"sha": "9c01e9f7f56694db0179673fca221358d3524903", "node_id": "C_kwDOAAsO6NoAKDljMDFlOWY3ZjU2Njk0ZGIwMTc5NjczZmNhMjIxMzU4ZDM1MjQ5MDM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-24T09:12:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-24T09:12:14Z"}, "message": "Merge from rustc", "tree": {"sha": "7a64babe493c9e88f72cfd2eead7fccadd304e0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a64babe493c9e88f72cfd2eead7fccadd304e0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c01e9f7f56694db0179673fca221358d3524903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c01e9f7f56694db0179673fca221358d3524903", "html_url": "https://github.com/rust-lang/rust/commit/9c01e9f7f56694db0179673fca221358d3524903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c01e9f7f56694db0179673fca221358d3524903/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c14ad4d9fe83e737d7b8db0c2520ef54c99926e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c14ad4d9fe83e737d7b8db0c2520ef54c99926e", "html_url": "https://github.com/rust-lang/rust/commit/0c14ad4d9fe83e737d7b8db0c2520ef54c99926e"}, {"sha": "4f4d0586ad20c66a16d547581ca379beafece93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4d0586ad20c66a16d547581ca379beafece93a", "html_url": "https://github.com/rust-lang/rust/commit/4f4d0586ad20c66a16d547581ca379beafece93a"}], "stats": {"total": 15069, "additions": 11399, "deletions": 3670}, "files": [{"sha": "23d3e71424b2b41b8490407f4f5d531de13eba64", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -41,16 +41,24 @@ jobs:\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n     if: \"github.event_name == 'pull_request'\"\n+    continue-on-error: \"${{ matrix.tidy }}\"\n     strategy:\n       matrix:\n         include:\n           - name: mingw-check\n+            tidy: false\n+            os: ubuntu-20.04-xl\n+            env: {}\n+          - name: mingw-check-tidy\n+            tidy: true\n             os: ubuntu-20.04-xl\n             env: {}\n           - name: x86_64-gnu-llvm-13\n+            tidy: false\n             os: ubuntu-20.04-xl\n             env: {}\n           - name: x86_64-gnu-tools\n+            tidy: false\n             env:\n               CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n             os: ubuntu-20.04-xl\n@@ -301,7 +309,7 @@ jobs:\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n-              RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n+              RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false --set rust.lto=thin\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n               SELECT_XCODE: /Applications/Xcode_13.4.1.app"}, {"sha": "97148641670f448e9751683d2348d6c8e7d12e04", "filename": "Cargo.lock", "status": "modified", "additions": 172, "deletions": 80, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -30,7 +30,7 @@ version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"43bb833f0bf979d8475d38fbf09ed3b8a55e1885fe93ad3f93239fc6a4f17b98\"\n dependencies = [\n- \"getrandom 0.2.0\",\n+ \"getrandom 0.2.8\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -77,6 +77,15 @@ dependencies = [\n  \"yansi-term\",\n ]\n \n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.12.1\"\n@@ -181,7 +190,7 @@ checksum = \"cab84319d616cfb654d03394f38ab7e6f0919e181b1b57e1fd15e7fb4077d9a7\"\n dependencies = [\n  \"addr2line\",\n  \"cc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object\",\n@@ -294,7 +303,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.68.0\"\n+version = \"0.69.0\"\n dependencies = [\n  \"anyhow\",\n  \"bytesize\",\n@@ -394,7 +403,7 @@ dependencies = [\n  \"directories\",\n  \"rustc-build-sysroot\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util\",\n+ \"rustc_tools_util 0.2.1\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n@@ -502,12 +511,6 @@ dependencies = [\n  \"jobserver\",\n ]\n \n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -658,7 +661,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.67\"\n+version = \"0.1.68\"\n dependencies = [\n  \"clippy_lints\",\n  \"clippy_utils\",\n@@ -673,7 +676,7 @@ dependencies = [\n  \"regex\",\n  \"rustc-semver\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util\",\n+ \"rustc_tools_util 0.3.0\",\n  \"semver\",\n  \"serde\",\n  \"syn\",\n@@ -700,14 +703,14 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.67\"\n+version = \"0.1.68\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n  \"declare_clippy_lint\",\n  \"if_chain\",\n  \"itertools\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"rustc-semver\",\n@@ -723,7 +726,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.67\"\n+version = \"0.1.68\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -951,7 +954,7 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -960,42 +963,41 @@ version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-deque\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n+checksum = \"715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"crossbeam-epoch\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.6\"\n+version = \"0.9.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"97242a70df9b89a65d0b6df3c4bf5b9ce03c5b7309019777fbde37e7537f8762\"\n+checksum = \"01a9af1f4c2ef74bb8aa1f7e19706bc72d03598c8a570bb5de72243c7a9d9d5a\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"autocfg\",\n+ \"cfg-if\",\n  \"crossbeam-utils\",\n- \"lazy_static\",\n  \"memoffset\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.8\"\n+version = \"0.8.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0bf124c720b7686e3c2663cf54062ab0f68a88af2fb6a030e87e30bf721fcb38\"\n+checksum = \"4fb766fa798726286dbbb842f174001dab8abc7b627a1dd86e0b7222a95d929f\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n- \"lazy_static\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -1029,6 +1031,16 @@ dependencies = [\n  \"quote\",\n ]\n \n+[[package]]\n+name = \"ctor\"\n+version = \"0.1.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d2301688392eb071b0bf1a37be05c469d3cc4dbbd95df672fe28ab021e6a096\"\n+dependencies = [\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"curl\"\n version = \"0.4.44\"\n@@ -1068,7 +1080,7 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"declare_clippy_lint\"\n-version = \"0.1.67\"\n+version = \"0.1.68\"\n dependencies = [\n  \"itertools\",\n  \"quote\",\n@@ -1105,6 +1117,12 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8\"\n \n+[[package]]\n+name = \"difference\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n+\n [[package]]\n name = \"digest\"\n version = \"0.10.2\"\n@@ -1139,7 +1157,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"dirs-sys-next\",\n ]\n \n@@ -1342,7 +1360,7 @@ version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1d34cfa13a63ae058bfa601fe9e313bbdb3746427c1459185464ce0fcf62e1e8\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"winapi\",\n@@ -1360,7 +1378,7 @@ version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b39522e96686d38f4bc984b9198e3a0613264abaebaff2c5c918bfa6b6da09af\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"crc32fast\",\n  \"libc\",\n  \"libz-sys\",\n@@ -1599,20 +1617,20 @@ version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.0\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee8025cf36f917e6a52cce185b7c7177689b838b7ec138364e50cc2277a56cf4\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"libc\",\n- \"wasi 0.9.0+wasi-snapshot-preview1\",\n+ \"wasi 0.11.0+wasi-snapshot-preview1\",\n ]\n \n [[package]]\n@@ -1684,6 +1702,21 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"handlebars\"\n+version = \"3.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4498fc115fa7d34de968184e473529abb40eeb6be8bc5f7faba3d08c316cb3e3\"\n+dependencies = [\n+ \"log\",\n+ \"pest\",\n+ \"pest_derive\",\n+ \"quick-error 2.0.1\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"handlebars\"\n version = \"4.3.3\"\n@@ -1795,7 +1828,7 @@ version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n dependencies = [\n- \"quick-error\",\n+ \"quick-error 1.2.3\",\n ]\n \n [[package]]\n@@ -1967,7 +2000,7 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -1991,19 +2024,19 @@ dependencies = [\n \n [[package]]\n name = \"io-lifetimes\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e394faa0efb47f9f227f1cd89978f854542b318a6f64fa695489c9c993056656\"\n+checksum = \"46112a93252b123d31a119a8d1a1ac19deac4fac6e0e8b0df58f0d4e5870e63c\"\n dependencies = [\n  \"libc\",\n  \"windows-sys\",\n ]\n \n [[package]]\n name = \"is-terminal\"\n-version = \"0.4.0\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aae5bc6e2eb41c9def29a3e0f1306382807764b9b53112030eff57435667352d\"\n+checksum = \"28dfb6c8100ccc63462345b67d1bbc3679177c75ee4bf59bf29c8b1d110b8189\"\n dependencies = [\n  \"hermit-abi 0.2.6\",\n  \"io-lifetimes\",\n@@ -2151,7 +2184,7 @@ version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c0cf036d15402bea3c5d4de17b3fce76b3e4a56ebc1f577be0e7a72f7c607cf0\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"winapi\",\n ]\n \n@@ -2222,9 +2255,9 @@ dependencies = [\n \n [[package]]\n name = \"linux-raw-sys\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f9f08d8963a6c613f4b1a78f4f4a4dbfadf8e6545b2d72861731e4858b8b47f\"\n+checksum = \"f051f77a7c8e6957c0696eac88f26b0117e54f52d3fc682ab19397a8812846a4\"\n \n [[package]]\n name = \"litemap\"\n@@ -2252,7 +2285,7 @@ version = \"0.4.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"51b9bbe6c47d51fc3e1a9b945965946b4c44142ab8792c50835a980d362c2710\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -2329,12 +2362,12 @@ dependencies = [\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.9.0\",\n- \"handlebars\",\n+ \"handlebars 4.3.3\",\n  \"lazy_static\",\n  \"log\",\n  \"memchr\",\n  \"opener\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n@@ -2344,6 +2377,19 @@ dependencies = [\n  \"topological-sort\",\n ]\n \n+[[package]]\n+name = \"mdman\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"handlebars 3.5.5\",\n+ \"pretty_assertions\",\n+ \"pulldown-cmark 0.7.2\",\n+ \"same-file\",\n+ \"serde_json\",\n+ \"url\",\n+]\n+\n [[package]]\n name = \"measureme\"\n version = \"10.1.0\"\n@@ -2379,9 +2425,9 @@ dependencies = [\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.6.5\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n+checksum = \"5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -2434,7 +2480,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"colored\",\n  \"env_logger 0.9.0\",\n- \"getrandom 0.2.0\",\n+ \"getrandom 0.2.8\",\n  \"lazy_static\",\n  \"libc\",\n  \"libffi\",\n@@ -2530,7 +2576,7 @@ version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5a518809ac14b25b569624d0268eba1e88498f71615893dca57982bed7621abb\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n@@ -2556,7 +2602,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0c7ae222234c30df141154f159066c5093ff73b63204dcda7121eb082fc56a95\"\n dependencies = [\n  \"bitflags\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"foreign-types\",\n  \"libc\",\n  \"once_cell\",\n@@ -2618,6 +2664,15 @@ version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n \n+[[package]]\n+name = \"output_vt100\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"628223faebab4e3e40667ee0b2336d34a5b960ff60ea743ddfdbcf7770bcfb66\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"owo-colors\"\n version = \"3.4.0\"\n@@ -2626,11 +2681,11 @@ checksum = \"decf7381921fea4dcb2549c5667eda59b3ec297ab7e2b5fc33eac69d2e7da87b\"\n \n [[package]]\n name = \"packed_simd_2\"\n-version = \"0.3.4\"\n+version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3278e0492f961fd4ae70909f56b2723a7e8d01a228427294e19cdfdebda89a17\"\n+checksum = \"a1914cd452d8fccd6f9db48147b29fd4ae05bea9dc5d9ad578509f72415de282\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"libm\",\n ]\n \n@@ -2639,7 +2694,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2650,7 +2705,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2684,7 +2739,7 @@ version = \"0.8.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"instant\",\n  \"libc\",\n  \"redox_syscall\",\n@@ -2698,7 +2753,7 @@ version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n@@ -2859,6 +2914,18 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \n+[[package]]\n+name = \"pretty_assertions\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n+dependencies = [\n+ \"ansi_term 0.11.0\",\n+ \"ctor\",\n+ \"difference\",\n+ \"output_vt100\",\n+]\n+\n [[package]]\n name = \"pretty_env_logger\"\n version = \"0.4.0\"\n@@ -2934,6 +3001,17 @@ dependencies = [\n  \"cc\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n+dependencies = [\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -2957,6 +3035,12 @@ version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0\"\n \n+[[package]]\n+name = \"quick-error\"\n+version = \"2.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a993555f31e5a609f617c12db6250dedcac1b0a85076912c436e6fc9b2c8e6a3\"\n+\n [[package]]\n name = \"quine-mc_cluskey\"\n version = \"0.2.4\"\n@@ -3031,7 +3115,7 @@ version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"34cf66eb183df1c5876e2dcf6b13d57340741e8dc255b48e40a26de954d06ae7\"\n dependencies = [\n- \"getrandom 0.2.0\",\n+ \"getrandom 0.2.8\",\n ]\n \n [[package]]\n@@ -3100,7 +3184,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"528532f3d801c87aec9def2add9ca802fe569e44a544afe633765267840abe64\"\n dependencies = [\n- \"getrandom 0.2.0\",\n+ \"getrandom 0.2.8\",\n  \"redox_syscall\",\n ]\n \n@@ -3591,7 +3675,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"bitflags\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"ena\",\n  \"indexmap\",\n  \"jobserver\",\n@@ -4039,6 +4123,7 @@ dependencies = [\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n+ \"rustc_error_messages\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_graphviz\",\n@@ -4070,6 +4155,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -4374,7 +4460,7 @@ dependencies = [\n name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\",\n@@ -4429,6 +4515,12 @@ version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"598f48ce2a421542b3e64828aa742b687cc1b91d2f96591cfdb7ac5988cd6366\"\n \n+[[package]]\n+name = \"rustc_tools_util\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ba09476327c4b70ccefb6180f046ef588c26a24cf5d269a9feba316eb4f029f\"\n+\n [[package]]\n name = \"rustc_trait_selection\"\n version = \"0.0.0\"\n@@ -4539,7 +4631,7 @@ dependencies = [\n  \"itertools\",\n  \"minifier\",\n  \"once_cell\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"rayon\",\n  \"regex\",\n  \"rustdoc-json-types\",\n@@ -4777,7 +4869,7 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"028f48d513f9678cda28f6e4064755b3fbb2af6acd672f2c209b62323f7aea0f\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"cpufeatures\",\n  \"digest\",\n ]\n@@ -4788,7 +4880,7 @@ version = \"0.10.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"99c3bd8169c58782adad9290a9af5939994036b76187f7b4f0e6de91dbbfc0ec\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"cpufeatures\",\n  \"digest\",\n ]\n@@ -4930,7 +5022,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c886bd4480155fd3ef527d45e9ac8dd7118a898a46530b7b94c3e21866259fce\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"libc\",\n  \"psm\",\n  \"winapi\",\n@@ -4948,7 +5040,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -4972,7 +5064,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -5079,7 +5171,7 @@ version = \"3.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5cdb1ef4eaeeaddc8fbd371e5017057064af0911902ef36b39801f67cc6d79e4\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"fastrand\",\n  \"libc\",\n  \"redox_syscall\",\n@@ -5132,7 +5224,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -5148,7 +5240,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0639d10d8f4615f223a57275cf40f9bdb7cfbb806bcb7f7cc56e3beb55a576eb\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"getopts\",\n  \"libc\",\n  \"num_cpus\",\n@@ -5315,7 +5407,7 @@ version = \"0.1.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"pin-project-lite\",\n  \"tracing-attributes\",\n  \"tracing-core\",\n@@ -5369,7 +5461,7 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"245da694cc7fc4729f3f418b304cb57789f1bed2a78c575407ab8a23f53cb4d3\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.12.1\",\n  \"lazy_static\",\n  \"matchers\",\n  \"parking_lot 0.11.2\",\n@@ -5388,7 +5480,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3ce989c9962c7f61fe084dd4a230eec784649dfc2392467c790007c3a6e134e7\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.12.1\",\n  \"atty\",\n  \"tracing-core\",\n  \"tracing-log\",\n@@ -5401,7 +5493,7 @@ version = \"1.6.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"rand 0.8.5\",\n  \"static_assertions\",\n ]\n@@ -5648,7 +5740,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -5685,7 +5777,7 @@ version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n dependencies = [\n- \"getrandom 0.2.0\",\n+ \"getrandom 0.2.8\",\n ]\n \n [[package]]"}, {"sha": "1cec4a84480c43a4215d10ea2fc3f3b3d227f580", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -25,6 +25,8 @@ members = [\n   \"src/tools/cargo/crates/credential/cargo-credential-1password\",\n   \"src/tools/cargo/crates/credential/cargo-credential-macos-keychain\",\n   \"src/tools/cargo/crates/credential/cargo-credential-wincred\",\n+  \"src/tools/cargo/crates/mdman\",\n+  # \"src/tools/cargo/crates/resolver-tests\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\","}, {"sha": "4582d3c6badf99491254930d6e7c0f3ee6d7cff8", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -774,6 +774,18 @@ impl Integer {\n         }\n     }\n \n+    /// Returns the largest signed value that can be represented by this Integer.\n+    #[inline]\n+    pub fn signed_max(self) -> i128 {\n+        match self {\n+            I8 => i8::MAX as i128,\n+            I16 => i16::MAX as i128,\n+            I32 => i32::MAX as i128,\n+            I64 => i64::MAX as i128,\n+            I128 => i128::MAX,\n+        }\n+    }\n+\n     /// Finds the smallest Integer type which can represent the signed value.\n     #[inline]\n     pub fn fit_signed(x: i128) -> Integer {"}, {"sha": "31596a1e9bf889ca1f684fcca0c20673add5c558", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -2554,10 +2554,9 @@ pub enum AttrStyle {\n }\n \n rustc_index::newtype_index! {\n-    pub struct AttrId {\n-        ENCODABLE = custom\n-        DEBUG_FORMAT = \"AttrId({})\"\n-    }\n+    #[custom_encodable]\n+    #[debug_format = \"AttrId({})]\"]\n+    pub struct AttrId {}\n }\n \n impl<S: Encoder> Encodable<S> for AttrId {"}, {"sha": "daa82996b3d11f52a9fead380c10c879ac7e9896", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -8,9 +8,8 @@ rustc_index::newtype_index! {\n     /// This is later turned into [`DefId`] and `HirId` for the HIR.\n     ///\n     /// [`DefId`]: rustc_span::def_id::DefId\n-    pub struct NodeId {\n-        DEBUG_FORMAT = \"NodeId({})\"\n-    }\n+    #[debug_format = \"NodeId({})\"]\n+    pub struct NodeId {}\n }\n \n rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeMapEntry, NodeId);"}, {"sha": "275ed02c2b9f7fa031184ac794f871902a49d9d1", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -51,7 +51,7 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         if i != 0 || j != lines.len() { Some((i, j)) } else { None }\n     }\n \n-    fn get_horizontal_trim<'a>(lines: &'a [&str], kind: CommentKind) -> Option<String> {\n+    fn get_horizontal_trim(lines: &[&str], kind: CommentKind) -> Option<String> {\n         let mut i = usize::MAX;\n         let mut first = true;\n "}, {"sha": "3634e6e47ce12e220d3b64f2fa4e6be9eb8b004d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n@@ -596,38 +596,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n-        // Resume argument type, which should be `&mut Context<'_>`.\n-        // NOTE: Using the `'static` lifetime here is technically cheating.\n-        // The `Future::poll` argument really is `&'a mut Context<'b>`, but we cannot\n-        // express the fact that we are not storing it across yield-points yet,\n-        // and we would thus run into lifetime errors.\n-        // See <https://github.com/rust-lang/rust/issues/68923>.\n-        // Our lowering makes sure we are not mis-using the `_task_context` input type\n-        // in the sense that we are indeed not using it across yield points. We\n-        // get a fresh `&mut Context` for each resume / call of `Future::poll`.\n-        // This \"cheating\" was previously done with a `ResumeTy` that contained a raw\n-        // pointer, and a `get_context` accessor that pulled the `Context` lifetimes\n-        // out of thin air.\n-        let context_lifetime_ident = Ident::with_dummy_span(kw::StaticLifetime);\n-        let context_lifetime = self.arena.alloc(hir::Lifetime {\n-            hir_id: self.next_id(),\n-            ident: context_lifetime_ident,\n-            res: hir::LifetimeName::Static,\n-        });\n-        let context_path =\n-            hir::QPath::LangItem(hir::LangItem::Context, self.lower_span(span), None);\n-        let context_ty = hir::MutTy {\n-            ty: self.arena.alloc(hir::Ty {\n-                hir_id: self.next_id(),\n-                kind: hir::TyKind::Path(context_path),\n-                span: self.lower_span(span),\n-            }),\n-            mutbl: hir::Mutability::Mut,\n-        };\n+        // Resume argument type: `ResumeTy`\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+        let resume_ty = hir::QPath::LangItem(hir::LangItem::ResumeTy, unstable_span, None);\n         let input_ty = hir::Ty {\n             hir_id: self.next_id(),\n-            kind: hir::TyKind::Rptr(context_lifetime, context_ty),\n-            span: self.lower_span(span),\n+            kind: hir::TyKind::Path(resume_ty),\n+            span: unstable_span,\n         };\n \n         // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n@@ -680,15 +656,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::ExprKind::Closure(c)\n         };\n \n-        let track_caller = self\n-            .attrs\n-            .get(&outer_hir_id.local_id)\n-            .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n-\n         let hir_id = self.lower_node_id(closure_node_id);\n         let unstable_span =\n             self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-        if track_caller {\n+\n+        if self.tcx.features().closure_track_caller\n+            && let Some(attrs) = self.attrs.get(&outer_hir_id.local_id)\n+            && attrs.into_iter().any(|attr| attr.has_name(sym::track_caller))\n+        {\n             self.lower_attrs(\n                 hir_id,\n                 &[Attribute {\n@@ -731,7 +706,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ///     mut __awaitee => loop {\n     ///         match unsafe { ::std::future::Future::poll(\n     ///             <::std::pin::Pin>::new_unchecked(&mut __awaitee),\n-    ///             task_context,\n+    ///             ::std::future::get_context(task_context),\n     ///         ) } {\n     ///             ::std::task::Poll::Ready(result) => break result,\n     ///             ::std::task::Poll::Pending => {}\n@@ -772,7 +747,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // unsafe {\n         //     ::std::future::Future::poll(\n         //         ::std::pin::Pin::new_unchecked(&mut __awaitee),\n-        //         task_context,\n+        //         ::std::future::get_context(task_context),\n         //     )\n         // }\n         let poll_expr = {\n@@ -790,10 +765,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 arena_vec![self; ref_mut_awaitee],\n                 Some(expr_hir_id),\n             );\n+            let get_context = self.expr_call_lang_item_fn_mut(\n+                gen_future_span,\n+                hir::LangItem::GetContext,\n+                arena_vec![self; task_context],\n+                Some(expr_hir_id),\n+            );\n             let call = self.expr_call_lang_item_fn(\n                 span,\n                 hir::LangItem::FuturePoll,\n-                arena_vec![self; new_unchecked, task_context],\n+                arena_vec![self; new_unchecked, get_context],\n                 Some(expr_hir_id),\n             );\n             self.arena.alloc(self.expr_unsafe(call))"}, {"sha": "9d4c2900eaf41aa12e6edb21621132a071f88374", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,6 +1,6 @@\n use super::errors::{InvalidAbi, InvalidAbiSuggestion, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n-use super::{Arena, AstOwner, ImplTraitContext, ImplTraitPosition};\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n \n use rustc_ast::ptr::P;\n@@ -24,7 +24,6 @@ use thin_vec::ThinVec;\n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) tcx: TyCtxt<'hir>,\n     pub(super) resolver: &'a mut ResolverAstLowering,\n-    pub(super) ast_arena: &'a Arena<'static>,\n     pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n@@ -60,7 +59,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             tcx: self.tcx,\n             resolver: self.resolver,\n             arena: self.tcx.hir_arena,\n-            ast_arena: self.ast_arena,\n \n             // HirId handling.\n             bodies: Vec::new(),"}, {"sha": "db2527a200c329b7190abdb5fea08f86f13ca725", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -42,7 +42,6 @@ extern crate tracing;\n \n use crate::errors::{AssocTyParentheses, AssocTyParenthesesSub, MisplacedImplTrait, TraitFnAsync};\n \n-use rustc_arena::declare_arena;\n use rustc_ast::ptr::P;\n use rustc_ast::visit;\n use rustc_ast::{self as ast, *};\n@@ -94,13 +93,6 @@ struct LoweringContext<'a, 'hir> {\n     /// Used to allocate HIR nodes.\n     arena: &'hir hir::Arena<'hir>,\n \n-    /// Used to allocate temporary AST nodes for use during lowering.\n-    /// This allows us to create \"fake\" AST -- these nodes can sometimes\n-    /// be allocated on the stack, but other times we need them to live longer\n-    /// than the current stack frame, so they can be collected into vectors\n-    /// and things like that.\n-    ast_arena: &'a Arena<'static>,\n-\n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n     /// Attributes inside the owner being lowered.\n@@ -146,15 +138,6 @@ struct LoweringContext<'a, 'hir> {\n     generics_def_id_map: Vec<FxHashMap<LocalDefId, LocalDefId>>,\n }\n \n-declare_arena!([\n-    [] tys: rustc_ast::Ty,\n-    [] aba: rustc_ast::AngleBracketedArgs,\n-    [] ptr: rustc_ast::PolyTraitRef,\n-    // This _marker field is needed because `declare_arena` creates `Arena<'tcx>` and we need to\n-    // use `'tcx`. If we don't have this we get a compile error.\n-    [] _marker: std::marker::PhantomData<&'tcx ()>,\n-]);\n-\n trait ResolverAstLoweringExt {\n     fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n@@ -431,7 +414,7 @@ fn compute_hir_hash(\n     })\n }\n \n-pub fn lower_to_hir<'hir>(tcx: TyCtxt<'hir>, (): ()) -> hir::Crate<'hir> {\n+pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n     let krate = tcx.untracked_crate.steal();\n     let mut resolver = tcx.resolver_for_lowering(()).steal();\n@@ -442,13 +425,10 @@ pub fn lower_to_hir<'hir>(tcx: TyCtxt<'hir>, (): ()) -> hir::Crate<'hir> {\n         tcx.definitions_untracked().def_index_count(),\n     );\n \n-    let ast_arena = Arena::default();\n-\n     for def_id in ast_index.indices() {\n         item::ItemLowerer {\n             tcx,\n             resolver: &mut resolver,\n-            ast_arena: &ast_arena,\n             ast_index: &ast_index,\n             owners: &mut owners,\n         }\n@@ -620,7 +600,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.impl_trait_defs = current_impl_trait_defs;\n         self.impl_trait_bounds = current_impl_trait_bounds;\n \n-        debug_assert!(self.children.iter().find(|(id, _)| id == &def_id).is_none());\n+        debug_assert!(!self.children.iter().any(|(id, _)| id == &def_id));\n         self.children.push((def_id, hir::MaybeOwner::Owner(info)));\n     }\n \n@@ -1001,8 +981,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 GenericArgs::Parenthesized(data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n-                    let aba = self.ast_arena.aba.alloc(data.as_angle_bracketed_args());\n-                    self.lower_angle_bracketed_parameter_data(aba, ParamMode::Explicit, itctx).0\n+                    self.lower_angle_bracketed_parameter_data(\n+                        &data.as_angle_bracketed_args(),\n+                        ParamMode::Explicit,\n+                        itctx,\n+                    )\n+                    .0\n                 }\n             };\n             gen_args_ctor.into_generic_args(self)\n@@ -1067,13 +1051,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let node_id = this.next_node_id();\n-                        let ty = this.ast_arena.tys.alloc(Ty {\n-                            id: node_id,\n-                            kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                            span: this.lower_span(constraint.span),\n-                            tokens: None,\n-                        });\n-                        let ty = this.lower_ty(ty, itctx);\n+                        let ty = this.lower_ty(\n+                            &Ty {\n+                                id: node_id,\n+                                kind: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n+                                span: this.lower_span(constraint.span),\n+                                tokens: None,\n+                            },\n+                            itctx,\n+                        );\n \n                         hir::TypeBindingKind::Equality { term: ty.into() }\n                     })\n@@ -1217,13 +1203,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n         {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n-                let poly_trait_ref = this.ast_arena.ptr.alloc(PolyTraitRef {\n-                    bound_generic_params: vec![],\n-                    trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n-                    span: t.span\n-                });\n                 let bound = this.lower_poly_trait_ref(\n-                    poly_trait_ref,\n+                    &PolyTraitRef {\n+                        bound_generic_params: vec![],\n+                        trait_ref: TraitRef { path: path.clone(), ref_id: t.id },\n+                        span: t.span\n+                    },\n                     itctx,\n                 );\n                 let bounds = this.arena.alloc_from_iter([bound]);"}, {"sha": "55ea12d25ea2ceead70b4c4e6c4de49548a84852", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -42,7 +42,6 @@ enum SelfSemantic {\n /// What is the context that prevents using `~const`?\n enum DisallowTildeConstContext<'a> {\n     TraitObject,\n-    ImplTrait,\n     Fn(FnKind<'a>),\n }\n \n@@ -187,11 +186,7 @@ impl<'a> AstValidator<'a> {\n \n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n-        if outer.is_some() {\n-            self.with_banned_tilde_const(DisallowTildeConstContext::ImplTrait, f);\n-        } else {\n-            f(self);\n-        }\n+        f(self);\n         self.outer_impl_trait = old;\n     }\n \n@@ -1384,7 +1379,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n                     match reason {\n                         DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::ImplTrait => err.note(\"`impl Trait`s cannot have `~const` trait bounds\"),\n                         DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n                         DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n                     };"}, {"sha": "c780d047992cdb994c709277bbe81443bc3b45e9", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -148,7 +148,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.graph.next_constraints[p];\n \n-            Some(self.constraints[p].clone())\n+            Some(self.constraints[p])\n         } else if let Some(next_static_idx) = self.next_static_idx {\n             self.next_static_idx = if next_static_idx == (self.graph.first_constraints.len() - 1) {\n                 None"}, {"sha": "1f0b8adeaf16c1ecbe31529b0f0ea6efe0ec5371", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -115,13 +115,11 @@ impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    pub struct OutlivesConstraintIndex {\n-        DEBUG_FORMAT = \"OutlivesConstraintIndex({})\"\n-    }\n+    #[debug_format = \"OutlivesConstraintIndex({})\"]\n+    pub struct OutlivesConstraintIndex {}\n }\n \n rustc_index::newtype_index! {\n-    pub struct ConstraintSccIndex {\n-        DEBUG_FORMAT = \"ConstraintSccIndex({})\"\n-    }\n+    #[debug_format = \"ConstraintSccIndex({})\"]\n+    pub struct ConstraintSccIndex {}\n }"}, {"sha": "becc04bbdab0d54fd3f54c43853c2aa3b72ee7a9", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -28,10 +28,10 @@ pub use super::{\n ///     that shows how to do this at `src/test/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n-pub fn get_body_with_borrowck_facts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn get_body_with_borrowck_facts(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> BodyWithBorrowckFacts<'tcx> {\n+) -> BodyWithBorrowckFacts<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n     let input_body: &Body<'_> = &input_body.borrow();"}, {"sha": "8c4885770ad37b6d009eb450d82a7e2b47a4d057", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -108,9 +108,8 @@ impl_visitable! {\n }\n \n rustc_index::newtype_index! {\n-    pub struct BorrowIndex {\n-        DEBUG_FORMAT = \"bw{}\"\n-    }\n+    #[debug_format = \"bw{}\"]\n+    pub struct BorrowIndex {}\n }\n \n /// `Borrows` stores the data used in the analyses that track the flow"}, {"sha": "8d5c5a7124f88aeee0e472d5557d80b74cbea1ad", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -649,7 +649,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if !assign_value.is_empty() {\n             err.span_suggestion_verbose(\n                 sugg_span.shrink_to_hi(),\n-                format!(\"consider assigning a value\"),\n+                \"consider assigning a value\",\n                 format!(\" = {}\", assign_value),\n                 Applicability::MaybeIncorrect,\n             );"}, {"sha": "00f5e8a83972f9c6456c51635867e2a7bfa59227", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -270,7 +270,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 for extra in extra_info {\n                     match extra {\n                         ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n-                            err.span_note(*span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                            err.span_note(*span, \"due to current limitations in the borrow checker, this implies a `'static` lifetime\");\n                         }\n                     }\n                 }"}, {"sha": "2c4d953f011fc013c8058fc17506cecb12e76832", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::{Body, Local, Location};\n /// Find all uses of (including assignments to) a [`Local`].\n ///\n /// Uses `BTreeSet` so output is deterministic.\n-pub(super) fn find<'tcx>(body: &Body<'tcx>, local: Local) -> BTreeSet<Location> {\n+pub(super) fn find(body: &Body<'_>, local: Local) -> BTreeSet<Location> {\n     let mut visitor = AllLocalUsesVisitor { for_local: local, uses: BTreeSet::default() };\n     visitor.visit_body(body);\n     visitor.uses"}, {"sha": "bcc8afbfd952d15763d32cd6239c5c129ee8f35b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -18,11 +18,11 @@ use rustc_infer::infer::{\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n+use rustc_middle::ty::{Region, TyCtxt};\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::borrowck_errors;\n use crate::session_diagnostics::{\n@@ -70,7 +70,25 @@ impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n ///\n /// Usually we expect this to either be empty or contain a small number of items, so we can avoid\n /// allocation most of the time.\n-pub(crate) type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n+pub(crate) struct RegionErrors<'tcx>(Vec<RegionErrorKind<'tcx>>, TyCtxt<'tcx>);\n+\n+impl<'tcx> RegionErrors<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self(vec![], tcx)\n+    }\n+    #[track_caller]\n+    pub fn push(&mut self, val: impl Into<RegionErrorKind<'tcx>>) {\n+        let val = val.into();\n+        self.1.sess.delay_span_bug(DUMMY_SP, \"{val:?}\");\n+        self.0.push(val);\n+    }\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+    pub fn into_iter(self) -> impl Iterator<Item = RegionErrorKind<'tcx>> {\n+        self.0.into_iter()\n+    }\n+}\n \n #[derive(Clone, Debug)]\n pub(crate) enum RegionErrorKind<'tcx> {\n@@ -472,7 +490,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         for extra in extra_info {\n             match extra {\n                 ExtraConstraintInfo::PlaceholderFromPredicate(span) => {\n-                    diag.span_note(span, format!(\"due to current limitations in the borrow checker, this implies a `'static` lifetime\"));\n+                    diag.span_note(span, \"due to current limitations in the borrow checker, this implies a `'static` lifetime\");\n                 }\n             }\n         }"}, {"sha": "168b798788b4c747c7fad8e4db5337b5f36fceaf", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -124,10 +124,7 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx BorrowCheckResult<'tcx> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n \n@@ -2059,12 +2056,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<InitIndex> {\n         let mpi = self.move_data.rev_lookup.find_local(local);\n         let ii = &self.move_data.init_path_map[mpi];\n-        for &index in ii {\n-            if flow_state.ever_inits.contains(index) {\n-                return Some(index);\n-            }\n-        }\n-        None\n+        ii.into_iter().find(|&&index| flow_state.ever_inits.contains(index)).copied()\n     }\n \n     /// Adds the place into the used mutable variables set"}, {"sha": "288b7d85be2d41d4d5e89fe1eab90f597f1668bd", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -20,9 +20,8 @@ pub struct LocationTable {\n }\n \n rustc_index::newtype_index! {\n-    pub struct LocationIndex {\n-        DEBUG_FORMAT = \"LocationIndex({})\"\n-    }\n+    #[debug_format = \"LocationIndex({})\"]\n+    pub struct LocationIndex {}\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "b63e286676ff48fc2129344547850f320da554d0", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -55,9 +55,8 @@ pub(crate) struct NllMemberConstraint<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    pub(crate) struct NllMemberConstraintIndex {\n-        DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n-    }\n+    #[debug_format = \"MemberConstraintIndex({})\"]\n+    pub(crate) struct NllMemberConstraintIndex {}\n }\n \n impl Default for MemberConstraintSet<'_, ty::RegionVid> {"}, {"sha": "308f6e19a73e86b2277985a092a5748a77827bd2", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -562,7 +562,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mir_def_id = body.source.def_id();\n         self.propagate_constraints(body);\n \n-        let mut errors_buffer = RegionErrors::new();\n+        let mut errors_buffer = RegionErrors::new(infcx.tcx);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -831,7 +831,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if self.eval_verify_bound(\n                 infcx,\n                 param_env,\n-                body,\n                 generic_ty,\n                 type_test.lower_bound,\n                 &type_test.verify_bound,\n@@ -962,14 +961,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_verify_bound(\n-                infcx,\n-                param_env,\n-                body,\n-                generic_ty,\n-                ur,\n-                &type_test.verify_bound,\n-            ) {\n+            if self.eval_verify_bound(infcx, param_env, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -1190,7 +1182,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n@@ -1213,25 +1204,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n-                self.eval_verify_bound(\n-                    infcx,\n-                    param_env,\n-                    body,\n-                    generic_ty,\n-                    lower_bound,\n-                    verify_bound,\n-                )\n+                self.eval_verify_bound(infcx, param_env, generic_ty, lower_bound, verify_bound)\n             }),\n \n             VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n-                self.eval_verify_bound(\n-                    infcx,\n-                    param_env,\n-                    body,\n-                    generic_ty,\n-                    lower_bound,\n-                    verify_bound,\n-                )\n+                self.eval_verify_bound(infcx, param_env, generic_ty, lower_bound, verify_bound)\n             }),\n         }\n     }\n@@ -1670,26 +1647,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n         debug!(\"check_bound_universal_region: longer_fr_scc={:?}\", longer_fr_scc,);\n \n-        // If we have some bound universal region `'a`, then the only\n-        // elements it can contain is itself -- we don't know anything\n-        // else about it!\n-        let Some(error_element) = ({\n-            self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n-                RegionElement::Location(_) => true,\n-                RegionElement::RootUniversalRegion(_) => true,\n-                RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n-            })\n-        }) else {\n-            return;\n-        };\n-        debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n+        for error_element in self.scc_values.elements_contained_in(longer_fr_scc) {\n+            match error_element {\n+                RegionElement::Location(_) | RegionElement::RootUniversalRegion(_) => {}\n+                // If we have some bound universal region `'a`, then the only\n+                // elements it can contain is itself -- we don't know anything\n+                // else about it!\n+                RegionElement::PlaceholderRegion(placeholder1) => {\n+                    if placeholder == placeholder1 {\n+                        continue;\n+                    }\n+                }\n+            }\n \n-        // Find the region that introduced this `error_element`.\n-        errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n-            longer_fr,\n-            error_element,\n-            placeholder,\n-        });\n+            errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n+                longer_fr,\n+                error_element,\n+                placeholder,\n+            });\n+\n+            // Stop after the first error, it gets too noisy otherwise, and does not provide more information.\n+            break;\n+        }\n+        debug!(\"check_bound_universal_region: all bounds satisfied\");\n     }\n \n     #[instrument(level = \"debug\", skip(self, infcx, errors_buffer))]"}, {"sha": "c3dfeedc205f7e8e4a4841fea994ea2abf79070f", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -90,12 +90,14 @@ impl RegionValueElements {\n rustc_index::newtype_index! {\n     /// A single integer representing a `Location` in the MIR control-flow\n     /// graph. Constructed efficiently from `RegionValueElements`.\n-    pub struct PointIndex { DEBUG_FORMAT = \"PointIndex({})\" }\n+    #[debug_format = \"PointIndex({})\"]\n+    pub struct PointIndex {}\n }\n \n rustc_index::newtype_index! {\n     /// A single integer representing a `ty::Placeholder`.\n-    pub struct PlaceholderIndex { DEBUG_FORMAT = \"PlaceholderIndex({})\" }\n+    #[debug_format = \"PlaceholderIndex({})\"]\n+    pub struct PlaceholderIndex {}\n }\n \n /// An individual element in a region value -- the value of a"}, {"sha": "09cf870bcf35af780f724bdb8a4ea55a6fca3ccd", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -85,7 +85,7 @@ impl UniversalRegionRelations<'_> {\n     /// outlives `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we return all of them.\n-    pub(crate) fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n+    pub(crate) fn non_local_upper_bounds(&self, fr: RegionVid) -> Vec<RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n         let res = self.non_local_bounds(&self.inverse_outlives, fr);\n         assert!(!res.is_empty(), \"can't find an upper bound!?\");\n@@ -148,9 +148,9 @@ impl UniversalRegionRelations<'_> {\n     /// Helper for `non_local_upper_bounds` and `non_local_lower_bounds`.\n     /// Repeatedly invokes `postdom_parent` until we find something that is not\n     /// local. Returns `None` if we never do so.\n-    fn non_local_bounds<'a>(\n+    fn non_local_bounds(\n         &self,\n-        relation: &'a TransitiveRelation<RegionVid>,\n+        relation: &TransitiveRelation<RegionVid>,\n         fr0: RegionVid,\n     ) -> Vec<RegionVid> {\n         // This method assumes that `fr0` is one of the universally"}, {"sha": "8023ef60d205290478d37c467291d88c17ac093b", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -46,7 +46,7 @@ struct Appearance {\n }\n \n rustc_index::newtype_index! {\n-    pub struct AppearanceIndex { .. }\n+    pub struct AppearanceIndex {}\n }\n \n impl vll::LinkElem for Appearance {"}, {"sha": "247607ff29e20717196020ee862ae279fbb268b6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let locations = location.to_locations();\n         for constraint in constraints.outlives().iter() {\n-            let mut constraint = constraint.clone();\n+            let mut constraint = *constraint;\n             constraint.locations = locations;\n             if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n@@ -1153,27 +1153,31 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n+        trace!(?annotated_type);\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n \n         let tcx = self.infcx.tcx;\n \n         for proj in &user_ty.projs {\n+            if let ty::Alias(ty::Opaque, ..) = curr_projected_ty.ty.kind() {\n+                // There is nothing that we can compare here if we go through an opaque type.\n+                // We're always in its defining scope as we can otherwise not project through\n+                // it, so we're constraining it anyways.\n+                return Ok(());\n+            }\n             let projected_ty = curr_projected_ty.projection_ty_core(\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, _| {\n+                |this, field, ()| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n                 |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n-        debug!(\n-            \"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n-            user_ty.base, annotated_type, user_ty.projs, curr_projected_ty\n-        );\n+        trace!(?curr_projected_ty);\n \n         let ty = curr_projected_ty.ty;\n         self.relate_types(ty, v.xform(ty::Variance::Contravariant), a, locations, category)?;"}, {"sha": "925392b500ad27196d33e92c7a81b475762a33a0", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -352,7 +352,7 @@ pub fn parse_asm_args<'a>(\n ///\n /// This function must be called immediately after the option token is parsed.\n /// Otherwise, the suggestion will be incorrect.\n-fn err_duplicate_option<'a>(p: &mut Parser<'a>, symbol: Symbol, span: Span) {\n+fn err_duplicate_option(p: &mut Parser<'_>, symbol: Symbol, span: Span) {\n     let mut err = p\n         .sess\n         .span_diagnostic"}, {"sha": "f8761653bf5b7d80dde81339468a465eb1f0cfb3", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -35,7 +35,7 @@ pub fn expand(\n             (item, true, ecx.with_def_site_ctxt(ty.span))\n         } else {\n             ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-            return vec![orig_item.clone()]\n+            return vec![orig_item];\n         };\n \n     // Generate a bunch of new items using the AllocFnFactory"}, {"sha": "b88de224675379a24f1f78e50c9ea9f0fc7f60a1", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -262,6 +262,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //          use proc_macro::bridge::client::ProcMacro;\n //\n //          #[rustc_proc_macro_decls]\n+//          #[used]\n //          #[allow(deprecated)]\n //          static DECLS: &[ProcMacro] = &[\n //              ProcMacro::custom_derive($name_trait1, &[], ::$name1);\n@@ -364,6 +365,7 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n         )\n         .map(|mut i| {\n             i.attrs.push(cx.attr_word(sym::rustc_proc_macro_decls, span));\n+            i.attrs.push(cx.attr_word(sym::used, span));\n             i.attrs.push(cx.attr_nested_word(sym::allow, sym::deprecated, span));\n             i\n         });"}, {"sha": "729ae4071e2008b53e1e7276484ab8fb4e021ceb", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -239,8 +239,7 @@ pub fn expand_test_or_bench(\n             cx.attr_nested_word(sym::cfg, sym::test, attr_sp),\n             // #[rustc_test_marker = \"test_case_sort_key\"]\n             cx.attr_name_value_str(sym::rustc_test_marker, test_path_symbol, attr_sp),\n-        ]\n-        .into(),\n+        ],\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,"}, {"sha": "e4ac89a7bec6b245d17cf41828f392a76df8e4dc", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -644,7 +644,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         }\n-        sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n+        sym::assert_inhabited | sym::assert_zero_valid | sym::assert_mem_uninitialized_valid => {\n             intrinsic_args!(fx, args => (); intrinsic);\n \n             let layout = fx.layout_of(substs.type_at(0));\n@@ -673,7 +673,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_uninit_valid && !fx.tcx.permits_uninit_init(layout) {\n+            if intrinsic == sym::assert_mem_uninitialized_valid\n+                && !fx.tcx.permits_uninit_init(layout)\n+            {\n                 with_no_trimmed_paths!({\n                     crate::base::codegen_panic(\n                         fx,"}, {"sha": "d464bd3d12a07a57fe6304f213018dd3777b23d8", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -52,7 +52,7 @@ pub fn linkage_to_gcc(linkage: Linkage) -> FunctionType {\n     }\n }\n \n-pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_integers: bool) -> (ModuleCodegen<GccContext>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n "}, {"sha": "0afc56b4494d3a237948dd508dbd4e5c00bf9cac", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -44,7 +44,7 @@ pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) ->\n     context.new_array_constructor(None, typ, &elements)\n }\n \n-pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n+pub fn type_is_pointer(typ: Type<'_>) -> bool {\n     typ.get_pointee().is_some()\n }\n "}, {"sha": "bf1da38312f7d93ed0aafc0af1d388373ec0debf", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -161,7 +161,7 @@ impl ExtraBackendMethods for GccCodegenBackend {\n         mods\n     }\n \n-    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n+    fn compile_codegen_unit(&self, tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n         base::compile_codegen_unit(tcx, cgu_name, *self.supports_128bit_integers.lock().expect(\"lock\"))\n     }\n "}, {"sha": "606f710641fc0e25a17fd6f2b598058328a1e6b4", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -144,7 +144,7 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                     // We prefer the latter because it matches the behavior of\n                     // Clang.\n                     if late && matches!(reg, InlineAsmRegOrRegClass::Reg(_)) {\n-                        constraints.push(format!(\"{}\", reg_to_llvm(reg, Some(&in_value.layout))));\n+                        constraints.push(reg_to_llvm(reg, Some(&in_value.layout)).to_string());\n                     } else {\n                         constraints.push(format!(\"{}\", op_idx[&idx]));\n                     }"}, {"sha": "487eead22b897de056ab822dbc78247244c0b4c3", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -137,6 +137,14 @@ fn instrument_function_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribu\n     }\n }\n \n+fn nojumptables_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n+    if !cx.sess().opts.unstable_opts.no_jump_tables {\n+        return None;\n+    }\n+\n+    Some(llvm::CreateAttrStringValue(cx.llcx, \"no-jump-tables\", \"true\"))\n+}\n+\n fn probestack_attr<'ll>(cx: &CodegenCx<'ll, '_>) -> Option<&'ll Attribute> {\n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer and thread sanitizer. With asan we're already protected from\n@@ -293,6 +301,7 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     // FIXME: none of these three functions interact with source level attributes.\n     to_add.extend(frame_pointer_type_attr(cx));\n     to_add.extend(instrument_function_attr(cx));\n+    to_add.extend(nojumptables_attr(cx));\n     to_add.extend(probestack_attr(cx));\n     to_add.extend(stackprotector_attr(cx));\n "}, {"sha": "6c0faf37a63ce453b906185924ccb6d420dffb09", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -425,7 +425,7 @@ fn thin_lto(\n         info!(\"going for that thin, thin LTO\");\n \n         let green_modules: FxHashMap<_, _> =\n-            cached_modules.iter().map(|&(_, ref wp)| (wp.cgu_name.clone(), wp.clone())).collect();\n+            cached_modules.iter().map(|(_, wp)| (wp.cgu_name.clone(), wp.clone())).collect();\n \n         let full_scope_len = modules.len() + serialized_modules.len() + cached_modules.len();\n         let mut thin_buffers = Vec::with_capacity(modules.len());"}, {"sha": "5bf45a81e4347cd7de59a42a80fdaaa796131bd6", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -233,8 +233,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // Set KCFI operand bundle\n         let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n         let kcfi_bundle =\n-            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n-                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+            if self.tcx.sess.is_sanitizer_kcfi_enabled() && let Some(fn_abi) = fn_abi && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n                 Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n             } else {\n                 None"}, {"sha": "d9ccba07a346a1066e93beea9981566f383b15e9", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -3,7 +3,6 @@ use crate::back::write::to_llvm_code_model;\n use crate::callee::get_fn;\n use crate::coverageinfo;\n use crate::debuginfo;\n-use crate::errors::BranchProtectionRequiresAArch64;\n use crate::llvm;\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -281,34 +280,43 @@ pub unsafe fn create_module<'ll>(\n     }\n \n     if let Some(BranchProtection { bti, pac_ret }) = sess.opts.unstable_opts.branch_protection {\n-        if sess.target.arch != \"aarch64\" {\n-            sess.emit_err(BranchProtectionRequiresAArch64);\n+        let behavior = if llvm_version >= (15, 0, 0) {\n+            llvm::LLVMModFlagBehavior::Min\n         } else {\n+            llvm::LLVMModFlagBehavior::Error\n+        };\n+\n+        if sess.target.arch == \"aarch64\" {\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"branch-target-enforcement\\0\".as_ptr().cast(),\n                 bti.into(),\n             );\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address\\0\".as_ptr().cast(),\n                 pac_ret.is_some().into(),\n             );\n             let pac_opts = pac_ret.unwrap_or(PacRet { leaf: false, key: PAuthKey::A });\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address-all\\0\".as_ptr().cast(),\n                 pac_opts.leaf.into(),\n             );\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n-                llvm::LLVMModFlagBehavior::Error,\n+                behavior,\n                 \"sign-return-address-with-bkey\\0\".as_ptr().cast(),\n                 u32::from(pac_opts.key == PAuthKey::B),\n             );\n+        } else {\n+            bug!(\n+                \"branch-protection used on non-AArch64 target; \\\n+                  this should be checked in rustc_session.\"\n+            );\n         }\n     }\n "}, {"sha": "393bf30e9f83411d5063ba17d76c7657aeb020ee", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -30,7 +30,7 @@ use std::ffi::CString;\n /// implementing this Rust version, and though the format documentation is very explicit and\n /// detailed, some undocumented details in Clang's implementation (that may or may not be important)\n /// were also replicated for Rust's Coverage Map.\n-pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     let tcx = cx.tcx;\n \n     // Ensure the installed version of LLVM supports at least Coverage Map\n@@ -284,7 +284,7 @@ fn save_function_record(\n /// \"code coverage dead code cgu\" during the partitioning process. This prevents us from generating\n /// code regions for the same function more than once which can lead to linker errors regarding\n /// duplicate symbols.\n-fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n     assert!(cx.codegen_unit.is_code_coverage_dead_code_cgu());\n \n     let tcx = cx.tcx;"}, {"sha": "48e3a812e4f20c839a60a7adcb61969201e82065", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -111,7 +111,7 @@ macro_rules! return_if_di_node_created_in_meantime {\n \n /// Extract size and alignment from a TyAndLayout.\n #[inline]\n-fn size_and_align_of<'tcx>(ty_and_layout: TyAndLayout<'tcx>) -> (Size, Align) {\n+fn size_and_align_of(ty_and_layout: TyAndLayout<'_>) -> (Size, Align) {\n     (ty_and_layout.size, ty_and_layout.align.abi)\n }\n "}, {"sha": "b46209972421fe894fd4b217013d7072558d6682", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -51,10 +51,6 @@ pub(crate) struct SymbolAlreadyDefined<'a> {\n     pub symbol_name: &'a str,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_branch_protection_requires_aarch64)]\n-pub(crate) struct BranchProtectionRequiresAArch64;\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_invalid_minimum_alignment)]\n pub(crate) struct InvalidMinimumAlignment {"}, {"sha": "1ce48f82e1c9b739bf26fd800d132544706f72d7", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -567,7 +567,7 @@ fn codegen_msvc_try<'ll>(\n         // module.\n         //\n         // When modifying, make sure that the type_name string exactly matches\n-        // the one used in src/libpanic_unwind/seh.rs.\n+        // the one used in library/panic_unwind/src/seh.rs.\n         let type_info_vtable = bx.declare_global(\"??_7type_info@@6B@\", bx.type_i8p());\n         let type_name = bx.const_bytes(b\"rust_panic\\0\");\n         let type_info ="}, {"sha": "8b4861962b22947f0d9d1dd4fbeae5571eb4c50f", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -79,6 +79,7 @@ pub enum LLVMModFlagBehavior {\n     Append = 5,\n     AppendUnique = 6,\n     Max = 7,\n+    Min = 8,\n }\n \n // Consts for the LLVM CallConv type, pre-cast to usize.\n@@ -2389,11 +2390,11 @@ extern \"C\" {\n \n     pub fn LLVMRustSetDataLayoutFromTargetMachine<'a>(M: &'a Module, TM: &'a TargetMachine);\n \n-    pub fn LLVMRustBuildOperandBundleDef<'a>(\n+    pub fn LLVMRustBuildOperandBundleDef(\n         Name: *const c_char,\n-        Inputs: *const &'a Value,\n+        Inputs: *const &'_ Value,\n         NumInputs: c_uint,\n-    ) -> &'a mut OperandBundleDef<'a>;\n+    ) -> &mut OperandBundleDef<'_>;\n     pub fn LLVMRustFreeOperandBundleDef<'a>(Bundle: &'a mut OperandBundleDef<'a>);\n \n     pub fn LLVMRustPositionBuilderAtStart<'a>(B: &Builder<'a>, BB: &'a BasicBlock);"}, {"sha": "b19398e68c260186ec637b8d02a1f25dba1c8385", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -175,6 +175,89 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     val\n }\n \n+fn emit_s390x_va_arg<'ll, 'tcx>(\n+    bx: &mut Builder<'_, 'll, 'tcx>,\n+    list: OperandRef<'tcx, &'ll Value>,\n+    target_ty: Ty<'tcx>,\n+) -> &'ll Value {\n+    // Implementation of the s390x ELF ABI calling convention for va_args see\n+    // https://github.com/IBM/s390x-abi (chapter 1.2.4)\n+    let va_list_addr = list.immediate();\n+    let va_list_layout = list.deref(bx.cx).layout;\n+    let va_list_ty = va_list_layout.llvm_type(bx);\n+    let layout = bx.cx.layout_of(target_ty);\n+\n+    let in_reg = bx.append_sibling_block(\"va_arg.in_reg\");\n+    let in_mem = bx.append_sibling_block(\"va_arg.in_mem\");\n+    let end = bx.append_sibling_block(\"va_arg.end\");\n+\n+    // FIXME: vector ABI not yet supported.\n+    let target_ty_size = bx.cx.size_of(target_ty).bytes();\n+    let indirect: bool = target_ty_size > 8 || !target_ty_size.is_power_of_two();\n+    let unpadded_size = if indirect { 8 } else { target_ty_size };\n+    let padded_size = 8;\n+    let padding = padded_size - unpadded_size;\n+\n+    let gpr_type = indirect || !layout.is_single_fp_element(bx.cx);\n+    let (max_regs, reg_count_field, reg_save_index, reg_padding) =\n+        if gpr_type { (5, 0, 2, padding) } else { (4, 1, 16, 0) };\n+\n+    // Check whether the value was passed in a register or in memory.\n+    let reg_count = bx.struct_gep(\n+        va_list_ty,\n+        va_list_addr,\n+        va_list_layout.llvm_field_index(bx.cx, reg_count_field),\n+    );\n+    let reg_count_v = bx.load(bx.type_i64(), reg_count, Align::from_bytes(8).unwrap());\n+    let use_regs = bx.icmp(IntPredicate::IntULT, reg_count_v, bx.const_u64(max_regs));\n+    bx.cond_br(use_regs, in_reg, in_mem);\n+\n+    // Emit code to load the value if it was passed in a register.\n+    bx.switch_to_block(in_reg);\n+\n+    // Work out the address of the value in the register save area.\n+    let reg_ptr =\n+        bx.struct_gep(va_list_ty, va_list_addr, va_list_layout.llvm_field_index(bx.cx, 3));\n+    let reg_ptr_v = bx.load(bx.type_i8p(), reg_ptr, bx.tcx().data_layout.pointer_align.abi);\n+    let scaled_reg_count = bx.mul(reg_count_v, bx.const_u64(8));\n+    let reg_off = bx.add(scaled_reg_count, bx.const_u64(reg_save_index * 8 + reg_padding));\n+    let reg_addr = bx.gep(bx.type_i8(), reg_ptr_v, &[reg_off]);\n+\n+    // Update the register count.\n+    let new_reg_count_v = bx.add(reg_count_v, bx.const_u64(1));\n+    bx.store(new_reg_count_v, reg_count, Align::from_bytes(8).unwrap());\n+    bx.br(end);\n+\n+    // Emit code to load the value if it was passed in memory.\n+    bx.switch_to_block(in_mem);\n+\n+    // Work out the address of the value in the argument overflow area.\n+    let arg_ptr =\n+        bx.struct_gep(va_list_ty, va_list_addr, va_list_layout.llvm_field_index(bx.cx, 2));\n+    let arg_ptr_v = bx.load(bx.type_i8p(), arg_ptr, bx.tcx().data_layout.pointer_align.abi);\n+    let arg_off = bx.const_u64(padding);\n+    let mem_addr = bx.gep(bx.type_i8(), arg_ptr_v, &[arg_off]);\n+\n+    // Update the argument overflow area pointer.\n+    let arg_size = bx.cx().const_u64(padded_size);\n+    let new_arg_ptr_v = bx.inbounds_gep(bx.type_i8(), arg_ptr_v, &[arg_size]);\n+    bx.store(new_arg_ptr_v, arg_ptr, bx.tcx().data_layout.pointer_align.abi);\n+    bx.br(end);\n+\n+    // Return the appropriate result.\n+    bx.switch_to_block(end);\n+    let val_addr = bx.phi(bx.type_i8p(), &[reg_addr, mem_addr], &[in_reg, in_mem]);\n+    let val_type = layout.llvm_type(bx);\n+    let val_addr = if indirect {\n+        let ptr_type = bx.cx.type_ptr_to(val_type);\n+        let ptr_addr = bx.bitcast(val_addr, bx.cx.type_ptr_to(ptr_type));\n+        bx.load(ptr_type, ptr_addr, bx.tcx().data_layout.pointer_align.abi)\n+    } else {\n+        bx.bitcast(val_addr, bx.cx.type_ptr_to(val_type))\n+    };\n+    bx.load(val_type, val_addr, layout.align.abi)\n+}\n+\n pub(super) fn emit_va_arg<'ll, 'tcx>(\n     bx: &mut Builder<'_, 'll, 'tcx>,\n     addr: OperandRef<'tcx, &'ll Value>,\n@@ -200,6 +283,7 @@ pub(super) fn emit_va_arg<'ll, 'tcx>(\n             emit_ptr_va_arg(bx, addr, target_ty, false, Align::from_bytes(8).unwrap(), true)\n         }\n         \"aarch64\" => emit_aapcs_va_arg(bx, addr, target_ty),\n+        \"s390x\" => emit_s390x_va_arg(bx, addr, target_ty),\n         // Windows x86_64\n         \"x86_64\" if target.is_like_windows => {\n             let target_ty_size = bx.cx.size_of(target_ty).bytes();"}, {"sha": "6eb120157da0205b34c762ec5787d2a9665bd9b0", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -123,7 +123,7 @@ fn try_filter_fat_archs<'a>(\n ) -> io::Result<Option<(&'a [u8], u64)>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n-    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n+    let desired = match archs.iter().find(|a| a.architecture() == target_arch) {\n         Some(a) => a,\n         None => return Ok(None),\n     };"}, {"sha": "edde1537b81e19bcbde989104bf83592b4aff038", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -253,7 +253,7 @@ pub fn each_linked_rlib(\n     };\n     for &cnum in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n-            Some(&Linkage::NotLinked | &Linkage::IncludedFromDylib) => continue,\n+            Some(&Linkage::NotLinked | &Linkage::Dynamic | &Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n             None => return Err(errors::LinkRlibError::MissingFormat),\n         }\n@@ -607,21 +607,21 @@ fn link_dwarf_object<'a>(\n     }\n \n     impl<Relocations> ThorinSession<Relocations> {\n-        fn alloc_mmap<'arena>(&'arena self, data: Mmap) -> &'arena Mmap {\n+        fn alloc_mmap(&self, data: Mmap) -> &Mmap {\n             (*self.arena_mmap.alloc(data)).borrow()\n         }\n     }\n \n     impl<Relocations> thorin::Session<Relocations> for ThorinSession<Relocations> {\n-        fn alloc_data<'arena>(&'arena self, data: Vec<u8>) -> &'arena [u8] {\n+        fn alloc_data(&self, data: Vec<u8>) -> &[u8] {\n             (*self.arena_data.alloc(data)).borrow()\n         }\n \n-        fn alloc_relocation<'arena>(&'arena self, data: Relocations) -> &'arena Relocations {\n+        fn alloc_relocation(&self, data: Relocations) -> &Relocations {\n             (*self.arena_relocations.alloc(data)).borrow()\n         }\n \n-        fn read_input<'arena>(&'arena self, path: &Path) -> std::io::Result<&'arena [u8]> {\n+        fn read_input(&self, path: &Path) -> std::io::Result<&[u8]> {\n             let file = File::open(&path)?;\n             let mmap = (unsafe { Mmap::map(file) })?;\n             Ok(self.alloc_mmap(mmap))\n@@ -722,7 +722,7 @@ fn link_natively<'a>(\n \n     linker::disable_localization(&mut cmd);\n \n-    for &(ref k, ref v) in sess.target.link_env.as_ref() {\n+    for (k, v) in sess.target.link_env.as_ref() {\n         cmd.env(k.as_ref(), v.as_ref());\n     }\n     for k in sess.target.link_env_remove.as_ref() {"}, {"sha": "0268659d3b9a13d8515eace64f9d4d2851945bec", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -108,7 +108,7 @@ pub fn get_linker<'a>(\n     if sess.target.is_like_msvc {\n         if let Some(ref tool) = msvc_tool {\n             cmd.args(tool.args());\n-            for &(ref k, ref v) in tool.env() {\n+            for (k, v) in tool.env() {\n                 if k == \"PATH\" {\n                     new_path.extend(env::split_paths(v));\n                     msvc_changed_path = true;"}, {"sha": "8cb7d74b90d4b40dc6393cd63b5925b7a3260c9c", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -163,10 +163,10 @@ fn is_reachable_non_generic_provider_extern(tcx: TyCtxt<'_>, def_id: DefId) -> b\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n-fn exported_symbols_provider_local<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn exported_symbols_provider_local(\n+    tcx: TyCtxt<'_>,\n     cnum: CrateNum,\n-) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportInfo)] {\n+) -> &[(ExportedSymbol<'_>, SymbolExportInfo)] {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {"}, {"sha": "60e9b40e8fb409f862244c561500de87ca628a66", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -10,7 +10,7 @@ pub mod type_names;\n /// NOTE: This is somewhat inconsistent right now: For empty enums and enums with a single\n ///       fieldless variant, we generate DW_TAG_struct_type, although a\n ///       DW_TAG_enumeration_type would be a better fit.\n-pub fn wants_c_like_enum_debuginfo<'tcx>(enum_type_and_layout: TyAndLayout<'tcx>) -> bool {\n+pub fn wants_c_like_enum_debuginfo(enum_type_and_layout: TyAndLayout<'_>) -> bool {\n     match enum_type_and_layout.ty.kind() {\n         ty::Adt(adt_def, _) => {\n             if !adt_def.is_enum() {"}, {"sha": "0f6e6032f9bffb68a2a7098886643f284cb40ea0", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -29,6 +29,9 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let align = meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_ALIGN)\n                 .get_usize(bx, vtable);\n \n+            // Size is always <= isize::MAX.\n+            let size_bound = bx.data_layout().ptr_sized_integer().signed_max() as u128;\n+            bx.range_metadata(size, WrappingRange { start: 0, end: size_bound });\n             // Alignment is always nonzero.\n             bx.range_metadata(align, WrappingRange { start: 1, end: !0 });\n "}, {"sha": "2421acab4715d1078b73471abf79515d270f6448", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> VirtualIndex {\n \n /// This takes a valid `self` receiver type and extracts the principal trait\n /// ref of the type.\n-fn expect_dyn_trait_in_self<'tcx>(ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n+fn expect_dyn_trait_in_self(ty: Ty<'_>) -> ty::PolyExistentialTraitRef<'_> {\n     for arg in ty.peel_refs().walk() {\n         if let GenericArgKind::Type(ty) = arg.unpack() {\n             if let ty::Dynamic(data, _, _) = ty.kind() {"}, {"sha": "cff72048ead08058c20171a520d0b0b9cd42ed20", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -663,12 +663,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         enum AssertIntrinsic {\n             Inhabited,\n             ZeroValid,\n-            UninitValid,\n+            MemUninitializedValid,\n         }\n         let panic_intrinsic = intrinsic.and_then(|i| match i {\n             sym::assert_inhabited => Some(AssertIntrinsic::Inhabited),\n             sym::assert_zero_valid => Some(AssertIntrinsic::ZeroValid),\n-            sym::assert_uninit_valid => Some(AssertIntrinsic::UninitValid),\n+            sym::assert_mem_uninitialized_valid => Some(AssertIntrinsic::MemUninitializedValid),\n             _ => None,\n         });\n         if let Some(intrinsic) = panic_intrinsic {\n@@ -679,7 +679,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n                 ZeroValid => !bx.tcx().permits_zero_init(layout),\n-                UninitValid => !bx.tcx().permits_uninit_init(layout),\n+                MemUninitializedValid => !bx.tcx().permits_uninit_init(layout),\n             };\n             Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({"}, {"sha": "a75609260eda49f874c909be5583d6693d98c148", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -110,10 +110,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     _ => bug!(),\n                 };\n                 let value = meth::VirtualIndex::from_index(idx).get_usize(bx, vtable);\n-                if name == sym::vtable_align {\n+                match name {\n+                    // Size is always <= isize::MAX.\n+                    sym::vtable_size => {\n+                        let size_bound = bx.data_layout().ptr_sized_integer().signed_max() as u128;\n+                        bx.range_metadata(value, WrappingRange { start: 0, end: size_bound });\n+                    },\n                     // Alignment is always nonzero.\n-                    bx.range_metadata(value, WrappingRange { start: 1, end: !0 });\n-                };\n+                    sym::vtable_align => bx.range_metadata(value, WrappingRange { start: 1, end: !0 }),\n+                    _ => {}\n+                }\n                 value\n             }\n             sym::pref_align_of"}, {"sha": "da69fc8ecf77e11d6726f0686d3f061cd7374407", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -419,7 +419,7 @@ pub fn from_target_feature(\n \n /// Computes the set of target features used in a function for the purposes of\n /// inline assembly.\n-fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n+fn asm_target_features(tcx: TyCtxt<'_>, did: DefId) -> &FxHashSet<Symbol> {\n     let mut target_features = tcx.sess.unstable_target_features.clone();\n     if tcx.def_kind(did).has_codegen_attrs() {\n         let attrs = tcx.codegen_fn_attrs(did);"}, {"sha": "986b6d655300168046dad275e318667b1adff014", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n                 self.write_immediate(val, dest)\n             }\n-            (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n                 let val = self.read_immediate(src)?;\n                 if data_a.principal() == data_b.principal() {\n                     // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables."}, {"sha": "666fcbd6f80488cc2dff1abc141252a50b72aafc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -303,15 +303,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             sym::offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n+                let offset_count = self.read_machine_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_pointer(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_scalar(&args[1])?.to_machine_isize(self)?;\n+                let offset_count = self.read_machine_isize(&args[1])?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -428,7 +428,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::transmute => {\n                 self.copy_op(&args[0], dest, /*allow_transmute*/ true)?;\n             }\n-            sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n+            sym::assert_inhabited\n+            | sym::assert_zero_valid\n+            | sym::assert_mem_uninitialized_valid => {\n                 let ty = instance.substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n \n@@ -460,7 +462,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                if intrinsic_name == sym::assert_uninit_valid {\n+                if intrinsic_name == sym::assert_mem_uninitialized_valid {\n                     let should_panic = !self.tcx.permits_uninit_init(layout);\n \n                     if should_panic {\n@@ -668,7 +670,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         count: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n+        let count = self.read_machine_usize(&count)?;\n         let layout = self.layout_of(src.layout.ty.builtin_deref(true).unwrap().ty)?;\n         let (size, align) = (layout.size, layout.align.abi);\n         // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n@@ -696,7 +698,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let dst = self.read_pointer(&dst)?;\n         let byte = self.read_scalar(&byte)?.to_u8()?;\n-        let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n+        let count = self.read_machine_usize(&count)?;\n \n         // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n         // but no actual allocation can be big enough for the difference to be noticeable."}, {"sha": "fcc6f8ea85282673c6f790d08ab13af0a85520f0", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -39,7 +39,7 @@ pub enum Immediate<Prov: Provenance = AllocId> {\n impl<Prov: Provenance> From<Scalar<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n     fn from(val: Scalar<Prov>) -> Self {\n-        Immediate::Scalar(val.into())\n+        Immediate::Scalar(val)\n     }\n }\n \n@@ -53,15 +53,15 @@ impl<Prov: Provenance> Immediate<Prov> {\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n-        Immediate::ScalarPair(val.into(), Scalar::from_machine_usize(len, cx).into())\n+        Immediate::ScalarPair(val, Scalar::from_machine_usize(len, cx))\n     }\n \n     pub fn new_dyn_trait(\n         val: Scalar<Prov>,\n         vtable: Pointer<Option<Prov>>,\n         cx: &impl HasDataLayout,\n     ) -> Self {\n-        Immediate::ScalarPair(val.into(), Scalar::from_maybe_pointer(vtable, cx))\n+        Immediate::ScalarPair(val, Scalar::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n@@ -341,10 +341,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     alloc_range(b_offset, b_size),\n                     /*read_provenance*/ b.is_ptr(),\n                 )?;\n-                Some(ImmTy {\n-                    imm: Immediate::ScalarPair(a_val.into(), b_val.into()),\n-                    layout: mplace.layout,\n-                })\n+                Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout })\n             }\n             _ => {\n                 // Neither a scalar nor scalar pair.\n@@ -407,13 +404,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.read_immediate(op)?.to_scalar())\n     }\n \n+    // Pointer-sized reads are fairly common and need target layout access, so we wrap them in\n+    // convenience functions.\n+\n     /// Read a pointer from a place.\n     pub fn read_pointer(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n         self.read_scalar(op)?.to_pointer(self)\n     }\n+    /// Read a pointer-sized unsigned integer from a place.\n+    pub fn read_machine_usize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, u64> {\n+        self.read_scalar(op)?.to_machine_usize(self)\n+    }\n+    /// Read a pointer-sized signed integer from a place.\n+    pub fn read_machine_isize(&self, op: &OpTy<'tcx, M::Provenance>) -> InterpResult<'tcx, i64> {\n+        self.read_scalar(op)?.to_machine_isize(self)\n+    }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> {\n@@ -569,8 +577,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Unevaluated(uv) => {\n                 let instance = self.resolve(uv.def, uv.substs)?;\n                 let cid = GlobalId { instance, promoted: None };\n-                self.ctfe_query(span, |tcx| tcx.eval_to_valtree(self.param_env.and(cid)))?\n-                    .unwrap_or_else(|| bug!(\"unable to create ValTree for {uv:?}\"))\n+                self.ctfe_query(span, |tcx| {\n+                    tcx.eval_to_valtree(self.param_env.with_const().and(cid))\n+                })?\n+                .unwrap_or_else(|| bug!(\"unable to create ValTree for {uv:?}\"))\n             }\n             ty::ConstKind::Bound(..) | ty::ConstKind::Infer(..) => {\n                 span_bug!(self.cur_span(), \"unexpected ConstKind in ctfe: {val:?}\")"}, {"sha": "e8ff70e3a4095075ebe765e16a18549decfd866d", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -36,7 +36,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if let Abi::ScalarPair(..) = dest.layout.abi {\n             // We can use the optimized path and avoid `place_field` (which might do\n             // `force_allocation`).\n-            let pair = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n+            let pair = Immediate::ScalarPair(val, Scalar::from_bool(overflowed));\n             self.write_immediate(pair, dest)?;\n         } else {\n             assert!(self.tcx.sess.opts.unstable_opts.randomize_layout);"}, {"sha": "97a73e98abcbca9d563027620fc8a74630014606", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -141,7 +141,7 @@ impl<Prov: Provenance> MemPlace<Prov> {\n         match self.meta {\n             MemPlaceMeta::None => Immediate::from(Scalar::from_maybe_pointer(self.ptr, cx)),\n             MemPlaceMeta::Meta(meta) => {\n-                Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx).into(), meta.into())\n+                Immediate::ScalarPair(Scalar::from_maybe_pointer(self.ptr, cx), meta)\n             }\n         }\n     }"}, {"sha": "291464ab58ae20da7692acaa0bc77c158c57f688", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -363,7 +363,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_scalar(&n)?.to_machine_usize(self)?;\n+                let n = self.read_machine_usize(&n)?;\n                 self.place_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {\n@@ -392,7 +392,7 @@ where\n             Index(local) => {\n                 let layout = self.layout_of(self.tcx.types.usize)?;\n                 let n = self.local_to_op(self.frame(), local, Some(layout))?;\n-                let n = self.read_scalar(&n)?.to_machine_usize(self)?;\n+                let n = self.read_machine_usize(&n)?;\n                 self.operand_index(base, n)?\n             }\n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "550c7a44c4199e6cf7043d4dd60f6e49c7f4b436", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -119,11 +119,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Drop { place, target, unwind } => {\n+                let frame = self.frame();\n+                let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;\n+                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n+                if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n+                    // This is the branch we enter if and only if the dropped type has no drop glue\n+                    // whatsoever. This can happen as a result of monomorphizing a drop of a\n+                    // generic. In order to make sure that generic and non-generic code behaves\n+                    // roughly the same (and in keeping with Mir semantics) we do nothing here.\n+                    self.go_to_block(target);\n+                    return Ok(());\n+                }\n                 let place = self.eval_place(place)?;\n-                let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n-\n-                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_in_place(&place, instance, target, unwind)?;\n             }\n "}, {"sha": "94e1b95a0eb3c9501a33f4d3bafecd82c632bd9f", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -9,8 +9,8 @@ use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping,\n     Local, Location, MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef,\n-    ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, UnOp, START_BLOCK,\n+    ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n+    Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n@@ -667,10 +667,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.fail(location, \"`Deinit`is not allowed until deaggregation\");\n                 }\n             }\n-            StatementKind::Retag(_, _) => {\n+            StatementKind::Retag(kind, _) => {\n                 // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n                 // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n                 // seem to fail to set their `MirPhase` correctly.\n+                if *kind == RetagKind::Raw || *kind == RetagKind::TwoPhase {\n+                    self.fail(location, format!(\"explicit `{:?}` is forbidden\", kind));\n+                }\n             }\n             StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)"}, {"sha": "0366fb0a148c7c1c6e22f33e2171c520b7579f44", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -8,7 +8,7 @@ edition = \"2021\"\n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n bitflags = \"1.2.1\"\n-cfg-if = \"0.1.2\"\n+cfg-if = \"1.0\"\n ena = \"0.14\"\n indexmap = { version = \"1.9.1\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n@@ -21,7 +21,11 @@ rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dangle\"] }\n+smallvec = { version = \"1.8.1\", features = [\n+    \"const_generics\",\n+    \"union\",\n+    \"may_dangle\",\n+] }\n stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.15\"\n tempfile = \"3.2\""}, {"sha": "94a8c1fc051dd6f3bb9aedcab3b33a74e0adca80", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -22,7 +22,7 @@ struct PreOrderFrame<Iter> {\n }\n \n rustc_index::newtype_index! {\n-    struct PreorderIndex { .. }\n+    struct PreorderIndex {}\n }\n \n pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {"}, {"sha": "16296b2248975e6eb627a3d9ceb21ed967a6bb42", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -205,22 +205,19 @@ impl SelfProfilerRef {\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n     /// stderr if the compiler is invoked with -Ztime-passes.\n-    pub fn verbose_generic_activity<'a>(\n-        &'a self,\n-        event_label: &'static str,\n-    ) -> VerboseTimingGuard<'a> {\n+    pub fn verbose_generic_activity(&self, event_label: &'static str) -> VerboseTimingGuard<'_> {\n         let message =\n             if self.print_verbose_generic_activities { Some(event_label.to_owned()) } else { None };\n \n         VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n     /// Like `verbose_generic_activity`, but with an extra arg.\n-    pub fn verbose_generic_activity_with_arg<'a, A>(\n-        &'a self,\n+    pub fn verbose_generic_activity_with_arg<A>(\n+        &self,\n         event_label: &'static str,\n         event_arg: A,\n-    ) -> VerboseTimingGuard<'a>\n+    ) -> VerboseTimingGuard<'_>\n     where\n         A: Borrow<str> + Into<String>,\n     {"}, {"sha": "1ff0d58df140907129ac3d97d39a81ee10a3e630", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -199,7 +199,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     /// Viewing the relation as a graph, computes the \"mutual\n     /// immediate postdominator\" of a set of points (if one\n     /// exists). See `postdom_upper_bound` for details.\n-    pub fn mutual_immediate_postdominator<'a>(&'a self, mut mubs: Vec<T>) -> Option<T> {\n+    pub fn mutual_immediate_postdominator(&self, mut mubs: Vec<T>) -> Option<T> {\n         loop {\n             match mubs.len() {\n                 0 => return None,"}, {"sha": "14257e4d5c60b8c1ccbd5c40b89267b0162d19eb", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -178,7 +178,7 @@ impl<V: Eq + Hash> UnordSet<V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -255,7 +255,7 @@ impl<K: Eq + Hash, V> UnordMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+    pub fn items(&self) -> UnordItems<(&K, &V), impl Iterator<Item = (&K, &V)>> {\n         UnordItems(self.inner.iter())\n     }\n \n@@ -311,7 +311,7 @@ impl<V> UnordBag<V> {\n     }\n \n     #[inline]\n-    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+    pub fn items(&self) -> UnordItems<&V, impl Iterator<Item = &V>> {\n         UnordItems(self.inner.iter())\n     }\n "}, {"sha": "236f66eae72c33cee18652a0bb9ffc97f32dcb60", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1199,10 +1199,13 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n             };\n \n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            (*DEFAULT_HOOK)(info);\n+            // Don't do this for `ExplicitBug`, which has an unhelpful message and backtrace.\n+            if !info.payload().is::<rustc_errors::ExplicitBug>() {\n+                (*DEFAULT_HOOK)(info);\n \n-            // Separate the output with an empty line\n-            eprintln!();\n+                // Separate the output with an empty line\n+                eprintln!();\n+            }\n \n             // Print the ICE message\n             report_ice(info, BUG_REPORT_URL);"}, {"sha": "d05559e92440f28f5eb2b7197991b30f74e39392", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -163,6 +163,7 @@ E0311: include_str!(\"./error_codes/E0311.md\"),\n E0312: include_str!(\"./error_codes/E0312.md\"),\n E0316: include_str!(\"./error_codes/E0316.md\"),\n E0317: include_str!(\"./error_codes/E0317.md\"),\n+E0320: include_str!(\"./error_codes/E0320.md\"),\n E0321: include_str!(\"./error_codes/E0321.md\"),\n E0322: include_str!(\"./error_codes/E0322.md\"),\n E0323: include_str!(\"./error_codes/E0323.md\"),\n@@ -183,6 +184,7 @@ E0373: include_str!(\"./error_codes/E0373.md\"),\n E0374: include_str!(\"./error_codes/E0374.md\"),\n E0375: include_str!(\"./error_codes/E0375.md\"),\n E0376: include_str!(\"./error_codes/E0376.md\"),\n+E0377: include_str!(\"./error_codes/E0377.md\"),\n E0378: include_str!(\"./error_codes/E0378.md\"),\n E0379: include_str!(\"./error_codes/E0379.md\"),\n E0380: include_str!(\"./error_codes/E0380.md\"),\n@@ -238,13 +240,17 @@ E0452: include_str!(\"./error_codes/E0452.md\"),\n E0453: include_str!(\"./error_codes/E0453.md\"),\n E0454: include_str!(\"./error_codes/E0454.md\"),\n E0455: include_str!(\"./error_codes/E0455.md\"),\n+E0457: include_str!(\"./error_codes/E0457.md\"),\n E0458: include_str!(\"./error_codes/E0458.md\"),\n E0459: include_str!(\"./error_codes/E0459.md\"),\n+E0460: include_str!(\"./error_codes/E0460.md\"),\n+E0462: include_str!(\"./error_codes/E0462.md\"),\n E0463: include_str!(\"./error_codes/E0463.md\"),\n E0464: include_str!(\"./error_codes/E0464.md\"),\n E0466: include_str!(\"./error_codes/E0466.md\"),\n E0468: include_str!(\"./error_codes/E0468.md\"),\n E0469: include_str!(\"./error_codes/E0469.md\"),\n+E0472: include_str!(\"./error_codes/E0472.md\"),\n E0477: include_str!(\"./error_codes/E0477.md\"),\n E0478: include_str!(\"./error_codes/E0478.md\"),\n E0482: include_str!(\"./error_codes/E0482.md\"),\n@@ -575,10 +581,7 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0314, // closure outlives stack frame\n //  E0315, // cannot invoke closure outside of its lifetime\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n-    E0320, // recursive overflow during dropck\n //  E0372, // coherence not object safe\n-    E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n-           // between structures with the same definition\n //  E0385, // {} in an aliasable location\n //  E0402, // cannot use an outer type parameter in this context\n //  E0406, // merged into 420\n@@ -592,15 +595,11 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0421, // merged into 531\n //  E0427, // merged into 530\n //  E0456, // plugin `..` is not available for triple `..`\n-    E0457, // plugin `..` only found in rlib format, but must be available...\n-    E0460, // found possibly newer version of crate `..`\n     E0461, // couldn't find crate `..` with expected target triple ..\n-    E0462, // found staticlib `..` instead of rlib or dylib\n     E0465, // multiple .. candidates for `..` found\n //  E0467, // removed\n //  E0470, // removed\n //  E0471, // constant evaluation error (in pattern)\n-    E0472, // llvm_asm! is unsupported on this target\n //  E0473, // dereference of reference outside its lifetime\n //  E0474, // captured variable `..` does not outlive the enclosing closure\n //  E0475, // index of slice outside its lifetime"}, {"sha": "03b93d925c19a3f5c0eab3202af14735ab04cfdf", "filename": "compiler/rustc_error_codes/src/error_codes/E0158.md", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0158.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0158.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0158.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,38 +1,53 @@\n-An associated const has been referenced in a pattern.\n+An associated `const`, `const` parameter or `static` has been referenced\n+in a pattern.\n \n Erroneous code example:\n \n ```compile_fail,E0158\n-enum EFoo { A, B, C, D }\n+enum Foo {\n+    One,\n+    Two\n+}\n \n-trait Foo {\n-    const X: EFoo;\n+trait Bar {\n+    const X: Foo;\n }\n \n-fn test<A: Foo>(arg: EFoo) {\n+fn test<A: Bar>(arg: Foo) {\n     match arg {\n-        A::X => { // error!\n-            println!(\"A::X\");\n-        }\n+        A::X => println!(\"A::X\"), // error: E0158: associated consts cannot be\n+                                  //        referenced in patterns\n+        Foo::Two => println!(\"Two\")\n     }\n }\n ```\n \n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n+Associated `const`s cannot be referenced in patterns because it is impossible\n+for the compiler to prove exhaustiveness (that some pattern will always match).\n+Take the above example, because Rust does type checking in the *generic*\n+method, not the *monomorphized* specific instance. So because `Bar` could have\n+theoretically infinite implementations, there's no way to always be sure that\n+`A::X` is `Foo::One`. So this code must be rejected. Even if code can be\n+proven exhaustive by a programmer, the compiler cannot currently prove this.\n \n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n+The same holds true of `const` parameters and `static`s.\n \n-If you want to match against a `static`, consider using a guard instead:\n+If you want to match against an associated `const`, `const` parameter or\n+`static` consider using a guard instead:\n \n ```\n-static FORTY_TWO: i32 = 42;\n+trait Trait {\n+    const X: char;\n+}\n+\n+static FOO: char = 'j';\n \n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n+fn test<A: Trait, const Y: char>(arg: char) {\n+    match arg {\n+        c if c == A::X => println!(\"A::X\"),\n+        c if c == Y => println!(\"Y\"),\n+        c if c == FOO => println!(\"FOO\"),\n+        _ => ()\n+    }\n }\n ```"}, {"sha": "e6e1b7c19a566fe8a512ff2e4bdaf88db9fb7671", "filename": "compiler/rustc_error_codes/src/error_codes/E0320.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0320.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0320.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0320.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,27 @@\n+Recursion limit reached while creating drop-check rules.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0320\n+enum A<T> {\n+    B,\n+    C(T, Box<A<(T, T)>>)\n+}\n+\n+fn foo<T>() {\n+    A::<T>::B; // error: overflow while adding drop-check rules for A<T>\n+}\n+```\n+\n+The Rust compiler must be able to reason about how a type is [`Drop`]ped, and\n+by extension the types of its fields, to be able to generate the glue to\n+properly drop a value. The code example above shows a type where this inference\n+is impossible because it is recursive. Note that this is *not* the same as\n+[E0072](E0072.html), where a type has an infinite size; the type here has a\n+finite size but any attempt to `Drop` it would recurse infinitely. For more\n+information, read [the `Drop` docs](../std/ops/trait.Drop.html).\n+\n+It is not possible to define a type with recursive drop-check rules. All such\n+recursion must be removed.\n+\n+[`Drop`]: ../std/ops/trait.Drop.html"}, {"sha": "b1d36406332bdb08bc071867da0d3791d72f2028", "filename": "compiler/rustc_error_codes/src/error_codes/E0377.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0377.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0377.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0377.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,29 @@\n+The trait `CoerceUnsized` may only be implemented for a coercion between\n+structures with the same definition.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0377\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+pub struct Foo<T: ?Sized> {\n+    field_with_unsized_type: T,\n+}\n+\n+pub struct Bar<T: ?Sized> {\n+    field_with_unsized_type: T,\n+}\n+\n+// error: the trait `CoerceUnsized` may only be implemented for a coercion\n+//        between structures with the same definition\n+impl<T, U> CoerceUnsized<Bar<U>> for Foo<T> where T: CoerceUnsized<U> {}\n+```\n+\n+When attempting to implement `CoerceUnsized`, the `impl` signature must look\n+like: `impl CoerceUnsized<Type<U>> for Type<T> where T: CoerceUnsized<U>`;\n+the *implementer* and *`CoerceUnsized` type parameter* must be the same\n+type. In this example, `Bar` and `Foo` (even though structurally identical)\n+are *not* the same type and are rejected. Learn more about the `CoerceUnsized`\n+trait and DST coercion in\n+[the `CoerceUnsized` docs](../std/ops/trait.CoerceUnsized.html)."}, {"sha": "53d384d36c4267c7b42db39ee6a268e292deefc4", "filename": "compiler/rustc_error_codes/src/error_codes/E0457.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,36 @@\n+Plugin `..` only found in rlib format, but must be available in dylib format.\n+\n+Erroronous code example:\n+\n+`rlib-plugin.rs`\n+```ignore (needs-linkage-with-other-tests)\n+#![crate_type = \"rlib\"]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_middle;\n+extern crate rustc_driver;\n+\n+use rustc_driver::plugin::Registry;\n+\n+#[no_mangle]\n+fn __rustc_plugin_registrar(_: &mut Registry) {}\n+```\n+\n+`main.rs`\n+```ignore (needs-linkage-with-other-tests)\n+#![feature(plugin)]\n+#![plugin(rlib_plugin)] // error: plugin `rlib_plugin` only found in rlib\n+                        //        format, but must be available in dylib\n+\n+fn main() {}\n+```\n+\n+The compiler exposes a plugin interface to allow altering the compile process\n+(adding lints, etc). Plugins must be defined in their own crates (similar to\n+[proc-macro](../reference/procedural-macros.html) isolation) and then compiled\n+and linked to another crate. Plugin crates *must* be compiled to the\n+dynamically-linked dylib format, and not the statically-linked rlib format.\n+Learn more about different output types in\n+[this section](../reference/linkage.html) of the Rust reference.\n+\n+This error is easily fixed by recompiling the plugin crate in the dylib format."}, {"sha": "001678a9bce0625f359d3553c316bcf4fbdd67ce", "filename": "compiler/rustc_error_codes/src/error_codes/E0460.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0460.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0460.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0460.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,71 @@\n+Found possibly newer version of crate `..` which `..` depends on.\n+\n+Consider these erroneous files:\n+\n+`a1.rs`\n+```ignore (needs-linkage-with-other-tests)\n+#![crate_name = \"a\"]\n+\n+pub fn foo<T>() {}\n+```\n+\n+`a2.rs`\n+```ignore (needs-linkage-with-other-tests)\n+#![crate_name = \"a\"]\n+\n+pub fn foo<T>() {\n+    println!(\"foo<T>()\");\n+}\n+```\n+\n+`b.rs`\n+```ignore (needs-linkage-with-other-tests)\n+#![crate_name = \"b\"]\n+\n+extern crate a; // linked with `a1.rs`\n+\n+pub fn foo() {\n+    a::foo::<isize>();\n+}\n+```\n+\n+`main.rs`\n+```ignore (needs-linkage-with-other-tests)\n+extern crate a; // linked with `a2.rs`\n+extern crate b; // error: found possibly newer version of crate `a` which `b`\n+                //        depends on\n+\n+fn main() {}\n+```\n+\n+The dependency graph of this program can be represented as follows:\n+```text\n+    crate `main`\n+         |\n+         +-------------+\n+         |             |\n+         |             v\n+depends: |         crate `b`\n+ `a` v1  |             |\n+         |             | depends:\n+         |             |  `a` v2\n+         v             |\n+      crate `a` <------+\n+```\n+\n+Crate `main` depends on crate `a` (version 1) and crate `b` which in turn\n+depends on crate `a` (version 2); this discrepancy in versions cannot be\n+reconciled. This difference in versions typically occurs when one crate is\n+compiled and linked, then updated and linked to another crate. The crate\n+\"version\" is a SVH (Strict Version Hash) of the crate in an\n+implementation-specific way. Note that this error can *only* occur when\n+directly compiling and linking with `rustc`; [Cargo] automatically resolves\n+dependencies, without using the compiler's own dependency management that\n+causes this issue.\n+\n+This error can be fixed by:\n+ * Using [Cargo], the Rust package manager, automatically fixing this issue.\n+ * Recompiling crate `a` so that both crate `b` and `main` have a uniform\n+   version to depend on.\n+\n+[Cargo]: ../cargo/index.html"}, {"sha": "4509cc6fad2d4e9bde523b81f93778d0eae9652d", "filename": "compiler/rustc_error_codes/src/error_codes/E0462.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0462.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0462.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0462.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,32 @@\n+Found `staticlib` `..` instead of `rlib` or `dylib`.\n+\n+Consider the following two files:\n+\n+`a.rs`\n+```ignore (cannot-link-with-other-tests)\n+#![crate_type = \"staticlib\"]\n+\n+fn foo() {}\n+```\n+\n+`main.rs`\n+```ignore (cannot-link-with-other-tests)\n+extern crate a;\n+\n+fn main() {\n+    a::foo();\n+}\n+```\n+\n+Crate `a` is compiled as a `staticlib`. A `staticlib` is a system-dependant\n+library only intended for linking with non-Rust applications (C programs). Note\n+that `staticlib`s include all upstream dependencies (`core`, `std`, other user\n+dependencies, etc) which makes them significantly larger than `dylib`s:\n+prefer `staticlib` for linking with C programs. Learn more about different\n+`crate_type`s in [this section of the Reference](../reference/linkage.html).\n+\n+This error can be fixed by:\n+ * Using [Cargo](../cargo/index.html), the Rust package manager, automatically\n+   fixing this issue.\n+ * Recompiling the crate as a `rlib` or `dylib`; formats suitable for Rust\n+   linking."}, {"sha": "0005cd41911a9295c8047b920b36e2a6e42b39d6", "filename": "compiler/rustc_error_codes/src/error_codes/E0472.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0472.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0472.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0472.md?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,31 @@\n+Inline assembly (`asm!`) is not supported on this target.\n+\n+Example of erroneous code:\n+\n+```ignore (cannot-change-target)\n+// compile-flags: --target sparc64-unknown-linux-gnu\n+#![no_std]\n+\n+use core::arch::asm;\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\"); // error: inline assembly is not supported on this target\n+    }\n+}\n+```\n+\n+The Rust compiler does not support inline assembly, with the `asm!` macro\n+(previously `llvm_asm!`), for all targets. All Tier 1 targets do support this\n+macro but support among Tier 2 and 3 targets is not guaranteed (even when they\n+have `std` support). Note that this error is related to\n+`error[E0658]: inline assembly is not stable yet on this architecture`, but\n+distinct in that with `E0472` support is not planned or in progress.\n+\n+There is no way to easily fix this issue, however:\n+ * Consider if you really need inline assembly, is there some other way to\n+   achieve your goal (intrinsics, etc)?\n+ * Consider writing your assembly externally, linking with it and calling it\n+   from Rust.\n+ * Consider contributing to <https://github.com/rust-lang/rust> and help\n+   integrate support for your target!"}, {"sha": "860212b051f39c4a8739110e9bf1edf220aa23cf", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -17,9 +17,6 @@ codegen_llvm_instrument_coverage_requires_llvm_12 =\n codegen_llvm_symbol_already_defined =\n     symbol `{$symbol_name}` is already defined\n \n-codegen_llvm_branch_protection_requires_aarch64 =\n-    -Zbranch-protection is only supported on aarch64\n-\n codegen_llvm_invalid_minimum_alignment =\n     invalid minimum global alignment: {$err}\n "}, {"sha": "2eb409a5ddd5e12297262ade97e6bb20ce48dd06", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -350,6 +350,9 @@ lint_builtin_mutable_transmutes =\n \n lint_builtin_unstable_features = unstable feature\n \n+lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n+     .label = this function will not propagate the caller location\n+\n lint_builtin_unreachable_pub = unreachable `pub` {$what}\n     .suggestion = consider restricting its visibility\n     .help = or consider exporting it for use by other crates"}, {"sha": "b3ca540417da79876f17449c5a2d4aa82d767861", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -166,12 +166,6 @@ metadata_conflicting_alloc_error_handler =\n metadata_global_alloc_required =\n     no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n \n-metadata_alloc_func_required =\n-    `#[alloc_error_handler]` function required, but not found\n-\n-metadata_missing_alloc_error_handler =\n-    use `#![feature(default_alloc_error_handler)]` for a default error handler\n-\n metadata_no_transitive_needs_dep =\n     the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n "}, {"sha": "60d3d3e69abbe13385988c7a2478e4c33dea03e6", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,301 @@\n+mir_build_unconditional_recursion = function cannot return without recursing\n+    .label = cannot return without recursing\n+    .help = a `loop` may express intention better if this is on purpose\n+\n+mir_build_unconditional_recursion_call_site_label = recursive call site\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block (error E0133)\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n+    block (error E0133)\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block (error E0133)\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block (error E0133)\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block (error E0133)\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of inline assembly is unsafe and requires unsafe function or block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of mutable static is unsafe and requires unsafe function or block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of extern static is unsafe and requires unsafe function or block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    dereference of raw pointer is unsafe and requires unsafe function or block\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    access to union field is unsafe and requires unsafe function or block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    mutation of layout constrained field is unsafe and requires unsafe function or block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_unused_unsafe = unnecessary `unsafe` block\n+    .label = unnecessary `unsafe` block\n+\n+mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n+mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n+\n+mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n+    .def_note = `{$peeled_ty}` defined here\n+    .type_note = the matched value is of type `{$ty}`\n+    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n+    .reference_note = references are always considered inhabited\n+    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n+\n+mir_build_static_in_pattern = statics cannot be referenced in patterns\n+\n+mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n+\n+mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n+\n+mir_build_non_const_path = runtime values cannot be referenced in patterns\n+\n+mir_build_unreachable_pattern = unreachable pattern\n+    .label = unreachable pattern\n+    .catchall_label = matches any value\n+\n+mir_build_const_pattern_depends_on_generic_parameter =\n+    constant pattern depends on a generic parameter\n+\n+mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n+\n+mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n+    lower range bound must be less than or equal to upper\n+    .label = lower bound larger than upper bound\n+    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n+\n+mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n+\n+mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } outside of the construct\n+\n+mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } into the body\n+\n+mir_build_bindings_with_variant_name =\n+    pattern binding `{$ident}` is named the same as one of the variants of the type `{$ty_path}`\n+    .suggestion = to match on the variant, qualify the path\n+\n+mir_build_irrefutable_let_patterns_generic_let = irrefutable `let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `let` is useless\n+    .help = consider removing `let`\n+\n+mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `if let` is useless\n+    .help = consider replacing the `if let` with a `let`\n+\n+mir_build_irrefutable_let_patterns_if_let_guard = irrefutable `if let` guard {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the guard is useless\n+    .help = consider removing the guard and adding a `let` inside the match arm\n+\n+mir_build_irrefutable_let_patterns_let_else = irrefutable `let...else` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the `else` clause is useless\n+    .help = consider removing the `else` clause\n+\n+mir_build_irrefutable_let_patterns_while_let = irrefutable `while let` {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    }\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match, so the loop will never exit\n+    .help = consider instead using a `loop {\"{\"} ... {\"}\"}` with a `let` inside it\n+\n+mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\n+\n+mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n+    .label = first mutable borrow, by `{$name}`, occurs here\n+    .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n+    .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n+    .moved = also moved into `{$name_moved}` here"}, {"sha": "ab9e8b6baae6ad4a3e30bbd92ff4bafe18e66e4c", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -41,6 +41,8 @@ session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is\n \n session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n \n+session_branch_protection_requires_aarch64 = `-Zbranch-protection` is only supported on aarch64\n+\n session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n \n session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions"}, {"sha": "37a51980a0888b375ff07b9b33fdca744c521337", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -57,6 +57,7 @@ fluent_messages! {\n     lint => \"../locales/en-US/lint.ftl\",\n     metadata => \"../locales/en-US/metadata.ftl\",\n     middle => \"../locales/en-US/middle.ftl\",\n+    mir_build => \"../locales/en-US/mir_build.ftl\",\n     mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n     parse => \"../locales/en-US/parse.ftl\",\n@@ -380,7 +381,7 @@ impl<S: Into<String>> From<S> for DiagnosticMessage {\n     }\n }\n \n-/// A workaround for \"good path\" ICEs when formatting types in disables lints.\n+/// A workaround for \"good path\" ICEs when formatting types in disabled lints.\n ///\n /// Delays formatting until `.into(): DiagnosticMessage` is used.\n pub struct DelayDm<F>(pub F);\n@@ -548,9 +549,7 @@ fn icu_locale_from_unic_langid(lang: LanguageIdentifier) -> Option<icu_locid::Lo\n     icu_locid::Locale::try_from_bytes(lang.to_string().as_bytes()).ok()\n }\n \n-pub fn fluent_value_from_str_list_sep_by_and<'source>(\n-    l: Vec<Cow<'source, str>>,\n-) -> FluentValue<'source> {\n+pub fn fluent_value_from_str_list_sep_by_and(l: Vec<Cow<'_, str>>) -> FluentValue<'_> {\n     // Fluent requires 'static value here for its AnyEq usages.\n     #[derive(Clone, PartialEq, Debug)]\n     struct FluentStrListSepByAnd(Vec<String>);"}, {"sha": "0b8847f827df1aa6ad9b8a056ccadba7d03ed9aa", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -468,7 +468,7 @@ fn check_nested_occurrences(\n                 // We check that the meta-variable is correctly used.\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n-            (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroName, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Parenthesis =>\n             {\n                 state = NestedMacroState::MacroNameParen;\n@@ -483,7 +483,7 @@ fn check_nested_occurrences(\n                     valid,\n                 );\n             }\n-            (NestedMacroState::MacroNameParen, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroNameParen, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Brace =>\n             {\n                 state = NestedMacroState::Empty;"}, {"sha": "320c533a66e5d0bfc1b47367765394d928277d10", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -792,7 +792,7 @@ impl<'tt> FirstSets<'tt> {\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n                     let subfirst_owned;\n                     let subfirst = match self.first.get(&sp.entire()) {\n-                        Some(&Some(ref subfirst)) => subfirst,\n+                        Some(Some(subfirst)) => subfirst,\n                         Some(&None) => {\n                             subfirst_owned = self.first(&seq_rep.tts);\n                             &subfirst_owned"}, {"sha": "878284f5928de6cc4fffbe77a8bf94f4a20b3891", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -356,7 +356,7 @@ fn parse_sep_and_kleene_op(\n // `$$` or a meta-variable is the lhs of a macro but shouldn't.\n //\n // For example, `macro_rules! foo { ( ${length()} ) => {} }`\n-fn span_dollar_dollar_or_metavar_in_the_lhs_err<'sess>(sess: &'sess ParseSess, token: &Token) {\n+fn span_dollar_dollar_or_metavar_in_the_lhs_err(sess: &ParseSess, token: &Token) {\n     sess.span_diagnostic\n         .span_err(token.span, &format!(\"unexpected token: {}\", pprust::token_to_string(token)));\n     sess.span_diagnostic.span_note_without_error("}, {"sha": "e5348039edd62c396847e0f581e14846566ce648", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -126,6 +126,8 @@ declare_features! (\n     (accepted, copy_closures, \"1.26.0\", Some(44490), None),\n     /// Allows `crate` in paths.\n     (accepted, crate_in_paths, \"1.30.0\", Some(45477), None),\n+    /// Allows rustc to inject a default alloc_error_handler\n+    (accepted, default_alloc_error_handler, \"CURRENT_RUSTC_VERSION\", Some(66741), None),\n     /// Allows using assigning a default type to type parameters in algebraic data type definitions.\n     (accepted, default_type_params, \"1.0.0\", None, None),\n     /// Allows `#[deprecated]` attribute."}, {"sha": "a616dd70f8e6ddb2e216ce73a9e97dde707f75a4", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -368,8 +368,6 @@ declare_features! (\n     (active, debugger_visualizer, \"1.62.0\", Some(95939), None),\n     /// Allows declarative macros 2.0 (`macro`).\n     (active, decl_macro, \"1.17.0\", Some(39412), None),\n-    /// Allows rustc to inject a default alloc_error_handler\n-    (active, default_alloc_error_handler, \"1.48.0\", Some(66741), None),\n     /// Allows default type parameters to influence type inference.\n     (active, default_type_parameter_fallback, \"1.3.0\", Some(27336), None),\n     /// Allows using `#[deprecated_safe]` to deprecate the safeness of a function or trait"}, {"sha": "434f0a53b7866aed46efe8e4668653842cac157e", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -164,7 +164,7 @@\n //!     fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n //!         dot::Id::new(format!(\"N{}\", n)).unwrap()\n //!     }\n-//!     fn node_label<'b>(&'b self, n: &Nd) -> dot::LabelText<'b> {\n+//!     fn node_label(&self, n: &Nd) -> dot::LabelText<'_> {\n //!         dot::LabelText::LabelStr(self.nodes[*n].into())\n //!     }\n //!     fn edge_label<'b>(&'b self, _: &Ed) -> dot::LabelText<'b> {"}, {"sha": "03bcaa6946825baac7073958262ddd75f7bd3bf2", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -138,7 +138,7 @@ rustc_index::newtype_index! {\n     /// an \"item-like\" to something else can be implemented by a `Vec` instead of a\n     /// tree or hash map.\n     #[derive(HashStable_Generic)]\n-    pub struct ItemLocalId { .. }\n+    pub struct ItemLocalId {}\n }\n \n impl ItemLocalId {"}, {"sha": "038509031b180a3cd42417a23846ff36c00ea7c0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -286,9 +286,10 @@ language_item_table! {\n \n     // FIXME(swatinem): the following lang items are used for async lowering and\n     // should become obsolete eventually.\n+    ResumeTy,                sym::ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n     IdentityFuture,          sym::identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n+    GetContext,              sym::get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n \n-    Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n     FromFrom,                sym::from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;"}, {"sha": "c29a3afd7fba876896d006e2b0fb45407d1a3f8c", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -26,11 +26,9 @@ use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n-use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n-use rustc_middle::ty::{\n-    self, Const, DefIdTree, EarlyBinder, IsSuggestable, Ty, TyCtxt, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{DynKind, EarlyBinder};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -490,7 +488,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.astconv\n                                 .normalize_ty(\n                                     self.span,\n-                                    EarlyBinder(tcx.at(self.span).type_of(param.def_id))\n+                                    tcx.at(self.span)\n+                                        .bound_type_of(param.def_id)\n                                         .subst(tcx, substs),\n                                 )\n                                 .into()\n@@ -1255,10 +1254,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.normalize_ty(\n-            span,\n-            EarlyBinder(self.tcx().at(span).type_of(did)).subst(self.tcx(), substs),\n-        )\n+        self.normalize_ty(span, self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs))\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n@@ -2240,7 +2236,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ),\n                     \"s\",\n                 ),\n-                [only] => (format!(\"{only}\"), \"\"),\n+                [only] => (only.to_string(), \"\"),\n                 [] => unreachable!(),\n             };\n             let last_span = *arg_spans.last().unwrap();"}, {"sha": "a714663741be72eaf7448eae77b05c45bf4f8aec", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -99,18 +99,17 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n             ty: Ty<'tcx>,\n             tcx: TyCtxt<'tcx>,\n             param_env: ty::ParamEnv<'tcx>,\n-            span: Span,\n         ) -> bool {\n             // We don't just accept all !needs_drop fields, due to semver concerns.\n             match ty.kind() {\n                 ty::Ref(..) => true, // references never drop (even mutable refs, which are non-Copy and hence fail the later check)\n                 ty::Tuple(tys) => {\n                     // allow tuples of allowed types\n-                    tys.iter().all(|ty| allowed_union_field(ty, tcx, param_env, span))\n+                    tys.iter().all(|ty| allowed_union_field(ty, tcx, param_env))\n                 }\n                 ty::Array(elem, _len) => {\n                     // Like `Copy`, we do *not* special-case length 0.\n-                    allowed_union_field(*elem, tcx, param_env, span)\n+                    allowed_union_field(*elem, tcx, param_env)\n                 }\n                 _ => {\n                     // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n@@ -124,7 +123,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n         for field in &def.non_enum_variant().fields {\n             let field_ty = field.ty(tcx, substs);\n \n-            if !allowed_union_field(field_ty, tcx, param_env, span) {\n+            if !allowed_union_field(field_ty, tcx, param_env) {\n                 let (field_span, ty_span) = match tcx.hir().get_if_local(field.did) {\n                     // We are currently checking the type this field came from, so it must be local.\n                     Some(Node::Field(field)) => (field.span, field.ty.span),\n@@ -163,7 +162,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n }\n \n /// Check that a `static` is inhabited.\n-fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     // Make sure statics are inhabited.\n     // Other parts of the compiler assume that there are no uninhabited places. In principle it\n     // would be enough to check this for `extern` statics, as statics with an initializer will\n@@ -213,7 +212,7 @@ fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n \n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n-fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n+fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     let item = tcx.hir().item(id);\n     let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n         tcx.sess.delay_span_bug(tcx.hir().span(id.hir_id()), \"expected opaque item\");\n@@ -246,8 +245,8 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n #[instrument(level = \"debug\", skip(tcx, span))]\n-pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(super) fn check_opaque_for_inheriting_lifetimes(\n+    tcx: TyCtxt<'_>,\n     def_id: LocalDefId,\n     span: Span,\n ) {\n@@ -497,7 +496,7 @@ fn is_enum_of_nonnullable_ptr<'tcx>(\n     matches!(field.ty(tcx, substs).kind(), ty::FnPtr(..) | ty::Ref(..))\n }\n \n-fn check_static_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+fn check_static_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     if tcx.codegen_fn_attrs(def_id).import_linkage.is_some() {\n         if match tcx.type_of(def_id).kind() {\n             ty::RawPtr(_) => false,\n@@ -509,7 +508,7 @@ fn check_static_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     }\n }\n \n-fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n+fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n         id.owner_id,\n@@ -1161,7 +1160,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>)\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+fn check_enum(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n "}, {"sha": "c6bda9b46410edbeb539aeb31b40bf17d601f45b", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -71,8 +71,14 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n-    {\n+    if let Err(_) = compare_predicate_entailment(\n+        tcx,\n+        impl_m,\n+        impl_m_span,\n+        trait_m,\n+        impl_trait_ref,\n+        CheckImpliedWfMode::Check,\n+    ) {\n         return;\n     }\n }\n@@ -150,6 +156,7 @@ fn compare_predicate_entailment<'tcx>(\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n+    check_implied_wf: CheckImpliedWfMode,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -255,15 +262,15 @@ fn compare_predicate_entailment<'tcx>(\n \n     let mut wf_tys = FxIndexSet::default();\n \n-    let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n+    let unnormalized_impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n         impl_m_span,\n         infer::HigherRankedType,\n         tcx.fn_sig(impl_m.def_id),\n     );\n+    let unnormalized_impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(unnormalized_impl_sig));\n \n     let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n-    let impl_sig = ocx.normalize(&norm_cause, param_env, impl_sig);\n-    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+    let impl_fty = ocx.normalize(&norm_cause, param_env, unnormalized_impl_fty);\n     debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n     let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n@@ -304,29 +311,108 @@ fn compare_predicate_entailment<'tcx>(\n         return Err(emitted);\n     }\n \n+    if check_implied_wf == CheckImpliedWfMode::Check {\n+        // We need to check that the impl's args are well-formed given\n+        // the hybrid param-env (impl + trait method where-clauses).\n+        ocx.register_obligation(traits::Obligation::new(\n+            infcx.tcx,\n+            ObligationCause::dummy(),\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n+        ));\n+    }\n+    let emit_implied_wf_lint = || {\n+        infcx.tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+            impl_m_hir_id,\n+            infcx.tcx.def_span(impl_m.def_id),\n+            \"impl method assumes more implied bounds than the corresponding trait method\",\n+            |lint| lint,\n+        );\n+    };\n+\n     // Check that all obligations are satisfied by the implementation's\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-        return Err(reported);\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                return Err(reported);\n+            }\n+        }\n     }\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n     );\n-    infcx.check_region_obligations_and_report_errors(\n-        impl_m.def_id.expect_local(),\n-        &outlives_environment,\n+    infcx.process_registered_region_obligations(\n+        outlives_env.region_bound_pairs(),\n+        outlives_env.param_env,\n     );\n+    let errors = infcx.resolve_regions(&outlives_env);\n+    if !errors.is_empty() {\n+        // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n+        // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                if infcx.tainted_by_errors().is_none() {\n+                    infcx.err_ctxt().report_region_errors(impl_m.def_id.expect_local(), &errors);\n+                }\n+                return Err(tcx\n+                    .sess\n+                    .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"));\n+            }\n+        }\n+    }\n \n     Ok(())\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+enum CheckImpliedWfMode {\n+    /// Checks implied well-formedness of the impl method. If it fails, we will\n+    /// re-check with `Skip`, and emit a lint if it succeeds.\n+    Check,\n+    /// Skips checking implied well-formedness of the impl method, but will emit\n+    /// a lint if the `compare_predicate_entailment` succeeded. This means that\n+    /// the reason that we had failed earlier during `Check` was due to the impl\n+    /// having stronger requirements than the trait.\n+    Skip,\n+}\n+\n fn compare_asyncness<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -405,6 +491,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n             tcx.fn_sig(impl_m.def_id),\n         ),\n     );\n+    impl_sig.error_reported()?;\n     let impl_return_ty = impl_sig.output();\n \n     // Normalize the trait signature with liberated bound vars, passing it through\n@@ -419,6 +506,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         )\n         .fold_with(&mut collector);\n     let trait_sig = ocx.normalize(&norm_cause, param_env, unnormalized_trait_sig);\n+    trait_sig.error_reported()?;\n     let trait_return_ty = trait_sig.output();\n \n     let wf_tys = FxIndexSet::from_iter(\n@@ -1429,8 +1517,8 @@ fn compare_generic_param_kinds<'tcx>(\n }\n \n /// Use `tcx.compare_assoc_const_impl_item_with_trait_item` instead\n-pub(crate) fn raw_compare_const_impl<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn raw_compare_const_impl(\n+    tcx: TyCtxt<'_>,\n     (impl_const_item_def, trait_const_item_def): (LocalDefId, DefId),\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_const_item = tcx.associated_item(impl_const_item_def);"}, {"sha": "598dc2dca5c6288b88eab85e96c9f95d0de8fa1b", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -75,7 +75,7 @@ pub fn intrinsic_operation_unsafety(tcx: TyCtxt<'_>, intrinsic_id: DefId) -> hir\n         sym::abort\n         | sym::assert_inhabited\n         | sym::assert_zero_valid\n-        | sym::assert_uninit_valid\n+        | sym::assert_mem_uninitialized_valid\n         | sym::size_of\n         | sym::min_align_of\n         | sym::needs_drop\n@@ -193,9 +193,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n             sym::rustc_peek => (1, vec![param(0)], param(0)),\n             sym::caller_location => (0, vec![], tcx.caller_location_ty()),\n-            sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n-                (1, Vec::new(), tcx.mk_unit())\n-            }\n+            sym::assert_inhabited\n+            | sym::assert_zero_valid\n+            | sym::assert_mem_uninitialized_valid => (1, Vec::new(), tcx.mk_unit()),\n             sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n             sym::transmute => (2, vec![param(0)], param(1)),\n             sym::prefetch_read_data"}, {"sha": "ed2aed293a7710218016b653a028db52f5a9ff9d", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -115,10 +115,10 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n \n /// Given a `DefId` for an opaque type in return position, find its parent item's return\n /// expressions.\n-fn get_owner_return_paths<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn get_owner_return_paths(\n+    tcx: TyCtxt<'_>,\n     def_id: LocalDefId,\n-) -> Option<(LocalDefId, ReturnsVisitor<'tcx>)> {\n+) -> Option<(LocalDefId, ReturnsVisitor<'_>)> {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_id = tcx.hir().get_parent_item(hir_id).def_id;\n     tcx.hir().find_by_def_id(parent_id).and_then(|node| node.body_id()).map(|body_id| {"}, {"sha": "aedc736b023939f3f8b8d72cde6412d7ccb668c6", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1673,7 +1673,7 @@ fn check_method_receiver<'tcx>(\n     }\n }\n \n-fn e0307<'tcx>(tcx: TyCtxt<'tcx>, span: Span, receiver_ty: Ty<'_>) {\n+fn e0307(tcx: TyCtxt<'_>, span: Span, receiver_ty: Ty<'_>) {\n     struct_span_err!(\n         tcx.sess.diagnostic(),\n         span,"}, {"sha": "2790d91572becae4c81abe75a32371ce804ff0d2", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -171,7 +171,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     }\n }\n \n-fn visit_implementation_of_coerce_unsized<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) {\n+fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\", impl_did);\n \n     // Just compute this for the side-effects, in particular reporting\n@@ -181,7 +181,7 @@ fn visit_implementation_of_coerce_unsized<'tcx>(tcx: TyCtxt<'tcx>, impl_did: Loc\n     tcx.at(span).coerce_unsized_info(impl_did);\n }\n \n-fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) {\n+fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n     let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);"}, {"sha": "a9331af4eab32f622d7ccec1340604df7faa32b9", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -198,10 +198,10 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             // entire graph when there are many connected regions.\n \n             rustc_index::newtype_index! {\n-                pub struct RegionId {\n-                    ENCODABLE = custom\n-                }\n+                #[custom_encodable]\n+                pub struct RegionId {}\n             }\n+\n             struct ConnectedRegion {\n                 idents: SmallVec<[Symbol; 8]>,\n                 impl_blocks: FxHashSet<usize>,"}, {"sha": "c6d4aeefc80e5e7883862065b6b6fe5fd63ba6d0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -184,11 +184,19 @@ fn emit_orphan_check_error<'tcx>(\n                     ty::Adt(def, _) => tcx.mk_adt(*def, ty::List::empty()),\n                     _ => ty,\n                 };\n-                let this = \"this\".to_string();\n-                let (ty, postfix) = match &ty.kind() {\n-                    ty::Slice(_) => (this, \" because slices are always foreign\"),\n-                    ty::Array(..) => (this, \" because arrays are always foreign\"),\n-                    ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n+                let msg = |ty: &str, postfix: &str| {\n+                    format!(\"{ty} is not defined in the current crate{postfix}\")\n+                };\n+                let this = |name: &str| msg(\"this\", &format!(\" because {name} are always foreign\"));\n+                let msg = match &ty.kind() {\n+                    ty::Slice(_) => this(\"slices\"),\n+                    ty::Array(..) => this(\"arrays\"),\n+                    ty::Tuple(..) => this(\"tuples\"),\n+                    ty::Alias(ty::Opaque, ..) => {\n+                        \"type alias impl trait is treated as if it were foreign, \\\n+                        because its hidden type could be from a foreign crate\"\n+                            .to_string()\n+                    }\n                     ty::RawPtr(ptr_ty) => {\n                         emit_newtype_suggestion_for_raw_ptr(\n                             full_impl_span,\n@@ -198,12 +206,11 @@ fn emit_orphan_check_error<'tcx>(\n                             &mut err,\n                         );\n \n-                        (format!(\"`{}`\", ty), \" because raw pointers are always foreign\")\n+                        msg(&format!(\"`{ty}`\"), \" because raw pointers are always foreign\")\n                     }\n-                    _ => (format!(\"`{}`\", ty), \"\"),\n+                    _ => msg(&format!(\"`{ty}`\"), \"\"),\n                 };\n \n-                let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n                 if is_target_ty {\n                     // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n                     err.span_label(self_ty_span, &msg);"}, {"sha": "b7d599f57fd449136dd6e81d461ac269fba5b5bb", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -839,7 +839,7 @@ fn convert_variant(\n     )\n }\n \n-fn adt_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::AdtDef<'tcx> {\n+fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtDef<'_> {\n     use rustc_hir::*;\n \n     let def_id = def_id.expect_local();"}, {"sha": "b63a8ef698d1843f77021a8197e5c57ee14bd022", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -276,7 +276,7 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n     rl\n }\n \n-fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n+fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n@@ -1018,7 +1018,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn object_lifetime_default<'tcx>(tcx: TyCtxt<'tcx>, param_def_id: DefId) -> ObjectLifetimeDefault {\n+fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifetimeDefault {\n     debug_assert_eq!(tcx.def_kind(param_def_id), DefKind::TyParam);\n     let param_def_id = param_def_id.expect_local();\n     let parent_def_id = tcx.local_parent(param_def_id);"}, {"sha": "0943350e2d47c8431c97132a85fe6f844a356b27", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -318,10 +318,10 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     }\n }\n \n-fn const_evaluatable_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn const_evaluatable_predicates_of(\n+    tcx: TyCtxt<'_>,\n     def_id: LocalDefId,\n-) -> FxIndexSet<(ty::Predicate<'tcx>, Span)> {\n+) -> FxIndexSet<(ty::Predicate<'_>, Span)> {\n     struct ConstCollector<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         preds: FxIndexSet<(ty::Predicate<'tcx>, Span)>,"}, {"sha": "b60fc276178b396204208118750ca7434fa54976", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -157,11 +157,11 @@ fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node,\n /// ```\n ///\n /// Would return `S1 = [C]` and `S2 = [Vec<C>, C]`.\n-fn get_impl_substs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn get_impl_substs(\n+    tcx: TyCtxt<'_>,\n     impl1_def_id: LocalDefId,\n     impl2_node: Node,\n-) -> Option<(SubstsRef<'tcx>, SubstsRef<'tcx>)> {\n+) -> Option<(SubstsRef<'_>, SubstsRef<'_>)> {\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n     let param_env = tcx.param_env(impl1_def_id);"}, {"sha": "a46f2a94cd281a17006d5cb2a6be6332eaabb661", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -13,9 +13,9 @@ use super::utils::*;\n /// `global_inferred_outlives`: this is initially the empty map that\n ///     was generated by walking the items in the crate. This will\n ///     now be filled with inferred predicates.\n-pub(super) fn infer_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-) -> FxHashMap<DefId, ty::EarlyBinder<RequiredPredicates<'tcx>>> {\n+pub(super) fn infer_predicates(\n+    tcx: TyCtxt<'_>,\n+) -> FxHashMap<DefId, ty::EarlyBinder<RequiredPredicates<'_>>> {\n     debug!(\"infer_predicates\");\n \n     let mut explicit_map = ExplicitPredicatesMap::new();"}, {"sha": "af14ee08a9981bd187a89ee1bdb1365a053a7aaa", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -4,7 +4,7 @@ use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n \n use crate::type_error_struct;\n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n@@ -399,6 +399,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n+                for arg in arg_exprs {\n+                    self.check_expr(arg);\n+                }\n+\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = &callee_expr.kind\n                     && let [segment] = path.segments\n                     && let Some(mut diag) = self\n@@ -424,21 +428,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n-\n-                // This is the \"default\" function signature, used in case of error.\n-                // In that case, we check each argument against \"error\" in order to\n-                // set up all the node type bindings.\n-                (\n-                    ty::Binder::dummy(self.tcx.mk_fn_sig(\n-                        self.err_args(arg_exprs.len()).into_iter(),\n-                        self.tcx.ty_error(),\n-                        false,\n-                        hir::Unsafety::Normal,\n-                        abi::Abi::Rust,\n-                    )),\n-                    None,\n-                )\n+                let err = self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n+\n+                return self.tcx.ty_error_with_guaranteed(err);\n             }\n         };\n \n@@ -498,7 +490,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         if let [callee_expr, rest @ ..] = arg_exprs {\n-            let callee_ty = self.check_expr(callee_expr);\n+            let callee_ty = self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr)?;\n+\n             // First, do a probe with `IsSuggestion(true)` to avoid emitting\n             // any strange errors. If it's successful, then we'll do a true\n             // method lookup.\n@@ -591,7 +584,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         callee_expr: &'tcx hir::Expr<'tcx>,\n         callee_ty: Ty<'tcx>,\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let mut unit_variant = None;\n         if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n             && let Res::Def(def::DefKind::Ctor(kind, CtorKind::Const), _)\n@@ -720,7 +713,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_label(span, label);\n             }\n         }\n-        err.emit();\n+        err.emit()\n     }\n \n     fn confirm_deferred_closure_call("}, {"sha": "042a50f2fd42eb89906167fde85ed9b0e4eb1622", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -847,13 +847,15 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            (_, DynStar) | (DynStar, _) => {\n+            (_, DynStar) => {\n                 if fcx.tcx.features().dyn_star {\n                     bug!(\"should be handled by `try_coerce`\")\n                 } else {\n                     Err(CastError::IllegalCast)\n                 }\n             }\n+\n+            (DynStar, _) => Err(CastError::IllegalCast),\n         }\n     }\n "}, {"sha": "b0cd4a16e9869270546b1a485cb0479ddd7b7626", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -118,7 +118,7 @@ fn identity(_: Ty<'_>) -> Vec<Adjustment<'_>> {\n     vec![]\n }\n \n-fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>> {\n+fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'_>> {\n     move |target| vec![Adjustment { kind, target }]\n }\n \n@@ -1548,7 +1548,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             cause,\n                             expected,\n                             found,\n-                            coercion_error.clone(),\n+                            coercion_error,\n                             fcx,\n                             parent_id,\n                             expression,\n@@ -1567,7 +1567,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             cause,\n                             expected,\n                             found,\n-                            coercion_error.clone(),\n+                            coercion_error,\n                             fcx,\n                             id,\n                             expression,\n@@ -1583,7 +1583,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             cause,\n                             expected,\n                             found,\n-                            coercion_error.clone(),\n+                            coercion_error,\n                         );\n                     }\n                 }"}, {"sha": "e68bd1297c87865d58574f933ec4b5e138d885ad", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -23,24 +23,24 @@ use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn emit_coerce_suggestions(\n+    pub fn emit_type_mismatch_suggestions(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        error: Option<TypeError<'tcx>>,\n+        _error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n-        self.annotate_expected_due_to_let_ty(err, expr, error);\n-\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_compatible_variants(err, expr, expected, expr_ty)\n             || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n             || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n@@ -49,9 +49,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+    }\n \n+    pub fn emit_coerce_suggestions(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        if expr_ty == expected {\n+            return;\n+        }\n+\n+        self.annotate_expected_due_to_let_ty(err, expr, error);\n+        self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n@@ -163,7 +178,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_vars_with_obligations(checked_ty);\n-        let mut err = self.err_ctxt().report_mismatched_types(&cause, expected, expr_ty, e.clone());\n+        let mut err = self.err_ctxt().report_mismatched_types(&cause, expected, expr_ty, e);\n \n         let is_insufficiently_polymorphic =\n             matches!(e, TypeError::RegionsInsufficientlyPolymorphic(..));\n@@ -406,7 +421,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n \n                     let note_about_variant_field_privacy = (field_is_local && !field_is_accessible)\n-                        .then(|| format!(\" (its field is private, but it's local to this crate and its privacy can be changed)\"));\n+                        .then(|| \" (its field is private, but it's local to this crate and its privacy can be changed)\".to_string());\n \n                     let sole_field_ty = sole_field.ty(self.tcx, substs);\n                     if self.can_coerce(expr_ty, sole_field_ty) {\n@@ -1275,7 +1290,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         match (&expected_ty.kind(), &checked_ty.kind()) {\n-            (&ty::Int(ref exp), &ty::Int(ref found)) => {\n+            (ty::Int(exp), ty::Int(found)) => {\n                 let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n                 {\n                     (Some(exp), Some(found)) if exp < found => (true, false),\n@@ -1288,7 +1303,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n+            (ty::Uint(exp), ty::Uint(found)) => {\n                 let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n                 {\n                     (Some(exp), Some(found)) if exp < found => (true, false),\n@@ -1321,7 +1336,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Float(ref found)) => {\n+            (ty::Float(exp), ty::Float(found)) => {\n                 if found.bit_width() < exp.bit_width() {\n                     suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n@@ -1357,7 +1372,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Uint(ref found)) => {\n+            (ty::Float(exp), ty::Uint(found)) => {\n                 // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n@@ -1386,7 +1401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 true\n             }\n-            (&ty::Float(ref exp), &ty::Int(ref found)) => {\n+            (ty::Float(exp), ty::Int(found)) => {\n                 // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose("}, {"sha": "ae641b26eeedbb48898bb1019e747c217b57833a", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -104,16 +104,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // FIXME(compiler-errors): We probably should fold some of the\n-            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n-            // since some of those aren't necessarily just coerce suggestions.\n-            let _ = self.suggest_deref_ref_or_into(\n+            let _ = self.emit_type_mismatch_suggestions(\n                 &mut err,\n                 expr.peel_drop_temps(),\n-                expected_ty,\n                 ty,\n+                expected_ty,\n                 None,\n-            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n+                None,\n+            );\n             extend_err(&mut err);\n             err.emit();\n         }\n@@ -1874,7 +1872,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // I don't use 'is_range_literal' because only double-sided, half-open ranges count.\n         if let ExprKind::Struct(\n                 QPath::LangItem(LangItem::Range, ..),\n-                &[ref range_start, ref range_end],\n+                [range_start, range_end],\n                 _,\n             ) = last_expr_field.expr.kind\n             && let variant_field ="}, {"sha": "7774ffc9b9793ea8ac6a93a0e41b9ca196514a71", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -756,8 +756,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n     fn walk_captures(&mut self, closure_expr: &hir::Closure<'_>) {\n-        fn upvar_is_local_variable<'tcx>(\n-            upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n+        fn upvar_is_local_variable(\n+            upvars: Option<&FxIndexMap<hir::HirId, hir::Upvar>>,\n             upvar_id: hir::HirId,\n             body_owner_is_closure: bool,\n         ) -> bool {"}, {"sha": "150e917c73988bef7126b16ede746d8a60b20eec", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, UserType,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -333,22 +333,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Basically whenever we are converting from a type scheme into\n-    /// the fn body space, we always want to normalize associated\n-    /// types as well. This function combines the two.\n-    fn instantiate_type_scheme<T>(&self, span: Span, substs: SubstsRef<'tcx>, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"instantiate_type_scheme(value={:?}, substs={:?})\", value, substs);\n-        let value = EarlyBinder(value).subst(self.tcx, substs);\n-        let result = self.normalize(span, value);\n-        debug!(\"instantiate_type_scheme = {:?}\", result);\n-        result\n-    }\n-\n-    /// As `instantiate_type_scheme`, but for the bounds found in a\n-    /// generic type scheme.\n+    /// Instantiates and normalizes the bounds for a given item\n     pub(in super::super) fn instantiate_bounds(\n         &self,\n         span: Span,\n@@ -1160,10 +1145,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let def_id = res.def_id();\n \n-        // The things we are substituting into the type should not contain\n-        // escaping late-bound regions, and nor should the base type scheme.\n-        let ty = tcx.type_of(def_id);\n-\n         let arg_count = GenericArgCountResult {\n             explicit_late_bound,\n             correct: if infer_args_for_err.is_empty() {\n@@ -1286,8 +1267,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 },\n             )\n         });\n-        assert!(!substs.has_escaping_bound_vars());\n-        assert!(!ty.has_escaping_bound_vars());\n \n         // First, store the \"user substs\" for later.\n         self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n@@ -1296,17 +1275,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Substitute the values for the type parameters into the type of\n         // the referenced item.\n-        let ty_substituted = self.instantiate_type_scheme(span, &substs, ty);\n+        let ty = tcx.bound_type_of(def_id);\n+        assert!(!substs.has_escaping_bound_vars());\n+        assert!(!ty.0.has_escaping_bound_vars());\n+        let ty_substituted = self.normalize(span, ty.subst(tcx, substs));\n \n         if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter; instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n             // This also occurs for an enum variant on a type alias.\n-            let ty = tcx.type_of(impl_def_id);\n-\n-            let impl_ty = self.instantiate_type_scheme(span, &substs, ty);\n+            let impl_ty = self.normalize(span, tcx.bound_type_of(impl_def_id).subst(tcx, substs));\n             match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {"}, {"sha": "6f26afcaf1680abfd0bc4c4a4e80dd4a86be7023", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -4,15 +4,13 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::ty::error::TypeError;\n \n rustc_index::newtype_index! {\n-    pub(crate) struct ExpectedIdx {\n-        DEBUG_FORMAT = \"ExpectedIdx({})\",\n-    }\n+    #[debug_format = \"ExpectedIdx({})\"]\n+    pub(crate) struct ExpectedIdx {}\n }\n \n rustc_index::newtype_index! {\n-    pub(crate) struct ProvidedIdx {\n-        DEBUG_FORMAT = \"ProvidedIdx({})\",\n-    }\n+    #[debug_format = \"ProvidedIdx({})\"]\n+    pub(crate) struct ProvidedIdx {}\n }\n \n impl ExpectedIdx {"}, {"sha": "877680053f09061e3966a480f9ad5b68ae5bbe12", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty, TypeSuperVisitable, TypeVisitor};\n use rustc_session::Session;\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, sym, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n@@ -214,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n-                    .delay_as_bug();\n+                    .emit();\n                     (self.err_args(provided_args.len()), None)\n                 }\n             }\n@@ -1013,7 +1013,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } else {\n                                 args_span\n                             };\n-                            labels.push((span, format!(\"multiple arguments are missing\")));\n+                            labels.push((span, \"multiple arguments are missing\".to_string()));\n                             suggestion_text = match suggestion_text {\n                                 SuggestionText::None | SuggestionText::Provide(_) => {\n                                     SuggestionText::Provide(true)\n@@ -1141,6 +1141,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"()\".to_string()\n                     } else if expected_ty.is_suggestable(tcx, false) {\n                         format!(\"/* {} */\", expected_ty)\n+                    } else if let Some(fn_def_id) = fn_def_id\n+                        && self.tcx.def_kind(fn_def_id).is_fn_like()\n+                        && let self_implicit = matches!(call_expr.kind, hir::ExprKind::MethodCall(..)) as usize\n+                        && let Some(arg) = self.tcx.fn_arg_names(fn_def_id).get(expected_idx.as_usize() + self_implicit)\n+                        && arg.name != kw::SelfLower\n+                    {\n+                        format!(\"/* {} */\", arg.name)\n                     } else {\n                         \"/* value */\".to_string()\n                     }"}, {"sha": "efec0244633340e6947783902d2b1db102ba1bea", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 87, "deletions": 11, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,6 +1,7 @@\n use super::FnCtxt;\n \n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n+use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -15,10 +16,11 @@ use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+    TypeVisitable,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n-use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -319,11 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            err.multipart_suggestion_verbose(\n-                format!(\"use parentheses to call these\"),\n-                sugg,\n-                applicability,\n-            );\n+            err.multipart_suggestion_verbose(\"use parentheses to call these\", sugg, applicability);\n \n             true\n         } else {\n@@ -754,7 +752,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return true\n                 }\n             }\n-            &hir::FnRetTy::Return(ref ty) => {\n+            hir::FnRetTy::Return(ty) => {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n@@ -1128,9 +1126,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let cond_parent = hir.parent_iter(expr.hir_id).skip_while(|(_, node)| {\n-            matches!(node, hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, _, _), .. }) if op.node == hir::BinOpKind::And)\n-        }).next();\n+        let cond_parent = hir.parent_iter(expr.hir_id).find(|(_, node)| {\n+            !matches!(node, hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, _, _), .. }) if op.node == hir::BinOpKind::And)\n+        });\n         // Don't suggest:\n         //     `let Some(_) = a.is_some() && b`\n         //                     ++++++++++\n@@ -1240,6 +1238,84 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn suggest_associated_const(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let Some((DefKind::AssocFn, old_def_id)) = self.typeck_results.borrow().type_dependent_def(expr.hir_id) else {\n+            return false;\n+        };\n+        let old_item_name = self.tcx.item_name(old_def_id);\n+        let capitalized_name = Symbol::intern(&old_item_name.as_str().to_uppercase());\n+        if old_item_name == capitalized_name {\n+            return false;\n+        }\n+        let (item, segment) = match expr.kind {\n+            hir::ExprKind::Path(QPath::Resolved(\n+                Some(ty),\n+                hir::Path { segments: [segment], .. },\n+            ))\n+            | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n+                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                if let Ok(pick) = self.probe_for_name(\n+                    Mode::Path,\n+                    Ident::new(capitalized_name, segment.ident.span),\n+                    IsSuggestion(true),\n+                    self_ty,\n+                    expr.hir_id,\n+                    ProbeScope::TraitsInScope,\n+                ) {\n+                    (pick.item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            hir::ExprKind::Path(QPath::Resolved(\n+                None,\n+                hir::Path { segments: [.., segment], .. },\n+            )) => {\n+                // we resolved through some path that doesn't end in the item name,\n+                // better not do a bad suggestion by accident.\n+                if old_item_name != segment.ident.name {\n+                    return false;\n+                }\n+                if let Some(item) = self\n+                    .tcx\n+                    .associated_items(self.tcx.parent(old_def_id))\n+                    .filter_by_name_unhygienic(capitalized_name)\n+                    .next()\n+                {\n+                    (*item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            _ => return false,\n+        };\n+        if item.def_id == old_def_id || self.tcx.def_kind(item.def_id) != DefKind::AssocConst {\n+            // Same item\n+            return false;\n+        }\n+        let item_ty = self.tcx.type_of(item.def_id);\n+        // FIXME(compiler-errors): This check is *so* rudimentary\n+        if item_ty.needs_subst() {\n+            return false;\n+        }\n+        if self.can_coerce(item_ty, expected_ty) {\n+            err.span_suggestion_verbose(\n+                segment.ident.span,\n+                format!(\"try referring to the associated const `{capitalized_name}` instead\",),\n+                capitalized_name,\n+                Applicability::MachineApplicable,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "16806fdba4fbc2113c766be2ed489c032b5f1fda", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -233,6 +233,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             self.tcx()\n                 .sess\n                 .delay_span_bug(expr.span, format!(\"could not resolve infer vars in `{ty}`\"));\n+            return;\n         }\n         let ty = self.tcx().erase_regions(ty);\n         let m = self.tcx().parent_module(expr.hir_id).to_def_id();"}, {"sha": "f7b493bc2242bd4b8bdd2141fbbfb27515980013", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -79,7 +79,7 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n /// result of `foo`. On the other hand, if `place` points to `x` then `f` will\n /// be called both on the `ExprKind::Path` node that represents the expression\n /// as well as the HirId of the local `x` itself.\n-fn for_each_consumable<'tcx>(hir: Map<'tcx>, place: TrackedValue, mut f: impl FnMut(TrackedValue)) {\n+fn for_each_consumable(hir: Map<'_>, place: TrackedValue, mut f: impl FnMut(TrackedValue)) {\n     f(place);\n     let node = hir.find(place.hir_id());\n     if let Some(Node::Expr(expr)) = node {\n@@ -96,15 +96,13 @@ fn for_each_consumable<'tcx>(hir: Map<'tcx>, place: TrackedValue, mut f: impl Fn\n }\n \n rustc_index::newtype_index! {\n-    pub struct PostOrderId {\n-        DEBUG_FORMAT = \"id({})\",\n-    }\n+    #[debug_format = \"id({})\"]\n+    pub struct PostOrderId {}\n }\n \n rustc_index::newtype_index! {\n-    pub struct TrackedValueIndex {\n-        DEBUG_FORMAT = \"hidx({})\",\n-    }\n+    #[debug_format = \"hidx({})\"]\n+    pub struct TrackedValueIndex {}\n }\n \n /// Identifies a value whose drop state we need to track."}, {"sha": "e4ac91befac610e8f71729bf7be89dacf1ababff", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -607,10 +607,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         ty::Tuple(fields) => {\n             let mut has_emitted = false;\n             let comps = match data.expr.map(|e| &e.kind) {\n-                Some(hir::ExprKind::Tup(comps)) => {\n-                    debug_assert_eq!(comps.len(), fields.len());\n-                    Some(comps)\n-                }\n+                Some(hir::ExprKind::Tup(comps)) if comps.len() == fields.len() => Some(comps),\n                 _ => None,\n             };\n             for (i, ty) in fields.iter().enumerate() {"}, {"sha": "b06927f9662be7aeb09882ab6b7ec860a1a94061", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -462,8 +462,8 @@ fn fatally_break_rust(sess: &Session) {\n     ));\n }\n \n-fn has_expected_num_generic_args<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn has_expected_num_generic_args(\n+    tcx: TyCtxt<'_>,\n     trait_did: Option<DefId>,\n     expected: usize,\n ) -> bool {"}, {"sha": "fddb8a458a7d5f0716a6ba25f7339849a1196eb4", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -456,9 +456,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n         //\n-        // N.B., instantiate late-bound regions first so that\n-        // `instantiate_type_scheme` can normalize associated types that\n-        // may reference those regions.\n+        // N.B., instantiate late-bound regions before normalizing the\n+        // function signature so that normalization does not need to deal\n+        // with bound regions.\n         let fn_sig = tcx.bound_fn_sig(def_id);\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);"}, {"sha": "7c5a9a333feba56da059e18d4b90b1cf1563db56", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -689,6 +689,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let entry = spanned_predicates.entry(spans);\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n+                            Some(Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n+                                span: item_span,\n+                                ..\n+                            })) => {\n+                                tcx.sess.delay_span_bug(\n+                                        *item_span,\n+                                        \"auto trait is invoked with no method error, but no error reported?\",\n+                                    );\n+                            }\n                             Some(_) => unreachable!(),\n                             None => (),\n                         }\n@@ -997,7 +1007,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n                             err.span_suggestion(\n                                 span,\n-                                &format!(\"there is a method with a similar name\",),\n+                                \"there is a method with a similar name\",\n                                 lev_candidate.name,\n                                 Applicability::MaybeIncorrect,\n                             );"}, {"sha": "9f0d175c4c669870d4edff2499bb79f2490ddb3d", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -904,7 +904,7 @@ enum Op {\n }\n \n /// Dereferences a single level of immutable referencing.\n-fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+fn deref_ty_if_possible(ty: Ty<'_>) -> Ty<'_> {\n     match ty.kind() {\n         ty::Ref(_, ty, hir::Mutability::Not) => *ty,\n         _ => ty,"}, {"sha": "d3e88b1b80ae29a30aec1856320059b54bdbf793", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -2130,7 +2130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n         {\n             let ty = self.resolve_vars_if_possible(ti.expected);\n-            let is_slice_or_array_or_vector = self.is_slice_or_array_or_vector(&mut err, snippet.clone(), ty);\n+            let is_slice_or_array_or_vector = self.is_slice_or_array_or_vector(ty);\n             match is_slice_or_array_or_vector.1.kind() {\n                 ty::Adt(adt_def, _)\n                     if self.tcx.is_diagnostic_item(sym::Option, adt_def.did())\n@@ -2159,17 +2159,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn is_slice_or_array_or_vector(\n-        &self,\n-        err: &mut Diagnostic,\n-        snippet: String,\n-        ty: Ty<'tcx>,\n-    ) -> (bool, Ty<'tcx>) {\n+    fn is_slice_or_array_or_vector(&self, ty: Ty<'tcx>) -> (bool, Ty<'tcx>) {\n         match ty.kind() {\n             ty::Adt(adt_def, _) if self.tcx.is_diagnostic_item(sym::Vec, adt_def.did()) => {\n                 (true, ty)\n             }\n-            ty::Ref(_, ty, _) => self.is_slice_or_array_or_vector(err, snippet, *ty),\n+            ty::Ref(_, ty, _) => self.is_slice_or_array_or_vector(*ty),\n             ty::Slice(..) | ty::Array(..) => (true, ty),\n             _ => (false, ty),\n         }"}, {"sha": "a9347991e7f9899935a361581d47600b8ed777f5", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1675,7 +1675,7 @@ fn apply_capture_kind_on_capture_ty<'tcx>(\n }\n \n /// Returns the Span of where the value with the provided HirId would be dropped\n-fn drop_location_span<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> Span {\n+fn drop_location_span(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> Span {\n     let owner_id = tcx.hir().get_enclosing_scope(hir_id).unwrap();\n \n     let owner_node = tcx.hir().get(owner_id);\n@@ -1843,10 +1843,10 @@ fn restrict_precision_for_drop_types<'a, 'tcx>(\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n-fn restrict_precision_for_unsafe<'tcx>(\n-    mut place: Place<'tcx>,\n+fn restrict_precision_for_unsafe(\n+    mut place: Place<'_>,\n     mut curr_mode: ty::UpvarCapture,\n-) -> (Place<'tcx>, ty::UpvarCapture) {\n+) -> (Place<'_>, ty::UpvarCapture) {\n     if place.base_ty.is_unsafe_ptr() {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n@@ -1876,10 +1876,10 @@ fn restrict_precision_for_unsafe<'tcx>(\n /// - No Index projections are captured, since arrays are captured completely.\n /// - No unsafe block is required to capture `place`\n /// Returns the truncated place and updated capture mode.\n-fn restrict_capture_precision<'tcx>(\n-    place: Place<'tcx>,\n+fn restrict_capture_precision(\n+    place: Place<'_>,\n     curr_mode: ty::UpvarCapture,\n-) -> (Place<'tcx>, ty::UpvarCapture) {\n+) -> (Place<'_>, ty::UpvarCapture) {\n     let (mut place, mut curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n@@ -1904,10 +1904,10 @@ fn restrict_capture_precision<'tcx>(\n }\n \n /// Truncate deref of any reference.\n-fn adjust_for_move_closure<'tcx>(\n-    mut place: Place<'tcx>,\n+fn adjust_for_move_closure(\n+    mut place: Place<'_>,\n     mut kind: ty::UpvarCapture,\n-) -> (Place<'tcx>, ty::UpvarCapture) {\n+) -> (Place<'_>, ty::UpvarCapture) {\n     let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     if let Some(idx) = first_deref {\n@@ -1919,10 +1919,10 @@ fn adjust_for_move_closure<'tcx>(\n \n /// Adjust closure capture just that if taking ownership of data, only move data\n /// from enclosing stack frame.\n-fn adjust_for_non_move_closure<'tcx>(\n-    mut place: Place<'tcx>,\n+fn adjust_for_non_move_closure(\n+    mut place: Place<'_>,\n     mut kind: ty::UpvarCapture,\n-) -> (Place<'tcx>, ty::UpvarCapture) {\n+) -> (Place<'_>, ty::UpvarCapture) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n@@ -2225,10 +2225,10 @@ fn determine_place_ancestry_relation<'tcx>(\n ///     // it is constrained to `'a`\n /// }\n /// ```\n-fn truncate_capture_for_optimization<'tcx>(\n-    mut place: Place<'tcx>,\n+fn truncate_capture_for_optimization(\n+    mut place: Place<'_>,\n     mut curr_mode: ty::UpvarCapture,\n-) -> (Place<'tcx>, ty::UpvarCapture) {\n+) -> (Place<'_>, ty::UpvarCapture) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n     // Find the right-most deref (if any). All the projections that come after this"}, {"sha": "67b4d6d6959f602c042889c168d0047adf2fbd5b", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -249,7 +249,7 @@ fn dump_graph(query: &DepGraphQuery) {\n         // dump a .txt file with just the edges:\n         let txt_path = format!(\"{}.txt\", path);\n         let mut file = BufWriter::new(File::create(&txt_path).unwrap());\n-        for &(ref source, ref target) in &edges {\n+        for (source, target) in &edges {\n             write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n         }\n     }\n@@ -432,10 +432,7 @@ fn walk_between<'q>(\n     }\n }\n \n-fn filter_edges<'q>(\n-    query: &'q DepGraphQuery,\n-    nodes: &FxHashSet<DepKind>,\n-) -> Vec<(DepKind, DepKind)> {\n+fn filter_edges(query: &DepGraphQuery, nodes: &FxHashSet<DepKind>) -> Vec<(DepKind, DepKind)> {\n     let uniq: FxHashSet<_> = query\n         .edges()\n         .into_iter()"}, {"sha": "cb0f0db220d97b6505b46030d497787eb6f53a81", "filename": "compiler/rustc_index/src/vec/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -3,7 +3,10 @@\n // Allows the macro invocation below to work\n use crate as rustc_index;\n \n-rustc_macros::newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n+rustc_macros::newtype_index! {\n+    #[max = 0xFFFF_FFFA]\n+    struct MyIdx {}\n+}\n \n #[test]\n fn index_size_is_optimized() {"}, {"sha": "a722613e3310efacb04b8636609c2dff4772e5c7", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -151,7 +151,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// FIXME: This method should only be used for canonical queries and therefore be private.\n+    ///\n+    /// As the new solver does canonicalization slightly differently, this is also used there\n+    /// for now. This should hopefully change fairly soon.\n+    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow_mut()\n             .opaque_type_storage"}, {"sha": "96a976fb89e0fe8f15fdf680787893d676315771", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -184,7 +184,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n             let text = if br.has_name() {\n                 format!(\"the lifetime `{}` as defined here\", br.name)\n             } else {\n-                format!(\"the anonymous lifetime as defined here\")\n+                \"the anonymous lifetime as defined here\".to_string()\n             };\n             (text, sp)\n         }\n@@ -203,7 +203,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                             sp = param.span;\n                         }\n                         let text = if name == kw::UnderscoreLifetime {\n-                            format!(\"the anonymous lifetime as defined here\")\n+                            \"the anonymous lifetime as defined here\".to_string()\n                         } else {\n                             format!(\"the lifetime `{}` as defined here\", name)\n                         };\n@@ -2199,10 +2199,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n \n-        fn binding_suggestion<'tcx, S: fmt::Display>(\n+        fn binding_suggestion<S: fmt::Display>(\n             err: &mut Diagnostic,\n             type_param_span: Option<(Span, bool)>,\n-            bound_kind: GenericKind<'tcx>,\n+            bound_kind: GenericKind<'_>,\n             sub: S,\n             add_lt_sugg: Option<(Span, String)>,\n         ) {"}, {"sha": "9534bce54ef0e7217fff7b76ba8337eb886093dc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                         );\n                     }\n                     (Some(sub_span), Some(sup_span), _, Some(sup_symbol)) => {\n-                        err.span_note(sub_span, format!(\"the lifetime defined here...\"));\n+                        err.span_note(sub_span, \"the lifetime defined here...\");\n                         err.span_note(\n                             sup_span,\n                             format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n@@ -55,17 +55,11 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n                             sub_span,\n                             format!(\"the lifetime `{sub_symbol}` defined here...\"),\n                         );\n-                        err.span_note(\n-                            sup_span,\n-                            format!(\"...must outlive the lifetime defined here\"),\n-                        );\n+                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n                     }\n                     (Some(sub_span), Some(sup_span), _, _) => {\n-                        err.span_note(sub_span, format!(\"the lifetime defined here...\"));\n-                        err.span_note(\n-                            sup_span,\n-                            format!(\"...must outlive the lifetime defined here\"),\n-                        );\n+                        err.span_note(sub_span, \"the lifetime defined here...\");\n+                        err.span_note(sup_span, \"...must outlive the lifetime defined here\");\n                     }\n                     _ => {}\n                 }"}, {"sha": "da2c6fbc05f576f2a76128878891e828f51c546a", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -488,7 +488,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         // If this empty region is from a universe that can\n                         // name the placeholder, then the placeholder is\n                         // larger; otherwise, the only ancestor is `'static`.\n-                        if a_ui.can_name(placeholder.universe) { true } else { false }\n+                        return a_ui.can_name(placeholder.universe);\n                     }\n                 }\n             }"}, {"sha": "a9ef91db059a1ccf381749b61b61b92407559152", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1693,7 +1693,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n+    ) -> Option<ErrorGuaranteed> {\n         let errors = self.resolve_regions(outlives_env);\n \n         if let None = self.tainted_by_errors() {\n@@ -1704,6 +1704,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             // errors from silly ones.\n             self.report_region_errors(generic_param_scope, &errors);\n         }\n+\n+        (!errors.is_empty()).then(|| {\n+            self.tcx.sess.delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\")\n+        })\n     }\n \n     // [Note-Type-error-reporting]\n@@ -1920,7 +1924,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),\n-            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b)),\n         }\n     }\n "}, {"sha": "47bd1564f0828ab1a36cb97f74d81b3f05143128", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -68,6 +68,7 @@ use crate::infer::{\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::ConstraintCategory;\n@@ -177,7 +178,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         generic_param_scope: LocalDefId,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) {\n+    ) -> Option<ErrorGuaranteed> {\n         self.process_registered_region_obligations(\n             outlives_env.region_bound_pairs(),\n             outlives_env.param_env,"}, {"sha": "40bbec8ddd091da396b17dcb866004b4b10cab20", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -5,7 +5,7 @@ use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::GenericArg;\n-use rustc_middle::ty::{self, EarlyBinder, OutlivesPredicate, SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, OutlivesPredicate, SubstsRef, Ty, TyCtxt};\n \n use smallvec::smallvec;\n \n@@ -304,14 +304,13 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let bounds = tcx.item_bounds(def_id);\n-        trace!(\"{:#?}\", bounds);\n+        let bounds = tcx.bound_item_bounds(def_id);\n+        trace!(\"{:#?}\", bounds.0);\n         bounds\n-            .into_iter()\n+            .subst_iter(tcx, substs)\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())\n-            .map(|b| b.1)\n-            .map(move |r| EarlyBinder(r).subst(tcx, substs))\n+            .map(|OutlivesPredicate(_, r)| r)\n     }\n \n     /// Searches through a predicate list for a predicate `T: 'a`."}, {"sha": "c46edc33ff40ccd13ac18c7fbc43a15a49a6de96", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -357,15 +357,13 @@ impl<'tcx> SccUniverse<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    struct LeakCheckNode {\n-        DEBUG_FORMAT = \"LeakCheckNode({})\"\n-    }\n+    #[debug_format = \"LeakCheckNode({})\"]\n+    struct LeakCheckNode {}\n }\n \n rustc_index::newtype_index! {\n-    struct LeakCheckScc {\n-        DEBUG_FORMAT = \"LeakCheckScc({})\"\n-    }\n+    #[debug_format = \"LeakCheckScc({})\"]\n+    struct LeakCheckScc {}\n }\n \n /// Represents the graph of constraints. For each `R1: R2` constraint we create"}, {"sha": "955c54e85157eb9279ab9f788701fb531a27ccbb", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -87,18 +87,12 @@ impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n \n /// The combined undo log for all the various unification tables. For each change to the storage\n /// for any kind of inference variable, we record an UndoLog entry in the vector here.\n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub(crate) struct InferCtxtUndoLogs<'tcx> {\n     logs: Vec<UndoLog<'tcx>>,\n     num_open_snapshots: usize,\n }\n \n-impl Default for InferCtxtUndoLogs<'_> {\n-    fn default() -> Self {\n-        Self { logs: Default::default(), num_open_snapshots: Default::default() }\n-    }\n-}\n-\n /// The UndoLogs trait defines how we undo a particular kind of action (of type T). We can undo any\n /// action that is convertible into an UndoLog (per the From impls above).\n impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>"}, {"sha": "ac455055b430375ce8aa245d092498ed9a67e199", "filename": "compiler/rustc_infer/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fproject.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> ProjectionCache<'_, 'tcx> {\n     pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>, result: EvaluationResult) {\n         let mut map = self.map();\n         match map.get(&key) {\n-            Some(&ProjectionCacheEntry::NormalizedTy { ref ty, complete: _ }) => {\n+            Some(ProjectionCacheEntry::NormalizedTy { ty, complete: _ }) => {\n                 info!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n                 let mut ty = ty.clone();\n                 if result.must_apply_considering_regions() {"}, {"sha": "1d0c7f5b7a388fab828bc2cfddffcb74da82bda9", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n         self.register_plugins.compute(|| {\n-            let crate_name = self.crate_name()?.peek().clone();\n+            let crate_name = *self.crate_name()?.peek();\n             let krate = self.parse()?.take();\n \n             let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};"}, {"sha": "ff2196d58577c817557e23d497733fbbc7c00f2e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -754,6 +754,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(move_size_limit, Some(4096));\n     tracked!(mutable_noalias, Some(true));\n     tracked!(no_generate_arange_section, true);\n+    tracked!(no_jump_tables, true);\n     tracked!(no_link, true);\n     tracked!(no_profiler_runtime, true);\n     tracked!(no_unique_section_names, true);"}, {"sha": "d6de6e70ead808a888d8a56a611a424c3f36e2f4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -25,6 +25,7 @@ use crate::{\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n+use hir::IsAsync;\n use rustc_ast::attr;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n@@ -40,7 +41,10 @@ use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, Gate\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::{ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin};\n+use rustc_hir::intravisit::FnKind as HirFnKind;\n+use rustc_hir::{\n+    Body, FnDecl, ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin,\n+};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -270,7 +274,7 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                             |lint| {\n                                 let suggested_ident =\n                                     format!(\"{}{}\", binding_annot.prefix_str(), ident);\n-                                lint.set_arg(\"ident\", ident.clone()).span_suggestion(\n+                                lint.set_arg(\"ident\", ident).span_suggestion(\n                                     fieldpat.span,\n                                     fluent::suggestion,\n                                     suggested_ident,\n@@ -1370,6 +1374,72 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n     }\n }\n \n+declare_lint! {\n+    /// The `ungated_async_fn_track_caller` lint warns when the\n+    /// `#[track_caller]` attribute is used on an async function, method, or\n+    /// closure, without enabling the corresponding unstable feature flag.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[track_caller]\n+    /// async fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The attribute must be used in conjunction with the\n+    /// [`closure_track_caller` feature flag]. Otherwise, the `#[track_caller]`\n+    /// annotation will function as as no-op.\n+    ///\n+    /// [`closure_track_caller` feature flag]: https://doc.rust-lang.org/beta/unstable-book/language-features/closure-track-caller.html\n+    UNGATED_ASYNC_FN_TRACK_CALLER,\n+    Warn,\n+    \"enabling track_caller on an async fn is a no-op unless the closure_track_caller feature is enabled\"\n+}\n+\n+declare_lint_pass!(\n+    /// Explains corresponding feature flag must be enabled for the `#[track_caller] attribute to\n+    /// do anything\n+    UngatedAsyncFnTrackCaller => [UNGATED_ASYNC_FN_TRACK_CALLER]\n+);\n+\n+impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        fn_kind: HirFnKind<'_>,\n+        _: &'tcx FnDecl<'_>,\n+        _: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if fn_kind.asyncness() == IsAsync::Async\n+            && !cx.tcx.features().closure_track_caller\n+            && let attrs = cx.tcx.hir().attrs(hir_id)\n+            // Now, check if the function has the `#[track_caller]` attribute\n+            && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n+            {\n+                cx.struct_span_lint(\n+                    UNGATED_ASYNC_FN_TRACK_CALLER,\n+                    attr.span,\n+                    fluent::lint_ungated_async_fn_track_caller,\n+                    |lint| {\n+                        lint.span_label(span, fluent::label);\n+                        rustc_session::parse::add_feature_diagnostics(\n+                            lint,\n+                            &cx.tcx.sess.parse_sess,\n+                            sym::closure_track_caller,\n+                        );\n+                        lint\n+                    },\n+                );\n+            }\n+    }\n+}\n+\n declare_lint! {\n     /// The `unreachable_pub` lint triggers for `pub` items not reachable from\n     /// the crate root.\n@@ -2052,7 +2122,7 @@ impl KeywordIdents {\n             ident.span,\n             fluent::lint_builtin_keyword_idents,\n             |lint| {\n-                lint.set_arg(\"kw\", ident.clone()).set_arg(\"next\", next_edition).span_suggestion(\n+                lint.set_arg(\"kw\", ident).set_arg(\"next\", next_edition).span_suggestion(\n                     ident.span,\n                     fluent::suggestion,\n                     format!(\"r#{}\", ident),"}, {"sha": "3c9ad410663f97f37346ea59c176fccbb36fb7f0", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -438,18 +438,18 @@ impl LintStore {\n                         return CheckLintNameResult::Tool(Ok(&lint_ids));\n                     }\n                 },\n-                Some(&Id(ref id)) => return CheckLintNameResult::Tool(Ok(slice::from_ref(id))),\n+                Some(Id(id)) => return CheckLintNameResult::Tool(Ok(slice::from_ref(id))),\n                 // If the lint was registered as removed or renamed by the lint tool, we don't need\n                 // to treat tool_lints and rustc lints different and can use the code below.\n                 _ => {}\n             }\n         }\n         match self.by_name.get(&complete_name) {\n-            Some(&Renamed(ref new_name, _)) => CheckLintNameResult::Warning(\n+            Some(Renamed(new_name, _)) => CheckLintNameResult::Warning(\n                 format!(\"lint `{}` has been renamed to `{}`\", complete_name, new_name),\n                 Some(new_name.to_owned()),\n             ),\n-            Some(&Removed(ref reason)) => CheckLintNameResult::Warning(\n+            Some(Removed(reason)) => CheckLintNameResult::Warning(\n                 format!(\"lint `{}` has been removed: {}\", complete_name, reason),\n                 None,\n             ),\n@@ -470,7 +470,7 @@ impl LintStore {\n                     CheckLintNameResult::Ok(&lint_ids)\n                 }\n             },\n-            Some(&Id(ref id)) => CheckLintNameResult::Ok(slice::from_ref(id)),\n+            Some(Id(id)) => CheckLintNameResult::Ok(slice::from_ref(id)),\n             Some(&Ignored) => CheckLintNameResult::Ok(&[]),\n         }\n     }\n@@ -483,7 +483,16 @@ impl LintStore {\n             return CheckLintNameResult::NoLint(Some(Symbol::intern(&name_lower)));\n         }\n         // ...if not, search for lints with a similar name\n-        let groups = self.lint_groups.keys().copied().map(Symbol::intern);\n+        // Note: find_best_match_for_name depends on the sort order of its input vector.\n+        // To ensure deterministic output, sort elements of the lint_groups hash map.\n+        // Also, never suggest deprecated lint groups.\n+        let mut groups: Vec<_> = self\n+            .lint_groups\n+            .iter()\n+            .filter_map(|(k, LintGroup { depr, .. })| if depr.is_none() { Some(k) } else { None })\n+            .collect();\n+        groups.sort();\n+        let groups = groups.iter().map(|k| Symbol::intern(k));\n         let lints = self.lints.iter().map(|l| Symbol::intern(&l.name_lower()));\n         let names: Vec<Symbol> = groups.chain(lints).collect();\n         let suggestion = find_best_match_for_name(&names, Symbol::intern(&name_lower), None);\n@@ -513,7 +522,7 @@ impl LintStore {\n                     CheckLintNameResult::Tool(Err((Some(&lint_ids), complete_name)))\n                 }\n             },\n-            Some(&Id(ref id)) => {\n+            Some(Id(id)) => {\n                 CheckLintNameResult::Tool(Err((Some(slice::from_ref(id)), complete_name)))\n             }\n             Some(other) => {"}, {"sha": "182734fa9fc8fc72970117c5c32e7746de87e62e", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -71,11 +71,11 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopsOverFallibles {\n                 );\n             } else {\n                 lint.multipart_suggestion_verbose(\n-                    format!(\"to check pattern in a loop use `while let`\"),\n+                    \"to check pattern in a loop use `while let`\",\n                     vec![\n                         // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n                         (expr.span.with_hi(pat.span.lo()), format!(\"while let {var}(\")),\n-                        (pat.span.between(arg.span), format!(\") = \")),\n+                        (pat.span.between(arg.span), \") = \".to_string()),\n                     ],\n                     Applicability::MaybeIncorrect\n                 );\n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopsOverFallibles {\n                 vec![\n                     // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n                     (expr.span.with_hi(pat.span.lo()), format!(\"if let {var}(\")),\n-                    (pat.span.between(arg.span), format!(\") = \")),\n+                    (pat.span.between(arg.span), \") = \".to_string()),\n                 ],\n                 Applicability::MaybeIncorrect,\n             )"}, {"sha": "e9d3d44a3f9f9f6e6fede79abd3d00190aa2bd1d", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -39,9 +39,9 @@ struct LintLevelSets {\n }\n \n rustc_index::newtype_index! {\n+    #[custom_encodable] // we don't need encoding\n     struct LintStackIndex {\n-        ENCODABLE = custom, // we don't need encoding\n-        const COMMAND_LINE = 0,\n+        const COMMAND_LINE = 0;\n     }\n }\n "}, {"sha": "1275d6f223c7a38ebe5fbfd42cc50c04c4990149", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -219,6 +219,7 @@ late_lint_methods!(\n             // May Depend on constants elsewhere\n             UnusedBrokenConst: UnusedBrokenConst,\n             UnstableFeatures: UnstableFeatures,\n+            UngatedAsyncFnTrackCaller: UngatedAsyncFnTrackCaller,\n             ArrayIntoIter: ArrayIntoIter::default(),\n             DropTraitConstraints: DropTraitConstraints,\n             TemporaryCStringAsPtr: TemporaryCStringAsPtr,"}, {"sha": "8dccfe0046c451d2f8d5969b7fd537be7968b430", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -304,7 +304,7 @@ fn check_panic_str<'tcx>(\n \n /// Given the span of `some_macro!(args);`, gives the span of `(` and `)`,\n /// and the type of (opening) delimiter used.\n-fn find_delimiters<'tcx>(cx: &LateContext<'tcx>, span: Span) -> Option<(Span, Span, char)> {\n+fn find_delimiters(cx: &LateContext<'_>, span: Span) -> Option<(Span, Span, char)> {\n     let snippet = cx.sess().parse_sess.source_map().span_to_snippet(span).ok()?;\n     let (open, open_ch) = snippet.char_indices().find(|&(_, c)| \"([{\".contains(c))?;\n     let close = snippet.rfind(|c| \")]}\".contains(c))?;"}, {"sha": "91fcd6d690ee7a52c819546eccc065dca1baf64c", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -175,13 +175,23 @@ impl EarlyLintPass for NonCamelCaseTypes {\n             return;\n         }\n \n-        match it.kind {\n+        match &it.kind {\n             ast::ItemKind::TyAlias(..)\n             | ast::ItemKind::Enum(..)\n             | ast::ItemKind::Struct(..)\n             | ast::ItemKind::Union(..) => self.check_case(cx, \"type\", &it.ident),\n             ast::ItemKind::Trait(..) => self.check_case(cx, \"trait\", &it.ident),\n             ast::ItemKind::TraitAlias(..) => self.check_case(cx, \"trait alias\", &it.ident),\n+\n+            // N.B. This check is only for inherent associated types, so that we don't lint against\n+            // trait impls where we should have warned for the trait definition already.\n+            ast::ItemKind::Impl(box ast::Impl { of_trait: None, items, .. }) => {\n+                for it in items {\n+                    if let ast::AssocItemKind::Type(..) = it.kind {\n+                        self.check_case(cx, \"associated type\", &it.ident);\n+                    }\n+                }\n+            }\n             _ => (),\n         }\n     }"}, {"sha": "3b8df61a0eab771a704f9ed9006bbd1807b612fa", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1279,7 +1279,7 @@ impl UnusedImportBraces {\n     fn check_use_tree(&self, cx: &EarlyContext<'_>, use_tree: &ast::UseTree, item: &ast::Item) {\n         if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n             // Recursively check nested UseTrees\n-            for &(ref tree, _) in items {\n+            for (tree, _) in items {\n                 self.check_use_tree(cx, tree, item);\n             }\n "}, {"sha": "67868ded0b86b5b4c9de2442bfc2a75515fee6a0", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1405,7 +1405,7 @@ declare_lint! {\n     /// struct S;\n     ///\n     /// impl S {\n-    ///     fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+    ///     fn late(self, _: &u8, _: &u8) {}\n     /// }\n     ///\n     /// fn main() {\n@@ -3311,6 +3311,7 @@ declare_lint_pass! {\n         FFI_UNWIND_CALLS,\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n         NAMED_ARGUMENTS_USED_POSITIONALLY,\n+        IMPLIED_BOUNDS_ENTAILMENT,\n     ]\n }\n \n@@ -3998,3 +3999,44 @@ declare_lint! {\n     Warn,\n     \"named arguments in format used positionally\"\n }\n+\n+declare_lint! {\n+    /// The `implied_bounds_entailment` lint detects cases where the arguments of an impl method\n+    /// have stronger implied bounds than those from the trait method it's implementing.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(implied_bounds_entailment)]\n+    ///\n+    /// trait Trait {\n+    ///     fn get<'s>(s: &'s str, _: &'static &'static ()) -> &'static str;\n+    /// }\n+    ///\n+    /// impl Trait for () {\n+    ///     fn get<'s>(s: &'s str, _: &'static &'s ()) -> &'static str {\n+    ///         s\n+    ///     }\n+    /// }\n+    ///\n+    /// let val = <() as Trait>::get(&String::from(\"blah blah blah\"), &&());\n+    /// println!(\"{}\", val);\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Neither the trait method, which provides no implied bounds about `'s`, nor the impl,\n+    /// requires the main function to prove that 's: 'static, but the impl method is allowed\n+    /// to assume that `'s: 'static` within its own body.\n+    ///\n+    /// This can be used to implement an unsound API if used incorrectly.\n+    pub IMPLIED_BOUNDS_ENTAILMENT,\n+    Warn,\n+    \"impl method assumes more implied bounds than its corresponding trait method\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #105572 <https://github.com/rust-lang/rust/issues/105572>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseError,\n+    };\n+}"}, {"sha": "9ff944864047753173598cdbe56778f022e2e919", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -39,10 +39,8 @@ impl<'a> DiagnosticDerive<'a> {\n             let init = match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(format!(\n-                            \"specify the slug as the first argument to the `#[diag(...)]` \\\n-                            attribute, such as `#[diag(hir_analysis_example_error)]`\",\n-                        ))\n+                        .help(\"specify the slug as the first argument to the `#[diag(...)]` \\\n+                            attribute, such as `#[diag(hir_analysis_example_error)]`\")\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                 }\n@@ -133,10 +131,8 @@ impl<'a> LintDiagnosticDerive<'a> {\n             match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n-                        .help(format!(\n-                            \"specify the slug as the first argument to the attribute, such as \\\n-                            `#[diag(compiletest_example)]`\",\n-                        ))\n+                        .help(\"specify the slug as the first argument to the attribute, such as \\\n+                            `#[diag(compiletest_example)]`\")\n                         .emit();\n                     DiagnosticDeriveError::ErrorHandled.to_compile_error()\n                 }"}, {"sha": "767db3673225988f7bbe02621bfab31cb76b56db", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -29,7 +29,7 @@ impl SubdiagnosticDeriveBuilder {\n         Self { diag, f }\n     }\n \n-    pub(crate) fn into_tokens<'a>(self, mut structure: Structure<'a>) -> TokenStream {\n+    pub(crate) fn into_tokens(self, mut structure: Structure<'_>) -> TokenStream {\n         let implementation = {\n             let ast = structure.ast();\n             let span = ast.span().unwrap();"}, {"sha": "4ff9c777ad8587215548ecff47ff104733d0b9e0", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -385,7 +385,7 @@ impl quote::ToTokens for Applicability {\n \n /// Build the mapping of field names to fields. This allows attributes to peek values from\n /// other fields.\n-pub(super) fn build_field_mapping<'v>(variant: &VariantInfo<'v>) -> HashMap<String, TokenStream> {\n+pub(super) fn build_field_mapping(variant: &VariantInfo<'_>) -> HashMap<String, TokenStream> {\n     let mut fields_map = FieldMap::new();\n     for binding in variant.bindings() {\n         if let Some(ident) = &binding.ast().ident {"}, {"sha": "153473de6244952770385d1f5233ac4106a17168", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 53, "deletions": 102, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,35 +1,15 @@\n use proc_macro2::{Span, TokenStream};\n use quote::quote;\n use syn::parse::*;\n-use syn::punctuated::Punctuated;\n use syn::*;\n \n-mod kw {\n-    syn::custom_keyword!(derive);\n-    syn::custom_keyword!(DEBUG_FORMAT);\n-    syn::custom_keyword!(MAX);\n-    syn::custom_keyword!(ENCODABLE);\n-    syn::custom_keyword!(custom);\n-    syn::custom_keyword!(ORD_IMPL);\n-}\n-\n-#[derive(Debug)]\n-enum DebugFormat {\n-    // The user will provide a custom `Debug` impl, so we shouldn't generate\n-    // one\n-    Custom,\n-    // Use the specified format string in the generated `Debug` impl\n-    // By default, this is \"{}\"\n-    Format(String),\n-}\n-\n // We parse the input and emit the output in a single step.\n // This field stores the final macro output\n struct Newtype(TokenStream);\n \n impl Parse for Newtype {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let attrs = input.call(Attribute::parse_outer)?;\n+        let mut attrs = input.call(Attribute::parse_outer)?;\n         let vis: Visibility = input.parse()?;\n         input.parse::<Token![struct]>()?;\n         let name: Ident = input.parse()?;\n@@ -39,93 +19,68 @@ impl Parse for Newtype {\n \n         // Any additional `#[derive]` macro paths to apply\n         let mut derive_paths: Vec<Path> = Vec::new();\n-        let mut debug_format: Option<DebugFormat> = None;\n+        let mut debug_format: Option<Lit> = None;\n         let mut max = None;\n         let mut consts = Vec::new();\n         let mut encodable = true;\n         let mut ord = true;\n \n-        // Parse an optional trailing comma\n-        let try_comma = || -> Result<()> {\n-            if body.lookahead1().peek(Token![,]) {\n-                body.parse::<Token![,]>()?;\n-            }\n-            Ok(())\n-        };\n-\n-        if body.lookahead1().peek(Token![..]) {\n-            body.parse::<Token![..]>()?;\n-        } else {\n-            loop {\n-                if body.lookahead1().peek(kw::derive) {\n-                    body.parse::<kw::derive>()?;\n-                    let derives;\n-                    bracketed!(derives in body);\n-                    let derives: Punctuated<Path, Token![,]> =\n-                        derives.parse_terminated(Path::parse)?;\n-                    try_comma()?;\n-                    derive_paths.extend(derives);\n-                    continue;\n-                }\n-                if body.lookahead1().peek(kw::DEBUG_FORMAT) {\n-                    body.parse::<kw::DEBUG_FORMAT>()?;\n-                    body.parse::<Token![=]>()?;\n-                    let new_debug_format = if body.lookahead1().peek(kw::custom) {\n-                        body.parse::<kw::custom>()?;\n-                        DebugFormat::Custom\n-                    } else {\n-                        let format_str: LitStr = body.parse()?;\n-                        DebugFormat::Format(format_str.value())\n-                    };\n-                    try_comma()?;\n-                    if let Some(old) = debug_format.replace(new_debug_format) {\n-                        panic!(\"Specified multiple debug format options: {:?}\", old);\n-                    }\n-                    continue;\n-                }\n-                if body.lookahead1().peek(kw::MAX) {\n-                    body.parse::<kw::MAX>()?;\n-                    body.parse::<Token![=]>()?;\n-                    let val: Lit = body.parse()?;\n-                    try_comma()?;\n-                    if let Some(old) = max.replace(val) {\n-                        panic!(\"Specified multiple MAX: {:?}\", old);\n-                    }\n-                    continue;\n-                }\n-                if body.lookahead1().peek(kw::ENCODABLE) {\n-                    body.parse::<kw::ENCODABLE>()?;\n-                    body.parse::<Token![=]>()?;\n-                    body.parse::<kw::custom>()?;\n-                    try_comma()?;\n+        attrs.retain(|attr| match attr.path.get_ident() {\n+            Some(ident) => match &*ident.to_string() {\n+                \"custom_encodable\" => {\n                     encodable = false;\n-                    continue;\n+                    false\n                 }\n-                if body.lookahead1().peek(kw::ORD_IMPL) {\n-                    body.parse::<kw::ORD_IMPL>()?;\n-                    body.parse::<Token![=]>()?;\n-                    body.parse::<kw::custom>()?;\n+                \"no_ord_impl\" => {\n                     ord = false;\n-                    continue;\n+                    false\n                 }\n+                \"max\" => {\n+                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                        panic!(\"#[max = NUMBER] attribute requires max value\");\n+                    };\n+\n+                    if let Some(old) = max.replace(literal.lit) {\n+                        panic!(\"Specified multiple max: {:?}\", old);\n+                    }\n \n-                // We've parsed everything that the user provided, so we're done\n-                if body.is_empty() {\n-                    break;\n+                    false\n                 }\n+                \"debug_format\" => {\n+                    let Ok(Meta::NameValue(literal) )= attr.parse_meta() else {\n+                        panic!(\"#[debug_format = FMT] attribute requires a format\");\n+                    };\n+\n+                    if let Some(old) = debug_format.replace(literal.lit) {\n+                        panic!(\"Specified multiple debug format options: {:?}\", old);\n+                    }\n \n-                // Otherwise, we are parsing a user-defined constant\n-                let const_attrs = body.call(Attribute::parse_outer)?;\n-                body.parse::<Token![const]>()?;\n-                let const_name: Ident = body.parse()?;\n-                body.parse::<Token![=]>()?;\n-                let const_val: Expr = body.parse()?;\n-                try_comma()?;\n-                consts.push(quote! { #(#const_attrs)* #vis const #const_name: #name = #name::from_u32(#const_val); });\n+                    false\n+                }\n+                _ => true,\n+            },\n+            _ => true,\n+        });\n+\n+        loop {\n+            // We've parsed everything that the user provided, so we're done\n+            if body.is_empty() {\n+                break;\n             }\n+\n+            // Otherwise, we are parsing a user-defined constant\n+            let const_attrs = body.call(Attribute::parse_outer)?;\n+            body.parse::<Token![const]>()?;\n+            let const_name: Ident = body.parse()?;\n+            body.parse::<Token![=]>()?;\n+            let const_val: Expr = body.parse()?;\n+            body.parse::<Token![;]>()?;\n+            consts.push(quote! { #(#const_attrs)* #vis const #const_name: #name = #name::from_u32(#const_val); });\n         }\n \n-        let debug_format = debug_format.unwrap_or(DebugFormat::Format(\"{}\".to_string()));\n+        let debug_format =\n+            debug_format.unwrap_or_else(|| Lit::Str(LitStr::new(\"{}\", Span::call_site())));\n+\n         // shave off 256 indices at the end to allow space for packing these indices into enums\n         let max = max.unwrap_or_else(|| Lit::Int(LitInt::new(\"0xFFFF_FF00\", Span::call_site())));\n \n@@ -180,18 +135,14 @@ impl Parse for Newtype {\n             quote! {}\n         };\n \n-        let debug_impl = match debug_format {\n-            DebugFormat::Custom => quote! {},\n-            DebugFormat::Format(format) => {\n-                quote! {\n-                    impl ::std::fmt::Debug for #name {\n-                        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n-                            write!(fmt, #format, self.as_u32())\n-                        }\n-                    }\n+        let debug_impl = quote! {\n+            impl ::std::fmt::Debug for #name {\n+                fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+                    write!(fmt, #debug_format, self.as_u32())\n                 }\n             }\n         };\n+\n         let spec_partial_eq_impl = if let Lit::Int(max) = &max {\n             if let Ok(max_val) = max.base10_parse::<u32>() {\n                 quote! {"}, {"sha": "b34dc0df1e2805702763fc4ce09a53a677308022", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,10 +1,9 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n use crate::errors::{\n-    AllocFuncRequired, ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n-    GlobalAllocRequired, MissingAllocErrorHandler, NoMultipleAllocErrorHandler,\n-    NoMultipleGlobalAlloc, NoPanicStrategy, NoTransitiveNeedsDep, NotProfilerRuntime,\n-    ProfilerBuiltinsNeedsCore,\n+    ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n+    GlobalAllocRequired, NoMultipleAllocErrorHandler, NoMultipleGlobalAlloc, NoPanicStrategy,\n+    NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n };\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n@@ -521,8 +520,8 @@ impl<'a> CrateLoader<'a> {\n         }))\n     }\n \n-    fn resolve_crate<'b>(\n-        &'b mut self,\n+    fn resolve_crate(\n+        &mut self,\n         name: Symbol,\n         span: Span,\n         dep_kind: CrateDepKind,\n@@ -895,10 +894,6 @@ impl<'a> CrateLoader<'a> {\n         } else {\n             // The alloc crate provides a default allocation error handler if\n             // one isn't specified.\n-            if !self.sess.features_untracked().default_alloc_error_handler {\n-                self.sess.emit_err(AllocFuncRequired);\n-                self.sess.emit_note(MissingAllocErrorHandler);\n-            }\n             self.cstore.alloc_error_handler_kind = Some(AllocatorKind::Default);\n         }\n     }"}, {"sha": "de2a879f1d73769c59f4dda5661f1abc93e1b5cf", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -371,14 +371,6 @@ pub struct ConflictingAllocErrorHandler {\n #[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;\n \n-#[derive(Diagnostic)]\n-#[diag(metadata_alloc_func_required)]\n-pub struct AllocFuncRequired;\n-\n-#[derive(Diagnostic)]\n-#[diag(metadata_missing_alloc_error_handler)]\n-pub struct MissingAllocErrorHandler;\n-\n #[derive(Diagnostic)]\n #[diag(metadata_no_transitive_needs_dep)]\n pub struct NoTransitiveNeedsDep<'a> {"}, {"sha": "dda5f4bac4289310140abef18ff316f57bf44132", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1011,11 +1011,7 @@ impl CrateError {\n                 sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                sess.emit_err(StableCrateIdCollision {\n-                    span,\n-                    crate_name0: crate_name0,\n-                    crate_name1: crate_name1,\n-                });\n+                sess.emit_err(StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n                 sess.emit_err(DlError { span, err: s });\n@@ -1074,7 +1070,7 @@ impl CrateError {\n                     }\n                     sess.emit_err(NoCrateWithTriple {\n                         span,\n-                        crate_name: crate_name,\n+                        crate_name,\n                         locator_triple: locator.triple.triple(),\n                         add_info,\n                         found_crates,"}, {"sha": "99d8225a4c391381075f18b736bdb816771ffebe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -78,10 +78,6 @@ pub(crate) struct CrateMetadata {\n     blob: MetadataBlob,\n \n     // --- Some data pre-decoded from the metadata blob, usually for performance ---\n-    /// NOTE(eddyb) we pass `'static` to a `'tcx` parameter because this\n-    /// lifetime is only used behind `LazyValue`, `LazyArray`, or `LazyTable`, and therefore acts like a\n-    /// universal (`for<'tcx>`), that is paired up with whichever `TyCtxt`\n-    /// is being used to decode those values.\n     root: CrateRoot,\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n@@ -688,10 +684,10 @@ impl MetadataBlob {\n     pub(crate) fn get_root(&self) -> CrateRoot {\n         let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n-        let pos = (((slice[offset + 0] as u32) << 24)\n-            | ((slice[offset + 1] as u32) << 16)\n-            | ((slice[offset + 2] as u32) << 8)\n-            | ((slice[offset + 3] as u32) << 0)) as usize;\n+\n+        let pos_bytes = slice[offset..][..4].try_into().unwrap();\n+        let pos = u32::from_be_bytes(pos_bytes) as usize;\n+\n         LazyValue::<CrateRoot>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n     }\n \n@@ -702,16 +698,14 @@ impl MetadataBlob {\n         writeln!(out, \"hash {} stable_crate_id {:?}\", root.hash, root.stable_crate_id)?;\n         writeln!(out, \"proc_macro {:?}\", root.proc_macro_data.is_some())?;\n         writeln!(out, \"=External Dependencies=\")?;\n+\n         for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+            let CrateDep { name, extra_filename, hash, host_hash, kind } = dep;\n+            let number = i + 1;\n+\n             writeln!(\n                 out,\n-                \"{} {}{} hash {} host_hash {:?} kind {:?}\",\n-                i + 1,\n-                dep.name,\n-                dep.extra_filename,\n-                dep.hash,\n-                dep.host_hash,\n-                dep.kind\n+                \"{number} {name}{extra_filename} hash {hash} host_hash {host_hash:?} kind {kind:?}\"\n             )?;\n         }\n         write!(out, \"\\n\")?;"}, {"sha": "d5d31bc3edc97af6572079812df5d2a68ad14f1b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Symbol {\n                     s.emit_str(self.as_str());\n                 }\n                 Entry::Occupied(o) => {\n-                    let x = o.get().clone();\n+                    let x = *o.get();\n                     s.emit_u8(SYMBOL_OFFSET);\n                     s.emit_usize(x);\n                 }\n@@ -1093,7 +1093,7 @@ fn should_encode_const(def_kind: DefKind) -> bool {\n     }\n }\n \n-fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if tcx.def_kind(def_id) != DefKind::AssocFn {\n         return false;\n     }\n@@ -1849,7 +1849,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        self.lazy_array(deps.iter().map(|&(_, ref dep)| dep))\n+        self.lazy_array(deps.iter().map(|(_, dep)| dep))\n     }\n \n     fn encode_lib_features(&mut self) -> LazyArray<(Symbol, Option<Symbol>)> {\n@@ -1986,7 +1986,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_array(\n             exported_symbols\n                 .iter()\n-                .filter(|&&(ref exported_symbol, _)| match *exported_symbol {\n+                .filter(|&(exported_symbol, _)| match *exported_symbol {\n                     ExportedSymbol::NoDefId(symbol_name) => symbol_name != metadata_symbol_name,\n                     _ => true,\n                 })"}, {"sha": "26a41f633fffa460f861df4ef0f48de2513e21bc", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -416,11 +416,6 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n-#[derive(TyEncodable, TyDecodable)]\n-struct GeneratorData<'tcx> {\n-    layout: mir::GeneratorLayout<'tcx>,\n-}\n-\n // Tags used for encoding Spans:\n const TAG_VALID_SPAN_LOCAL: u8 = 0;\n const TAG_VALID_SPAN_FOREIGN: u8 = 1;"}, {"sha": "543bd56a20c18e863b5aa714dc000b71c95a1fef", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -18,6 +18,8 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+# Used for intra-doc links\n+rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "75282f958b53b3b738c6498f16600f59209f2698", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -93,7 +93,7 @@ macro_rules! arena_types {\n             // Interned types\n             [] tys: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::TyKind<'tcx>>,\n             [] predicates: rustc_type_ir::WithCachedTypeInfo<rustc_middle::ty::PredicateKind<'tcx>>,\n-            [] consts: rustc_middle::ty::ConstS<'tcx>,\n+            [] consts: rustc_middle::ty::ConstData<'tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena"}, {"sha": "865bb70afb506172c5976fc73f8e504246a9b210", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -175,7 +175,7 @@ impl DepNodeExt for DepNode {\n     /// DepNode. Condition (2) might not be fulfilled if a DepNode\n     /// refers to something from the previous compilation session that\n     /// has been removed.\n-    fn extract_def_id<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n+    fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         if tcx.fingerprint_style(self.kind) == FingerprintStyle::DefPathHash {\n             Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into()), &mut || {\n                 panic!(\"Failed to extract DefId: {:?} {}\", self.kind, self.hash)"}, {"sha": "fe640f185b647847b55320c58854f50bfb33184a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -18,7 +18,7 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n #[inline]\n-pub fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n+pub fn associated_body(node: Node<'_>) -> Option<BodyId> {\n     match node {\n         Node::Item(Item {\n             kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),\n@@ -41,7 +41,7 @@ pub fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n     }\n }\n \n-fn is_body_owner<'hir>(node: Node<'hir>, hir_id: HirId) -> bool {\n+fn is_body_owner(node: Node<'_>, hir_id: HirId) -> bool {\n     match associated_body(node) {\n         Some(b) => b.hir_id == hir_id,\n         None => false,\n@@ -170,6 +170,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n             bug!(\n@@ -310,6 +311,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n         self.find_parent_node(hir_id)\n             .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n@@ -334,12 +336,14 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n+    #[track_caller]\n     pub fn get(self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     #[inline]\n+    #[track_caller]\n     pub fn get_by_def_id(self, id: LocalDefId) -> Node<'hir> {\n         self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n     }\n@@ -377,6 +381,7 @@ impl<'hir> Map<'hir> {\n         self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[&id.hir_id.local_id]\n     }\n \n+    #[track_caller]\n     pub fn fn_decl_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             node.fn_decl()\n@@ -385,6 +390,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn fn_sig_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             node.fn_sig()\n@@ -393,6 +399,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[track_caller]\n     pub fn enclosing_body_owner(self, hir_id: HirId) -> LocalDefId {\n         for (_, node) in self.parent_iter(hir_id) {\n             if let Some(body) = associated_body(node) {\n@@ -408,7 +415,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node(hir_id);\n-        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)));\n+        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n         parent\n     }\n \n@@ -419,10 +426,11 @@ impl<'hir> Map<'hir> {\n     /// Given a `LocalDefId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(self, id: LocalDefId) -> Option<BodyId> {\n-        self.get_if_local(id.to_def_id()).map(associated_body).flatten()\n+        self.find_by_def_id(id).and_then(associated_body)\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n+    #[track_caller]\n     pub fn body_owned_by(self, id: LocalDefId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n             let hir_id = self.local_def_id_to_hir_id(id);"}, {"sha": "0b32f67a81e16bb3fcea96e999fdb1bf273b1f00", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -300,6 +300,16 @@ impl<'tcx, V> Canonical<'tcx, V> {\n         let Canonical { max_universe, variables, value } = self;\n         Canonical { max_universe, variables, value: map_op(value) }\n     }\n+\n+    /// Allows you to map the `value` of a canonical while keeping the same set of\n+    /// bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the name! See\n+    /// the comment of [Canonical::unchecked_map] for more details.\n+    pub fn unchecked_rebind<W>(self, value: W) -> Canonical<'tcx, W> {\n+        let Canonical { max_universe, variables, value: _ } = self;\n+        Canonical { max_universe, variables, value }\n+    }\n }\n \n pub type QueryOutlivesConstraint<'tcx> = ("}, {"sha": "0e18ba73d7129da3bd04fc6b0852ec90f493de53", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -103,12 +103,7 @@ impl EffectiveVisibilities {\n \n     pub fn public_at_level(&self, id: LocalDefId) -> Option<Level> {\n         self.effective_vis(id).and_then(|effective_vis| {\n-            for level in Level::all_levels() {\n-                if effective_vis.is_public_at_level(level) {\n-                    return Some(level);\n-                }\n-            }\n-            None\n+            Level::all_levels().into_iter().find(|&level| effective_vis.is_public_at_level(level))\n         })\n     }\n "}, {"sha": "94ca38c0e758ff2bf9615572b552e2f7b85d10eb", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -147,9 +147,8 @@ rustc_index::newtype_index! {\n     ///\n     /// * The subscope with `first_statement_index == 1` is scope of `c`,\n     ///   and thus does not include EXPR_2, but covers the `...`.\n-    pub struct FirstStatementIndex {\n-        derive [HashStable]\n-    }\n+    #[derive(HashStable)]\n+    pub struct FirstStatementIndex {}\n }\n \n // compilation error if size of `ScopeData` is not the same as a `u32`"}, {"sha": "0836f236e248f7779e50dee234a9f2a712952054", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -223,8 +223,8 @@ pub fn deprecation_message_and_lint(\n     )\n }\n \n-pub fn early_report_deprecation<'a>(\n-    lint_buffer: &'a mut LintBuffer,\n+pub fn early_report_deprecation(\n+    lint_buffer: &mut LintBuffer,\n     message: &str,\n     suggestion: Option<Symbol>,\n     lint: &'static Lint,"}, {"sha": "e7bb3ab0bc352d6016fb83389c9df33aa0c14553", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -10,10 +10,10 @@ rustc_index::newtype_index! {\n     /// CounterValueReference.as_u32() (which ascend from 1) or an ExpressionOperandId.as_u32()\n     /// (which _*descend*_ from u32::MAX). Id value `0` (zero) represents a virtual counter with a\n     /// constant value of `0`.\n+    #[derive(HashStable)]\n+    #[max = 0xFFFF_FFFF]\n+    #[debug_format = \"ExpressionOperandId({})\"]\n     pub struct ExpressionOperandId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n-        MAX = 0xFFFF_FFFF,\n     }\n }\n \n@@ -32,11 +32,10 @@ impl ExpressionOperandId {\n }\n \n rustc_index::newtype_index! {\n-    pub struct CounterValueReference {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"CounterValueReference({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n+    #[derive(HashStable)]\n+    #[max = 0xFFFF_FFFF]\n+    #[debug_format = \"CounterValueReference({})\"]\n+    pub struct CounterValueReference {}\n }\n \n impl CounterValueReference {\n@@ -56,33 +55,30 @@ rustc_index::newtype_index! {\n     /// InjectedExpressionId.as_u32() converts to ExpressionOperandId.as_u32()\n     ///\n     /// Values descend from u32::MAX.\n-    pub struct InjectedExpressionId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"InjectedExpressionId({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n+    #[derive(HashStable)]\n+    #[max = 0xFFFF_FFFF]\n+    #[debug_format = \"InjectedExpressionId({})\"]\n+    pub struct InjectedExpressionId {}\n }\n \n rustc_index::newtype_index! {\n     /// InjectedExpressionIndex.as_u32() translates to u32::MAX - ExpressionOperandId.as_u32()\n     ///\n     /// Values ascend from 0.\n-    pub struct InjectedExpressionIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n+    #[derive(HashStable)]\n+    #[max = 0xFFFF_FFFF]\n+    #[debug_format = \"InjectedExpressionIndex({})\"]\n+    pub struct InjectedExpressionIndex {}\n }\n \n rustc_index::newtype_index! {\n     /// MappedExpressionIndex values ascend from zero, and are recalculated indexes based on their\n     /// array position in the LLVM coverage map \"Expressions\" array, which is assembled during the\n     /// \"mapgen\" process. They cannot be computed algorithmically, from the other `newtype_index`s.\n-    pub struct MappedExpressionIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n-        MAX = 0xFFFF_FFFF,\n-    }\n+    #[derive(HashStable)]\n+    #[max = 0xFFFF_FFFF]\n+    #[debug_format = \"MappedExpressionIndex({})\"]\n+    pub struct MappedExpressionIndex {}\n }\n \n impl From<CounterValueReference> for ExpressionOperandId {"}, {"sha": "50e41e3e006310a098eeb9652a3ff09d161418bc", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -654,10 +654,10 @@ impl SourceInfo {\n // Variables and temps\n \n rustc_index::newtype_index! {\n+    #[derive(HashStable)]\n+    #[debug_format = \"_{}\"]\n     pub struct Local {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"_{}\",\n-        const RETURN_PLACE = 0,\n+        const RETURN_PLACE = 0;\n     }\n }\n \n@@ -1146,10 +1146,10 @@ rustc_index::newtype_index! {\n     ///     https://rustc-dev-guide.rust-lang.org/appendix/background.html#what-is-a-dataflow-analysis\n     /// [`CriticalCallEdges`]: ../../rustc_const_eval/transform/add_call_guards/enum.AddCallGuards.html#variant.CriticalCallEdges\n     /// [guide-mir]: https://rustc-dev-guide.rust-lang.org/mir/\n+    #[derive(HashStable)]\n+    #[debug_format = \"bb{}\"]\n     pub struct BasicBlock {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"bb{}\",\n-        const START_BLOCK = 0,\n+        const START_BLOCK = 0;\n     }\n }\n \n@@ -1530,10 +1530,9 @@ rustc_index::newtype_index! {\n     /// [wrapper]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#newtype\n     /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n     /// [mir-datatypes]: https://rustc-dev-guide.rust-lang.org/mir/index.html#mir-data-types\n-    pub struct Field {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"field[{}]\"\n-    }\n+    #[derive(HashStable)]\n+    #[debug_format = \"field[{}]\"]\n+    pub struct Field {}\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -1757,20 +1756,20 @@ impl Debug for Place<'_> {\n // Scopes\n \n rustc_index::newtype_index! {\n+    #[derive(HashStable)]\n+    #[debug_format = \"scope[{}]\"]\n     pub struct SourceScope {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"scope[{}]\",\n-        const OUTERMOST_SOURCE_SCOPE = 0,\n+        const OUTERMOST_SOURCE_SCOPE = 0;\n     }\n }\n \n impl SourceScope {\n     /// Finds the original HirId this MIR item came from.\n     /// This is necessary after MIR optimizations, as otherwise we get a HirId\n     /// from the function that was inlined instead of the function call site.\n-    pub fn lint_root<'tcx>(\n+    pub fn lint_root(\n         self,\n-        source_scopes: &IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+        source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n     ) -> Option<HirId> {\n         let mut data = &source_scopes[self];\n         // FIXME(oli-obk): we should be able to just walk the `inlined_parent_scope`, but it\n@@ -2755,10 +2754,9 @@ impl<'tcx> TypeVisitable<'tcx> for UserTypeProjection {\n }\n \n rustc_index::newtype_index! {\n-    pub struct Promoted {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"promoted[{}]\"\n-    }\n+    #[derive(HashStable)]\n+    #[debug_format = \"promoted[{}]\"]\n+    pub struct Promoted {}\n }\n \n impl<'tcx> Debug for Constant<'tcx> {"}, {"sha": "40289af257ff4dda8bcfdc411decbdb7f8936aad", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -88,7 +88,7 @@ pub fn dump_mir<'tcx, F>(\n     dump_matched_mir_node(tcx, pass_num, pass_name, disambiguator, body, extra_data);\n }\n \n-pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, def_id: DefId) -> bool {\n+pub fn dump_enabled(tcx: TyCtxt<'_>, pass_name: &str, def_id: DefId) -> bool {\n     let Some(ref filters) = tcx.sess.opts.unstable_opts.dump_mir else {\n         return false;\n     };\n@@ -421,7 +421,7 @@ impl<'tcx> ExtraComments<'tcx> {\n     }\n }\n \n-fn use_verbose<'tcx>(ty: Ty<'tcx>, fn_def: bool) -> bool {\n+fn use_verbose(ty: Ty<'_>, fn_def: bool) -> bool {\n     match *ty.kind() {\n         ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n         // Unit type\n@@ -448,15 +448,15 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n \n             // FIXME: this is a poor version of `pretty_print_const_value`.\n             let fmt_val = |val: &ConstValue<'tcx>| match val {\n-                ConstValue::ZeroSized => format!(\"<ZST>\"),\n+                ConstValue::ZeroSized => \"<ZST>\".to_string(),\n                 ConstValue::Scalar(s) => format!(\"Scalar({:?})\", s),\n-                ConstValue::Slice { .. } => format!(\"Slice(..)\"),\n-                ConstValue::ByRef { .. } => format!(\"ByRef(..)\"),\n+                ConstValue::Slice { .. } => \"Slice(..)\".to_string(),\n+                ConstValue::ByRef { .. } => \"ByRef(..)\".to_string(),\n             };\n \n             let fmt_valtree = |valtree: &ty::ValTree<'tcx>| match valtree {\n                 ty::ValTree::Leaf(leaf) => format!(\"ValTree::Leaf({:?})\", leaf),\n-                ty::ValTree::Branch(_) => format!(\"ValTree::Branch(..)\"),\n+                ty::ValTree::Branch(_) => \"ValTree::Branch(..)\".to_string(),\n             };\n \n             let val = match literal {"}, {"sha": "a8a4532223c2d901a47e1cf1f18cb21a718538e7", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -130,10 +130,9 @@ pub struct UnsafetyCheckResult {\n }\n \n rustc_index::newtype_index! {\n-    pub struct GeneratorSavedLocal {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"_{}\",\n-    }\n+    #[derive(HashStable)]\n+    #[debug_format = \"_{}\"]\n+    pub struct GeneratorSavedLocal {}\n }\n \n /// The layout of generator state."}, {"sha": "887ee57157540e6f408de841d5825761978af356", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -230,7 +230,7 @@ where\n }\n \n /// Format a string showing the start line and column, and end line and column within a file.\n-pub fn source_range_no_file<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n+pub fn source_range_no_file(tcx: TyCtxt<'_>, span: Span) -> String {\n     let source_map = tcx.sess.source_map();\n     let start = source_map.lookup_char_pos(span.lo());\n     let end = source_map.lookup_char_pos(span.hi());\n@@ -322,7 +322,7 @@ fn block_span_viewable<'tcx>(\n     Some(SpanViewable { bb, span, id, tooltip })\n }\n \n-fn compute_block_span<'tcx>(data: &BasicBlockData<'tcx>, body_span: Span) -> Span {\n+fn compute_block_span(data: &BasicBlockData<'_>, body_span: Span) -> Span {\n     let mut span = data.terminator().source_info.span;\n     for statement_span in data.statements.iter().map(|statement| statement.source_info.span) {\n         // Only combine Spans from the root context, and within the function's body_span.\n@@ -522,12 +522,7 @@ where\n }\n \n #[inline(always)]\n-fn write_coverage_gap<'tcx, W>(\n-    tcx: TyCtxt<'tcx>,\n-    lo: BytePos,\n-    hi: BytePos,\n-    w: &mut W,\n-) -> io::Result<()>\n+fn write_coverage_gap<W>(tcx: TyCtxt<'_>, lo: BytePos, hi: BytePos, w: &mut W) -> io::Result<()>\n where\n     W: Write,\n {\n@@ -582,8 +577,8 @@ where\n     Ok(())\n }\n \n-fn make_html_snippet<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn make_html_snippet(\n+    tcx: TyCtxt<'_>,\n     span: Span,\n     some_viewable: Option<&SpanViewable>,\n ) -> Option<String> {\n@@ -664,7 +659,7 @@ fn trim_span_hi(span: Span, to_pos: BytePos) -> Span {\n     if to_pos >= span.hi() { span } else { span.with_hi(cmp::max(span.lo(), to_pos)) }\n }\n \n-fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n+fn fn_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n     let fn_decl_span = tcx.def_span(def_id);\n     if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n         if fn_decl_span.eq_ctxt(body_span) { fn_decl_span.to(body_span) } else { body_span }\n@@ -673,7 +668,7 @@ fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n     }\n }\n \n-fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<&'tcx rustc_hir::Body<'tcx>> {\n+fn hir_body(tcx: TyCtxt<'_>, def_id: DefId) -> Option<&rustc_hir::Body<'_>> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n     hir::map::associated_body(hir_node).map(|fn_body_id| tcx.hir().body(fn_body_id))\n }"}, {"sha": "6b4489026d3d379dee958125b73ced3eb3d40fb1", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -320,8 +320,10 @@ pub enum StatementKind<'tcx> {\n     /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n     /// more details.\n     ///\n-    /// For code that is not specific to stacked borrows, you should consider retags to read\n-    /// and modify the place in an opaque way.\n+    /// For code that is not specific to stacked borrows, you should consider retags to read and\n+    /// modify the place in an opaque way.\n+    ///\n+    /// Only `RetagKind::Default` and `RetagKind::FnEntry` are permitted.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n@@ -562,14 +564,13 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// The behavior of this statement differs significantly before and after drop elaboration.\n-    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n-    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n-    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n-    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n-    /// call?)\n-    ///\n-    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n-    /// `Drop` will be executed if...\n+    ///\n+    /// After drop elaboration: `Drop` terminators are a complete nop for types that have no drop\n+    /// glue. For other types, `Drop` terminators behave exactly like a call to\n+    /// `core::mem::drop_in_place` with a pointer to the given place.\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically,\n+    /// the `Drop` will be executed if...\n     ///\n     /// **Needs clarification**: End of that sentence. This in effect should document the exact\n     /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:"}, {"sha": "599f0b9d3fab4de99f30f25ba9fd1bf6774ed3ab", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -32,8 +32,9 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n-        let answer = match self.ty.kind() {\n+        match self.ty.kind() {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n                     None => adt_def.non_enum_variant(),\n@@ -47,9 +48,7 @@ impl<'tcx> PlaceTy<'tcx> {\n             }\n             ty::Tuple(tys) => tys[f.index()],\n             _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n-        };\n-        debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n-        answer\n+        }\n     }\n \n     /// Convenience wrapper around `projection_ty_core` for\n@@ -234,7 +233,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) | &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n-            &Operand::Constant(ref c) => c.literal.ty(),\n+            Operand::Constant(c) => c.literal.ty(),\n         }\n     }\n }"}, {"sha": "0b461d1ce41c5f2559bda8ea0a82f3e06562431d", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -302,7 +302,7 @@ pub fn reachable<'a, 'tcx>(\n }\n \n /// Returns a `BitSet` containing all basic blocks reachable from the `START_BLOCK`.\n-pub fn reachable_as_bitset<'tcx>(body: &Body<'tcx>) -> BitSet<BasicBlock> {\n+pub fn reachable_as_bitset(body: &Body<'_>) -> BitSet<BasicBlock> {\n     let mut iter = preorder(body);\n     (&mut iter).for_each(drop);\n     iter.visited"}, {"sha": "e4bb3ce3d5a99b32793e8f0a9f1467d5b47f76f7", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -15,7 +15,15 @@ use rustc_span::{Span, DUMMY_SP};\n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n pub trait Key: Sized {\n-    type CacheSelector = DefaultCacheSelector<Self>;\n+    // N.B. Most of the keys down below have `type CacheSelector = DefaultCacheSelector<Self>;`,\n+    //      it would be reasonable to use associated type defaults, to remove the duplication...\n+    //\n+    //      ...But r-a doesn't support them yet and using a default here causes r-a to not infer\n+    //      return types of queries which is very annoying. Thus, until r-a support associated\n+    //      type defaults, plese restrain from using them here <3\n+    //\n+    //      r-a issue: <https://github.com/rust-lang/rust-analyzer/issues/13693>\n+    type CacheSelector;\n \n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n@@ -37,6 +45,8 @@ pub trait Key: Sized {\n }\n \n impl Key for () {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -48,6 +58,8 @@ impl Key for () {\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -59,6 +71,8 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n }\n \n impl<'tcx> Key for ty::Instance<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -70,6 +84,8 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -81,6 +97,8 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -92,6 +110,8 @@ impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n }\n \n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -145,6 +165,8 @@ impl Key for LocalDefId {\n }\n \n impl Key for DefId {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n@@ -159,6 +181,8 @@ impl Key for DefId {\n }\n \n impl Key for ty::WithOptConstParam<LocalDefId> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -169,6 +193,8 @@ impl Key for ty::WithOptConstParam<LocalDefId> {\n }\n \n impl Key for SimplifiedType {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -179,6 +205,8 @@ impl Key for SimplifiedType {\n }\n \n impl Key for (DefId, DefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -189,6 +217,8 @@ impl Key for (DefId, DefId) {\n }\n \n impl<'tcx> Key for (ty::Instance<'tcx>, LocalDefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -199,6 +229,8 @@ impl<'tcx> Key for (ty::Instance<'tcx>, LocalDefId) {\n }\n \n impl Key for (DefId, LocalDefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -209,6 +241,8 @@ impl Key for (DefId, LocalDefId) {\n }\n \n impl Key for (LocalDefId, DefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -219,6 +253,8 @@ impl Key for (LocalDefId, DefId) {\n }\n \n impl Key for (LocalDefId, LocalDefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -229,6 +265,8 @@ impl Key for (LocalDefId, LocalDefId) {\n }\n \n impl Key for (DefId, Option<Ident>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -243,6 +281,8 @@ impl Key for (DefId, Option<Ident>) {\n }\n \n impl Key for (DefId, LocalDefId, Ident) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -253,6 +293,8 @@ impl Key for (DefId, LocalDefId, Ident) {\n }\n \n impl Key for (CrateNum, DefId) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0 == LOCAL_CRATE\n@@ -263,6 +305,8 @@ impl Key for (CrateNum, DefId) {\n }\n \n impl Key for (CrateNum, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0 == LOCAL_CRATE\n@@ -273,6 +317,8 @@ impl Key for (CrateNum, SimplifiedType) {\n }\n \n impl Key for (DefId, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -283,6 +329,8 @@ impl Key for (DefId, SimplifiedType) {\n }\n \n impl<'tcx> Key for SubstsRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -293,6 +341,8 @@ impl<'tcx> Key for SubstsRef<'tcx> {\n }\n \n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.krate == LOCAL_CRATE\n@@ -303,6 +353,8 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         (self.0).def.did.krate == LOCAL_CRATE\n@@ -313,6 +365,8 @@ impl<'tcx> Key for (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>) {\n }\n \n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -323,6 +377,8 @@ impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.1.def_id().krate == LOCAL_CRATE\n@@ -333,6 +389,8 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -343,6 +401,8 @@ impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n }\n \n impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -353,6 +413,8 @@ impl<'tcx> Key for mir::interpret::ConstAlloc<'tcx> {\n }\n \n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.def_id().krate == LOCAL_CRATE\n@@ -363,6 +425,8 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n }\n \n impl<'tcx> Key for ty::PolyExistentialTraitRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.def_id().krate == LOCAL_CRATE\n@@ -373,6 +437,8 @@ impl<'tcx> Key for ty::PolyExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.0.def_id().krate == LOCAL_CRATE\n@@ -383,6 +449,8 @@ impl<'tcx> Key for (ty::PolyTraitRef<'tcx>, ty::PolyTraitRef<'tcx>) {\n }\n \n impl<'tcx> Key for GenericArg<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -393,6 +461,8 @@ impl<'tcx> Key for GenericArg<'tcx> {\n }\n \n impl<'tcx> Key for mir::ConstantKind<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -403,6 +473,8 @@ impl<'tcx> Key for mir::ConstantKind<'tcx> {\n }\n \n impl<'tcx> Key for ty::Const<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -413,6 +485,8 @@ impl<'tcx> Key for ty::Const<'tcx> {\n }\n \n impl<'tcx> Key for Ty<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -429,6 +503,8 @@ impl<'tcx> Key for Ty<'tcx> {\n }\n \n impl<'tcx> Key for TyAndLayout<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -439,6 +515,8 @@ impl<'tcx> Key for TyAndLayout<'tcx> {\n }\n \n impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -449,6 +527,8 @@ impl<'tcx> Key for (Ty<'tcx>, Ty<'tcx>) {\n }\n \n impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -459,6 +539,8 @@ impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n }\n \n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -469,6 +551,8 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n }\n \n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         self.value.query_crate_is_local()\n@@ -479,6 +563,8 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n }\n \n impl Key for Symbol {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -489,6 +575,8 @@ impl Key for Symbol {\n }\n \n impl Key for Option<Symbol> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -501,6 +589,8 @@ impl Key for Option<Symbol> {\n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n impl<'tcx, T> Key for Canonical<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -512,6 +602,8 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n }\n \n impl Key for (Symbol, u32, u32) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -523,6 +615,8 @@ impl Key for (Symbol, u32, u32) {\n }\n \n impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -534,6 +628,8 @@ impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -545,6 +641,8 @@ impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n }\n \n impl<'tcx> Key for (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -556,6 +654,8 @@ impl<'tcx> Key for (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n }\n \n impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -567,6 +667,8 @@ impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n }\n \n impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true\n@@ -578,6 +680,8 @@ impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n }\n \n impl Key for HirId {\n+    type CacheSelector = DefaultCacheSelector<Self>;\n+\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n         true"}, {"sha": "ac903010c8d31bba0e158db5016516709d3b5b38", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -35,9 +35,8 @@ macro_rules! thir_with_elements {\n         $(\n             newtype_index! {\n                 #[derive(HashStable)]\n-                pub struct $id {\n-                    DEBUG_FORMAT = $format\n-                }\n+                #[debug_format = $format]\n+                pub struct $id {}\n             }\n         )*\n "}, {"sha": "dd75b0d9ebc23e30de15728d67d877fb48e52a00", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -210,26 +210,23 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Box::new(chalk_ir::TyData { kind: ty, flags: flags })\n     }\n \n-    fn ty_data<'a>(self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n+    fn ty_data(self, ty: &Self::InternedType) -> &chalk_ir::TyData<Self> {\n         ty\n     }\n \n     fn intern_lifetime(self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n         Box::new(lifetime)\n     }\n \n-    fn lifetime_data<'a>(\n-        self,\n-        lifetime: &'a Self::InternedLifetime,\n-    ) -> &'a chalk_ir::LifetimeData<Self> {\n+    fn lifetime_data(self, lifetime: &Self::InternedLifetime) -> &chalk_ir::LifetimeData<Self> {\n         &lifetime\n     }\n \n     fn intern_const(self, constant: chalk_ir::ConstData<Self>) -> Self::InternedConst {\n         Box::new(constant)\n     }\n \n-    fn const_data<'a>(self, constant: &'a Self::InternedConst) -> &'a chalk_ir::ConstData<Self> {\n+    fn const_data(self, constant: &Self::InternedConst) -> &chalk_ir::ConstData<Self> {\n         &constant\n     }\n \n@@ -246,18 +243,15 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Box::new(data)\n     }\n \n-    fn generic_arg_data<'a>(\n-        self,\n-        data: &'a Self::InternedGenericArg,\n-    ) -> &'a chalk_ir::GenericArgData<Self> {\n+    fn generic_arg_data(self, data: &Self::InternedGenericArg) -> &chalk_ir::GenericArgData<Self> {\n         &data\n     }\n \n     fn intern_goal(self, goal: chalk_ir::GoalData<Self>) -> Self::InternedGoal {\n         Box::new(goal)\n     }\n \n-    fn goal_data<'a>(self, goal: &'a Self::InternedGoal) -> &'a chalk_ir::GoalData<Self> {\n+    fn goal_data(self, goal: &Self::InternedGoal) -> &chalk_ir::GoalData<Self> {\n         &goal\n     }\n \n@@ -268,7 +262,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn goals_data<'a>(self, goals: &'a Self::InternedGoals) -> &'a [chalk_ir::Goal<Self>] {\n+    fn goals_data(self, goals: &Self::InternedGoals) -> &[chalk_ir::Goal<Self>] {\n         goals\n     }\n \n@@ -279,10 +273,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn substitution_data<'a>(\n+    fn substitution_data(\n         self,\n-        substitution: &'a Self::InternedSubstitution,\n-    ) -> &'a [chalk_ir::GenericArg<Self>] {\n+        substitution: &Self::InternedSubstitution,\n+    ) -> &[chalk_ir::GenericArg<Self>] {\n         substitution\n     }\n \n@@ -293,10 +287,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Box::new(data)\n     }\n \n-    fn program_clause_data<'a>(\n+    fn program_clause_data(\n         self,\n-        clause: &'a Self::InternedProgramClause,\n-    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        clause: &Self::InternedProgramClause,\n+    ) -> &chalk_ir::ProgramClauseData<Self> {\n         &clause\n     }\n \n@@ -307,10 +301,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn program_clauses_data<'a>(\n+    fn program_clauses_data(\n         self,\n-        clauses: &'a Self::InternedProgramClauses,\n-    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        clauses: &Self::InternedProgramClauses,\n+    ) -> &[chalk_ir::ProgramClause<Self>] {\n         clauses\n     }\n \n@@ -321,10 +315,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn quantified_where_clauses_data<'a>(\n+    fn quantified_where_clauses_data(\n         self,\n-        clauses: &'a Self::InternedQuantifiedWhereClauses,\n-    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses: &Self::InternedQuantifiedWhereClauses,\n+    ) -> &[chalk_ir::QuantifiedWhereClause<Self>] {\n         clauses\n     }\n \n@@ -335,10 +329,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn variable_kinds_data<'a>(\n+    fn variable_kinds_data(\n         self,\n-        parameter_kinds: &'a Self::InternedVariableKinds,\n-    ) -> &'a [chalk_ir::VariableKind<Self>] {\n+        parameter_kinds: &Self::InternedVariableKinds,\n+    ) -> &[chalk_ir::VariableKind<Self>] {\n         parameter_kinds\n     }\n \n@@ -349,10 +343,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn canonical_var_kinds_data<'a>(\n+    fn canonical_var_kinds_data(\n         self,\n-        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n-    ) -> &'a [chalk_ir::CanonicalVarKind<Self>] {\n+        canonical_var_kinds: &Self::InternedCanonicalVarKinds,\n+    ) -> &[chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n \n@@ -363,10 +357,10 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn constraints_data<'a>(\n+    fn constraints_data(\n         self,\n-        constraints: &'a Self::InternedConstraints,\n-    ) -> &'a [chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n+        constraints: &Self::InternedConstraints,\n+    ) -> &[chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n         constraints\n     }\n \n@@ -377,10 +371,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         data.into_iter().collect::<Result<Vec<_>, _>>()\n     }\n \n-    fn variances_data<'a>(\n-        self,\n-        variances: &'a Self::InternedVariances,\n-    ) -> &'a [chalk_ir::Variance] {\n+    fn variances_data(self, variances: &Self::InternedVariances) -> &[chalk_ir::Variance] {\n         variances\n     }\n }"}, {"sha": "6a149be3137ee69ecc0145939aa4e6701aded6ec", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -96,7 +96,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n \n-#[derive(Copy, Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable, PartialEq, Eq)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;"}, {"sha": "aad5b2fbe0769c115b25f290980ec972d5ae2369", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -60,7 +60,7 @@ pub enum OverlapMode {\n }\n \n impl OverlapMode {\n-    pub fn get<'tcx>(tcx: TyCtxt<'tcx>, trait_id: DefId) -> OverlapMode {\n+    pub fn get(tcx: TyCtxt<'_>, trait_id: DefId) -> OverlapMode {\n         let with_negative_coherence = tcx.features().with_negative_coherence;\n         let strict_coherence = tcx.has_attr(trait_id, sym::rustc_strict_coherence);\n \n@@ -180,6 +180,7 @@ impl Iterator for Ancestors<'_> {\n }\n \n /// Information about the most specialized definition of an associated item.\n+#[derive(Debug)]\n pub struct LeafDef {\n     /// The associated item described by this `LeafDef`.\n     pub item: ty::AssocItem,\n@@ -253,11 +254,11 @@ impl<'tcx> Ancestors<'tcx> {\n ///\n /// Returns `Err` if an error was reported while building the specialization\n /// graph.\n-pub fn ancestors<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn ancestors(\n+    tcx: TyCtxt<'_>,\n     trait_def_id: DefId,\n     start_from_impl: DefId,\n-) -> Result<Ancestors<'tcx>, ErrorGuaranteed> {\n+) -> Result<Ancestors<'_>, ErrorGuaranteed> {\n     let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n \n     if let Some(reported) = specialization_graph.has_errored {"}, {"sha": "6ade8935fc84f3116607411fe126a9664c2def53", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -238,10 +238,7 @@ impl<'tcx> CapturedPlace<'tcx> {\n     }\n }\n \n-fn symbols_for_closure_captures<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: (LocalDefId, LocalDefId),\n-) -> Vec<Symbol> {\n+fn symbols_for_closure_captures(tcx: TyCtxt<'_>, def_id: (LocalDefId, LocalDefId)) -> Vec<Symbol> {\n     let typeck_results = tcx.typeck(def_id.0);\n     let captures = typeck_results.closure_min_captures_flattened(def_id.1);\n     captures.into_iter().map(|captured_place| captured_place.to_symbol(tcx)).collect()"}, {"sha": "8cc8286c1dbe67ea25fba051aab058f27ba18d2b", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -310,7 +310,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        let consts: ty::ConstS<'tcx> = Decodable::decode(decoder);\n+        let consts: ty::ConstData<'tcx> = Decodable::decode(decoder);\n         decoder.interner().mk_const(consts.kind, consts.ty)\n     }\n }"}, {"sha": "152a7e9d43fa4e32e7c6754efb5397cdc782beeb", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -14,10 +14,10 @@ pub use int::*;\n pub use kind::*;\n pub use valtree::*;\n \n-/// Use this rather than `ConstS`, whenever possible.\n+/// Use this rather than `ConstData, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n-pub struct Const<'tcx>(pub Interned<'tcx, ConstS<'tcx>>);\n+pub struct Const<'tcx>(pub(super) Interned<'tcx, ConstData<'tcx>>);\n \n impl<'tcx> fmt::Debug for Const<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -30,13 +30,13 @@ impl<'tcx> fmt::Debug for Const<'tcx> {\n \n /// Typed constant value.\n #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, TyEncodable, TyDecodable)]\n-pub struct ConstS<'tcx> {\n+pub struct ConstData<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub kind: ConstKind<'tcx>,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ConstS<'_>, 40);\n+static_assert_size!(ConstData<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n@@ -239,7 +239,7 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Const<'tcx> {\n+pub fn const_param_default(tcx: TyCtxt<'_>, def_id: DefId) -> Const<'_> {\n     let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { default: Some(ac), .. },"}, {"sha": "48958e0d9e91cd6328ea6eff03b246257a5de180", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -232,7 +232,7 @@ impl ScalarInt {\n     }\n \n     #[inline]\n-    pub fn try_to_machine_usize<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Result<u64, Size> {\n+    pub fn try_to_machine_usize(&self, tcx: TyCtxt<'_>) -> Result<u64, Size> {\n         Ok(self.to_bits(tcx.data_layout.pointer_size)? as u64)\n     }\n "}, {"sha": "5de414077a2b134bc8b9c0ac4924cc18f23b9565", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -17,7 +17,7 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n-    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstS, DefIdTree, FloatTy, FloatVar,\n+    self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, DefIdTree, FloatTy, FloatVar,\n     FloatVid, GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst,\n     ParamTy, PolyExistentialPredicate, PolyFnSig, Predicate, PredicateKind, Region, RegionKind,\n     ReprOptions, TraitObjectVisitor, Ty, TyKind, TyVar, TyVid, TypeAndMut, TypeckResults, UintTy,\n@@ -140,7 +140,7 @@ pub struct CtxtInterners<'tcx> {\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n-    const_: InternedSet<'tcx, ConstS<'tcx>>,\n+    const_: InternedSet<'tcx, ConstData<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n     layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n@@ -331,7 +331,7 @@ impl<'tcx> CommonConsts<'tcx> {\n         };\n \n         CommonConsts {\n-            unit: mk_const(ty::ConstS {\n+            unit: mk_const(ty::ConstData {\n                 kind: ty::ConstKind::Value(ty::ValTree::zst()),\n                 ty: types.unit,\n             }),\n@@ -1518,7 +1518,7 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n \n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx, T> Borrow<T> for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n-    fn borrow<'a>(&'a self) -> &'a T {\n+    fn borrow(&self) -> &T {\n         &self.0.internee\n     }\n }\n@@ -1541,7 +1541,7 @@ impl<'tcx, T: Hash> Hash for InternedInSet<'tcx, WithCachedTypeInfo<T>> {\n }\n \n impl<'tcx, T> Borrow<[T]> for InternedInSet<'tcx, List<T>> {\n-    fn borrow<'a>(&'a self) -> &'a [T] {\n+    fn borrow(&self) -> &[T] {\n         &self.0[..]\n     }\n }\n@@ -1601,7 +1601,7 @@ macro_rules! direct_interners {\n \n direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n-    const_: mk_const_internal(ConstS<'tcx>): Const -> Const<'tcx>,\n+    const_: mk_const_internal(ConstData<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n@@ -1976,7 +1976,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_const(self, kind: impl Into<ty::ConstKind<'tcx>>, ty: Ty<'tcx>) -> Const<'tcx> {\n-        self.mk_const_internal(ty::ConstS { kind: kind.into(), ty })\n+        self.mk_const_internal(ty::ConstData { kind: kind.into(), ty })\n     }\n \n     #[inline]"}, {"sha": "8306d670a65deed8e81a4ecd092790b5834786e9", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -22,7 +22,7 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_predicate<'tcx>(binder: ty::Binder<'tcx, ty::PredicateKind<'_>>) -> FlagComputation {\n+    pub fn for_predicate(binder: ty::Binder<'_, ty::PredicateKind<'_>>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_predicate(binder);\n         result\n@@ -95,7 +95,7 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n \n-            &ty::Generator(_, ref substs, _) => {\n+            ty::Generator(_, substs, _) => {\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -186,7 +186,7 @@ impl FlagComputation {\n \n             &ty::Slice(tt) => self.add_ty(tt),\n \n-            &ty::RawPtr(ref m) => {\n+            ty::RawPtr(m) => {\n                 self.add_ty(m.ty);\n             }\n "}, {"sha": "705adecd3b90f517b9d9c5ed814fdcbaecf4c111", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -70,14 +70,6 @@ impl GenericParamDef {\n         }\n     }\n \n-    pub fn has_default(&self) -> bool {\n-        match self.kind {\n-            GenericParamDefKind::Type { has_default, .. }\n-            | GenericParamDefKind::Const { has_default } => has_default,\n-            GenericParamDefKind::Lifetime => false,\n-        }\n-    }\n-\n     pub fn is_anonymous_lifetime(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime => {"}, {"sha": "9e0ca44d0981df0dbcf4afc9a3282310d37d1c1e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -993,7 +993,7 @@ where\n /// might (from a foreign exception or similar).\n #[inline]\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n-pub fn fn_can_unwind<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: Option<DefId>, abi: SpecAbi) -> bool {\n+pub fn fn_can_unwind(tcx: TyCtxt<'_>, fn_def_id: Option<DefId>, abi: SpecAbi) -> bool {\n     if let Some(did) = fn_def_id {\n         // Special attribute for functions which can't unwind.\n         if tcx.codegen_fn_attrs(did).flags.contains(CodegenFnAttrFlags::NEVER_UNWIND) {"}, {"sha": "f01d74539a12e1b9be8731abf0b56d9d7eb45cf5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -80,7 +80,7 @@ pub use self::closure::{\n     CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{\n-    Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n+    Const, ConstData, ConstInt, ConstKind, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n     tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n@@ -535,6 +535,17 @@ impl<'tcx> Predicate<'tcx> {\n         self\n     }\n \n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n+    pub fn is_coinductive(self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n+                tcx.trait_is_coinductive(data.def_id())\n+            }\n+            ty::PredicateKind::WellFormed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Whether this projection can be soundly normalized.\n     ///\n     /// Wf predicates must not be normalized, as normalization\n@@ -945,7 +956,7 @@ impl<'tcx> Term<'tcx> {\n                     &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => TermKind::Const(ty::Const(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n+                    &*((ptr & !TAG_MASK) as *const ty::ConstData<'tcx>),\n                 ))),\n                 _ => core::intrinsics::unreachable(),\n             }\n@@ -991,7 +1002,7 @@ impl<'tcx> TermKind<'tcx> {\n             TermKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ct.0.0) & TAG_MASK, 0);\n-                (CONST_TAG, ct.0.0 as *const ty::ConstS<'tcx> as usize)\n+                (CONST_TAG, ct.0.0 as *const ty::ConstData<'tcx> as usize)\n             }\n         };\n \n@@ -1018,6 +1029,24 @@ pub struct ProjectionPredicate<'tcx> {\n     pub term: Term<'tcx>,\n }\n \n+impl<'tcx> ProjectionPredicate<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.projection_ty.self_ty()\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ProjectionPredicate<'tcx> {\n+        Self { projection_ty: self.projection_ty.with_self_ty(tcx, self_ty), ..self }\n+    }\n+\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.projection_ty.trait_def_id(tcx)\n+    }\n+\n+    pub fn def_id(self) -> DefId {\n+        self.projection_ty.def_id\n+    }\n+}\n+\n pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n@@ -1054,18 +1083,6 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ProjectionPredicate<'tcx> {\n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        Self {\n-            projection_ty: tcx.mk_alias_ty(\n-                self.projection_ty.def_id,\n-                [self_ty.into()].into_iter().chain(self.projection_ty.substs.iter().skip(1)),\n-            ),\n-            ..self\n-        }\n-    }\n-}\n-\n pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }"}, {"sha": "c49e75d68ad32b3401efcfa533edcf6e94ba9933", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -2883,13 +2883,19 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n /// `std::vec::Vec` to just `Vec`, as long as there is no other `Vec` importable anywhere.\n ///\n /// The implementation uses similar import discovery logic to that of 'use' suggestions.\n+///\n+/// See also [`DelayDm`](rustc_error_messages::DelayDm) and [`with_no_trimmed_paths`].\n fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n     let mut map: FxHashMap<DefId, Symbol> = FxHashMap::default();\n \n     if let TrimmedDefPaths::GoodPath = tcx.sess.opts.trimmed_def_paths {\n+        // Trimming paths is expensive and not optimized, since we expect it to only be used for error reporting.\n+        //\n         // For good paths causing this bug, the `rustc_middle::ty::print::with_no_trimmed_paths`\n         // wrapper can be used to suppress this query, in exchange for full paths being formatted.\n-        tcx.sess.delay_good_path_bug(\"trimmed_def_paths constructed\");\n+        tcx.sess.delay_good_path_bug(\n+            \"trimmed_def_paths constructed but no error emitted; use `DelayDm` for lints or `with_no_trimmed_paths` for debugging\",\n+        );\n     }\n \n     let unique_symbols_rev: &mut FxHashMap<(Namespace, Symbol), Option<DefId>> ="}, {"sha": "4d34ca3d66b5fd20b86a7b9fbbec7b0e51f60bdd", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -428,7 +428,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(a)\n         }\n \n-        (&ty::Param(ref a_p), &ty::Param(ref b_p)) if a_p.index == b_p.index => Ok(a),\n+        (ty::Param(a_p), ty::Param(b_p)) if a_p.index == b_p.index => Ok(a),\n \n         (ty::Placeholder(p1), ty::Placeholder(p2)) if p1 == p2 => Ok(a),\n "}, {"sha": "30073b541ecbd0e5c09a32e0c91bcd028a6fa770", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -99,12 +99,6 @@ impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n     }\n }\n \n-impl fmt::Debug for ty::RegionVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"'_#{}r\", self.index())\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_no_trimmed_paths!(fmt::Display::fmt(self, f))"}, {"sha": "f7e4c8215698eca6d36c3e52a9d2a79061b323ee", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1169,7 +1169,7 @@ pub struct AliasTy<'tcx> {\n }\n \n impl<'tcx> AliasTy<'tcx> {\n-    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n@@ -1183,7 +1183,7 @@ impl<'tcx> AliasTy<'tcx> {\n     /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n     /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n     pub fn trait_ref_and_own_substs(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n         debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));\n@@ -1202,14 +1202,18 @@ impl<'tcx> AliasTy<'tcx> {\n     /// WARNING: This will drop the substs for generic associated types\n     /// consider calling [Self::trait_ref_and_own_substs] to get those\n     /// as well.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         tcx.mk_trait_ref(def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.substs.type_at(0)\n     }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n }\n \n #[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n@@ -1378,9 +1382,8 @@ pub struct ConstVid<'tcx> {\n rustc_index::newtype_index! {\n     /// A **region** (lifetime) **v**ariable **ID**.\n     #[derive(HashStable)]\n-    pub struct RegionVid {\n-        DEBUG_FORMAT = custom,\n-    }\n+    #[debug_format = \"'_#{}r\"]\n+    pub struct RegionVid {}\n }\n \n impl Atom for RegionVid {\n@@ -1391,7 +1394,7 @@ impl Atom for RegionVid {\n \n rustc_index::newtype_index! {\n     #[derive(HashStable)]\n-    pub struct BoundVar { .. }\n+    pub struct BoundVar {}\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]"}, {"sha": "0c33e5bda1a55a2fe0d29047963b394b38d324ad", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(&*ct.0.0) & TAG_MASK, 0);\n-                (CONST_TAG, ct.0.0 as *const ty::ConstS<'tcx> as usize)\n+                (CONST_TAG, ct.0.0 as *const ty::ConstData<'tcx> as usize)\n             }\n         };\n \n@@ -166,7 +166,7 @@ impl<'tcx> GenericArg<'tcx> {\n                     &*((ptr & !TAG_MASK) as *const WithCachedTypeInfo<ty::TyKind<'tcx>>),\n                 ))),\n                 CONST_TAG => GenericArgKind::Const(ty::Const(Interned::new_unchecked(\n-                    &*((ptr & !TAG_MASK) as *const ty::ConstS<'tcx>),\n+                    &*((ptr & !TAG_MASK) as *const ty::ConstData<'tcx>),\n                 ))),\n                 _ => intrinsics::unreachable(),\n             }\n@@ -348,7 +348,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n         substs.reserve(defs.params.len());\n         for param in &defs.params {\n             let kind = mk_kind(param, substs);\n-            assert_eq!(param.index as usize, substs.len());\n+            assert_eq!(param.index as usize, substs.len(), \"{substs:#?}, {defs:#?}\");\n             substs.push(kind);\n         }\n     }\n@@ -400,6 +400,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n         if let GenericArgKind::Type(ty) = self[i].unpack() {\n             ty\n@@ -409,6 +410,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n         if let GenericArgKind::Lifetime(lt) = self[i].unpack() {\n             lt\n@@ -418,6 +420,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn const_at(&self, i: usize) -> ty::Const<'tcx> {\n         if let GenericArgKind::Const(ct) = self[i].unpack() {\n             ct\n@@ -427,6 +430,7 @@ impl<'tcx> InternalSubsts<'tcx> {\n     }\n \n     #[inline]\n+    #[track_caller]\n     pub fn type_for_def(&self, def: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         self.type_at(def.index as usize).into()\n     }\n@@ -573,6 +577,10 @@ impl<T> EarlyBinder<T> {\n     pub fn rebind<U>(&self, value: U) -> EarlyBinder<U> {\n         EarlyBinder(value)\n     }\n+\n+    pub fn skip_binder(self) -> T {\n+        self.0\n+    }\n }\n \n impl<T> EarlyBinder<Option<T>> {"}, {"sha": "136a4906c58de7f1c607e70a90af645b43381c4b", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -608,10 +608,10 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n }\n \n rustc_index::newtype_index! {\n+    #[derive(HashStable)]\n+    #[debug_format = \"UserType({})\"]\n     pub struct UserTypeAnnotationIndex {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"UserType({})\",\n-        const START_INDEX = 0,\n+        const START_INDEX = 0;\n     }\n }\n "}, {"sha": "6d3b94c1fdbf8651c113ba2f7dd73e4fb09cb8bd", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -3,6 +3,7 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n use crate::ty::layout::IntegerExt;\n+use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -769,6 +770,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n+impl<'tcx> TyCtxtAt<'tcx> {\n+    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n+    }\n+}\n+\n struct OpaqueTypeExpander<'tcx> {\n     // Contains the DefIds of the opaque types that are currently being\n     // expanded. When we expand an opaque type we insert the DefId of\n@@ -1241,7 +1248,7 @@ pub fn needs_drop_components<'tcx>(\n     }\n }\n \n-pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n+pub fn is_trivially_const_drop(ty: Ty<'_>) -> bool {\n     match *ty.kind() {\n         ty::Bool\n         | ty::Char"}, {"sha": "d5553f84f7517d8531eb348324bef6c259f44b2c", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -88,9 +88,11 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n-    #[instrument(level = \"trace\", ret)]\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n+        let res =\n+            self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags);\n+        trace!(?self, ?flags, ?res, \"has_type_flags\");\n+        res\n     }\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n@@ -560,10 +562,8 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = t.flags();\n-        trace!(t.flags=?t.flags());\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -572,10 +572,8 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = r.type_flags();\n-        trace!(r.flags=?flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n@@ -584,7 +582,6 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\", ret)]\n     fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);\n@@ -596,14 +593,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\", ret)]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate,\n-            predicate.flags(),\n-            self.flags\n-        );\n         if predicate.flags().intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {"}, {"sha": "f77bd9f0c6ffc320d6222f03130feff9550ab844", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -88,8 +88,8 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n                 let fn_ptr = Pointer::from(fn_alloc_id);\n                 Scalar::from_pointer(fn_ptr, &tcx)\n             }\n-            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n-            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size),\n+            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size),\n             VtblEntry::Vacant => continue,\n             VtblEntry::Method(instance) => {\n                 // Prepare the fn ptr we write into the vtable."}, {"sha": "c242be570312354d780529f5df3449d0e6d64ffe", "filename": "compiler/rustc_middle/src/values.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fvalues.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,3 +1,4 @@\n+use crate::dep_graph::DepKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_hir as hir;\n@@ -11,16 +12,16 @@ use rustc_span::Span;\n \n use std::fmt::Write;\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for Ty<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Ty<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo<DepKind>]) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe { std::mem::transmute::<Ty<'tcx>, Ty<'_>>(tcx.ty_error()) }\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::SymbolName<'_> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, _: &[QueryInfo<DepKind>]) -> Self {\n         // SAFETY: This is never called when `Self` is not `SymbolName<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow.\n         unsafe {\n@@ -31,12 +32,12 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::SymbolName<'_> {\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for ty::Binder<'_, ty::FnSig<'_>> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, stack: &[QueryInfo<DepKind>]) -> Self {\n         let err = tcx.ty_error();\n \n         let arity = if let Some(frame) = stack.get(0)\n-            && frame.query.name == \"fn_sig\"\n+            && frame.query.dep_kind == DepKind::fn_sig\n             && let Some(def_id) = frame.query.def_id\n             && let Some(node) = tcx.hir().get_if_local(def_id)\n             && let Some(sig) = node.fn_sig()\n@@ -61,12 +62,12 @@ impl<'tcx> Value<TyCtxt<'tcx>> for ty::Binder<'_, ty::FnSig<'_>> {\n     }\n }\n \n-impl<'tcx> Value<TyCtxt<'tcx>> for Representability {\n-    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo]) -> Self {\n+impl<'tcx> Value<TyCtxt<'tcx>, DepKind> for Representability {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx>, cycle: &[QueryInfo<DepKind>]) -> Self {\n         let mut item_and_field_ids = Vec::new();\n         let mut representable_ids = FxHashSet::default();\n         for info in cycle {\n-            if info.query.name == \"representability\"\n+            if info.query.dep_kind == DepKind::representability\n                 && let Some(field_id) = info.query.def_id\n                 && let Some(field_id) = field_id.as_local()\n                 && let Some(DefKind::Field) = info.query.def_kind\n@@ -80,7 +81,7 @@ impl<'tcx> Value<TyCtxt<'tcx>> for Representability {\n             }\n         }\n         for info in cycle {\n-            if info.query.name == \"representability_adt_ty\"\n+            if info.query.dep_kind == DepKind::representability_adt_ty\n                 && let Some(def_id) = info.query.ty_adt_id\n                 && let Some(def_id) = def_id.as_local()\n                 && !item_and_field_ids.iter().any(|&(id, _)| id == def_id)"}, {"sha": "4ad3343d3031b2fa1e0f23eb2efc03ffd85edad1", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -17,6 +17,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_infer = { path = \"../rustc_infer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "dca4906c07de54bd2042edccd8ab65a5702e44fb", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -15,9 +15,6 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n-            @call(\"mir_retag_raw\", args) => {\n-                Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n-            },\n             @call(\"mir_set_discriminant\", args) => {\n                 let place = self.parse_place(args[0])?;\n                 let var = self.parse_integer_literal(args[1])? as u32;\n@@ -42,6 +39,29 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_goto\", args) => {\n                 Ok(TerminatorKind::Goto { target: self.parse_block(args[0])? } )\n             },\n+            @call(\"mir_unreachable\", _args) => {\n+                Ok(TerminatorKind::Unreachable)\n+            },\n+            @call(\"mir_drop\", args) => {\n+                Ok(TerminatorKind::Drop {\n+                    place: self.parse_place(args[0])?,\n+                    target: self.parse_block(args[1])?,\n+                    unwind: None,\n+                })\n+            },\n+            @call(\"mir_drop_and_replace\", args) => {\n+                Ok(TerminatorKind::DropAndReplace {\n+                    place: self.parse_place(args[0])?,\n+                    value: self.parse_operand(args[1])?,\n+                    target: self.parse_block(args[2])?,\n+                    unwind: None,\n+                })\n+            },\n+            @call(\"mir_call\", args) => {\n+                let destination = self.parse_place(args[0])?;\n+                let target = self.parse_block(args[1])?;\n+                self.parse_call(args[2], destination, target)\n+            },\n             ExprKind::Match { scrutinee, arms } => {\n                 let discr = self.parse_operand(*scrutinee)?;\n                 self.parse_match(arms, expr.span).map(|t| TerminatorKind::SwitchInt { discr, targets: t })\n@@ -53,7 +73,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n         let Some((otherwise, rest)) = arms.split_last() else {\n             return Err(ParseError {\n                 span,\n-                item_description: format!(\"no arms\"),\n+                item_description: \"no arms\".to_string(),\n                 expected: \"at least one arm\".to_string(),\n             })\n         };\n@@ -86,6 +106,32 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n         Ok(SwitchTargets::new(values.into_iter().zip(targets), otherwise))\n     }\n \n+    fn parse_call(\n+        &self,\n+        expr_id: ExprId,\n+        destination: Place<'tcx>,\n+        target: BasicBlock,\n+    ) -> PResult<TerminatorKind<'tcx>> {\n+        parse_by_kind!(self, expr_id, _, \"function call\",\n+            ExprKind::Call { fun, args, from_hir_call, fn_span, .. } => {\n+                let fun = self.parse_operand(*fun)?;\n+                let args = args\n+                    .iter()\n+                    .map(|arg| self.parse_operand(*arg))\n+                    .collect::<PResult<Vec<_>>>()?;\n+                Ok(TerminatorKind::Call {\n+                    func: fun,\n+                    args,\n+                    destination,\n+                    target: Some(target),\n+                    cleanup: None,\n+                    from_hir_call: *from_hir_call,\n+                    fn_span: *fn_span,\n+                })\n+            },\n+        )\n+    }\n+\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"rvalue\",\n             @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),"}, {"sha": "1d96893c7a3ea966aecc4852e79ea01fba386200", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -66,14 +66,14 @@ pub fn as_constant_inner<'tcx>(\n \n             let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n-            Constant { span, user_ty: user_ty, literal }\n+            Constant { span, user_ty, literal }\n         }\n         ExprKind::ZstLiteral { ref user_ty } => {\n             let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n             let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n-            Constant { span, user_ty: user_ty, literal }\n+            Constant { span, user_ty, literal }\n         }\n         ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n             let user_ty = user_ty.as_ref().map(push_cuta).flatten();"}, {"sha": "dbcb0132c9f88f5993ca0c7920ba79ada3cb9d07", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// will actually provide a pointer to the interior of the box, and not move the `dyn Debug`\n     /// value to the stack.\n     ///\n-    /// See #68034 for more details.\n+    /// See #68304 for more details.\n     pub(crate) fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,"}, {"sha": "e22fa6365dcb44ebb25f27e7bd1e58cc254c6d02", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -81,8 +81,8 @@ pub(in crate::build) struct PlaceBuilder<'tcx> {\n /// ProjectionElems `Downcast`, `ConstantIndex`, `Index`, or `Subslice` because those will never be\n /// part of a path that is captured by a closure. We stop applying projections once we see the first\n /// projection that isn't captured by a closure.\n-fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n-    mir_projections: &[PlaceElem<'tcx>],\n+fn convert_to_hir_projections_and_truncate_for_capture(\n+    mir_projections: &[PlaceElem<'_>],\n ) -> Vec<HirProjectionKind> {\n     let mut hir_projections = Vec::new();\n     let mut variant = None;"}, {"sha": "f90aba80bf3cf574f17fb3b0571cac22b5b4d6d2", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -2210,7 +2210,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n-        let local = LocalDecl::<'tcx> {\n+        let local = LocalDecl {\n             mutability,\n             ty: var_ty,\n             user_ty: if user_ty.is_empty() { None } else { Some(Box::new(user_ty)) },"}, {"sha": "46e14cc9ac3b10667b9b5a5c2b19e9f40af71655", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -551,16 +551,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             //\n             // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n-            (\n-                &TestKind::SwitchInt { switch_ty: _, ref options },\n-                &PatKind::Constant { ref value },\n-            ) if is_switch_ty(match_pair.pattern.ty) => {\n+            (TestKind::SwitchInt { switch_ty: _, options }, PatKind::Constant { value })\n+                if is_switch_ty(match_pair.pattern.ty) =>\n+            {\n                 let index = options.get_index_of(value).unwrap();\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n-            (&TestKind::SwitchInt { switch_ty: _, ref options }, &PatKind::Range(ref range)) => {\n+            (TestKind::SwitchInt { switch_ty: _, options }, PatKind::Range(range)) => {\n                 let not_contained =\n                     self.values_not_contained_in_range(&*range, options).unwrap_or(false);\n \n@@ -578,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             (\n                 &TestKind::Len { len: test_len, op: BinOp::Eq },\n-                &PatKind::Slice { ref prefix, ref slice, ref suffix },\n+                PatKind::Slice { prefix, slice, suffix },\n             ) => {\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n                 match (test_len.cmp(&pat_len), slice) {\n@@ -615,7 +614,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             (\n                 &TestKind::Len { len: test_len, op: BinOp::Ge },\n-                &PatKind::Slice { ref prefix, ref slice, ref suffix },\n+                PatKind::Slice { prefix, slice, suffix },\n             ) => {\n                 // the test is `$actual_len >= test_len`\n                 let pat_len = (prefix.len() + suffix.len()) as u64;\n@@ -651,7 +650,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(ref test), &PatKind::Range(ref pat)) => {\n+            (TestKind::Range(test), PatKind::Range(pat)) => {\n                 use std::cmp::Ordering::*;\n \n                 if test == pat {\n@@ -678,7 +677,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 no_overlap\n             }\n \n-            (&TestKind::Range(ref range), &PatKind::Constant { value }) => {\n+            (TestKind::Range(range), &PatKind::Constant { value }) => {\n                 if let Some(false) = self.const_range_contains(&*range, value) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails."}, {"sha": "9daf68a15f4b1ea4aef695c67f463e6f72514523", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -28,10 +28,10 @@ use rustc_target::spec::abi::Abi;\n \n use super::lints;\n \n-pub(crate) fn mir_built<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn mir_built(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx rustc_data_structures::steal::Steal<Body<'tcx>> {\n+) -> &rustc_data_structures::steal::Steal<Body<'_>> {\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_built(def);\n     }\n@@ -372,7 +372,7 @@ struct CFG<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    struct ScopeId { .. }\n+    struct ScopeId {}\n }\n \n #[derive(Debug)]\n@@ -625,12 +625,12 @@ fn construct_const<'a, 'tcx>(\n ///\n /// This is required because we may still want to run MIR passes on an item\n /// with type errors, but normal MIR construction can't handle that in general.\n-fn construct_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn construct_error(\n+    tcx: TyCtxt<'_>,\n     def: LocalDefId,\n     body_owner_kind: hir::BodyOwnerKind,\n     err: ErrorGuaranteed,\n-) -> Body<'tcx> {\n+) -> Body<'_> {\n     let span = tcx.def_span(def);\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def);\n     let generator_kind = tcx.generator_kind(def);"}, {"sha": "c92634a609de0f762df392231779f6510bc5a72e", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -185,7 +185,7 @@ pub(crate) enum BreakableTarget {\n }\n \n rustc_index::newtype_index! {\n-    struct DropIdx { .. }\n+    struct DropIdx {}\n }\n \n const ROOT_NODE: DropIdx = DropIdx::from_u32(0);"}, {"sha": "3c311729a52aa6dd0f29c912c7230d721ec97bef", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 189, "deletions": 99, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,7 +1,7 @@\n use crate::build::ExprCategory;\n+use crate::errors::*;\n use rustc_middle::thir::visit::{self, Visitor};\n \n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::thir::*;\n@@ -12,7 +12,6 @@ use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n-use std::borrow::Cow;\n use std::ops::Bound;\n \n struct UnsafetyVisitor<'a, 'tcx> {\n@@ -46,7 +45,9 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             self.warn_unused_unsafe(\n                 hir_id,\n                 block_span,\n-                Some((self.tcx.sess.source_map().guess_head_span(enclosing_span), \"block\")),\n+                Some(UnusedUnsafeEnclosing::Block {\n+                    span: self.tcx.sess.source_map().guess_head_span(enclosing_span),\n+                }),\n             );\n             f(self);\n         } else {\n@@ -60,7 +61,9 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n                     hir_id,\n                     span,\n                     if self.unsafe_op_in_unsafe_fn_allowed() {\n-                        self.body_unsafety.unsafe_fn_sig_span().map(|span| (span, \"fn\"))\n+                        self.body_unsafety\n+                            .unsafe_fn_sig_span()\n+                            .map(|span| UnusedUnsafeEnclosing::Function { span })\n                     } else {\n                         None\n                     },\n@@ -83,30 +86,11 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             }\n             SafetyContext::UnsafeFn if unsafe_op_in_unsafe_fn_allowed => {}\n             SafetyContext::UnsafeFn => {\n-                let (description, note) = kind.description_and_note(self.tcx);\n                 // unsafe_op_in_unsafe_fn is disallowed\n-                self.tcx.struct_span_lint_hir(\n-                    UNSAFE_OP_IN_UNSAFE_FN,\n-                    self.hir_context,\n-                    span,\n-                    format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n-                    |lint| lint.span_label(span, kind.simple_description()).note(note),\n-                )\n+                kind.emit_unsafe_op_in_unsafe_fn_lint(self.tcx, self.hir_context, span);\n             }\n             SafetyContext::Safe => {\n-                let (description, note) = kind.description_and_note(self.tcx);\n-                let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe{} block\",\n-                    description,\n-                    fn_sugg,\n-                )\n-                .span_label(span, kind.simple_description())\n-                .note(note)\n-                .emit();\n+                kind.emit_requires_unsafe_err(self.tcx, span, unsafe_op_in_unsafe_fn_allowed);\n             }\n         }\n     }\n@@ -115,17 +99,15 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         block_span: Span,\n-        enclosing_unsafe: Option<(Span, &'static str)>,\n+        enclosing_unsafe: Option<UnusedUnsafeEnclosing>,\n     ) {\n         let block_span = self.tcx.sess.source_map().guess_head_span(block_span);\n-        let msg = \"unnecessary `unsafe` block\";\n-        self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, msg, |lint| {\n-            lint.span_label(block_span, msg);\n-            if let Some((span, kind)) = enclosing_unsafe {\n-                lint.span_label(span, format!(\"because it's nested under this `unsafe` {}\", kind));\n-            }\n-            lint\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_UNSAFE,\n+            hir_id,\n+            block_span,\n+            UnusedUnsafe { span: block_span, enclosing: enclosing_unsafe },\n+        );\n     }\n \n     /// Whether the `unsafe_op_in_unsafe_fn` lint is `allow`ed at the current HIR node.\n@@ -536,84 +518,192 @@ enum UnsafeOpKind {\n use UnsafeOpKind::*;\n \n impl UnsafeOpKind {\n-    pub fn simple_description(&self) -> &'static str {\n-        match self {\n-            CallToUnsafeFunction(..) => \"call to unsafe function\",\n-            UseOfInlineAssembly => \"use of inline assembly\",\n-            InitializingTypeWith => \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n-            UseOfMutableStatic => \"use of mutable static\",\n-            UseOfExternStatic => \"use of extern static\",\n-            DerefOfRawPointer => \"dereference of raw pointer\",\n-            AccessToUnionField => \"access to union field\",\n-            MutationOfLayoutConstrainedField => \"mutation of layout constrained field\",\n-            BorrowOfLayoutConstrainedField => {\n-                \"borrow of layout constrained field with interior mutability\"\n-            }\n-            CallToFunctionWith(..) => \"call to function with `#[target_feature]`\",\n-        }\n-    }\n-\n-    pub fn description_and_note(&self, tcx: TyCtxt<'_>) -> (Cow<'static, str>, &'static str) {\n+    pub fn emit_unsafe_op_in_unsafe_fn_lint(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        hir_id: hir::HirId,\n+        span: Span,\n+    ) {\n         match self {\n-            CallToUnsafeFunction(did) => (\n-                if let Some(did) = did {\n-                    Cow::from(format!(\"call to unsafe function `{}`\", tcx.def_path_str(*did)))\n-                } else {\n-                    Cow::Borrowed(self.simple_description())\n+            CallToUnsafeFunction(did) if did.is_some() => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n                 },\n-                \"consult the function's documentation for information on how to avoid undefined \\\n-                 behavior\",\n             ),\n-            UseOfInlineAssembly => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+            CallToUnsafeFunction(..) => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafeNameless { span },\n             ),\n-            InitializingTypeWith => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"initializing a layout restricted type's field with a value outside the valid \\\n-                 range is undefined behavior\",\n+            UseOfInlineAssembly => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfInlineAssemblyRequiresUnsafe { span },\n             ),\n-            UseOfMutableStatic => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"mutable statics can be mutated by multiple threads: aliasing violations or data \\\n-                 races will cause undefined behavior\",\n+            InitializingTypeWith => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnInitializingTypeWithRequiresUnsafe { span },\n             ),\n-            UseOfExternStatic => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"extern statics are not controlled by the Rust type system: invalid data, \\\n-                 aliasing violations or data races will cause undefined behavior\",\n+            UseOfMutableStatic => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfMutableStaticRequiresUnsafe { span },\n             ),\n-            DerefOfRawPointer => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"raw pointers may be null, dangling or unaligned; they can violate aliasing rules \\\n-                 and cause data races: all of these are undefined behavior\",\n+            UseOfExternStatic => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnUseOfExternStaticRequiresUnsafe { span },\n             ),\n-            AccessToUnionField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"the field may not be properly initialized: using uninitialized data will cause \\\n-                 undefined behavior\",\n+            DerefOfRawPointer => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnDerefOfRawPointerRequiresUnsafe { span },\n             ),\n-            MutationOfLayoutConstrainedField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"mutating layout constrained fields cannot statically be checked for valid values\",\n+            AccessToUnionField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnAccessToUnionFieldRequiresUnsafe { span },\n             ),\n-            BorrowOfLayoutConstrainedField => (\n-                Cow::Borrowed(self.simple_description()),\n-                \"references to fields of layout constrained fields lose the constraints. Coupled \\\n-                 with interior mutability, the field can be changed to invalid values\",\n+            MutationOfLayoutConstrainedField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnMutationOfLayoutConstrainedFieldRequiresUnsafe { span },\n             ),\n-            CallToFunctionWith(did) => (\n-                Cow::from(format!(\n-                    \"call to function `{}` with `#[target_feature]`\",\n-                    tcx.def_path_str(*did)\n-                )),\n-                \"can only be called if the required target features are available\",\n+            BorrowOfLayoutConstrainedField => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnBorrowOfLayoutConstrainedFieldRequiresUnsafe { span },\n+            ),\n+            CallToFunctionWith(did) => tcx.emit_spanned_lint(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                hir_id,\n+                span,\n+                UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                },\n             ),\n         }\n     }\n+\n+    pub fn emit_requires_unsafe_err(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        span: Span,\n+        unsafe_op_in_unsafe_fn_allowed: bool,\n+    ) {\n+        match self {\n+            CallToUnsafeFunction(did) if did.is_some() && unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n+                });\n+            }\n+            CallToUnsafeFunction(did) if did.is_some() => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(did.unwrap()),\n+                });\n+            }\n+            CallToUnsafeFunction(..) if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed { span },\n+                );\n+            }\n+            CallToUnsafeFunction(..) => {\n+                tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeNameless { span });\n+            }\n+            UseOfInlineAssembly if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfInlineAssemblyRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfInlineAssembly => {\n+                tcx.sess.emit_err(UseOfInlineAssemblyRequiresUnsafe { span });\n+            }\n+            InitializingTypeWith if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(InitializingTypeWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            InitializingTypeWith => {\n+                tcx.sess.emit_err(InitializingTypeWithRequiresUnsafe { span });\n+            }\n+            UseOfMutableStatic if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfMutableStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfMutableStatic => {\n+                tcx.sess.emit_err(UseOfMutableStaticRequiresUnsafe { span });\n+            }\n+            UseOfExternStatic if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(UseOfExternStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            UseOfExternStatic => {\n+                tcx.sess.emit_err(UseOfExternStaticRequiresUnsafe { span });\n+            }\n+            DerefOfRawPointer if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(DerefOfRawPointerRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            DerefOfRawPointer => {\n+                tcx.sess.emit_err(DerefOfRawPointerRequiresUnsafe { span });\n+            }\n+            AccessToUnionField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess\n+                    .emit_err(AccessToUnionFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span });\n+            }\n+            AccessToUnionField => {\n+                tcx.sess.emit_err(AccessToUnionFieldRequiresUnsafe { span });\n+            }\n+            MutationOfLayoutConstrainedField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    MutationOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                        span,\n+                    },\n+                );\n+            }\n+            MutationOfLayoutConstrainedField => {\n+                tcx.sess.emit_err(MutationOfLayoutConstrainedFieldRequiresUnsafe { span });\n+            }\n+            BorrowOfLayoutConstrainedField if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(\n+                    BorrowOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed { span },\n+                );\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                tcx.sess.emit_err(BorrowOfLayoutConstrainedFieldRequiresUnsafe { span });\n+            }\n+            CallToFunctionWith(did) if unsafe_op_in_unsafe_fn_allowed => {\n+                tcx.sess.emit_err(CallToFunctionWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                });\n+            }\n+            CallToFunctionWith(did) => {\n+                tcx.sess.emit_err(CallToFunctionWithRequiresUnsafe {\n+                    span,\n+                    function: &tcx.def_path_str(*did),\n+                });\n+            }\n+        }\n+    }\n }\n \n-pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) {\n+pub fn check_unsafety(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) {\n     // THIR unsafeck is gated under `-Z thir-unsafeck`\n     if !tcx.sess.opts.unstable_opts.thir_unsafeck {\n         return;\n@@ -659,16 +749,16 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n     visitor.visit_expr(&thir[expr]);\n }\n \n-pub(crate) fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+pub(crate) fn thir_check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n         tcx.thir_check_unsafety_for_const_arg(def)\n     } else {\n         check_unsafety(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n }\n \n-pub(crate) fn thir_check_unsafety_for_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn thir_check_unsafety_for_const_arg(\n+    tcx: TyCtxt<'_>,\n     (did, param_did): (LocalDefId, DefId),\n ) {\n     check_unsafety(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })"}, {"sha": "68179001b916dbc3ac5128f91d7ed1cdcd7fe6e6", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,616 @@\n+use crate::thir::pattern::MatchCheckCtxt;\n+use rustc_errors::Handler;\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{symbol::Ident, Span};\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unconditional_recursion)]\n+#[help]\n+pub struct UnconditionalRecursion {\n+    #[label]\n+    pub span: Span,\n+    #[label(mir_build_unconditional_recursion_call_site_label)]\n+    pub call_sites: Vec<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe<'a> {\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafeNameless {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfInlineAssemblyRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnInitializingTypeWithRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfMutableStaticRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnUseOfExternStaticRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnDerefOfRawPointerRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnAccessToUnionFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnMutationOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe)]\n+pub struct UnsafeOpInUnsafeFnBorrowOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe)]\n+#[note]\n+pub struct UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe<'a> {\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafe<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe_nameless, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeNameless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_inline_assembly_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfInlineAssemblyRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfInlineAssemblyRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_initializing_type_with_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct InitializingTypeWithRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct InitializingTypeWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutable_static_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfMutableStaticRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfMutableStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_extern_static_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct UseOfExternStaticRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct UseOfExternStaticRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_deref_raw_pointer_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct DerefOfRawPointerRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct DerefOfRawPointerRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct AccessToUnionFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct AccessToUnionFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_mutation_of_layout_constrained_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct MutationOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct MutationOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_borrow_of_layout_constrained_field_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct BorrowOfLayoutConstrainedFieldRequiresUnsafe {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(\n+    mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed,\n+    code = \"E0133\"\n+)]\n+#[note]\n+pub struct BorrowOfLayoutConstrainedFieldRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_fn_with_requires_unsafe, code = \"E0133\")]\n+#[note]\n+pub struct CallToFunctionWithRequiresUnsafe<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed, code = \"E0133\")]\n+#[note]\n+pub struct CallToFunctionWithRequiresUnsafeUnsafeOpInUnsafeFnAllowed<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub function: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unused_unsafe)]\n+pub struct UnusedUnsafe {\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub enclosing: Option<UnusedUnsafeEnclosing>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UnusedUnsafeEnclosing {\n+    #[label(mir_build_unused_unsafe_enclosing_block_label)]\n+    Block {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(mir_build_unused_unsafe_enclosing_fn_label)]\n+    Function {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+pub(crate) struct NonExhaustivePatternsTypeNotEmpty<'p, 'tcx, 'm> {\n+    pub cx: &'m MatchCheckCtxt<'p, 'tcx>,\n+    pub expr_span: Span,\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'a> IntoDiagnostic<'a> for NonExhaustivePatternsTypeNotEmpty<'_, '_, '_> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::mir_build_non_exhaustive_patterns_type_not_empty,\n+            error_code!(E0004),\n+        );\n+\n+        let peeled_ty = self.ty.peel_refs();\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.set_arg(\"peeled_ty\", peeled_ty);\n+\n+        if let ty::Adt(def, _) = peeled_ty.kind() {\n+            let def_span = self\n+                .cx\n+                .tcx\n+                .hir()\n+                .get_if_local(def.did())\n+                .and_then(|node| node.ident())\n+                .map(|ident| ident.span)\n+                .unwrap_or_else(|| self.cx.tcx.def_span(def.did()));\n+\n+            // workaround to make test pass\n+            let mut span: MultiSpan = def_span.into();\n+            span.push_span_label(def_span, \"\");\n+\n+            diag.span_note(span, rustc_errors::fluent::def_note);\n+        }\n+\n+        let is_variant_list_non_exhaustive = match self.ty.kind() {\n+            ty::Adt(def, _) if def.is_variant_list_non_exhaustive() && !def.did().is_local() => {\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        if is_variant_list_non_exhaustive {\n+            diag.note(rustc_errors::fluent::non_exhaustive_type_note);\n+        } else {\n+            diag.note(rustc_errors::fluent::type_note);\n+        }\n+\n+        if let ty::Ref(_, sub_ty, _) = self.ty.kind() {\n+            if !sub_ty.is_inhabited_from(self.cx.tcx, self.cx.module, self.cx.param_env) {\n+                diag.note(rustc_errors::fluent::reference_note);\n+            }\n+        }\n+\n+        let mut suggestion = None;\n+        let sm = self.cx.tcx.sess.source_map();\n+        if self.span.eq_ctxt(self.expr_span) {\n+            // Get the span for the empty match body `{}`.\n+            let (indentation, more) = if let Some(snippet) = sm.indentation_before(self.span) {\n+                (format!(\"\\n{}\", snippet), \"    \")\n+            } else {\n+                (\" \".to_string(), \"\")\n+            };\n+            suggestion = Some((\n+                self.span.shrink_to_hi().with_hi(self.expr_span.hi()),\n+                format!(\n+                    \" {{{indentation}{more}_ => todo!(),{indentation}}}\",\n+                    indentation = indentation,\n+                    more = more,\n+                ),\n+            ));\n+        }\n+\n+        if let Some((span, sugg)) = suggestion {\n+            diag.span_suggestion_verbose(\n+                span,\n+                rustc_errors::fluent::suggestion,\n+                sugg,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            diag.help(rustc_errors::fluent::help);\n+        }\n+\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_static_in_pattern, code = \"E0158\")]\n+pub struct StaticInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_assoc_const_in_pattern, code = \"E0158\")]\n+pub struct AssocConstInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_const_param_in_pattern, code = \"E0158\")]\n+pub struct ConstParamInPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_non_const_path, code = \"E0080\")]\n+pub struct NonConstPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_unreachable_pattern)]\n+pub struct UnreachablePattern {\n+    #[label]\n+    pub span: Option<Span>,\n+    #[label(catchall_label)]\n+    pub catchall: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_const_pattern_depends_on_generic_parameter)]\n+pub struct ConstPatternDependsOnGenericParameter {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_could_not_eval_const_pattern)]\n+pub struct CouldNotEvalConstPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper, code = \"E0030\")]\n+pub struct LowerRangeBoundMustBeLessThanOrEqualToUpper {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(teach_note)]\n+    pub teach: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_lower_range_bound_must_be_less_than_upper, code = \"E0579\")]\n+pub struct LowerRangeBoundMustBeLessThanUpper {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_leading_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct LeadingIrrefutableLetPatterns {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_trailing_irrefutable_let_patterns)]\n+#[note]\n+#[help]\n+pub struct TrailingIrrefutableLetPatterns {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_bindings_with_variant_name, code = \"E0170\")]\n+pub struct BindingsWithVariantName {\n+    #[suggestion(code = \"{ty_path}::{ident}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Option<Span>,\n+    pub ty_path: String,\n+    pub ident: Ident,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_generic_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsGenericLet {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_if_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsIfLet {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_if_let_guard)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsIfLetGuard {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_let_else)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsLetElse {\n+    pub count: usize,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_irrefutable_let_patterns_while_let)]\n+#[note]\n+#[help]\n+pub struct IrrefutableLetPatternsWhileLet {\n+    pub count: usize,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_borrow_of_moved_value)]\n+pub struct BorrowOfMovedValue<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    #[label(occurs_because_label)]\n+    pub binding_span: Span,\n+    #[label(value_borrowed_label)]\n+    pub conflicts_ref: Vec<Span>,\n+    pub name: Ident,\n+    pub ty: Ty<'tcx>,\n+    #[suggestion(code = \"ref \", applicability = \"machine-applicable\")]\n+    pub suggest_borrowing: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_multiple_mut_borrows)]\n+pub struct MultipleMutBorrows {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub binding_span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<MultipleMutBorrowOccurence>,\n+    pub name: Ident,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum MultipleMutBorrowOccurence {\n+    #[label(mutable_borrow)]\n+    Mutable {\n+        #[primary_span]\n+        span: Span,\n+        name_mut: Ident,\n+    },\n+    #[label(immutable_borrow)]\n+    Immutable {\n+        #[primary_span]\n+        span: Span,\n+        name_immut: Ident,\n+    },\n+    #[label(moved)]\n+    Moved {\n+        #[primary_span]\n+        span: Span,\n+        name_moved: Ident,\n+    },\n+}"}, {"sha": "2b05e92fdcf20c0913e199bf11fdeeb591b73d8d", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -19,6 +19,7 @@ extern crate rustc_middle;\n \n mod build;\n mod check_unsafety;\n+mod errors;\n mod lints;\n pub mod thir;\n "}, {"sha": "8529c64cd5cca64213f3b1efedb38df29c0094b5", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::UnconditionalRecursion;\n use rustc_data_structures::graph::iterate::{\n     NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n@@ -36,19 +37,11 @@ pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n \n         let sp = tcx.def_span(def_id);\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             UNCONDITIONAL_RECURSION,\n             hir_id,\n             sp,\n-            \"function cannot return without recursing\",\n-            |lint| {\n-                lint.span_label(sp, \"cannot return without recursing\");\n-                // offer some help to the programmer.\n-                for call_span in vis.reachable_recursive_calls {\n-                    lint.span_label(call_span, \"recursive call site\");\n-                }\n-                lint.help(\"a `loop` may express intention better if this is on purpose\")\n-            },\n+            UnconditionalRecursion { span: sp, call_sites: vis.reachable_recursive_calls },\n         );\n     }\n }"}, {"sha": "a355e1bdab5f51c78d865660833d0faafe83e33a", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -18,10 +18,10 @@ use rustc_middle::thir::*;\n use rustc_middle::ty::{self, RvalueScopes, TyCtxt};\n use rustc_span::Span;\n \n-pub(crate) fn thir_body<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) fn thir_body(\n+    tcx: TyCtxt<'_>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<(&'tcx Steal<Thir<'tcx>>, ExprId), ErrorGuaranteed> {\n+) -> Result<(&Steal<Thir<'_>>, ExprId), ErrorGuaranteed> {\n     let hir = tcx.hir();\n     let body = hir.body(hir.body_owned_by(owner_def.did));\n     let mut cx = Cx::new(tcx, owner_def);\n@@ -52,10 +52,7 @@ pub(crate) fn thir_body<'tcx>(\n     Ok((tcx.alloc_steal_thir(cx.thir), expr))\n }\n \n-pub(crate) fn thir_tree<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    owner_def: ty::WithOptConstParam<LocalDefId>,\n-) -> String {\n+pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n     match thir_body(tcx, owner_def) {\n         Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n         Err(_) => \"error\".into(),"}, {"sha": "a94d8d6c6431c81c0d95e2f525d9cff0d8c12d08", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 72, "deletions": 158, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -4,18 +4,22 @@ use super::usefulness::{\n };\n use super::{PatCtxt, PatternError};\n \n+use crate::errors::*;\n+\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DelayDm, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, MultiSpan,\n+    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+\n use rustc_session::lint::builtin::{\n     BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n };\n@@ -107,28 +111,20 @@ impl PatCtxt<'_, '_> {\n         for error in &self.errors {\n             match *error {\n                 PatternError::StaticInPattern(span) => {\n-                    self.span_e0158(span, \"statics cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(StaticInPattern { span });\n                 }\n                 PatternError::AssocConstInPattern(span) => {\n-                    self.span_e0158(span, \"associated consts cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(AssocConstInPattern { span });\n                 }\n                 PatternError::ConstParamInPattern(span) => {\n-                    self.span_e0158(span, \"const parameters cannot be referenced in patterns\")\n+                    self.tcx.sess.emit_err(ConstParamInPattern { span });\n                 }\n                 PatternError::NonConstPath(span) => {\n-                    rustc_middle::mir::interpret::struct_error(\n-                        self.tcx.at(span),\n-                        \"runtime values cannot be referenced in patterns\",\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(NonConstPath { span });\n                 }\n             }\n         }\n     }\n-\n-    fn span_e0158(&self, span: Span, text: &str) {\n-        struct_span_err!(self.tcx.sess, span, E0158, \"{}\", text).emit();\n-    }\n }\n \n impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n@@ -345,29 +341,6 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             );\n             return true;\n         }\n-        let lint_affix = |affix: &[Option<(Span, bool)>], kind, suggestion| {\n-            let span_start = affix[0].unwrap().0;\n-            let span_end = affix.last().unwrap().unwrap().0;\n-            let span = span_start.to(span_end);\n-            let cnt = affix.len();\n-            let s = pluralize!(cnt);\n-            cx.tcx.struct_span_lint_hir(\n-                IRREFUTABLE_LET_PATTERNS,\n-                top,\n-                span,\n-                format!(\"{kind} irrefutable pattern{s} in let chain\"),\n-                |lint| {\n-                    lint.note(format!(\n-                        \"{these} pattern{s} will always match\",\n-                        these = pluralize!(\"this\", cnt),\n-                    ))\n-                    .help(format!(\n-                        \"consider moving {} {suggestion}\",\n-                        if cnt > 1 { \"them\" } else { \"it\" }\n-                    ))\n-                },\n-            );\n-        };\n         if let Some(until) = chain_refutabilities.iter().position(|r| !matches!(*r, Some((_, false)))) && until > 0 {\n             // The chain has a non-zero prefix of irrefutable `let` statements.\n \n@@ -381,13 +354,21 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             if !matches!(let_source, LetSource::WhileLet | LetSource::IfLetGuard) {\n                 // Emit the lint\n                 let prefix = &chain_refutabilities[..until];\n-                lint_affix(prefix, \"leading\", \"outside of the construct\");\n+                let span_start = prefix[0].unwrap().0;\n+                let span_end = prefix.last().unwrap().unwrap().0;\n+                let span = span_start.to(span_end);\n+                let count = prefix.len();\n+                cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, LeadingIrrefutableLetPatterns { count });\n             }\n         }\n         if let Some(from) = chain_refutabilities.iter().rposition(|r| !matches!(*r, Some((_, false)))) && from != (chain_refutabilities.len() - 1) {\n             // The chain has a non-empty suffix of irrefutable `let` statements\n             let suffix = &chain_refutabilities[from + 1..];\n-            lint_affix(suffix, \"trailing\", \"into the body\");\n+            let span_start = suffix[0].unwrap().0;\n+            let span_end = suffix.last().unwrap().unwrap().0;\n+            let span = span_start.to(span_end);\n+            let count = suffix.len();\n+            cx.tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, top, span, TrailingIrrefutableLetPatterns { count });\n         }\n         true\n     }\n@@ -568,32 +549,22 @@ fn check_for_bindings_named_same_as_variants(\n             })\n         {\n             let variant_count = edef.variants().len();\n-            cx.tcx.struct_span_lint_hir(\n+            let ty_path = with_no_trimmed_paths!({\n+                cx.tcx.def_path_str(edef.did())\n+            });\n+            cx.tcx.emit_spanned_lint(\n                 BINDINGS_WITH_VARIANT_NAME,\n                 p.hir_id,\n                 p.span,\n-                DelayDm(|| format!(\n-                    \"pattern binding `{}` is named the same as one \\\n-                        of the variants of the type `{}`\",\n-                    ident, cx.tcx.def_path_str(edef.did())\n-                )),\n-                |lint| {\n-                    let ty_path = cx.tcx.def_path_str(edef.did());\n-                    lint.code(error_code!(E0170));\n-\n+                BindingsWithVariantName {\n                     // If this is an irrefutable pattern, and there's > 1 variant,\n                     // then we can't actually match on this. Applying the below\n                     // suggestion would produce code that breaks on `check_irrefutable`.\n-                    if rf == Refutable || variant_count == 1 {\n-                        lint.span_suggestion(\n-                            p.span,\n-                            \"to match on the variant, qualify the path\",\n-                            format!(\"{}::{}\", ty_path, ident),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-\n-                    lint\n+                    suggestion: if rf == Refutable || variant_count == 1 {\n+                        Some(p.span)\n+                    } else { None },\n+                    ty_path,\n+                    ident,\n                 },\n             )\n         }\n@@ -611,14 +582,12 @@ fn pat_is_catchall(pat: &DeconstructedPat<'_, '_>) -> bool {\n }\n \n fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n-    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\", |lint| {\n-        if let Some(catchall) = catchall {\n-            // We had a catchall pattern, hint at that.\n-            lint.span_label(span, \"unreachable pattern\");\n-            lint.span_label(catchall, \"matches any value\");\n-        }\n-        lint\n-    });\n+    tcx.emit_spanned_lint(\n+        UNREACHABLE_PATTERNS,\n+        id,\n+        span,\n+        UnreachablePattern { span: if catchall.is_some() { Some(span) } else { None }, catchall },\n+    );\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, id: HirId, span: Span) {\n@@ -634,67 +603,18 @@ fn irrefutable_let_patterns(\n     span: Span,\n ) {\n     macro_rules! emit_diag {\n-        (\n-            $lint:expr,\n-            $source_name:expr,\n-            $note_sufix:expr,\n-            $help_sufix:expr\n-        ) => {{\n-            let s = pluralize!(count);\n-            let these = pluralize!(\"this\", count);\n-            tcx.struct_span_lint_hir(\n-                IRREFUTABLE_LET_PATTERNS,\n-                id,\n-                span,\n-                format!(\"irrefutable {} pattern{s}\", $source_name),\n-                |lint| {\n-                    lint.note(&format!(\n-                        \"{these} pattern{s} will always match, so the {}\",\n-                        $note_sufix\n-                    ))\n-                    .help(concat!(\"consider \", $help_sufix))\n-                },\n-            )\n+        ($lint:tt) => {{\n+            tcx.emit_spanned_lint(IRREFUTABLE_LET_PATTERNS, id, span, $lint { count });\n         }};\n     }\n \n     match source {\n-        LetSource::GenericLet => {\n-            emit_diag!(lint, \"`let`\", \"`let` is useless\", \"removing `let`\");\n-        }\n-        LetSource::IfLet => {\n-            emit_diag!(\n-                lint,\n-                \"`if let`\",\n-                \"`if let` is useless\",\n-                \"replacing the `if let` with a `let`\"\n-            );\n-        }\n-        LetSource::IfLetGuard => {\n-            emit_diag!(\n-                lint,\n-                \"`if let` guard\",\n-                \"guard is useless\",\n-                \"removing the guard and adding a `let` inside the match arm\"\n-            );\n-        }\n-        LetSource::LetElse => {\n-            emit_diag!(\n-                lint,\n-                \"`let...else`\",\n-                \"`else` clause is useless\",\n-                \"removing the `else` clause\"\n-            );\n-        }\n-        LetSource::WhileLet => {\n-            emit_diag!(\n-                lint,\n-                \"`while let`\",\n-                \"loop will never exit\",\n-                \"instead using a `loop { ... }` with a `let` inside it\"\n-            );\n-        }\n-    };\n+        LetSource::GenericLet => emit_diag!(IrrefutableLetPatternsGenericLet),\n+        LetSource::IfLet => emit_diag!(IrrefutableLetPatternsIfLet),\n+        LetSource::IfLetGuard => emit_diag!(IrrefutableLetPatternsIfLetGuard),\n+        LetSource::LetElse => emit_diag!(IrrefutableLetPatternsLetElse),\n+        LetSource::WhileLet => emit_diag!(IrrefutableLetPatternsWhileLet),\n+    }\n }\n \n fn is_let_irrefutable<'p, 'tcx>(\n@@ -760,15 +680,17 @@ fn non_exhaustive_match<'p, 'tcx>(\n     // informative.\n     let mut err;\n     let pattern;\n-    let mut patterns_len = 0;\n+    let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        err = create_e0004(\n-            cx.tcx.sess,\n-            sp,\n-            format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n-        );\n-        pattern = \"_\".to_string();\n+        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+            cx,\n+            expr_span,\n+            span: sp,\n+            ty: scrut_ty,\n+        });\n+        return;\n     } else {\n+        // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n         err = create_e0004(\n             cx.tcx.sess,\n@@ -1039,24 +961,17 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                 }\n             });\n             if !conflicts_ref.is_empty() {\n-                let occurs_because = format!(\n-                    \"move occurs because `{}` has type `{}` which does not implement the `Copy` trait\",\n+                sess.emit_err(BorrowOfMovedValue {\n+                    span: pat.span,\n+                    binding_span,\n+                    conflicts_ref,\n                     name,\n-                    typeck_results.node_type(pat.hir_id),\n-                );\n-                let mut err = sess.struct_span_err(pat.span, \"borrow of moved value\");\n-                err.span_label(binding_span, format!(\"value moved into `{}` here\", name))\n-                    .span_label(binding_span, occurs_because)\n-                    .span_labels(conflicts_ref, \"value borrowed here after move\");\n-                if pat.span.contains(binding_span) {\n-                    err.span_suggestion_verbose(\n-                        binding_span.shrink_to_lo(),\n-                        \"borrow this binding in the pattern to avoid moving the value\",\n-                        \"ref \".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                err.emit();\n+                    ty: typeck_results.node_type(pat.hir_id),\n+                    suggest_borrowing: pat\n+                        .span\n+                        .contains(binding_span)\n+                        .then(|| binding_span.shrink_to_lo()),\n+                });\n             }\n             return;\n         }\n@@ -1086,19 +1001,18 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     // Report errors if any.\n     if !conflicts_mut_mut.is_empty() {\n         // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-        let mut err = sess\n-            .struct_span_err(pat.span, \"cannot borrow value as mutable more than once at a time\");\n-        err.span_label(binding_span, format!(\"first mutable borrow, by `{}`, occurs here\", name));\n-        for (span, name) in conflicts_mut_mut {\n-            err.span_label(span, format!(\"another mutable borrow, by `{}`, occurs here\", name));\n+        let mut occurences = vec![];\n+\n+        for (span, name_mut) in conflicts_mut_mut {\n+            occurences.push(MultipleMutBorrowOccurence::Mutable { span, name_mut });\n         }\n-        for (span, name) in conflicts_mut_ref {\n-            err.span_label(span, format!(\"also borrowed as immutable, by `{}`, here\", name));\n+        for (span, name_immut) in conflicts_mut_ref {\n+            occurences.push(MultipleMutBorrowOccurence::Immutable { span, name_immut });\n         }\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"also moved into `{}` here\", name));\n+        for (span, name_moved) in conflicts_move {\n+            occurences.push(MultipleMutBorrowOccurence::Moved { span, name_moved });\n         }\n-        err.emit();\n+        sess.emit_err(MultipleMutBorrows { span: pat.span, binding_span, occurences, name });\n     } else if !conflicts_mut_ref.is_empty() {\n         // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n         let (primary, also) = match mut_outer {"}, {"sha": "6470efab2e93c676318e22dad0ce87954c5754b0", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -70,7 +70,7 @@ mod fallback_to_const_ref {\n     /// hoops to get a reference to the value.\n     pub(super) struct FallbackToConstRef(());\n \n-    pub(super) fn fallback_to_const_ref<'tcx>(c2p: &super::ConstToPat<'tcx>) -> FallbackToConstRef {\n+    pub(super) fn fallback_to_const_ref(c2p: &super::ConstToPat<'_>) -> FallbackToConstRef {\n         assert!(c2p.behind_reference.get());\n         FallbackToConstRef(())\n     }"}, {"sha": "a95349d767098bc58baca1211ce8b744e3f7bd7a", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -404,7 +404,7 @@ impl SplitIntRange {\n     }\n \n     /// Iterate over the contained ranges.\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = IntRange> + Captures<'a> {\n+    fn iter(&self) -> impl Iterator<Item = IntRange> + Captures<'_> {\n         use IntBorder::*;\n \n         let self_range = Self::to_borders(self.range.clone());\n@@ -612,7 +612,7 @@ impl SplitVarLenSlice {\n     }\n \n     /// Iterate over the partition of this slice.\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = Slice> + Captures<'a> {\n+    fn iter(&self) -> impl Iterator<Item = Slice> + Captures<'_> {\n         let smaller_lengths = match self.array_len {\n             // The only admissible fixed-length slice is one of the array size. Whether `max_slice`\n             // is fixed-length or variable-length, it will be the only relevant slice to output"}, {"sha": "2c775b397182b352eea62549c4b7179129e20178", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -6,10 +6,12 @@ mod deconstruct_pat;\n mod usefulness;\n \n pub(crate) use self::check_match::check_match;\n+pub(crate) use self::usefulness::MatchCheckCtxt;\n \n+use crate::errors::*;\n use crate::thir::util::UserAnnotatedTyHelpers;\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::error_code;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n@@ -139,13 +141,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..y` where `x >= y`. The range is empty => error.\n             (RangeEnd::Excluded, _) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0579,\n-                    \"lower range bound must be less than upper\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanUpper { span });\n                 PatKind::Wild\n             }\n             // `x..=y` where `x == y`.\n@@ -156,23 +152,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..=y` where `x > y` hence the range is empty => error.\n             (RangeEnd::Included, _) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanOrEqualToUpper {\n                     span,\n-                    E0030,\n-                    \"lower range bound must be less than or equal to upper\"\n-                );\n-                err.span_label(span, \"lower bound larger than upper bound\");\n-                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                    err.note(\n-                        \"When matching against a range, the compiler \\\n-                              verifies that the range is non-empty. Range \\\n-                              patterns include both end-points, so this is \\\n-                              equivalent to requiring the start of the range \\\n-                              to be less than or equal to the end of the range.\",\n-                    );\n-                }\n-                err.emit();\n+                    teach: if self.tcx.sess.teach(&error_code!(E0030)) { Some(()) } else { None },\n+                });\n                 PatKind::Wild\n             }\n         }\n@@ -501,7 +484,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             Err(_) => {\n-                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                self.tcx.sess.emit_err(CouldNotEvalConstPattern { span });\n                 return pat_from_kind(PatKind::Wild);\n             }\n         };\n@@ -548,11 +531,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             Err(ErrorHandled::TooGeneric) => {\n                 // While `Reported | Linted` cases will have diagnostics emitted already\n                 // it is not true for TooGeneric case, so we need to give user more information.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n                 pat_from_kind(PatKind::Wild)\n             }\n             Err(_) => {\n-                self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n+                self.tcx.sess.emit_err(CouldNotEvalConstPattern { span });\n                 pat_from_kind(PatKind::Wild)\n             }\n         }\n@@ -584,7 +567,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             mir::ConstantKind::Val(_, _) => self.const_to_pat(value, id, span, false).kind,\n             mir::ConstantKind::Unevaluated(..) => {\n                 // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                self.tcx.sess.emit_err(ConstPatternDependsOnGenericParameter { span });\n                 return PatKind::Wild;\n             }\n         }"}, {"sha": "923dc16c11b077268e175de33677bb58400649c3", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -149,15 +149,15 @@ enum DefUse {\n }\n \n impl DefUse {\n-    fn apply<'tcx>(trans: &mut impl GenKill<Local>, place: Place<'tcx>, context: PlaceContext) {\n+    fn apply(trans: &mut impl GenKill<Local>, place: Place<'_>, context: PlaceContext) {\n         match DefUse::for_place(place, context) {\n             Some(DefUse::Def) => trans.kill(place.local),\n             Some(DefUse::Use) => trans.gen(place.local),\n             None => {}\n         }\n     }\n \n-    fn for_place<'tcx>(place: Place<'tcx>, context: PlaceContext) -> Option<DefUse> {\n+    fn for_place(place: Place<'_>, context: PlaceContext) -> Option<DefUse> {\n         match context {\n             PlaceContext::NonUse(_) => None,\n "}, {"sha": "9b053985bedf6823f13a47fe5f5a6d5770cc38b8", "filename": "compiler/rustc_mir_dataflow/src/move_paths/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -14,9 +14,8 @@ use self::abs_domain::{AbstractElem, Lift};\n mod abs_domain;\n \n rustc_index::newtype_index! {\n-    pub struct MovePathIndex {\n-        DEBUG_FORMAT = \"mp{}\"\n-    }\n+    #[debug_format = \"mp{}\"]\n+    pub struct MovePathIndex {}\n }\n \n impl polonius_engine::Atom for MovePathIndex {\n@@ -26,15 +25,13 @@ impl polonius_engine::Atom for MovePathIndex {\n }\n \n rustc_index::newtype_index! {\n-    pub struct MoveOutIndex {\n-        DEBUG_FORMAT = \"mo{}\"\n-    }\n+    #[debug_format = \"mo{}\"]\n+    pub struct MoveOutIndex {}\n }\n \n rustc_index::newtype_index! {\n-    pub struct InitIndex {\n-        DEBUG_FORMAT = \"in{}\"\n-    }\n+    #[debug_format = \"in{}\"]\n+    pub struct InitIndex {}\n }\n \n impl MoveOutIndex {"}, {"sha": "fe5ee4011ab8483bb3987779220c77ce7af56577", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -823,7 +823,7 @@ fn iter_fields<'tcx>(\n }\n \n /// Returns all locals with projections that have their reference or address taken.\n-fn excluded_locals<'tcx>(body: &Body<'tcx>) -> IndexVec<Local, bool> {\n+fn excluded_locals(body: &Body<'_>) -> IndexVec<Local, bool> {\n     struct Collector {\n         result: IndexVec<Local, bool>,\n     }"}, {"sha": "adf6ae4c7270fbe37b642bb26e738d7cb1063354", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -490,10 +490,10 @@ fn check_unused_unsafe(\n     unused_unsafes\n }\n \n-fn unsafety_check_result<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn unsafety_check_result(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx UnsafetyCheckResult {\n+) -> &UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def);\n \n     // N.B., this borrow is valid because all the consumers of"}, {"sha": "d435d3ee69b76a94eda4fe73a4ff40d60eb8aa0d", "filename": "compiler/rustc_mir_transform/src/cleanup_post_borrowck.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,59 +1,48 @@\n-//! This module provides a pass to replacing the following statements with\n-//! [`Nop`]s\n+//! This module provides a pass that removes parts of MIR that are no longer relevant after\n+//! analysis phase and borrowck. In particular, it removes false edges, user type annotations and\n+//! replaces following statements with [`Nop`]s:\n //!\n //!   - [`AscribeUserType`]\n //!   - [`FakeRead`]\n //!   - [`Assign`] statements with a [`Shallow`] borrow\n //!\n-//! The `CleanFakeReadsAndBorrows` \"pass\" is actually implemented as two\n-//! traversals (aka visits) of the input MIR. The first traversal,\n-//! `DeleteAndRecordFakeReads`, deletes the fake reads and finds the\n-//! temporaries read by [`ForMatchGuard`] reads, and `DeleteFakeBorrows`\n-//! deletes the initialization of those temporaries.\n-//!\n //! [`AscribeUserType`]: rustc_middle::mir::StatementKind::AscribeUserType\n-//! [`Shallow`]: rustc_middle::mir::BorrowKind::Shallow\n-//! [`FakeRead`]: rustc_middle::mir::StatementKind::FakeRead\n //! [`Assign`]: rustc_middle::mir::StatementKind::Assign\n-//! [`ForMatchGuard`]: rustc_middle::mir::FakeReadCause::ForMatchGuard\n+//! [`FakeRead`]: rustc_middle::mir::StatementKind::FakeRead\n //! [`Nop`]: rustc_middle::mir::StatementKind::Nop\n+//! [`Shallow`]: rustc_middle::mir::BorrowKind::Shallow\n \n use crate::MirPass;\n-use rustc_middle::mir::visit::MutVisitor;\n-use rustc_middle::mir::{Body, BorrowKind, Location, Rvalue};\n-use rustc_middle::mir::{Statement, StatementKind};\n+use rustc_middle::mir::{Body, BorrowKind, Rvalue, StatementKind, TerminatorKind};\n use rustc_middle::ty::TyCtxt;\n \n-pub struct CleanupNonCodegenStatements;\n+pub struct CleanupPostBorrowck;\n \n-pub struct DeleteNonCodegenStatements<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n+impl<'tcx> MirPass<'tcx> for CleanupPostBorrowck {\n+    fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        for basic_block in body.basic_blocks.as_mut() {\n+            for statement in basic_block.statements.iter_mut() {\n+                match statement.kind {\n+                    StatementKind::AscribeUserType(..)\n+                    | StatementKind::Assign(box (_, Rvalue::Ref(_, BorrowKind::Shallow, _)))\n+                    | StatementKind::FakeRead(..) => statement.make_nop(),\n+                    _ => (),\n+                }\n+            }\n+            let terminator = basic_block.terminator_mut();\n+            match terminator.kind {\n+                TerminatorKind::FalseEdge { real_target, .. }\n+                | TerminatorKind::FalseUnwind { real_target, .. } => {\n+                    terminator.kind = TerminatorKind::Goto { target: real_target };\n+                }\n+                _ => {}\n+            }\n+        }\n \n-impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let mut delete = DeleteNonCodegenStatements { tcx };\n-        delete.visit_body_preserves_cfg(body);\n         body.user_type_annotations.raw.clear();\n \n         for decl in &mut body.local_decls {\n             decl.user_ty = None;\n         }\n     }\n }\n-\n-impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        match statement.kind {\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::Assign(box (_, Rvalue::Ref(_, BorrowKind::Shallow, _)))\n-            | StatementKind::FakeRead(..) => statement.make_nop(),\n-            _ => (),\n-        }\n-        self.super_statement(statement, location);\n-    }\n-}"}, {"sha": "e384cfe165990c47940bde2566b8da034d49fe33", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -701,8 +701,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n                         if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n                             let val = Immediate::ScalarPair(\n-                                const_arg.to_scalar().into(),\n-                                Scalar::from_bool(false).into(),\n+                                const_arg.to_scalar(),\n+                                Scalar::from_bool(false),\n                             );\n                             this.ecx.write_immediate(val, &dest)\n                         } else {"}, {"sha": "78d28f1ebab7ce345d5082169bb0b80e4c34045b", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -282,9 +282,9 @@ impl graph::WithPredecessors for CoverageGraph {\n \n rustc_index::newtype_index! {\n     /// A node in the control-flow graph of CoverageGraph.\n+    #[debug_format = \"bcb{}\"]\n     pub(super) struct BasicCoverageBlock {\n-        DEBUG_FORMAT = \"bcb{}\",\n-        const START_BCB = 0,\n+        const START_BCB = 0;\n     }\n }\n "}, {"sha": "1468afc64563dc20bba1ea5e4e2f062918042d99", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -533,10 +533,10 @@ fn make_code_region(\n     }\n }\n \n-fn fn_sig_and_body<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn fn_sig_and_body(\n+    tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> (Option<&'tcx rustc_hir::FnSig<'tcx>>, &'tcx rustc_hir::Body<'tcx>) {\n+) -> (Option<&rustc_hir::FnSig<'_>>, &rustc_hir::Body<'_>) {\n     // FIXME(#79625): Consider improving MIR to provide the information needed, to avoid going back\n     // to HIR for it.\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");"}, {"sha": "3bd7f31b45dcaa673f9e4873615bc10c8b7d4607", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -136,7 +136,7 @@ fn coverageinfo<'tcx>(tcx: TyCtxt<'tcx>, instance_def: ty::InstanceDef<'tcx>) ->\n     coverage_visitor.info\n }\n \n-fn covered_code_regions<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Vec<&'tcx CodeRegion> {\n+fn covered_code_regions(tcx: TyCtxt<'_>, def_id: DefId) -> Vec<&CodeRegion> {\n     let body = mir_body(tcx, def_id);\n     body.basic_blocks\n         .iter()\n@@ -163,7 +163,7 @@ fn is_inlined(body: &Body<'_>, statement: &Statement<'_>) -> bool {\n /// This function ensures we obtain the correct MIR for the given item irrespective of\n /// whether that means const mir or runtime mir. For `const fn` this opts for runtime\n /// mir.\n-fn mir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx mir::Body<'tcx> {\n+fn mir_body(tcx: TyCtxt<'_>, def_id: DefId) -> &mir::Body<'_> {\n     let id = ty::WithOptConstParam::unknown(def_id);\n     let def = ty::InstanceDef::Item(id);\n     tcx.instance_mir(def)"}, {"sha": "fa7f22303a8b50514bfcea5703d22b6b3c59b0c3", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     }\n }\n \n-fn debug_basic_blocks<'tcx>(mir_body: &Body<'tcx>) -> String {\n+fn debug_basic_blocks(mir_body: &Body<'_>) -> String {\n     format!(\n         \"{:?}\",\n         mir_body"}, {"sha": "ddab7bbb2e3016a29fb23d9259c66a4064d9eac2", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n }\n \n /// Returns true if values of a given type will never be passed indirectly, regardless of ABI.\n-fn type_will_always_be_passed_directly<'tcx>(ty: Ty<'tcx>) -> bool {\n+fn type_will_always_be_passed_directly(ty: Ty<'_>) -> bool {\n     matches!(\n         ty.kind(),\n         ty::Bool"}, {"sha": "08e296a837127b72911b152275b7c242ca47d0f9", "filename": "compiler/rustc_mir_transform/src/dest_prop.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdest_prop.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -129,6 +129,7 @@\n \n use std::collections::hash_map::{Entry, OccupiedEntry};\n \n+use crate::simplify::remove_dead_blocks;\n use crate::MirPass;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n@@ -235,6 +236,12 @@ impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n             apply_merges(body, tcx, &merges, &merged_locals);\n         }\n \n+        if round_count != 0 {\n+            // Merging can introduce overlap between moved arguments and/or call destination in an\n+            // unreachable code, which validator considers to be ill-formed.\n+            remove_dead_blocks(tcx, body);\n+        }\n+\n         trace!(round_count);\n     }\n }\n@@ -651,7 +658,7 @@ impl WriteInfo {\n         }\n     }\n \n-    fn add_place<'tcx>(&mut self, place: Place<'tcx>) {\n+    fn add_place(&mut self, place: Place<'_>) {\n         self.writes.push(place.local);\n     }\n "}, {"sha": "ae79c2290f6d30c0f923a2f75e6aaac9f6b95f17", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -77,8 +77,6 @@ mod match_branches;\n mod multiple_return_terminators;\n mod normalize_array_len;\n mod nrvo;\n-// This pass is public to allow external drivers to perform MIR cleanup\n-pub mod remove_false_edges;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n mod remove_uninit_drops;\n@@ -268,10 +266,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n /// Make MIR ready for const evaluation. This is run on all MIR, not just on consts!\n /// FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n /// We used to have this for pre-miri MIR based const eval.\n-fn mir_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_const(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Steal<Body<'_>> {\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_const(def);\n     }\n@@ -310,10 +305,10 @@ fn mir_const<'tcx>(\n }\n \n /// Compute the main MIR body and the list of MIR bodies of the promoteds.\n-fn mir_promoted<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn mir_promoted(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n+) -> (&Steal<Body<'_>>, &Steal<IndexVec<Promoted, Body<'_>>>) {\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_promoted(def);\n     }\n@@ -352,7 +347,7 @@ fn mir_promoted<'tcx>(\n }\n \n /// Compute the MIR that is used during CTFE (and thus has no optimizations run on it)\n-fn mir_for_ctfe<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+fn mir_for_ctfe(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n     let did = def_id.expect_local();\n     if let Some(def) = ty::WithOptConstParam::try_lookup(did, tcx) {\n         tcx.mir_for_ctfe_of_const_arg(def)\n@@ -366,10 +361,7 @@ fn mir_for_ctfe<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n /// we'd get cycle errors with `mir_for_ctfe`, because typeck would need to typeck\n /// the const parameter while type checking the main body, which in turn would try\n /// to type check the main body again.\n-fn mir_for_ctfe_of_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (did, param_did): (LocalDefId, DefId),\n-) -> &'tcx Body<'tcx> {\n+fn mir_for_ctfe_of_const_arg(tcx: TyCtxt<'_>, (did, param_did): (LocalDefId, DefId)) -> &Body<'_> {\n     tcx.arena.alloc(inner_mir_for_ctfe(\n         tcx,\n         ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n@@ -426,10 +418,10 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n /// Obtain just the main MIR (no promoteds) and run some cleanups on it. This also runs\n /// mir borrowck *before* doing so in order to ensure that borrowck can be run and doesn't\n /// end up missing the source MIR due to stealing happening.\n-fn mir_drops_elaborated_and_const_checked<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn mir_drops_elaborated_and_const_checked(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx Steal<Body<'tcx>> {\n+) -> &Steal<Body<'_>> {\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_drops_elaborated_and_const_checked(def);\n     }\n@@ -494,10 +486,9 @@ fn run_analysis_to_runtime_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>\n /// After this series of passes, no lifetime analysis based on borrowing can be done.\n fn run_analysis_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let passes: &[&dyn MirPass<'tcx>] = &[\n-        &remove_false_edges::RemoveFalseEdges,\n+        &cleanup_post_borrowck::CleanupPostBorrowck,\n         &simplify_branches::SimplifyConstCondition::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n-        &cleanup_post_borrowck::CleanupNonCodegenStatements,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n         &deref_separator::Derefer,\n     ];\n@@ -600,7 +591,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n }\n \n /// Optimize the MIR and prepare it for codegen.\n-fn optimized_mir<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx Body<'tcx> {\n+fn optimized_mir(tcx: TyCtxt<'_>, did: DefId) -> &Body<'_> {\n     let did = did.expect_local();\n     assert_eq!(ty::WithOptConstParam::try_lookup(did, tcx), None);\n     tcx.arena.alloc(inner_optimized_mir(tcx, did))\n@@ -637,10 +628,10 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n \n /// Fetch all the promoteds of an item and prepare their MIR bodies to be ready for\n /// constant evaluation once all substitutions become known.\n-fn promoted_mir<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn promoted_mir(\n+    tcx: TyCtxt<'_>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> &'tcx IndexVec<Promoted, Body<'tcx>> {\n+) -> &IndexVec<Promoted, Body<'_>> {\n     if tcx.is_constructor(def.did.to_def_id()) {\n         return tcx.arena.alloc(IndexVec::new());\n     }"}, {"sha": "71f5ccf7e2465330252f0f48a69ee033f109c86e", "filename": "compiler/rustc_mir_transform/src/remove_false_edges.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0c14ad4d9fe83e737d7b8db0c2520ef54c99926e/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c14ad4d9fe83e737d7b8db0c2520ef54c99926e/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs?ref=0c14ad4d9fe83e737d7b8db0c2520ef54c99926e", "patch": "@@ -1,29 +0,0 @@\n-use rustc_middle::mir::{Body, TerminatorKind};\n-use rustc_middle::ty::TyCtxt;\n-\n-use crate::MirPass;\n-\n-/// Removes `FalseEdge` and `FalseUnwind` terminators from the MIR.\n-///\n-/// These are only needed for borrow checking, and can be removed afterwards.\n-///\n-/// FIXME: This should probably have its own MIR phase.\n-pub struct RemoveFalseEdges;\n-\n-impl<'tcx> MirPass<'tcx> for RemoveFalseEdges {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        for block in body.basic_blocks_mut() {\n-            let terminator = block.terminator_mut();\n-            terminator.kind = match terminator.kind {\n-                TerminatorKind::FalseEdge { real_target, .. } => {\n-                    TerminatorKind::Goto { target: real_target }\n-                }\n-                TerminatorKind::FalseUnwind { real_target, .. } => {\n-                    TerminatorKind::Goto { target: real_target }\n-                }\n-\n-                _ => continue,\n-            }\n-        }\n-    }\n-}"}, {"sha": "dace540fa29d2596739379f140d446909c08cc5f", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -174,9 +174,36 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     let mut body =\n         new_body(source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n+    // The first argument (index 0), but add 1 for the return value.\n+    let mut dropee_ptr = Place::from(Local::new(1 + 0));\n+    if tcx.sess.opts.unstable_opts.mir_emit_retag {\n+        // We want to treat the function argument as if it was passed by `&mut`. As such, we\n+        // generate\n+        // ```\n+        // temp = &mut *arg;\n+        // Retag(temp, FnEntry)\n+        // ```\n+        // It's important that we do this first, before anything that depends on `dropee_ptr`\n+        // has been put into the body.\n+        let reborrow = Rvalue::Ref(\n+            tcx.lifetimes.re_erased,\n+            BorrowKind::Mut { allow_two_phase_borrow: false },\n+            tcx.mk_place_deref(dropee_ptr),\n+        );\n+        let ref_ty = reborrow.ty(body.local_decls(), tcx);\n+        dropee_ptr = body.local_decls.push(LocalDecl::new(ref_ty, span)).into();\n+        let new_statements = [\n+            StatementKind::Assign(Box::new((dropee_ptr, reborrow))),\n+            StatementKind::Retag(RetagKind::FnEntry, Box::new(dropee_ptr)),\n+        ];\n+        for s in new_statements {\n+            body.basic_blocks_mut()[START_BLOCK]\n+                .statements\n+                .push(Statement { source_info, kind: s });\n+        }\n+    }\n+\n     if ty.is_some() {\n-        // The first argument (index 0), but add 1 for the return value.\n-        let dropee_ptr = Place::from(Local::new(1 + 0));\n         let patch = {\n             let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator ="}, {"sha": "e4f3ace9a93dafced0e7a50fefd1e1d8a597433c", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -532,7 +532,7 @@ struct VarField<'tcx> {\n }\n \n /// Match on `((_LOCAL as Variant).FIELD: TY)`.\n-fn match_variant_field_place<'tcx>(place: Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n+fn match_variant_field_place(place: Place<'_>) -> Option<(Local, VarField<'_>)> {\n     match place.as_ref() {\n         PlaceRef {\n             local,"}, {"sha": "3a2bf051516554bc6f6acdf220f42a604a5de656", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -182,7 +182,7 @@ fn replace_flattened_locals<'tcx>(\n     let mut fragments = IndexVec::new();\n     for (k, v) in &replacements.fields {\n         fragments.ensure_contains_elem(k.local, || Vec::new());\n-        fragments[k.local].push((&k.projection[..], *v));\n+        fragments[k.local].push((k.projection, *v));\n     }\n     debug!(?fragments);\n "}, {"sha": "deeeb9af4eb9232b38a525b98cc0cdfc19924dde", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -595,8 +595,8 @@ fn check_recursion_limit<'tcx>(\n         let def_path_str = tcx.def_path_str(def_id);\n         let (shrunk, written_to_path) = shrunk_instance_name(tcx, &instance);\n         let mut path = PathBuf::new();\n-        let was_written = if written_to_path.is_some() {\n-            path = written_to_path.unwrap();\n+        let was_written = if let Some(written_to_path) = written_to_path {\n+            path = written_to_path;\n             Some(())\n         } else {\n             None"}, {"sha": "a55a3fe5ccaaa1663bcbeebc7465010be70d9130", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -345,10 +345,7 @@ where\n     }\n }\n \n-fn collect_and_partition_mono_items<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (): (),\n-) -> (&'tcx DefIdSet, &'tcx [CodegenUnit<'tcx>]) {\n+fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[CodegenUnit<'_>]) {\n     let collection_mode = match tcx.sess.opts.unstable_opts.print_mono_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n@@ -541,7 +538,7 @@ fn dump_mono_items_stats<'tcx>(\n     Ok(())\n }\n \n-fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSet {\n+fn codegened_and_inlined_items(tcx: TyCtxt<'_>, (): ()) -> &DefIdSet {\n     let (items, cgus) = tcx.collect_and_partition_mono_items(());\n     let mut visited = DefIdSet::default();\n     let mut result = items.clone();"}, {"sha": "40b88788caa6743c66a5e7f9c0e6dba47fd6cb9a", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -25,7 +25,7 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, DelimArgs, Extern};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, Const, DelimArgs, Extern};\n use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutability, StrLit};\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n@@ -1217,11 +1217,7 @@ impl<'a> Parser<'a> {\n             value: self.mk_expr(blk.span, ExprKind::Block(blk, None)),\n         };\n         let blk_span = anon_const.value.span;\n-        Ok(self.mk_expr_with_attrs(\n-            span.to(blk_span),\n-            ExprKind::ConstBlock(anon_const),\n-            AttrVec::from(attrs),\n-        ))\n+        Ok(self.mk_expr_with_attrs(span.to(blk_span), ExprKind::ConstBlock(anon_const), attrs))\n     }\n \n     /// Parses mutability (`mut` or nothing)."}, {"sha": "5333d3b8587ddaafa80c49336c50890d4f25af7a", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -277,8 +277,7 @@ impl<'a> Parser<'a> {\n                         if let Some(arg) = args\n                             .iter()\n                             .rev()\n-                            .skip_while(|arg| matches!(arg, AngleBracketedArg::Constraint(_)))\n-                            .next()\n+                            .find(|arg| !matches!(arg, AngleBracketedArg::Constraint(_)))\n                         {\n                             err.span_suggestion_verbose(\n                                 arg.span().shrink_to_hi(),"}, {"sha": "edb0e4367f27354114415fa2dccac4ba576a1af8", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -571,7 +571,7 @@ fn check_item<'tcx>(\n     }\n }\n \n-fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id: hir::TraitItemId) {\n+fn check_trait_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::TraitItemId) {\n     use hir::TraitItemKind::{Const, Fn};\n     if matches!(tcx.def_kind(id.owner_id), DefKind::AssocConst | DefKind::AssocFn) {\n         let trait_item = tcx.hir().trait_item(id);\n@@ -583,20 +583,16 @@ fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id:\n     }\n }\n \n-fn check_foreign_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    worklist: &mut Vec<LocalDefId>,\n-    id: hir::ForeignItemId,\n-) {\n+fn check_foreign_item(tcx: TyCtxt<'_>, worklist: &mut Vec<LocalDefId>, id: hir::ForeignItemId) {\n     if matches!(tcx.def_kind(id.owner_id), DefKind::Static(_) | DefKind::Fn)\n         && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n     {\n         worklist.push(id.owner_id.def_id);\n     }\n }\n \n-fn create_and_seed_worklist<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn create_and_seed_worklist(\n+    tcx: TyCtxt<'_>,\n ) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n     let effective_visibilities = &tcx.effective_visibilities(());\n     // see `MarkSymbolVisitor::struct_constructors`\n@@ -626,8 +622,8 @@ fn create_and_seed_worklist<'tcx>(\n     (worklist, struct_constructors)\n }\n \n-fn live_symbols_and_ignored_derived_traits<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn live_symbols_and_ignored_derived_traits(\n+    tcx: TyCtxt<'_>,\n     (): (),\n ) -> (FxHashSet<LocalDefId>, FxHashMap<LocalDefId, Vec<(DefId, DefId)>>) {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx);\n@@ -787,7 +783,6 @@ impl<'tcx> DeadVisitor<'tcx> {\n         let mut dead_codes = dead_codes\n             .iter()\n             .filter(|v| !v.name.as_str().starts_with('_'))\n-            .map(|v| v)\n             .collect::<Vec<&DeadVariant>>();\n         if dead_codes.is_empty() {\n             return;"}, {"sha": "aeacbaa67cb5718976fa8b34d46ef03b7482b35d", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -15,8 +15,8 @@ use std::sync::Arc;\n \n use crate::errors::DebugVisualizerUnreadable;\n \n-fn check_for_debugger_visualizer<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn check_for_debugger_visualizer(\n+    tcx: TyCtxt<'_>,\n     hir_id: HirId,\n     debugger_visualizers: &mut FxHashSet<DebuggerVisualizerFile>,\n ) {\n@@ -69,7 +69,7 @@ fn check_for_debugger_visualizer<'tcx>(\n }\n \n /// Traverses and collects the debugger visualizers for a specific crate.\n-fn debugger_visualizers<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Vec<DebuggerVisualizerFile> {\n+fn debugger_visualizers(tcx: TyCtxt<'_>, cnum: CrateNum) -> Vec<DebuggerVisualizerFile> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector."}, {"sha": "10ffa87efe35f635228a6de8d161ead2172c934d", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -18,11 +18,7 @@ use rustc_span::symbol::{kw::Empty, sym, Symbol};\n \n use crate::errors::{DuplicateDiagnosticItem, DuplicateDiagnosticItemInCrate};\n \n-fn observe_item<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    diagnostic_items: &mut DiagnosticItems,\n-    def_id: LocalDefId,\n-) {\n+fn observe_item(tcx: TyCtxt<'_>, diagnostic_items: &mut DiagnosticItems, def_id: LocalDefId) {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let attrs = tcx.hir().attrs(hir_id);\n     if let Some(name) = extract(attrs) {\n@@ -63,7 +59,7 @@ fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n }\n \n /// Traverse and collect the diagnostic items in the current\n-fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems {\n+fn diagnostic_items(tcx: TyCtxt<'_>, cnum: CrateNum) -> DiagnosticItems {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector.\n@@ -92,7 +88,7 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems\n }\n \n /// Traverse and collect all the diagnostic items in all crates.\n-fn all_diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> DiagnosticItems {\n+fn all_diagnostic_items(tcx: TyCtxt<'_>, (): ()) -> DiagnosticItems {\n     // Initialize the collector.\n     let mut items = DiagnosticItems::default();\n "}, {"sha": "272386f313e8d0736aecdd274652c4374e1fca6e", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -121,7 +121,7 @@ impl<'k> StatCollector<'k> {\n \n     fn print(&self, title: &str, prefix: &str) {\n         let mut nodes: Vec<_> = self.nodes.iter().collect();\n-        nodes.sort_by_key(|&(_, ref node)| node.stats.count * node.stats.size);\n+        nodes.sort_by_key(|(_, node)| node.stats.count * node.stats.size);\n \n         let total_size = nodes.iter().map(|(_, node)| node.stats.count * node.stats.size).sum();\n \n@@ -147,7 +147,7 @@ impl<'k> StatCollector<'k> {\n             );\n             if !node.subnodes.is_empty() {\n                 let mut subnodes: Vec<_> = node.subnodes.iter().collect();\n-                subnodes.sort_by_key(|&(_, ref subnode)| subnode.count * subnode.size);\n+                subnodes.sort_by_key(|(_, subnode)| subnode.count * subnode.size);\n \n                 for (label, subnode) in subnodes {\n                     let size = subnode.count * subnode.size;"}, {"sha": "9a40b847d8552ebd9800fa42f6a6791b17562f73", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -83,7 +83,6 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                         .map(|p| p.display().to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")\n-                        .into()\n                 };\n                 let first_defined_span = self.tcx.hir().span_if_local(original_def_id);\n                 let mut orig_crate_name = Empty;\n@@ -98,7 +97,6 @@ impl<'tcx> LanguageItemCollector<'tcx> {\n                         .map(|p| p.display().to_string())\n                         .collect::<Vec<_>>()\n                         .join(\", \")\n-                        .into()\n                 };\n                 if first_defined_span.is_none() {\n                     orig_crate_name = self.tcx.crate_name(original_def_id.krate);"}, {"sha": "827d86780aa8c517b87b2d41f6b0e76ab49b2d06", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -26,7 +26,7 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n     }\n }\n \n-fn dump_layout_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: LocalDefId, attr: &Attribute) {\n+fn dump_layout_of(tcx: TyCtxt<'_>, item_def_id: LocalDefId, attr: &Attribute) {\n     let tcx = tcx;\n     let param_env = tcx.param_env(item_def_id);\n     let ty = tcx.type_of(item_def_id);"}, {"sha": "b49432b79962bd3c288ec770a85fe2d1d1e5483c", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -108,15 +108,13 @@ use std::rc::Rc;\n mod rwu_table;\n \n rustc_index::newtype_index! {\n-    pub struct Variable {\n-        DEBUG_FORMAT = \"v({})\",\n-    }\n+    #[debug_format = \"v({})\"]\n+    pub struct Variable {}\n }\n \n rustc_index::newtype_index! {\n-    pub struct LiveNode {\n-        DEBUG_FORMAT = \"ln({})\",\n-    }\n+    #[debug_format = \"ln({})\"]\n+    pub struct LiveNode {}\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]"}, {"sha": "ad09522038678f0842b25a0196910c4d9552ade2", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -347,7 +347,7 @@ fn check_item<'tcx>(\n     }\n }\n \n-fn has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+fn has_custom_linkage(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     // Anything which has custom linkage gets thrown on the worklist no\n     // matter where it is in the crate, along with \"special std symbols\"\n     // which are currently akin to allocator symbols.\n@@ -364,7 +364,7 @@ fn has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n         || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n }\n \n-fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n+fn reachable_set(tcx: TyCtxt<'_>, (): ()) -> FxHashSet<LocalDefId> {\n     let effective_visibilities = &tcx.effective_visibilities(());\n \n     let any_library ="}, {"sha": "96f7236de5cb12ab9209f1b2827319026419cfaf", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -853,7 +853,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n /// Check whether a path is a `use` item that has been marked as unstable.\n ///\n /// See issue #94972 for details on why this is a special case\n-fn is_unstable_reexport<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId) -> bool {\n+fn is_unstable_reexport(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     // Get the LocalDefId so we can lookup the item to check the kind.\n     let Some(def_id) = tcx.hir().opt_local_def_id(id) else { return false; };\n "}, {"sha": "fc6372cf99ee8be90a2def5d6a32d41718df2f0e", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -11,7 +11,7 @@ use crate::errors::{MissingLangItem, MissingPanicHandler, UnknownExternLangItem}\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItems) {\n+pub fn check_crate(tcx: TyCtxt<'_>, items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n     // so here.\n@@ -40,7 +40,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n     verify(tcx, items);\n }\n \n-fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n+fn verify(tcx: TyCtxt<'_>, items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n     let needs_check = tcx.sess.crate_types().iter().any(|kind| match *kind {"}, {"sha": "2bcfdab03c817bcc983a216d84fa3a78a59e8c92", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -227,7 +227,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n         *self.serialized_data.write() = None;\n     }\n \n-    fn serialize<'tcx>(&self, tcx: TyCtxt<'tcx>, encoder: FileEncoder) -> FileEncodeResult {\n+    fn serialize(&self, tcx: TyCtxt<'_>, encoder: FileEncoder) -> FileEncodeResult {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate `SourceFileIndex`es.\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for Symbol {\n                     s.emit_str(self.as_str());\n                 }\n                 Entry::Occupied(o) => {\n-                    let x = o.get().clone();\n+                    let x = *o.get();\n                     s.emit_u8(SYMBOL_OFFSET);\n                     s.emit_usize(x);\n                 }"}, {"sha": "9ffcc5672cc33676c2b37077603f21eeff3cb402", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -66,7 +66,7 @@ impl QueryContext for QueryCtxt<'_> {\n         tls::with_related_context(**self, |icx| icx.query)\n     }\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap> {\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<DepKind>> {\n         self.queries.try_collect_active_jobs(**self)\n     }\n \n@@ -195,7 +195,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n \n #[derive(Clone, Copy)]\n pub(crate) struct QueryStruct<'tcx> {\n-    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap) -> Option<()>,\n+    pub try_collect_active_jobs: fn(QueryCtxt<'tcx>, &mut QueryMap<DepKind>) -> Option<()>,\n     pub alloc_self_profile_query_strings: fn(TyCtxt<'tcx>, &mut QueryKeyStringCache),\n     pub encode_query_results:\n         Option<fn(QueryCtxt<'tcx>, &mut CacheEncoder<'_, 'tcx>, &mut EncodedDepNodeIndex)>,\n@@ -313,7 +313,7 @@ pub(crate) fn create_query_frame<\n     key: K,\n     kind: DepKind,\n     name: &'static str,\n-) -> QueryStackFrame {\n+) -> QueryStackFrame<DepKind> {\n     // Disable visible paths printing for performance reasons.\n     // Showing visible path instead of any path is not that important in production.\n     let description = ty::print::with_no_visible_paths!(\n@@ -346,7 +346,7 @@ pub(crate) fn create_query_frame<\n     };\n     let ty_adt_id = key.ty_adt_id();\n \n-    QueryStackFrame::new(name, description, span, def_id, def_kind, ty_adt_id, hash)\n+    QueryStackFrame::new(description, span, def_id, def_kind, kind, ty_adt_id, hash)\n }\n \n fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)\n@@ -378,7 +378,7 @@ fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n     Q: QueryConfig<QueryCtxt<'tcx>>,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n-    Q::Value: Value<TyCtxt<'tcx>>,\n+    Q::Value: Value<TyCtxt<'tcx>, DepKind>,\n {\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n@@ -402,7 +402,7 @@ where\n         #[cfg(debug_assertions)]\n         let _guard = tracing::span!(tracing::Level::TRACE, stringify!($name), ?key).entered();\n         let tcx = QueryCtxt::from_tcx(tcx);\n-        force_query::<Q, _>(tcx, key, dep_node);\n+        force_query::<Q, _, DepKind>(tcx, key, dep_node);\n         true\n     } else {\n         false\n@@ -480,7 +480,7 @@ macro_rules! define_queries {\n             type Cache = query_storage::$name<'tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key>\n+            fn query_state<'a>(tcx: QueryCtxt<'tcx>) -> &'a QueryState<Self::Key, crate::dep_graph::DepKind>\n                 where QueryCtxt<'tcx>: 'a\n             {\n                 &tcx.queries.$name\n@@ -587,9 +587,10 @@ macro_rules! define_queries {\n             use $crate::plumbing::{QueryStruct, QueryCtxt};\n             use $crate::profiling_support::QueryKeyStringCache;\n             use rustc_query_system::query::QueryMap;\n+            use rustc_middle::dep_graph::DepKind;\n \n             pub(super) const fn dummy_query_struct<'tcx>() -> QueryStruct<'tcx> {\n-                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap) -> Option<()> {\n+                fn noop_try_collect_active_jobs(_: QueryCtxt<'_>, _: &mut QueryMap<DepKind>) -> Option<()> {\n                     None\n                 }\n                 fn noop_alloc_self_profile_query_strings(_: TyCtxt<'_>, _: &mut QueryKeyStringCache) {}\n@@ -675,7 +676,8 @@ macro_rules! define_queries_struct {\n             $(\n                 $(#[$attr])*\n                 $name: QueryState<\n-                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key\n+                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n+                    rustc_middle::dep_graph::DepKind,\n                 >,\n             )*\n         }\n@@ -684,7 +686,7 @@ macro_rules! define_queries_struct {\n             pub(crate) fn try_collect_active_jobs(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n-            ) -> Option<QueryMap> {\n+            ) -> Option<QueryMap<rustc_middle::dep_graph::DepKind>> {\n                 let tcx = QueryCtxt { tcx, queries: self };\n                 let mut jobs = QueryMap::default();\n \n@@ -718,7 +720,7 @@ macro_rules! define_queries_struct {\n                 mode: QueryMode,\n             ) -> Option<query_stored::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n-                get_query::<queries::$name<'tcx>, _>(qcx, span, key, mode)\n+                get_query::<queries::$name<'tcx>, _, rustc_middle::dep_graph::DepKind>(qcx, span, key, mode)\n             })*\n         }\n     };"}, {"sha": "5f54bab9c31474d87852d7e4fa820a34a385274d", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -278,7 +278,7 @@ pub(crate) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n /// If we are recording only summary data, the ids will point to\n /// just the query names. If we are recording query keys too, we\n /// allocate the corresponding strings here.\n-pub fn alloc_self_profile_query_strings<'tcx>(tcx: TyCtxt<'tcx>) {\n+pub fn alloc_self_profile_query_strings(tcx: TyCtxt<'_>) {\n     if !tcx.prof.enabled() {\n         return;\n     }"}, {"sha": "52957ee0222387b62747d335e3429016184cf0bf", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -37,7 +37,7 @@ pub struct DepGraph<K: DepKind> {\n }\n \n rustc_index::newtype_index! {\n-    pub struct DepNodeIndex { .. }\n+    pub struct DepNodeIndex {}\n }\n \n impl DepNodeIndex {\n@@ -974,7 +974,7 @@ pub struct WorkProduct {\n \n // Index type for `DepNodeData`'s edges.\n rustc_index::newtype_index! {\n-    struct EdgeIndex { .. }\n+    struct EdgeIndex {}\n }\n \n /// `CurrentDepGraph` stores the dependency graph for the current session. It"}, {"sha": "a918328d4130ea08257536e8f432ca0c42396a32", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -27,9 +27,8 @@ use smallvec::SmallVec;\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n // and use those bits to encode which index type it contains.\n rustc_index::newtype_index! {\n-    pub struct SerializedDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n+    #[max = 0x7FFF_FFFF]\n+    pub struct SerializedDepNodeIndex {}\n }\n \n /// Data for use when recompiling the **current crate**."}, {"sha": "24c960765df8a387b8a177d3a8b4741d13204f3f", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -21,7 +21,7 @@ pub trait QueryConfig<Qcx: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key>\n+    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n         Qcx: 'a;\n "}, {"sha": "a5a2f0093ce6b97bff16dbf438d6915ef9ea5241", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,6 +1,8 @@\n+use crate::dep_graph::DepKind;\n use crate::error::CycleStack;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryStackFrame};\n+use core::marker::PhantomData;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -28,48 +30,48 @@ use {\n \n /// Represents a span and a query key.\n #[derive(Clone, Debug)]\n-pub struct QueryInfo {\n+pub struct QueryInfo<D: DepKind> {\n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n-    pub query: QueryStackFrame,\n+    pub query: QueryStackFrame<D>,\n }\n \n-pub type QueryMap = FxHashMap<QueryJobId, QueryJobInfo>;\n+pub type QueryMap<D> = FxHashMap<QueryJobId, QueryJobInfo<D>>;\n \n /// A value uniquely identifying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryJobId(pub NonZeroU64);\n \n impl QueryJobId {\n-    fn query(self, map: &QueryMap) -> QueryStackFrame {\n+    fn query<D: DepKind>(self, map: &QueryMap<D>) -> QueryStackFrame<D> {\n         map.get(&self).unwrap().query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span(self, map: &QueryMap) -> Span {\n+    fn span<D: DepKind>(self, map: &QueryMap<D>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent(self, map: &QueryMap) -> Option<QueryJobId> {\n+    fn parent<D: DepKind>(self, map: &QueryMap<D>) -> Option<QueryJobId> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a>(self, map: &'a QueryMap) -> Option<&'a QueryLatch> {\n+    fn latch<D: DepKind>(self, map: &QueryMap<D>) -> Option<&QueryLatch<D>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n #[derive(Clone)]\n-pub struct QueryJobInfo {\n-    pub query: QueryStackFrame,\n-    pub job: QueryJob,\n+pub struct QueryJobInfo<D: DepKind> {\n+    pub query: QueryStackFrame<D>,\n+    pub job: QueryJob<D>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob {\n+pub struct QueryJob<D: DepKind> {\n     pub id: QueryJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n@@ -80,10 +82,11 @@ pub struct QueryJob {\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch>,\n+    latch: Option<QueryLatch<D>>,\n+    spooky: core::marker::PhantomData<D>,\n }\n \n-impl QueryJob {\n+impl<D: DepKind> QueryJob<D> {\n     /// Creates a new query job.\n     #[inline]\n     pub fn new(id: QueryJobId, span: Span, parent: Option<QueryJobId>) -> Self {\n@@ -93,11 +96,12 @@ impl QueryJob {\n             parent,\n             #[cfg(parallel_compiler)]\n             latch: None,\n+            spooky: PhantomData,\n         }\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self) -> QueryLatch {\n+    pub(super) fn latch(&mut self) -> QueryLatch<D> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n@@ -123,12 +127,12 @@ impl QueryJobId {\n     #[cold]\n     #[inline(never)]\n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn find_cycle_in_stack(\n+    pub(super) fn find_cycle_in_stack<D: DepKind>(\n         &self,\n-        query_map: QueryMap,\n+        query_map: QueryMap<D>,\n         current_job: &Option<QueryJobId>,\n         span: Span,\n-    ) -> CycleError {\n+    ) -> CycleError<D> {\n         // Find the waitee amongst `current_job` parents\n         let mut cycle = Vec::new();\n         let mut current_job = Option::clone(current_job);\n@@ -162,14 +166,18 @@ impl QueryJobId {\n \n     #[cold]\n     #[inline(never)]\n-    pub fn try_find_layout_root(&self, query_map: QueryMap) -> Option<(QueryJobInfo, usize)> {\n+    pub fn try_find_layout_root<D: DepKind>(\n+        &self,\n+        query_map: QueryMap<D>,\n+    ) -> Option<(QueryJobInfo<D>, usize)> {\n         let mut last_layout = None;\n         let mut current_id = Some(*self);\n         let mut depth = 0;\n \n         while let Some(id) = current_id {\n             let info = query_map.get(&id).unwrap();\n-            if info.query.name == \"layout_of\" {\n+            // FIXME: This string comparison should probably not be done.\n+            if format!(\"{:?}\", info.query.dep_kind) == \"layout_of\" {\n                 depth += 1;\n                 last_layout = Some((info.clone(), depth));\n             }\n@@ -180,43 +188,47 @@ impl QueryJobId {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter {\n+struct QueryWaiter<D: DepKind> {\n     query: Option<QueryJobId>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError>>,\n+    cycle: Lock<Option<CycleError<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl QueryWaiter {\n+impl<D: DepKind> QueryWaiter<D> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo {\n+struct QueryLatchInfo<D: DepKind> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter>>,\n+    waiters: Vec<Lrc<QueryWaiter<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch {\n-    info: Lrc<Mutex<QueryLatchInfo>>,\n+pub(super) struct QueryLatch<D: DepKind> {\n+    info: Lrc<Mutex<QueryLatchInfo<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl QueryLatch {\n+impl<D: DepKind> QueryLatch<D> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n         }\n     }\n \n     /// Awaits for the query job to complete.\n-    pub(super) fn wait_on(&self, query: Option<QueryJobId>, span: Span) -> Result<(), CycleError> {\n+    pub(super) fn wait_on(\n+        &self,\n+        query: Option<QueryJobId>,\n+        span: Span,\n+    ) -> Result<(), CycleError<D>> {\n         let waiter =\n             Lrc::new(QueryWaiter { query, span, cycle: Lock::new(None), condvar: Condvar::new() });\n         self.wait_on_inner(&waiter);\n@@ -231,7 +243,7 @@ impl QueryLatch {\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -265,7 +277,7 @@ impl QueryLatch {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -287,9 +299,14 @@ type Waiter = (QueryJobId, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<F>(query_map: &QueryMap, query: QueryJobId, mut visit: F) -> Option<Option<Waiter>>\n+fn visit_waiters<F, D>(\n+    query_map: &QueryMap<D>,\n+    query: QueryJobId,\n+    mut visit: F,\n+) -> Option<Option<Waiter>>\n where\n     F: FnMut(Span, QueryJobId) -> Option<Option<Waiter>>,\n+    D: DepKind,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -318,8 +335,8 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check(\n-    query_map: &QueryMap,\n+fn cycle_check<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId,\n     span: Span,\n     stack: &mut Vec<(Span, QueryJobId)>,\n@@ -359,8 +376,8 @@ fn cycle_check(\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root(\n-    query_map: &QueryMap,\n+fn connected_to_root<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId,\n     visited: &mut FxHashSet<QueryJobId>,\n ) -> bool {\n@@ -382,9 +399,10 @@ fn connected_to_root(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, T, F>(query_map: &QueryMap, queries: &'a [T], f: F) -> &'a T\n+fn pick_query<'a, T, F, D>(query_map: &QueryMap<D>, queries: &'a [T], f: F) -> &'a T\n where\n     F: Fn(&T) -> (Span, QueryJobId),\n+    D: DepKind,\n {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n@@ -408,10 +426,10 @@ where\n /// If a cycle was not found, the starting query is removed from `jobs` and\n /// the function returns false.\n #[cfg(parallel_compiler)]\n-fn remove_cycle(\n-    query_map: &QueryMap,\n+fn remove_cycle<D: DepKind>(\n+    query_map: &QueryMap<D>,\n     jobs: &mut Vec<QueryJobId>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<D>>>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n@@ -513,7 +531,7 @@ fn remove_cycle(\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-pub fn deadlock(query_map: QueryMap, registry: &rayon_core::Registry) {\n+pub fn deadlock<D: DepKind>(query_map: QueryMap<D>, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();\n@@ -549,9 +567,9 @@ pub fn deadlock(query_map: QueryMap, registry: &rayon_core::Registry) {\n \n #[inline(never)]\n #[cold]\n-pub(crate) fn report_cycle<'a>(\n+pub(crate) fn report_cycle<'a, D: DepKind>(\n     sess: &'a Session,\n-    CycleError { usage, cycle: stack }: &CycleError,\n+    CycleError { usage, cycle: stack }: &CycleError<D>,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     assert!(!stack.is_empty());\n \n@@ -617,7 +635,7 @@ pub fn print_query_stack<Qcx: QueryContext>(\n         };\n         let mut diag = Diagnostic::new(\n             Level::FailureNote,\n-            &format!(\"#{} [{}] {}\", i, query_info.query.name, query_info.query.description),\n+            &format!(\"#{} [{:?}] {}\", i, query_info.query.dep_kind, query_info.query.description),\n         );\n         diag.span = query_info.job.span.into();\n         handler.force_print_diagnostic(diag);"}, {"sha": "ce9179ea832e75e8fbc6e61ff2f00b108ae8f1f5", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -14,6 +14,7 @@ pub use self::caches::{\n mod config;\n pub use self::config::{QueryConfig, QueryVTable};\n \n+use crate::dep_graph::DepKind;\n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use rustc_data_structures::sync::Lock;\n use rustc_errors::Diagnostic;\n@@ -26,37 +27,37 @@ use thin_vec::ThinVec;\n ///\n /// This is mostly used in case of cycles for error reporting.\n #[derive(Clone, Debug)]\n-pub struct QueryStackFrame {\n-    pub name: &'static str,\n+pub struct QueryStackFrame<D: DepKind> {\n     pub description: String,\n     span: Option<Span>,\n     pub def_id: Option<DefId>,\n     pub def_kind: Option<DefKind>,\n     pub ty_adt_id: Option<DefId>,\n+    pub dep_kind: D,\n     /// This hash is used to deterministically pick\n     /// a query to remove cycles in the parallel compiler.\n     #[cfg(parallel_compiler)]\n     hash: u64,\n }\n \n-impl QueryStackFrame {\n+impl<D: DepKind> QueryStackFrame<D> {\n     #[inline]\n     pub fn new(\n-        name: &'static str,\n         description: String,\n         span: Option<Span>,\n         def_id: Option<DefId>,\n         def_kind: Option<DefKind>,\n+        dep_kind: D,\n         ty_adt_id: Option<DefId>,\n         _hash: impl FnOnce() -> u64,\n     ) -> Self {\n         Self {\n-            name,\n             description,\n             span,\n             def_id,\n             def_kind,\n             ty_adt_id,\n+            dep_kind,\n             #[cfg(parallel_compiler)]\n             hash: _hash(),\n         }\n@@ -104,7 +105,7 @@ pub trait QueryContext: HasDepContext {\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId>;\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap>;\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n \n     /// Load side effects associated to the node in the previous session.\n     fn load_side_effects(&self, prev_dep_node_index: SerializedDepNodeIndex) -> QuerySideEffects;"}, {"sha": "53844dab9db59490992e073f0b62bf742df3f223", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::config::QueryVTable;\n@@ -31,26 +31,27 @@ use thin_vec::ThinVec;\n \n use super::QueryConfig;\n \n-pub struct QueryState<K> {\n+pub struct QueryState<K, D: DepKind> {\n     #[cfg(parallel_compiler)]\n-    active: Sharded<FxHashMap<K, QueryResult>>,\n+    active: Sharded<FxHashMap<K, QueryResult<D>>>,\n     #[cfg(not(parallel_compiler))]\n-    active: Lock<FxHashMap<K, QueryResult>>,\n+    active: Lock<FxHashMap<K, QueryResult<D>>>,\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult {\n+enum QueryResult<D: DepKind> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob),\n+    Started(QueryJob<D>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<K> QueryState<K>\n+impl<K, D> QueryState<K, D>\n where\n     K: Eq + Hash + Clone + Debug,\n+    D: DepKind,\n {\n     pub fn all_inactive(&self) -> bool {\n         #[cfg(parallel_compiler)]\n@@ -67,8 +68,8 @@ where\n     pub fn try_collect_active_jobs<Qcx: Copy>(\n         &self,\n         qcx: Qcx,\n-        make_query: fn(Qcx, K) -> QueryStackFrame,\n-        jobs: &mut QueryMap,\n+        make_query: fn(Qcx, K) -> QueryStackFrame<D>,\n+        jobs: &mut QueryMap<D>,\n     ) -> Option<()> {\n         #[cfg(parallel_compiler)]\n         {\n@@ -102,34 +103,34 @@ where\n     }\n }\n \n-impl<K> Default for QueryState<K> {\n-    fn default() -> QueryState<K> {\n+impl<K, D: DepKind> Default for QueryState<K, D> {\n+    fn default() -> QueryState<K, D> {\n         QueryState { active: Default::default() }\n     }\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, K>\n+struct JobOwner<'tcx, K, D: DepKind>\n where\n     K: Eq + Hash + Clone,\n {\n-    state: &'tcx QueryState<K>,\n+    state: &'tcx QueryState<K, D>,\n     key: K,\n     id: QueryJobId,\n }\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<Qcx, V, R>(\n+fn mk_cycle<Qcx, V, R, D: DepKind>(\n     qcx: Qcx,\n-    cycle_error: CycleError,\n+    cycle_error: CycleError<D>,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n-    Qcx: QueryContext,\n-    V: std::fmt::Debug + Value<Qcx::DepContext>,\n+    Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n+    V: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n     R: Clone,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n@@ -139,13 +140,13 @@ where\n \n fn handle_cycle_error<Tcx, V>(\n     tcx: Tcx,\n-    cycle_error: &CycleError,\n+    cycle_error: &CycleError<Tcx::DepKind>,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n where\n     Tcx: DepContext,\n-    V: Value<Tcx>,\n+    V: Value<Tcx, Tcx::DepKind>,\n {\n     use HandleCycleError::*;\n     match handler {\n@@ -165,7 +166,7 @@ where\n     }\n }\n \n-impl<'tcx, K> JobOwner<'tcx, K>\n+impl<'tcx, K, D: DepKind> JobOwner<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n {\n@@ -180,12 +181,12 @@ where\n     #[inline(always)]\n     fn try_start<'b, Qcx>(\n         qcx: &'b Qcx,\n-        state: &'b QueryState<K>,\n+        state: &'b QueryState<K, Qcx::DepKind>,\n         span: Span,\n         key: K,\n-    ) -> TryGetJob<'b, K>\n+    ) -> TryGetJob<'b, K, D>\n     where\n-        Qcx: QueryContext,\n+        Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -280,9 +281,10 @@ where\n     }\n }\n \n-impl<'tcx, K> Drop for JobOwner<'tcx, K>\n+impl<'tcx, K, D> Drop for JobOwner<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n+    D: DepKind,\n {\n     #[inline(never)]\n     #[cold]\n@@ -308,19 +310,20 @@ where\n }\n \n #[derive(Clone)]\n-pub(crate) struct CycleError {\n+pub(crate) struct CycleError<D: DepKind> {\n     /// The query and related span that uses the cycle.\n-    pub usage: Option<(Span, QueryStackFrame)>,\n-    pub cycle: Vec<QueryInfo>,\n+    pub usage: Option<(Span, QueryStackFrame<D>)>,\n+    pub cycle: Vec<QueryInfo<D>>,\n }\n \n /// The result of `try_start`.\n-enum TryGetJob<'tcx, K>\n+enum TryGetJob<'tcx, K, D>\n where\n     K: Eq + Hash + Clone,\n+    D: DepKind,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, K>),\n+    NotYetStarted(JobOwner<'tcx, K, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -329,17 +332,17 @@ where\n     JobCompleted(TimingGuard<'tcx>),\n \n     /// Trying to execute the query resulted in a cycle.\n-    Cycle(CycleError),\n+    Cycle(CycleError<D>),\n }\n \n /// Checks if the query is already computed and in the cache.\n /// It returns the shard index and a lock guard to the shard,\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<'a, Tcx, C, R, OnHit>(\n+pub fn try_get_cached<Tcx, C, R, OnHit>(\n     tcx: Tcx,\n-    cache: &'a C,\n+    cache: &C,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n@@ -360,7 +363,7 @@ where\n \n fn try_execute_query<Qcx, C>(\n     qcx: Qcx,\n-    state: &QueryState<C::Key>,\n+    state: &QueryState<C::Key, Qcx::DepKind>,\n     cache: &C,\n     span: Span,\n     key: C::Key,\n@@ -370,11 +373,11 @@ fn try_execute_query<Qcx, C>(\n where\n     C: QueryCache,\n     C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n-    C::Value: Value<Qcx::DepContext>,\n+    C::Value: Value<Qcx::DepContext, Qcx::DepKind>,\n     C::Stored: Debug + std::borrow::Borrow<C::Value>,\n     Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n+    match JobOwner::<'_, C::Key, Qcx::DepKind>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n             let (result, dep_node_index) = execute_job(qcx, key.clone(), dep_node, query, job.id);\n             if query.feedable {\n@@ -739,11 +742,12 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, Qcx>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx, D>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n+    D: DepKind,\n     Q: QueryConfig<Qcx>,\n     Q::Key: DepNodeParams<Qcx::DepContext>,\n-    Q::Value: Value<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     let query = Q::make_vtable(qcx, &key);\n@@ -772,11 +776,12 @@ where\n     Some(result)\n }\n \n-pub fn force_query<Q, Qcx>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n+pub fn force_query<Q, Qcx, D>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n where\n+    D: DepKind,\n     Q: QueryConfig<Qcx>,\n     Q::Key: DepNodeParams<Qcx::DepContext>,\n-    Q::Value: Value<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext, D>,\n     Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query."}, {"sha": "b6e2cfa3dca5e3c33ab02040cea3b2f55b9e75f5", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,12 +1,12 @@\n-use crate::dep_graph::DepContext;\n+use crate::dep_graph::{DepContext, DepKind};\n use crate::query::QueryInfo;\n \n-pub trait Value<Tcx: DepContext>: Sized {\n-    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo]) -> Self;\n+pub trait Value<Tcx: DepContext, D: DepKind>: Sized {\n+    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo<D>]) -> Self;\n }\n \n-impl<Tcx: DepContext, T> Value<Tcx> for T {\n-    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo]) -> T {\n+impl<Tcx: DepContext, T, D: DepKind> Value<Tcx, D> for T {\n+    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo<D>]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}, {"sha": "cf63599626866203f41feeaca0bf156bd9d0ce75", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 // Ensure there is at most one `self` in the list\n                 let self_spans = items\n                     .iter()\n-                    .filter_map(|&(ref use_tree, _)| {\n+                    .filter_map(|(use_tree, _)| {\n                         if let ast::UseTreeKind::Simple(..) = use_tree.kind {\n                             if use_tree.ident().name == kw::SelfLower {\n                                 return Some(use_tree.span);"}, {"sha": "600308b6508db9931c3b6974acf48493421d8bfc", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -277,11 +277,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 let override_suggestion =\n                     if [\"true\", \"false\"].contains(&item_str.to_string().to_lowercase().as_str()) {\n                         let item_typo = item_str.to_string().to_lowercase();\n-                        Some((\n-                            item_span,\n-                            \"you may want to use a bool value instead\",\n-                            format!(\"{}\", item_typo),\n-                        ))\n+                        Some((item_span, \"you may want to use a bool value instead\", item_typo))\n                     // FIXME(vincenzopalazzo): make the check smarter,\n                     // and maybe expand with levenshtein distance checks\n                     } else if item_str.as_str() == \"printf\" {\n@@ -2324,7 +2320,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         let message = format!(\"consider introducing lifetime `{}` here\", name);\n                         should_continue = suggest(err, false, span, &message, sugg);\n                     } else {\n-                        let message = format!(\"consider introducing a named lifetime parameter\");\n+                        let message = \"consider introducing a named lifetime parameter\";\n                         should_continue = suggest(err, false, span, &message, sugg);\n                     }\n                 }"}, {"sha": "2182b73693774638c46a5f91f3f51fdaaf109956", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1491,7 +1491,7 @@ impl<'a> Resolver<'a> {\n             label_res_map: self.label_res_map.clone(),\n             lifetimes_res_map: self.lifetimes_res_map.clone(),\n             extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n-            next_node_id: self.next_node_id.clone(),\n+            next_node_id: self.next_node_id,\n             node_id_to_def_id: self.node_id_to_def_id.clone(),\n             def_id_to_node_id: self.def_id_to_node_id.clone(),\n             trait_map: self.trait_map.clone(),\n@@ -1686,21 +1686,43 @@ impl<'a> Resolver<'a> {\n             .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n+    /// Test if AmbiguityError ambi is any identical to any one inside ambiguity_errors\n+    fn matches_previous_ambiguity_error(&mut self, ambi: &AmbiguityError<'_>) -> bool {\n+        for ambiguity_error in &self.ambiguity_errors {\n+            // if the span location and ident as well as its span are the same\n+            if ambiguity_error.kind == ambi.kind\n+                && ambiguity_error.ident == ambi.ident\n+                && ambiguity_error.ident.span == ambi.ident.span\n+                && ambiguity_error.b1.span == ambi.b1.span\n+                && ambiguity_error.b2.span == ambi.b2.span\n+                && ambiguity_error.misc1 == ambi.misc1\n+                && ambiguity_error.misc2 == ambi.misc2\n+            {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n     fn record_use(\n         &mut self,\n         ident: Ident,\n         used_binding: &'a NameBinding<'a>,\n         is_lexical_scope: bool,\n     ) {\n         if let Some((b2, kind)) = used_binding.ambiguity {\n-            self.ambiguity_errors.push(AmbiguityError {\n+            let ambiguity_error = AmbiguityError {\n                 kind,\n                 ident,\n                 b1: used_binding,\n                 b2,\n                 misc1: AmbiguityErrorMisc::None,\n                 misc2: AmbiguityErrorMisc::None,\n-            });\n+            };\n+            if !self.matches_previous_ambiguity_error(&ambiguity_error) {\n+                // avoid dumplicated span information to be emitt out\n+                self.ambiguity_errors.push(ambiguity_error);\n+            }\n         }\n         if let NameBindingKind::Import { import, binding, ref used } = used_binding.kind {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,"}, {"sha": "6afd5fe5a7f2a1a9e96b9f2d5d10c5a74427ac92", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -957,10 +957,10 @@ impl SaveHandler for CallbackHandler<'_> {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn process_crate<H: SaveHandler>(\n+    tcx: TyCtxt<'_>,\n     cratename: Symbol,\n-    input: &'l Input,\n+    input: &Input,\n     config: Option<Config>,\n     mut handler: H,\n ) {"}, {"sha": "e72b76cfee9e9660a427746e2cadd14cb0ef711c", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -115,6 +115,10 @@ pub struct StackProtectorNotSupportedForTarget<'a> {\n     pub target_triple: &'a TargetTriple,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(session_branch_protection_requires_aarch64)]\n+pub(crate) struct BranchProtectionRequiresAArch64;\n+\n #[derive(Diagnostic)]\n #[diag(session_split_debuginfo_unstable_platform)]\n pub struct SplitDebugInfoUnstablePlatform {"}, {"sha": "6f1b31ff9c3aec9cbce8cb0bf3b2fe053a566ba7", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -122,7 +122,7 @@ pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n     let target = crate::config::host_triple();\n     let mut sysroot_candidates: SmallVec<[PathBuf; 2]> =\n         smallvec![get_or_default_sysroot().expect(\"Failed finding sysroot\")];\n-    let path = current_dll_path().and_then(|s| Ok(s.canonicalize().map_err(|e| e.to_string())?));\n+    let path = current_dll_path().and_then(|s| s.canonicalize().map_err(|e| e.to_string()));\n     if let Ok(dll) = path {\n         // use `parent` twice to chop off the file name and then also the\n         // directory containing the dll which should be either `lib` or `bin`.\n@@ -165,7 +165,7 @@ pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n     }\n \n     fn default_from_rustc_driver_dll() -> Result<PathBuf, String> {\n-        let dll = current_dll_path().and_then(|s| Ok(canonicalize(s)))?;\n+        let dll = current_dll_path().map(|s| canonicalize(s))?;\n \n         // `dll` will be in one of the following two:\n         // - compiler's libdir: $sysroot/lib/*.dll"}, {"sha": "40bc669707aa01d33f55a89e9eaef27cf7127cbf", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1421,6 +1421,8 @@ options! {\n         \"run all passes except codegen; no output\"),\n     no_generate_arange_section: bool = (false, parse_no_flag, [TRACKED],\n         \"omit DWARF address ranges that give faster lookups\"),\n+    no_jump_tables: bool = (false, parse_no_flag, [TRACKED],\n+        \"disable the jump tables and lookup tables that can be generated from a switch case lowering\"),\n     no_leak_check: bool = (false, parse_no_flag, [UNTRACKED],\n         \"disable the 'leak check' for subtyping; unsound, but useful for tests\"),\n     no_link: bool = (false, parse_no_flag, [TRACKED],"}, {"sha": "2aa8ca9e4a9194d94316f5e184d313e8ed5cb7b3", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -122,7 +122,7 @@ pub fn feature_err_issue<'a>(\n /// Construct a future incompatibility diagnostic for a feature gate.\n ///\n /// This diagnostic is only a warning and *does not cause compilation to fail*.\n-pub fn feature_warn<'a>(sess: &'a ParseSess, feature: Symbol, span: Span, explain: &str) {\n+pub fn feature_warn(sess: &ParseSess, feature: Symbol, span: Span, explain: &str) {\n     feature_warn_issue(sess, feature, span, GateIssue::Language, explain);\n }\n \n@@ -134,8 +134,8 @@ pub fn feature_warn<'a>(sess: &'a ParseSess, feature: Symbol, span: Span, explai\n /// Almost always, you want to use this for a language feature. If so, prefer `feature_warn`.\n #[allow(rustc::diagnostic_outside_of_impl)]\n #[allow(rustc::untranslatable_diagnostic)]\n-pub fn feature_warn_issue<'a>(\n-    sess: &'a ParseSess,\n+pub fn feature_warn_issue(\n+    sess: &ParseSess,\n     feature: Symbol,\n     span: Span,\n     issue: GateIssue,\n@@ -160,7 +160,7 @@ pub fn feature_warn_issue<'a>(\n }\n \n /// Adds the diagnostics for a feature to an existing error.\n-pub fn add_feature_diagnostics<'a>(err: &mut Diagnostic, sess: &'a ParseSess, feature: Symbol) {\n+pub fn add_feature_diagnostics(err: &mut Diagnostic, sess: &ParseSess, feature: Symbol) {\n     add_feature_diagnostics_for_issue(err, sess, feature, GateIssue::Language);\n }\n \n@@ -169,9 +169,9 @@ pub fn add_feature_diagnostics<'a>(err: &mut Diagnostic, sess: &'a ParseSess, fe\n /// This variant allows you to control whether it is a library or language feature.\n /// Almost always, you want to use this for a language feature. If so, prefer\n /// `add_feature_diagnostics`.\n-pub fn add_feature_diagnostics_for_issue<'a>(\n+pub fn add_feature_diagnostics_for_issue(\n     err: &mut Diagnostic,\n-    sess: &'a ParseSess,\n+    sess: &ParseSess,\n     feature: Symbol,\n     issue: GateIssue,\n ) {"}, {"sha": "01a9b1000882bd5c77a20b64a697a57ea409d260", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -3,10 +3,10 @@ use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n use crate::errors::{\n-    CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers, LinkerPluginToWindowsNotSupported,\n-    NotCircumventFeature, ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist,\n-    SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n-    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n+    BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n+    LinkerPluginToWindowsNotSupported, NotCircumventFeature, ProfileSampleUseFileDoesNotExist,\n+    ProfileUseFileDoesNotExist, SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported,\n+    SkippingConstChecks, SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n     TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n     UnsupportedDwarfVersion,\n };\n@@ -1323,7 +1323,7 @@ pub fn build_session(\n     let warnings_allow = sopts\n         .lint_opts\n         .iter()\n-        .rfind(|&&(ref key, _)| *key == \"warnings\")\n+        .rfind(|&(key, _)| *key == \"warnings\")\n         .map_or(false, |&(_, level)| level == lint::Allow);\n     let cap_lints_allow = sopts.lint_cap.map_or(false, |cap| cap == lint::Allow);\n     let can_emit_warnings = !(warnings_allow || cap_lints_allow);\n@@ -1565,6 +1565,10 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         }\n     }\n \n+    if sess.opts.unstable_opts.branch_protection.is_some() && sess.target.arch != \"aarch64\" {\n+        sess.emit_err(BranchProtectionRequiresAArch64);\n+    }\n+\n     if let Some(dwarf_version) = sess.opts.unstable_opts.dwarf_version {\n         if dwarf_version > 5 {\n             sess.emit_err(UnsupportedDwarfVersion { dwarf_version });"}, {"sha": "b996d36a318c5f42ca287a2465a389d1d8f77ec1", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::profiling::VerboseTimingGuard;\n use std::path::{Path, PathBuf};\n \n impl Session {\n-    pub fn timer<'a>(&'a self, what: &'static str) -> VerboseTimingGuard<'a> {\n+    pub fn timer(&self, what: &'static str) -> VerboseTimingGuard<'_> {\n         self.prof.verbose_generic_activity(what)\n     }\n     pub fn time<R>(&self, what: &'static str, f: impl FnOnce() -> R) -> R {"}, {"sha": "5ce2577b63c1d81cfd46150dffeb5e039ee00b0c", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -13,7 +13,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_arena = { path = \"../rustc_arena\" }\n scoped-tls = \"1.0\"\n unicode-width = \"0.1.4\"\n-cfg-if = \"0.1.2\"\n+cfg-if = \"1.0\"\n tracing = \"0.1\"\n sha1 = { package = \"sha-1\", version = \"0.10.0\" }\n sha2 = \"0.10.1\""}, {"sha": "221f65b66e6d4b77a1a0f63bc27acf3905e718b5", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -10,10 +10,9 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n \n rustc_index::newtype_index! {\n-    pub struct CrateNum {\n-        ENCODABLE = custom\n-        DEBUG_FORMAT = \"crate{}\"\n-    }\n+    #[custom_encodable]\n+    #[debug_format = \"crate{}\"]\n+    pub struct CrateNum {}\n }\n \n /// Item definitions in the currently-compiled crate would have the `CrateNum`\n@@ -194,13 +193,12 @@ rustc_index::newtype_index! {\n     /// A DefIndex is an index into the hir-map for a crate, identifying a\n     /// particular definition. It should really be considered an interned\n     /// shorthand for a particular DefPath.\n+    #[custom_encodable] // (only encodable in metadata)\n+    #[debug_format = \"DefIndex({})\"]\n     pub struct DefIndex {\n-        ENCODABLE = custom // (only encodable in metadata)\n-\n-        DEBUG_FORMAT = \"DefIndex({})\",\n         /// The crate root is always assigned index 0 by the AST Map code,\n         /// thanks to `NodeCollector::new`.\n-        const CRATE_DEF_INDEX = 0,\n+        const CRATE_DEF_INDEX = 0;\n     }\n }\n "}, {"sha": "c2d8287f2431dc3faa5cad0a1b0070e97257dc72", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -61,9 +61,8 @@ pub struct SyntaxContextData {\n \n rustc_index::newtype_index! {\n     /// A unique ID associated with a macro invocation and expansion.\n-    pub struct ExpnIndex {\n-        ENCODABLE = custom\n-    }\n+    #[custom_encodable]\n+    pub struct ExpnIndex {}\n }\n \n /// A unique ID associated with a macro invocation and expansion.\n@@ -82,11 +81,10 @@ impl fmt::Debug for ExpnId {\n \n rustc_index::newtype_index! {\n     /// A unique ID associated with a macro invocation and expansion.\n-    pub struct LocalExpnId {\n-        ENCODABLE = custom\n-        ORD_IMPL = custom\n-        DEBUG_FORMAT = \"expn{}\"\n-    }\n+    #[custom_encodable]\n+    #[no_ord_impl]\n+    #[debug_format = \"expn{}\"]\n+    pub struct LocalExpnId {}\n }\n \n // To ensure correctness of incremental compilation,"}, {"sha": "e802663471341cdd1eba4b0549c313e2d98ea969", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -164,7 +164,6 @@ symbols! {\n         Capture,\n         Center,\n         Clone,\n-        Context,\n         Continue,\n         Copy,\n         Count,\n@@ -264,6 +263,7 @@ symbols! {\n         Relaxed,\n         Release,\n         Result,\n+        ResumeTy,\n         Return,\n         Right,\n         Rust,\n@@ -376,9 +376,9 @@ symbols! {\n         assert_eq_macro,\n         assert_inhabited,\n         assert_macro,\n+        assert_mem_uninitialized_valid,\n         assert_ne_macro,\n         assert_receiver_is_total_eq,\n-        assert_uninit_valid,\n         assert_zero_valid,\n         asserting,\n         associated_const_equality,\n@@ -753,6 +753,7 @@ symbols! {\n         generic_associated_types_extended,\n         generic_const_exprs,\n         generic_param_attrs,\n+        get_context,\n         global_allocator,\n         global_asm,\n         globs,\n@@ -1801,7 +1802,7 @@ impl fmt::Display for MacroRulesNormalizedIdent {\n pub struct Symbol(SymbolIndex);\n \n rustc_index::newtype_index! {\n-    struct SymbolIndex { .. }\n+    struct SymbolIndex {}\n }\n \n impl Symbol {"}, {"sha": "493e31a688fccdf6f6c0a4a19d1811faa763969a", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -99,13 +99,8 @@ fn is_c_void_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Adt(adt_def, ..) => {\n             let def_id = adt_def.0.did;\n             let crate_name = tcx.crate_name(def_id.krate);\n-            if tcx.item_name(def_id).as_str() == \"c_void\"\n+            tcx.item_name(def_id).as_str() == \"c_void\"\n                 && (crate_name == sym::core || crate_name == sym::std || crate_name == sym::libc)\n-            {\n-                true\n-            } else {\n-                false\n-            }\n         }\n         _ => false,\n     }\n@@ -267,8 +262,7 @@ fn encode_predicates<'tcx>(\n ) -> String {\n     // <predicate1[..predicateN]>E as part of vendor extended type\n     let mut s = String::new();\n-    let predicates: Vec<ty::PolyExistentialPredicate<'tcx>> =\n-        predicates.iter().map(|predicate| predicate).collect();\n+    let predicates: Vec<ty::PolyExistentialPredicate<'tcx>> = predicates.iter().collect();\n     for predicate in predicates {\n         s.push_str(&encode_predicate(tcx, predicate, dict, options));\n     }\n@@ -322,7 +316,7 @@ fn encode_substs<'tcx>(\n ) -> String {\n     // [I<subst1..substN>E] as part of vendor extended type\n     let mut s = String::new();\n-    let substs: Vec<GenericArg<'_>> = substs.iter().map(|subst| subst).collect();\n+    let substs: Vec<GenericArg<'_>> = substs.iter().collect();\n     if !substs.is_empty() {\n         s.push('I');\n         for subst in substs {\n@@ -344,7 +338,7 @@ fn encode_substs<'tcx>(\n }\n \n /// Encodes a ty:Ty name, including its crate and path disambiguators and names.\n-fn encode_ty_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> String {\n+fn encode_ty_name(tcx: TyCtxt<'_>, def_id: DefId) -> String {\n     // Encode <name> for use in u<length><name>[I<element-type1..element-typeN>E], where\n     // <element-type> is <subst>, using v0's <path> without v0's extended form of paths:\n     //\n@@ -703,11 +697,8 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                         tcx.layout_of(param_env.and(ty)).map_or(false, |layout| layout.is_zst());\n                     !is_zst\n                 });\n-                if field.is_none() {\n-                    // Transform repr(transparent) types without non-ZST field into ()\n-                    ty = tcx.mk_unit();\n-                } else {\n-                    let ty0 = tcx.type_of(field.unwrap().did);\n+                if let Some(field) = field {\n+                    let ty0 = tcx.type_of(field.did);\n                     // Generalize any repr(transparent) user-defined type that is either a pointer\n                     // or reference, and either references itself or any other type that contains or\n                     // references itself, to avoid a reference cycle.\n@@ -720,6 +711,9 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                     } else {\n                         ty = transform_ty(tcx, ty0, options);\n                     }\n+                } else {\n+                    // Transform repr(transparent) types without non-ZST field into ()\n+                    ty = tcx.mk_unit();\n                 }\n             } else {\n                 ty = tcx.mk_adt(*adt_def, transform_substs(tcx, substs, options));"}, {"sha": "4a2d39cc70023bbb81b49c3ba06413273b85e9f0", "filename": "compiler/rustc_target/src/abi/call/loongarch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Floongarch.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -19,7 +19,7 @@ enum FloatConv {\n #[derive(Copy, Clone)]\n struct CannotUseFpConv;\n \n-fn is_loongarch_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+fn is_loongarch_aggregate<Ty>(arg: &ArgAbi<'_, Ty>) -> bool {\n     match arg.layout.abi {\n         Abi::Vector { .. } => true,\n         _ => arg.layout.is_aggregate(),\n@@ -290,7 +290,7 @@ fn classify_arg<'a, Ty, C>(\n     }\n }\n \n-fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+fn extend_integer_width<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     if let Abi::Scalar(scalar) = arg.layout.abi {\n         if let abi::Int(i, _) = scalar.primitive() {\n             // 32-bit integers are always sign-extended"}, {"sha": "34280d38e3406a7bef5f4e00839b993f88f10eec", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -25,7 +25,7 @@ enum FloatConv {\n #[derive(Copy, Clone)]\n struct CannotUseFpConv;\n \n-fn is_riscv_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {\n+fn is_riscv_aggregate<Ty>(arg: &ArgAbi<'_, Ty>) -> bool {\n     match arg.layout.abi {\n         Abi::Vector { .. } => true,\n         _ => arg.layout.is_aggregate(),\n@@ -296,7 +296,7 @@ fn classify_arg<'a, Ty, C>(\n     }\n }\n \n-fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n+fn extend_integer_width<Ty>(arg: &mut ArgAbi<'_, Ty>, xlen: u64) {\n     if let Abi::Scalar(scalar) = arg.layout.abi {\n         if let abi::Int(i, _) = scalar.primitive() {\n             // 32-bit integers are always sign-extended"}, {"sha": "88a0a1f8ecfdedafd60a8d9f6f516f488f06ca79", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -20,9 +20,8 @@ impl ToJson for Endian {\n }\n \n rustc_index::newtype_index! {\n-    pub struct VariantIdx {\n-        derive [HashStable_Generic]\n-    }\n+    #[derive(HashStable_Generic)]\n+    pub struct VariantIdx {}\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]"}, {"sha": "988cd401f406bff9f66d02a6d55895afde9a5e21", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1319,7 +1319,7 @@ pub struct Target {\n }\n \n impl Target {\n-    pub fn parse_data_layout<'a>(&'a self) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n+    pub fn parse_data_layout(&self) -> Result<TargetDataLayout, TargetDataLayoutErrors<'_>> {\n         let mut dl = TargetDataLayout::parse_from_llvm_datalayout_string(&self.data_layout)?;\n \n         // Perform consistency checks against the Target information."}, {"sha": "a30d1df4ede52bd3ffcdbf298b0f0d9f0d2e3d44", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -19,6 +19,7 @@\n #![feature(let_chains)]\n #![feature(if_let_guard)]\n #![feature(never_type)]\n+#![feature(result_option_inspect)]\n #![feature(type_alias_impl_trait)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n@@ -37,4 +38,5 @@ extern crate smallvec;\n pub mod autoderef;\n pub mod errors;\n pub mod infer;\n+pub mod solve;\n pub mod traits;"}, {"sha": "e9ddad11ff23e5707ad6297186d93846588e1e03", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,150 @@\n+//! Code shared by trait and projection goals for candidate assembly.\n+\n+use super::infcx_ext::InferCtxtExt;\n+use super::{\n+    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n+    EvalCtxt, Goal,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{\n+    canonical::{CanonicalVarValues, OriginalQueryValues},\n+    InferCtxt,\n+};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+use std::fmt::Debug;\n+\n+/// A candidate is a possible way to prove a goal.\n+///\n+/// It consists of both the `source`, which describes how that goal would be proven,\n+/// and the `result` when using the given `source`.\n+///\n+/// For the list of possible candidates, please look at the documentation of\n+/// [super::trait_goals::CandidateSource] and [super::project_goals::CandidateSource].\n+#[derive(Debug, Clone)]\n+pub(super) struct Candidate<'tcx, G: GoalKind<'tcx>> {\n+    pub(super) source: G::CandidateSource,\n+    pub(super) result: CanonicalResponse<'tcx>,\n+}\n+\n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n+    type CandidateSource: Debug + Copy;\n+\n+    fn self_ty(self) -> Ty<'tcx>;\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n+\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n+        impl_def_id: DefId,\n+    );\n+}\n+\n+/// An abstraction which correctly deals with the canonical results for candidates.\n+///\n+/// It also deduplicates the behavior between trait and projection predicates.\n+pub(super) struct AssemblyCtxt<'a, 'tcx, G: GoalKind<'tcx>> {\n+    pub(super) cx: &'a mut EvalCtxt<'tcx>,\n+    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n+    candidates: Vec<Candidate<'tcx, G>>,\n+}\n+\n+impl<'a, 'tcx, G: GoalKind<'tcx>> AssemblyCtxt<'a, 'tcx, G> {\n+    pub(super) fn assemble_and_evaluate_candidates(\n+        cx: &'a mut EvalCtxt<'tcx>,\n+        goal: CanonicalGoal<'tcx, G>,\n+    ) -> Vec<Candidate<'tcx, G>> {\n+        let (ref infcx, goal, var_values) =\n+            cx.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+        let mut acx = AssemblyCtxt { cx, infcx, var_values, candidates: Vec::new() };\n+\n+        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+\n+        acx.assemble_impl_candidates(goal);\n+\n+        acx.candidates\n+    }\n+\n+    pub(super) fn try_insert_candidate(\n+        &mut self,\n+        source: G::CandidateSource,\n+        certainty: Certainty,\n+    ) {\n+        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+            Ok(result) => self.candidates.push(Candidate { source, result }),\n+            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        }\n+    }\n+\n+    /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n+    ///\n+    /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n+    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n+    /// this case as projections as self types add `\n+    fn assemble_candidates_after_normalizing_self_ty(&mut self, goal: Goal<'tcx, G>) {\n+        let tcx = self.cx.tcx;\n+        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n+        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+            return\n+        };\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n+            let normalizes_to_goal = goal.with(\n+                tcx,\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    term: normalized_ty.into(),\n+                }),\n+            );\n+            let normalization_certainty =\n+                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n+                    Ok((_, certainty)) => certainty,\n+                    Err(NoSolution) => return,\n+                };\n+\n+            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+            let mut orig_values = OriginalQueryValues::default();\n+            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let normalized_candidates =\n+                AssemblyCtxt::assemble_and_evaluate_candidates(self.cx, goal);\n+\n+            // Map each candidate from being canonical wrt the current inference context to being\n+            // canonical wrt the caller.\n+            for Candidate { source, result } in normalized_candidates {\n+                self.infcx.probe(|_| {\n+                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n+                        &self.infcx,\n+                        &orig_values,\n+                        result,\n+                    );\n+\n+                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n+                    //\n+                    // If we have an ambiguous candidate it hides that normalization\n+                    // caused an overflow which may cause issues.\n+                    self.try_insert_candidate(\n+                        source,\n+                        normalization_certainty.unify_and(candidate_certainty),\n+                    )\n+                })\n+            }\n+        })\n+    }\n+\n+    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, G>) {\n+        self.cx.tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(self.cx.tcx),\n+            goal.predicate.self_ty(),\n+            |impl_def_id| G::consider_impl_candidate(self, goal, impl_def_id),\n+        );\n+    }\n+}"}, {"sha": "993b79890669c206a8da81d42f7c0b31091a3aab", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,257 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::CanonicalGoal;\n+use super::{EvalCtxt, QueryResult};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TyCtxt;\n+use std::{cmp::Ordering, collections::hash_map::Entry};\n+\n+#[derive(Debug, Clone)]\n+struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    response: QueryResult<'tcx>,\n+    // The lowest element on the stack on which this result\n+    // relies on. Starts out as just being the depth at which\n+    // we've proven this obligation, but gets lowered to the\n+    // depth of another goal if we rely on it in a cycle.\n+    depth: usize,\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+/// The cache used for goals which are currently in progress or which depend\n+/// on in progress results.\n+///\n+/// Once we're done with a goal we can store it in the global trait solver\n+/// cache of the `TyCtxt`. For goals which we're currently proving, or which\n+/// have only been proven via a coinductive cycle using a goal still on our stack\n+/// we have to use this separate data structure.\n+///\n+/// The current data structure is not perfect, so there may still be room for\n+/// improvement here. We have the following requirements:\n+///\n+/// ## Is there is a provisional entry for the given goal:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// self.entries.get(goal)\n+/// ```\n+///\n+/// ## Get all goals on the stack involved in a cycle:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let entry = self.entries.get(goal).unwrap();\n+/// let involved_goals = self.stack.iter().skip(entry.depth);\n+/// ```\n+///\n+/// ## Capping the depth of all entries\n+///\n+/// Needed whenever we encounter a cycle. The current implementation always\n+/// iterates over all entries instead of only the ones with a larger depth.\n+/// Changing this may result in notable performance improvements.\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let cycle_depth = self.entries.get(goal).unwrap().depth;\n+/// for e in &mut self.entries {\n+///     e.depth = e.depth.min(cycle_depth);\n+/// }\n+/// ```\n+///\n+/// ## Checking whether we have to rerun the current goal\n+///\n+/// A goal has to be rerun if its provisional result was used in a cycle\n+/// and that result is different from its final result. We update\n+/// [StackElem::has_been_used] for the deepest stack element involved in a cycle.\n+///\n+/// ## Moving all finished goals into the global cache\n+///\n+/// If `stack_elem.has_been_used` is true, iterate over all entries, moving the ones\n+/// with equal depth. If not, simply move this single entry.\n+pub(super) struct ProvisionalCache<'tcx> {\n+    stack: Vec<StackElem<'tcx>>,\n+    entries: FxHashMap<CanonicalGoal<'tcx>, ProvisionalEntry<'tcx>>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { stack: Vec::new(), entries: Default::default() }\n+    }\n+\n+    pub(super) fn current_depth(&self) -> usize {\n+        self.stack.len()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.entries.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(cache.stack.len()) {\n+                    return Err(self.deal_with_overflow());\n+                }\n+\n+                v.insert(ProvisionalEntry {\n+                    response: fixme_response_yes_no_constraints(),\n+                    depth: cache.stack.len(),\n+                });\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry) => {\n+                // FIXME: `ProvisionalEntry` should be `Copy`.\n+                let entry = entry.get().clone();\n+                cache.stack[entry.depth].has_been_used = true;\n+                for provisional_entry in cache.entries.values_mut() {\n+                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n+                }\n+\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself simply checking\n+                // the stack is enough.\n+                if cache.stack[entry.depth..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n+                {\n+                    Err(entry.response)\n+                } else {\n+                    Err(fixme_response_maybe_no_constraints())\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let cache = &mut self.provisional_cache;\n+        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let provisional_entry = cache.entries.get_mut(&goal).unwrap();\n+        // Check whether the current stack entry is the root of a cycle.\n+        //\n+        // If so, we either move all participants of that cycle to the global cache\n+        // or, in case the provisional response used in the cycle is not equal to the\n+        // final response, have to recompute the goal after updating the provisional\n+        // response to the final response of this iteration.\n+        if has_been_used {\n+            if provisional_entry.response == response {\n+                // We simply drop all entries according to an immutable condition, so\n+                // query instability is not a concern here.\n+                #[allow(rustc::potential_query_instability)]\n+                cache.entries.retain(|goal, entry| match entry.depth.cmp(&cache.stack.len()) {\n+                    Ordering::Less => true,\n+                    Ordering::Equal => {\n+                        Self::try_move_finished_goal_to_global_cache(\n+                            self.tcx,\n+                            &mut self.overflow_data,\n+                            &cache.stack,\n+                            // FIXME: these should be `Copy` :(\n+                            goal.clone(),\n+                            entry.response.clone(),\n+                        );\n+                        false\n+                    }\n+                    Ordering::Greater => bug!(\"entry with greater depth than the current leaf\"),\n+                });\n+\n+                true\n+            } else {\n+                provisional_entry.response = response;\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                false\n+            }\n+        } else {\n+            Self::try_move_finished_goal_to_global_cache(\n+                self.tcx,\n+                &mut self.overflow_data,\n+                &cache.stack,\n+                goal,\n+                response,\n+            );\n+            cache.entries.remove(&goal);\n+            true\n+        }\n+    }\n+\n+    fn try_move_finished_goal_to_global_cache(\n+        tcx: TyCtxt<'tcx>,\n+        overflow_data: &mut OverflowData,\n+        stack: &[StackElem<'tcx>],\n+        goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) {\n+        // We move goals to the global cache if we either did not hit an overflow or if it's\n+        // the root goal as that will now always hit the same overflow limit.\n+        //\n+        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+        // isn't impacted by the overflow as that goal still has unstable query dependencies\n+        // because it didn't go its full depth.\n+        //\n+        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+        if should_cache_globally {\n+            // FIXME: move the provisional entry to the global cache.\n+            let _ = (tcx, goal, response);\n+        }\n+    }\n+}\n+\n+fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}\n+\n+fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "80115d78d88d17aad9cbb4d77894a435c6be14d3", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,92 @@\n+use std::mem;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_infer::{\n+    infer::InferCtxt,\n+    traits::{query::NoSolution, FulfillmentError, PredicateObligation, TraitEngine},\n+};\n+use rustc_middle::ty;\n+\n+use super::{Certainty, EvalCtxt};\n+\n+/// A trait engine using the new trait solver.\n+///\n+/// This is mostly identical to how `evaluate_all` works inside of the\n+/// solver, except that the requirements are slightly different.\n+///\n+/// Unlike `evaluate_all` it is possible to add new obligations later on\n+/// and we also have to track diagnostics information by using `Obligation`\n+/// instead of `Goal`.\n+///\n+/// It is also likely that we want to use slightly different datastructures\n+/// here as this will have to deal with far more root goals than `evaluate_all`.\n+pub struct FulfillmentCtxt<'tcx> {\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> FulfillmentCtxt<'tcx> {\n+    pub fn new() -> FulfillmentCtxt<'tcx> {\n+        FulfillmentCtxt { obligations: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n+    fn register_predicate_obligation(\n+        &mut self,\n+        _infcx: &InferCtxt<'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        self.obligations.push(obligation);\n+    }\n+\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = self.select_where_possible(infcx);\n+        if !errors.is_empty() {\n+            return errors;\n+        }\n+\n+        if self.obligations.is_empty() {\n+            Vec::new()\n+        } else {\n+            unimplemented!(\"ambiguous obligations\")\n+        }\n+    }\n+\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = Vec::new();\n+        for i in 0.. {\n+            if !infcx.tcx.recursion_limit().value_within_limit(i) {\n+                unimplemented!(\"overflow\")\n+            }\n+\n+            let mut has_changed = false;\n+            for o in mem::take(&mut self.obligations) {\n+                let mut cx = EvalCtxt::new(infcx.tcx);\n+                let (changed, certainty) = match cx.evaluate_goal(infcx, o.clone().into()) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => unimplemented!(\"error\"),\n+                };\n+\n+                has_changed |= changed;\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => self.obligations.push(o),\n+                }\n+            }\n+\n+            if !has_changed {\n+                break;\n+            }\n+        }\n+\n+        errors\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.clone()\n+    }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        unimplemented!(\"Should be moved out of `TraitEngine`\")\n+    }\n+}"}, {"sha": "436f4eea6625bcdf45b7b3e66bec6cba9d4bee80", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,55 @@\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::Ty;\n+use rustc_span::DUMMY_SP;\n+\n+use crate::solve::ExternalConstraints;\n+\n+use super::{Certainty, QueryResult, Response};\n+\n+/// Methods used inside of the canonical queries of the solver.\n+pub(super) trait InferCtxtExt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx>;\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx> {\n+        self.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::MiscVariable,\n+            span: DUMMY_SP,\n+        })\n+    }\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self)?;\n+\n+        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n+    }\n+}\n+\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n+}"}, {"sha": "7f5e3208f4e7c0fd03dba54521b106c640ac214b", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,309 @@\n+//! The new trait solver, currently still WIP.\n+//!\n+//! As a user of the trait system, you can use `TyCtxt::evaluate_goal` to\n+//! interact with this solver.\n+//!\n+//! For a high-level overview of how this solver works, check out the relevant\n+//! section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section. If you read this before then ask me\n+//! about it on zulip.\n+\n+// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n+// preserves universes and creates a unique var (in the highest universe) for each\n+// appearance of a region.\n+\n+// FIXME: `CanonicalVarValues` should be interned and `Copy`.\n+\n+// FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n+\n+use std::mem;\n+\n+use rustc_infer::infer::canonical::OriginalQueryValues;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n+use rustc_span::DUMMY_SP;\n+\n+use self::infcx_ext::InferCtxtExt;\n+\n+mod assembly;\n+mod cache;\n+mod fulfill;\n+mod infcx_ext;\n+mod overflow;\n+mod project_goals;\n+mod trait_goals;\n+\n+pub use fulfill::FulfillmentCtxt;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n+    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n+        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct ExternalConstraints<'tcx> {\n+    // FIXME: implement this.\n+    regions: (),\n+    opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+}\n+\n+type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n+pub trait TyCtxtExt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        let mut cx = EvalCtxt::new(self);\n+        cx.evaluate_canonical_goal(goal)\n+    }\n+}\n+\n+struct EvalCtxt<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    provisional_cache: cache::ProvisionalCache<'tcx>,\n+    overflow_data: overflow::OverflowData,\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n+        EvalCtxt {\n+            tcx,\n+            provisional_cache: cache::ProvisionalCache::empty(),\n+            overflow_data: overflow::OverflowData::new(tcx),\n+        }\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n+        Ok((\n+            true, // FIXME: check whether `var_values` are an identity substitution.\n+            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+        ))\n+    }\n+\n+    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        match self.try_push_stack(goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // We may have to repeatedly recompute the goal in case of coinductive cycles,\n+        // check out the `cache` module for more information.\n+        //\n+        // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n+        loop {\n+            let result = self.compute_goal(goal);\n+\n+            // FIXME: `Response` should be `Copy`\n+            if self.try_finalize_goal(goal, result.clone()) {\n+                return result;\n+            }\n+        }\n+    }\n+\n+    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        // WARNING: We're looking at a canonical value without instantiating it here.\n+        //\n+        // We have to be incredibly careful to not change the order of bound variables or\n+        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n+        // of `PredicateKind` this is the case and it is and faster than instantiating and\n+        // recanonicalizing.\n+        let Goal { param_env, predicate } = canonical_goal.value;\n+        if let Some(kind) = predicate.kind().no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n+                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                ),\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n+                    .compute_projection_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n+                    .compute_type_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n+                    .compute_region_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(_, _, _)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n+                | ty::PredicateKind::ConstEvaluatable(_)\n+                | ty::PredicateKind::ConstEquate(_, _)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+            }\n+        } else {\n+            let (infcx, goal, var_values) =\n+                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n+            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n+            infcx.make_canonical_response(var_values, certainty)\n+        }\n+    }\n+\n+    fn compute_type_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+\n+    fn compute_region_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn evaluate_all(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let mut new_goals = Vec::new();\n+        self.repeat_while_none(|this| {\n+            let mut has_changed = Err(Certainty::Yes);\n+            for goal in goals.drain(..) {\n+                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => return Some(Err(NoSolution)),\n+                };\n+\n+                if changed {\n+                    has_changed = Ok(());\n+                }\n+\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => {\n+                        new_goals.push(goal);\n+                        has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                    }\n+                }\n+            }\n+\n+            match has_changed {\n+                Ok(()) => {\n+                    mem::swap(&mut new_goals, &mut goals);\n+                    None\n+                }\n+                Err(certainty) => Some(Ok(certainty)),\n+            }\n+        })\n+    }\n+}\n+\n+fn fixme_instantiate_canonical_query_response<'tcx>(\n+    _: &InferCtxt<'tcx>,\n+    _: &OriginalQueryValues<'tcx>,\n+    _: CanonicalResponse<'tcx>,\n+) -> Certainty {\n+    unimplemented!()\n+}"}, {"sha": "8d73a83aec96e119639b011ab134ff94176f964c", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,80 @@\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Limit;\n+\n+use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+\n+/// When detecting a solver overflow, we return ambiguity. Overflow can be\n+/// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n+///\n+/// This is in issue in case of exponential blowup, e.g. if each goal on the stack\n+/// has multiple nested (overflowing) candidates. To deal with this, we reduce the limit\n+/// used by the solver when hitting the default limit for the first time.\n+///\n+/// FIXME: Get tests where always using the `default_limit` results in a hang and refer\n+/// to them here. We can also improve the overflow strategy if necessary.\n+pub(super) struct OverflowData {\n+    default_limit: Limit,\n+    current_limit: Limit,\n+    /// When proving an **AND** we have to repeatedly iterate over the yet unproven goals.\n+    ///\n+    /// Because of this each iteration also increases the depth in addition to the stack\n+    /// depth.\n+    additional_depth: usize,\n+}\n+\n+impl OverflowData {\n+    pub(super) fn new(tcx: TyCtxt<'_>) -> OverflowData {\n+        let default_limit = tcx.recursion_limit();\n+        OverflowData { default_limit, current_limit: default_limit, additional_depth: 0 }\n+    }\n+\n+    #[inline]\n+    pub(super) fn did_overflow(&self) -> bool {\n+        self.default_limit.0 != self.current_limit.0\n+    }\n+\n+    #[inline]\n+    pub(super) fn has_overflow(&self, depth: usize) -> bool {\n+        self.current_limit.value_within_limit(depth + self.additional_depth)\n+    }\n+\n+    /// Updating the current limit when hitting overflow.\n+    fn deal_with_overflow(&mut self) {\n+        // When first hitting overflow we reduce the overflow limit\n+        // for all future goals to prevent hangs if there's an exponental\n+        // blowup.\n+        self.current_limit.0 = self.default_limit.0 / 8;\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+        self.overflow_data.deal_with_overflow();\n+        fixme_response_overflow_no_constraints()\n+    }\n+\n+    /// A `while`-loop which tracks overflow.\n+    pub(super) fn repeat_while_none(\n+        &mut self,\n+        mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let start_depth = self.overflow_data.additional_depth;\n+        let depth = self.provisional_cache.current_depth();\n+        while !self.overflow_data.has_overflow(depth) {\n+            if let Some(result) = loop_body(self) {\n+                self.overflow_data.additional_depth = start_depth;\n+                return result;\n+            }\n+\n+            self.overflow_data.additional_depth += 1;\n+        }\n+        self.overflow_data.additional_depth = start_depth;\n+        self.overflow_data.deal_with_overflow();\n+        Ok(Certainty::Maybe(MaybeCause::Overflow))\n+    }\n+}\n+\n+fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "b50f42c4d9416091243668ff3ddb0e3bc87da922", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,244 @@\n+use crate::traits::{specialization_graph, translate_substs};\n+\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::specialization_graph::LeafDef;\n+use rustc_infer::traits::{ObligationCause, Reveal};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::ProjectionPredicate;\n+use rustc_middle::ty::TypeVisitable;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    Impl(DefId),\n+    ParamEnv(usize),\n+    Builtin,\n+}\n+\n+type Candidate<'tcx> = assembly::Candidate<'tcx, ProjectionPredicate<'tcx>>;\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_projection_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        self.merge_project_candidates(candidates)\n+    }\n+\n+    fn merge_project_candidates(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(candidates.pop().unwrap().result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.project_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(candidates.pop().unwrap().result)\n+    }\n+\n+    fn project_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::Builtin, _) => unimplemented!(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n+\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n+    }\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n+    }\n+\n+    fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.trait_def_id(tcx)\n+    }\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, ProjectionPredicate<'tcx>>,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let tcx = acx.cx.tcx;\n+        let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n+        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal_trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(trait_ref_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+\n+            let Some(assoc_def) = fetch_eligible_assoc_item_def(\n+                acx.infcx,\n+                goal.param_env,\n+                goal_trait_ref,\n+                goal.predicate.def_id(),\n+                impl_def_id\n+            ) else {\n+                return\n+            };\n+\n+            if !assoc_def.item.defaultness(tcx).has_value() {\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(assoc_def.item.def_id),\n+                    \"missing value for assoc item in impl\",\n+                );\n+            }\n+\n+            // Getting the right substitutions here is complex, e.g. given:\n+            // - a goal `<Vec<u32> as Trait<i32>>::Assoc<u64>`\n+            // - the applicable impl `impl<T> Trait<i32> for Vec<T>`\n+            // - and the impl which defines `Assoc` being `impl<T, U> Trait<U> for Vec<T>`\n+            //\n+            // We first rebase the goal substs onto the impl, going from `[Vec<u32>, i32, u64]`\n+            // to `[u32, u64]`.\n+            //\n+            // And then map these substs to the substs of the defining impl of `Assoc`, going\n+            // from `[u32, u64]` to `[u32, i32, u64]`.\n+            let impl_substs_with_gat = goal.predicate.projection_ty.substs.rebase_onto(\n+                tcx,\n+                goal_trait_ref.def_id,\n+                impl_trait_ref.substs,\n+            );\n+            let substs = translate_substs(\n+                acx.infcx,\n+                goal.param_env,\n+                impl_def_id,\n+                impl_substs_with_gat,\n+                assoc_def.defining_node,\n+            );\n+\n+            // Finally we construct the actual value of the associated type.\n+            let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n+            let ty = tcx.bound_type_of(assoc_def.item.def_id);\n+            let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n+                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n+                let kind =\n+                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n+                ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n+            } else {\n+                ty.map_bound(|ty| ty.into())\n+            };\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.term,  term.subst(tcx, substs))\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(rhs_certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+\n+            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+}\n+\n+/// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n+///\n+/// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n+/// diverge.\n+#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+fn fetch_eligible_assoc_item_def<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    goal_trait_ref: ty::TraitRef<'tcx>,\n+    trait_assoc_def_id: DefId,\n+    impl_def_id: DefId,\n+) -> Option<LeafDef> {\n+    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+        .map_err(|ErrorGuaranteed { .. }| ())\n+        .ok()?;\n+\n+    let eligible = if node_item.is_final() {\n+        // Non-specializable items are always projectable.\n+        true\n+    } else {\n+        // Only reveal a specializable default if we're past type-checking\n+        // and the obligation is monomorphic, otherwise passes such as\n+        // transmute checking and polymorphic MIR optimizations could\n+        // get a result which isn't correct for all monomorphizations.\n+        if param_env.reveal() == Reveal::All {\n+            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            !poly_trait_ref.still_further_specializable()\n+        } else {\n+            debug!(?node_item.item.def_id, \"not eligible due to default\");\n+            false\n+        }\n+    };\n+\n+    if eligible { Some(node_item) } else { None }\n+}"}, {"sha": "10b45a77dabb0976f04eb22a1c14b58d04918ba4", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -0,0 +1,180 @@\n+//! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n+\n+use std::iter;\n+\n+use super::assembly::{self, AssemblyCtxt};\n+use super::{CanonicalGoal, EvalCtxt, Goal, QueryResult};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::TraitPredicate;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// Some user-defined impl with the given `DefId`.\n+    Impl(DefId),\n+    /// The n-th caller bound in the `param_env` of our goal.\n+    ///\n+    /// This is pretty much always a bound from the `where`-clauses of the\n+    /// currently checked item.\n+    ParamEnv(usize),\n+    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (for syntax highlighting)\n+    /// trait Trait {\n+    ///     type Assoc: OtherTrait;\n+    /// }\n+    /// ```\n+    ///\n+    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n+    /// the bounds on `Trait::Assoc`.\n+    AliasBound(usize),\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n+    Builtin,\n+    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n+    /// at the constituent types of the `self_ty` to check whether the auto trait\n+    /// is implemented for those.\n+    AutoImpl,\n+}\n+\n+type Candidate<'tcx> = assembly::Candidate<'tcx, TraitPredicate<'tcx>>;\n+\n+impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n+    type CandidateSource = CandidateSource;\n+\n+    fn self_ty(self) -> Ty<'tcx> {\n+        self.self_ty()\n+    }\n+\n+    fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        self.with_self_ty(tcx, self_ty)\n+    }\n+\n+    fn trait_def_id(self, _: TyCtxt<'tcx>) -> DefId {\n+        self.def_id()\n+    }\n+\n+    fn consider_impl_candidate(\n+        acx: &mut AssemblyCtxt<'_, 'tcx, Self>,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let impl_trait_ref = acx.cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        acx.infcx.probe(|_| {\n+            let impl_substs = acx.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(acx.cx.tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = acx\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+\n+            let Ok(certainty) = acx.cx.evaluate_all(acx.infcx, nested_goals) else { return };\n+            acx.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_trait_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = AssemblyCtxt::assemble_and_evaluate_candidates(self, goal);\n+        self.merge_trait_candidates_discard_reservation_impls(candidates)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound(_), _)\n+            | (CandidateSource::Builtin, _)\n+            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // FIXME: reduce candidate to ambiguous\n+                // FIXME: replace `var_values` with identity, yeet external constraints.\n+                unimplemented!()\n+            }\n+        }\n+\n+        candidate\n+    }\n+}"}, {"sha": "948632ccc6c40a87082f62225f42bd1b09ee68ba", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -159,13 +159,12 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             orig_env,\n             orig_env,\n             &mut fresh_preds,\n-            false,\n         ) else {\n             return AutoTraitResult::NegativeImpl;\n         };\n \n         let (full_env, full_user_env) = self\n-            .evaluate_predicates(&infcx, trait_did, ty, new_env, user_env, &mut fresh_preds, true)\n+            .evaluate_predicates(&infcx, trait_did, ty, new_env, user_env, &mut fresh_preds)\n             .unwrap_or_else(|| {\n                 panic!(\"Failed to fully process: {:?} {:?} {:?}\", ty, trait_did, orig_env)\n             });\n@@ -247,7 +246,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         user_env: ty::ParamEnv<'tcx>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n-        only_projections: bool,\n     ) -> Option<(ty::ParamEnv<'tcx>, ty::ParamEnv<'tcx>)> {\n         let tcx = infcx.tcx;\n \n@@ -322,7 +320,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         fresh_preds,\n                         &mut predicates,\n                         &mut select,\n-                        only_projections,\n                     ) {\n                         return None;\n                     }\n@@ -600,7 +597,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n         selcx: &mut SelectionContext<'_, 'tcx>,\n-        only_projections: bool,\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n@@ -744,7 +740,6 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                                     fresh_preds,\n                                     predicates,\n                                     selcx,\n-                                    only_projections,\n                                 ) {\n                                     return false;\n                                 }"}, {"sha": "26757965c9583ee0b5981342d2e462bb9e8f8148", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -66,13 +66,13 @@ pub fn add_placeholder_note(err: &mut Diagnostic) {\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, returns `None`.\n #[instrument(skip(tcx, skip_leak_check), level = \"debug\")]\n-pub fn overlapping_impls<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+pub fn overlapping_impls(\n+    tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     skip_leak_check: SkipLeakCheck,\n     overlap_mode: OverlapMode,\n-) -> Option<OverlapResult<'tcx>> {\n+) -> Option<OverlapResult<'_>> {\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n@@ -283,7 +283,7 @@ fn implicit_negative<'cx, 'tcx>(\n \n /// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n /// where-clauses) If so, return true, they are disjoint and false otherwise.\n-fn negative_impl<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+fn negative_impl(tcx: TyCtxt<'_>, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:"}, {"sha": "f8efe9bfa9f827b3d98c2544ebb544d73849e339", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -138,10 +138,10 @@ pub fn is_const_evaluatable<'tcx>(\n                 } else if uv.has_non_region_param() {\n                     NotConstEvaluatable::MentionsParam\n                 } else {\n-                    let guar = infcx.tcx.sess.delay_span_bug(\n-                        span,\n-                        format!(\"Missing value for constant, but no error reported?\"),\n-                    );\n+                    let guar = infcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(span, \"Missing value for constant, but no error reported?\");\n                     NotConstEvaluatable::Error(guar)\n                 };\n "}, {"sha": "27c207528c73537c9c8a5a01e7fa595549dc12b4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -14,21 +14,27 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"CollectAllMismatches\"\n     }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n     fn intercrate(&self) -> bool {\n         false\n     }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n+\n     fn a_is_expected(&self) -> bool {\n         true\n-    } // irrelevant\n+    }\n+\n     fn mark_ambiguous(&mut self) {\n         bug!()\n     }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n@@ -38,22 +44,28 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n+\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         _b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         Ok(a)\n     }\n+\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n-            return Ok(a);\n-        }\n-        relate::super_relate_tys(self, a, b).or_else(|e| {\n-            self.errors.push(e);\n-            Ok(a)\n+        self.infcx.probe(|_| {\n+            if a.is_ty_infer() || b.is_ty_infer() {\n+                Ok(a)\n+            } else {\n+                self.infcx.super_combine_tys(self, a, b).or_else(|e| {\n+                    self.errors.push(e);\n+                    Ok(a)\n+                })\n+            }\n         })\n     }\n+\n     fn consts(\n         &mut self,\n         a: ty::Const<'tcx>,\n@@ -64,6 +76,7 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n         }\n         relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n     }\n+\n     fn binders<T: Relate<'tcx>>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,"}, {"sha": "8f317beaa77dd15c32a76fb0656ca732d8d1f3ae", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -226,7 +226,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             let arg_length = arguments.len();\n             let distinct = matches!(other, &[ArgKind::Tuple(..)]);\n             match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                (1, Some(ArgKind::Tuple(_, fields))) => {\n                     format!(\"a single {}-tuple as argument\", fields.len())\n                 }\n                 _ => format!(\n@@ -1574,7 +1574,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     &error.obligation.cause,\n                     expected_found.expected,\n                     expected_found.found,\n-                    err.clone(),\n+                    *err,\n                 )\n                 .emit();\n             }\n@@ -1583,7 +1583,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     &error.obligation.cause,\n                     expected_found.expected,\n                     expected_found.found,\n-                    err.clone(),\n+                    *err,\n                 );\n                 let code = error.obligation.cause.code().peel_derives().peel_match_impls();\n                 if let ObligationCauseCode::BindingObligation(..)\n@@ -1735,8 +1735,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 values.map(|(_, is_normalized_ty_expected, normalized_ty, expected_ty)| {\n                     infer::ValuePairs::Terms(ExpectedFound::new(\n                         is_normalized_ty_expected,\n-                        normalized_ty.into(),\n-                        expected_ty.into(),\n+                        normalized_ty,\n+                        expected_ty,\n                     ))\n                 }),\n                 err,\n@@ -2332,9 +2332,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 // get rid of :: between Trait and <type>\n                                 // must be '::' between them, otherwise the parser won't accept the code\n                                 suggestions.push((between_span, \"\".to_string(),));\n-                                suggestions.push((generic_arg.span_ext.shrink_to_hi(), format!(\">\")));\n+                                suggestions.push((generic_arg.span_ext.shrink_to_hi(), \">\".to_string()));\n                             } else {\n-                                suggestions.push((trait_path_segment.ident.span.shrink_to_hi(), format!(\">\")));\n+                                suggestions.push((trait_path_segment.ident.span.shrink_to_hi(), \">\".to_string()));\n                             }\n                             err.multipart_suggestion(\n                                 message,"}, {"sha": "9656bfbf4ecc161fb6e6dbd31acb750bb8daee4e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 48, "deletions": 56, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -335,7 +335,7 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n-    fn function_argument_obligation(\n+    fn note_function_argument_obligation(\n         &self,\n         arg_hir_id: HirId,\n         err: &mut Diagnostic,\n@@ -1789,7 +1789,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         self.note_conflicting_closure_bounds(cause, &mut err);\n \n         if let Some(found_node) = found_node {\n-            hint_missing_borrow(span, found_span, found, expected, found_node, &mut err);\n+            hint_missing_borrow(span, found, expected, found_node, &mut err);\n         }\n \n         err\n@@ -2344,28 +2344,33 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n             GeneratorInteriorOrUpvar::Upvar(upvar_span) => {\n-                // `Some(ref_ty)` if `target_ty` is `&T` and `T` fails to impl `Sync`\n-                let refers_to_non_sync = match target_ty.kind() {\n-                    ty::Ref(_, ref_ty, _) => match self.evaluate_obligation(&obligation) {\n-                        Ok(eval) if !eval.may_apply() => Some(ref_ty),\n+                // `Some((ref_ty, is_mut))` if `target_ty` is `&T` or `&mut T` and fails to impl `Send`\n+                let non_send = match target_ty.kind() {\n+                    ty::Ref(_, ref_ty, mutability) => match self.evaluate_obligation(&obligation) {\n+                        Ok(eval) if !eval.may_apply() => Some((ref_ty, mutability.is_mut())),\n                         _ => None,\n                     },\n                     _ => None,\n                 };\n \n-                let (span_label, span_note) = match refers_to_non_sync {\n-                    // if `target_ty` is `&T` and `T` fails to impl `Sync`,\n-                    // include suggestions to make `T: Sync` so that `&T: Send`\n-                    Some(ref_ty) => (\n-                        format!(\n-                            \"has type `{}` which {}, because `{}` is not `Sync`\",\n-                            target_ty, trait_explanation, ref_ty\n-                        ),\n-                        format!(\n-                            \"captured value {} because `&` references cannot be sent unless their referent is `Sync`\",\n-                            trait_explanation\n-                        ),\n-                    ),\n+                let (span_label, span_note) = match non_send {\n+                    // if `target_ty` is `&T` or `&mut T` and fails to impl `Send`,\n+                    // include suggestions to make `T: Sync` so that `&T: Send`,\n+                    // or to make `T: Send` so that `&mut T: Send`\n+                    Some((ref_ty, is_mut)) => {\n+                        let ref_ty_trait = if is_mut { \"Send\" } else { \"Sync\" };\n+                        let ref_kind = if is_mut { \"&mut\" } else { \"&\" };\n+                        (\n+                            format!(\n+                                \"has type `{}` which {}, because `{}` is not `{}`\",\n+                                target_ty, trait_explanation, ref_ty, ref_ty_trait\n+                            ),\n+                            format!(\n+                                \"captured value {} because `{}` references cannot be sent unless their referent is `{}`\",\n+                                trait_explanation, ref_kind, ref_ty_trait\n+                            ),\n+                        )\n+                    }\n                     None => (\n                         format!(\"has type `{}` which {}\", target_ty, trait_explanation),\n                         format!(\"captured value {}\", trait_explanation),\n@@ -2740,7 +2745,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             }\n                             ty::Closure(def_id, _) => err.span_note(\n                                 self.tcx.def_span(def_id),\n-                                &format!(\"required because it's used within this closure\"),\n+                                \"required because it's used within this closure\",\n                             ),\n                             _ => err.note(&msg),\n                         };\n@@ -2904,7 +2909,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ref parent_code,\n                 ..\n             } => {\n-                self.function_argument_obligation(\n+                self.note_function_argument_obligation(\n                     arg_hir_id,\n                     err,\n                     parent_code,\n@@ -3136,23 +3141,20 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n     }\n-    fn function_argument_obligation(\n+    fn note_function_argument_obligation(\n         &self,\n         arg_hir_id: HirId,\n         err: &mut Diagnostic,\n         parent_code: &ObligationCauseCode<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        predicate: ty::Predicate<'tcx>,\n+        failed_pred: ty::Predicate<'tcx>,\n         call_hir_id: HirId,\n     ) {\n         let tcx = self.tcx;\n         let hir = tcx.hir();\n-        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n-            let parent_id = hir.get_parent_item(arg_hir_id);\n-            let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n-                Some(t) if t.hir_owner == parent_id => t,\n-                _ => self.tcx.typeck(parent_id.def_id),\n-            };\n+        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id)\n+            && let Some(typeck_results) = &self.typeck_results\n+        {\n             if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n                 let expr = expr.peel_blocks();\n                 let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n@@ -3177,37 +3179,29 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let mut type_diffs = vec![];\n \n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n-                && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n-                && let Some(pred) = predicates.predicates.get(*idx)\n+                && let Some(node_substs) = typeck_results.node_substs_opt(call_hir_id)\n+                && let where_clauses = self.tcx.predicates_of(def_id).instantiate(self.tcx, node_substs)\n+                && let Some(where_pred) = where_clauses.predicates.get(*idx)\n             {\n-                if let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                    _ => Err(()),\n-                })\n-                    && let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n-                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                        _ => Err(()),\n-                    })\n+                if let Some(where_pred) = where_pred.to_opt_poly_trait_pred()\n+                    && let Some(failed_pred) = failed_pred.to_opt_poly_trait_pred()\n                 {\n                     let mut c = CollectAllMismatches {\n                         infcx: self.infcx,\n                         param_env,\n                         errors: vec![],\n                     };\n-                    if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n+                    if let Ok(_) = c.relate(where_pred, failed_pred) {\n                         type_diffs = c.errors;\n                     }\n-                } else if let ty::PredicateKind::Clause(\n-                    ty::Clause::Projection(proj)\n-                ) = pred.kind().skip_binder()\n-                    && let ty::PredicateKind::Clause(\n-                        ty::Clause::Projection(projection)\n-                    ) = predicate.kind().skip_binder()\n+                } else if let Some(where_pred) = where_pred.to_opt_poly_projection_pred()\n+                    && let Some(failed_pred) = failed_pred.to_opt_poly_projection_pred()\n+                    && let Some(found) = failed_pred.skip_binder().term.ty()\n                 {\n                     type_diffs = vec![\n                         Sorts(ty::error::ExpectedFound {\n-                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, proj.projection_ty)),\n-                            found: projection.term.ty().unwrap(),\n+                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, where_pred.skip_binder().projection_ty)),\n+                            found,\n                         }),\n                     ];\n                 }\n@@ -3222,9 +3216,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // If the expression we're calling on is a binding, we want to point at the\n                 // `let` when talking about the type. Otherwise we'll point at every part\n                 // of the method chain with the type.\n-                self.point_at_chain(binding_expr, typeck_results, type_diffs, param_env, err);\n+                self.point_at_chain(binding_expr, &typeck_results, type_diffs, param_env, err);\n             } else {\n-                self.point_at_chain(expr, typeck_results, type_diffs, param_env, err);\n+                self.point_at_chain(expr, &typeck_results, type_diffs, param_env, err);\n             }\n         }\n         let call_node = hir.find(call_hir_id);\n@@ -3386,7 +3380,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n             err.span_note(\n                 multi_span,\n-                format!(\"the method call chain might not have had the expected associated types\"),\n+                \"the method call chain might not have had the expected associated types\",\n             );\n         }\n     }\n@@ -3455,7 +3449,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n /// Add a hint to add a missing borrow or remove an unnecessary one.\n fn hint_missing_borrow<'tcx>(\n     span: Span,\n-    found_span: Span,\n     found: Ty<'tcx>,\n     expected: Ty<'tcx>,\n     found_node: Node<'_>,\n@@ -3474,13 +3467,12 @@ fn hint_missing_borrow<'tcx>(\n         }\n     };\n \n-    let fn_decl = found_node\n-        .fn_decl()\n-        .unwrap_or_else(|| span_bug!(found_span, \"found node must be a function\"));\n+    // This could be a variant constructor, for example.\n+    let Some(fn_decl) = found_node.fn_decl() else { return; };\n \n     let arg_spans = fn_decl.inputs.iter().map(|ty| ty.span);\n \n-    fn get_deref_type_and_refs<'tcx>(mut ty: Ty<'tcx>) -> (Ty<'tcx>, usize) {\n+    fn get_deref_type_and_refs(mut ty: Ty<'_>) -> (Ty<'_>, usize) {\n         let mut refs = 0;\n \n         while let ty::Ref(_, new_ty, _) = ty.kind() {"}, {"sha": "c30531fa906642c090bd7abb9e2389a64773d38e", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -484,10 +484,7 @@ fn subst_and_check_impossible_predicates<'tcx>(\n ///\n /// This only considers predicates that reference the impl's generics, and not\n /// those that reference the method's generics.\n-fn is_impossible_method<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (impl_def_id, trait_item_def_id): (DefId, DefId),\n-) -> bool {\n+fn is_impossible_method(tcx: TyCtxt<'_>, (impl_def_id, trait_item_def_id): (DefId, DefId)) -> bool {\n     struct ReferencesOnlyParentGenerics<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         generics: &'tcx ty::Generics,"}, {"sha": "f2c5f730b31b938ed858a46156458f02d3717496", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n     /// argument types are well-formed. This may imply certain relationships\n     /// between generic parameters. For example:\n     /// ```\n-    /// fn foo<'a,T>(x: &'a T) {}\n+    /// fn foo<T>(x: &T) {}\n     /// ```\n     /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n     /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`."}, {"sha": "5276da2e49c750743c4b9d26a2909eb843926de8", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -25,7 +25,6 @@ use rustc_data_structures::sso::SsoHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n@@ -1553,7 +1552,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.def_id)\n+                    specialization_graph::assoc_def(selcx.tcx(), impl_data.impl_def_id, obligation.predicate.def_id)\n                         .map_err(|ErrorGuaranteed { .. }| ())?;\n \n                 if node_item.is_final() {\n@@ -2113,7 +2112,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let Ok(assoc_ty) = assoc_def(selcx, impl_def_id, assoc_item_id) else {\n+    let Ok(assoc_ty) = specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations: nested };\n     };\n \n@@ -2210,7 +2209,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let mut obligations = data.nested;\n \n     let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-    let Ok(leaf_def) = assoc_def(selcx, data.impl_def_id, trait_fn_def_id) else {\n+    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations };\n     };\n     if !leaf_def.item.defaultness(tcx).has_value() {\n@@ -2347,58 +2346,6 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n     }\n }\n \n-/// Locate the definition of an associated type in the specialization hierarchy,\n-/// starting from the given impl.\n-///\n-/// Based on the \"projection mode\", this lookup may in fact only examine the\n-/// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_def(\n-    selcx: &SelectionContext<'_, '_>,\n-    impl_def_id: DefId,\n-    assoc_def_id: DefId,\n-) -> Result<specialization_graph::LeafDef, ErrorGuaranteed> {\n-    let tcx = selcx.tcx();\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraitDef::ancestors()),\n-    // so, in order to avoid unnecessary infinite recursion, we manually look\n-    // for the associated item at the given impl.\n-    // If there is no such item in that impl, this function will fail with a\n-    // cycle error if the specialization graph is currently being built.\n-    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n-        let item = tcx.associated_item(impl_item_id);\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        return Ok(specialization_graph::LeafDef {\n-            item: *item,\n-            defining_node: impl_node,\n-            finalizing_node: if item.defaultness(tcx).is_default() {\n-                None\n-            } else {\n-                Some(impl_node)\n-            },\n-        });\n-    }\n-\n-    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n-        Ok(assoc_item)\n-    } else {\n-        // This is saying that neither the trait nor\n-        // the impl contain a definition for this\n-        // associated type.  Normally this situation\n-        // could only arise through a compiler bug --\n-        // if the user wrote a bad item name, it\n-        // should have failed in astconv.\n-        bug!(\n-            \"No associated type `{}` for {}\",\n-            tcx.item_name(assoc_def_id),\n-            tcx.def_path_str(impl_def_id)\n-        )\n-    }\n-}\n-\n pub(crate) trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,"}, {"sha": "81e8f9e914c2373ceae19be1daf898dc54e1a2d8", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1171,19 +1171,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: Iterator<Item = ty::Predicate<'tcx>>,\n     {\n-        cycle.all(|predicate| self.coinductive_predicate(predicate))\n-    }\n-\n-    fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n-                self.tcx().trait_is_coinductive(data.def_id())\n-            }\n-            ty::PredicateKind::WellFormed(_) => true,\n-            _ => false,\n-        };\n-        debug!(?predicate, ?result, \"coinductive_predicate\");\n-        result\n+        cycle.all(|predicate| predicate.is_coinductive(self.tcx()))\n     }\n \n     /// Further evaluates `candidate` to decide whether all type parameters match and whether nested"}, {"sha": "02b0667774028a37224a926b1d74bb9a92f52b6f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -1,6 +1,7 @@\n use super::OverlapError;\n \n use crate::traits;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n@@ -379,3 +380,51 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n }\n+\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+pub(crate) fn assoc_def(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: DefId,\n+    assoc_def_id: DefId,\n+) -> Result<LeafDef, ErrorGuaranteed> {\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraitDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n+        let &item = tcx.associated_item(impl_item_id);\n+        let impl_node = Node::Impl(impl_def_id);\n+        return Ok(LeafDef {\n+            item,\n+            defining_node: impl_node,\n+            finalizing_node: if item.defaultness(tcx).is_default() {\n+                None\n+            } else {\n+                Some(impl_node)\n+            },\n+        });\n+    }\n+\n+    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n+        Ok(assoc_item)\n+    } else {\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\n+            \"No associated type `{}` for {}\",\n+            tcx.item_name(assoc_def_id),\n+            tcx.def_path_str(impl_def_id)\n+        )\n+    }\n+}"}, {"sha": "5ec9c2a24cd448db3534fa5f3a8798cba24a1c64", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -191,7 +191,7 @@ fn dump_vtable_entries<'tcx>(\n     });\n }\n \n-fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n+fn own_existential_vtable_entries(tcx: TyCtxt<'_>, trait_def_id: DefId) -> &[DefId] {\n     let trait_methods = tcx\n         .associated_items(trait_def_id)\n         .in_definition_order()"}, {"sha": "f288eb112582dfeed77719c0ea805d3c2376c17f", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -719,7 +719,7 @@ impl<'tcx> chalk_ir::UnificationDatabase<RustInterner<'tcx>> for RustIrDatabase<\n /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n /// the type parameter index. For regions, we use the `BoundRegionKind::BrNamed`\n /// variant (which has a `DefId`).\n-fn bound_vars_for_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+fn bound_vars_for_item(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n     InternalSubsts::for_item(tcx, def_id, |param, substs| match param.kind {\n         ty::GenericParamDefKind::Type { .. } => tcx\n             .mk_ty(ty::Bound("}, {"sha": "6e6bc62a040d11df006d5d30727948c9253e9c19", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -54,7 +54,7 @@ fn try_normalize_after_erasing_regions<'tcx, T: TypeFoldable<'tcx> + PartialEq +\n     }\n }\n \n-fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {\n+fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n     match p.kind().skip_binder() {\n         ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..)) => false,"}, {"sha": "78fcceb5f2cb512a3d7ec17e201577a988ab0e9f", "filename": "compiler/rustc_transmute/src/layout/nfa.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c01e9f7f56694db0179673fca221358d3524903/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Fnfa.rs?ref=9c01e9f7f56694db0179673fca221358d3524903", "patch": "@@ -123,7 +123,7 @@ where\n             let fix_state = |state| if state == other.start { self.accepting } else { state };\n             let entry = transitions.entry(fix_state(source)).or_default();\n             for (edge, destinations) in transition {\n-                let entry = entry.entry(edge.clone()).or_default();\n+                let entry = entry.entry(edge).or_default();\n                 for destination in destinations {\n                     entry.insert(fix_state(destination));\n                 }\n@@ -147,7 +147,7 @@ where\n             }\n             let entry = transitions.entry(source).or_default();\n             for (edge, destinations) in transition {\n-                let entry = entry.entry(edge.clone()).or_default();\n+                let entry = entry.entry(*edge).or_default();\n                 for &(mut destination) in destinations {\n                     // if dest is accepting state of `other`, replace with accepting state of `self`\n                     if destination == other.accepting {"}]}