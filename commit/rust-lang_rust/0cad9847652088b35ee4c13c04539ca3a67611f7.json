{"sha": "0cad9847652088b35ee4c13c04539ca3a67611f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYWQ5ODQ3NjUyMDg4YjM1ZWU0YzEzYzA0NTM5Y2EzYTY3NjExZjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T21:48:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Migrate Rtio objects to true trait objects\n\nThis moves as many as I could over to ~Trait instead of ~Typedef. The only\nremaining one is the IoFactoryObject which should be coming soon...", "tree": {"sha": "2d0150f46613a7ca4ac18391008f713b8e4f4e3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d0150f46613a7ca4ac18391008f713b8e4f4e3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cad9847652088b35ee4c13c04539ca3a67611f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cad9847652088b35ee4c13c04539ca3a67611f7", "html_url": "https://github.com/rust-lang/rust/commit/0cad9847652088b35ee4c13c04539ca3a67611f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cad9847652088b35ee4c13c04539ca3a67611f7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35756fbcf6572d588929fde64fb4027f47e9d0af", "url": "https://api.github.com/repos/rust-lang/rust/commits/35756fbcf6572d588929fde64fb4027f47e9d0af", "html_url": "https://github.com/rust-lang/rust/commit/35756fbcf6572d588929fde64fb4027f47e9d0af"}], "stats": {"total": 191, "additions": 92, "deletions": 99}, "files": [{"sha": "946ecbea6f778405afef271b4f2aa795d02038c8", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -13,19 +13,16 @@ use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer, Listener, Acceptor};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioSocket,\n-               RtioTcpListener, RtioTcpListenerObject,\n-               RtioTcpAcceptor, RtioTcpAcceptorObject,\n-               RtioTcpStream, RtioTcpStreamObject};\n+use rt::rtio::{IoFactory, IoFactoryObject, RtioTcpListenerObject,\n+               RtioSocket, RtioTcpListener, RtioTcpAcceptor, RtioTcpStream};\n use rt::local::Local;\n \n pub struct TcpStream {\n-    priv obj: ~RtioTcpStreamObject\n+    priv obj: ~RtioTcpStream\n }\n \n impl TcpStream {\n-    fn new(s: ~RtioTcpStreamObject) -> TcpStream {\n+    fn new(s: ~RtioTcpStream) -> TcpStream {\n         TcpStream { obj: s }\n     }\n \n@@ -142,7 +139,7 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n }\n \n pub struct TcpAcceptor {\n-    priv obj: ~RtioTcpAcceptorObject\n+    priv obj: ~RtioTcpAcceptor\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {"}, {"sha": "ed01dc9dcdaa5bcd875e83ec7e8433d5c4f51012", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -13,11 +13,11 @@ use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n+use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, IoFactoryObject};\n use rt::local::Local;\n \n pub struct UdpSocket {\n-    priv obj: ~RtioUdpSocketObject\n+    priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {"}, {"sha": "1394cdb04a87c8546edef3db1fb9a76e90c2dceb", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -25,9 +25,8 @@ instances as clients.\n use prelude::*;\n \n use super::super::support::PathLike;\n-use rt::rtio::{IoFactory, IoFactoryObject, RtioUnixListenerObject};\n-use rt::rtio::{RtioUnixAcceptorObject, RtioPipeObject, RtioUnixListener};\n-use rt::rtio::RtioUnixAcceptor;\n+use rt::rtio::{IoFactory, IoFactoryObject, RtioUnixListener};\n+use rt::rtio::{RtioUnixAcceptor, RtioPipe, RtioUnixListenerObject};\n use rt::io::pipe::PipeStream;\n use rt::io::{io_error, Listener, Acceptor, Reader, Writer};\n use rt::local::Local;\n@@ -38,7 +37,7 @@ pub struct UnixStream {\n }\n \n impl UnixStream {\n-    fn new(obj: ~RtioPipeObject) -> UnixStream {\n+    fn new(obj: ~RtioPipe) -> UnixStream {\n         UnixStream { obj: PipeStream::new_bound(obj) }\n     }\n \n@@ -141,7 +140,7 @@ impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n }\n \n pub struct UnixAcceptor {\n-    priv obj: ~RtioUnixAcceptorObject,\n+    priv obj: ~RtioUnixAcceptor,\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {"}, {"sha": "c15fbc79da9f6d85618d469200afa3eea22f794a", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -16,14 +16,14 @@\n use prelude::*;\n use super::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioPipe, RtioPipeObject};\n+use rt::rtio::RtioPipe;\n \n pub struct PipeStream {\n-    priv obj: ~RtioPipeObject\n+    priv obj: ~RtioPipe,\n }\n \n impl PipeStream {\n-    pub fn new_bound(inner: ~RtioPipeObject) -> PipeStream {\n+    pub fn new_bound(inner: ~RtioPipe) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n }"}, {"sha": "c13b275ae52bf8dc4ef254460428534208c8bf19", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -16,7 +16,7 @@ use libc;\n use rt::io;\n use rt::io::io_error;\n use rt::local::Local;\n-use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n+use rt::rtio::{RtioProcess, IoFactoryObject, IoFactory};\n \n // windows values don't matter as long as they're at least one of unix's\n // TERM/KILL/INT signals\n@@ -26,7 +26,7 @@ use rt::rtio::{RtioProcess, RtioProcessObject, IoFactoryObject, IoFactory};\n #[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n \n pub struct Process {\n-    priv handle: ~RtioProcessObject,\n+    priv handle: ~RtioProcess,\n     io: ~[Option<io::PipeStream>],\n }\n "}, {"sha": "77ac87830e2537955337efa3fab517e1ae20a582", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -13,7 +13,7 @@ use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::local::Local;\n-use rt::rtio::{IoFactoryObject, IoFactory, RtioTTYObject, RtioTTY};\n+use rt::rtio::{IoFactoryObject, IoFactory, RtioTTY};\n use super::{Reader, Writer, io_error};\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n@@ -87,7 +87,7 @@ pub fn println_args(fmt: &fmt::Arguments) {\n \n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n-    priv inner: ~RtioTTYObject\n+    priv inner: ~RtioTTY\n }\n \n impl StdReader {\n@@ -129,7 +129,7 @@ impl Reader for StdReader {\n \n /// Representation of a writer to a standard output stream\n pub struct StdWriter {\n-    priv inner: ~RtioTTYObject\n+    priv inner: ~RtioTTY\n }\n \n impl StdWriter {"}, {"sha": "7d13e034dc1beb86415f8e6f5dace92eecd43e88", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -11,12 +11,11 @@\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::io::{io_error};\n-use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioTimer, RtioTimerObject};\n+use rt::rtio::{IoFactory, IoFactoryObject, RtioTimer};\n use rt::local::Local;\n \n pub struct Timer {\n-    priv obj: ~RtioTimerObject\n+    priv obj: ~RtioTimer\n }\n \n /// Sleep the current task for `msecs` milliseconds."}, {"sha": "66d7a6bf48823b3f80df0610f67a0a4290043558", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -279,7 +279,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n-        let loop_ = ~UvEventLoop::new();\n+        let loop_ = ~UvEventLoop::new() as ~rtio::EventLoop;\n         let mut sched = ~Scheduler::new(loop_,\n                                         work_queue.clone(),\n                                         work_queues.clone(),\n@@ -303,7 +303,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n         // set.\n         let work_queue = WorkQueue::new();\n \n-        let main_loop = ~UvEventLoop::new();\n+        let main_loop = ~UvEventLoop::new() as ~rtio::EventLoop;\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n                                                      work_queue,\n                                                      work_queues.clone(),"}, {"sha": "ef695130e22ca3952575001bea859a828d98ba45", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -23,31 +23,18 @@ use super::io::support::PathLike;\n use super::io::{SeekStyle};\n use super::io::{FileMode, FileAccess, FileStat};\n \n-// XXX: ~object doesn't work currently so these are some placeholder\n-// types to use instead\n-pub type EventLoopObject = uvio::UvEventLoop;\n-pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n-pub type IoFactoryObject = uvio::UvIoFactory;\n-pub type RtioTcpStreamObject = uvio::UvTcpStream;\n-pub type RtioTcpAcceptorObject = uvio::UvTcpAcceptor;\n+// FIXME(#9893) cannot call by-value self method on a trait object\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n-pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n-pub type RtioTimerObject = uvio::UvTimer;\n-pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n-pub type RtioPipeObject = uvio::UvPipeStream;\n-pub type RtioProcessObject = uvio::UvProcess;\n pub type RtioUnixListenerObject = uvio::UvUnixListener;\n-pub type RtioUnixAcceptorObject = uvio::UvUnixAcceptor;\n-pub type RtioTTYObject = uvio::UvTTY;\n \n pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n     fn callback_ms(&mut self, ms: u64, ~fn());\n-    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallbackObject;\n+    fn remote_callback(&mut self, ~fn()) -> ~RemoteCallback;\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n }\n \n pub trait RemoteCallback {\n@@ -73,10 +60,10 @@ pub struct FileOpenConfig {\n }\n \n pub trait IoFactory {\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n-    fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n     fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n@@ -89,22 +76,22 @@ pub trait IoFactory {\n     fn fs_readdir<P: PathLike>(&mut self, path: &P, flags: c_int) ->\n         Result<~[Path], IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<~RtioPipeObject>]), IoError>;\n+            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n \n     fn unix_bind<P: PathLike>(&mut self, path: &P) ->\n         Result<~RtioUnixListenerObject, IoError>;\n     fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n-        Result<~RtioPipeObject, IoError>;\n+        Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n-            -> Result<~RtioTTYObject, IoError>;\n+            -> Result<~RtioTTY, IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n-    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError>;\n+    fn listen(self) -> Result<~RtioTcpAcceptor, IoError>;\n }\n \n pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn accept(&mut self) -> Result<~RtioTcpStream, IoError>;\n     fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n@@ -166,11 +153,11 @@ pub trait RtioPipe {\n }\n \n pub trait RtioUnixListener {\n-    fn listen(self) -> Result<~RtioUnixAcceptorObject, IoError>;\n+    fn listen(self) -> Result<~RtioUnixAcceptor, IoError>;\n }\n \n pub trait RtioUnixAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipeObject, IoError>;\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError>;\n     fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n@@ -182,3 +169,10 @@ pub trait RtioTTY {\n     fn reset_mode(&mut self);\n     fn get_winsize(&mut self) -> Result<(int, int), IoError>;\n }\n+\n+pub trait PausibleIdleCallback {\n+    fn start(&mut self, f: ~fn());\n+    fn pause(&mut self);\n+    fn resume(&mut self);\n+    fn close(&mut self);\n+}"}, {"sha": "464e2b2c4c254d3f66afb10b1024522413af99bd", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -16,7 +16,7 @@ use unstable::raw;\n use super::sleeper_list::SleeperList;\n use super::work_queue::WorkQueue;\n use super::stack::{StackPool};\n-use super::rtio::{EventLoop, EventLoopObject, RemoteCallbackObject};\n+use super::rtio::EventLoop;\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n use super::message_queue::MessageQueue;\n@@ -63,7 +63,7 @@ pub struct Scheduler {\n     no_sleep: bool,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n-    event_loop: ~EventLoopObject,\n+    event_loop: ~EventLoop,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n     priv sched_task: Option<~Task>,\n@@ -107,7 +107,7 @@ impl Scheduler {\n \n     // * Initialization Functions\n \n-    pub fn new(event_loop: ~EventLoopObject,\n+    pub fn new(event_loop: ~EventLoop,\n                work_queue: WorkQueue<~Task>,\n                work_queues: ~[WorkQueue<~Task>],\n                sleeper_list: SleeperList)\n@@ -119,7 +119,7 @@ impl Scheduler {\n \n     }\n \n-    pub fn new_special(event_loop: ~EventLoopObject,\n+    pub fn new_special(event_loop: ~EventLoop,\n                        work_queue: WorkQueue<~Task>,\n                        work_queues: ~[WorkQueue<~Task>],\n                        sleeper_list: SleeperList,\n@@ -227,7 +227,7 @@ impl Scheduler {\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoopObject = &mut self_sched.event_loop;\n+            let event_loop: *mut ~EventLoop = &mut self_sched.event_loop;\n \n             // Our scheduler must be in the task before the event loop\n             // is started.\n@@ -793,7 +793,7 @@ pub enum SchedMessage {\n }\n \n pub struct SchedHandle {\n-    priv remote: ~RemoteCallbackObject,\n+    priv remote: ~RemoteCallback,\n     priv queue: MessageQueue<SchedMessage>,\n     sched_id: uint\n }"}, {"sha": "66d3f3de6ec23a46ae142971ecfaee84270693da", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -22,6 +22,7 @@ use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n use path::GenericPath;\n use rt::sched::Scheduler;\n+use rt::rtio::EventLoop;\n use unstable::{run_in_bare_thread};\n use rt::thread::Thread;\n use rt::task::Task;\n@@ -36,7 +37,7 @@ pub fn new_test_uv_sched() -> Scheduler {\n     let queue = WorkQueue::new();\n     let queues = ~[queue.clone()];\n \n-    let mut sched = Scheduler::new(~UvEventLoop::new(),\n+    let mut sched = Scheduler::new(~UvEventLoop::new() as ~EventLoop,\n                                    queue,\n                                    queues,\n                                    SleeperList::new());\n@@ -195,7 +196,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         for i in range(0u, nthreads) {\n-            let loop_ = ~UvEventLoop::new();\n+            let loop_ = ~UvEventLoop::new() as ~EventLoop;\n             let mut sched = ~Scheduler::new(loop_,\n                                             work_queues[i].clone(),\n                                             work_queues.clone(),"}, {"sha": "00572d66573d290a8c4c91f71e8e07f0f38b482f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -215,11 +215,11 @@ impl EventLoop for UvEventLoop {\n \n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback {\n         let idle_watcher = IdleWatcher::new(self.uvio.uv_loop());\n-        return ~UvPausibleIdleCallback {\n+        ~UvPausibleIdleCallback {\n             watcher: idle_watcher,\n             idle_flag: false,\n             closed: false\n-        };\n+        } as ~PausibleIdleCallback\n     }\n \n     fn callback_ms(&mut self, ms: u64, f: ~fn()) {\n@@ -231,12 +231,12 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n-    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallbackObject {\n-        ~UvRemoteCallback::new(self.uvio.uv_loop(), f)\n+    fn remote_callback(&mut self, f: ~fn()) -> ~RemoteCallback{\n+        ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n-        Some(&mut self.uvio)\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n+        Some(&mut self.uvio as &mut IoFactory)\n     }\n }\n \n@@ -246,30 +246,30 @@ pub struct UvPausibleIdleCallback {\n     priv closed: bool\n }\n \n-impl UvPausibleIdleCallback {\n+impl RtioPausibleIdleCallback for UvPausibleIdleCallback {\n     #[inline]\n-    pub fn start(&mut self, f: ~fn()) {\n+    fn start(&mut self, f: ~fn()) {\n         do self.watcher.start |_idle_watcher, _status| {\n             f();\n         };\n         self.idle_flag = true;\n     }\n     #[inline]\n-    pub fn pause(&mut self) {\n+    fn pause(&mut self) {\n         if self.idle_flag == true {\n             self.watcher.stop();\n             self.idle_flag = false;\n         }\n     }\n     #[inline]\n-    pub fn resume(&mut self) {\n+    fn resume(&mut self) {\n         if self.idle_flag == false {\n             self.watcher.restart();\n             self.idle_flag = true;\n         }\n     }\n     #[inline]\n-    pub fn close(&mut self) {\n+    fn close(&mut self) {\n         self.pause();\n         if !self.closed {\n             self.closed = true;\n@@ -447,11 +447,11 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError> {\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioTcpStream, IoError>> = &result_cell;\n \n         // Block this task and take ownership, switch to scheduler context\n         do task::unkillable { // FIXME(#8674)\n@@ -467,7 +467,8 @@ impl IoFactory for UvIoFactory {\n                         None => {\n                             let tcp = NativeHandle::from_native_handle(stream.native_handle());\n                             let home = get_handle_to_current_scheduler!();\n-                            let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n+                            let res = Ok(~UvTcpStream { watcher: tcp, home: home }\n+                                                as ~RtioTcpStream);\n \n                             // Store the stream in the task's stack\n                             unsafe { (*result_cell_ptr).put_back(res); }\n@@ -517,12 +518,12 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => {\n                 let home = get_handle_to_current_scheduler!();\n-                Ok(~UvUdpSocket { watcher: watcher, home: home })\n+                Ok(~UvUdpSocket { watcher: watcher, home: home } as ~RtioUdpSocket)\n             }\n             Err(uverr) => {\n                 do task::unkillable { // FIXME(#8674)\n@@ -540,10 +541,10 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError> {\n+    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n         let watcher = TimerWatcher::new(self.uv_loop());\n         let home = get_handle_to_current_scheduler!();\n-        Ok(~UvTimer::new(watcher, home))\n+        Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n@@ -750,7 +751,7 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<~RtioPipeObject>]), IoError>\n+            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n     {\n         // Sadly, we must create the UvProcess before we actually call uv_spawn\n         // so that the exit_cb can close over it and notify it when the process\n@@ -792,7 +793,8 @@ impl IoFactory for UvIoFactory {\n             Ok(io) => {\n                 // Only now do we actually get a handle to this scheduler.\n                 ret.home = Some(get_handle_to_current_scheduler!());\n-                Ok((ret, io))\n+                Ok((ret as ~RtioProcess,\n+                    io.move_iter().map(|p| p.map(|p| p as ~RtioPipe)).collect()))\n             }\n             Err(uverr) => {\n                 // We still need to close the process handle we created, but\n@@ -827,12 +829,12 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n-        Result<~RtioPipeObject, IoError>\n+        Result<~RtioPipe, IoError>\n     {\n         let scheduler: ~Scheduler = Local::take();\n         let mut pipe = Pipe::new(self.uv_loop(), false);\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioPipeObject, IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n \n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n@@ -845,7 +847,7 @@ impl IoFactory for UvIoFactory {\n                                         handle as *uvll::uv_pipe_t);\n                         let home = get_handle_to_current_scheduler!();\n                         let pipe = UvUnboundPipe::new(pipe, home);\n-                        Ok(~UvPipeStream::new(pipe))\n+                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n                     }\n                     Some(e) => { Err(uv_error_to_io_error(e)) }\n                 };\n@@ -871,13 +873,13 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n-            -> Result<~RtioTTYObject, IoError> {\n+            -> Result<~RtioTTY, IoError> {\n         match tty::TTY::new(self.uv_loop(), fd, readable) {\n             Ok(tty) => Ok(~UvTTY {\n                 home: get_handle_to_current_scheduler!(),\n                 tty: tty,\n                 close_on_drop: close_on_drop,\n-            }),\n+            } as ~RtioTTY),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n@@ -921,7 +923,7 @@ impl RtioSocket for UvTcpListener {\n }\n \n impl RtioTcpListener for UvTcpListener {\n-    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError> {\n+    fn listen(self) -> Result<~RtioTcpAcceptor, IoError> {\n         do self.home_for_io_consume |self_| {\n             let acceptor = ~UvTcpAcceptor::new(self_);\n             let incoming = Cell::new(acceptor.incoming.clone());\n@@ -935,14 +937,15 @@ impl RtioTcpListener for UvTcpListener {\n                             // first accept call in the callback guarenteed to succeed\n                             server.accept(inc.as_stream());\n                             let home = get_handle_to_current_scheduler!();\n-                            Ok(~UvTcpStream { watcher: inc, home: home })\n+                            Ok(~UvTcpStream { watcher: inc, home: home }\n+                                    as ~RtioTcpStream)\n                         }\n                     };\n                     incoming.send(inc);\n                 }\n             };\n             match res {\n-                Ok(()) => Ok(acceptor),\n+                Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n                 Err(e) => Err(uv_error_to_io_error(e)),\n             }\n         }\n@@ -951,7 +954,7 @@ impl RtioTcpListener for UvTcpListener {\n \n pub struct UvTcpAcceptor {\n     priv listener: UvTcpListener,\n-    priv incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    priv incoming: Tube<Result<~RtioTcpStream, IoError>>,\n }\n \n impl HomingIO for UvTcpAcceptor {\n@@ -984,7 +987,7 @@ fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n }\n \n impl RtioTcpAcceptor for UvTcpAcceptor {\n-    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n+    fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n         do self.home_for_io |self_| {\n             self_.incoming.recv()\n         }\n@@ -1718,7 +1721,7 @@ impl UvUnixListener {\n }\n \n impl RtioUnixListener for UvUnixListener {\n-    fn listen(self) -> Result<~RtioUnixAcceptorObject, IoError> {\n+    fn listen(self) -> Result<~RtioUnixAcceptor, IoError> {\n         do self.home_for_io_consume |self_| {\n             let acceptor = ~UvUnixAcceptor::new(self_);\n             let incoming = Cell::new(acceptor.incoming.clone());\n@@ -1732,14 +1735,14 @@ impl RtioUnixListener for UvUnixListener {\n                             server.accept(inc.as_stream());\n                             let home = get_handle_to_current_scheduler!();\n                             let pipe = UvUnboundPipe::new(inc, home);\n-                            Ok(~UvPipeStream::new(pipe))\n+                            Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n                         }\n                     };\n                     incoming.send(inc);\n                 }\n             };\n             match res {\n-                Ok(()) => Ok(acceptor),\n+                Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n                 Err(e) => Err(uv_error_to_io_error(e)),\n             }\n         }\n@@ -1776,7 +1779,7 @@ impl Drop for UvTTY {\n \n pub struct UvUnixAcceptor {\n     listener: UvUnixListener,\n-    incoming: Tube<Result<~RtioPipeObject, IoError>>,\n+    incoming: Tube<Result<~RtioPipe, IoError>>,\n }\n \n impl HomingIO for UvUnixAcceptor {\n@@ -1790,7 +1793,7 @@ impl UvUnixAcceptor {\n }\n \n impl RtioUnixAcceptor for UvUnixAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipeObject, IoError> {\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n         do self.home_for_io |self_| {\n             self_.incoming.recv()\n         }"}, {"sha": "fbe2988f77c7178915e91c59305b8ca1c9a3e2f4", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cad9847652088b35ee4c13c04539ca3a67611f7/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=0cad9847652088b35ee4c13c04539ca3a67611f7", "patch": "@@ -89,7 +89,7 @@ use unstable::sync::Exclusive;\n use rt::in_green_task_context;\n use rt::local::Local;\n use rt::task::{Task, Sched};\n-use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread};\n+use rt::shouldnt_be_public::{Scheduler, KillHandle, WorkQueue, Thread, EventLoop};\n use rt::uv::uvio::UvEventLoop;\n \n #[cfg(test)] use task::default_task_opts;\n@@ -607,7 +607,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n             let work_queue = WorkQueue::new();\n \n             // Create a new scheduler to hold the new task\n-            let new_loop = ~UvEventLoop::new();\n+            let new_loop = ~UvEventLoop::new() as ~EventLoop;\n             let mut new_sched = ~Scheduler::new_special(new_loop,\n                                                         work_queue,\n                                                         (*sched).work_queues.clone(),"}]}