{"sha": "92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjBkYzZiNGJiYWIzYmNmYzk2YzA1ODg3NzYwMzJkNWY4ZTQ5NjY=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-28T01:58:19Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-28T01:59:58Z"}, "message": "libstd: inlining almost every methods in bigint module.", "tree": {"sha": "a7ee429935dfa3916d7549676f70b522ee1b80d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7ee429935dfa3916d7549676f70b522ee1b80d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "html_url": "https://github.com/rust-lang/rust/commit/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b3490a551bc46c3d2b99d1a811ee93201f32f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b3490a551bc46c3d2b99d1a811ee93201f32f3", "html_url": "https://github.com/rust-lang/rust/commit/01b3490a551bc46c3d2b99d1a811ee93201f32f3"}], "stats": {"total": 87, "additions": 86, "deletions": 1}, "files": [{"sha": "3ea94eababb42b6f250ebae1e88e3a3bd50b936f", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "patch": "@@ -53,15 +53,19 @@ pub mod BigDigit {\n     priv static hi_mask: uint = (-1 as uint) << bits;\n     priv static lo_mask: uint = (-1 as uint) >> bits;\n \n+    #[inline(always)]\n     priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    #[inline(always)]\n     priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n+    #[inline(always)]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -78,32 +82,40 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n+    #[inline(always)]\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n+    #[inline(always)]\n     fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n+    #[inline(always)]\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n+    #[inline(always)]\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigUint {\n+    #[inline(always)]\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return Less; }\n@@ -121,16 +133,19 @@ impl TotalOrd for BigUint {\n }\n \n impl ToStr for BigUint {\n+    #[inline(always)]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigUint {\n+    #[inline(always)]\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -139,6 +154,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -147,18 +163,22 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n+    #[inline(always)]\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n+    #[inline(always)]\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n+    #[inline(always)]\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -178,6 +198,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -233,6 +254,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n+        #[inline(always)]\n         fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n@@ -249,13 +271,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n+        #[inline(always)]\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n+        #[inline(always)]\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -267,20 +291,23 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Quot<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn quot(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.quot_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.quot_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n+    #[inline(always)]\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n@@ -420,16 +447,19 @@ impl Integer for BigUint {\n }\n \n impl IntConvertible for BigUint {\n+    #[inline(always)]\n     fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n+    #[inline(always)]\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n+    #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -438,6 +468,7 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n+        #[inline(always)]\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -453,6 +484,7 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n+        #[inline(always)]\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let s = str::concat(vec::reversed(v).map(|n| {\n@@ -466,14 +498,16 @@ impl ToStrRadix for BigUint {\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(str::to_bytes(s), radix)\n     }\n }\n \n-pub impl BigUint {\n+impl BigUint {\n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n@@ -485,6 +519,7 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -494,11 +529,13 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::from_slice(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -521,6 +558,7 @@ pub impl BigUint {\n         }\n     }\n \n+    #[inline(always)]\n     pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n@@ -530,12 +568,14 @@ pub impl BigUint {\n         }\n     }\n \n+    #[inline(always)]\n     priv fn shl_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n+    #[inline(always)]\n     priv fn shl_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return self; }\n \n@@ -551,6 +591,7 @@ pub impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n+    #[inline(always)]\n     priv fn shr_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -559,6 +600,7 @@ pub impl BigUint {\n         );\n     }\n \n+    #[inline(always)]\n     priv fn shr_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return self; }\n \n@@ -573,6 +615,7 @@ pub impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n+#[inline(always)]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -598,6 +641,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n+#[inline(always)]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -625,21 +669,26 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n+    #[inline(always)]\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for Sign {\n+    #[inline(always)]\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -651,6 +700,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n+    #[inline(always)]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -667,32 +717,40 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n+    #[inline(always)]\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n+    #[inline(always)]\n     fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n+    #[inline(always)]\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n+    #[inline(always)]\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigInt {\n+    #[inline(always)]\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -706,49 +764,58 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n+    #[inline(always)]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigInt {\n+    #[inline(always)]\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n+    #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n+    #[inline(always)]\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n+    #[inline(always)]\n     fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n+    #[inline(always)]\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n+    #[inline(always)]\n     fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n+    #[inline(always)]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => copy *self,\n             Minus => BigInt::from_biguint(Plus, copy self.data)\n         }\n     }\n \n+    #[inline(always)]\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -757,12 +824,15 @@ impl Signed for BigInt {\n         }\n     }\n \n+    #[inline(always)]\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n+    #[inline(always)]\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => copy *other,\n@@ -777,6 +847,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -794,6 +865,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -808,20 +880,23 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Quot<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn quot(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.quot_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.quot_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n+    #[inline(always)]\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n@@ -910,6 +985,7 @@ impl Integer for BigInt {\n }\n \n impl IntConvertible for BigInt {\n+    #[inline(always)]\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n@@ -919,6 +995,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n+    #[inline(always)]\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -933,6 +1010,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n+    #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -944,6 +1022,7 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n@@ -952,11 +1031,13 @@ impl FromStrRadix for BigInt {\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -965,17 +1046,20 @@ pub impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -989,6 +1073,7 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n+    #[inline(always)]\n     fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),"}]}