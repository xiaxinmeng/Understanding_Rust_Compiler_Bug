{"sha": "e61f126fb48f3f21cc019b7dc005b5287cef79e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MWYxMjZmYjQ4ZjNmMjFjYzAxOWI3ZGMwMDViNTI4N2NlZjc5ZTU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-18T14:25:46Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-20T13:42:10Z"}, "message": "Replace shared root with optional root\n\nThis simplifies the node manipulation, as we can (in later commits) always know\nwhen traversing nodes that we are not in a shared root.", "tree": {"sha": "19b7425cae4ef9f665bf3b5f6f2b4313fd76f76c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b7425cae4ef9f665bf3b5f6f2b4313fd76f76c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e61f126fb48f3f21cc019b7dc005b5287cef79e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e61f126fb48f3f21cc019b7dc005b5287cef79e5", "html_url": "https://github.com/rust-lang/rust/commit/e61f126fb48f3f21cc019b7dc005b5287cef79e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e61f126fb48f3f21cc019b7dc005b5287cef79e5/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c6f982cc908aacc39c3ac97f31c989f81cc213c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f982cc908aacc39c3ac97f31c989f81cc213c", "html_url": "https://github.com/rust-lang/rust/commit/3c6f982cc908aacc39c3ac97f31c989f81cc213c"}], "stats": {"total": 189, "additions": 112, "deletions": 77}, "files": [{"sha": "478fa8e15268e4818d441e8f58b4215aace2ba17", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 112, "deletions": 77, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e61f126fb48f3f21cc019b7dc005b5287cef79e5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61f126fb48f3f21cc019b7dc005b5287cef79e5/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=e61f126fb48f3f21cc019b7dc005b5287cef79e5", "patch": "@@ -122,7 +122,7 @@ use UnderflowResult::*;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n-    root: node::Root<K, V>,\n+    root: Option<node::Root<K, V>>,\n     length: usize,\n }\n \n@@ -147,10 +147,11 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         {\n             match node.force() {\n                 Leaf(leaf) => {\n-                    let mut out_tree = BTreeMap { root: node::Root::new_leaf(), length: 0 };\n+                    let mut out_tree = BTreeMap { root: Some(node::Root::new_leaf()), length: 0 };\n \n                     {\n-                        let mut out_node = match out_tree.root.as_mut().force() {\n+                        let root = out_tree.root.as_mut().unwrap();\n+                        let mut out_node = match root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -170,8 +171,13 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n \n+                    // Cannot call ensure_root_is_owned() because lacking K: Ord\n+                    if out_tree.root.is_none() {\n+                        out_tree.root = Some(node::Root::new_leaf());\n+                    }\n+\n                     {\n-                        let mut out_node = out_tree.root.push_level();\n+                        let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -190,7 +196,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                                 (root, length)\n                             };\n \n-                            out_node.push(k, v, subroot);\n+                            out_node.push(k, v, subroot.unwrap_or_else(|| node::Root::new_leaf()));\n                             out_tree.length += 1 + sublength;\n                         }\n                     }\n@@ -203,9 +209,9 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n         if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n-            BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+            BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref())\n+            clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n \n@@ -271,14 +277,14 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -290,7 +296,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut()?.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -344,15 +350,18 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>>,\n     length: usize,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -417,8 +426,8 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -437,8 +446,8 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n /// [`BTreeMap`]: struct.BTreeMap.html\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    front: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    back: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n \n     // Be invariant in `K` and `V`\n     _marker: PhantomData<&'a mut (K, V)>,\n@@ -447,7 +456,10 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let range = Range { front: self.front.reborrow(), back: self.back.reborrow() };\n+        let range = Range {\n+            front: self.front.as_ref().map(|f| f.reborrow()),\n+            back: self.back.as_ref().map(|b| b.reborrow()),\n+        };\n         f.debug_list().entries(range).finish()\n     }\n }\n@@ -544,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n-        BTreeMap { root: node::Root::shared_empty_root(), length: 0 }\n+        BTreeMap { root: None, length: 0 }\n     }\n \n     /// Clears the map, removing all elements.\n@@ -589,7 +601,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), key) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -616,7 +628,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref(), k) {\n+        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -645,7 +657,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_ref().first_leaf_edge();\n+        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -674,7 +686,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let front = self.root.as_mut().first_leaf_edge();\n+        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n         if let Ok(kv) = front.right_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -708,7 +720,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_ref().last_leaf_edge();\n+        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n \n@@ -737,7 +749,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        let back = self.root.as_mut().last_leaf_edge();\n+        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n         if let Ok(kv) = back.left_kv() {\n             Some(OccupiedEntry {\n                 handle: kv.forget_node_type(),\n@@ -801,7 +813,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n             GoDown(_) => None,\n         }\n@@ -896,7 +908,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut(), key) {\n+        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -992,11 +1004,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_ref();\n-        let root2 = self.root.as_ref();\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &self.root {\n+            let root1 = root.as_ref();\n+            let root2 = root.as_ref();\n+            let (f, b) = range_search(root1, root2, range);\n \n-        Range { front: f, back: b }\n+            Range { front: Some(f), back: Some(b) }\n+        } else {\n+            Range { front: None, back: None }\n+        }\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -1036,11 +1052,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<T>,\n         R: RangeBounds<T>,\n     {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n-        let (f, b) = range_search(root1, root2, range);\n+        if let Some(root) = &mut self.root {\n+            let root1 = root.as_mut();\n+            let root2 = unsafe { ptr::read(&root1) };\n+            let (f, b) = range_search(root1, root2, range);\n \n-        RangeMut { front: f, back: b, _marker: PhantomData }\n+            RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n+        } else {\n+            RangeMut { front: None, back: None, _marker: PhantomData }\n+        }\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1065,7 +1085,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         self.ensure_root_is_owned();\n-        match search::search_tree(self.root.as_mut(), &key) {\n+        match search::search_tree(self.root.as_mut().unwrap().as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1077,7 +1097,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         self.ensure_root_is_owned();\n-        let mut cur_node = self.root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1126,7 +1146,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(&mut self) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = self.root.as_mut();\n+        let mut cur_node = self.root.as_mut().unwrap().as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1187,14 +1207,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n-        right.root = node::Root::new_leaf();\n-        for _ in 0..(self.root.as_ref().height()) {\n-            right.root.push_level();\n+        right.root = Some(node::Root::new_leaf());\n+        for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n+            right.root.as_mut().unwrap().push_level();\n         }\n \n         {\n-            let mut left_node = self.root.as_mut();\n-            let mut right_node = right.root.as_mut();\n+            let mut left_node = self.root.as_mut().unwrap().as_mut();\n+            let mut right_node = right.root.as_mut().unwrap().as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1223,7 +1243,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_right_border();\n         right.fix_left_border();\n \n-        if self.root.as_ref().height() < right.root.as_ref().height() {\n+        if self.root.as_ref().unwrap().as_ref().height()\n+            < right.root.as_ref().unwrap().as_ref().height()\n+        {\n             self.recalc_length();\n             right.length = total_num - self.len();\n         } else {\n@@ -1261,27 +1283,27 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n \n     /// Removes empty levels on the top.\n     fn fix_top(&mut self) {\n         loop {\n             {\n-                let node = self.root.as_ref();\n+                let node = self.root.as_ref().unwrap().as_ref();\n                 if node.height() == 0 || node.len() > 0 {\n                     break;\n                 }\n             }\n-            self.root.pop_level();\n+            self.root.as_mut().unwrap().pop_level();\n         }\n     }\n \n     fn fix_right_border(&mut self) {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -1307,7 +1329,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.root.as_mut();\n+            let mut cur_node = self.root.as_mut().unwrap().as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();\n@@ -1329,8 +1351,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// If the root node is the shared root node, allocate our own node.\n     fn ensure_root_is_owned(&mut self) {\n-        if self.root.is_shared_root() {\n-            self.root = node::Root::new_leaf();\n+        if self.root.is_none() {\n+            self.root = Some(node::Root::new_leaf());\n         }\n     }\n }\n@@ -1458,12 +1480,21 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        let root1 = unsafe { ptr::read(&self.root).into_ref() };\n-        let root2 = unsafe { ptr::read(&self.root).into_ref() };\n+        if self.root.is_none() {\n+            mem::forget(self);\n+            return IntoIter { front: None, back: None, length: 0 };\n+        }\n+\n+        let root1 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n+        let root2 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n         let len = self.length;\n         mem::forget(self);\n \n-        IntoIter { front: root1.first_leaf_edge(), back: root2.last_leaf_edge(), length: len }\n+        IntoIter {\n+            front: Some(root1.first_leaf_edge()),\n+            back: Some(root2.last_leaf_edge()),\n+            length: len,\n+        }\n     }\n }\n \n@@ -1480,7 +1511,8 @@ impl<K, V> Drop for IntoIter<K, V> {\n \n                 // No need to avoid the shared root, because the tree was definitely not empty.\n                 unsafe {\n-                    let mut node = ptr::read(&self.0.front).into_node().forget_type();\n+                    let mut node =\n+                        unwrap_unchecked(ptr::read(&self.0.front)).into_node().forget_type();\n                     while let Some(parent) = node.deallocate_and_ascend() {\n                         node = parent.into_node().forget_type();\n                     }\n@@ -1495,14 +1527,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n         }\n \n         unsafe {\n-            let mut node = ptr::read(&self.front).into_node().forget_type();\n-            if node.is_shared_root() {\n-                return;\n-            }\n-            // Most of the nodes have been deallocated while traversing\n-            // but one pile from a leaf up to the root is left standing.\n-            while let Some(parent) = node.deallocate_and_ascend() {\n-                node = parent.into_node().forget_type();\n+            if let Some(front) = ptr::read(&self.front) {\n+                let mut node = front.into_node().forget_type();\n+                // Most of the nodes have been deallocated while traversing\n+                // but one pile from a leaf up to the root is left standing.\n+                while let Some(parent) = node.deallocate_and_ascend() {\n+                    node = parent.into_node().forget_type();\n+                }\n             }\n         }\n     }\n@@ -1517,7 +1548,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.front.next_unchecked() })\n+            Some(unsafe { self.front.as_mut().unwrap().next_unchecked() })\n         }\n     }\n \n@@ -1533,7 +1564,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n             None\n         } else {\n             self.length -= 1;\n-            Some(unsafe { self.back.next_back_unchecked() })\n+            Some(unsafe { self.back.as_mut().unwrap().next_back_unchecked() })\n         }\n     }\n }\n@@ -1683,7 +1714,7 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1696,7 +1727,7 @@ impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1734,7 +1765,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n \n     unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.front.next_unchecked()\n+        unwrap_unchecked(self.front.as_mut()).next_unchecked()\n     }\n }\n \n@@ -1755,7 +1786,7 @@ impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        self.back.next_back_unchecked()\n+        unwrap_unchecked(self.back.as_mut()).next_back_unchecked()\n     }\n }\n \n@@ -1969,8 +2000,8 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n-                front: self.root.as_ref().first_leaf_edge(),\n-                back: self.root.as_ref().last_leaf_edge(),\n+                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n+                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n             },\n             length: self.length,\n         }\n@@ -1999,13 +2030,17 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        let root1 = self.root.as_mut();\n-        let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n-            range: RangeMut {\n-                front: root1.first_leaf_edge(),\n-                back: root2.last_leaf_edge(),\n-                _marker: PhantomData,\n+            range: if let Some(root) = &mut self.root {\n+                let root1 = root.as_mut();\n+                let root2 = unsafe { ptr::read(&root1) };\n+                RangeMut {\n+                    front: Some(root1.first_leaf_edge()),\n+                    back: Some(root2.last_leaf_edge()),\n+                    _marker: PhantomData,\n+                }\n+            } else {\n+                RangeMut { front: None, back: None, _marker: PhantomData }\n             },\n             length: self.length,\n         }"}]}