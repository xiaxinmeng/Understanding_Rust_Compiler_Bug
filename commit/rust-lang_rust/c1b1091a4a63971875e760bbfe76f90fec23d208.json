{"sha": "c1b1091a4a63971875e760bbfe76f90fec23d208", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYjEwOTFhNGE2Mzk3MTg3NWU3NjBiYmZlNzZmOTBmZWMyM2QyMDg=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-15T04:31:36Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-18T07:33:09Z"}, "message": "Support printf formats in terminfo strings\n\nterminfo parameterized strings supports a limited subset of printf-style\nformatting operations, such as %#5.3d.", "tree": {"sha": "eaaee64eda550dd7a6432d47c868fd6ab7c50b17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaaee64eda550dd7a6432d47c868fd6ab7c50b17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1b1091a4a63971875e760bbfe76f90fec23d208", "comment_count": 8, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b1091a4a63971875e760bbfe76f90fec23d208", "html_url": "https://github.com/rust-lang/rust/commit/c1b1091a4a63971875e760bbfe76f90fec23d208", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1b1091a4a63971875e760bbfe76f90fec23d208/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d084d9e7df0da671765c8a2d9212757f16ab1c9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d084d9e7df0da671765c8a2d9212757f16ab1c9d", "html_url": "https://github.com/rust-lang/rust/commit/d084d9e7df0da671765c8a2d9212757f16ab1c9d"}], "stats": {"total": 274, "additions": 243, "deletions": 31}, "files": [{"sha": "dca890ddf516029847ef3dc3818681ee30ad6a66", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 243, "deletions": 31, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/c1b1091a4a63971875e760bbfe76f90fec23d208/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b1091a4a63971875e760bbfe76f90fec23d208/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=c1b1091a4a63971875e760bbfe76f90fec23d208", "patch": "@@ -11,7 +11,8 @@\n //! Parameterized string expansion\n \n use core::prelude::*;\n-use core::{char, int, vec};\n+use core::{char, vec, util};\n+use core::num::strconv::{SignNone,SignNeg,SignAll,DigAll,to_str_bytes_common};\n use core::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n@@ -23,13 +24,21 @@ enum States {\n     PushParam,\n     CharConstant,\n     CharClose,\n-    IntConstant,\n+    IntConstant(int),\n+    FormatPattern(Flags, FormatState),\n     SeekIfElse(int),\n     SeekIfElsePercent(int),\n     SeekIfEnd(int),\n     SeekIfEndPercent(int)\n }\n \n+#[deriving(Eq)]\n+enum FormatState {\n+    FormatStateFlags,\n+    FormatStateWidth,\n+    FormatStatePrecision\n+}\n+\n /// Types of parameters a capability can use\n pub enum Param {\n     String(~str),\n@@ -71,8 +80,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n     let mut stack: ~[Param] = ~[];\n \n-    let mut intstate = ~[];\n-\n     // Copy parameters into a local vector for mutability\n     let mut mparams = [Number(0), ..9];\n     for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n@@ -100,26 +107,11 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             _       => return Err(~\"a non-char was used with %c\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n-                    's' => if stack.len() > 0 {\n-                        match stack.pop() {\n-                            String(s) => output.push_all(s.as_bytes()),\n-                            _         => return Err(~\"a non-str was used with %s\")\n-                        }\n-                    } else { return Err(~\"stack is empty\") },\n-                    'd' => if stack.len() > 0 {\n-                        match stack.pop() {\n-                            Number(x) => {\n-                                let s = x.to_str();\n-                                output.push_all(s.as_bytes())\n-                            }\n-                            _         => return Err(~\"a non-number was used with %d\")\n-                        }\n-                    } else { return Err(~\"stack is empty\") },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n-                    '{' => state = IntConstant,\n+                    '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n                         match stack.pop() {\n                             String(s) => stack.push(Number(s.len() as int)),\n@@ -231,6 +223,30 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         (_, _) => return Err(~\"first two params not numbers with %i\")\n                     },\n \n+                    // printf-style support for %doxXs\n+                    'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n+                        let flags = Flags::new();\n+                        let res = format(stack.pop(), FormatOp::from_char(cur), flags);\n+                        if res.is_err() { return res }\n+                        output.push_all(res.unwrap())\n+                    } else { return Err(~\"stack is empty\") },\n+                    ':'|'#'|' '|'.'|'0'..'9' => {\n+                        let mut flags = Flags::new();\n+                        let mut fstate = FormatStateFlags;\n+                        match cur {\n+                            ':' => (),\n+                            '#' => flags.alternate = true,\n+                            ' ' => flags.space = true,\n+                            '.' => fstate = FormatStatePrecision,\n+                            '0'..'9' => {\n+                                flags.width = (cur - '0') as uint;\n+                                fstate = FormatStateWidth;\n+                            }\n+                            _ => util::unreachable()\n+                        }\n+                        state = FormatPattern(flags, fstate);\n+                    }\n+\n                     // conditionals\n                     '?' => (),\n                     't' => if stack.len() > 0 {\n@@ -288,17 +304,61 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     return Err(~\"malformed character constant\");\n                 }\n             },\n-            IntConstant => {\n-                if cur == '}' {\n-                    stack.push(match int::parse_bytes(intstate, 10) {\n-                        Some(n) => Number(n),\n-                        None => return Err(~\"bad int constant\")\n-                    });\n-                    intstate.clear();\n-                    state = Nothing;\n-                } else {\n-                    intstate.push(cur as u8);\n-                    old_state = Nothing;\n+            IntConstant(i) => {\n+                match cur {\n+                    '}' => {\n+                        stack.push(Number(i));\n+                        state = Nothing;\n+                    }\n+                    '0'..'9' => {\n+                        state = IntConstant(i*10 + ((cur - '0') as int));\n+                        old_state = Nothing;\n+                    }\n+                    _ => return Err(~\"bad int constant\")\n+                }\n+            }\n+            FormatPattern(ref mut flags, ref mut fstate) => {\n+                old_state = Nothing;\n+                match (*fstate, cur) {\n+                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n+                        let res = format(stack.pop(), FormatOp::from_char(cur), *flags);\n+                        if res.is_err() { return res }\n+                        output.push_all(res.unwrap());\n+                        old_state = state; // will cause state to go to Nothing\n+                    } else { return Err(~\"stack is empty\") },\n+                    (FormatStateFlags,'#') => {\n+                        flags.alternate = true;\n+                    }\n+                    (FormatStateFlags,'-') => {\n+                        flags.left = true;\n+                    }\n+                    (FormatStateFlags,'+') => {\n+                        flags.sign = true;\n+                    }\n+                    (FormatStateFlags,' ') => {\n+                        flags.space = true;\n+                    }\n+                    (FormatStateFlags,'0'..'9') => {\n+                        flags.width = (cur - '0') as uint;\n+                        *fstate = FormatStateWidth;\n+                    }\n+                    (FormatStateFlags,'.') => {\n+                        *fstate = FormatStatePrecision;\n+                    }\n+                    (FormatStateWidth,'0'..'9') => {\n+                        let old = flags.width;\n+                        flags.width = flags.width * 10 + ((cur - '0') as uint);\n+                        if flags.width < old { return Err(~\"format width overflow\") }\n+                    }\n+                    (FormatStateWidth,'.') => {\n+                        *fstate = FormatStatePrecision;\n+                    }\n+                    (FormatStatePrecision,'0'..'9') => {\n+                        let old = flags.precision;\n+                        flags.precision = flags.precision * 10 + ((cur - '0') as uint);\n+                        if flags.precision < old { return Err(~\"format precision overflow\") }\n+                    }\n+                    _ => return Err(~\"invalid format specifier\")\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -349,6 +409,142 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     Ok(output)\n }\n \n+#[deriving(Eq)]\n+priv struct Flags {\n+    width: uint,\n+    precision: uint,\n+    alternate: bool,\n+    left: bool,\n+    sign: bool,\n+    space: bool\n+}\n+\n+impl Flags {\n+    priv fn new() -> Flags {\n+        Flags{ width: 0, precision: 0, alternate: false,\n+               left: false, sign: false, space: false }\n+    }\n+}\n+\n+priv enum FormatOp {\n+    FormatDigit,\n+    FormatOctal,\n+    FormatHex,\n+    FormatHEX,\n+    FormatString\n+}\n+\n+impl FormatOp {\n+    priv fn from_char(c: char) -> FormatOp {\n+        match c {\n+            'd' => FormatDigit,\n+            'o' => FormatOctal,\n+            'x' => FormatHex,\n+            'X' => FormatHEX,\n+            's' => FormatString,\n+            _ => fail!(\"bad FormatOp char\")\n+        }\n+    }\n+    priv fn to_char(self) -> char {\n+        match self {\n+            FormatDigit => 'd',\n+            FormatOctal => 'o',\n+            FormatHex => 'x',\n+            FormatHEX => 'X',\n+            FormatString => 's'\n+        }\n+    }\n+}\n+\n+priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n+    let mut s = match val {\n+        Number(d) => {\n+            match op {\n+                FormatString => {\n+                    return Err(~\"non-number on stack with %s\")\n+                }\n+                _ => {\n+                    let radix = match op {\n+                        FormatDigit => 10,\n+                        FormatOctal => 8,\n+                        FormatHex|FormatHEX => 16,\n+                        FormatString => util::unreachable()\n+                    };\n+                    let mut (s,_) = match op {\n+                        FormatDigit => {\n+                            let sign = if flags.sign { SignAll } else { SignNeg };\n+                            to_str_bytes_common(&d, radix, false, sign, DigAll)\n+                        }\n+                        _ => to_str_bytes_common(&(d as uint), radix, false, SignNone, DigAll)\n+                    };\n+                    if flags.precision > s.len() {\n+                        let mut s_ = vec::with_capacity(flags.precision);\n+                        let n = flags.precision - s.len();\n+                        s_.grow(n, &('0' as u8));\n+                        s_.push_all_move(s);\n+                        s = s_;\n+                    }\n+                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n+                    match op {\n+                        FormatDigit => {\n+                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                                s.unshift(' ' as u8);\n+                            }\n+                        }\n+                        FormatOctal => {\n+                            if flags.alternate && s[0] != '0' as u8 {\n+                                s.unshift('0' as u8);\n+                            }\n+                        }\n+                        FormatHex => {\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatHEX => {\n+                            s = s.into_ascii().to_upper().into_bytes();\n+                            if flags.alternate {\n+                                let s_ = util::replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                                s.push_all_move(s_);\n+                            }\n+                        }\n+                        FormatString => util::unreachable()\n+                    }\n+                    s\n+                }\n+            }\n+        }\n+        String(s) => {\n+            match op {\n+                FormatString => {\n+                    let mut s = s.as_bytes_with_null_consume();\n+                    s.pop(); // remove the null\n+                    if flags.precision > 0 && flags.precision < s.len() {\n+                        s.truncate(flags.precision);\n+                    }\n+                    s\n+                }\n+                _ => {\n+                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n+                }\n+            }\n+        }\n+    };\n+    if flags.width > s.len() {\n+        let n = flags.width - s.len();\n+        if flags.left {\n+            s.grow(n, &(' ' as u8));\n+        } else {\n+            let mut s_ = vec::with_capacity(flags.width);\n+            s_.grow(n, &(' ' as u8));\n+            s_.push_all_move(s);\n+            s = s_;\n+        }\n+    }\n+    Ok(s)\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -443,4 +639,20 @@ mod test {\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n     }\n+\n+    #[test]\n+    fn test_format() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n+                          [String(~\"foo\"), String(~\"foo\"), String(~\"f\"), String(~\"foo\")], vars),\n+                   Ok(bytes!(\"foofoo ffo\").to_owned()));\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(~\"foo\")], vars),\n+                   Ok(bytes!(\"fo  \").to_owned()));\n+\n+        assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),\n+                   Ok(bytes!(\"1001    1+1\").to_owned()));\n+        assert_eq!(expand(bytes!(\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\"), [Number(15), Number(27)], vars),\n+                   Ok(bytes!(\"17017  001b0X001B\").to_owned()));\n+    }\n }"}]}