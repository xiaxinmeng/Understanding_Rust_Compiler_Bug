{"sha": "d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZGQ4NjA0ZWI3NjY4M2UxYmI2MTNjYzM1ZDNhZDk3MGY0ZDM3MmY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-19T14:16:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-19T14:16:43Z"}, "message": "Rollup merge of #56348 - matklad:todo-macro, r=withoutboats\n\nAdd todo!() macro\n\nThe primary use-case of `todo!()` macro is to be a much easier to type\nalternative to `unimplemented!()` macro.\n\nEDIT: hide unpopular proposal about re-purposing unimplemented\n\n<details>\nHowever, instead of just replacing `unimplemented!()`, it gives it a\nmore nuanced meaning: a thing which is intentionally left\nunimplemented and which should not be called at runtime. Usually,\nyou'd like to prevent such cases statically, but sometimes you, for\nexample, have to implement a trait only some methods of which are\napplicable. There are examples in the wild of code doing this thing,\nand in this case, the current message of `unimplemented`, \"not *yet*\nimplemented\" is slightly misleading.\n\nWith the addition of TODO, you have three nuanced choices for a\n`!`-returning macro (in addition to a good-old panic we all love):\n\n  * todo!()\n  * unreachable!()\n  * unimplemented!()\n\nHere's a rough guideline what each one means:\n\n- `todo`: use it during development, as a \"hole\" or placeholder. It\n  might be a good idea to add a pre-commit hook which checks that\n  `todo` is not accidentally committed.\n\n- `unreachable!()`: use it when your code can statically guarantee\n  that some situation can not happen. If you use a library and hit\n  `unreachable!()` in the library's code, it's definitely a bug in the\n  library. It's OK to have `unreachable!()` in the code base,\n  although, if possible, it's better to replace it with\n  compiler-verified exhaustive checks.\n\n- `unimplemented!()`: use it when the type checker forces you to\n  handle some situation, but there's a contract that a callee must not\n  actually call the code. If you use a library and hit\n  `unimplemented!()`, it's probably a bug in your code, though\n  it *could* be a bug in the library (or library docs) as well. It is\n  ok-ish to see an `unimplemented!()` in real code, but it usually\n  signifies a clunky, eyebrow-rising API.\n</details>", "tree": {"sha": "95a2b55faa646337fd6ad3bb901c0112aa5f3fed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95a2b55faa646337fd6ad3bb901c0112aa5f3fed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJckPnLCRBK7hj4Ov3rIwAAdHIIAFaix9oOmQBkcF9GNfjIY7Ni\nRrLyGrB3UGwpuKSMnaCzzM3bn1h305248rcFGkg4xg5aVX5+BbUN75I2/rJKzVjr\n0ms8fbvEUvLYQ5rlmbx09KVSchKhwClQCOsRbC3b5/blm4PAOF/dKQT+e3/RvMIL\nbz4x7UnT5MufB8Ad0iKhqoqKnGT8YbomoTtPpOKIc65+R+W2UI+91FGM0IhWmLv0\nwc0zHmks9RLPnHR7CBIubBxF14CLXMBAiKOw3u0CuFNg7El5ScdhShKuDQ2Z0RN2\ngt9Gqm2ysOvoqalcIa2Ty3xmLaPTZMCxLLbG7H8qYOZRJhRfnxMPXZe0ZgaEQbc=\n=536P\n-----END PGP SIGNATURE-----\n", "payload": "tree 95a2b55faa646337fd6ad3bb901c0112aa5f3fed\nparent ef4d1c419525e1510aa650e2bec0d8f7449a2130\nparent 9d408d972f7cf16162ec3ab35e11c659ccee9566\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553005003 +0100\ncommitter GitHub <noreply@github.com> 1553005003 +0100\n\nRollup merge of #56348 - matklad:todo-macro, r=withoutboats\n\nAdd todo!() macro\n\nThe primary use-case of `todo!()` macro is to be a much easier to type\nalternative to `unimplemented!()` macro.\n\nEDIT: hide unpopular proposal about re-purposing unimplemented\n\n<details>\nHowever, instead of just replacing `unimplemented!()`, it gives it a\nmore nuanced meaning: a thing which is intentionally left\nunimplemented and which should not be called at runtime. Usually,\nyou'd like to prevent such cases statically, but sometimes you, for\nexample, have to implement a trait only some methods of which are\napplicable. There are examples in the wild of code doing this thing,\nand in this case, the current message of `unimplemented`, \"not *yet*\nimplemented\" is slightly misleading.\n\nWith the addition of TODO, you have three nuanced choices for a\n`!`-returning macro (in addition to a good-old panic we all love):\n\n  * todo!()\n  * unreachable!()\n  * unimplemented!()\n\nHere's a rough guideline what each one means:\n\n- `todo`: use it during development, as a \"hole\" or placeholder. It\n  might be a good idea to add a pre-commit hook which checks that\n  `todo` is not accidentally committed.\n\n- `unreachable!()`: use it when your code can statically guarantee\n  that some situation can not happen. If you use a library and hit\n  `unreachable!()` in the library's code, it's definitely a bug in the\n  library. It's OK to have `unreachable!()` in the code base,\n  although, if possible, it's better to replace it with\n  compiler-verified exhaustive checks.\n\n- `unimplemented!()`: use it when the type checker forces you to\n  handle some situation, but there's a contract that a callee must not\n  actually call the code. If you use a library and hit\n  `unimplemented!()`, it's probably a bug in your code, though\n  it *could* be a bug in the library (or library docs) as well. It is\n  ok-ish to see an `unimplemented!()` in real code, but it usually\n  signifies a clunky, eyebrow-rising API.\n</details>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "html_url": "https://github.com/rust-lang/rust/commit/d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4dd8604eb76683e1bb613cc35d3ad970f4d372f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4d1c419525e1510aa650e2bec0d8f7449a2130", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4d1c419525e1510aa650e2bec0d8f7449a2130", "html_url": "https://github.com/rust-lang/rust/commit/ef4d1c419525e1510aa650e2bec0d8f7449a2130"}, {"sha": "9d408d972f7cf16162ec3ab35e11c659ccee9566", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d408d972f7cf16162ec3ab35e11c659ccee9566", "html_url": "https://github.com/rust-lang/rust/commit/9d408d972f7cf16162ec3ab35e11c659ccee9566"}], "stats": {"total": 62, "additions": 61, "deletions": 1}, "files": [{"sha": "d77936c7ddd913fe9cad93e213742ff693a6bb9f", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d4dd8604eb76683e1bb613cc35d3ad970f4d372f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4dd8604eb76683e1bb613cc35d3ad970f4d372f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "patch": "@@ -559,6 +559,65 @@ macro_rules! unimplemented {\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n+/// A standardized placeholder for marking unfinished code.\n+///\n+/// This can be useful if you are prototyping and are just looking to have your\n+/// code typecheck. `todo!` works exactly like `unimplemented!`, there only\n+/// difference between the two macros is the name.\n+///\n+/// # Panics\n+///\n+/// This will always [panic!](macro.panic.html)\n+///\n+/// # Examples\n+///\n+/// Here's an example of some in-progress code. We have a trait `Foo`:\n+///\n+/// ```\n+/// trait Foo {\n+///     fn bar(&self);\n+///     fn baz(&self);\n+/// }\n+/// ```\n+///\n+/// We want to implement `Foo` on one of our types, but we also want to work on\n+/// just `bar()` first. In order for our code to compile, we need to implement\n+/// `baz()`, so we can use `todo!`:\n+///\n+/// ```\n+/// #![feature(todo_macro)]\n+///\n+/// # trait Foo {\n+/// #     fn bar(&self);\n+/// #     fn baz(&self);\n+/// # }\n+/// struct MyStruct;\n+///\n+/// impl Foo for MyStruct {\n+///     fn bar(&self) {\n+///         // implementation goes here\n+///     }\n+///\n+///     fn baz(&self) {\n+///         // let's not worry about implementing baz() for now\n+///         todo!();\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let s = MyStruct;\n+///     s.bar();\n+///\n+///     // we aren't even using baz() yet, so this is fine.\n+/// }\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"todo_macro\", issue = \"59277\")]\n+macro_rules! todo {\n+    () => (panic!(\"not yet implemented\"));\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n+}\n+\n /// A macro to create an array of [`MaybeUninit`]\n ///\n /// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`."}, {"sha": "296c4c887274e61eb7b3f9d719c9915b322f69e7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4dd8604eb76683e1bb613cc35d3ad970f4d372f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4dd8604eb76683e1bb613cc35d3ad970f4d372f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d4dd8604eb76683e1bb613cc35d3ad970f4d372f", "patch": "@@ -301,6 +301,7 @@\n #![feature(stmt_expr_attributes)]\n #![feature(str_internals)]\n #![feature(thread_local)]\n+#![feature(todo_macro)]\n #![feature(toowned_clone_into)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n@@ -323,7 +324,7 @@ use prelude::v1::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::{assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::{unreachable, unimplemented, write, writeln, r#try};\n+pub use core::{unreachable, unimplemented, write, writeln, r#try, todo};\n \n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]"}]}