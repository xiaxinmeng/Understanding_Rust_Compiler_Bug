{"sha": "987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NzYzMWQzYmE1N2Y5ZmRmZTU0ZjNmZWVkMDMxMjdjN2U2ZDVjNWM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-19T00:33:24Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-27T10:09:59Z"}, "message": "Move query functions out from the define_maps! macro", "tree": {"sha": "c5a20c2866c18c0d471802bf53de3035c4640925", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a20c2866c18c0d471802bf53de3035c4640925"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "html_url": "https://github.com/rust-lang/rust/commit/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4036d2be8aa7323257bcc244ba47a512f2938965", "url": "https://api.github.com/repos/rust-lang/rust/commits/4036d2be8aa7323257bcc244ba47a512f2938965", "html_url": "https://github.com/rust-lang/rust/commit/4036d2be8aa7323257bcc244ba47a512f2938965"}], "stats": {"total": 627, "additions": 327, "deletions": 300}, "files": [{"sha": "2f6e7ade89f615b4173a0413dc2710c99425bc1b", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dep_graph::SerializedDepNodeIndex;\n+use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n@@ -19,20 +20,31 @@ use ty::maps::Query;\n use ty::maps::QueryMap;\n \n use std::hash::Hash;\n+use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::stable_hasher::HashStable;\n+use ich::StableHashingContext;\n \n /// Query configuration and description traits.\n \n pub trait QueryConfig<'tcx> {\n-    type Key: Eq + Hash + Clone;\n-    type Value: Clone;\n+    const NAME: &'static str;\n+\n+    type Key: Eq + Hash + Clone + Debug;\n+    type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;\n \n     fn query(key: Self::Key) -> Query<'tcx>;\n     fn query_map<'a>(tcx: TyCtxt<'a, 'tcx, '_>) -> &'a Lock<QueryMap<'tcx, Self>>;\n+\n+    fn to_dep_node(tcx: TyCtxt<'_, 'tcx, '_>, key: &Self::Key) -> DepNode;\n+\n+    fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n+\n+    fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value;\n }\n \n-pub(super) trait QueryDescription<'tcx>: QueryConfig<'tcx> {\n+pub trait QueryDescription<'tcx>: QueryConfig<'tcx> {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n \n     #[inline]"}, {"sha": "57223a3c7b2749d6881a51f945f5c2647b91d1cf", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode};\n-use errors::DiagnosticBuilder;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n@@ -43,7 +42,7 @@ use ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n-use util::common::{profq_msg, ErrorReported, ProfileQueriesMsg};\n+use util::common::{ErrorReported};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_target::spec::PanicStrategy;"}, {"sha": "c3f3424600ca9e4be3302e3c8728e0e866df9f85", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 300, "deletions": 290, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -25,14 +25,15 @@ use ty::maps::config::QueryDescription;\n use ty::maps::job::{QueryJob, QueryResult, QueryInfo};\n use ty::item_path;\n \n-use util::common::{profq_msg, ProfileQueriesMsg};\n+use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n use std::mem;\n use std::ptr;\n use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n+use syntax::codemap::DUMMY_SP;\n \n pub struct QueryMap<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n     pub(super) map: FxHashMap<D::Key, QueryResult<'tcx, QueryValue<D::Value>>>,\n@@ -75,14 +76,18 @@ macro_rules! profq_msg {\n \n // If enabled, format a key using its debug string, which can be\n // expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n+macro_rules! profq_query_msg {\n+    ($query:expr, $tcx:expr, $key:expr) => {{\n+        let msg = if cfg!(debug_assertions) {\n             if $tcx.sess.profile_queries_and_keys() {\n                 Some(format!(\"{:?}\", $key))\n             } else { None }\n-        } else { None }\n-    }\n+        } else { None };\n+        QueryMsg {\n+            query: $query,\n+            msg,\n+        }\n+    }}\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n@@ -325,14 +330,286 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    fn try_get_with<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key)\n+    -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+               Q::NAME,\n+               key,\n+               span);\n+\n+        profq_msg!(self,\n+            ProfileQueriesMsg::QueryBegin(\n+                span.data(),\n+                profq_query_msg!(Q::NAME, self, key),\n+            )\n+        );\n+\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => {\n+                return result.map(|(v, index)| {\n+                    self.dep_graph.read_index(index);\n+                    v\n+                })\n+            }\n+        };\n+\n+        // Fast path for when incr. comp. is off. `to_dep_node` is\n+        // expensive for some DepKinds.\n+        if !self.dep_graph.is_fully_enabled() {\n+            let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n+            return self.force_query_with_job::<Q>(key, job, null_dep_node).map(|(v, _)| v);\n+        }\n+\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        if dep_node.kind.is_anon() {\n+            profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+\n+            let res = job.start(self, |tcx| {\n+                tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                    Q::compute(tcx.global_tcx(), key)\n+                })\n+            });\n+\n+            profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+            let ((result, dep_node_index), diagnostics) = res;\n+\n+            self.dep_graph.read_index(dep_node_index);\n+\n+            self.on_disk_query_result_cache\n+                .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+\n+            job.complete(&result, dep_node_index);\n+\n+            return Ok(result);\n+        }\n+\n+        if !dep_node.kind.is_input() {\n+            if let Some(dep_node_index) = self.try_mark_green_and_read(&dep_node) {\n+                profq_msg!(self, ProfileQueriesMsg::CacheHit);\n+                return self.load_from_disk_and_cache_in_memory::<Q>(key,\n+                                                                    job,\n+                                                                    dep_node_index,\n+                                                                    &dep_node)\n+            }\n+        }\n+\n+        match self.force_query_with_job::<Q>(key, job, dep_node) {\n+            Ok((result, dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Ok(result)\n+            }\n+            Err(e) => Err(e)\n+        }\n+    }\n+\n+    fn load_from_disk_and_cache_in_memory<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'a, 'gcx, Q>,\n+        dep_node_index: DepNodeIndex,\n+        dep_node: &DepNode\n+    ) -> Result<Q::Value, CycleError<'gcx>>\n+    {\n+        // Note this function can be called concurrently from the same query\n+        // We must ensure that this is handled correctly\n+\n+        debug_assert!(self.dep_graph.is_green(dep_node));\n+\n+        // First we try to load the result from the on-disk cache\n+        let result = if Q::cache_on_disk(key.clone()) &&\n+                        self.sess.opts.debugging_opts.incremental_queries {\n+            let prev_dep_node_index =\n+                self.dep_graph.prev_dep_node_index_of(dep_node);\n+            let result = Q::try_load_from_disk(self.global_tcx(),\n+                                                    prev_dep_node_index);\n+\n+            // We always expect to find a cached result for things that\n+            // can be forced from DepNode.\n+            debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n+                            result.is_some(),\n+                            \"Missing on-disk cache entry for {:?}\",\n+                            dep_node);\n+            result\n+        } else {\n+            // Some things are never cached on disk.\n+            None\n+        };\n+\n+        let result = if let Some(result) = result {\n+            result\n+        } else {\n+            // We could not load a result from the on-disk cache, so\n+            // recompute.\n+\n+            // The diagnostics for this query have already been\n+            // promoted to the current session during\n+            // try_mark_green(), so we can ignore them here.\n+            let (result, _) = job.start(self, |tcx| {\n+                // The dep-graph for this computation is already in\n+                // place\n+                tcx.dep_graph.with_ignore(|| {\n+                    Q::compute(tcx, key)\n+                })\n+            });\n+            result\n+        };\n+\n+        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // the cache and make sure that they have the expected fingerprint.\n+        if self.sess.opts.debugging_opts.incremental_verify_ich {\n+            use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+            use ich::Fingerprint;\n+\n+            assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+                    self.dep_graph.prev_fingerprint_of(dep_node),\n+                    \"Fingerprint for green query instance not loaded \\\n+                        from cache: {:?}\", dep_node);\n+\n+            debug!(\"BEGIN verify_ich({:?})\", dep_node);\n+            let mut hcx = self.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+\n+            result.hash_stable(&mut hcx, &mut hasher);\n+\n+            let new_hash: Fingerprint = hasher.finish();\n+            debug!(\"END verify_ich({:?})\", dep_node);\n+\n+            let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n+\n+            assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n+                for {:?}\", dep_node);\n+        }\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok(result)\n+    }\n+\n+    fn force_query_with_job<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        job: JobOwner<'_, 'gcx, Q>,\n+        dep_node: DepNode)\n+    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // If the following assertion triggers, it can have two reasons:\n+        // 1. Something is wrong with DepNode creation, either here or\n+        //    in DepGraph::try_mark_green()\n+        // 2. Two distinct query keys get mapped to the same DepNode\n+        //    (see for example #48923)\n+        assert!(!self.dep_graph.dep_node_exists(&dep_node),\n+                \"Forcing query with already existing DepNode.\\n\\\n+                    - query-key: {:?}\\n\\\n+                    - dep-node: {:?}\",\n+                key, dep_node);\n+\n+        profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+        let res = job.start(self, |tcx| {\n+            if dep_node.kind.is_eval_always() {\n+                tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                    tcx,\n+                                                    key,\n+                                                    Q::compute)\n+            } else {\n+                tcx.dep_graph.with_task(dep_node,\n+                                        tcx,\n+                                        key,\n+                                        Q::compute)\n+            }\n+        });\n+        profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n+\n+        let ((result, dep_node_index), diagnostics) = res;\n+\n+        if self.sess.opts.debugging_opts.query_dep_graph {\n+            self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n+        }\n+\n+        if dep_node.kind != ::dep_graph::DepKind::Null {\n+            self.on_disk_query_result_cache\n+                .store_diagnostics(dep_node_index, diagnostics);\n+        }\n+\n+        job.complete(&result, dep_node_index);\n+\n+        Ok((result, dep_node_index))\n+    }\n+\n+    /// Ensure that either this query has all green inputs or been executed.\n+    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    ///\n+    /// This function is particularly useful when executing passes for their\n+    /// side-effects -- e.g., in order to report errors for erroneous programs.\n+    ///\n+    /// Note: The optimization is only available during incr. comp.\n+    pub fn ensure_query<Q: QueryDescription<'gcx>>(self, key: Q::Key) -> () {\n+        let dep_node = Q::to_dep_node(self, &key);\n+\n+        // Ensuring an \"input\" or anonymous query makes no sense\n+        assert!(!dep_node.kind.is_anon());\n+        assert!(!dep_node.kind.is_input());\n+        if self.try_mark_green_and_read(&dep_node).is_none() {\n+            // A None return from `try_mark_green_and_read` means that this is either\n+            // a new dep node or that the dep node has already been marked red.\n+            // Either way, we can't call `dep_graph.read()` as we don't have the\n+            // DepNodeIndex. We must invoke the query itself. The performance cost\n+            // this introduces should be negligible as we'll immediately hit the\n+            // in-memory cache, or another query down the line will.\n+            let _ = self.get_query::<Q>(DUMMY_SP, key);\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    fn force_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        key: Q::Key,\n+        span: Span,\n+        dep_node: DepNode\n+    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+        // We may be concurrently trying both execute and force a query\n+        // Ensure that only one of them runs the query\n+        let job = match JobOwner::try_get(self, span, &key) {\n+            TryGetJob::NotYetStarted(job) => job,\n+            TryGetJob::JobCompleted(result) => return result,\n+        };\n+        self.force_query_with_job::<Q>(key, job, dep_node)\n+    }\n+\n+    pub fn try_get_query<Q: QueryDescription<'gcx>>(\n+        self,\n+        span: Span,\n+        key: Q::Key\n+    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+        match self.try_get_with::<Q>(span, key) {\n+            Ok(e) => Ok(e),\n+            Err(e) => Err(self.report_cycle(e)),\n+        }\n+    }\n+\n+    pub fn get_query<Q: QueryDescription<'gcx>>(self, span: Span, key: Q::Key) -> Q::Value {\n+        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n+            e.emit();\n+            Q::handle_cycle_error(self)\n+        })\n+    }\n }\n \n macro_rules! handle_cycle_error {\n     ([][$this: expr]) => {{\n         Value::from_cycle_error($this.global_tcx())\n     }};\n     ([fatal_cycle$(, $modifiers:ident)*][$this:expr]) => {{\n-        $this.tcx.sess.abort_if_errors();\n+        $this.sess.abort_if_errors();\n         unreachable!();\n     }};\n     ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n@@ -345,7 +622,6 @@ macro_rules! define_maps {\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n-        use dep_graph::DepNodeIndex;\n         use rustc_data_structures::sync::Lock;\n \n         define_map_struct! {\n@@ -369,12 +645,6 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n-        #[allow(bad_style)]\n-        #[derive(Clone, Debug, PartialEq, Eq)]\n-        pub enum QueryMsg {\n-            $($name(Option<String>)),*\n-        }\n-\n         impl<$tcx> Query<$tcx> {\n             pub fn name(&self) -> &'static str {\n                 match *self {\n@@ -425,103 +695,34 @@ macro_rules! define_maps {\n             type Key = $K;\n             type Value = $V;\n \n+            const NAME: &'static str = stringify!($name);\n+\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n             fn query_map<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryMap<$tcx, Self>> {\n                 &tcx.maps.$name\n             }\n-        }\n-\n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n \n             #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            fn try_get_with(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                            span: Span,\n-                            key: $K)\n-                            -> Result<$V, CycleError<$tcx>>\n-            {\n-                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n-                       stringify!($name),\n-                       key,\n-                       span);\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        QueryMsg::$name(profq_key!(tcx, key))\n-                    )\n-                );\n-\n-                let job = match JobOwner::try_get(tcx, span, &key) {\n-                    TryGetJob::NotYetStarted(job) => job,\n-                    TryGetJob::JobCompleted(result) => {\n-                        return result.map(|(v, index)| {\n-                            tcx.dep_graph.read_index(index);\n-                            v\n-                        })\n-                    }\n-                };\n-\n-                // Fast path for when incr. comp. is off. `to_dep_node` is\n-                // expensive for some DepKinds.\n-                if !tcx.dep_graph.is_fully_enabled() {\n-                    let null_dep_node = DepNode::new_no_params(::dep_graph::DepKind::Null);\n-                    return Self::force_with_job(tcx, key, job, null_dep_node)\n-                                .map(|(v, _)| v);\n-                }\n-\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                if dep_node.kind.is_anon() {\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                    let res = job.start(tcx, |tcx| {\n-                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                            Self::compute_result(tcx.global_tcx(), key)\n-                        })\n-                    });\n-\n-                    profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                    let ((result, dep_node_index), diagnostics) = res;\n-\n-                    tcx.dep_graph.read_index(dep_node_index);\n-\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n-\n-                    job.complete(&result, dep_node_index);\n-\n-                    return Ok(result);\n-                }\n-\n-                if !dep_node.kind.is_input() {\n-                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n-                        profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                        return Self::load_from_disk_and_cache_in_memory(tcx,\n-                                                                        key,\n-                                                                        job,\n-                                                                        dep_node_index,\n-                                                                        &dep_node)\n-                    }\n-                }\n+            fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value {\n+                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                provider(tcx.global_tcx(), key)\n+            }\n \n-                match Self::force_with_job(tcx, key, job, dep_node) {\n-                    Ok((result, dep_node_index)) => {\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        Ok(result)\n-                    }\n-                    Err(e) => Err(e)\n-                }\n+            fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value {\n+                handle_cycle_error!([$($modifiers)*][tcx])\n             }\n+        }\n \n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n             /// Ensure that either this query has all green inputs or been executed.\n             /// Executing query::ensure(D) is considered a read of the dep-node D.\n             ///\n@@ -530,185 +731,7 @@ macro_rules! define_maps {\n             ///\n             /// Note: The optimization is only available during incr. comp.\n             pub fn ensure(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> () {\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-\n-                // Ensuring an \"input\" or anonymous query makes no sense\n-                assert!(!dep_node.kind.is_anon());\n-                assert!(!dep_node.kind.is_input());\n-                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n-                    // A None return from `try_mark_green_and_read` means that this is either\n-                    // a new dep node or that the dep node has already been marked red.\n-                    // Either way, we can't call `dep_graph.read()` as we don't have the\n-                    // DepNodeIndex. We must invoke the query itself. The performance cost\n-                    // this introduces should be negligible as we'll immediately hit the\n-                    // in-memory cache, or another query down the line will.\n-                    let _ = tcx.$name(key);\n-                }\n-            }\n-\n-            fn compute_result(tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n-                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                provider(tcx.global_tcx(), key)\n-            }\n-\n-            fn load_from_disk_and_cache_in_memory(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                                  key: $K,\n-                                                  job: JobOwner<'a, $tcx, Self>,\n-                                                  dep_node_index: DepNodeIndex,\n-                                                  dep_node: &DepNode)\n-                                                  -> Result<$V, CycleError<$tcx>>\n-            {\n-                // Note this function can be called concurrently from the same query\n-                // We must ensure that this is handled correctly\n-\n-                debug_assert!(tcx.dep_graph.is_green(dep_node));\n-\n-                // First we try to load the result from the on-disk cache\n-                let result = if Self::cache_on_disk(key) &&\n-                                tcx.sess.opts.debugging_opts.incremental_queries {\n-                    let prev_dep_node_index =\n-                        tcx.dep_graph.prev_dep_node_index_of(dep_node);\n-                    let result = Self::try_load_from_disk(tcx.global_tcx(),\n-                                                          prev_dep_node_index);\n-\n-                    // We always expect to find a cached result for things that\n-                    // can be forced from DepNode.\n-                    debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n-                                  result.is_some(),\n-                                  \"Missing on-disk cache entry for {:?}\",\n-                                  dep_node);\n-                    result\n-                } else {\n-                    // Some things are never cached on disk.\n-                    None\n-                };\n-\n-                let result = if let Some(result) = result {\n-                    result\n-                } else {\n-                    // We could not load a result from the on-disk cache, so\n-                    // recompute.\n-\n-                    // The diagnostics for this query have already been\n-                    // promoted to the current session during\n-                    // try_mark_green(), so we can ignore them here.\n-                    let (result, _) = job.start(tcx, |tcx| {\n-                        // The dep-graph for this computation is already in\n-                        // place\n-                        tcx.dep_graph.with_ignore(|| {\n-                            Self::compute_result(tcx, key)\n-                        })\n-                    });\n-                    result\n-                };\n-\n-                // If -Zincremental-verify-ich is specified, re-hash results from\n-                // the cache and make sure that they have the expected fingerprint.\n-                if tcx.sess.opts.debugging_opts.incremental_verify_ich {\n-                    use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-                    use ich::Fingerprint;\n-\n-                    assert!(Some(tcx.dep_graph.fingerprint_of(dep_node_index)) ==\n-                            tcx.dep_graph.prev_fingerprint_of(dep_node),\n-                            \"Fingerprint for green query instance not loaded \\\n-                             from cache: {:?}\", dep_node);\n-\n-                    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n-                    let mut hcx = tcx.create_stable_hashing_context();\n-                    let mut hasher = StableHasher::new();\n-\n-                    result.hash_stable(&mut hcx, &mut hasher);\n-\n-                    let new_hash: Fingerprint = hasher.finish();\n-                    debug!(\"END verify_ich({:?})\", dep_node);\n-\n-                    let old_hash = tcx.dep_graph.fingerprint_of(dep_node_index);\n-\n-                    assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-                        for {:?}\", dep_node);\n-                }\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n-                }\n-\n-                job.complete(&result, dep_node_index);\n-\n-                Ok(result)\n-            }\n-\n-            #[allow(dead_code)]\n-            fn force(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                     key: $K,\n-                     span: Span,\n-                     dep_node: DepNode)\n-                     -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // We may be concurrently trying both execute and force a query\n-                // Ensure that only one of them runs the query\n-                let job = match JobOwner::try_get(tcx, span, &key) {\n-                    TryGetJob::NotYetStarted(job) => job,\n-                    TryGetJob::JobCompleted(result) => return result,\n-                };\n-                Self::force_with_job(tcx,\n-                                     key,\n-                                     job,\n-                                     dep_node)\n-            }\n-\n-            fn force_with_job(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                               key: $K,\n-                               job: JobOwner<'_, $tcx, Self>,\n-                               dep_node: DepNode)\n-                               -> Result<($V, DepNodeIndex), CycleError<$tcx>> {\n-                // If the following assertion triggers, it can have two reasons:\n-                // 1. Something is wrong with DepNode creation, either here or\n-                //    in DepGraph::try_mark_green()\n-                // 2. Two distinct query keys get mapped to the same DepNode\n-                //    (see for example #48923)\n-                assert!(!tcx.dep_graph.dep_node_exists(&dep_node),\n-                        \"Forcing query with already existing DepNode.\\n\\\n-                          - query-key: {:?}\\n\\\n-                          - dep-node: {:?}\",\n-                        key, dep_node);\n-\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-                let res = job.start(tcx, |tcx| {\n-                    if dep_node.kind.is_eval_always() {\n-                        tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                            tcx,\n-                                                            key,\n-                                                            Self::compute_result)\n-                    } else {\n-                        tcx.dep_graph.with_task(dep_node,\n-                                                tcx,\n-                                                key,\n-                                                Self::compute_result)\n-                    }\n-                });\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-\n-                let ((result, dep_node_index), diagnostics) = res;\n-\n-                if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    tcx.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n-                }\n-\n-                if dep_node.kind != ::dep_graph::DepKind::Null {\n-                    tcx.on_disk_query_result_cache\n-                       .store_diagnostics(dep_node_index, diagnostics);\n-                }\n-\n-                job.complete(&result, dep_node_index);\n-\n-                Ok((result, dep_node_index))\n-            }\n-\n-            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key) {\n-                    Ok(e) => Ok(e),\n-                    Err(e) => Err(tcx.report_cycle(e)),\n-                }\n+                tcx.ensure_query::<queries::$name>(key);\n             }\n         })*\n \n@@ -744,10 +767,7 @@ macro_rules! define_maps {\n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n             pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n-                    e.emit();\n-                    handle_cycle_error!([$($modifiers)*][self])\n-                })\n+                self.tcx.get_query::<queries::$name>(self.span, key)\n             })*\n         }\n \n@@ -838,7 +858,6 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n                                            dep_node: &DepNode)\n                                            -> bool {\n-    use ty::maps::keys::Key;\n     use hir::def_id::LOCAL_CRATE;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -881,23 +900,14 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             {\n                 use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n \n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                let span = if stringify!($query) != \"def_span\" {\n-                    $key.default_span(tcx)\n-                } else {\n-                    ::syntax_pos::DUMMY_SP\n-                };\n-\n                 profq_msg!(tcx,\n                     ProfileQueriesMsg::QueryBegin(\n-                        span.data(),\n-                        ::ty::maps::QueryMsg::$query(profq_key!(tcx, $key))\n+                        DUMMY_SP.data(),\n+                        profq_query_msg!(::ty::maps::queries::$query::NAME, tcx, $key),\n                     )\n                 );\n \n-                match ::ty::maps::queries::$query::force(tcx, $key, span, *dep_node) {\n+                match tcx.force_query::<::ty::maps::queries::$query>($key, DUMMY_SP, *dep_node) {\n                     Ok(_) => {},\n                     Err(e) => {\n                         tcx.report_cycle(e).emit();"}, {"sha": "050561df6384ac98e42bf42a7126eba812a03158", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -2031,7 +2031,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n-        match queries::adt_sized_constraint::try_get(tcx, DUMMY_SP, self.did) {\n+        match tcx.try_get_query::<queries::adt_sized_constraint>(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n             Err(mut bug) => {\n                 debug!(\"adt_sized_constraint: {:?} is recursive\", self);"}, {"sha": "4aa70e1f7e006964adef5cb1069a1ec8f885afc3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -1024,7 +1024,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {\n-        match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n+        match tcx.try_get_query::<ty::queries::needs_drop_raw>(DUMMY_SP, param_env.and(ty)) {\n             Ok(v) => v,\n             Err(mut bug) => {\n                 // Cycles should be reported as an error by `check_representable`."}, {"sha": "c74e42263ef1497aacee2fedeaceed19746487b1", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -25,7 +25,6 @@ use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n-use ty::maps::{QueryMsg};\n use ty::TyCtxt;\n use dep_graph::{DepNode};\n use proc_macro;\n@@ -77,6 +76,13 @@ pub struct ProfQDumpParams {\n     pub dump_profq_msg_log:bool,\n }\n \n+#[allow(bad_style)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct QueryMsg {\n+    pub query: &'static str,\n+    pub msg: Option<String>,\n+}\n+\n /// A sequence of these messages induce a trace of query-based incremental compilation.\n /// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n #[derive(Clone,Debug)]"}, {"sha": "6426286ccbc6c3bfb7a0ac2dc5c7176ef9aa2855", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -10,7 +10,7 @@\n \n use super::*;\n use syntax_pos::SpanData;\n-use rustc::ty::maps::QueryMsg;\n+use rustc::util::common::QueryMsg;\n use std::fs::File;\n use std::time::{Duration, Instant};\n use std::collections::hash_map::HashMap;"}, {"sha": "693df0706dcc3f64e9c15421daa16cba23a5f050", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987631d3ba57f9fdfe54f3feed03127c7e6d5c5c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=987631d3ba57f9fdfe54f3feed03127c7e6d5c5c", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let callee_mir = match ty::queries::optimized_mir::try_get(self.tcx,\n+                let callee_mir = match self.tcx.try_get_query::<ty::queries::optimized_mir>(\n                                                                            callsite.location.span,\n                                                                            callsite.callee) {\n                     Ok(callee_mir) if self.should_inline(callsite, callee_mir) => {"}]}