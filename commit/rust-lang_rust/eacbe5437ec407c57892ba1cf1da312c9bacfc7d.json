{"sha": "eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "node_id": "C_kwDOAAsO6NoAKGVhY2JlNTQzN2VjNDA3YzU3ODkyYmExY2YxZGEzMTJjOWJhY2ZjN2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-20T05:09:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-20T05:09:01Z"}, "message": "Rollup merge of #100667 - Xiretza:diag-structs-parser-ivd, r=davidtwco\n\nMigrate \"invalid variable declaration\" errors to SessionDiagnostic\n\nAfter seeing the great blog post on Inside Rust, I decided to try my hand at this. Just one diagnostic for now to get used to the workflow and to check if this is the way to do it or if there are any problems.", "tree": {"sha": "ea99c1fa8cea05c23d5093a976bfd73b7ac661bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea99c1fa8cea05c23d5093a976bfd73b7ac661bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjAGxtCRBK7hj4Ov3rIwAAoXkIAKN0mx8QKODe6s+AJD+y2QuL\ndof6XjFZKDwhUrzWBJBkS7oRGBsenKzNEP0fp1KKQ5QIeN/hcfTasS+krH/H+rs/\n9MCCT+KtiA6Xop8r1FoeHH8aST51iaP9ruiXGOER5z7mpBOtXFiW1wrQiJuLckHL\n6KnywqII6rux1ydLJBUjgtjRIKauTRTLTtooqeFk9YXy4dxbgyv7ay2ksUjIkIaW\nJL5TDhFs/HV8UlrceQ4LEYRao8Bxe7yFezUtFLFfiwFOGEJ1dOKAFXOdULdBD714\n9SkxeoQ0/0LQgNRo1A5WH/VOJrMiBJ57pq3Lc6aMfkNC1i90cwcB7XCqHmu4pkw=\n=77sZ\n-----END PGP SIGNATURE-----\n", "payload": "tree ea99c1fa8cea05c23d5093a976bfd73b7ac661bd\nparent 61a529d90236c879bc7d9445dfa18c88a30c3b25\nparent e8499cfadcf17c051a33ab45a414b399f89a0a91\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1660972141 +0200\ncommitter GitHub <noreply@github.com> 1660972141 +0200\n\nRollup merge of #100667 - Xiretza:diag-structs-parser-ivd, r=davidtwco\n\nMigrate \"invalid variable declaration\" errors to SessionDiagnostic\n\nAfter seeing the great blog post on Inside Rust, I decided to try my hand at this. Just one diagnostic for now to get used to the workflow and to check if this is the way to do it or if there are any problems.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "html_url": "https://github.com/rust-lang/rust/commit/eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61a529d90236c879bc7d9445dfa18c88a30c3b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/61a529d90236c879bc7d9445dfa18c88a30c3b25", "html_url": "https://github.com/rust-lang/rust/commit/61a529d90236c879bc7d9445dfa18c88a30c3b25"}, {"sha": "e8499cfadcf17c051a33ab45a414b399f89a0a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8499cfadcf17c051a33ab45a414b399f89a0a91", "html_url": "https://github.com/rust-lang/rust/commit/e8499cfadcf17c051a33ab45a414b399f89a0a91"}], "stats": {"total": 69, "additions": 50, "deletions": 19}, "files": [{"sha": "2d378013dd053d86826b36f19b22ebe80a3ab8dc", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "patch": "@@ -32,3 +32,12 @@ parser_incorrect_use_of_await =\n parser_in_in_typo =\n     expected iterable, found keyword `in`\n     .suggestion = remove the duplicated `in`\n+\n+parser_invalid_variable_declaration =\n+    invalid variable declaration\n+\n+parser_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parser_missing_let_before_mut = missing keyword\n+parser_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parser_use_let_not_var = write `let` instead of `var` to introduce a new variable"}, {"sha": "eeedfd157bebe75e5d1b264b331cb27fbdd6f801", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "patch": "@@ -334,6 +334,35 @@ struct InInTypo {\n     sugg_span: Span,\n }\n \n+#[derive(SessionDiagnostic)]\n+#[error(parser::invalid_variable_declaration)]\n+pub struct InvalidVariableDeclaration {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sub: InvalidVariableDeclarationSub,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum InvalidVariableDeclarationSub {\n+    #[suggestion(\n+        parser::switch_mut_let_order,\n+        applicability = \"maybe-incorrect\",\n+        code = \"let mut\"\n+    )]\n+    SwitchMutLetOrder(#[primary_span] Span),\n+    #[suggestion(\n+        parser::missing_let_before_mut,\n+        applicability = \"machine-applicable\",\n+        code = \"let mut\"\n+    )]\n+    MissingLet(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotAuto(#[primary_span] Span),\n+    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    UseLetNotVar(#[primary_span] Span),\n+}\n+\n // SnapshotParser is used to create a snapshot of the parser\n // without causing duplicate errors being emitted when the `Parser`\n // is dropped."}, {"sha": "875636bdc2879871ec9df2cbc299019cee647411", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eacbe5437ec407c57892ba1cf1da312c9bacfc7d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=eacbe5437ec407c57892ba1cf1da312c9bacfc7d", "patch": "@@ -1,5 +1,7 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::{AttemptLocalParseRecovery, Error};\n+use super::diagnostics::{\n+    AttemptLocalParseRecovery, Error, InvalidVariableDeclaration, InvalidVariableDeclarationSub,\n+};\n use super::expr::LhsExpr;\n use super::pat::RecoverComma;\n use super::path::PathStyle;\n@@ -58,28 +60,22 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(kw::Mut) && self.is_keyword_ahead(1, &[kw::Let]) {\n             self.bump();\n             let mut_let_span = lo.to(self.token.span);\n-            self.struct_span_err(mut_let_span, \"invalid variable declaration\")\n-                .span_suggestion(\n-                    mut_let_span,\n-                    \"switch the order of `mut` and `let`\",\n-                    \"let mut\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.sess.emit_err(InvalidVariableDeclaration {\n+                span: mut_let_span,\n+                sub: InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n+            });\n         }\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n             self.parse_local_mk(lo, attrs, capture_semi, force_collect)?\n         } else if self.is_kw_followed_by_ident(kw::Mut) {\n-            self.recover_stmt_local(lo, attrs, \"missing keyword\", \"let mut\")?\n+            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n         } else if self.is_kw_followed_by_ident(kw::Auto) {\n             self.bump(); // `auto`\n-            let msg = \"write `let` instead of `auto` to introduce a new variable\";\n-            self.recover_stmt_local(lo, attrs, msg, \"let\")?\n+            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::UseLetNotAuto)?\n         } else if self.is_kw_followed_by_ident(sym::var) {\n             self.bump(); // `var`\n-            let msg = \"write `let` instead of `var` to introduce a new variable\";\n-            self.recover_stmt_local(lo, attrs, msg, \"let\")?\n+            self.recover_stmt_local(lo, attrs, InvalidVariableDeclarationSub::UseLetNotVar)?\n         } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n@@ -217,13 +213,10 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         attrs: AttrWrapper,\n-        msg: &str,\n-        sugg: &str,\n+        subdiagnostic: fn(Span) -> InvalidVariableDeclarationSub,\n     ) -> PResult<'a, Stmt> {\n         let stmt = self.recover_local_after_let(lo, attrs)?;\n-        self.struct_span_err(lo, \"invalid variable declaration\")\n-            .span_suggestion(lo, msg, sugg, Applicability::MachineApplicable)\n-            .emit();\n+        self.sess.emit_err(InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n         Ok(stmt)\n     }\n "}]}