{"sha": "9f6f001988ae32e06b3abee5d869ad921fd614ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNmYwMDE5ODhhZTMyZTA2YjNhYmVlNWQ4NjlhZDkyMWZkNjE0YWU=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-04-02T04:45:38Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-04-02T07:28:16Z"}, "message": "same_item_push: Don't trigger same_item_push if the vec is used in the loop body", "tree": {"sha": "31b36b23d5a36fe86b70a91768f29706832a6ade", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31b36b23d5a36fe86b70a91768f29706832a6ade"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f6f001988ae32e06b3abee5d869ad921fd614ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f6f001988ae32e06b3abee5d869ad921fd614ae", "html_url": "https://github.com/rust-lang/rust/commit/9f6f001988ae32e06b3abee5d869ad921fd614ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f6f001988ae32e06b3abee5d869ad921fd614ae/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72eb60a28b4cc9767987919d54fffb23f76afaee", "url": "https://api.github.com/repos/rust-lang/rust/commits/72eb60a28b4cc9767987919d54fffb23f76afaee", "html_url": "https://github.com/rust-lang/rust/commit/72eb60a28b4cc9767987919d54fffb23f76afaee"}], "stats": {"total": 144, "additions": 91, "deletions": 53}, "files": [{"sha": "b3d784474c82cc691b90dadf0e14f117d7af5a6f", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 84, "deletions": 53, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9f6f001988ae32e06b3abee5d869ad921fd614ae/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6f001988ae32e06b3abee5d869ad921fd614ae/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=9f6f001988ae32e06b3abee5d869ad921fd614ae", "patch": "@@ -1,11 +1,13 @@\n use super::SAME_ITEM_PUSH;\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::symbol::sym;\n@@ -41,70 +43,94 @@ pub(super) fn check<'tcx>(\n     }\n \n     // Determine whether it is safe to lint the body\n-    let mut same_item_push_visitor = SameItemPushVisitor {\n-        should_lint: true,\n-        vec_push: None,\n-        cx,\n-    };\n+    let mut same_item_push_visitor = SameItemPushVisitor::new(cx);\n     walk_expr(&mut same_item_push_visitor, body);\n-    if same_item_push_visitor.should_lint {\n-        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n-            let vec_ty = cx.typeck_results().expr_ty(vec);\n-            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n-            if cx\n-                .tcx\n-                .lang_items()\n-                .clone_trait()\n-                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-            {\n-                // Make sure that the push does not involve possibly mutating values\n-                match pushed_item.kind {\n-                    ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n-                            // immutable bindings that are initialized with literal or constant\n-                            Res::Local(hir_id) => {\n-                                let node = cx.tcx.hir().get(hir_id);\n-                                if_chain! {\n-                                    if let Node::Binding(pat) = node;\n-                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n-                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n-                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n-                                    if let Some(init) = parent_let_expr.init;\n-                                    then {\n-                                        match init.kind {\n-                                            // immutable bindings that are initialized with literal\n-                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                                            // immutable bindings that are initialized with constant\n-                                            ExprKind::Path(ref path) => {\n-                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n-                                                    emit_lint(cx, vec, pushed_item);\n-                                                }\n+    if_chain! {\n+        if same_item_push_visitor.should_lint();\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push;\n+        let vec_ty = cx.typeck_results().expr_ty(vec);\n+        let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+        if cx\n+            .tcx\n+            .lang_items()\n+            .clone_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]));\n+        then {\n+            // Make sure that the push does not involve possibly mutating values\n+            match pushed_item.kind {\n+                ExprKind::Path(ref qpath) => {\n+                    match cx.qpath_res(qpath, pushed_item.hir_id) {\n+                        // immutable bindings that are initialized with literal or constant\n+                        Res::Local(hir_id) => {\n+                            let node = cx.tcx.hir().get(hir_id);\n+                            if_chain! {\n+                                if let Node::Binding(pat) = node;\n+                                if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                if let Some(init) = parent_let_expr.init;\n+                                then {\n+                                    match init.kind {\n+                                        // immutable bindings that are initialized with literal\n+                                        ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                        // immutable bindings that are initialized with constant\n+                                        ExprKind::Path(ref path) => {\n+                                            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n+                                                emit_lint(cx, vec, pushed_item);\n                                             }\n-                                            _ => {},\n                                         }\n+                                        _ => {},\n                                     }\n                                 }\n-                            },\n-                            // constant\n-                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n-                            _ => {},\n-                        }\n-                    },\n-                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                    _ => {},\n-                }\n+                            }\n+                        },\n+                        // constant\n+                        Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                        _ => {},\n+                    }\n+                },\n+                ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                _ => {},\n             }\n         }\n     }\n }\n \n // Scans the body of the for loop and determines whether lint should be given\n struct SameItemPushVisitor<'a, 'tcx> {\n-    should_lint: bool,\n+    non_deterministic_expr: bool,\n+    multiple_pushes: bool,\n     // this field holds the last vec push operation visited, which should be the only push seen\n     vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n     cx: &'a LateContext<'tcx>,\n+    used_locals: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> SameItemPushVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            non_deterministic_expr: false,\n+            multiple_pushes: false,\n+            vec_push: None,\n+            cx,\n+            used_locals: FxHashSet::default(),\n+        }\n+    }\n+\n+    fn should_lint(&self) -> bool {\n+        if_chain! {\n+            if !self.non_deterministic_expr;\n+            if !self.multiple_pushes;\n+            if let Some((vec, _)) = self.vec_push;\n+            if let Some(hir_id) = path_to_local(vec);\n+            then {\n+                !self.used_locals.contains(&hir_id)\n+            } else {\n+                false\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n@@ -113,9 +139,14 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             // Non-determinism may occur ... don't give a lint\n-            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n+            ExprKind::Loop(..) | ExprKind::Match(..) | ExprKind::If(..) => self.non_deterministic_expr = true,\n             ExprKind::Block(block, _) => self.visit_block(block),\n-            _ => {},\n+            _ => {\n+                if let Some(hir_id) = path_to_local(expr) {\n+                    self.used_locals.insert(hir_id);\n+                }\n+                walk_expr(self, expr);\n+            },\n         }\n     }\n \n@@ -140,7 +171,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n                 self.vec_push = vec_push_option;\n             } else {\n                 // There are multiple pushes ... don't lint\n-                self.should_lint = false;\n+                self.multiple_pushes = true;\n             }\n         }\n     }"}, {"sha": "9d420ec672a26da73e827a620c36de4ddeb3bc75", "filename": "tests/ui/same_item_push.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f6f001988ae32e06b3abee5d869ad921fd614ae/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f6f001988ae32e06b3abee5d869ad921fd614ae/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=9f6f001988ae32e06b3abee5d869ad921fd614ae", "patch": "@@ -148,4 +148,11 @@ fn main() {\n         };\n         vec.push(item);\n     }\n+\n+    // Fix #6987\n+    let mut vec = Vec::new();\n+    for _ in 0..10 {\n+        vec.push(1);\n+        vec.extend(&[2]);\n+    }\n }"}]}