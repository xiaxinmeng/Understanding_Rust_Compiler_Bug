{"sha": "f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYjU1ODNmNjA4NGM2OGNmMWY0NmExNTU0ZGI3ZWUzZjAyNTJlYzE=", "commit": {"author": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-07T20:44:57Z"}, "committer": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-19T17:45:16Z"}, "message": "add trait structs and other changes from V to local", "tree": {"sha": "eb36b1988446444e6398cd9874ed42e729af2463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb36b1988446444e6398cd9874ed42e729af2463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "html_url": "https://github.com/rust-lang/rust/commit/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "html_url": "https://github.com/rust-lang/rust/commit/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c"}], "stats": {"total": 140, "additions": 84, "deletions": 56}, "files": [{"sha": "72d7b473204f822ceedf09710d97a96c30df4bc3", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "patch": "@@ -19,7 +19,7 @@ use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir, Local};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -208,9 +208,9 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     (regioncx, polonius_output, closure_region_requirements)\n }\n \n-fn dump_mir_results<'a, 'gcx, 'tcx, V: Idx>(\n+fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResults<V>,\n+    liveness: &LivenessResults<Local>,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -406,7 +406,7 @@ impl ToRegionVid for RegionVid {\n     }\n }\n \n-fn live_variable_set<V: Idx>(regular: &LocalSet<V>, drops: &LocalSet<V>) -> String {\n+fn live_variable_set(regular: &LocalSet<Local>, drops: &LocalSet<Local>) -> String {\n     // sort and deduplicate:\n     let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n "}, {"sha": "e70c87e8401c964e16e3caae2171d71a1da7d79a", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "patch": "@@ -34,10 +34,10 @@ use super::TypeChecker;\n ///\n /// NB. This computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'gcx, 'tcx, V: Idx>(\n+pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    liveness: &LivenessResults<V>,\n+    liveness: &LivenessResults<Local>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n@@ -55,17 +55,16 @@ pub(super) fn generate<'gcx, 'tcx, V: Idx>(\n     }\n }\n \n-struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V>\n+struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n where\n     'typeck: 'gen,\n     'flow: 'gen,\n     'tcx: 'typeck + 'flow,\n     'gcx: 'tcx,\n-    V: Idx + 'gen,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults<V>,\n+    liveness: &'gen LivenessResults<Local>,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n@@ -76,7 +75,7 @@ struct DropData<'tcx> {\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx, V: Idx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V> {\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n     /// Liveness constraints:\n     ///\n     /// > If a variable V is live at point P, then all regions R in the type of V"}, {"sha": "f1091e40c77a5f54776187d2250da6c48dfb5216", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "patch": "@@ -126,14 +126,14 @@ fn self_arg() -> Local {\n     Local::new(1)\n }\n \n-struct SuspensionPoint<V: Idx> {\n+struct SuspensionPoint {\n     state: u32,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n-    storage_liveness: liveness::LocalSet<V>,\n+    storage_liveness: liveness::LocalSet<Local>,\n }\n \n-struct TransformVisitor<'a, 'tcx: 'a, V: Idx> {\n+struct TransformVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: &'tcx Substs<'tcx>,\n@@ -145,16 +145,16 @@ struct TransformVisitor<'a, 'tcx: 'a, V: Idx> {\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    storage_liveness: HashMap<BasicBlock, liveness::LocalSet<V>>,\n+    storage_liveness: HashMap<BasicBlock, liveness::LocalSet<Local>>,\n \n     // A list of suspension points, generated during the transform\n-    suspension_points: Vec<SuspensionPoint<V>>,\n+    suspension_points: Vec<SuspensionPoint>,\n \n     // The original RETURN_PLACE local\n     new_ret_local: Local,\n }\n \n-impl<'a, 'tcx, V: Idx> TransformVisitor<'a, 'tcx, V> {\n+impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     // Make a GeneratorState rvalue\n     fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n@@ -191,7 +191,7 @@ impl<'a, 'tcx, V: Idx> TransformVisitor<'a, 'tcx, V> {\n     }\n }\n \n-impl<'a, 'tcx, V: Idx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx, V> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext<'tcx>,\n@@ -317,9 +317,9 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     new_ret_local\n }\n \n-struct StorageIgnored<V: Idx>(liveness::LocalSet<V>);\n+struct StorageIgnored(liveness::LocalSet<Local>);\n \n-impl<'tcx, V: Idx> Visitor<'tcx> for StorageIgnored<V> {\n+impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     fn visit_statement(&mut self,\n                        _block: BasicBlock,\n                        statement: &Statement<'tcx>,\n@@ -332,9 +332,9 @@ impl<'tcx, V: Idx> Visitor<'tcx> for StorageIgnored<V> {\n     }\n }\n \n-struct BorrowedLocals<V: Idx>(liveness::LocalSet<V>);\n+struct BorrowedLocals(liveness::LocalSet<Local>);\n \n-fn mark_as_borrowed<'tcx, V: Idx>(place: &Place<'tcx>, locals: &mut BorrowedLocals<V>) {\n+fn mark_as_borrowed<'tcx, V: Idx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     match *place {\n         Place::Local(l) => { locals.0.add(&l); },\n         Place::Static(..) => (),\n@@ -349,7 +349,7 @@ fn mark_as_borrowed<'tcx, V: Idx>(place: &Place<'tcx>, locals: &mut BorrowedLoca\n     }\n }\n \n-impl<'tcx, V: Idx> Visitor<'tcx> for BorrowedLocals<V> {\n+impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n@@ -361,12 +361,12 @@ impl<'tcx, V: Idx> Visitor<'tcx> for BorrowedLocals<V> {\n     }\n }\n \n-fn locals_live_across_suspend_points<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n                                                source: MirSource,\n                                                movable: bool) ->\n-                                               (liveness::LocalSet<V>,\n-                                                HashMap<BasicBlock, liveness::LocalSet<V>>) {\n+                                               (liveness::LocalSet<Local>,\n+                                                HashMap<BasicBlock, liveness::LocalSet<Local>>) {\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n@@ -460,15 +460,15 @@ fn locals_live_across_suspend_points<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tc\n     (set, storage_liveness_map)\n }\n \n-fn compute_layout<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource,\n                             upvars: Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n-        HashMap<BasicBlock, liveness::LocalSet<V>>)\n+        HashMap<BasicBlock, liveness::LocalSet<Local>>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n@@ -524,10 +524,10 @@ fn compute_layout<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &mut Mir<'tcx>,\n                            cases: Vec<(u32, BasicBlock)>,\n-                           transform: &TransformVisitor<'a, 'tcx, V>,\n+                           transform: &TransformVisitor<'a, 'tcx>,\n                            default: TerminatorKind<'tcx>) {\n     let default_block = insert_term_block(mir, default);\n \n@@ -608,9 +608,9 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn create_generator_drop_shim<'a, 'tcx, V: Idx>(\n+fn create_generator_drop_shim<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                transform: &TransformVisitor<'a, 'tcx, V>,\n+                transform: &TransformVisitor<'a, 'tcx>,\n                 def_id: DefId,\n                 source: MirSource,\n                 gen_ty: Ty<'tcx>,\n@@ -719,9 +719,9 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_block\n }\n \n-fn create_generator_resume_function<'a, 'tcx, V: Idx>(\n+fn create_generator_resume_function<'a, 'tcx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        transform: TransformVisitor<'a, 'tcx, V>,\n+        transform: TransformVisitor<'a, 'tcx>,\n         def_id: DefId,\n         source: MirSource,\n         mir: &mut Mir<'tcx>) {\n@@ -790,10 +790,10 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'a, 'tcx, F, V: Idx>(mir: &mut Mir<'tcx>,\n-                          transform: &TransformVisitor<'a, 'tcx, V>,\n+fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n+                          transform: &TransformVisitor<'a, 'tcx>,\n                           target: F) -> Vec<(u32, BasicBlock)>\n-    where F: Fn(&SuspensionPoint<V>) -> Option<BasicBlock> {\n+    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n     let source_info = source_info(mir);\n \n     transform.suspension_points.iter().filter_map(|point| {"}, {"sha": "811e0e55909375e78fcd27658bb70b44aaaa1ae5", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2b5583f6084c68cf1f46a1554db7ee3f0252ec1/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=f2b5583f6084c68cf1f46a1554db7ee3f0252ec1", "patch": "@@ -40,6 +40,7 @@ use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::work_queue::WorkQueue;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n use rustc::ty::item_path;\n+use rustc::mir::Local;\n use rustc::mir::visit::MirVisitable;\n use std::path::{Path, PathBuf};\n use std::fs;\n@@ -61,6 +62,28 @@ pub struct LivenessResult<V: Idx> {\n     pub outs: IndexVec<BasicBlock, LocalSet<V>>,\n }\n \n+trait LiveVariableMap {\n+    type LiveVar;\n+\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local;\n+}\n+\n+#[derive(Eq, PartialEq, Clone)]\n+struct IdentityMap;\n+\n+impl LiveVariableMap for IdentityMap {\n+    type LiveVar = Local;\n+\n+    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n+        Some(local)\n+    }\n+\n+    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n+        local\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct LivenessMode {\n     /// If true, then we will consider \"regular uses\" of a variable to be live.\n@@ -91,7 +114,7 @@ pub struct LivenessResults<V: Idx> {\n }\n \n impl<V: Idx> LivenessResults<V> {\n-    pub fn compute<'tcx>(mir: &Mir<'tcx>) -> LivenessResults<V> {\n+    pub fn compute<'tcx>(mir: &Mir<'tcx>, map: &dyn LiveVariableMap<LiveVar = V>) -> LivenessResults<V> {\n         LivenessResults {\n             regular: liveness_of_locals(\n                 &mir,\n@@ -187,6 +210,7 @@ where V:Idx\n             defs_uses: DefsUses {\n                 defs: LocalSet::new_empty(locals),\n                 uses: LocalSet::new_empty(locals),\n+                map: &IdentityMap {},\n             },\n         };\n         // Visit the various parts of the basic block in reverse. If we go\n@@ -283,25 +307,26 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n     }\n }\n \n-struct DefsUsesVisitor<V: Idx> {\n+struct DefsUsesVisitor<'lv> {\n     mode: LivenessMode,\n-    defs_uses: DefsUses<V>,\n+    defs_uses: DefsUses<'lv>,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses<V: Idx>\n+struct DefsUses<'lv>\n {\n-    defs: LocalSet<V>,\n-    uses: LocalSet<V>,\n+    defs: LocalSet<Local>,\n+    uses: LocalSet<Local>,\n+    map: &'lv dyn LiveVariableMap<LiveVar=Local>,\n }\n \n-impl<V: Idx> DefsUses<V> {\n+impl<'lv> DefsUses<'lv> {\n     fn clear(&mut self) {\n         self.uses.clear();\n         self.defs.clear();\n     }\n \n-    fn apply(&self, bits: &mut LocalSet<V>) -> bool {\n+    fn apply(&self, bits: &mut LocalSet<Local>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n@@ -315,8 +340,10 @@ impl<V: Idx> DefsUses<V> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        self.uses.remove(&index);\n-        self.defs.add(&index);\n+        if let Some(v_index) = self.map.from_local(index) {\n+            self.uses.remove(&v_index);\n+            self.defs.add(&v_index);\n+        }\n     }\n \n     fn add_use(&mut self, index: Local) {\n@@ -330,30 +357,31 @@ impl<V: Idx> DefsUses<V> {\n         //     X = 5\n         //     // Defs = {}, Uses = {X}\n         //     use(X)\n-        self.defs.remove(&index);\n-        self.uses.add(&index);\n+        if let Some(v_index) = self.map.from_local(index) {\n+            self.defs.remove(&v_index);\n+            self.uses.add(&v_index);\n+        }\n     }\n }\n \n-impl<V> DefsUsesVisitor<V>\n-where V: Idx\n+impl<'lv> DefsUsesVisitor<'lv>\n {\n     /// Update `bits` with the effects of `value` and call `callback`. We\n     /// should always visit in reverse order. This method assumes that we have\n     /// not visited anything before; if you have, clear `bits` first.\n     fn update_bits_and_do_callback<'tcx, OP>(&mut self, location: Location,\n-                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet<V>,\n+                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet<Local>,\n                                              callback: &mut OP)\n     where\n-        OP: FnMut(Location, &LocalSet<V>),\n+        OP: FnMut(Location, &LocalSet<Local>),\n     {\n         value.apply(location, self);\n         self.defs_uses.apply(bits);\n         callback(location, bits);\n     }\n }\n \n-impl<'tcx, V: Idx> Visitor<'tcx> for DefsUsesVisitor<V> {\n+impl<'tcx, 'lv> Visitor<'tcx> for DefsUsesVisitor<'lv> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n         match categorize(context, self.mode) {\n             Some(DefUse::Def) => {\n@@ -369,12 +397,13 @@ impl<'tcx, V: Idx> Visitor<'tcx> for DefsUsesVisitor<V> {\n     }\n }\n \n-fn block<'tcx, V: Idx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses<V> {\n+fn block<'tcx, 'lv>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses<'lv> {\n     let mut visitor = DefsUsesVisitor {\n         mode,\n         defs_uses: DefsUses {\n             defs: LocalSet::new_empty(locals),\n             uses: LocalSet::new_empty(locals),\n+            map: &IdentityMap {},\n         },\n     };\n \n@@ -398,7 +427,7 @@ pub fn dump_mir<'a, 'tcx, V: Idx>(\n     pass_name: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult<Local>,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -442,7 +471,7 @@ pub fn write_mir_fn<'a, 'tcx, V :Idx>(\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LocalSet<V>>| {\n             let live: Vec<String> = mir.local_decls\n                 .indices()\n                 .filter(|i| result[block].contains(i))"}]}