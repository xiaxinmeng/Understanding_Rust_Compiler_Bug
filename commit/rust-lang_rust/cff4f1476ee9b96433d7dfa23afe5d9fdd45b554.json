{"sha": "cff4f1476ee9b96433d7dfa23afe5d9fdd45b554", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZjRmMTQ3NmVlOWI5NjQzM2Q3ZGZhMjNhZmU1ZDlmZGQ0NWI1NTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-25T04:10:05Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-25T04:42:21Z"}, "message": "rustc: Less copy", "tree": {"sha": "d6d4debfa8e7091f94819d95f69150f06a52f00c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6d4debfa8e7091f94819d95f69150f06a52f00c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554", "html_url": "https://github.com/rust-lang/rust/commit/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d33e308ac8bd4e59a54feaddf301488c215f90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d33e308ac8bd4e59a54feaddf301488c215f90b", "html_url": "https://github.com/rust-lang/rust/commit/2d33e308ac8bd4e59a54feaddf301488c215f90b"}], "stats": {"total": 287, "additions": 148, "deletions": 139}, "files": [{"sha": "bd3b96d73eb90919c5ee06ce4f06527d7fde3855", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 148, "deletions": 139, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cff4f1476ee9b96433d7dfa23afe5d9fdd45b554/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cff4f1476ee9b96433d7dfa23afe5d9fdd45b554", "patch": "@@ -481,161 +481,170 @@ fn wild() -> @pat {\n     @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n }\n \n-fn specialize(cx: @MatchCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n+fn specialize(cx: @MatchCheckCtxt, +r: ~[@pat], ctor_id: ctor, arity: uint,\n               left_ty: ty::t) -> Option<~[@pat]> {\n-    let r0 = raw_pat(r[0]);\n-    match /*bad*/copy r0.node {\n-      pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n-                                   vec::tail(r))),\n-      pat_ident(_, _, _) => {\n-        match cx.tcx.def_map.find(r0.id) {\n-          Some(def_variant(_, id)) => {\n-            if variant(id) == ctor_id { Some(vec::tail(r)) }\n-            else { None }\n-          }\n-          Some(def_const(did)) => {\n-            let const_expr = lookup_const_by_id(cx.tcx, did).get();\n-            let e_v = eval_const_expr(cx.tcx, const_expr);\n-            let match_ = match ctor_id {\n-                val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n-                range(ref c_lo, ref c_hi) => {\n-                    compare_const_vals((*c_lo), e_v) >= 0 &&\n-                        compare_const_vals((*c_hi), e_v) <= 0\n+    // Sad, but I can't get rid of this easily\n+    let mut r0 = copy *raw_pat(r[0]);\n+    match r0 {\n+        pat{id: pat_id, node: n, span: pat_span} =>\n+            match n {\n+            pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n+                                         vec::tail(r))),\n+            pat_ident(_, _, _) => {\n+                match cx.tcx.def_map.find(pat_id) {\n+                    Some(def_variant(_, id)) => {\n+                        if variant(id) == ctor_id { Some(vec::tail(r)) }\n+                        else { None }\n+                    }\n+                    Some(def_const(did)) => {\n+                        let const_expr =\n+                            lookup_const_by_id(cx.tcx, did).get();\n+                        let e_v = eval_const_expr(cx.tcx, const_expr);\n+                        let match_ = match ctor_id {\n+                            val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                            range(ref c_lo, ref c_hi) => {\n+                                compare_const_vals((*c_lo), e_v) >= 0 &&\n+                                    compare_const_vals((*c_hi), e_v) <= 0\n+                            }\n+                            single => true,\n+                            _ => fail ~\"type error\"\n+                        };\n+                        if match_ { Some(vec::tail(r)) } else { None }\n+                    }\n+                    _ => Some(vec::append(vec::from_elem(arity, wild()),\n+                                          vec::tail(r)))\n                 }\n-                single => true,\n-                _ => fail ~\"type error\"\n-            };\n-            if match_ { Some(vec::tail(r)) } else { None }\n-          }\n-          _ => Some(vec::append(vec::from_elem(arity, wild()), vec::tail(r)))\n-        }\n-      }\n-      pat_enum(_, args) => {\n-        match cx.tcx.def_map.get(r0.id) {\n-          def_variant(_, id) if variant(id) == ctor_id => {\n-            let args = match args {\n-              Some(args) => args,\n-              None => vec::from_elem(arity, wild())\n-            };\n-            Some(vec::append(args, vec::tail(r)))\n-          }\n-          def_variant(_, _) => None,\n-          def_struct(*) => {\n-            // XXX: Is this right? --pcw\n-            let new_args;\n-            match args {\n-              Some(args) => new_args = args,\n-              None => new_args = vec::from_elem(arity, wild())\n-            }\n-            Some(vec::append(new_args, vec::tail(r)))\n-          }\n-          _ => None\n-        }\n-      }\n-      pat_rec(flds, _) => {\n-        let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n-            ty::ty_rec(flds) => flds,\n-            _ => fail ~\"bad type for pat_rec\"\n-        };\n-        let args = vec::map(ty_flds, |ty_fld| {\n-            match vec::find(flds, |f| f.ident == ty_fld.ident ) {\n-              Some(f) => f.pat,\n-              _ => wild()\n             }\n-        });\n-        Some(vec::append(args, vec::tail(r)))\n-      }\n-      pat_struct(_, flds, _) => {\n-        // Is this a struct or an enum variant?\n-        match cx.tcx.def_map.get(r0.id) {\n-            def_variant(_, variant_id) => {\n-                if variant(variant_id) == ctor_id {\n-                    // XXX: Is this right? --pcw\n-                    let args = flds.map(|ty_field| {\n-                        match vec::find(flds, |f| f.ident == ty_field.ident) {\n-                            Some(f) => f.pat,\n-                            _ => wild()\n+            pat_enum(_, args) => {\n+                match cx.tcx.def_map.get(pat_id) {\n+                    def_variant(_, id) if variant(id) == ctor_id => {\n+                        let args = match args {\n+                            Some(args) => args,\n+                            None => vec::from_elem(arity, wild())\n+                        };\n+                        Some(vec::append(args, vec::tail(r)))\n+                    }\n+                    def_variant(_, _) => None,\n+                    def_struct(*) => {\n+                        // XXX: Is this right? --pcw\n+                        let new_args;\n+                        match args {\n+                            Some(args) => new_args = args,\n+                            None => new_args = vec::from_elem(arity, wild())\n                         }\n-                    });\n-                    Some(vec::append(args, vec::tail(r)))\n-                } else {\n-                    None\n+                        Some(vec::append(new_args, vec::tail(r)))\n+                    }\n+                    _ => None\n                 }\n             }\n-            _ => {\n-                // Grab the class data that we care about.\n-                let class_fields, class_id;\n-                match ty::get(left_ty).sty {\n-                    ty::ty_struct(cid, _) => {\n-                        class_id = cid;\n-                        class_fields = ty::lookup_struct_fields(cx.tcx,\n-                                                               class_id);\n+            pat_rec(ref flds, _) => {\n+                let ty_flds = match /*bad*/copy ty::get(left_ty).sty {\n+                    ty::ty_rec(flds) => flds,\n+                    _ => fail ~\"bad type for pat_rec\"\n+                };\n+                let args = vec::map(ty_flds, |ty_fld| {\n+                    match flds.find(|f| f.ident == ty_fld.ident) {\n+                        Some(f) => f.pat,\n+                        _ => wild()\n+                    }\n+                });\n+                Some(vec::append(args, vec::tail(r)))\n+            }\n+            pat_struct(_, ref flds, _) => {\n+                // Is this a struct or an enum variant?\n+                match cx.tcx.def_map.get(pat_id) {\n+                    def_variant(_, variant_id) => {\n+                        if variant(variant_id) == ctor_id {\n+                            // XXX: Is this right? --pcw\n+                            let args = flds.map(|ty_field| {\n+                                match flds.find(|f|\n+                                                f.ident == ty_field.ident) {\n+                                    Some(f) => f.pat,\n+                                    _ => wild()\n+                                }\n+                            });\n+                            Some(vec::append(args, vec::tail(r)))\n+                        } else {\n+                            None\n+                        }\n                     }\n                     _ => {\n-                        cx.tcx.sess.span_bug(r0.span, ~\"struct pattern \\\n-                                                        didn't resolve to a \\\n-                                                        struct\");\n+                        // Grab the class data that we care about.\n+                        let class_fields, class_id;\n+                        match ty::get(left_ty).sty {\n+                            ty::ty_struct(cid, _) => {\n+                                class_id = cid;\n+                                class_fields =\n+                                    ty::lookup_struct_fields(cx.tcx,\n+                                                             class_id);\n+                            }\n+                            _ => {\n+                                cx.tcx.sess.span_bug(pat_span,\n+                                ~\"struct pattern didn't resolve to a struct\");\n+                            }\n+                        }\n+                        let args = vec::map(class_fields, |class_field| {\n+                            match flds.find(|f|\n+                                            f.ident == class_field.ident) {\n+                                Some(f) => f.pat,\n+                                _ => wild()\n+                            }\n+                        });\n+                        Some(vec::append(args, vec::tail(r)))\n                     }\n                 }\n-                let args = vec::map(class_fields, |class_field| {\n-                    match vec::find(flds, |f| f.ident == class_field.ident ) {\n-                      Some(f) => f.pat,\n-                      _ => wild()\n+            }\n+            pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n+            pat_box(a) | pat_uniq(a) | pat_region(a) =>\n+                Some(vec::append(~[a], vec::tail(r))),\n+            pat_lit(expr) => {\n+                let e_v = eval_const_expr(cx.tcx, expr);\n+                let match_ = match ctor_id {\n+                    val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n+                    range(ref c_lo, ref c_hi) => {\n+                        compare_const_vals((*c_lo), e_v) >= 0 &&\n+                            compare_const_vals((*c_hi), e_v) <= 0\n                     }\n-                });\n-                Some(vec::append(args, vec::tail(r)))\n+                    single => true,\n+                    _ => fail ~\"type error\"\n+                };\n+                if match_ { Some(vec::tail(r)) } else { None }\n             }\n-        }\n-      }\n-      pat_tup(args) => Some(vec::append(args, vec::tail(r))),\n-      pat_box(a) | pat_uniq(a) | pat_region(a) =>\n-          Some(vec::append(~[a], vec::tail(r))),\n-      pat_lit(expr) => {\n-        let e_v = eval_const_expr(cx.tcx, expr);\n-        let match_ = match ctor_id {\n-          val(ref v) => compare_const_vals(e_v, (*v)) == 0,\n-          range(ref c_lo, ref c_hi) => {\n-            compare_const_vals((*c_lo), e_v) >= 0 &&\n-                compare_const_vals((*c_hi), e_v) <= 0\n-          }\n-          single => true,\n-          _ => fail ~\"type error\"\n-        };\n-        if match_ { Some(vec::tail(r)) } else { None }\n-      }\n-      pat_range(lo, hi) => {\n-        let (c_lo, c_hi) = match ctor_id {\n-          val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n-          range(ref lo, ref hi) => ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n-          single => return Some(vec::tail(r)),\n-          _ => fail ~\"type error\"\n-        };\n-        let v_lo = eval_const_expr(cx.tcx, lo),\n-            v_hi = eval_const_expr(cx.tcx, hi);\n-        let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n+            pat_range(lo, hi) => {\n+                let (c_lo, c_hi) = match ctor_id {\n+                    val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n+                    range(ref lo, ref hi) =>\n+                        ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n+                    single => return Some(vec::tail(r)),\n+                    _ => fail ~\"type error\"\n+                };\n+                let v_lo = eval_const_expr(cx.tcx, lo),\n+                v_hi = eval_const_expr(cx.tcx, hi);\n+                let match_ = compare_const_vals(c_lo, v_lo) >= 0 &&\n                     compare_const_vals(c_hi, v_hi) <= 0;\n-        if match_ { Some(vec::tail(r)) } else { None }\n+          if match_ { Some(vec::tail(r)) } else { None }\n       }\n-      pat_vec(elems, tail) => {\n-        match ctor_id {\n-          vec(_) => {\n-            if elems.len() < arity && tail.is_some() {\n-              // XXX: Bad copy.\n-              Some(vec::append(\n-                vec::append(copy elems, vec::from_elem(\n-                    arity - elems.len(), wild()\n-                )),\n-                vec::tail(r)\n-              ))\n-            } else if elems.len() == arity {\n-              Some(vec::append(elems, vec::tail(r)))\n-            } else {\n-              None\n+            pat_vec(elems, tail) => {\n+                match ctor_id {\n+                    vec(_) => {\n+                        let num_elements = elems.len();\n+                        if num_elements < arity && tail.is_some() {\n+                            Some(vec::append(\n+                                vec::append(elems, vec::from_elem(\n+                                    arity - num_elements, wild()\n+                                )),\n+                                vec::tail(r)\n+                            ))\n+                        } else if num_elements == arity {\n+                            Some(vec::append(elems, vec::tail(r)))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => None\n+                }\n             }\n-          }\n-          _ => None\n         }\n-      }\n     }\n }\n "}]}