{"sha": "83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYTUxZGVlZjViOTJkOTEzMWIxOWU1M2IwZmM1YTFiY2Y5OGY1NjU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-27T22:41:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-08T11:15:10Z"}, "message": "resolve: Model `resolve_legacy_scope` after `resolve_lexical_macro_path_segment`", "tree": {"sha": "f1fee7ed9bece95996888137d9c4ce0e721c7048", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1fee7ed9bece95996888137d9c4ce0e721c7048"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "html_url": "https://github.com/rust-lang/rust/commit/83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e5e0454598b3b81525274b39ea9f57d5f988435", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5e0454598b3b81525274b39ea9f57d5f988435", "html_url": "https://github.com/rust-lang/rust/commit/4e5e0454598b3b81525274b39ea9f57d5f988435"}], "stats": {"total": 181, "additions": 121, "deletions": 60}, "files": [{"sha": "26756e2992600f86f48ec7ae1a36b2c3ab106468", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -1402,8 +1402,6 @@ pub struct Resolver<'a, 'b: 'a> {\n     proc_mac_errors: Vec<macros::ProcMacError>,\n     /// crate-local macro expanded `macro_export` referred to by a module-relative path\n     macro_expanded_macro_export_errors: BTreeSet<(Span, Span)>,\n-    /// macro-expanded `macro_rules` shadowing existing macros\n-    disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1715,7 +1713,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ambiguity_errors: Vec::new(),\n             use_injections: Vec::new(),\n             proc_mac_errors: Vec::new(),\n-            disallowed_shadowing: Vec::new(),\n             macro_expanded_macro_export_errors: BTreeSet::new(),\n \n             arenas,\n@@ -4534,7 +4531,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn report_errors(&mut self, krate: &Crate) {\n-        self.report_shadowing_errors();\n         self.report_with_use_injections(krate);\n         self.report_proc_macro_import(krate);\n         let mut reported_spans = FxHashSet();\n@@ -4572,20 +4568,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n     }\n \n-    fn report_shadowing_errors(&mut self) {\n-        let mut reported_errors = FxHashSet();\n-        for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_legacy_scope(&binding.parent, binding.ident, false).is_some() &&\n-               reported_errors.insert((binding.ident, binding.binding.span)) {\n-                let msg = format!(\"`{}` is already in scope\", binding.ident);\n-                self.session.struct_span_err(binding.binding.span, &msg)\n-                    .note(\"macro-expanded `macro_rules!`s may not shadow \\\n-                           existing macros (see RFC 1560)\")\n-                    .emit();\n-            }\n-        }\n-    }\n-\n     fn report_conflict<'b>(&mut self,\n                        parent: Module,\n                        ident: Ident,"}, {"sha": "3baf581c0dec076c8aad7479ead58825f6a311d6", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -81,9 +81,9 @@ pub enum LegacyScope<'a> {\n // Binding produced by a `macro_rules` item.\n // Not modularized, can shadow previous legacy bindings, etc.\n pub struct LegacyBinding<'a> {\n-    pub binding: &'a NameBinding<'a>,\n-    pub parent: Cell<LegacyScope<'a>>,\n-    pub ident: Ident,\n+    binding: &'a NameBinding<'a>,\n+    parent: Cell<LegacyScope<'a>>,\n+    ident: Ident,\n }\n \n pub struct ProcMacError {\n@@ -784,42 +784,101 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n     }\n \n-    crate fn resolve_legacy_scope(&mut self,\n-                                  mut scope: &'a Cell<LegacyScope<'a>>,\n-                                  ident: Ident,\n-                                  record_used: bool)\n-                                  -> Option<(&'a NameBinding<'a>, FromExpansion)> {\n+    fn resolve_legacy_scope(&mut self,\n+                            scope: &'a Cell<LegacyScope<'a>>,\n+                            ident: Ident,\n+                            record_used: bool)\n+                            -> Option<(&'a NameBinding<'a>, FromExpansion)> {\n         let ident = ident.modern();\n-        let mut relative_depth: u32 = 0;\n+\n+        // Names from inner scope that can't shadow names from outer scopes, e.g.\n+        // macro_rules! mac { ... }\n+        // {\n+        //     define_mac!(); // if this generates another `macro_rules! mac`, then it can't shadow\n+        //                    // the outer `mac` and we have and ambiguity error\n+        //     mac!();\n+        // }\n+        let mut potentially_ambiguous_result: Option<(&NameBinding, FromExpansion)> = None;\n+\n+        // Go through all the scopes and try to resolve the name.\n+        let mut where_to_resolve = scope;\n+        let mut relative_depth = 0u32;\n         loop {\n-            match scope.get() {\n-                LegacyScope::Empty => break,\n-                LegacyScope::Expansion(invocation) => {\n-                    match invocation.expansion.get() {\n-                        LegacyScope::Invocation(_) => scope.set(invocation.legacy_scope.get()),\n-                        LegacyScope::Empty => {\n-                            scope = &invocation.legacy_scope;\n-                        }\n-                        _ => {\n+            let result = match where_to_resolve.get() {\n+                LegacyScope::Binding(legacy_binding) => if ident == legacy_binding.ident {\n+                    Some((legacy_binding.binding, FromExpansion(relative_depth > 0)))\n+                } else {\n+                    None\n+                }\n+                _ => None,\n+            };\n+\n+            macro_rules! continue_search { () => {\n+                where_to_resolve = match where_to_resolve.get() {\n+                    LegacyScope::Binding(binding) => &binding.parent,\n+                    LegacyScope::Invocation(invocation) => {\n+                        relative_depth = relative_depth.saturating_sub(1);\n+                        &invocation.legacy_scope\n+                    }\n+                    LegacyScope::Expansion(invocation) => match invocation.expansion.get() {\n+                        LegacyScope::Empty => &invocation.legacy_scope,\n+                        LegacyScope::Binding(..) | LegacyScope::Expansion(..) => {\n                             relative_depth += 1;\n-                            scope = &invocation.expansion;\n+                            &invocation.expansion\n+                        }\n+                        LegacyScope::Invocation(..) => {\n+                            where_to_resolve.set(invocation.legacy_scope.get());\n+                            where_to_resolve\n                         }\n                     }\n-                }\n-                LegacyScope::Invocation(invocation) => {\n-                    relative_depth = relative_depth.saturating_sub(1);\n-                    scope = &invocation.legacy_scope;\n-                }\n-                LegacyScope::Binding(potential_binding) => {\n-                    if potential_binding.ident == ident {\n-                        if record_used && relative_depth > 0 {\n-                            self.disallowed_shadowing.push(potential_binding);\n+                    LegacyScope::Empty => break, // nowhere else to search\n+                };\n+\n+                continue;\n+            }}\n+\n+            match result {\n+                Some(result) => {\n+                    if !record_used {\n+                        return Some(result);\n+                    }\n+\n+                    // Found a solution that is ambiguous with a previously found solution.\n+                    // Push an ambiguity error for later reporting and\n+                    // return something for better recovery.\n+                    if let Some(previous_result) = potentially_ambiguous_result {\n+                        if result.0.def() != previous_result.0.def() {\n+                            self.ambiguity_errors.push(AmbiguityError {\n+                                span: ident.span,\n+                                name: ident.name,\n+                                b1: previous_result.0,\n+                                b2: result.0,\n+                            });\n+                            return Some(previous_result);\n                         }\n-                        return Some((potential_binding.binding, FromExpansion(relative_depth > 0)));\n                     }\n-                    scope = &potential_binding.parent;\n+\n+                    // Found a solution that's not an ambiguity yet, but is \"suspicious\" and\n+                    // can participate in ambiguities later on.\n+                    // Remember it and go search for other solutions in outer scopes.\n+                    if (result.1).0 {\n+                        potentially_ambiguous_result = Some(result);\n+\n+                        continue_search!();\n+                    }\n+\n+                    // Found a solution that can't be ambiguous.\n+                    return Some(result);\n                 }\n-            };\n+                None => {\n+                    continue_search!();\n+                }\n+            }\n+        }\n+\n+        // Previously found potentially ambiguous result turned out to not be ambiguous after all.\n+        if let Some(previous_result) = potentially_ambiguous_result {\n+            return Some(previous_result);\n         }\n \n         None\n@@ -846,8 +905,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             let check_consistency = |this: &Self, new_def: Def| {\n                 if let Some(def) = def {\n-                    if this.ambiguity_errors.is_empty() && this.disallowed_shadowing.is_empty() &&\n-                       new_def != def && new_def != Def::Err {\n+                    if this.ambiguity_errors.is_empty() && new_def != def && new_def != Def::Err {\n                         // Make sure compilation does not succeed if preferred macro resolution\n                         // has changed after the macro had been expanded. In theory all such\n                         // situations should be reported as ambiguity errors, so this is span-bug."}, {"sha": "bf0a7fa21d37acb3126d0292f8efa1e1b1b74ef2", "filename": "src/test/ui/macros/macro-shadowing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.rs?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -17,14 +17,14 @@ macro_rules! macro_one { () => {} }\n #[macro_use(macro_two)] extern crate two_macros;\n \n macro_rules! m1 { () => {\n-    macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n+    macro_rules! foo { () => {} }\n \n     #[macro_use] //~ ERROR `macro_two` is already in scope\n     extern crate two_macros as __;\n }}\n m1!();\n \n-foo!();\n+foo!(); //~ ERROR `foo` is ambiguous\n \n macro_rules! m2 { () => {\n     macro_rules! foo { () => {} }"}, {"sha": "04f4abc401337c2c06ce99a2162d62fd44529c66", "filename": "src/test/ui/macros/macro-shadowing.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -9,16 +9,27 @@ LL | m1!();\n    |\n    = note: macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\n \n-error: `foo` is already in scope\n+error[E0659]: `foo` is ambiguous\n+  --> $DIR/macro-shadowing.rs:27:1\n+   |\n+LL | foo!(); //~ ERROR `foo` is ambiguous\n+   | ^^^\n+   |\n+note: `foo` could refer to the name defined here\n   --> $DIR/macro-shadowing.rs:20:5\n    |\n-LL |     macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n+LL |     macro_rules! foo { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | m1!();\n    | ------ in this macro invocation\n+note: `foo` could also refer to the name defined here\n+  --> $DIR/macro-shadowing.rs:15:1\n    |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+LL | macro_rules! foo { () => {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: macro-expanded macros do not shadow\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "977b475b11340477b848f393f92d0f90e93f8d03", "filename": "src/test/ui/out-of-order-shadowing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.rs?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n // aux-build:define_macro.rs\n-// error-pattern: `bar` is already in scope\n \n macro_rules! bar { () => {} }\n define_macro!(bar);\n-bar!();\n+bar!(); //~ ERROR `bar` is ambiguous\n \n macro_rules! m { () => { #[macro_use] extern crate define_macro; } }\n m!();"}, {"sha": "424c194d8fce0f3507264828fd3c9ff054433037", "filename": "src/test/ui/out-of-order-shadowing.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83a51deef5b92d9131b19e53b0fc5a1bcf98f565/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr?ref=83a51deef5b92d9131b19e53b0fc5a1bcf98f565", "patch": "@@ -1,11 +1,22 @@\n-error: `bar` is already in scope\n+error[E0659]: `bar` is ambiguous\n   --> $DIR/out-of-order-shadowing.rs:15:1\n    |\n+LL | bar!(); //~ ERROR `bar` is ambiguous\n+   | ^^^\n+   |\n+note: `bar` could refer to the name defined here\n+  --> $DIR/out-of-order-shadowing.rs:14:1\n+   |\n LL | define_macro!(bar);\n    | ^^^^^^^^^^^^^^^^^^^\n+note: `bar` could also refer to the name defined here\n+  --> $DIR/out-of-order-shadowing.rs:13:1\n    |\n-   = note: macro-expanded `macro_rules!`s may not shadow existing macros (see RFC 1560)\n+LL | macro_rules! bar { () => {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: macro-expanded macros do not shadow\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}]}