{"sha": "02a6662e2feec6ecf49d497c78ecf17599223e03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYTY2NjJlMmZlZWM2ZWNmNDlkNDk3Yzc4ZWNmMTc1OTkyMjNlMDM=", "commit": {"author": {"name": "Remy Rakic", "email": "remy.rakic@gmail.com", "date": "2019-11-20T10:13:03Z"}, "committer": {"name": "Remy Rakic", "email": "remy.rakic@gmail.com", "date": "2019-12-06T10:50:02Z"}, "message": "Implement subset errors using Polonius\n\n- switches to using the Naive variant by default\n- emits subset errors or propagates unsatisfied obligations\n  to the caller", "tree": {"sha": "35c235643895c00d51053989e0df18148d82c646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c235643895c00d51053989e0df18148d82c646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02a6662e2feec6ecf49d497c78ecf17599223e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02a6662e2feec6ecf49d497c78ecf17599223e03", "html_url": "https://github.com/rust-lang/rust/commit/02a6662e2feec6ecf49d497c78ecf17599223e03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02a6662e2feec6ecf49d497c78ecf17599223e03/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3dca69bb706a015cf220a80ca35234dd2aeee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3dca69bb706a015cf220a80ca35234dd2aeee6", "html_url": "https://github.com/rust-lang/rust/commit/7a3dca69bb706a015cf220a80ca35234dd2aeee6"}], "stats": {"total": 190, "additions": 172, "deletions": 18}, "files": [{"sha": "5be299f2a9440af37b9e8f824349103f7574a967", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02a6662e2feec6ecf49d497c78ecf17599223e03/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a6662e2feec6ecf49d497c78ecf17599223e03/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=02a6662e2feec6ecf49d497c78ecf17599223e03", "patch": "@@ -300,7 +300,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n         if infcx.tcx.sess.opts.debugging_opts.polonius {\n             let algorithm = env::var(\"POLONIUS_ALGORITHM\")\n-                .unwrap_or_else(|_| String::from(\"Hybrid\"));\n+                .unwrap_or_else(|_| String::from(\"Naive\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();\n             debug!(\"compute_regions: using polonius algorithm {:?}\", algorithm);\n             Some(Rc::new(Output::compute(\n@@ -315,7 +315,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer, polonius_output.clone());\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "574c64aa571cbf103452400c80014c817f55e389", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 170, "deletions": 16, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/02a6662e2feec6ecf49d497c78ecf17599223e03/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a6662e2feec6ecf49d497c78ecf17599223e03/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=02a6662e2feec6ecf49d497c78ecf17599223e03", "patch": "@@ -44,7 +44,7 @@ use crate::borrow_check::{\n \n use self::values::{LivenessValues, RegionValueElements, RegionValues};\n use super::universal_regions::UniversalRegions;\n-use super::ToRegionVid;\n+use super::{PoloniusOutput, ToRegionVid};\n \n mod dump_mir;\n mod graphviz;\n@@ -484,6 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> Option<ClosureRegionRequirements<'tcx>> {\n         self.propagate_constraints(body);\n \n@@ -509,16 +510,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // multiple problems.\n         let mut region_naming = RegionErrorNamingCtx::new();\n \n-        self.check_universal_regions(\n-            infcx,\n-            body,\n-            local_names,\n-            upvars,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-            errors_buffer,\n-            &mut region_naming,\n-        );\n+        // In Polonius mode, the errors about missing universal region relations are in the output\n+        // and need to be emitted or propagated. Otherwise, we need to check whether the\n+        // constraints were too strong, and if so, emit or propagate those errors.\n+        if infcx.tcx.sess.opts.debugging_opts.polonius {\n+            self.check_polonius_subset_errors(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+                polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n+            );\n+        } else {\n+            self.check_universal_regions(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+            );\n+        }\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n \n@@ -1375,6 +1393,111 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n     }\n \n+    /// Checks if Polonius has found any unexpected free region relations.\n+    ///\n+    /// In Polonius terms, a \"subset error\" (or \"illegal subset relation error\") is the equivalent\n+    /// of NLL's \"checking if any region constraints were too strong\": a placeholder origin `'a`\n+    /// was unexpectedly found to be a subset of another placeholder origin `'b`, and means in NLL\n+    /// terms that the \"longer free region\" `'a` outlived the \"shorter free region\" `'b`.\n+    ///\n+    /// More details can be found in this blog post by Niko:\n+    /// http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/\n+    ///\n+    /// In the canonical example\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    ///\n+    /// returning `x` requires `&'a u32 <: &'b u32` and hence we establish (transitively) a\n+    /// constraint that `'a: 'b`. It is an error that we have no evidence that this\n+    /// constraint holds.\n+    ///\n+    /// If `propagated_outlives_requirements` is `Some`, then we will\n+    /// push unsatisfied obligations into there. Otherwise, we'll\n+    /// report them as errors.\n+    fn check_polonius_subset_errors(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+        polonius_output: Rc<PoloniusOutput>,\n+    ) {\n+        debug!(\"check_polonius_subset_errors: {} subset_errors\", polonius_output.subset_errors.len());\n+\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n+\n+        // Similarly to `check_universal_regions`: a free region relation, which was not explicitly\n+        // declared (\"known\") was found by Polonius, so emit an error, or propagate the\n+        // requirements for our caller into the `propagated_outlives_requirements` vector.\n+        //\n+        // Polonius doesn't model regions (\"origins\") as CFG-subsets or durations, but the\n+        // `longer_fr` and `shorter_fr` terminology will still be used here, for consistency with\n+        // the rest of the NLL infrastructure. The \"subset origin\" is the \"longer free region\",\n+        // and the \"superset origin\" is the outlived \"shorter free region\".\n+        //\n+        // Note: Polonius will produce a subset error at every point where the unexpected\n+        // `longer_fr`'s \"placeholder loan\" is contained in the `shorter_fr`. This can be helpful\n+        // for diagnostics in the future, e.g. to point more precisely at the key locations\n+        // requiring this constraint to hold. However, the error and diagnostics code downstream\n+        // expects that these errors are not duplicated (and that they are in a certain order).\n+        // Otherwise, diagnostics messages such as the ones giving names like `'1` to elided or\n+        // anonymous lifetimes for example, could give these names differently, while others like\n+        // the outlives suggestions or the debug output from `#[rustc_regions]` would be\n+        // duplicated. The polonius subset errors are deduplicated here, while keeping the\n+        // CFG-location ordering.\n+        let mut subset_errors: Vec<_> = polonius_output\n+            .subset_errors\n+            .iter()\n+            .flat_map(|(_location, subset_errors)| subset_errors.iter())\n+            .collect();\n+        subset_errors.sort();\n+        subset_errors.dedup();\n+\n+        for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n+            debug!(\"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n+                shorter_fr={:?}\", longer_fr, shorter_fr);\n+\n+            self.report_or_propagate_universal_region_error(\n+                *longer_fr,\n+                *shorter_fr,\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                &mut propagated_outlives_requirements,\n+                &mut outlives_suggestion,\n+                errors_buffer,\n+                region_naming,\n+            );\n+        }\n+\n+        // Handle the placeholder errors as usual, until the chalk-rustc-polonius triumvirate has\n+        // a more complete picture on how to separate this responsibility.\n+        for (fr, fr_definition) in self.definitions.iter_enumerated() {\n+            match fr_definition.origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // handled by polonius above\n+                }\n+\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n+                }\n+\n+                NLLRegionVariableOrigin::Existential { .. } => {\n+                    // nothing to check here\n+                }\n+            }\n+        }\n+\n+        // Emit outlives suggestions\n+        outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n+    }\n+\n     /// Checks the final value for the free region `fr` to see if it\n     /// grew too large. In particular, examine what `end(X)` points\n     /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n@@ -1474,8 +1597,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n+        self.report_or_propagate_universal_region_error(\n+            longer_fr,\n+            shorter_fr,\n+            infcx,\n+            body,\n+            local_names,\n+            upvars,\n+            mir_def_id,\n+            propagated_outlives_requirements,\n+            outlives_suggestion,\n+            errors_buffer,\n+            region_naming,\n+        )\n+    }\n+\n+    fn report_or_propagate_universal_region_error(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+    ) -> Option<ErrorReported> {\n         debug!(\n-            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            \"report_or_propagate_universal_region_error: fr={:?} does not outlive shorter_fr={:?}\",\n             longer_fr, shorter_fr,\n         );\n \n@@ -1484,9 +1636,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n-            {\n-                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+            if let Some(fr_minus) =\n+                self.universal_region_relations.non_local_lower_bound(longer_fr) {\n+                debug!(\"report_or_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n                     self.find_outlives_blame_span(body, longer_fr,\n@@ -1497,7 +1649,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // so slightly larger than `shorter_fr`.\n                 let shorter_fr_plus =\n                     self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n-                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n+                debug!(\n+                    \"report_or_propagate_universal_region_error: shorter_fr_plus={:?}\", shorter_fr_plus\n+                );\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {"}]}