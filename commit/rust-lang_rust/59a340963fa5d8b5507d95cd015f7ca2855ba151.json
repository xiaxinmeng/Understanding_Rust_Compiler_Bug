{"sha": "59a340963fa5d8b5507d95cd015f7ca2855ba151", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YTM0MDk2M2ZhNWQ4YjU1MDdkOTVjZDAxNWY3Y2EyODU1YmExNTE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-06-12T16:47:58Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-08-16T16:08:37Z"}, "message": "Add the Layout of the failed allocation to TryReserveError::AllocError\n\n\u2026 and add a separately-unstable field to force non-exhaustive matching\n(`#[non_exhaustive]` is no implemented yet on enum variants)\nso that we have the option to later expose the allocator\u2019s error value.\n\nCC https://github.com/rust-lang/wg-allocators/issues/23", "tree": {"sha": "20ec73bf0c84a434d0d1192fc4216eb64e1d1161", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ec73bf0c84a434d0d1192fc4216eb64e1d1161"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59a340963fa5d8b5507d95cd015f7ca2855ba151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59a340963fa5d8b5507d95cd015f7ca2855ba151", "html_url": "https://github.com/rust-lang/rust/commit/59a340963fa5d8b5507d95cd015f7ca2855ba151", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59a340963fa5d8b5507d95cd015f7ca2855ba151/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a92c29b2385f4999d4cd9ef7589f1fc07ef9cdfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a92c29b2385f4999d4cd9ef7589f1fc07ef9cdfb", "html_url": "https://github.com/rust-lang/rust/commit/a92c29b2385f4999d4cd9ef7589f1fc07ef9cdfb"}], "stats": {"total": 94, "additions": 52, "deletions": 42}, "files": [{"sha": "f1f22fe48c58ab0c4343a82dbd7ecfd26708c9c3", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -41,25 +41,28 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{Layout, LayoutErr};\n \n-/// Augments `AllocErr` with a CapacityOverflow variant.\n+/// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n-    /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr,\n-}\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<AllocErr> for TryReserveError {\n-    #[inline]\n-    fn from(AllocErr: AllocErr) -> Self {\n-        TryReserveError::AllocErr\n-    }\n+    /// The memory allocator returned an error\n+    AllocError {\n+        /// The layout of allocation request that failed\n+        layout: Layout,\n+\n+        #[doc(hidden)]\n+        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n+            Enable exposing the allocator\u2019s custom error value \\\n+            if an associated type is added in the future: \\\n+            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+        non_exhaustive: (),\n+    },\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]"}, {"sha": "4a48945adc37a4bf313a00fe38cd06fce4296d0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -87,6 +87,7 @@\n #![feature(const_in_array_repeat_expressions)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n+#![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]"}, {"sha": "bc8a38f6b3aad530a9a0eb95d826f1696cd9d8e5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -7,7 +7,7 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n+use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n use crate::collections::TryReserveError::{self, *};\n use crate::boxed::Box;\n \n@@ -413,7 +413,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -494,7 +494,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n@@ -642,8 +642,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n         strategy: ReserveStrategy,\n     ) -> Result<(), TryReserveError> {\n         unsafe {\n-            use crate::alloc::AllocErr;\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -672,12 +670,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            match (&res, fallibility) {\n+            let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                _ => {}\n-            }\n+                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n+                    layout: new_layout,\n+                    non_exhaustive: (),\n+                }),\n+                (Ok(ptr), _) => ptr,\n+            };\n \n-            self.ptr = res?.cast().into();\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n \n             Ok(())"}, {"sha": "55edf56345b59a4cb270129610b0318a9f2163dd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -566,11 +566,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -629,10 +629,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -651,7 +651,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "29a22aa0315b048199497108d04b2bb1eac04e46", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -1121,11 +1121,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1145,7 +1145,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1209,10 +1209,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1231,7 +1231,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1252,7 +1252,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d49b553fc0217a5161e9493220d25003b2221856", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -1168,7 +1168,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1188,7 +1188,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1211,7 +1211,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1256,7 +1256,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1275,7 +1275,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1296,7 +1296,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "a0538986a22421b4fc0cc1cac02738b006f036ef", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -2545,7 +2545,10 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n     match err {\n         hashbrown::CollectionAllocErr::CapacityOverflow => TryReserveError::CapacityOverflow,\n-        hashbrown::CollectionAllocErr::AllocErr { .. } => TryReserveError::AllocErr,\n+        hashbrown::CollectionAllocErr::AllocErr { layout } => TryReserveError::AllocError {\n+            layout,\n+            non_exhaustive: (),\n+        },\n     }\n }\n \n@@ -3405,7 +3408,7 @@ mod test_map {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n \n-        if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+        if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n         } else {\n             panic!(\"usize::MAX / 8 should trigger an OOM!\")\n         }"}, {"sha": "760d92f1d7b0ed589e7ccc597717c0c7ac6fde26", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59a340963fa5d8b5507d95cd015f7ca2855ba151/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=59a340963fa5d8b5507d95cd015f7ca2855ba151", "patch": "@@ -251,6 +251,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_raw_ptr_deref)]\n+#![feature(container_error_extra)]\n #![feature(core_intrinsics)]\n #![feature(custom_test_frameworks)]\n #![feature(doc_alias)]"}]}