{"sha": "27f8c7990e26900e72184f0fbe55da110782be72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZjhjNzk5MGUyNjkwMGU3MjE4NGYwZmJlNTVkYTExMDc4MmJlNzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-19T05:10:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-19T05:10:06Z"}, "message": "Rollup merge of #65485 - ecstatic-morse:const-validation-mismatch-ugliness, r=eddyb\n\nSuppress ICE when validators disagree on `LiveDrop`s in presence of `&mut`\n\nResolves #65394.\n\nThis hack disables the validator mismatch ICE in cases where a `MutBorrow` error has been emitted by both validators, but they don't agree on the number of `LiveDrop` errors.\n\nThe new validator is more conservative about whether a value is moved from in the presence of mutable borrows. For example, the new validator will emit a `LiveDrop` error on the following code.\n\n```rust\nconst _: Vec<i32> = {\n    let mut x = Vec::new();\n    let px = &mut x as *mut _;\n    let y = x;\n    unsafe { ptr::write(px, Vec::new()); }\n    y\n};\n```\n\nThis code is not UB AFAIK (it passes MIRI at least). The current validator does not emit a `LiveDrop` error for `x` upon exit from the initializer. `x` is not actually dropped, so I think this is correct? A proper fix for this would require a new `MaybeInitializedLocals` dataflow analysis or maybe a relaxation of the existing `IndirectlyMutableLocals` one.\n\nr? @RalfJung", "tree": {"sha": "7ee2c3a3fc7da68c2baf5d681f3c37493e6821ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ee2c3a3fc7da68c2baf5d681f3c37493e6821ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f8c7990e26900e72184f0fbe55da110782be72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqpquCRBK7hj4Ov3rIwAAdHIIAImkSd/SYm1zYLi8xBYsCer1\nO/t7ZRC+5g2DGecCSZ8HfHdZm37bGxDmuI14KtwvDG6yNIimThBKLCvEMNb+vYmy\nmQrJZeVl+cwU/zddd3FpPTf/3DSGayrygCpaH1eWZIpeXly1sCqhAIUJOwKcBdMi\ngvbtxqoAbsATaS58VL8x614LYDCQkY/pMbXEWyYQqYd0fs8c7n0UEvq5y7rNTCJh\nsM12e1BOn6U3Jx8h7yxqDgzL9BAoAwqo9+Wd3xf1hcaKfwV2pht27gJsiixCpHW4\n8MskwmNoPt1+GSb2J7hUJy2ohNuzO8bLZ4zm7s9muZTeG2ZT+j9ck3mQpqS0rlk=\n=U/4c\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ee2c3a3fc7da68c2baf5d681f3c37493e6821ce\nparent 99603e99cc1ab0260c5bdd4e752e876af7c390c0\nparent af691de9c1d9923e8a6b7965d1eebf21e1d87ad2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571461806 +0200\ncommitter GitHub <noreply@github.com> 1571461806 +0200\n\nRollup merge of #65485 - ecstatic-morse:const-validation-mismatch-ugliness, r=eddyb\n\nSuppress ICE when validators disagree on `LiveDrop`s in presence of `&mut`\n\nResolves #65394.\n\nThis hack disables the validator mismatch ICE in cases where a `MutBorrow` error has been emitted by both validators, but they don't agree on the number of `LiveDrop` errors.\n\nThe new validator is more conservative about whether a value is moved from in the presence of mutable borrows. For example, the new validator will emit a `LiveDrop` error on the following code.\n\n```rust\nconst _: Vec<i32> = {\n    let mut x = Vec::new();\n    let px = &mut x as *mut _;\n    let y = x;\n    unsafe { ptr::write(px, Vec::new()); }\n    y\n};\n```\n\nThis code is not UB AFAIK (it passes MIRI at least). The current validator does not emit a `LiveDrop` error for `x` upon exit from the initializer. `x` is not actually dropped, so I think this is correct? A proper fix for this would require a new `MaybeInitializedLocals` dataflow analysis or maybe a relaxation of the existing `IndirectlyMutableLocals` one.\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f8c7990e26900e72184f0fbe55da110782be72", "html_url": "https://github.com/rust-lang/rust/commit/27f8c7990e26900e72184f0fbe55da110782be72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f8c7990e26900e72184f0fbe55da110782be72/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99603e99cc1ab0260c5bdd4e752e876af7c390c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/99603e99cc1ab0260c5bdd4e752e876af7c390c0", "html_url": "https://github.com/rust-lang/rust/commit/99603e99cc1ab0260c5bdd4e752e876af7c390c0"}, {"sha": "af691de9c1d9923e8a6b7965d1eebf21e1d87ad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/af691de9c1d9923e8a6b7965d1eebf21e1d87ad2", "html_url": "https://github.com/rust-lang/rust/commit/af691de9c1d9923e8a6b7965d1eebf21e1d87ad2"}], "stats": {"total": 100, "additions": 83, "deletions": 17}, "files": [{"sha": "98d5487870a4de609eb01dfc2ce466d57415198e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27f8c7990e26900e72184f0fbe55da110782be72/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f8c7990e26900e72184f0fbe55da110782be72/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=27f8c7990e26900e72184f0fbe55da110782be72", "patch": "@@ -14,6 +14,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(core_intrinsics)]\n #![feature(const_fn)]\n #![feature(decl_macro)]\n+#![feature(drain_filter)]\n #![feature(exhaustive_patterns)]\n #![feature(never_type)]\n #![feature(specialization)]"}, {"sha": "da1abb9747c1a7ef5cff597176234cc5c8905557", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/27f8c7990e26900e72184f0fbe55da110782be72/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f8c7990e26900e72184f0fbe55da110782be72/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=27f8c7990e26900e72184f0fbe55da110782be72", "patch": "@@ -1024,23 +1024,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             new_errors.dedup();\n \n             if self.errors != new_errors {\n-                error!(\"old validator: {:?}\", self.errors);\n-                error!(\"new validator: {:?}\", new_errors);\n-\n-                // ICE on nightly if the validators do not emit exactly the same errors.\n-                // Users can supress this panic with an unstable compiler flag (hopefully after\n-                // filing an issue).\n-                let opts = &self.tcx.sess.opts;\n-                let trigger_ice = opts.unstable_features.is_nightly_build()\n-                    && !opts.debugging_opts.suppress_const_validation_back_compat_ice;\n-\n-                if trigger_ice {\n-                    span_bug!(\n-                        body.span,\n-                        \"{}\",\n-                        VALIDATOR_MISMATCH_ERR,\n-                    );\n-                }\n+                validator_mismatch(\n+                    self.tcx,\n+                    body,\n+                    std::mem::replace(&mut self.errors, vec![]),\n+                    new_errors,\n+                );\n             }\n         }\n \n@@ -1870,6 +1859,58 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize\n     Some(ret)\n }\n \n+fn validator_mismatch(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    mut old_errors: Vec<(Span, String)>,\n+    mut new_errors: Vec<(Span, String)>,\n+) {\n+    error!(\"old validator: {:?}\", old_errors);\n+    error!(\"new validator: {:?}\", new_errors);\n+\n+    // ICE on nightly if the validators do not emit exactly the same errors.\n+    // Users can supress this panic with an unstable compiler flag (hopefully after\n+    // filing an issue).\n+    let opts = &tcx.sess.opts;\n+    let strict_validation_enabled = opts.unstable_features.is_nightly_build()\n+        && !opts.debugging_opts.suppress_const_validation_back_compat_ice;\n+\n+    if !strict_validation_enabled {\n+        return;\n+    }\n+\n+    // If this difference would cause a regression from the old to the new or vice versa, trigger\n+    // the ICE.\n+    if old_errors.is_empty() || new_errors.is_empty() {\n+        span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n+    }\n+\n+    // HACK: Borrows that would allow mutation are forbidden in const contexts, but they cause the\n+    // new validator to be more conservative about when a dropped local has been moved out of.\n+    //\n+    // Supress the mismatch ICE in cases where the validators disagree only on the number of\n+    // `LiveDrop` errors and both observe the same sequence of `MutBorrow`s.\n+\n+    let is_live_drop = |(_, s): &mut (_, String)| s.starts_with(\"LiveDrop\");\n+    let is_mut_borrow = |(_, s): &&(_, String)| s.starts_with(\"MutBorrow\");\n+\n+    let old_live_drops: Vec<_> = old_errors.drain_filter(is_live_drop).collect();\n+    let new_live_drops: Vec<_> = new_errors.drain_filter(is_live_drop).collect();\n+\n+    let only_live_drops_differ = old_live_drops != new_live_drops && old_errors == new_errors;\n+\n+    let old_mut_borrows = old_errors.iter().filter(is_mut_borrow);\n+    let new_mut_borrows = new_errors.iter().filter(is_mut_borrow);\n+\n+    let at_least_one_mut_borrow = old_mut_borrows.clone().next().is_some();\n+\n+    if only_live_drops_differ && at_least_one_mut_borrow && old_mut_borrows.eq(new_mut_borrows) {\n+        return;\n+    }\n+\n+    span_bug!(body.span, \"{}\", VALIDATOR_MISMATCH_ERR);\n+}\n+\n const VALIDATOR_MISMATCH_ERR: &str =\n     r\"Disagreement between legacy and dataflow-based const validators.\n     After filing an issue, use `-Zsuppress-const-validation-back-compat-ice` to compile your code.\";"}, {"sha": "978e227bcc81709eed0a49a338120607bb39ad82", "filename": "src/test/ui/consts/const-eval/issue-65394.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/27f8c7990e26900e72184f0fbe55da110782be72/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f8c7990e26900e72184f0fbe55da110782be72/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.rs?ref=27f8c7990e26900e72184f0fbe55da110782be72", "patch": "@@ -0,0 +1,13 @@\n+// Test for absence of validation mismatch ICE in #65394\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir(borrowck_graphviz_postflow=\"hello.dot\")]\n+const _: Vec<i32> = {\n+    let mut x = Vec::<i32>::new();\n+    let r = &mut x; //~ ERROR references in constants may only refer to immutable values\n+    let y = x;\n+    y\n+};\n+\n+fn main() {}"}, {"sha": "f48c551cb50f57e19da7b1851324af08d152fb9c", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27f8c7990e26900e72184f0fbe55da110782be72/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/27f8c7990e26900e72184f0fbe55da110782be72/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=27f8c7990e26900e72184f0fbe55da110782be72", "patch": "@@ -0,0 +1,11 @@\n+error[E0017]: references in constants may only refer to immutable values\n+  --> $DIR/issue-65394.rs:8:13\n+   |\n+LL |     let r = &mut x;\n+   |             ^^^^^^ constants require immutable values\n+\n+[ERROR rustc_mir::transform::qualify_consts] old validator: [($DIR/issue-65394.rs:8:13: 8:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\")]\n+[ERROR rustc_mir::transform::qualify_consts] new validator: [($DIR/issue-65394.rs:8:13: 8:19, \"MutBorrow(Mut { allow_two_phase_borrow: false })\"), ($DIR/issue-65394.rs:7:9: 7:14, \"LiveDrop\")]\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0017`."}]}