{"sha": "277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3N2UwZjFiYWEyMWI4ZjNlNWIwNDBiNzhjZTJiZDZiZWNhNmNkN2M=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-21T17:59:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:27Z"}, "message": "move watcher to io module", "tree": {"sha": "2445703704ed75987a157302401c5d144788c8a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2445703704ed75987a157302401c5d144788c8a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "html_url": "https://github.com/rust-lang/rust/commit/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f7c4e7465f58cdbfdaaf232d571960f1b754b7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7c4e7465f58cdbfdaaf232d571960f1b754b7c", "html_url": "https://github.com/rust-lang/rust/commit/7f7c4e7465f58cdbfdaaf232d571960f1b754b7c"}], "stats": {"total": 60, "additions": 29, "deletions": 31}, "files": [{"sha": "6d5af76904932d3e00180dd5cfde2661ed0fd000", "filename": "crates/ra_vfs/src/io/mod.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fmod.rs?ref=277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "patch": "@@ -11,17 +11,19 @@ use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::{DirEntry, WalkDir};\n \n-use crate::{\n-    watcher::{Watcher, WatcherChange},\n-    VfsRoot,\n-};\n+mod watcher;\n+use watcher::Watcher;\n+pub use watcher::WatcherChange;\n+\n+use crate::VfsRoot;\n \n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n         path: PathBuf,\n         filter: Box<Fn(&DirEntry) -> bool + Send>,\n     },\n+    /// this variant should only be created by the watcher\n     HandleChange(WatcherChange),\n     LoadChange(WatcherChange),\n     Watch {", "previous_filename": "crates/ra_vfs/src/io.rs"}, {"sha": "e332984772d5bec54628b096d8bde6718c6be227", "filename": "crates/ra_vfs/src/io/watcher.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs?ref=277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "patch": "@@ -10,13 +10,6 @@ use std::{\n };\n use walkdir::{DirEntry, WalkDir};\n \n-pub(crate) struct Watcher {\n-    watcher: RecommendedWatcher,\n-    thread: thread::JoinHandle<()>,\n-    bomb: DropBomb,\n-    sender: Sender<io::Task>,\n-}\n-\n #[derive(Debug)]\n pub enum WatcherChange {\n     Create(PathBuf),\n@@ -61,6 +54,13 @@ fn handle_change_event(\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n+pub(crate) struct Watcher {\n+    watcher: RecommendedWatcher,\n+    thread: thread::JoinHandle<()>,\n+    bomb: DropBomb,\n+    sender: Sender<io::Task>,\n+}\n+\n impl Watcher {\n     pub(crate) fn start(\n         output_sender: Sender<io::Task>,", "previous_filename": "crates/ra_vfs/src/watcher.rs"}, {"sha": "5db0d86460e9fa1bdef22cb032ca0646fd29bc00", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=277e0f1baa21b8f3e5b040b78ce2bd6beca6cd7c", "patch": "@@ -14,7 +14,6 @@\n //! which are watched for changes. Typically, there will be a root for each\n //! Cargo package.\n mod io;\n-mod watcher;\n \n use std::{\n     cmp::Reverse,\n@@ -32,7 +31,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use walkdir::DirEntry;\n \n pub use crate::io::TaskResult as VfsTask;\n-pub use crate::watcher::WatcherChange;\n+use io::{Task, TaskResult, WatcherChange, WatcherChangeData, Worker};\n \n /// `RootFilter` is a predicate that checks if a file can belong to a root. If\n /// several filters match a file (nested dirs), the most nested one wins.\n@@ -100,7 +99,7 @@ pub struct Vfs {\n     files: Arena<VfsFile, VfsFileData>,\n     root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n-    worker: io::Worker,\n+    worker: Worker,\n }\n \n impl fmt::Debug for Vfs {\n@@ -204,7 +203,7 @@ impl Vfs {\n \n     pub fn handle_task(&mut self, task: io::TaskResult) {\n         match task {\n-            io::TaskResult::AddRoot(task) => {\n+            TaskResult::AddRoot(task) => {\n                 let mut files = Vec::new();\n                 // While we were scanning the root in the backgound, a file might have\n                 // been open in the editor, so we need to account for that.\n@@ -229,38 +228,35 @@ impl Vfs {\n                 };\n                 self.pending_changes.push(change);\n             }\n-            io::TaskResult::HandleChange(change) => match &change {\n-                watcher::WatcherChange::Create(path) if path.is_dir() => {\n+            TaskResult::HandleChange(change) => match &change {\n+                WatcherChange::Create(path) if path.is_dir() => {\n                     if let Some((root, _path, _file)) = self.find_root(&path) {\n                         let root_filter = self.roots[root].clone();\n                         let filter =\n                             move |entry: &DirEntry| root_filter.can_contain(entry.path()).is_some();\n                         self.worker\n                             .sender()\n-                            .send(io::Task::Watch {\n+                            .send(Task::Watch {\n                                 dir: path.to_path_buf(),\n                                 filter: Box::new(filter),\n                             })\n                             .unwrap()\n                     }\n                 }\n-                watcher::WatcherChange::Create(path)\n-                | watcher::WatcherChange::Remove(path)\n-                | watcher::WatcherChange::Write(path) => {\n+                WatcherChange::Create(path)\n+                | WatcherChange::Remove(path)\n+                | WatcherChange::Write(path) => {\n                     if self.should_handle_change(&path) {\n-                        self.worker\n-                            .sender()\n-                            .send(io::Task::LoadChange(change))\n-                            .unwrap()\n+                        self.worker.sender().send(Task::LoadChange(change)).unwrap()\n                     }\n                 }\n-                watcher::WatcherChange::Rescan => {\n+                WatcherChange::Rescan => {\n                     // TODO we should reload all files\n                 }\n             },\n-            io::TaskResult::LoadChange(change) => match change {\n-                io::WatcherChangeData::Create { path, text }\n-                | io::WatcherChangeData::Write { path, text } => {\n+            TaskResult::LoadChange(change) => match change {\n+                WatcherChangeData::Create { path, text }\n+                | WatcherChangeData::Write { path, text } => {\n                     if let Some((root, path, file)) = self.find_root(&path) {\n                         if let Some(file) = file {\n                             self.do_change_file(file, text, false);\n@@ -269,15 +265,15 @@ impl Vfs {\n                         }\n                     }\n                 }\n-                io::WatcherChangeData::Remove { path } => {\n+                WatcherChangeData::Remove { path } => {\n                     if let Some((root, path, file)) = self.find_root(&path) {\n                         if let Some(file) = file {\n                             self.do_remove_file(root, path, file, false);\n                         }\n                     }\n                 }\n             },\n-            io::TaskResult::NoOp => {}\n+            TaskResult::NoOp => {}\n         }\n     }\n "}]}