{"sha": "249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "node_id": "C_kwDOAAsO6NoAKDI0OWU0NmJmYmFlNjZkMThhOTY3NzFkZDJjM2JkYWYwZjhmYzI1YjQ", "commit": {"author": {"name": "Ellis Hoag", "email": "ellis.sparky.hoag@gmail.com", "date": "2022-09-11T23:43:18Z"}, "committer": {"name": "Ellis Hoag", "email": "ellis.sparky.hoag@gmail.com", "date": "2022-09-24T17:24:48Z"}, "message": "Add monomorphization errors", "tree": {"sha": "8a16b37264cde91184e4e9f0e8b91221fac9008e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a16b37264cde91184e4e9f0e8b91221fac9008e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "html_url": "https://github.com/rust-lang/rust/commit/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/comments", "author": {"login": "ellishg", "id": 8961915, "node_id": "MDQ6VXNlcjg5NjE5MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8961915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ellishg", "html_url": "https://github.com/ellishg", "followers_url": "https://api.github.com/users/ellishg/followers", "following_url": "https://api.github.com/users/ellishg/following{/other_user}", "gists_url": "https://api.github.com/users/ellishg/gists{/gist_id}", "starred_url": "https://api.github.com/users/ellishg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ellishg/subscriptions", "organizations_url": "https://api.github.com/users/ellishg/orgs", "repos_url": "https://api.github.com/users/ellishg/repos", "events_url": "https://api.github.com/users/ellishg/events{/privacy}", "received_events_url": "https://api.github.com/users/ellishg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ellishg", "id": 8961915, "node_id": "MDQ6VXNlcjg5NjE5MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8961915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ellishg", "html_url": "https://github.com/ellishg", "followers_url": "https://api.github.com/users/ellishg/followers", "following_url": "https://api.github.com/users/ellishg/following{/other_user}", "gists_url": "https://api.github.com/users/ellishg/gists{/gist_id}", "starred_url": "https://api.github.com/users/ellishg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ellishg/subscriptions", "organizations_url": "https://api.github.com/users/ellishg/orgs", "repos_url": "https://api.github.com/users/ellishg/repos", "events_url": "https://api.github.com/users/ellishg/events{/privacy}", "received_events_url": "https://api.github.com/users/ellishg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fdfcb35471e2b8a90aeb668b34e1fe5c7250c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fdfcb35471e2b8a90aeb668b34e1fe5c7250c4c", "html_url": "https://github.com/rust-lang/rust/commit/6fdfcb35471e2b8a90aeb668b34e1fe5c7250c4c"}], "stats": {"total": 471, "additions": 318, "deletions": 153}, "files": [{"sha": "a70ebf62da3e91f0215cc3ad0e8bef999c673105", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 197, "deletions": 1, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "patch": "@@ -1,6 +1,7 @@\n use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_macros::SessionDiagnostic;\n-use rustc_span::Span;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n use std::borrow::Cow;\n \n struct ExitCode {\n@@ -29,6 +30,201 @@ impl RanlibFailure {\n     }\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n #[derive(SessionDiagnostic)]\n #[diag(codegen_gcc::layout_size_overflow)]\n pub(crate) struct LayoutSizeOverflow {"}, {"sha": "cc9c90c2427096174b97b4b2c56d7d8b689763ed", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "patch": "@@ -4,7 +4,7 @@ mod simd;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -20,6 +20,7 @@ use crate::abi::GccType;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -242,15 +243,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }"}, {"sha": "22bd0a1de82308ab56398069dfc0cefa64fa665b", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 61, "deletions": 142, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Ordering;\n \n use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,43 +14,48 @@ use rustc_span::{Span, Symbol, sym};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+use crate::errors::{\n+    InvalidMonomorphizationInvalidFloatVector,\n+    InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationUnrecognized,\n+    InvalidMonomorphizationExpectedSignedUnsigned,\n+    InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationReturnLength,\n+    InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnElement,\n+    InvalidMonomorphizationReturnType,\n+    InvalidMonomorphizationInsertedType,\n+    InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationMismatchedLengths,\n+    InvalidMonomorphizationUnsupportedCast,\n+    InvalidMonomorphizationUnsupportedOperation\n+};\n use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n+        ($err:expr) => {\n             {\n-                emit_error!($($fmt)*);\n+                bx.sess().emit_err($err);\n                 return Err(());\n             }\n         }\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n-        };\n+        }\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n         };\n     }\n \n@@ -82,10 +87,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n             _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n-                expected_int_bits,\n-                expected_bytes\n+                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n             ),\n         };\n \n@@ -127,18 +129,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n         );\n \n         return Ok(compare_simd_types(\n@@ -163,8 +158,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         })\n                     }\n                     _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n+                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n                     ),\n                 }\n             }\n@@ -179,19 +173,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n@@ -207,10 +193,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -263,10 +246,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -279,13 +259,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -295,12 +273,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -412,13 +385,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n             _ => { /* Unsupported. Fallthrough. */ }\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+        return_error!(\n+            InvalidMonomorphizationUnsupportedCast { span, name, in_ty, in_elem, ret_ty, out_elem }\n         );\n     }\n \n@@ -431,10 +399,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -448,40 +413,28 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n+            ($err:expr) => {\n                 {\n-                    emit_error!($($fmt)*);\n+                    bx.sess().emit_err($err);\n                     return Err(());\n                 }\n             }\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f32\", elem_ty),\n                     64 => (\"f64\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        // Can we pass elem_ty directly?\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -504,7 +457,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n@@ -557,10 +510,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -579,12 +529,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n             }\n         };\n         let builtin_name =\n@@ -617,10 +567,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -644,13 +591,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -676,20 +617,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -704,22 +636,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n-                            in_ty,\n-                            in_elem,\n-                            ret_ty\n-                        ),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -733,11 +656,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n                     _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n+                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n                     ),\n                 };\n             }"}, {"sha": "2497d550323967431c6f6868d61c9173b6d27181", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=249e46bfbae66d18a96771dd2c3bdaf0f8fc25b4", "patch": "@@ -12,3 +12,60 @@ codegen_gcc_unwinding_inline_asm =\n \n codegen_gcc_lto_not_supported =\n     LTO is not supported. You may get a linker error.\n+\n+codegen_gcc_invalid_monomorphization_basic_integer =\n+    invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n+    invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n+\n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_bitmask =\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mask_type =\n+    invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_gcc_invalid_monomorphization_return_length =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_length_input_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_cast =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_operation =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`"}]}