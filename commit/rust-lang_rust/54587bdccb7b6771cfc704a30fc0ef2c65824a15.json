{"sha": "54587bdccb7b6771cfc704a30fc0ef2c65824a15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NTg3YmRjY2I3YjY3NzFjZmM3MDRhMzBmYzBlZjJjNjU4MjRhMTU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-16T21:58:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-16T21:58:02Z"}, "message": "Switch all vases of vec += elt to vec += vec. Prohibit former in rustboot. Tweak std lib vec fns in process.", "tree": {"sha": "6f154f9b038e9542b364e87ae887858a96bdb4a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f154f9b038e9542b364e87ae887858a96bdb4a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54587bdccb7b6771cfc704a30fc0ef2c65824a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54587bdccb7b6771cfc704a30fc0ef2c65824a15", "html_url": "https://github.com/rust-lang/rust/commit/54587bdccb7b6771cfc704a30fc0ef2c65824a15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54587bdccb7b6771cfc704a30fc0ef2c65824a15/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23eef4da22d55ad530f349dfd2dd40141258956f", "url": "https://api.github.com/repos/rust-lang/rust/commits/23eef4da22d55ad530f349dfd2dd40141258956f", "html_url": "https://github.com/rust-lang/rust/commit/23eef4da22d55ad530f349dfd2dd40141258956f"}], "stats": {"total": 503, "additions": 278, "deletions": 225}, "files": [{"sha": "d063fb05037c30a3a01d567f17e723fe9baf4d91", "filename": "src/Makefile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -469,7 +469,6 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         acyclic-unwind.rs \\\n                         alt-pattern-drop.rs \\\n                         alt-type-simple.rs \\\n-                        append-units.rs \\\n                         basic-1.rs \\\n                         basic-2.rs \\\n                         basic.rs \\"}, {"sha": "72bdd40449398373e8ed02931e88ffe2db35ca8e", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -993,16 +993,14 @@ let check_block (cx:Semant.ctxt) : (fn_ctx -> Ast.block -> unit) =\n             let src_ty = check_atom ~deref:true src in\n             let dst_ty = check_lval dst in\n               match fundamental_ty dst_ty, fundamental_ty src_ty with\n-                  Ast.TY_vec elt1, Ast.TY_vec elt2\n-                | Ast.TY_vec elt1, elt2 ->\n+                  Ast.TY_vec elt1, Ast.TY_vec elt2 ->\n                     if elt1 = elt2\n                     then ()\n                     else\n                       Common.err None\n                         \"mismatched types in vec-append: %s += %s\"\n                         (pretty_ty_str dst_ty)\n                         (pretty_ty_str src_ty)\n-                | Ast.TY_str, (Ast.TY_mach Common.TY_u8)\n                 | Ast.TY_str, Ast.TY_str -> ()\n                 | _ ->\n                     infer_lval src_ty dst;"}, {"sha": "f0ce9a95f96d2f861b2a1d13d550c95f504c5482", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -203,8 +203,8 @@ impure fn main(vec[str] args) {\n                 alt (output_file) {\n                     case (none[str]) {\n                         let vec[str] parts = _str.split(ifile, '.' as u8);\n-                        parts = _vec.pop[str](parts);\n-                        parts += \".bc\";\n+                        _vec.pop[str](parts);\n+                        parts += vec(\".bc\");\n                         auto ofile = _str.concat(parts);\n                         compile_input(sess, env, ifile, ofile, shared,\n                                       library_search_paths);"}, {"sha": "4cf3765f4d37052b23cff9901d4470e9f39d7524", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -13,7 +13,6 @@ import front.parser.new_parser;\n import front.parser.parse_mod_items;\n import util.common;\n import util.common.filename;\n-import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n \n@@ -394,7 +393,7 @@ impure fn eval_crate_directive(parser p,\n             auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span, cdir.span, im);\n             ast.index_item(index, i);\n-            append[@ast.item](items, i);\n+            _vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n@@ -412,11 +411,11 @@ impure fn eval_crate_directive(parser p,\n             auto im = ast.item_mod(id, m0, p.next_def_id());\n             auto i = @spanned(cdir.span, cdir.span, im);\n             ast.index_item(index, i);\n-            append[@ast.item](items, i);\n+            _vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_view_item(?vi)) {\n-            append[@ast.view_item](view_items, vi);\n+            _vec.push[@ast.view_item](view_items, vi);\n             ast.index_view_item(index, vi);\n         }\n "}, {"sha": "0a32a851dacd8d3a1b3686016f27ebe4a49a50f8", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -113,7 +113,7 @@ fn parse_fmt_string(str s) -> vec[piece] {\n     fn flush_buf(str buf, &vec[piece] pieces) -> str {\n         if (_str.byte_len(buf) > 0u) {\n             auto piece = piece_string(buf);\n-            pieces += piece;\n+            pieces += vec(piece);\n         }\n         ret \"\";\n     }\n@@ -133,7 +133,7 @@ fn parse_fmt_string(str s) -> vec[piece] {\n             } else {\n                 buf = flush_buf(buf, pieces);\n                 auto res = parse_conversion(s, i, lim);\n-                pieces += res._0;\n+                pieces += vec(res._0);\n                 i = res._1;\n             }\n         } else {"}, {"sha": "403558e29344a9f2b414c34ae6899cfd4543148a", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -420,7 +420,7 @@ impure fn next_token(reader rdr) -> token.token {\n \n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n-            accum_str += (c as u8);\n+            _str.push_byte(accum_str, (c as u8));\n             rdr.bump();\n             c = rdr.curr();\n         }\n@@ -580,23 +580,23 @@ impure fn next_token(reader rdr) -> token.token {\n                         alt (rdr.next()) {\n                             case ('n') {\n                                 rdr.bump();\n-                                accum_str += '\\n' as u8;\n+                                _str.push_byte(accum_str, '\\n' as u8);\n                             }\n                             case ('r') {\n                                 rdr.bump();\n-                                accum_str += '\\r' as u8;\n+                                _str.push_byte(accum_str, '\\r' as u8);\n                             }\n                             case ('t') {\n                                 rdr.bump();\n-                                accum_str += '\\t' as u8;\n+                                _str.push_byte(accum_str, '\\t' as u8);\n                             }\n                             case ('\\\\') {\n                                 rdr.bump();\n-                                accum_str += '\\\\' as u8;\n+                                _str.push_byte(accum_str, '\\\\' as u8);\n                             }\n                             case ('\"') {\n                                 rdr.bump();\n-                                accum_str += '\"' as u8;\n+                                _str.push_byte(accum_str, '\"' as u8);\n                             }\n                             // FIXME: unicode numeric escapes.\n                             case (?c2) {\n@@ -607,7 +607,7 @@ impure fn next_token(reader rdr) -> token.token {\n                         }\n                     }\n                     case (_) {\n-                        accum_str += rdr.curr() as u8;\n+                        _str.push_byte(accum_str, rdr.curr() as u8);\n                     }\n                 }\n                 rdr.bump();"}, {"sha": "5e38345d2519b2ff6505212439e854bc2f87684f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -9,7 +9,6 @@ import std.map.hashmap;\n import driver.session;\n import util.common;\n import util.common.filename;\n-import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n \n@@ -303,7 +302,7 @@ impure fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n                 case (token.IDENT(_)) {\n                     auto constr = parse_ty_constr(p);\n                     hi = constr.span;\n-                    append[@ast.constr](constrs, constr);\n+                    _vec.push[@ast.constr](constrs, constr);\n                     if (p.peek() == token.COMMA) {\n                         p.bump();\n                         more = false;\n@@ -573,7 +572,7 @@ impure fn parse_path(parser p, greed g) -> ast.path {\n         alt (p.peek()) {\n             case (token.IDENT(?i)) {\n                 hi = p.get_span();\n-                ids += i;\n+                ids += vec(i);\n                 p.bump();\n                 if (p.peek() == token.DOT) {\n                     if (g == GREEDY) {\n@@ -699,7 +698,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                     }\n                     case (token.COMMA) {\n                         p.bump();\n-                        fields += parse_field(p);\n+                        fields += vec(parse_field(p));\n                     }\n                     case (?t) {\n                         unexpected(p, t);\n@@ -877,7 +876,7 @@ impure fn extend_expr_by_ident(parser p, span lo, span hi,\n         case (ast.expr_path(?pth, ?def, ?ann)) {\n             if (_vec.len[@ast.ty](pth.node.types) == 0u) {\n                 auto idents_ = pth.node.idents;\n-                idents_ += i;\n+                idents_ += vec(i);\n                 auto tys = parse_ty_args(p, hi);\n                 auto pth_ = spanned(pth.span, tys.span,\n                                     rec(idents=idents_,\n@@ -1763,8 +1762,8 @@ impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n                 dtor = some[ast.block](parse_block(p));\n             }\n             case (_) {\n-                append[@ast.method](meths,\n-                                    parse_method(p));\n+                _vec.push[@ast.method](meths,\n+                                       parse_method(p));\n             }\n         }\n     }\n@@ -2161,12 +2160,11 @@ impure fn parse_rest_import_name(parser p, ast.ident first,\n         -> @ast.view_item {\n     auto lo = p.get_span();\n     auto hi = lo;\n-    let vec[ast.ident] identifiers = vec();\n-    identifiers += first;\n+    let vec[ast.ident] identifiers = vec(first);\n     while (p.peek() != token.SEMI) {\n         expect(p, token.DOT);\n         auto i = parse_ident(p);\n-        identifiers += i;\n+        identifiers += vec(i);\n     }\n     p.bump();\n     auto defined_id;\n@@ -2402,7 +2400,7 @@ impure fn parse_crate_directives(parser p, token.token term)\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n-        append[@ast.crate_directive](cdirs, cdir);\n+        _vec.push[@ast.crate_directive](cdirs, cdir);\n     }\n \n     ret cdirs;"}, {"sha": "62c6406a6b8b6a1e1467044a4170deebc17f0f69", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -3,6 +3,7 @@ import util.common.ty_mach_to_str;\n import util.common.new_str_hash;\n import std._int;\n import std._uint;\n+import std._str;\n \n tag binop {\n     PLUS;\n@@ -302,8 +303,8 @@ fn to_str(token t) -> str {\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape and encode.\n             auto tmp = \"'\";\n-            tmp += c as u8;\n-            tmp += '\\'' as u8;\n+            _str.push_byte(tmp, c as u8);\n+            _str.push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n "}, {"sha": "e2f2e1926832d170daf5c9a7c62b750f8948b8d3", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -7,7 +7,6 @@ import util.common.new_str_hash;\n import util.common.spanned;\n import util.common.span;\n import util.common.ty_mach;\n-import util.common.append;\n \n import front.ast;\n import front.ast.fn_decl;\n@@ -318,7 +317,7 @@ type ast_fold[ENV] =\n fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast.ty] tys_ = vec();\n     for (@ast.ty t in p.node.types) {\n-        append[@ast.ty](tys_, fold_ty(env, fld, t));\n+        _vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n     }\n     let ast.path_ p_ = rec(idents=p.node.idents, types=tys_);\n     ret fld.fold_path(env, p.span, p_);\n@@ -357,15 +356,15 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         case (ast.ty_tup(?elts)) {\n             let vec[@ty] elts_ = vec();\n             for (@ty elt in elts) {\n-                append[@ty](elts_,fold_ty(env, fld, elt));\n+                _vec.push[@ty](elts_,fold_ty(env, fld, elt));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n \n         case (ast.ty_rec(?flds)) {\n             let vec[ast.ty_field] flds_ = vec();\n             for (ast.ty_field f in flds) {\n-                append[ast.ty_field]\n+                _vec.push[ast.ty_field]\n                     (flds_, rec(ty=fold_ty(env, fld, f.ty) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n@@ -378,7 +377,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n                     case (ast.ty_fn(?p, ?ins, ?out)) {\n-                        append[ast.ty_method]\n+                        _vec.push[ast.ty_method]\n                             (meths_, rec(proto=p, inputs=ins, output=out\n                                          with m));\n                     }\n@@ -494,7 +493,7 @@ fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n-        append[@expr](exprs, fold_expr(env, fld, e));\n+        _vec.push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n@@ -525,7 +524,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n         case (ast.expr_tup(?es, ?t)) {\n             let vec[ast.elt] elts = vec();\n             for (ast.elt e in es) {\n-                elts += fold_tup_elt[ENV](env, fld, e);\n+                elts += vec(fold_tup_elt[ENV](env, fld, e));\n             }\n             ret fld.fold_expr_tup(env_, e.span, elts, t);\n         }\n@@ -534,7 +533,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             let vec[ast.field] fields = vec();\n             let option.t[@expr] b = none[@expr];\n             for (ast.field f in fs) {\n-                fields += fold_rec_field(env, fld, f);\n+                fields += vec(fold_rec_field(env, fld, f));\n             }\n             alt (base) {\n                 case (none[@ast.expr]) { }\n@@ -557,7 +556,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             for (option.t[@ast.expr] t_opt in args_opt) {\n                 alt (t_opt) {\n                     case (none[@ast.expr]) {\n-                        aargs_opt += none[@ast.expr];\n+                        aargs_opt += vec(none[@ast.expr]);\n                     }\n                     case (some[@ast.expr](?e)) {\n                         aargs_opt += vec(some(fold_expr(env_, fld, e)));\n@@ -779,7 +778,7 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        append[@ast.stmt](stmts, new_stmt);\n+        _vec.push[@ast.stmt](stmts, new_stmt);\n         ast.index_stmt(index, new_stmt);\n     }\n \n@@ -812,7 +811,7 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n                      &ast.fn_decl decl) -> ast.fn_decl {\n     let vec[ast.arg] inputs = vec();\n     for (ast.arg a in decl.inputs) {\n-        inputs += fold_arg(env, fld, a);\n+        inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n     ret fld.fold_fn_decl(env, decl.effect, inputs, output);\n@@ -846,7 +845,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n     let vec[ast.obj_field] fields = vec();\n     let vec[@ast.method] meths = vec();\n     for (ast.obj_field f in ob.fields) {\n-        fields += fold_obj_field(env, fld, f);\n+        fields += vec(fold_obj_field(env, fld, f));\n     }\n     let option.t[block] dtor = none[block];\n     alt (ob.dtor) {\n@@ -867,7 +866,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        append[@ast.method](meths, fold_method(_env, fld, m));\n+        _vec.push[@ast.method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n@@ -944,8 +943,8 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n                     auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n                     new_args += vec(rec(ty=new_ty, id=va.id));\n                 }\n-                new_variants += rec(name=v.name, args=new_args, id=v.id,\n-                                    ann=v.ann);\n+                new_variants += vec(rec(name=v.name, args=new_args, id=v.id,\n+                                        ann=v.ann));\n             }\n             ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n                                   ty_params, id);\n@@ -969,13 +968,13 @@ fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        append[@view_item](view_items, new_vi);\n+        _vec.push[@view_item](view_items, new_vi);\n         ast.index_view_item(index, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n-        append[@item](items, new_item);\n+        _vec.push[@item](items, new_item);\n         ast.index_item(index, new_item);\n     }\n \n@@ -1009,12 +1008,12 @@ fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        append[@view_item](view_items, new_vi);\n+        _vec.push[@view_item](view_items, new_vi);\n     }\n \n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n-        append[@native_item](items, new_item);\n+        _vec.push[@native_item](items, new_item);\n         ast.index_native_item(index, new_item);\n     }\n "}, {"sha": "7bea575f9bef024e141dd53e4fa5c71deff8ff21", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 64, "deletions": 56, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -20,7 +20,6 @@ import middle.ty.pat_ty;\n import middle.ty.plain_ty;\n \n import util.common;\n-import util.common.append;\n import util.common.istr;\n import util.common.new_def_hash;\n import util.common.new_str_hash;\n@@ -476,7 +475,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n             check (arg.mode == ast.alias);\n-            atys += T_typaram_ptr(cx.tn);\n+            atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n             let TypeRef t;\n             alt (arg.mode) {\n@@ -487,7 +486,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n                     t = type_of_inner(cx, arg.ty, false);\n                 }\n             }\n-            atys += t;\n+            atys += vec(t);\n         }\n     }\n     ret atys;\n@@ -510,30 +509,30 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n     // Arg 0: Output pointer.\n     if (ty.type_has_dynamic_size(output)) {\n-        atys += T_typaram_ptr(cx.tn);\n+        atys += vec(T_typaram_ptr(cx.tn));\n     } else {\n-        atys += T_ptr(type_of_inner(cx, output, false));\n+        atys += vec(T_ptr(type_of_inner(cx, output, false)));\n     }\n \n     // Arg 1: Task pointer.\n-    atys += T_taskptr(cx.tn);\n+    atys += vec(T_taskptr(cx.tn));\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n             check (t as int != 0);\n-            atys += t;\n+            atys += vec(t);\n         }\n         case (_) {\n-            atys += T_opaque_closure_ptr(cx.tn);\n+            atys += vec(T_opaque_closure_ptr(cx.tn));\n         }\n     }\n \n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += T_ptr(T_tydesc(cx.tn));\n+            atys += vec(T_ptr(T_tydesc(cx.tn)));\n             i += 1u;\n         }\n     }\n@@ -542,10 +541,11 @@ fn type_of_fn_full(@crate_ctxt cx,\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n-        atys += T_fn_pair(cx.tn,\n+        atys +=\n+            vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          plain_ty(ty.ty_nil), 0u));\n+                                          plain_ty(ty.ty_nil), 0u)));\n     }\n \n     // ... then explicit args.\n@@ -568,12 +568,12 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n                      @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n     if (abi == ast.native_abi_rust) {\n-        atys += T_taskptr(cx.tn);\n+        atys += vec(T_taskptr(cx.tn));\n         auto t = ty.ty_native_fn(abi, inputs, output);\n         auto ty_param_count = ty.count_ty_params(plain_ty(t));\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += T_ptr(T_tydesc(cx.tn));\n+            atys += vec(T_ptr(T_tydesc(cx.tn)));\n             i += 1u;\n         }\n     }\n@@ -623,14 +623,14 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n             for (@ty.t elt in elts) {\n-                tys += type_of_inner(cx, elt, boxed);\n+                tys += vec(type_of_inner(cx, elt, boxed));\n             }\n             llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += type_of_inner(cx, f.ty, boxed);\n+                tys += vec(type_of_inner(cx, f.ty, boxed));\n             }\n             llty = T_struct(tys);\n         }\n@@ -650,7 +650,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                     type_of_fn_full(cx, m.proto,\n                                     some[TypeRef](self_ty),\n                                     m.inputs, m.output, 0u);\n-                mtys += T_ptr(mty);\n+                mtys += vec(T_ptr(mty));\n             }\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair = T_struct(vec(T_ptr(vtbl),\n@@ -870,10 +870,10 @@ fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n \n     let ValueRef llglue = glues.upcall_glues.(n);\n     let vec[ValueRef] call_args = vec(llupcall);\n-    call_args += b.PtrToInt(lltaskptr, T_int());\n+    call_args += vec( b.PtrToInt(lltaskptr, T_int()));\n \n     for (ValueRef a in args) {\n-        call_args += b.ZExtOrBitCast(a, T_int());\n+        call_args += vec(b.ZExtOrBitCast(a, T_int()));\n     }\n \n     ret b.FastCall(llglue, call_args);\n@@ -1112,7 +1112,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     if (! ty.type_has_dynamic_size(t)) {\n         let vec[ValueRef] v = vec();\n         for (int i in ixs) {\n-            v += C_int(i);\n+            v += vec(C_int(i));\n         }\n         ret res(cx, cx.build.GEP(base, v));\n     }\n@@ -1159,8 +1159,8 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         let vec[@ty.t] prefix = vec();\n         let int i = 0;\n         while (i < ix) {\n-            append[@ty.t](prefix, ty.get_element_type(t, i as uint));\n-            i +=1 ;\n+            _vec.push[@ty.t](prefix, ty.get_element_type(t, i as uint));\n+            i += 1 ;\n         }\n \n         auto selected = ty.get_element_type(t, i as uint);\n@@ -1310,8 +1310,8 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n                         }\n                     }\n                     if (!seen) {\n-                        r.vals += r.cx.fcx.lltydescs.get(pid);\n-                        r.defs += pid;\n+                        r.vals += vec(r.cx.fcx.lltydescs.get(pid));\n+                        r.defs += vec(pid);\n                     }\n                 }\n                 case (_) { }\n@@ -2365,7 +2365,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             auto box_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n             find_scope_cx(cx).cleanups +=\n-                clean(bind drop_ty(_, sub.val, box_ty));\n+                vec(clean(bind drop_ty(_, sub.val, box_ty)));\n \n             auto box = sub.val;\n             auto rc = sub.bcx.build.GEP(box,\n@@ -2646,7 +2646,8 @@ fn trans_vec_add(@block_ctxt cx, @ty.t t,\n     r = copy_ty(r.bcx, INIT, tmp, lhs, t);\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n     tmp = load_scalar_or_boxed(bcx, tmp, t);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tmp, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, tmp, t)));\n     ret res(bcx, tmp);\n }\n \n@@ -2800,9 +2801,9 @@ fn join_results(@block_ctxt parent_cx,\n \n     for (result r in ins) {\n         if (! is_terminated(r.bcx)) {\n-            live += r;\n-            vals += r.val;\n-            bbs += r.bcx.llbb;\n+            live += vec(r);\n+            vals += vec(r.val);\n+            bbs += vec(r.bcx.llbb);\n         }\n     }\n \n@@ -2875,7 +2876,8 @@ fn trans_for(@block_ctxt cx,\n         cx.build.Br(scope_cx.llbb);\n         auto local_res = alloc_local(scope_cx, local);\n         auto bcx = copy_ty(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n-        scope_cx.cleanups += clean(bind drop_slot(_, local_res.val, t));\n+        scope_cx.cleanups +=\n+            vec(clean(bind drop_slot(_, local_res.val, t)));\n         bcx = trans_block(bcx, body).bcx;\n         bcx.build.Br(next_cx.llbb);\n         ret res(next_cx, C_nil());\n@@ -3245,7 +3247,8 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n \n             llvm.LLVMSetValueName(dst, _str.buf(id));\n             bcx.fcx.lllocals.insert(def_id, dst);\n-            bcx.cleanups += clean(bind drop_slot(_, dst, ty));\n+            bcx.cleanups +=\n+                vec(clean(bind drop_slot(_, dst, ty)));\n \n             ret copy_ty(bcx, INIT, dst, llval, ty);\n         }\n@@ -3368,7 +3371,7 @@ fn lval_generic_fn(@block_ctxt cx,\n         for (@ty.t t in tys) {\n             auto td = get_tydesc(bcx, t);\n             bcx = td.bcx;\n-            append[ValueRef](tydescs, td.val);\n+            _vec.push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec( item_type = tpt._1,\n                         tydescs = tydescs );\n@@ -3692,7 +3695,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n-                llargs += val;\n+                llargs += vec(val);\n                 b += 1;\n             }\n \n@@ -3706,7 +3709,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                                                        llout_arg_ty);\n                 }\n \n-                llargs += passed_arg;\n+                llargs += vec(passed_arg);\n                 a += 1u;\n             }\n         }\n@@ -3750,7 +3753,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 case (none[@ast.expr]) {\n                 }\n                 case (some[@ast.expr](?e)) {\n-                    append[@ast.expr](bound, e);\n+                    _vec.push[@ast.expr](bound, e);\n                 }\n             }\n         }\n@@ -3786,8 +3789,8 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n \n-                append[ValueRef](bound_vals, arg.val);\n-                append[@ty.t](bound_tys, ty.expr_ty(e));\n+                _vec.push[ValueRef](bound_vals, arg.val);\n+                _vec.push[@ty.t](bound_tys, ty.expr_ty(e));\n \n                 i += 1u;\n             }\n@@ -3914,7 +3917,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                  pair_box);\n \n             find_scope_cx(cx).cleanups +=\n-                clean(bind drop_slot(_, pair_v, pair_ty));\n+                vec(clean(bind drop_slot(_, pair_v, pair_ty)));\n \n             ret res(bcx, pair_v);\n         }\n@@ -3959,34 +3962,35 @@ fn trans_args(@block_ctxt cx,\n         }\n     }\n     if (ty.type_has_dynamic_size(retty)) {\n-        llargs += bcx.build.PointerCast(llretslot,\n-                                        T_typaram_ptr(cx.fcx.ccx.tn));\n+        llargs += vec(bcx.build.PointerCast(llretslot,\n+                                            T_typaram_ptr(cx.fcx.ccx.tn)));\n     } else if (ty.count_ty_params(retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-        llargs += cx.build.PointerCast(llretslot,\n-                                       T_ptr(type_of(bcx.fcx.ccx, retty)));\n+        llargs +=\n+            vec(cx.build.PointerCast(llretslot,\n+                                     T_ptr(type_of(bcx.fcx.ccx, retty))));\n     } else {\n-        llargs += llretslot;\n+        llargs += vec(llretslot);\n     }\n \n \n     // Arg 1: Task pointer.\n-    llargs += bcx.fcx.lltaskptr;\n+    llargs += vec(bcx.fcx.lltaskptr);\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (llobj) {\n         case (some[ValueRef](?ob)) {\n             // Every object is always found in memory,\n             // and not-yet-loaded (as part of an lval x.y\n             // doted method-call).\n-            llargs += bcx.build.Load(ob);\n+            llargs += vec(bcx.build.Load(ob));\n         }\n         case (_) {\n-            llargs += llenv;\n+            llargs += vec(llenv);\n         }\n     }\n \n@@ -3997,7 +4001,7 @@ fn trans_args(@block_ctxt cx,\n     alt (lliterbody) {\n         case (none[ValueRef]) {}\n         case (some[ValueRef](?lli)) {\n-            llargs += lli;\n+            llargs += vec(lli);\n         }\n     }\n \n@@ -4054,7 +4058,7 @@ fn trans_args(@block_ctxt cx,\n             val = bcx.build.PointerCast(val, lldestty);\n         }\n \n-        llargs += val;\n+        llargs += vec(val);\n         i += 1u;\n     }\n \n@@ -4116,7 +4120,8 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         // Retval doesn't correspond to anything really tangible in the frame,\n         // but it's a ref all the same, so we put a note here to drop it when\n         // we're done in this scope.\n-        find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n+        find_scope_cx(cx).cleanups +=\n+            vec(clean(bind drop_ty(_, retval, ret_ty)));\n     }\n \n     ret res(bcx, retval);\n@@ -4130,7 +4135,8 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     auto tup_val = tup_res.val;\n     bcx = tup_res.bcx;\n \n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, tup_val, t)));\n     let int i = 0;\n \n     for (ast.elt e in elts) {\n@@ -4171,7 +4177,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n     auto llty = type_of(bcx.fcx.ccx, t);\n     auto vec_val = vi2p(bcx, sub.val, llty);\n-    find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n+    find_scope_cx(bcx).cleanups +=\n+        vec(clean(bind drop_ty(_, vec_val, t)));\n \n     auto body = bcx.build.GEP(vec_val, vec(C_int(0),\n                                            C_int(abi.vec_elt_data)));\n@@ -4226,7 +4233,8 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     auto rec_val = rec_res.val;\n     bcx = rec_res.bcx;\n \n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, rec_val, t)));\n     let int i = 0;\n \n     auto base_val = C_nil();\n@@ -4499,7 +4507,7 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n                 llarg = bcx.build.Load(llarg);\n             }\n \n-            llargs += llarg;\n+            llargs += vec(llarg);\n         }\n     }\n \n@@ -4557,7 +4565,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n     auto bcx = cx;\n \n     find_scope_cx(cx).cleanups +=\n-        clean(bind drop_slot(_, llptr, ty));\n+        vec(clean(bind drop_slot(_, llptr, ty)));\n \n     alt (local.init) {\n         case (some[@ast.expr](?e)) {\n@@ -5026,7 +5034,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n \n         trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n                  ty_params, m.node.ann);\n-        methods += llfn;\n+        methods += vec(llfn);\n     }\n     auto vtbl = C_struct(methods);\n     auto gvar = llvm.LLVMAddGlobal(cx.llmod,\n@@ -5085,14 +5093,14 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         // Malloc a box for the body and copy args in.\n         let vec[@ty.t] obj_fields = vec();\n         for (ty.arg a in arg_tys) {\n-            append[@ty.t](obj_fields, a.ty);\n+            _vec.push[@ty.t](obj_fields, a.ty);\n         }\n \n         // Synthesize an obj body type.\n         auto tydesc_ty = plain_ty(ty.ty_type);\n         let vec[@ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n-            append[@ty.t](tps, tydesc_ty);\n+            _vec.push[@ty.t](tps, tydesc_ty);\n         }\n \n         let @ty.t typarams_ty = plain_ty(ty.ty_tup(tps));"}, {"sha": "923d97ff73f57b63a19d72933623bba6f5f20d2d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -11,7 +11,6 @@ import driver.session;\n import front.ast;\n import front.ast.mutability;\n import util.common;\n-import util.common.append;\n import util.common.new_def_hash;\n import util.common.span;\n \n@@ -756,7 +755,7 @@ fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n                 accum += (c as uint) - ('0' as uint);\n             } else {\n                 auto s = \"\";\n-                s += c;\n+                s += _str.unsafe_from_byte(c);\n                 sess.span_err(sp,\n                               \"bad numeric field on tuple: \"\n                               + \" non-digit character: \"\n@@ -1104,7 +1103,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[@ty.t](result_tps, rty);\n+                                    _vec.push[@ty.t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1244,7 +1243,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[@ty.t](result_elems,rty);\n+                                    _vec.push[@ty.t](result_elems,rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1301,7 +1300,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[field]\n+                                    _vec.push[field]\n                                         (result_fields,\n                                          rec(ty=rty with expected_field));\n                                 }"}, {"sha": "6668c20824318d32e11f77e93fd1f6aa1b4e691f", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -4,7 +4,6 @@ import front.ast.mutability;\n import middle.fold;\n import driver.session;\n import util.common;\n-import util.common.append;\n import util.common.span;\n \n import middle.ty;\n@@ -320,14 +319,14 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         case (ast.ty_tup(?fields)) {\n             let vec[@ty.t] flds = vec();\n             for (@ast.ty field in fields) {\n-                append[@ty.t](flds, ast_ty_to_ty(getter, field));\n+                _vec.push[@ty.t](flds, ast_ty_to_ty(getter, field));\n             }\n             sty = ty.ty_tup(flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n-                append[field](flds, rec(ident=f.ident,\n+                _vec.push[field](flds, rec(ident=f.ident,\n                                         ty=ast_ty_to_ty(getter, f.ty)));\n             }\n             sty = ty.ty_rec(flds);\n@@ -371,7 +370,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n             for (ast.ty_method m in meths) {\n                 auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(getter, m.output);\n-                append[ty.method](tmeths,\n+                _vec.push[ty.method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n@@ -565,7 +564,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(id_to_ty_item, item_to_ty, _);\n             auto t_field = ast_ty_to_ty(g, f.ty);\n-            append[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n+            _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n         auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj));\n         ret t_fn;\n@@ -870,7 +869,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n-            append[@ast.method](methods, m);\n+            _vec.push[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.id_to_ty_item, e.item_to_ty, _);\n         for (ast.obj_field fld in ob.fields) {\n@@ -879,7 +878,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 ann=ast.ann_type(fty, none[vec[@ty.t]])\n                 with fld\n             );\n-            append[ast.obj_field](fields, f);\n+            _vec.push[ast.obj_field](fields, f);\n         }\n \n         auto ob_ = rec(methods = methods,\n@@ -1572,14 +1571,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n                     auto arg_ty = rec(mode=ast.val, ty=expr_ty(a_0));\n-                    append[arg](arg_tys_0, arg_ty);\n+                    _vec.push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast.expr]) {\n                     args_0 += vec(none[@ast.expr]);\n \n                     // FIXME: breaks aliases too?\n                     auto typ = next_ty_var(fcx.ccx);\n-                    append[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n+                    _vec.push[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n                 }\n             }\n         }\n@@ -1623,10 +1622,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (some[@ast.expr](?e_0)) {\n                     auto arg_ty_1 = arg_tys_1.(i);\n                     auto e_1 = demand_expr(fcx, arg_ty_1.ty, e_0);\n-                    append[option.t[@ast.expr]](args_1, some[@ast.expr](e_1));\n+                    _vec.push[option.t[@ast.expr]](args_1,\n+                                                   some[@ast.expr](e_1));\n                 }\n                 case (none[@ast.expr]) {\n-                    append[option.t[@ast.expr]](args_1, none[@ast.expr]);\n+                    _vec.push[option.t[@ast.expr]](args_1, none[@ast.expr]);\n                 }\n             }\n \n@@ -2114,7 +2114,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 auto expr_1 = check_expr(fcx, e);\n                 auto expr_t = expr_ty(expr_1);\n                 demand(fcx, expr.span, t, expr_t);\n-                append[@ast.expr](args_1,expr_1);\n+                _vec.push[@ast.expr](args_1,expr_1);\n             }\n             auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -2131,8 +2131,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 if (e.mut == ast.mut) {\n                     expr_t = @rec(mut=ast.mut with *expr_t);\n                 }\n-                append[ast.elt](elts_1, rec(expr=expr_1 with e));\n-                append[@ty.t](elts_t, expr_t);\n+                _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n+                _vec.push[@ty.t](elts_t, expr_t);\n             }\n \n             auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)),\n@@ -2160,8 +2160,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 if (f.mut == ast.mut) {\n                     expr_t = @rec(mut=ast.mut with *expr_t);\n                 }\n-                append[ast.field](fields_1, rec(expr=expr_1 with f));\n-                append[field](fields_t, rec(ident=f.ident, ty=expr_t));\n+                _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n+                _vec.push[field](fields_t, rec(ident=f.ident, ty=expr_t));\n             }\n \n             auto ann = ast.ann_none;\n@@ -2418,7 +2418,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in block.node.stmts) {\n-        append[@ast.stmt](stmts, check_stmt(fcx, s));\n+        _vec.push[@ast.stmt](stmts, check_stmt(fcx, s));\n     }\n \n     auto expr = none[@ast.expr];"}, {"sha": "0c355001e95fa8c02da77d40a7ef99167ed42472", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -39,12 +39,12 @@ fn mkstate(io.writer out, uint width) -> ps {\n \n impure fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  p.context = _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n-                                                + indent));\n+  _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n+                                    + indent));\n }\n \n-impure fn pop_context(ps p) {\n-  p.context = _vec.pop[context](p.context);\n+fn pop_context(ps p) {\n+  _vec.pop[context](p.context);\n }\n \n impure fn add_token(ps p, token tok) {\n@@ -110,7 +110,8 @@ impure fn finish_block_scan(ps p, contexttype tp) {\n   }\n   p.scandepth = 0u;\n   push_context(p, tp, indent);\n-  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+  _vec.shift[token](p.buffered);\n+  for (token t in p.buffered) { add_token(p, t); }\n }\n \n impure fn finish_break_scan(ps p) {\n@@ -125,7 +126,8 @@ impure fn finish_break_scan(ps p) {\n     p.col += width;\n   }\n   p.scandepth = 0u;\n-  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+  _vec.shift[token](p.buffered);\n+  for (token t in p.buffered) { add_token(p, t); }\n }\n \n impure fn start_scan(ps p, token tok) {"}, {"sha": "1f9b455bce674def0144589e125a4fc344dcc785", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -717,7 +717,7 @@ fn escape_str(str st, char to_escape) -> str {\n       case ('\\\\') {out += \"\\\\\\\\\";}\n       case (?cur) {\n         if (cur == to_escape) {out += \"\\\\\";}\n-        out += cur as u8;\n+        _str.push_byte(out, cur as u8);\n       }\n     }\n     i += 1u;"}, {"sha": "4b4f54818e900fc613d0654753fa35e3403b80d8", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -68,15 +68,6 @@ fn istr(int i) -> str {\n     ret _int.to_str(i, 10u);\n }\n \n-\n-// FIXME: Weird bug. Due to the way we auto-deref + in +=, we can't append a\n-// boxed value to a vector-of-boxes using +=.  Best to figure out a way to fix\n-// this. Deref-on-demand or something? It's a hazard of the ambiguity between\n-// single-element and vector append.\n-fn append[T](&mutable vec[T] v, &T t) {\n-    v += t;\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "db9413b9278e3b4176397b78b0acb9769f1daee3", "filename": "src/lib/_str.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -111,6 +111,11 @@ fn unsafe_from_bytes(vec[u8] v) -> str {\n     ret rustrt.str_from_vec(v);\n }\n \n+fn unsafe_from_byte(u8 u) -> str {\n+    ret rustrt.str_from_vec(vec(u));\n+}\n+\n+\n fn refcount(str s) -> uint {\n     auto r = rustrt.refcount[u8](s);\n     if (r == dbg.const_refcount) {\n@@ -190,7 +195,6 @@ fn starts_with(str haystack, str needle) -> bool {\n     ret eq(substr(haystack, 0u, needle_len), needle);\n }\n \n-\n fn ends_with(str haystack, str needle) -> bool {\n     let uint haystack_len = byte_len(haystack);\n     let uint needle_len = byte_len(needle);\n@@ -206,34 +210,60 @@ fn ends_with(str haystack, str needle) -> bool {\n            needle);\n }\n \n-\n fn substr(str s, uint begin, uint len) -> str {\n     let str accum = \"\";\n     let uint i = begin;\n     while (i < begin+len) {\n-        accum += s.(i);\n+        accum += unsafe_from_byte(s.(i));\n         i += 1u;\n     }\n     ret accum;\n }\n \n+fn shift_byte(&mutable str s) -> u8 {\n+    auto len = byte_len(s);\n+    check(len > 0u);\n+    auto b = s.(0);\n+    s = substr(s, 1u, len - 1u);\n+    ret b;\n+}\n+\n+fn pop_byte(&mutable str s) -> u8 {\n+    auto len = byte_len(s);\n+    check(len > 0u);\n+    auto b = s.(len - 1u);\n+    s = substr(s, 0u, len - 1u);\n+    ret b;\n+}\n+\n+fn push_byte(&mutable str s, u8 b) {\n+    s += unsafe_from_byte(b);\n+}\n+\n+fn unshift_byte(&mutable str s, u8 b) {\n+    auto res = alloc(byte_len(s) + 1u);\n+    res += unsafe_from_byte(b);\n+    res += s;\n+    s = res;\n+}\n+\n fn split(str s, u8 sep) -> vec[str] {\n     let vec[str] v = vec();\n     let str accum = \"\";\n     let bool ends_with_sep = false;\n     for (u8 c in s) {\n         if (c == sep) {\n-            v += accum;\n+            v += vec(accum);\n             accum = \"\";\n             ends_with_sep = true;\n         } else {\n-            accum += c;\n+            accum += unsafe_from_byte(c);\n             ends_with_sep = false;\n         }\n     }\n     if (_str.byte_len(accum) != 0u ||\n         ends_with_sep) {\n-        v += accum;\n+        v += vec(accum);\n     }\n     ret v;\n }"}, {"sha": "5e8d4b975e3847028d84939c3be5cea4046a8d3f", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -61,15 +61,15 @@ fn to_str(mutable uint n, uint radix) -> str\n \n     let str s = \"\";\n     while (n != 0u) {\n-        s += digit(n % radix) as u8;\n+        s += _str.unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n \n     let str s1 = \"\";\n     let uint len = _str.byte_len(s);\n     while (len != 0u) {\n         len -= 1u;\n-        s1 += s.(len);\n+        s1 += _str.unsafe_from_byte(s.(len));\n     }\n     ret s1;\n "}, {"sha": "80cd242d2c8fe0af3106996c3e6e773e2cf2ab2f", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -103,28 +103,32 @@ fn slice[T](vec[T] v, uint start, uint end) -> vec[T] {\n     ret result;\n }\n \n-fn shift[T](vec[T] v) -> vec[T] {\n-    check(len[T](v) > 0u);\n-    ret slice[T](v, 1u, len[T](v));\n+fn shift[T](&mutable vec[T] v) -> T {\n+    auto ln = len[T](v);\n+    check(ln > 0u);\n+    auto e = v.(0);\n+    v = slice[T](v, 1u, ln);\n+    ret e;\n }\n \n-fn pop[T](vec[T] v) -> vec[T] {\n-    check(len[T](v) > 0u);\n-    ret slice[T](v, 0u, len[T](v) - 1u);\n+fn pop[T](&mutable vec[T] v) -> T {\n+    auto ln = len[T](v);\n+    check(ln > 0u);\n+    ln -= 1u;\n+    auto e = v.(ln);\n+    v = slice[T](v, 0u, ln);\n+    ret e;\n }\n \n-fn push[T](vec[T] v, &T t) -> vec[T] {\n-    v += t;\n-    ret v;\n+fn push[T](&mutable vec[T] v, &T t) {\n+    v += vec(t);\n }\n \n-fn unshift[T](vec[T] v, &T t) -> vec[T] {\n+fn unshift[T](&mutable vec[T] v, &T t) {\n     auto res = alloc[T](len[T](v) + 1u);\n-    res += t;\n-    for (T t_ in v) {\n-        res += t_;\n-    }\n-    ret res;\n+    res += vec(t);\n+    res += v;\n+    v = res;\n }\n \n fn grow[T](&mutable vec[T] v, int n, &T initval) {\n@@ -152,7 +156,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &vec[T] v0, &vec[U] v1) -> vec[V] {\n     let vec[V] u = alloc[V](v0_len);\n     auto i = 0u;\n     while (i < v0_len) {\n-        u += f(v0.(i), v1.(i));\n+        u += vec(f(v0.(i), v1.(i)));\n         i += 1u;\n     }\n "}, {"sha": "677bbcc4ec867b3b84372f1f0b2c40010a74a339", "filename": "src/lib/fs.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -38,8 +38,18 @@ impure fn list_dir(path p) -> vec[str] {\n   let vec[str] full_paths = vec();\n   for (str filename in os_fs.list_dir(p)) {\n     if (!_str.eq(filename, \".\")) {if (!_str.eq(filename, \"..\")) {\n-      full_paths = _vec.push[str](full_paths, p + filename);\n+      _vec.push[str](full_paths, p + filename);\n     }}\n   }\n   ret full_paths;\n }\n+\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "676d4150e3cd01fd5550b0d750880e1fb4783e64", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -10,10 +10,19 @@ impure fn list_dir(str path) -> vec[str] {\n   while (true) {\n     auto ent = os.libc.readdir(dir);\n     if (ent as int == 0) {break;}\n-    result = _vec.push[str](result, rustrt.rust_dirent_filename(ent));\n+    _vec.push[str](result, rustrt.rust_dirent_filename(ent));\n   }\n   os.libc.closedir(dir);\n   ret result;\n }\n \n const char path_sep = '/';\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "f3ea95a1d644c90ebcdc13724fa0faddff7023f1", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -8,9 +8,9 @@ native \"rust\" mod rustrt {\n fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n     auto argptrs = vec(_str.buf(prog));\n     for (str arg in args) {\n-        argptrs = _vec.push[sbuf](argptrs, _str.buf(arg));\n+        _vec.push[sbuf](argptrs, _str.buf(arg));\n     }\n-    argptrs = _vec.push[sbuf](argptrs, 0 as sbuf);\n+    _vec.push[sbuf](argptrs, 0 as sbuf);\n     ret argptrs;\n }\n "}, {"sha": "6b4e623b55081f0e85e3cc3c40298d8e987ce98c", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -169,10 +169,11 @@ fn mk_sha1() -> sha1 {\n \n         let vec[u8] res = vec();\n         for (u32 hpart in st.h) {\n-            res += (hpart >> 24u32) & 0xFFu32 as u8;\n-            res += (hpart >> 16u32) & 0xFFu32 as u8;\n-            res += (hpart >> 8u32) & 0xFFu32 as u8;\n-            res += hpart & 0xFFu32 as u8;\n+            auto a = (hpart >> 24u32) & 0xFFu32 as u8;\n+            auto b = (hpart >> 16u32) & 0xFFu32 as u8;\n+            auto c = (hpart >> 8u32) & 0xFFu32 as u8;\n+            auto d = (hpart & 0xFFu32 as u8);\n+            res += vec(a,b,c,d);\n         }\n         ret res;\n     }"}, {"sha": "52839b1f6ac69b95302d904bfc54eea82613bc32", "filename": "src/lib/sort.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -5,38 +5,38 @@ type lteq[T] = fn(&T a, &T b) -> bool;\n \n fn merge_sort[T](lteq[T] le, vec[T] v) -> vec[T] {\n \n-  fn merge[T](lteq[T] le, vec[T] a, vec[T] b) -> vec[T] {\n-    let vec[T] res = vec();\n-    let uint a_len = len[T](a);\n-    let uint a_ix = 0u;\n-    let uint b_len = len[T](b);\n-    let uint b_ix = 0u;\n-    while (a_ix < a_len && b_ix < b_len) {\n-      if (le(a.(a_ix), b.(b_ix))) {\n-        res += a.(a_ix);\n-        a_ix += 1u;\n-      } else {\n-        res += b.(b_ix);\n-        b_ix += 1u;\n-      }\n+    fn merge[T](lteq[T] le, vec[T] a, vec[T] b) -> vec[T] {\n+        let vec[T] res = vec();\n+        let uint a_len = len[T](a);\n+        let uint a_ix = 0u;\n+        let uint b_len = len[T](b);\n+        let uint b_ix = 0u;\n+        while (a_ix < a_len && b_ix < b_len) {\n+            if (le(a.(a_ix), b.(b_ix))) {\n+                res += vec(a.(a_ix));\n+                a_ix += 1u;\n+            } else {\n+                res += vec(b.(b_ix));\n+                b_ix += 1u;\n+            }\n+        }\n+        res += slice[T](a, a_ix, a_len);\n+        res += slice[T](b, b_ix, b_len);\n+        ret res;\n     }\n-    res += slice[T](a, a_ix, a_len);\n-    res += slice[T](b, b_ix, b_len);\n-    ret res;\n-  }\n \n-  let uint v_len = len[T](v);\n+    let uint v_len = len[T](v);\n \n-  if (v_len <= 1u) {\n-    ret v;\n-  }\n+    if (v_len <= 1u) {\n+        ret v;\n+    }\n \n-  let uint mid = v_len / 2u;\n-  let vec[T] a = slice[T](v, 0u, mid);\n-  let vec[T] b = slice[T](v, mid, v_len);\n-  ret merge[T](le,\n-               merge_sort[T](le, a),\n-               merge_sort[T](le, b));\n+    let uint mid = v_len / 2u;\n+    let vec[T] a = slice[T](v, 0u, mid);\n+    let vec[T] b = slice[T](v, mid, v_len);\n+    ret merge[T](le,\n+                 merge_sort[T](le, a),\n+                 merge_sort[T](le, b));\n }\n \n // Local Variables:"}, {"sha": "7a3cdbb206aeda66af27f66abeeb227d738b576e", "filename": "src/lib/std.rc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -34,6 +34,17 @@ auth _str = unsafe;\n auth _vec = unsafe;\n auth _task = unsafe;\n \n+\n+// FIXME: impure on these will infect caller in a way that is totally\n+// beyond reason, if the caller's mutated-argument doesn't escape;\n+// 'impure' needs work.\n+auth _str.unshift_byte = impure;\n+auth _str.shift_byte = impure;\n+auth _str.pop_byte = impure;\n+auth _vec.shift = impure;\n+auth _vec.unshift = impure;\n+auth _vec.pop = impure;\n+\n auth dbg = unsafe;\n \n auth _uint.next_power_of_two = unsafe;"}, {"sha": "f88d7798f9cc9f8892660a08737eb657661d9afd", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -8,3 +8,12 @@ impure fn list_dir(str path) -> vec[str] {\n }\n \n const char path_sep = '\\\\';\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "096389416a85516e743748f972f8feaaab45fec3", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -40,7 +40,7 @@ case (1) {\n       b += ns;\n     }\n     else {\n-      b += t.(i);\n+      _str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "3c426f51036c5b8b100a122e9f4c56aae53edae4", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -39,7 +39,7 @@ case (1) {\n       b += ns;\n     }\n     else {\n-      b += t.(i);\n+      _str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "f88f4330fcef624fd2cfd2b93fcd21e128fcddf5", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54587bdccb7b6771cfc704a30fc0ef2c65824a15/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=54587bdccb7b6771cfc704a30fc0ef2c65824a15", "patch": "@@ -28,7 +28,7 @@ fn make_cumulative(vec[aminoacids] aa) -> vec[aminoacids] {\n   let vec[aminoacids] ans = vec();\n   for (aminoacids a in aa) {\n     cp += a._1;\n-    ans += tup(a._0, cp);\n+    ans += vec(tup(a._0, cp));\n   }\n   ret ans;\n }\n@@ -59,7 +59,7 @@ fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n   auto rng = myrandom(std.rand.mk_rng().next());\n   let str op = \"\";\n   for each (uint i in _uint.range(0u, n as uint)) {\n-    op += select_random(rng.next(100u32), genelist) as u8;\n+    _str.push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n     if (_str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n@@ -76,7 +76,7 @@ fn make_repeat_fasta(str id, str desc, str s, int n) {\n   let uint sl = _str.byte_len(s);\n   for each (uint i in _uint.range(0u, n as uint)) {\n \n-    op += s.(i % sl);\n+    _str.push_byte(op, s.(i % sl));\n     if (_str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";"}, {"sha": "05b3478ba0daa77e36700e362587a995ca03b1c9", "filename": "src/test/run-pass/append-units.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23eef4da22d55ad530f349dfd2dd40141258956f/src%2Ftest%2Frun-pass%2Fappend-units.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23eef4da22d55ad530f349dfd2dd40141258956f/src%2Ftest%2Frun-pass%2Fappend-units.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fappend-units.rs?ref=23eef4da22d55ad530f349dfd2dd40141258956f", "patch": "@@ -1,15 +0,0 @@\n-fn main() {\n-  auto v = vec(1,2,3);\n-  v += 4;\n-  v += 5;\n-  check (v.(3) == 4);\n-  check (v.(4) == 5);\n-\n-  auto s = \"hello\";\n-  log s;\n-  s += 'z' as u8;\n-  s += 'y' as u8;\n-  log s;\n-  check (s.(5) == 'z' as u8);\n-  check (s.(6) == 'y' as u8);\n-}"}]}