{"sha": "c65f39dac4114052eee2a900a287d767d8b678c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NWYzOWRhYzQxMTQwNTJlZWUyYTkwMGEyODdkNzY3ZDhiNjc4YzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-16T13:08:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-16T13:08:35Z"}, "message": "Rollup merge of #73237 - tmiasko:arena, r=nnethercote\n\nCheck for overflow in DroplessArena and align returned memory\n\n* Check for overflow when calculating the slice start & end position.\n* Align the pointer obtained from the allocator, ensuring that it\n  satisfies user requested alignment (the allocator is only asked for\n  layout compatible with u8 slice).\n* Remove an incorrect assertion from DroplessArena::align.\n* Avoid forming references to an uninitialized memory in DroplessArena.\n\nHelps with #73007, #72624.", "tree": {"sha": "09c64fc7b41ffb71c1f656783ef84a976acb677b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09c64fc7b41ffb71c1f656783ef84a976acb677b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c65f39dac4114052eee2a900a287d767d8b678c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6MRUCRBK7hj4Ov3rIwAAdHIIAEP7YjzdFHdwqmYoGA4iUPCO\nd06op3risMDUy2aG/W7S95D0QEYdhg6UtgRPoeplobiyilaIVEyXGRuEOYZZgPnV\nTBmDwkiLV4ULNQr10lnZNdpc82TM+gNf8g/tUHMBTEhC+njMOR7d7tmWUe3YuP2p\nATzPQJIwK+7u2Qm/8JAJDZ49cpQNgurO8AZ/jJdX0irxJUnmZm808iku5q7Heg1T\nYnsT15IMX+0CCGV9SaRCR/IFxot4C9fKNv0csIYvW3Ks/uJStqjYh0l3DoSOl9i6\nUQk1jjwbgfg7LpYCI8dEenOTwrWBdTwZ1cqSC8HNR3UJG7N+IN9IUAh+Sn7nciA=\n=WDeg\n-----END PGP SIGNATURE-----\n", "payload": "tree 09c64fc7b41ffb71c1f656783ef84a976acb677b\nparent c8a9c340de32cb70c8bad8af1a4474f805c5a969\nparent 1f0895162ba5a783d4d73d5c263552eaca9343b3\nauthor Dylan DPC <dylan.dpc@gmail.com> 1592312915 +0200\ncommitter GitHub <noreply@github.com> 1592312915 +0200\n\nRollup merge of #73237 - tmiasko:arena, r=nnethercote\n\nCheck for overflow in DroplessArena and align returned memory\n\n* Check for overflow when calculating the slice start & end position.\n* Align the pointer obtained from the allocator, ensuring that it\n  satisfies user requested alignment (the allocator is only asked for\n  layout compatible with u8 slice).\n* Remove an incorrect assertion from DroplessArena::align.\n* Avoid forming references to an uninitialized memory in DroplessArena.\n\nHelps with #73007, #72624.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c65f39dac4114052eee2a900a287d767d8b678c6", "html_url": "https://github.com/rust-lang/rust/commit/c65f39dac4114052eee2a900a287d767d8b678c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c65f39dac4114052eee2a900a287d767d8b678c6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a9c340de32cb70c8bad8af1a4474f805c5a969", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a9c340de32cb70c8bad8af1a4474f805c5a969", "html_url": "https://github.com/rust-lang/rust/commit/c8a9c340de32cb70c8bad8af1a4474f805c5a969"}, {"sha": "1f0895162ba5a783d4d73d5c263552eaca9343b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0895162ba5a783d4d73d5c263552eaca9343b3", "html_url": "https://github.com/rust-lang/rust/commit/1f0895162ba5a783d4d73d5c263552eaca9343b3"}], "stats": {"total": 74, "additions": 42, "deletions": 32}, "files": [{"sha": "66c31cbebcc1efbea0181492aad8a29bcf312231", "filename": "src/librustc_arena/lib.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c65f39dac4114052eee2a900a287d767d8b678c6/src%2Flibrustc_arena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65f39dac4114052eee2a900a287d767d8b678c6/src%2Flibrustc_arena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_arena%2Flib.rs?ref=c65f39dac4114052eee2a900a287d767d8b678c6", "patch": "@@ -333,13 +333,6 @@ impl Default for DroplessArena {\n }\n \n impl DroplessArena {\n-    #[inline]\n-    fn align(&self, align: usize) {\n-        let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n-        self.ptr.set(final_address as *mut u8);\n-        assert!(self.ptr <= self.end);\n-    }\n-\n     #[inline(never)]\n     #[cold]\n     fn grow(&self, additional: usize) {\n@@ -370,30 +363,50 @@ impl DroplessArena {\n         }\n     }\n \n+    /// Allocates a byte slice with specified size and alignment from the\n+    /// current memory chunk. Returns `None` if there is no free space left to\n+    /// satisfy the request.\n     #[inline]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n-        unsafe {\n-            assert!(bytes != 0);\n-\n-            self.align(align);\n+    fn alloc_raw_without_grow(&self, bytes: usize, align: usize) -> Option<*mut u8> {\n+        let ptr = self.ptr.get() as usize;\n+        let end = self.end.get() as usize;\n+        // The allocation request fits into the current chunk iff:\n+        //\n+        // let aligned = align_to(ptr, align);\n+        // ptr <= aligned && aligned + bytes <= end\n+        //\n+        // Except that we work with fixed width integers and need to be careful\n+        // about potential overflow in the calcuation. If the overflow does\n+        // happen, then we definitely don't have enough free and need to grow\n+        // the arena.\n+        let aligned = ptr.checked_add(align - 1)? & !(align - 1);\n+        let new_ptr = aligned.checked_add(bytes)?;\n+        if new_ptr <= end {\n+            self.ptr.set(new_ptr as *mut u8);\n+            Some(aligned as *mut u8)\n+        } else {\n+            None\n+        }\n+    }\n \n-            let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n-            if (future_end as *mut u8) > self.end.get() {\n-                self.grow(bytes);\n+    #[inline]\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> *mut u8 {\n+        assert!(bytes != 0);\n+        loop {\n+            if let Some(a) = self.alloc_raw_without_grow(bytes, align) {\n+                break a;\n             }\n-\n-            let ptr = self.ptr.get();\n-            // Set the pointer past ourselves\n-            self.ptr.set(intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8);\n-            slice::from_raw_parts_mut(ptr, bytes)\n+            // No free space left. Allocate a new chunk to satisfy the request.\n+            // On failure the grow will panic or abort.\n+            self.grow(bytes);\n         }\n     }\n \n     #[inline]\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         assert!(!mem::needs_drop::<T>());\n \n-        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n \n         unsafe {\n             // Write into uninitialized memory.\n@@ -418,13 +431,11 @@ impl DroplessArena {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!slice.is_empty());\n \n-        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut _\n-            as *mut T;\n+        let mem = self.alloc_raw(slice.len() * mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n \n         unsafe {\n-            let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n-            arena_slice.copy_from_slice(slice);\n-            arena_slice\n+            mem.copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n+            slice::from_raw_parts_mut(mem, slice.len())\n         }\n     }\n \n@@ -467,7 +478,7 @@ impl DroplessArena {\n                     return &mut [];\n                 }\n                 let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n-                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n+                let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut T;\n                 unsafe { self.write_from_iter(iter, len, mem) }\n             }\n             (_, _) => {\n@@ -482,7 +493,7 @@ impl DroplessArena {\n                         let len = vec.len();\n                         let start_ptr = self\n                             .alloc_raw(len * mem::size_of::<T>(), mem::align_of::<T>())\n-                            as *mut _ as *mut T;\n+                            as *mut T;\n                         vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n                         vec.set_len(0);\n                         slice::from_raw_parts_mut(start_ptr, len)\n@@ -526,8 +537,7 @@ pub struct DropArena {\n impl DropArena {\n     #[inline]\n     pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n-        let mem =\n-            self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n+        let mem = self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut T;\n         // Write into uninitialized memory.\n         ptr::write(mem, object);\n         let result = &mut *mem;\n@@ -550,7 +560,7 @@ impl DropArena {\n         let start_ptr = self\n             .arena\n             .alloc_raw(len.checked_mul(mem::size_of::<T>()).unwrap(), mem::align_of::<T>())\n-            as *mut _ as *mut T;\n+            as *mut T;\n \n         let mut destructors = self.destructors.borrow_mut();\n         // Reserve space for the destructors so we can't panic while adding them"}, {"sha": "76c72e4c2603d53f7d8673b4fe9e73c548351ed9", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c65f39dac4114052eee2a900a287d767d8b678c6/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c65f39dac4114052eee2a900a287d767d8b678c6/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=c65f39dac4114052eee2a900a287d767d8b678c6", "patch": "@@ -55,7 +55,7 @@ impl<T: Copy> List<T> {\n             .dropless\n             .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n-            let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n+            let result = &mut *(mem as *mut List<T>);\n             // Write the length\n             result.len = slice.len();\n "}]}