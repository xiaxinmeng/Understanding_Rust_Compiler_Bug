{"sha": "4ac1796267c3af95cb97d630639d8938237586f6", "node_id": "C_kwDOAAsO6NoAKDRhYzE3OTYyNjdjM2FmOTVjYjk3ZDYzMDYzOWQ4OTM4MjM3NTg2ZjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-30T16:50:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-30T16:50:08Z"}, "message": "Rollup merge of #107125 - WaffleLapkin:expect_an_item_in_your_hir_by_the_next_morning, r=Nilstrieb\n\nAdd and use expect methods to hir.\n\n[The future has come](https://github.com/rust-lang/rust/pull/106090/files#r1070062462).\n\nr? `@Nilstrieb`\n\ntbh I'm not even sure if it's worth it", "tree": {"sha": "4f8f980b5f3f3bcd8c05a27a55f5b2a263f0f21b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f8f980b5f3f3bcd8c05a27a55f5b2a263f0f21b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac1796267c3af95cb97d630639d8938237586f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj1/VACRBK7hj4Ov3rIwAARNAIAGPw3UMl3qwrM5+PdwZ0nsZF\n9yQmOQ2W5+Sh+/gGeqLRAvjJSODraMXRcKm5HSfru+TIdUHHnT0DBVlEMkTEzOQ5\n3BsH3lZMhaA5qgiauMlyGjQgukXF4jaR1mf5/mGXhAwZlcY2pB8+9MznMqCxYlK5\nRhIB3js9k9idrrShocaHTuX8ftmzXgS7Ejk8CM+YGqw5ZgvbYr+TwMfCnKrW8cad\n3WVyY4kh2DBV0+jYpL3a6ZwzZ+/DAa6sBEFdLkhgS1X/FzPpa6M9y6vSSlfbOWe7\n8h0XtKNxK1VW10ww5xj5kp+sRJ+cCeSvHvUevHMe05DBJFIgFK6ErPvtRi4U+lg=\n=73KE\n-----END PGP SIGNATURE-----\n", "payload": "tree 4f8f980b5f3f3bcd8c05a27a55f5b2a263f0f21b\nparent 006ca9b14da1e0145844598b3d6a554c042c702a\nparent 883145f75d105abc32911f536738f66d74d32f4f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675097408 +0100\ncommitter GitHub <noreply@github.com> 1675097408 +0100\n\nRollup merge of #107125 - WaffleLapkin:expect_an_item_in_your_hir_by_the_next_morning, r=Nilstrieb\n\nAdd and use expect methods to hir.\n\n[The future has come](https://github.com/rust-lang/rust/pull/106090/files#r1070062462).\n\nr? `@Nilstrieb`\n\ntbh I'm not even sure if it's worth it\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac1796267c3af95cb97d630639d8938237586f6", "html_url": "https://github.com/rust-lang/rust/commit/4ac1796267c3af95cb97d630639d8938237586f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac1796267c3af95cb97d630639d8938237586f6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006ca9b14da1e0145844598b3d6a554c042c702a", "url": "https://api.github.com/repos/rust-lang/rust/commits/006ca9b14da1e0145844598b3d6a554c042c702a", "html_url": "https://github.com/rust-lang/rust/commit/006ca9b14da1e0145844598b3d6a554c042c702a"}, {"sha": "883145f75d105abc32911f536738f66d74d32f4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/883145f75d105abc32911f536738f66d74d32f4f", "html_url": "https://github.com/rust-lang/rust/commit/883145f75d105abc32911f536738f66d74d32f4f"}], "stats": {"total": 403, "additions": 378, "deletions": 25}, "files": [{"sha": "a063307af0cb4109e7c14dddf7504df9584e9839", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 360, "deletions": 3, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -2263,7 +2263,7 @@ pub struct TraitItem<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-impl TraitItem<'_> {\n+impl<'hir> TraitItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2273,6 +2273,32 @@ impl TraitItem<'_> {\n     pub fn trait_item_id(&self) -> TraitItemId {\n         TraitItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`TraitItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, Option<BodyId>) {\n+        let TraitItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &TraitFn<'hir>) {\n+        let TraitItemKind::Fn(ty, trfn) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, trfn)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> (GenericBounds<'hir>, Option<&'hir Ty<'hir>>) {\n+        let TraitItemKind::Type(bounds, ty) = self.kind else { self.expect_failed(\"a type\") };\n+        (bounds, ty)\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents a trait method's body (or just argument names).\n@@ -2325,7 +2351,7 @@ pub struct ImplItem<'hir> {\n     pub vis_span: Span,\n }\n \n-impl ImplItem<'_> {\n+impl<'hir> ImplItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2335,6 +2361,32 @@ impl ImplItem<'_> {\n     pub fn impl_item_id(&self) -> ImplItemId {\n         ImplItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ImplItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ImplItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, BodyId) {\n+        let ImplItemKind::Fn(ty, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, *body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> &'hir Ty<'hir> {\n+        let ImplItemKind::Type(ty) = self.kind else { self.expect_failed(\"a type\") };\n+        ty\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents various kinds of content within an `impl`.\n@@ -2995,7 +3047,7 @@ pub struct Item<'hir> {\n     pub vis_span: Span,\n }\n \n-impl Item<'_> {\n+impl<'hir> Item<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -3005,6 +3057,132 @@ impl Item<'_> {\n     pub fn item_id(&self) -> ItemId {\n         ItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_extern_crate(&self) -> Option<Symbol> {\n+        let ItemKind::ExternCrate(s) = self.kind else { self.expect_failed(\"an extern crate\") };\n+        s\n+    }\n+\n+    /// Expect an [`ItemKind::Use`] or panic.\n+    #[track_caller]\n+    pub fn expect_use(&self) -> (&'hir UsePath<'hir>, UseKind) {\n+        let ItemKind::Use(p, uk) = self.kind else { self.expect_failed(\"a use\") };\n+        (p, uk)\n+    }\n+\n+    /// Expect an [`ItemKind::Static`] or panic.\n+    #[track_caller]\n+    pub fn expect_static(&self) -> (&'hir Ty<'hir>, Mutability, BodyId) {\n+        let ItemKind::Static(ty, mutbl, body) = self.kind else { self.expect_failed(\"a static\") };\n+        (ty, mutbl, body)\n+    }\n+    /// Expect an [`ItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+    /// Expect an [`ItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &'hir Generics<'hir>, BodyId) {\n+        let ItemKind::Fn(sig, gen, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (sig, gen, *body)\n+    }\n+\n+    /// Expect an [`ItemKind::Macro`] or panic.\n+    #[track_caller]\n+    pub fn expect_macro(&self) -> (&ast::MacroDef, MacroKind) {\n+        let ItemKind::Macro(def, mk) = &self.kind else { self.expect_failed(\"a macro\") };\n+        (def, *mk)\n+    }\n+\n+    /// Expect an [`ItemKind::Mod`] or panic.\n+    #[track_caller]\n+    pub fn expect_mod(&self) -> &'hir Mod<'hir> {\n+        let ItemKind::Mod(m) = self.kind else { self.expect_failed(\"a module\") };\n+        m\n+    }\n+\n+    /// Expect an [`ItemKind::ForeignMod`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_mod(&self) -> (Abi, &'hir [ForeignItemRef]) {\n+        let ItemKind::ForeignMod { abi, items } = self.kind else { self.expect_failed(\"a foreign module\") };\n+        (abi, items)\n+    }\n+\n+    /// Expect an [`ItemKind::GlobalAsm`] or panic.\n+    #[track_caller]\n+    pub fn expect_global_asm(&self) -> &'hir InlineAsm<'hir> {\n+        let ItemKind::GlobalAsm(asm) = self.kind else { self.expect_failed(\"a global asm\") };\n+        asm\n+    }\n+\n+    /// Expect an [`ItemKind::TyAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty_alias(&self) -> (&'hir Ty<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::TyAlias(ty, gen) = self.kind else { self.expect_failed(\"a type alias\") };\n+        (ty, gen)\n+    }\n+\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n+    /// Expect an [`ItemKind::OpaqueTy`] or panic.\n+    #[track_caller]\n+    pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n+        let ItemKind::OpaqueTy(ty) = &self.kind else { self.expect_failed(\"an opaque type\") };\n+        ty\n+    }\n+\n+    /// Expect an [`ItemKind::Enum`] or panic.\n+    #[track_caller]\n+    pub fn expect_enum(&self) -> (&EnumDef<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Enum(def, gen) = &self.kind else { self.expect_failed(\"an enum\") };\n+        (def, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Struct`] or panic.\n+    #[track_caller]\n+    pub fn expect_struct(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Struct(data, gen) = &self.kind else { self.expect_failed(\"a struct\") };\n+        (data, gen)\n+    }\n+\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n+    /// Expect an [`ItemKind::Union`] or panic.\n+    #[track_caller]\n+    pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Union(data, gen) = &self.kind else { self.expect_failed(\"a union\") };\n+        (data, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Trait`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait(\n+        self,\n+    ) -> (IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]) {\n+        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { self.expect_failed(\"a trait\") };\n+        (is_auto, unsafety, gen, bounds, items)\n+    }\n+\n+    /// Expect an [`ItemKind::TraitAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_alias(&self) -> (&'hir Generics<'hir>, GenericBounds<'hir>) {\n+        let ItemKind::TraitAlias(gen, bounds) = self.kind else { self.expect_failed(\"a trait alias\") };\n+        (gen, bounds)\n+    }\n+\n+    /// Expect an [`ItemKind::Impl`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl(&self) -> &'hir Impl<'hir> {\n+        let ItemKind::Impl(imp) = self.kind else { self.expect_failed(\"an impl\") };\n+        imp\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -3597,6 +3775,185 @@ impl<'hir> Node<'hir> {\n     pub fn tuple_fields(&self) -> Option<&'hir [FieldDef<'hir>]> {\n         if let Node::Ctor(&VariantData::Tuple(fields, _, _)) = self { Some(fields) } else { None }\n     }\n+\n+    /// Expect a [`Node::Param`] or panic.\n+    #[track_caller]\n+    pub fn expect_param(self) -> &'hir Param<'hir> {\n+        let Node::Param(this) = self else { self.expect_failed(\"a parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Item`] or panic.\n+    #[track_caller]\n+    pub fn expect_item(self) -> &'hir Item<'hir> {\n+        let Node::Item(this) = self else { self.expect_failed(\"a item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ForeignItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n+        let Node::ForeignItem(this) = self else { self.expect_failed(\"a foreign item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n+        let Node::TraitItem(this) = self else { self.expect_failed(\"a trait item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ImplItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n+        let Node::ImplItem(this) = self else { self.expect_failed(\"an implementation item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Variant`] or panic.\n+    #[track_caller]\n+    pub fn expect_variant(self) -> &'hir Variant<'hir> {\n+        let Node::Variant(this) = self else { self.expect_failed(\"a variant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Field`] or panic.\n+    #[track_caller]\n+    pub fn expect_field(self) -> &'hir FieldDef<'hir> {\n+        let Node::Field(this) = self else { self.expect_failed(\"a field definition\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::AnonConst`] or panic.\n+    #[track_caller]\n+    pub fn expect_anon_const(self) -> &'hir AnonConst {\n+        let Node::AnonConst(this) = self else { self.expect_failed(\"an anonymous constant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Expr`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr(self) -> &'hir Expr<'hir> {\n+        let Node::Expr(this) = self else { self.expect_failed(\"an expression\") };\n+        this\n+    }\n+    /// Expect a [`Node::ExprField`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr_field(self) -> &'hir ExprField<'hir> {\n+        let Node::ExprField(this) = self else { self.expect_failed(\"an expression field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Stmt`] or panic.\n+    #[track_caller]\n+    pub fn expect_stmt(self) -> &'hir Stmt<'hir> {\n+        let Node::Stmt(this) = self else { self.expect_failed(\"a statement\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PathSegment`] or panic.\n+    #[track_caller]\n+    pub fn expect_path_segment(self) -> &'hir PathSegment<'hir> {\n+        let Node::PathSegment(this) = self else { self.expect_failed(\"a path segment\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ty`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty(self) -> &'hir Ty<'hir> {\n+        let Node::Ty(this) = self else { self.expect_failed(\"a type\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TypeBinding`] or panic.\n+    #[track_caller]\n+    pub fn expect_type_binding(self) -> &'hir TypeBinding<'hir> {\n+        let Node::TypeBinding(this) = self else { self.expect_failed(\"a type binding\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitRef`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_ref(self) -> &'hir TraitRef<'hir> {\n+        let Node::TraitRef(this) = self else { self.expect_failed(\"a trait reference\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Pat`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat(self) -> &'hir Pat<'hir> {\n+        let Node::Pat(this) = self else { self.expect_failed(\"a pattern\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PatField`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat_field(self) -> &'hir PatField<'hir> {\n+        let Node::PatField(this) = self else { self.expect_failed(\"a pattern field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Arm`] or panic.\n+    #[track_caller]\n+    pub fn expect_arm(self) -> &'hir Arm<'hir> {\n+        let Node::Arm(this) = self else { self.expect_failed(\"an arm\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Block`] or panic.\n+    #[track_caller]\n+    pub fn expect_block(self) -> &'hir Block<'hir> {\n+        let Node::Block(this) = self else { self.expect_failed(\"a block\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Local`] or panic.\n+    #[track_caller]\n+    pub fn expect_local(self) -> &'hir Local<'hir> {\n+        let Node::Local(this) = self else { self.expect_failed(\"a local\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ctor`] or panic.\n+    #[track_caller]\n+    pub fn expect_ctor(self) -> &'hir VariantData<'hir> {\n+        let Node::Ctor(this) = self else { self.expect_failed(\"a constructor\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Lifetime`] or panic.\n+    #[track_caller]\n+    pub fn expect_lifetime(self) -> &'hir Lifetime {\n+        let Node::Lifetime(this) = self else { self.expect_failed(\"a lifetime\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::GenericParam`] or panic.\n+    #[track_caller]\n+    pub fn expect_generic_param(self) -> &'hir GenericParam<'hir> {\n+        let Node::GenericParam(this) = self else { self.expect_failed(\"a generic parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Crate`] or panic.\n+    #[track_caller]\n+    pub fn expect_crate(self) -> &'hir Mod<'hir> {\n+        let Node::Crate(this) = self else { self.expect_failed(\"a crate\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Infer`] or panic.\n+    #[track_caller]\n+    pub fn expect_infer(self) -> &'hir InferArg {\n+        let Node::Infer(this) = self else { self.expect_failed(\"an infer\") };\n+        this\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} node, found {self:?}\")\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "bec9f0ff0772cb8a9862d65f761f07282b4be2cf", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -3140,8 +3140,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n             hir.get(fn_hir_id) else { return None };\n-        let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n-                hir.get_parent(fn_hir_id) else { bug!(\"ImplItem should have Impl parent\") };\n+        let i = hir.get_parent(fn_hir_id).expect_item().expect_impl();\n \n         let trait_ref = self.instantiate_mono_trait_ref(\n             i.of_trait.as_ref()?,"}, {"sha": "3115f5f464a09c44969f09a03cd1d81db92dd27a", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n-use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_hir::{GenericParamKind, ImplItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n@@ -918,7 +918,7 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let (sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n             let span = tcx\n                 .hir()\n                 .body_param_names(body)\n@@ -1080,12 +1080,12 @@ fn extract_spans_for_error_reporting<'tcx>(\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n-        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (sig, _) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n \n     let trait_args = trait_m.def_id.as_local().map(|def_id| {\n-        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        let (sig, _) = tcx.hir().expect_trait_item(def_id).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     });\n \n@@ -1358,7 +1358,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             .def_id\n             .as_local()\n             .and_then(|def_id| {\n-                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let (trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).expect_fn();\n                 let pos = trait_number_args.saturating_sub(1);\n                 trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n@@ -1370,7 +1370,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             })\n             .or(trait_item_span);\n \n-        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n         let impl_span = impl_m_sig\n             .decl\n@@ -1506,7 +1506,7 @@ fn compare_synthetic_generics<'tcx>(\n                     let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let (sig, _) = impl_m.expect_fn();\n                         let input_tys = sig.decl.inputs;\n \n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n@@ -1704,7 +1704,7 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        let (ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).expect_const();\n         cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n@@ -1717,7 +1717,7 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            let (ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).expect_const();\n             ty.span\n         });\n "}, {"sha": "5b9b57da3820e48e8a2c42a8364db3971384d272", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -1072,8 +1072,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n                     hir_ty.span,\n@@ -1106,8 +1106,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             {\n                 let last = idx == variant.fields.len() - 1;\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new("}, {"sha": "5716be4f1a95445c5f4db941b7c89123f440c13b", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -29,7 +29,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n         if item.span.is_dummy() {\n             continue;\n         }\n-        let hir::ItemKind::Use(path, _) = item.kind else { unreachable!() };\n+        let (path, _) = item.expect_use();\n         let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {"}, {"sha": "6600e4216bd1f4a54304af6e41bc128ff22d4670", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -56,7 +56,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n+    let impl_ = tcx.hir().expect_item(impl_did).expect_impl();\n \n     tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }"}, {"sha": "c6b16171311fb0de221c0bbcb9c2c667a7aba35d", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -3,15 +3,13 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::Unsafety;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::LocalDefId;\n \n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = item.expect_impl();\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "cc7235a61c0b822ef6c9ba0cbc71162b2ab949f9", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac1796267c3af95cb97d630639d8938237586f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=4ac1796267c3af95cb97d630639d8938237586f6", "patch": "@@ -1348,8 +1348,7 @@ fn suggest_impl_trait<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = tcx.hir().expect_item(def_id.expect_local()).expect_impl();\n     impl_\n         .of_trait\n         .as_ref()"}]}