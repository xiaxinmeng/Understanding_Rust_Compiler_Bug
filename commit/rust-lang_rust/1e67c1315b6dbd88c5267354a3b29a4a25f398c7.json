{"sha": "1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNjdjMTMxNWI2ZGJkODhjNTI2NzM1NGEzYjI5YTRhMjVmMzk4Yzc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-02-23T18:24:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-23T18:24:48Z"}, "message": "Rollup merge of #48123 - nikomatsakis:issue-47244-expected-num-args, r=estebank\n\ndetect wrong number of args when type-checking a closure\n\nInstead of creating inference variables for those argument types, use\nthe trait error-reporting code to give a nicer error. This also\nimproves some other spans for existing tests.\n\nFixes #47244\n\nr? @estebank", "tree": {"sha": "1e212f8c4c5fefc729eefdfc82852b2838130f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e212f8c4c5fefc729eefdfc82852b2838130f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJakFxwCRBK7hj4Ov3rIwAAdHIIAJcDKve3tCOTmvr48reF6JbG\njUYLoM+pPkyaCBhJhmqS0qwQi+u7fzWv77lckA2/jrlEZZpvy36JQ/eLNBPnMoTl\nENjO1JSY5b8z6wu7Mk7pjp7XP45HvYE82l2GAOm/GSmPhCH3+tlRcCP8GrCN/cHm\n7hZJVPALKe/SViMle288QdcB7t2Cpb2VkxsdPhhXfLHPS9p4OXXIIW8DEXFuBR+d\n5aqpieySok13dr0b4ubQDgLfc9HV+P0jMgIY9mUACYpZF0/OjFmV/8uFzjvxIz3U\nfIuOD4nip3MFJg05MSkr/OEfIrcNH7r0EgIxwn3I58atZfxzHAYU+HZ2C4CbUXM=\n=72e7\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e212f8c4c5fefc729eefdfc82852b2838130f5d\nparent a1acb155915329be75e5e1b86e2744e01fc61e3e\nparent cc05561048f07ae5e99b25bbe5db04eebe0c7cd2\nauthor Manish Goregaokar <manishsmail@gmail.com> 1519410288 -0800\ncommitter GitHub <noreply@github.com> 1519410288 -0800\n\nRollup merge of #48123 - nikomatsakis:issue-47244-expected-num-args, r=estebank\n\ndetect wrong number of args when type-checking a closure\n\nInstead of creating inference variables for those argument types, use\nthe trait error-reporting code to give a nicer error. This also\nimproves some other spans for existing tests.\n\nFixes #47244\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "html_url": "https://github.com/rust-lang/rust/commit/1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1acb155915329be75e5e1b86e2744e01fc61e3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1acb155915329be75e5e1b86e2744e01fc61e3e", "html_url": "https://github.com/rust-lang/rust/commit/a1acb155915329be75e5e1b86e2744e01fc61e3e"}, {"sha": "cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2", "html_url": "https://github.com/rust-lang/rust/commit/cc05561048f07ae5e99b25bbe5db04eebe0c7cd2"}], "stats": {"total": 269, "additions": 218, "deletions": 51}, "files": [{"sha": "12d8d6f3d7481f15fa82ec8b42bb493ec21191b6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "patch": "@@ -747,7 +747,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyTuple(ref tys, _) => tys.iter()\n                         .map(|t| match t.sty {\n                             ty::TypeVariants::TyTuple(ref tys, _) => ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 tys.iter()\n                                     .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n                                     .collect::<Vec<_>>()\n@@ -815,7 +815,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n         match node {\n             hir::map::NodeExpr(&hir::Expr {\n                 node: hir::ExprClosure(_, ref _decl, id, span, _),\n@@ -829,7 +833,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             ..\n                         } = arg.pat.clone().into_inner() {\n                             ArgKind::Tuple(\n-                                span,\n+                                Some(span),\n                                 args.iter().map(|pat| {\n                                     let snippet = self.tcx.sess.codemap()\n                                         .span_to_snippet(pat.span).unwrap();\n@@ -862,7 +866,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n                         .map(|arg| match arg.clone().into_inner().node {\n                     hir::TyTup(ref tys) => ArgKind::Tuple(\n-                        arg.span,\n+                        Some(arg.span),\n                         tys.iter()\n                             .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n                             .collect::<Vec<_>>(),\n@@ -874,7 +878,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_arg_count_mismatch(\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n@@ -1385,13 +1392,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-enum ArgKind {\n+/// Summarizes information\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n     Arg(String, String),\n-    Tuple(Span, Vec<(String, String)>),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n }\n \n impl ArgKind {\n     fn empty() -> ArgKind {\n         ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n     }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. This has no name (`_`) and no source spans..\n+    pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n+        match t.sty {\n+            ty::TyTuple(ref tys, _) => ArgKind::Tuple(\n+                None,\n+                tys.iter()\n+                   .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n+                   .collect::<Vec<_>>()\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", t.sty)),\n+        }\n+    }\n }"}, {"sha": "520b997882e07afe8c5e3c4f2f7673ecd459ea88", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "patch": "@@ -49,7 +49,7 @@ pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n \n mod coherence;\n-mod error_reporting;\n+pub mod error_reporting;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "794d466ee7cdbf5b47d206efea90f9d90b5a3903", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 139, "deletions": 43, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "patch": "@@ -17,14 +17,24 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use rustc::traits::error_reporting::ArgKind;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use rustc::ty::subst::Substs;\n use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n+use syntax::codemap::Span;\n use rustc::hir;\n \n+/// What signature do we *expect* the closure to have from context?\n+#[derive(Debug)]\n+struct ExpectedSig<'tcx> {\n+    /// Span that gave us this expectation, if we know that.\n+    cause_span: Option<Span>,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n struct ClosureSignatures<'tcx> {\n     bound_sig: ty::PolyFnSig<'tcx>,\n     liberated_sig: ty::FnSig<'tcx>,\n@@ -42,8 +52,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_expr_closure(expr={:?},expected={:?})\",\n-            expr,\n-            expected\n+            expr, expected\n         );\n \n         // It's always helpful for inference if we know the kind of\n@@ -64,12 +73,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         decl: &'gcx hir::FnDecl,\n         body: &'gcx hir::Body,\n         gen: Option<hir::GeneratorMovability>,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> Ty<'tcx> {\n         debug!(\n             \"check_closure(opt_kind={:?}, expected_sig={:?})\",\n-            opt_kind,\n-            expected_sig\n+            opt_kind, expected_sig\n         );\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n@@ -109,19 +117,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         if let Some(GeneratorTypes { yield_ty, interior }) = generator_types {\n-            self.demand_eqtype(expr.span,\n-                               yield_ty,\n-                               substs.generator_yield_ty(expr_def_id, self.tcx));\n-            self.demand_eqtype(expr.span,\n-                               liberated_sig.output(),\n-                               substs.generator_return_ty(expr_def_id, self.tcx));\n+            self.demand_eqtype(\n+                expr.span,\n+                yield_ty,\n+                substs.generator_yield_ty(expr_def_id, self.tcx),\n+            );\n+            self.demand_eqtype(\n+                expr.span,\n+                liberated_sig.output(),\n+                substs.generator_return_ty(expr_def_id, self.tcx),\n+            );\n             return self.tcx.mk_generator(expr_def_id, substs, interior);\n         }\n \n         debug!(\n             \"check_closure: expr.id={:?} closure_type={:?}\",\n-            expr.id,\n-            closure_type\n+            expr.id, closure_type\n         );\n \n         // Tuple up the arguments and insert the resulting function type into\n@@ -138,29 +149,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n-            expr_def_id,\n-            sig,\n-            opt_kind\n+            expr_def_id, sig, opt_kind\n         );\n \n         let sig_fn_ptr_ty = self.tcx.mk_fn_ptr(sig);\n-        self.demand_eqtype(expr.span,\n-                           sig_fn_ptr_ty,\n-                           substs.closure_sig_ty(expr_def_id, self.tcx));\n+        self.demand_eqtype(\n+            expr.span,\n+            sig_fn_ptr_ty,\n+            substs.closure_sig_ty(expr_def_id, self.tcx),\n+        );\n \n         if let Some(kind) = opt_kind {\n-            self.demand_eqtype(expr.span,\n-                               kind.to_ty(self.tcx),\n-                               substs.closure_kind_ty(expr_def_id, self.tcx));\n+            self.demand_eqtype(\n+                expr.span,\n+                kind.to_ty(self.tcx),\n+                substs.closure_kind_ty(expr_def_id, self.tcx),\n+            );\n         }\n \n         closure_type\n     }\n \n+    /// Given the expected type, figures out what it can about this closure we\n+    /// are about to type check:\n     fn deduce_expectations_from_expected_type(\n         &self,\n         expected_ty: Ty<'tcx>,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         debug!(\n             \"deduce_expectations_from_expected_type(expected_ty={:?})\",\n             expected_ty\n@@ -172,7 +187,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n-                        self.deduce_sig_from_projection(&pb)\n+                        self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n                 let kind = object_type\n@@ -181,15 +196,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n-            ty::TyFnPtr(sig) => (Some(sig.skip_binder().clone()), Some(ty::ClosureKind::Fn)),\n+            ty::TyFnPtr(sig) => {\n+                let expected_sig = ExpectedSig {\n+                    cause_span: None,\n+                    sig: sig.skip_binder().clone(),\n+                };\n+                (Some(expected_sig), Some(ty::ClosureKind::Fn))\n+            }\n             _ => (None, None),\n         }\n     }\n \n     fn deduce_expectations_from_obligations(\n         &self,\n         expected_vid: ty::TyVid,\n-    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n@@ -209,7 +230,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Projection(ref proj_predicate) => {\n                         let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n                         self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                            .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n+                            .and_then(|_| {\n+                                self.deduce_sig_from_projection(\n+                                    Some(obligation.cause.span),\n+                                    proj_predicate,\n+                                )\n+                            })\n                     }\n                     _ => None,\n                 }\n@@ -259,10 +285,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n+    ///\n+    /// The `cause_span` should be the span that caused us to\n+    /// have this expected signature, or `None` if we can't readily\n+    /// know that.\n     fn deduce_sig_from_projection(\n         &self,\n+        cause_span: Option<Span>,\n         projection: &ty::PolyProjectionPredicate<'tcx>,\n-    ) -> Option<ty::FnSig<'tcx>> {\n+    ) -> Option<ExpectedSig<'tcx>> {\n         let tcx = self.tcx;\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n@@ -294,16 +325,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_param_ty\n         );\n \n-        let fn_sig = self.tcx.mk_fn_sig(\n+        let sig = self.tcx.mk_fn_sig(\n             input_tys.cloned(),\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         );\n-        debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n+        debug!(\"deduce_sig_from_projection: sig {:?}\", sig);\n \n-        Some(fn_sig)\n+        Some(ExpectedSig { cause_span, sig })\n     }\n \n     fn self_type_matches_expected_vid(\n@@ -314,8 +345,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let self_ty = self.shallow_resolve(trait_ref.self_ty());\n         debug!(\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-            trait_ref,\n-            self_ty\n+            trait_ref, self_ty\n         );\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n@@ -328,7 +358,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: Option<ty::FnSig<'tcx>>,\n+        expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n             self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n@@ -404,7 +434,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n         body: &hir::Body,\n-        expected_sig: ty::FnSig<'tcx>,\n+        expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\n             \"sig_of_closure_with_expectation(expected_sig={:?})\",\n@@ -414,20 +444,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n         // expect.\n-        if expected_sig.variadic != decl.variadic {\n-            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n-        } else if expected_sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n-            // we could probably handle this case more gracefully\n+        if expected_sig.sig.variadic != decl.variadic {\n             return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        } else if expected_sig.sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+            return self.sig_of_closure_with_mismatched_number_of_arguments(\n+                expr_def_id,\n+                decl,\n+                body,\n+                expected_sig,\n+            );\n         }\n \n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.has_regions_escaping_depth(1));\n+        assert!(!expected_sig.sig.has_regions_escaping_depth(1));\n         let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n-            expected_sig.inputs().iter().cloned(),\n-            expected_sig.output(),\n+            expected_sig.sig.inputs().iter().cloned(),\n+            expected_sig.sig.output(),\n             decl.variadic,\n             hir::Unsafety::Normal,\n             Abi::RustCall,\n@@ -453,6 +487,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_sigs\n     }\n \n+    fn sig_of_closure_with_mismatched_number_of_arguments(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: ExpectedSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        let expr_map_node = self.tcx.hir.get_if_local(expr_def_id).unwrap();\n+        let expected_args: Vec<_> = expected_sig\n+            .sig\n+            .inputs()\n+            .iter()\n+            .map(|ty| ArgKind::from_expected_ty(ty))\n+            .collect();\n+        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n+        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        self.report_arg_count_mismatch(\n+            expected_span,\n+            Some(closure_span),\n+            expected_args,\n+            found_args,\n+            true,\n+        ).emit();\n+\n+        let error_sig = self.error_sig_of_closure(decl);\n+\n+        self.closure_sigs(expr_def_id, body, error_sig)\n+    }\n+\n     /// Enforce the user's types against the expectation.  See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n@@ -558,13 +621,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n+    /// Converts the types that the user supplied, in case that doing\n+    /// so should yield an error, but returns back a signature where\n+    /// all parameters are of type `TyErr`.\n+    fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+        let astconv: &AstConv = self;\n+\n+        let supplied_arguments = decl.inputs.iter().map(|a| {\n+            // Convert the types that the user supplied (if any), but ignore them.\n+            astconv.ast_ty_to_ty(a);\n+            self.tcx.types.err\n+        });\n+\n+        match decl.output {\n+            hir::Return(ref output) => {\n+                astconv.ast_ty_to_ty(&output);\n+            }\n+            hir::DefaultReturn(_) => {}\n+        }\n+\n+        let result = ty::Binder(self.tcx.mk_fn_sig(\n+            supplied_arguments,\n+            self.tcx.types.err,\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n+\n+        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+\n+        result\n+    }\n+\n     fn closure_sigs(\n         &self,\n         expr_def_id: DefId,\n         body: &hir::Body,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.tcx()\n+            .liberate_late_bound_regions(expr_def_id, &bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n             body.value.id,"}, {"sha": "b6463ca067b7f5c7eb1faba7e36f396e7ca3e8c8", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.rs?ref=1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #47244: in this specific scenario, when the\n+// expected type indicated 1 argument but the closure takes two, we\n+// would (early on) create type variables for the type of `b`. If the\n+// user then attempts to invoke a method on `b`, we would get an error\n+// saying that the type of `b` must be known, which was not very\n+// helpful.\n+\n+use std::collections::HashMap;\n+fn main() {\n+\n+    let m = HashMap::new();\n+    m.insert( \"foo\", \"bar\" );\n+\n+    m.iter().map( |_, b| {\n+        //~^ ERROR closure is expected to take a single 2-tuple\n+\n+        b.to_string()\n+    });\n+}"}, {"sha": "34934b8d19598c43e07d750c32dadc2f68746682", "filename": "src/test/ui/mismatched_types/closure-arg-count-expected-type-issue-47244.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e67c1315b6dbd88c5267354a3b29a4a25f398c7/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count-expected-type-issue-47244.stderr?ref=1e67c1315b6dbd88c5267354a3b29a4a25f398c7", "patch": "@@ -0,0 +1,14 @@\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count-expected-type-issue-47244.rs:24:14\n+   |\n+24 |     m.iter().map( |_, b| {\n+   |              ^^^  ------ takes 2 distinct arguments\n+   |              |\n+   |              expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+24 |     m.iter().map( |(_, b)| {\n+   |                   ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}