{"sha": "8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNmU2ZjVmODk2ZTFkYmMyZmIxMjRlN2RhZDg3NTBkOGI5MTEyZWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T01:28:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T01:31:14Z"}, "message": "rustc: Make iter_structural_ty_full and friends take one value, not two. Shaves a second off codegen.", "tree": {"sha": "40b137450d6083b442cc0ddbb6ec8f0c009a8cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40b137450d6083b442cc0ddbb6ec8f0c009a8cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef", "html_url": "https://github.com/rust-lang/rust/commit/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/044b16ad68984a1c99f88ddf6701f4eaefa15bf8", "html_url": "https://github.com/rust-lang/rust/commit/044b16ad68984a1c99f88ddf6701f4eaefa15bf8"}], "stats": {"total": 106, "additions": 36, "deletions": 70}, "files": [{"sha": "794da1590c10da1869385d6dc4cab7bfe5351fa3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 70, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8e6e6f5f896e1dbc2fb124e7dad8750d8b9112ef", "patch": "@@ -1639,21 +1639,18 @@ fn compare_scalar_values(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef,\n }\n \n type val_pair_fn = fn(&@block_ctxt, ValueRef, ValueRef) -> result ;\n-\n+type val_fn = fn(&@block_ctxt, ValueRef) -> result ;\n type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result ;\n \n-type val_pair_and_ty_fn =\n-    fn(&@block_ctxt, ValueRef, ValueRef, ty::t) -> result ;\n-\n \n // Iterates through the elements of a structural type.\n fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: &ty::t,\n                       f: val_and_ty_fn) -> result {\n     fn adaptor_fn(f: val_and_ty_fn, cx: &@block_ctxt, av: ValueRef,\n-                  bv: ValueRef, t: ty::t) -> result {\n+                  t: ty::t) -> result {\n         ret f(cx, av, t);\n     }\n-    ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n+    ret iter_structural_ty_full(cx, v, t, bind adaptor_fn(f, _, _, _));\n }\n \n fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &[ValueRef]) ->\n@@ -1672,74 +1669,63 @@ fn incr_ptr(cx: &@block_ctxt, p: ValueRef, incr: ValueRef, pp: ValueRef) {\n     cx.build.Store(cx.build.InBoundsGEP(p, ~[incr]), pp);\n }\n \n-fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n-                           t: &ty::t, f: &val_pair_and_ty_fn) -> result {\n-    fn iter_boxpp(cx: @block_ctxt, box_a_cell: ValueRef, box_b_cell: ValueRef,\n-                  f: &val_pair_and_ty_fn) -> result {\n-        let box_a_ptr = cx.build.Load(box_a_cell);\n-        let box_b_ptr = cx.build.Load(box_b_cell);\n+fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n+                           f: &val_and_ty_fn) -> result {\n+    fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: &val_and_ty_fn)\n+            -> result {\n+        let box_ptr = cx.build.Load(box_cell);\n         let tnil = ty::mk_nil(bcx_tcx(cx));\n         let tbox = ty::mk_imm_box(bcx_tcx(cx), tnil);\n         let inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         let next_cx = new_sub_block_ctxt(cx, \"next\");\n-        let null_test = cx.build.IsNull(box_a_ptr);\n+        let null_test = cx.build.IsNull(box_ptr);\n         cx.build.CondBr(null_test, next_cx.llbb, inner_cx.llbb);\n-        let r = f(inner_cx, box_a_ptr, box_b_ptr, tbox);\n+        let r = f(inner_cx, box_ptr, tbox);\n         r.bcx.build.Br(next_cx.llbb);\n         ret rslt(next_cx, C_nil());\n     }\n \n-    fn iter_ivec(bcx: @block_ctxt, av: ValueRef, bv: ValueRef, unit_ty: ty::t,\n-                 f: &val_pair_and_ty_fn) -> result {\n+    fn iter_ivec(bcx: @block_ctxt, av: ValueRef, unit_ty: ty::t,\n+                 f: &val_and_ty_fn) -> result {\n         // FIXME: \"unimplemented rebinding existing function\" workaround\n \n-        fn adapter(bcx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n-                   unit_ty: ty::t, f: val_pair_and_ty_fn) -> result {\n-            ret f(bcx, av, bv, unit_ty);\n+        fn adapter(bcx: &@block_ctxt, av: ValueRef, unit_ty: ty::t,\n+                   f: val_and_ty_fn) -> result {\n+            ret f(bcx, av, unit_ty);\n         }\n         let llunitty = type_of_or_i8(bcx, unit_ty);\n         let rs = size_of(bcx, unit_ty);\n         let unit_sz = rs.val;\n         bcx = rs.bcx;\n         let a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n-        let a_len = a_len_and_data.len;\n+        let len = a_len_and_data.len;\n         let a_elem = a_len_and_data.data;\n         bcx = a_len_and_data.bcx;\n-        let b_len_and_data = ivec::get_len_and_data(bcx, bv, unit_ty);\n-        let b_len = b_len_and_data.len;\n-        let b_elem = b_len_and_data.data;\n-        bcx = b_len_and_data.bcx;\n         // Calculate the last pointer address we want to handle.\n         // TODO: Optimize this when the size of the unit type is statically\n         // known to not use pointer casts, which tend to confuse LLVM.\n \n-        let len = umin(bcx, a_len, b_len);\n-        let b_elem_i8 = bcx.build.PointerCast(b_elem, T_ptr(T_i8()));\n-        let b_end_i8 = bcx.build.GEP(b_elem_i8, ~[len]);\n-        let b_end = bcx.build.PointerCast(b_end_i8, T_ptr(llunitty));\n+        let a_elem_i8 = bcx.build.PointerCast(a_elem, T_ptr(T_i8()));\n+        let a_end_i8 = bcx.build.GEP(a_elem_i8, ~[len]);\n+        let a_end = bcx.build.PointerCast(a_end_i8, T_ptr(llunitty));\n \n         let dest_elem_ptr = alloca(bcx, T_ptr(llunitty));\n-        let src_elem_ptr = alloca(bcx, T_ptr(llunitty));\n         bcx.build.Store(a_elem, dest_elem_ptr);\n-        bcx.build.Store(b_elem, src_elem_ptr);\n \n         // Now perform the iteration.\n         let loop_header_cx = new_sub_block_ctxt(bcx, \"iter_ivec_loop_header\");\n         bcx.build.Br(loop_header_cx.llbb);\n         let dest_elem = loop_header_cx.build.Load(dest_elem_ptr);\n-        let src_elem = loop_header_cx.build.Load(src_elem_ptr);\n         let not_yet_at_end =\n             loop_header_cx.build.ICmp(lib::llvm::LLVMIntULT, dest_elem,\n-                                      b_end);\n+                                      a_end);\n         let loop_body_cx = new_sub_block_ctxt(bcx, \"iter_ivec_loop_body\");\n         let next_cx = new_sub_block_ctxt(bcx, \"iter_ivec_next\");\n         loop_header_cx.build.CondBr(not_yet_at_end, loop_body_cx.llbb,\n                                     next_cx.llbb);\n \n-        rs =\n-            f(loop_body_cx,\n-              load_if_immediate(loop_body_cx, dest_elem, unit_ty),\n-              load_if_immediate(loop_body_cx, src_elem, unit_ty), unit_ty);\n+        rs = f(loop_body_cx,\n+               load_if_immediate(loop_body_cx, dest_elem, unit_ty), unit_ty);\n \n         loop_body_cx = rs.bcx;\n \n@@ -1749,15 +1735,14 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n         } else { increment = C_int(1); }\n \n         incr_ptr(loop_body_cx, dest_elem, increment, dest_elem_ptr);\n-        incr_ptr(loop_body_cx, src_elem, increment, src_elem_ptr);\n         loop_body_cx.build.Br(loop_header_cx.llbb);\n \n         ret rslt(next_cx, C_nil());\n     }\n \n-    fn iter_variant(cx: @block_ctxt, a_tup: ValueRef, b_tup: ValueRef,\n+    fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: &ty::variant_info, tps: &[ty::t],\n-                    tid: &ast::def_id, f: &val_pair_and_ty_fn) -> result {\n+                    tid: &ast::def_id, f: &val_and_ty_fn) -> result {\n         if std::ivec::len[ty::t](variant.args) == 0u {\n             ret rslt(cx, C_nil());\n         }\n@@ -1770,13 +1755,9 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n                 let rslt = GEP_tag(cx, a_tup, tid, variant.id, tps, j);\n                 let llfldp_a = rslt.val;\n                 cx = rslt.bcx;\n-                rslt = GEP_tag(cx, b_tup, tid, variant.id, tps, j);\n-                let llfldp_b = rslt.val;\n-                cx = rslt.bcx;\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n                 let llfld_a = load_if_immediate(cx, llfldp_a, ty_subst);\n-                let llfld_b = load_if_immediate(cx, llfldp_b, ty_subst);\n-                rslt = f(cx, llfld_a, llfld_b, ty_subst);\n+                rslt = f(cx, llfld_a, ty_subst);\n                 cx = rslt.bcx;\n                 j += 1;\n             }\n@@ -1792,11 +1773,8 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n         for fld: ty::field  in fields {\n             r = GEP_tup_like(r.bcx, t, av, ~[0, i]);\n             let llfld_a = r.val;\n-            r = GEP_tup_like(r.bcx, t, bv, ~[0, i]);\n-            let llfld_b = r.val;\n-            r =\n-                f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n-                  load_if_immediate(r.bcx, llfld_b, fld.mt.ty), fld.mt.ty);\n+            r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n+                  fld.mt.ty);\n             i += 1;\n         }\n       }\n@@ -1807,34 +1785,27 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n         let tup_t = ty::mk_imm_tup(tcx, ~[ty::mk_int(tcx), inner_t_s]);\n         r = GEP_tup_like(r.bcx, tup_t, av, ~[0, 1]);\n         let llfld_a = r.val;\n-        r = GEP_tup_like(r.bcx, tup_t, bv, ~[0, 1]);\n-        let llfld_b = r.val;\n-        r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner1),\n-              load_if_immediate(r.bcx, llfld_b, inner1), inner1);\n+        r = f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner1), inner1);\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n         let n_variants = std::ivec::len(variants);\n \n         // Cast the tags to types we can GEP into.\n         if n_variants == 1u {\n-            ret iter_variant(cx, av, bv, variants.(0), tps, tid, f);\n+            ret iter_variant(cx, av, variants.(0), tps, tid, f);\n         }\n \n         let lltagty = T_opaque_tag_ptr(bcx_ccx(cx).tn);\n         let av_tag = cx.build.PointerCast(av, lltagty);\n-        let bv_tag = cx.build.PointerCast(bv, lltagty);\n         let lldiscrim_a_ptr = cx.build.GEP(av_tag, ~[C_int(0), C_int(0)]);\n         let llunion_a_ptr = cx.build.GEP(av_tag, ~[C_int(0), C_int(1)]);\n         let lldiscrim_a = cx.build.Load(lldiscrim_a_ptr);\n-        let lldiscrim_b_ptr = cx.build.GEP(bv_tag, ~[C_int(0), C_int(0)]);\n-        let llunion_b_ptr = cx.build.GEP(bv_tag, ~[C_int(0), C_int(1)]);\n-        let lldiscrim_b = cx.build.Load(lldiscrim_b_ptr);\n \n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n         let bcx = cx;\n-        bcx = f(bcx, lldiscrim_a, lldiscrim_b, ty::mk_int(bcx_tcx(cx))).bcx;\n+        bcx = f(bcx, lldiscrim_a, ty::mk_int(bcx_tcx(cx))).bcx;\n         let unr_cx = new_sub_block_ctxt(bcx, \"tag-iter-unr\");\n         unr_cx.build.Unreachable();\n         let llswitch = bcx.build.Switch(lldiscrim_a, unr_cx.llbb, n_variants);\n@@ -1846,9 +1817,8 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n                                    \"tag-iter-variant-\" +\n                                        uint::to_str(i, 10u));\n             llvm::LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n-            variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, llunion_b_ptr,\n-                             variant, tps, tid, f).bcx;\n+            variant_cx = iter_variant(variant_cx, llunion_a_ptr, variant, tps,\n+                                      tid, f).bcx;\n             variant_cx.build.Br(next_cx.llbb);\n             i += 1u;\n         }\n@@ -1857,21 +1827,17 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, bv: ValueRef,\n       ty::ty_fn(_, _, _, _, _) {\n         let box_cell_a =\n             cx.build.GEP(av, ~[C_int(0), C_int(abi::fn_field_box)]);\n-        let box_cell_b =\n-            cx.build.GEP(bv, ~[C_int(0), C_int(abi::fn_field_box)]);\n-        ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n+        ret iter_boxpp(cx, box_cell_a, f);\n       }\n       ty::ty_obj(_) {\n         let box_cell_a =\n             cx.build.GEP(av, ~[C_int(0), C_int(abi::obj_field_box)]);\n-        let box_cell_b =\n-            cx.build.GEP(bv, ~[C_int(0), C_int(abi::obj_field_box)]);\n-        ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n+        ret iter_boxpp(cx, box_cell_a, f);\n       }\n-      ty::ty_ivec(unit_tm) { ret iter_ivec(cx, av, bv, unit_tm.ty, f); }\n+      ty::ty_ivec(unit_tm) { ret iter_ivec(cx, av, unit_tm.ty, f); }\n       ty::ty_istr. {\n         let unit_ty = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n-        ret iter_ivec(cx, av, bv, unit_ty, f);\n+        ret iter_ivec(cx, av, unit_ty, f);\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"type in iter_structural_ty_full\"); }\n     }"}]}