{"sha": "aec6c85b0c6281d938bdd80e98fa9473d8b27780", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzZjODViMGM2MjgxZDkzOGJkZDgwZTk4ZmE5NDczZDhiMjc3ODA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-02-27T16:52:07Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-03-06T08:47:43Z"}, "message": "Compute symbol names more lazily.", "tree": {"sha": "7092d404bb5e66fc1462d6808272457a6c516724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7092d404bb5e66fc1462d6808272457a6c516724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec6c85b0c6281d938bdd80e98fa9473d8b27780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec6c85b0c6281d938bdd80e98fa9473d8b27780", "html_url": "https://github.com/rust-lang/rust/commit/aec6c85b0c6281d938bdd80e98fa9473d8b27780", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec6c85b0c6281d938bdd80e98fa9473d8b27780/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "html_url": "https://github.com/rust-lang/rust/commit/33d5da1ee400e4b1b85a6a3f0c552ce68c665500"}], "stats": {"total": 183, "additions": 135, "deletions": 48}, "files": [{"sha": "c9b3acdd836ec195946f1d01570748a1667ecd7a", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n+use std::cmp;\n+use ty;\n+\n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n /// kind of crate, including cdylibs which export very few things.\n@@ -34,3 +38,52 @@ impl SymbolExportLevel {\n         }\n     }\n }\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum ExportedSymbol {\n+    NonGeneric(DefId),\n+    NoDefId(ty::SymbolName),\n+}\n+\n+impl ExportedSymbol {\n+    pub fn symbol_name(&self, tcx: ty::TyCtxt) -> ty::SymbolName {\n+        match *self {\n+            ExportedSymbol::NonGeneric(def_id) => {\n+                tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n+            }\n+            ExportedSymbol::NoDefId(symbol_name) => {\n+                symbol_name\n+            }\n+        }\n+    }\n+\n+    pub fn compare_stable(&self, tcx: ty::TyCtxt, other: &ExportedSymbol) -> cmp::Ordering {\n+        match *self {\n+            ExportedSymbol::NonGeneric(self_def_id) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(other_def_id) => {\n+                        tcx.def_path_hash(self_def_id).cmp(&tcx.def_path_hash(other_def_id))\n+                    }\n+                    ExportedSymbol::NoDefId(_) => {\n+                        cmp::Ordering::Less\n+                    }\n+                }\n+            }\n+            ExportedSymbol::NoDefId(self_symbol_name) => {\n+                match *other {\n+                    ExportedSymbol::NonGeneric(_) => {\n+                        cmp::Ordering::Greater\n+                    }\n+                    ExportedSymbol::NoDefId(ref other_symbol_name) => {\n+                        self_symbol_name.cmp(other_symbol_name)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum self::ExportedSymbol {\n+    NonGeneric(def_id),\n+    NoDefId(symbol_name)\n+});"}, {"sha": "2ef97b2673d6efddb6456aa8a2af8f1418cd8f47", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -26,7 +26,7 @@ use middle::region;\n use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n-use middle::exported_symbols::SymbolExportLevel;\n+use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n use session::{CompileResult, CrateDisambiguator};\n@@ -358,7 +358,7 @@ define_maps! { <'tcx>\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+        -> Arc<Vec<(ExportedSymbol, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),"}, {"sha": "a7c55880e2e17681ad69ac6454c79387dd822940", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -2806,7 +2806,7 @@ impl<'tcx> DtorckConstraint<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have\n     // this be a `&'tcx str`.\n@@ -2817,6 +2817,14 @@ impl_stable_hash_for!(struct self::SymbolName {\n     name\n });\n \n+impl SymbolName {\n+    pub fn new(name: &str) -> SymbolName {\n+        SymbolName {\n+            name: Symbol::intern(name).as_str()\n+        }\n+    }\n+}\n+\n impl Deref for SymbolName {\n     type Target = str;\n \n@@ -2828,3 +2836,9 @@ impl fmt::Display for SymbolName {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n+\n+impl fmt::Debug for SymbolName {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, fmt)\n+    }\n+}"}, {"sha": "3fe667f154372df68eed2eb96efbfdb562b02313", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -768,9 +768,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n     let mut symbols = Vec::new();\n \n     let export_threshold = symbol_export::crates_export_threshold(&[crate_type]);\n-    for &(ref name, _, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n+    for &(symbol, level) in tcx.exported_symbols(LOCAL_CRATE).iter() {\n         if level.is_below_threshold(export_threshold) {\n-            symbols.push(name.clone());\n+            symbols.push(symbol.symbol_name(tcx).to_string());\n         }\n     }\n \n@@ -782,9 +782,9 @@ fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {\n             // ... we add its symbol list to our export list.\n-            for &(ref name, _, level) in tcx.exported_symbols(cnum).iter() {\n+            for &(symbol, level) in tcx.exported_symbols(cnum).iter() {\n                 if level.is_below_threshold(export_threshold) {\n-                    symbols.push(name.clone());\n+                    symbols.push(symbol.symbol_name(tcx).to_string());\n                 }\n             }\n         }"}, {"sha": "f79651cef3ec8a58343537ed9390feadf20ce115", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -113,7 +113,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::No => panic!(\"didn't request LTO but we're doing LTO\"),\n     };\n \n-    let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n+    let symbol_filter = &|&(ref name, level): &(String, SymbolExportLevel)| {\n         if level.is_below_threshold(export_threshold) {\n             let mut bytes = Vec::with_capacity(name.len() + 1);\n             bytes.extend(name.bytes());"}, {"sha": "4e3a37104886b62eddcc51981cbac6ad8a253858", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -15,17 +15,17 @@ use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::middle::exported_symbols::SymbolExportLevel;\n+use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n use rustc::session::config;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n-    Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n+    Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n@@ -78,9 +78,10 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let reachable_non_generics = tcx\n         .exported_symbols(LOCAL_CRATE)\n         .iter()\n-        .filter_map(|&(_, opt_def_id, level)| {\n-            if let Some(def_id) = opt_def_id {\n-                if level.is_below_threshold(export_threshold) {\n+        .filter_map(|&(exported_symbol, _)| {\n+            if let ExportedSymbol::NonGeneric(def_id) = exported_symbol {\n+                if tcx.symbol_export_level(def_id)\n+                      .is_below_threshold(export_threshold) {\n                     return Some(def_id)\n                 }\n             }\n@@ -100,8 +101,7 @@ fn is_reachable_non_generic_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              cnum: CrateNum)\n-                                             -> Arc<Vec<(String,\n-                                                         Option<DefId>,\n+                                             -> Arc<Vec<(ExportedSymbol,\n                                                          SymbolExportLevel)>>\n {\n     assert_eq!(cnum, LOCAL_CRATE);\n@@ -176,34 +176,40 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut symbols: Vec<_> = reachable_non_generics\n         .iter()\n         .map(|&def_id| {\n-            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n             let export_level = tcx.symbol_export_level(def_id);\n-            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-            (str::to_owned(&name), Some(def_id), export_level)\n+            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\",\n+                   tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                   export_level);\n+            (ExportedSymbol::NonGeneric(def_id), export_level)\n         })\n         .collect();\n \n     if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-        symbols.push((\"main\".to_string(), None, SymbolExportLevel::C));\n+        let symbol_name = \"main\".to_string();\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n+\n+        symbols.push((exported_symbol, SymbolExportLevel::C));\n     }\n \n     if tcx.sess.allocator_kind.get().is_some() {\n         for method in ALLOCATOR_METHODS {\n-            symbols.push((format!(\"__rust_{}\", method.name),\n-                          None,\n-                          SymbolExportLevel::Rust));\n+            let symbol_name = format!(\"__rust_{}\", method.name);\n+            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n+\n+            symbols.push((exported_symbol, SymbolExportLevel::Rust));\n         }\n     }\n \n     if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-        symbols.push((metadata_symbol_name(tcx),\n-                      None,\n-                      SymbolExportLevel::Rust));\n+        let symbol_name = metadata_symbol_name(tcx);\n+        let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n+\n+        symbols.push((exported_symbol, SymbolExportLevel::Rust));\n     }\n \n     // Sort so we get a stable incr. comp. hash.\n-    symbols.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-        name1.cmp(name2)\n+    symbols.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n+        symbol1.compare_stable(tcx, symbol2)\n     });\n \n     Arc::new(symbols)\n@@ -218,8 +224,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn exported_symbols_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               cnum: CrateNum)\n-                                              -> Arc<Vec<(String,\n-                                                          Option<DefId>,\n+                                              -> Arc<Vec<(ExportedSymbol,\n                                                           SymbolExportLevel)>>\n {\n     // If this crate is a plugin and/or a custom derive crate, then\n@@ -243,8 +248,8 @@ fn exported_symbols_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .reachable_non_generics(cnum)\n         .iter()\n         .map(|&def_id| {\n-            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n             let export_level = if special_runtime_crate {\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's\n@@ -262,14 +267,18 @@ fn exported_symbols_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             } else {\n                 tcx.symbol_export_level(def_id)\n             };\n-            debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-            (str::to_owned(&name), Some(def_id), export_level)\n+\n+            debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\",\n+                   tcx.symbol_name(Instance::mono(tcx, def_id)),\n+                   export_level);\n+\n+            (ExportedSymbol::NonGeneric(def_id), export_level)\n         })\n         .collect();\n \n     // Sort so we get a stable incr. comp. hash.\n-    crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-        name1.cmp(name2)\n+    crate_exports.sort_unstable_by(|&(ref symbol1, ..), &(ref symbol2, ..)| {\n+        symbol1.compare_stable(tcx, symbol2)\n     });\n \n     Arc::new(crate_exports)"}, {"sha": "c0561ff0c17316e0e411d9d26daf1c2eb247ae4c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec6c85b0c6281d938bdd80e98fa9473d8b27780/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=aec6c85b0c6281d938bdd80e98fa9473d8b27780", "patch": "@@ -1332,20 +1332,31 @@ fn start_executing_work(tcx: TyCtxt,\n     let coordinator_send = tcx.tx_to_llvm_workers.clone();\n     let sess = tcx.sess;\n \n-    let exported_symbols = match sess.lto() {\n-        Lto::No => None,\n-        Lto::ThinLocal => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            Some(Arc::new(exported_symbols))\n-        }\n-        Lto::Yes | Lto::Fat | Lto::Thin => {\n-            let mut exported_symbols = FxHashMap();\n-            exported_symbols.insert(LOCAL_CRATE, tcx.exported_symbols(LOCAL_CRATE));\n-            for &cnum in tcx.crates().iter() {\n-                exported_symbols.insert(cnum, tcx.exported_symbols(cnum));\n+    // Compute the set of symbols we need to retain when doing LTO (if we need to)\n+    let exported_symbols = {\n+        let mut exported_symbols = FxHashMap();\n+\n+        let copy_symbols = |cnum| {\n+            let symbols = tcx.exported_symbols(cnum)\n+                             .iter()\n+                             .map(|&(s, lvl)| (s.symbol_name(tcx).to_string(), lvl))\n+                             .collect();\n+            Arc::new(symbols)\n+        };\n+\n+        match sess.lto() {\n+            Lto::No => None,\n+            Lto::ThinLocal => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                Some(Arc::new(exported_symbols))\n+            }\n+            Lto::Yes | Lto::Fat | Lto::Thin => {\n+                exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n+                for &cnum in tcx.crates().iter() {\n+                    exported_symbols.insert(cnum, copy_symbols(cnum));\n+                }\n+                Some(Arc::new(exported_symbols))\n             }\n-            Some(Arc::new(exported_symbols))\n         }\n     };\n "}]}