{"sha": "29711d8c96ace61f2d240837e392f49a6dd6c8fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NzExZDhjOTZhY2U2MWYyZDI0MDgzN2UzOTJmNDlhNmRkNmM4ZmQ=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-02-04T02:41:30Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-02-04T02:55:05Z"}, "message": "rustc_codegen_ssa: tune codegen scheduling to reduce memory usage\n\nFor better throughput during parallel processing by LLVM, we used to sort\nCGUs largest to smallest. This would lead to better thread utilization\nby, for example, preventing a large CGU from being processed last and\nhaving only one LLVM thread working while the rest remained idle.\n\nHowever, this strategy would lead to high memory usage, as it meant the\nLLVM-IR for all of the largest CGUs would be resident in memory at once.\n\nInstead, we can compromise by ordering CGUs such that the largest and\nsmallest are first, second largest and smallest are next, etc. If there\nare large size variations, this can reduce memory usage significantly.", "tree": {"sha": "cf049890b348d3dd0067eecc6efa6e8cef23ab33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf049890b348d3dd0067eecc6efa6e8cef23ab33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29711d8c96ace61f2d240837e392f49a6dd6c8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29711d8c96ace61f2d240837e392f49a6dd6c8fd", "html_url": "https://github.com/rust-lang/rust/commit/29711d8c96ace61f2d240837e392f49a6dd6c8fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29711d8c96ace61f2d240837e392f49a6dd6c8fd/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e708cbd91c9cae4426d69270248362b423324556", "url": "https://api.github.com/repos/rust-lang/rust/commits/e708cbd91c9cae4426d69270248362b423324556", "html_url": "https://github.com/rust-lang/rust/commit/e708cbd91c9cae4426d69270248362b423324556"}], "stats": {"total": 28, "additions": 21, "deletions": 7}, "files": [{"sha": "939c1ce58c212b64c3284b83d8f9f0dde7ebfe9d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29711d8c96ace61f2d240837e392f49a6dd6c8fd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/29711d8c96ace61f2d240837e392f49a6dd6c8fd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=29711d8c96ace61f2d240837e392f49a6dd6c8fd", "patch": "@@ -3626,6 +3626,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"cc\",\n+ \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n  \"memmap\","}, {"sha": "835f906239953780b0f3d90f90b6bc62d18e5c28", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29711d8c96ace61f2d240837e392f49a6dd6c8fd/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/29711d8c96ace61f2d240837e392f49a6dd6c8fd/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=29711d8c96ace61f2d240837e392f49a6dd6c8fd", "patch": "@@ -10,6 +10,7 @@ test = false\n [dependencies]\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n+itertools = \"0.9\"\n num_cpus = \"1.0\"\n memmap = \"0.7\"\n tracing = \"0.1\""}, {"sha": "658ad3c375d292d4e84e5bdc173f59ea84c119be", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29711d8c96ace61f2d240837e392f49a6dd6c8fd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29711d8c96ace61f2d240837e392f49a6dd6c8fd/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=29711d8c96ace61f2d240837e392f49a6dd6c8fd", "patch": "@@ -32,10 +32,11 @@ use rustc_session::config::{self, EntryFnType};\n use rustc_session::Session;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n-use std::cmp;\n use std::ops::{Deref, DerefMut};\n use std::time::{Duration, Instant};\n \n+use itertools::Itertools;\n+\n pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind, signed: bool) -> IntPredicate {\n     match op {\n         hir::BinOpKind::Eq => IntPredicate::IntEQ,\n@@ -546,12 +547,23 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, metadata_module);\n     }\n \n-    // We sort the codegen units by size. This way we can schedule work for LLVM\n-    // a bit more efficiently.\n-    let codegen_units = {\n-        let mut codegen_units = codegen_units.iter().collect::<Vec<_>>();\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        codegen_units\n+    // For better throughput during parallel processing by LLVM, we used to sort\n+    // CGUs largest to smallest. This would lead to better thread utilization\n+    // by, for example, preventing a large CGU from being processed last and\n+    // having only one LLVM thread working while the rest remained idle.\n+    //\n+    // However, this strategy would lead to high memory usage, as it meant the\n+    // LLVM-IR for all of the largest CGUs would be resident in memory at once.\n+    //\n+    // Instead, we can compromise by ordering CGUs such that the largest and\n+    // smallest are first, second largest and smallest are next, etc. If there\n+    // are large size variations, this can reduce memory usage significantly.\n+    let codegen_units: Vec<_> = {\n+        let mut sorted_cgus = codegen_units.iter().collect::<Vec<_>>();\n+        sorted_cgus.sort_by_cached_key(|cgu| cgu.size_estimate());\n+\n+        let (first_half, second_half) = sorted_cgus.split_at(sorted_cgus.len() / 2);\n+        second_half.iter().rev().interleave(first_half).copied().collect()\n     };\n \n     // The non-parallel compiler can only translate codegen units to LLVM IR"}]}