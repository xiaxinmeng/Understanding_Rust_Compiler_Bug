{"sha": "3e8351fb0607f8711749b00d80f68bf25de01a76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlODM1MWZiMDYwN2Y4NzExNzQ5YjAwZDgwZjY4YmYyNWRlMDFhNzY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-09T08:52:09Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-09T08:52:09Z"}, "message": "Merge #768\n\n768: Sort assists by the range of the affected element r=matklad a=robojumper\n\nCloses #763.\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/3be98f2ac93b278828e76eb813bdd8033f647b12/crates/ra_assists/src/lib.rs#L233-L236\r\n\r\nThis could be made more robust by a) adding a way to identify actions by things other than their label and b) allowing arbitrary actions to appear in the list as long as the tested actions are there in the correct order. Let me know if I should do any of that.\r\n\n\nCo-authored-by: robojumper <robojumper@gmail.com>", "tree": {"sha": "97388dafe71ececcbaf97249021b9c8d49786ccf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97388dafe71ececcbaf97249021b9c8d49786ccf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e8351fb0607f8711749b00d80f68bf25de01a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8351fb0607f8711749b00d80f68bf25de01a76", "html_url": "https://github.com/rust-lang/rust/commit/3e8351fb0607f8711749b00d80f68bf25de01a76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e8351fb0607f8711749b00d80f68bf25de01a76/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "12e3b4c70b5ef23b2fdfc197296d483680e125f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e3b4c70b5ef23b2fdfc197296d483680e125f9", "html_url": "https://github.com/rust-lang/rust/commit/12e3b4c70b5ef23b2fdfc197296d483680e125f9"}, {"sha": "4fdeb54bb5c7ba0704839a65996766d223c51fc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdeb54bb5c7ba0704839a65996766d223c51fc1", "html_url": "https://github.com/rust-lang/rust/commit/4fdeb54bb5c7ba0704839a65996766d223c51fc1"}], "stats": {"total": 286, "additions": 264, "deletions": 22}, "files": [{"sha": "5ce4a8084c1edb5be19a37abfaa226c58cd3559f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -1,3 +1,5 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n [[package]]\n name = \"aho-corasick\"\n version = \"0.6.9\""}, {"sha": "ea9707631db0b2815ab391ae847512d5a1eecd49", "filename": "crates/ra_assists/src/add_derive.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -24,6 +24,7 @@ pub(crate) fn add_derive(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n             }\n             Some(tt) => tt.syntax().range().end() - TextUnit::of_char(')'),\n         };\n+        edit.target(nominal.syntax().range());\n         edit.set_cursor(offset)\n     })\n }\n@@ -38,7 +39,7 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn add_derive_new() {\n@@ -80,4 +81,21 @@ struct Foo { a: i32, }\n             \",\n         );\n     }\n+\n+    #[test]\n+    fn add_derive_target() {\n+        check_assist_target(\n+            add_derive,\n+            \"\n+struct SomeThingIrrelevant;\n+/// `Foo` is a pretty important struct.\n+/// It does stuff.\n+struct Foo { a: i32<|>, }\n+struct EvenMoreIrrelevant;\n+            \",\n+            \"/// `Foo` is a pretty important struct.\n+/// It does stuff.\n+struct Foo { a: i32, }\",\n+        );\n+    }\n }"}, {"sha": "32fc074a6207750e41ad42129eb46f0f47689aa8", "filename": "crates/ra_assists/src/add_impl.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -11,6 +11,7 @@ pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     ctx.build(\"add impl\", |edit| {\n+        edit.target(nominal.syntax().range());\n         let type_params = nominal.type_param_list();\n         let start_offset = nominal.syntax().range().end();\n         let mut buf = String::new();\n@@ -37,7 +38,7 @@ pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_add_impl() {\n@@ -54,4 +55,18 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn add_impl_target() {\n+        check_assist_target(\n+            add_impl,\n+            \"\n+struct SomeThingIrrelevant;\n+/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {<|>}\n+struct EvenMoreIrrelevant;\n+\",\n+            \"/// Has a lifetime parameter\n+struct Foo<'a, T: Foo<'a>> {}\",\n+        );\n+    }\n }"}, {"sha": "41c8ac2f69de9148b946e724c7700adbab638f40", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -16,7 +16,7 @@ pub(crate) enum Assist {\n \n /// `AssistCtx` allows to apply an assist or check if it could be applied.\n ///\n-/// Assists use a somewhat overengineered approach, given the current needs. The\n+/// Assists use a somewhat over-engineered approach, given the current needs. The\n /// assists workflow consists of two phases. In the first phase, a user asks for\n /// the list of available assists. In the second phase, the user picks a\n /// particular assist and it gets applied.\n@@ -106,6 +106,7 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextUnit>,\n+    target: Option<TextRange>,\n }\n \n impl AssistBuilder {\n@@ -138,7 +139,15 @@ impl AssistBuilder {\n         self.cursor_position = Some(offset)\n     }\n \n+    pub(crate) fn target(&mut self, target: TextRange) {\n+        self.target = Some(target)\n+    }\n+\n     fn build(self) -> AssistAction {\n-        AssistAction { edit: self.edit.finish(), cursor_position: self.cursor_position }\n+        AssistAction {\n+            edit: self.edit.finish(),\n+            cursor_position: self.cursor_position,\n+            target: self.target,\n+        }\n     }\n }"}, {"sha": "6d9a4eec2fbf46dbd2dd08f96b2146a45b45a2c7", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -20,7 +20,7 @@ fn add_vis(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         _ => false,\n     });\n \n-    let offset = if let Some(keyword) = item_keyword {\n+    let (offset, target) = if let Some(keyword) = item_keyword {\n         let parent = keyword.parent()?;\n         let def_kws = vec![FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF];\n         // Parent is not a definition, can't add visibility\n@@ -31,17 +31,18 @@ fn add_vis(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         if parent.children().any(|child| child.kind() == VISIBILITY) {\n             return None;\n         }\n-        vis_offset(parent)\n+        (vis_offset(parent), keyword.range())\n     } else {\n         let ident = ctx.leaf_at_offset().find(|leaf| leaf.kind() == IDENT)?;\n         let field = ident.ancestors().find_map(ast::NamedFieldDef::cast)?;\n         if field.name()?.syntax().range() != ident.range() && field.visibility().is_some() {\n             return None;\n         }\n-        vis_offset(field.syntax())\n+        (vis_offset(field.syntax()), ident.range())\n     };\n \n     ctx.build(\"make pub(crate)\", |edit| {\n+        edit.target(target);\n         edit.insert(offset, \"pub(crate) \");\n         edit.set_cursor(offset);\n     })\n@@ -60,13 +61,15 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n \n fn change_vis(ctx: AssistCtx<impl HirDatabase>, vis: &ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n-        return ctx.build(\"chage to pub(crate)\", |edit| {\n+        return ctx.build(\"change to pub(crate)\", |edit| {\n+            edit.target(vis.syntax().range());\n             edit.replace(vis.syntax().range(), \"pub(crate)\");\n             edit.set_cursor(vis.syntax().range().start());\n         });\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n-        return ctx.build(\"chage to pub\", |edit| {\n+        return ctx.build(\"change to pub\", |edit| {\n+            edit.target(vis.syntax().range());\n             edit.replace(vis.syntax().range(), \"pub\");\n             edit.set_cursor(vis.syntax().range().start());\n         });\n@@ -77,7 +80,7 @@ fn change_vis(ctx: AssistCtx<impl HirDatabase>, vis: &ast::Visibility) -> Option\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn change_visibility_adds_pub_crate_to_items() {\n@@ -135,4 +138,11 @@ mod tests {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn change_visibility_target() {\n+        check_assist_target(change_visibility, \"<|>fn foo() {}\", \"fn\");\n+        check_assist_target(change_visibility, \"pub(crate)<|> fn foo() {}\", \"pub(crate)\");\n+        check_assist_target(change_visibility, \"struct S { <|>field: u32 }\", \"field\");\n+    }\n }"}, {"sha": "69b535a274a534c63727344a4213f33836ab9161", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -65,14 +65,15 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n             buf.push_str(\" => (),\\n\");\n         }\n         buf.push_str(\"}\");\n+        edit.target(match_expr.syntax().range());\n         edit.set_cursor(expr.syntax().range().start());\n         edit.replace_node_and_indent(match_expr.syntax(), buf);\n     })\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     use super::fill_match_arms;\n \n@@ -139,4 +140,19 @@ mod tests {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn fill_match_arms_target() {\n+        check_assist_target(\n+            fill_match_arms,\n+            r#\"\n+            enum E { X, Y}\n+\n+            fn main() {\n+                match E::X<|> {}\n+            }\n+            \"#,\n+            \"match E::X {}\",\n+        );\n+    }\n }"}, {"sha": "33da58f1761a0586b2166d7aac76c3a242525b3b", "filename": "crates/ra_assists/src/flip_comma.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -11,6 +11,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let prev = non_trivia_sibling(comma, Direction::Prev)?;\n     let next = non_trivia_sibling(comma, Direction::Next)?;\n     ctx.build(\"flip comma\", |edit| {\n+        edit.target(comma.range());\n         edit.replace(prev.range(), next.text());\n         edit.replace(next.range(), prev.text());\n     })\n@@ -20,7 +21,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n mod tests {\n     use super::*;\n \n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn flip_comma_works_for_function_parameters() {\n@@ -30,4 +31,9 @@ mod tests {\n             \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n         )\n     }\n+\n+    #[test]\n+    fn flip_comma_target() {\n+        check_assist_target(flip_comma, \"fn foo(x: i32,<|> y: Result<(), ()>) {}\", \",\")\n+    }\n }"}, {"sha": "934d1d6b3ca2b5a5be12f768eae62ede6045d6ef", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -45,6 +45,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<Ass\n         } else {\n             buf.push_str(\";\");\n             indent.text().push_to(&mut buf);\n+            edit.target(expr.syntax().range());\n             edit.replace(expr.syntax().range(), \"var_name\".to_string());\n             edit.insert(anchor_stmt.range().start(), buf);\n             if wrap_in_block {\n@@ -58,7 +59,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx<impl HirDatabase>) -> Option<Ass\n fn valid_covering_node(node: &SyntaxNode) -> bool {\n     node.kind() != COMMENT\n }\n-/// Check wether the node is a valid expression which can be extracted to a variable.\n+/// Check whether the node is a valid expression which can be extracted to a variable.\n /// In general that's true for any expression, but in some cases that would produce invalid code.\n fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n     match node.kind() {\n@@ -74,7 +75,7 @@ fn valid_target_expr(node: &SyntaxNode) -> Option<&ast::Expr> {\n /// and a boolean indicating whether we have to wrap it within a { } block\n /// to produce correct code.\n /// It can be a statement, the last in a block expression or a wanna be block\n-/// expression like a lamba or match arm.\n+/// expression like a lambda or match arm.\n fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n     expr.syntax().ancestors().find_map(|node| {\n         if ast::Stmt::cast(node).is_some() {\n@@ -100,7 +101,7 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_range};\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_range, check_assist_target, check_assist_range_target};\n \n     #[test]\n     fn test_introduce_var_simple() {\n@@ -425,4 +426,32 @@ fn main() {\n \",\n         );\n     }\n+\n+    // FIXME: This is not quite correct, but good enough(tm) for the sorting heuristic\n+    #[test]\n+    fn introduce_var_target() {\n+        check_assist_target(\n+            introduce_variable,\n+            \"\n+fn foo() -> u32 {\n+    r<|>eturn 2 + 2;\n+}\n+\",\n+            \"2 + 2\",\n+        );\n+\n+        check_assist_range_target(\n+            introduce_variable,\n+            \"\n+fn main() {\n+    let x = true;\n+    let tuple = match x {\n+        true => (<|>2 + 2<|>, true)\n+        _ => (0, false)\n+    };\n+}\n+\",\n+            \"2 + 2\",\n+        );\n+    }\n }"}, {"sha": "7928b49830b9e6e61bb42364de654b53189e484e", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 96, "deletions": 4, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -8,7 +8,7 @@\n mod assist_ctx;\n \n use ra_text_edit::TextEdit;\n-use ra_syntax::{TextUnit, SyntaxNode, Direction};\n+use ra_syntax::{TextRange, TextUnit, SyntaxNode, Direction};\n use ra_db::FileRange;\n use hir::db::HirDatabase;\n \n@@ -23,6 +23,7 @@ pub struct AssistLabel {\n pub struct AssistAction {\n     pub edit: TextEdit,\n     pub cursor_position: Option<TextUnit>,\n+    pub target: Option<TextRange>,\n }\n \n /// Return all the assists applicable at the given position.\n@@ -53,15 +54,24 @@ pub fn assists<H>(db: &H, range: FileRange) -> Vec<(AssistLabel, AssistAction)>\n where\n     H: HirDatabase + 'static,\n {\n+    use std::cmp::Ordering;\n+\n     AssistCtx::with_ctx(db, range, true, |ctx| {\n-        all_assists()\n+        let mut a = all_assists()\n             .iter()\n             .filter_map(|f| f(ctx.clone()))\n             .map(|a| match a {\n                 Assist::Resolved(label, action) => (label, action),\n                 Assist::Unresolved(..) => unreachable!(),\n             })\n-            .collect()\n+            .collect::<Vec<(AssistLabel, AssistAction)>>();\n+        a.sort_by(|a, b| match (a.1.target, b.1.target) {\n+            (Some(a), Some(b)) => a.len().cmp(&b.len()),\n+            (Some(_), None) => Ordering::Less,\n+            (None, Some(_)) => Ordering::Greater,\n+            (None, None) => Ordering::Equal,\n+        });\n+        a\n     })\n }\n \n@@ -97,7 +107,7 @@ mod helpers {\n     use hir::mock::MockDatabase;\n     use ra_syntax::TextRange;\n     use ra_db::FileRange;\n-    use test_utils::{extract_offset, assert_eq_text, add_cursor, extract_range};\n+    use test_utils::{extract_offset, extract_range, assert_eq_text, add_cursor};\n \n     use crate::{AssistCtx, Assist};\n \n@@ -151,6 +161,45 @@ mod helpers {\n         assert_eq_text!(after, &actual);\n     }\n \n+    pub(crate) fn check_assist_target(\n+        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        before: &str,\n+        target: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assist =\n+            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved(_) => unreachable!(),\n+            Assist::Resolved(_, it) => it,\n+        };\n+\n+        let range = action.target.expect(\"expected target on action\");\n+        assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n+    }\n+\n+    pub(crate) fn check_assist_range_target(\n+        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        before: &str,\n+        target: &str,\n+    ) {\n+        let (range, before) = extract_range(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange = FileRange { file_id, range };\n+        let assist =\n+            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved(_) => unreachable!(),\n+            Assist::Resolved(_, it) => it,\n+        };\n+\n+        let range = action.target.expect(\"expected target on action\");\n+        assert_eq_text!(&before[range.start().to_usize()..range.end().to_usize()], target);\n+    }\n+\n     pub(crate) fn check_assist_not_applicable(\n         assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n         before: &str,\n@@ -162,5 +211,48 @@ mod helpers {\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n     }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use hir::mock::MockDatabase;\n+    use ra_syntax::TextRange;\n+    use ra_db::FileRange;\n+    use test_utils::{extract_offset};\n+\n+    #[test]\n+    fn assist_order_field_struct() {\n+        let before = \"struct Foo { <|>bar: u32 }\";\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assists = super::assists(&db, frange);\n+        let mut assists = assists.iter();\n+\n+        assert_eq!(assists.next().expect(\"expected assist\").0.label, \"make pub(crate)\");\n+        assert_eq!(assists.next().expect(\"expected assist\").0.label, \"add `#[derive]`\");\n+    }\n+\n+    #[test]\n+    fn assist_order_if_expr() {\n+        let before = \"\n+        pub fn test_some_range(a: int) -> bool {\n+            if let 2..6 = 5<|> {\n+                true\n+            } else {\n+                false\n+            }\n+        }\";\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange =\n+            FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n+        let assists = super::assists(&db, frange);\n+        let mut assists = assists.iter();\n+\n+        assert_eq!(assists.next().expect(\"expected assist\").0.label, \"introduce variable\");\n+        assert_eq!(assists.next().expect(\"expected assist\").0.label, \"replace with match\");\n+    }\n \n }"}, {"sha": "e9d0a635b3ed9563908e40494e55309745b9d47e", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -47,6 +47,7 @@ pub(crate) fn remove_dbg(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     };\n \n     ctx.build(\"remove dbg!()\", |edit| {\n+        edit.target(macro_call.syntax().range());\n         edit.replace(macro_range, macro_content);\n         edit.set_cursor(cursor_pos);\n     })\n@@ -78,7 +79,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::{check_assist, check_assist_not_applicable};\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     #[test]\n     fn test_remove_dbg() {\n@@ -120,4 +121,19 @@ fn foo(n: usize) {\n         check_assist_not_applicable(remove_dbg, \"<|>dbg(5, 6, 7)\");\n         check_assist_not_applicable(remove_dbg, \"<|>dbg!(5, 6, 7\");\n     }\n+\n+    #[test]\n+    fn remove_dbg_target() {\n+        check_assist_target(\n+            remove_dbg,\n+            \"\n+fn foo(n: usize) {\n+    if let Some(_) = dbg!(n.<|>checked_sub(4)) {\n+        // ...\n+    }\n+}\n+\",\n+            \"dbg!(n.checked_sub(4))\",\n+        );\n+    }\n }"}, {"sha": "a22ec558473ea259c7f00e9578b28ce0c545f449", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -17,6 +17,7 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.build(\"replace with match\", |edit| {\n         let match_expr = build_match_expr(expr, pat, then_block, else_block);\n+        edit.target(if_expr.syntax().range());\n         edit.replace_node_and_indent(if_expr.syntax(), match_expr);\n         edit.set_cursor(if_expr.syntax().range().start())\n     })\n@@ -46,7 +47,7 @@ fn format_arm(block: &ast::Block) -> String {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_replace_if_let_with_match_unwraps_simple_expressions() {\n@@ -73,4 +74,26 @@ impl VariantData {\n }           \",\n         )\n     }\n+\n+    #[test]\n+    fn replace_if_let_with_match_target() {\n+        check_assist_target(\n+            replace_if_let_with_match,\n+            \"\n+impl VariantData {\n+    pub fn is_struct(&self) -> bool {\n+        if <|>let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}           \",\n+            \"if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\",\n+        );\n+    }\n }"}, {"sha": "051bc6fecf2ab9b8b5b58c915fd2318959eec003", "filename": "crates/ra_assists/src/split_import.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8351fb0607f8711749b00d80f68bf25de01a76/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs?ref=3e8351fb0607f8711749b00d80f68bf25de01a76", "patch": "@@ -24,6 +24,7 @@ pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     };\n \n     ctx.build(\"split import\", |edit| {\n+        edit.target(colon_colon.range());\n         edit.insert(l_curly, \"{\");\n         edit.insert(r_curly, \"}\");\n         edit.set_cursor(l_curly + TextUnit::of_str(\"{\"));\n@@ -33,7 +34,7 @@ pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::helpers::check_assist;\n+    use crate::helpers::{check_assist, check_assist_target};\n \n     #[test]\n     fn test_split_import() {\n@@ -52,4 +53,9 @@ mod tests {\n             \"use algo::{<|>visitor::{Visitor, visit}}\",\n         )\n     }\n+\n+    #[test]\n+    fn split_import_target() {\n+        check_assist_target(split_import, \"use algo::<|>visitor::{Visitor, visit}\", \"::\");\n+    }\n }"}]}