{"sha": "a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "node_id": "C_kwDOAAsO6NoAKGE3ZjcyMjE4Yzg5YzJhZjdkNjMwM2YzYjhjYjZiZDg2OGMwYWYzMzQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T13:42:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-26T23:03:49Z"}, "message": "slightly adjust and synchronize Machine passing for SB and DataRace", "tree": {"sha": "f1afb2529ade80046030a8bcf47b3fce51ccfcfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1afb2529ade80046030a8bcf47b3fce51ccfcfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "html_url": "https://github.com/rust-lang/rust/commit/a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f479404b12ad5ca9b163a591a708ae7be63f402d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f479404b12ad5ca9b163a591a708ae7be63f402d", "html_url": "https://github.com/rust-lang/rust/commit/f479404b12ad5ca9b163a591a708ae7be63f402d"}], "stats": {"total": 79, "additions": 24, "deletions": 55}, "files": [{"sha": "d669cc1362a9a7a06a31536c8899cf5ae5d3dce9", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "patch": "@@ -838,18 +838,18 @@ impl VClockAlloc {\n         &self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         \"Read\",\n                         false,\n@@ -869,17 +869,17 @@ impl VClockAlloc {\n         alloc_id: AllocId,\n         range: AllocRange,\n         write_type: WriteType,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(thread_mgr);\n+            let (index, clocks) = global.current_thread_state(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n                 if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n-                        thread_mgr,\n+                        &machine.threads,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -901,10 +901,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Write, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Write, machine)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n@@ -915,10 +914,9 @@ impl VClockAlloc {\n         &mut self,\n         alloc_id: AllocId,\n         range: AllocRange,\n-        global: &mut GlobalState,\n-        thread_mgr: &ThreadManager<'_, '_>,\n+        machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n-        self.unique_access(alloc_id, range, WriteType::Deallocate, global, thread_mgr)\n+        self.unique_access(alloc_id, range, WriteType::Deallocate, machine)\n     }\n }\n "}, {"sha": "edfef211dc675abcff79b316ed1f6335a18cf3df", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "patch": "@@ -1003,21 +1003,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_ref().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.read(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.borrow_mut().before_memory_read(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine,\n-            )?;\n+            stacked_borrows\n+                .borrow_mut()\n+                .before_memory_read(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1034,21 +1025,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.write(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.get_mut().before_memory_write(\n-                alloc_id,\n-                prov_extra,\n-                range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n-                machine,\n-            )?;\n+            stacked_borrows.get_mut().before_memory_write(alloc_id, prov_extra, range, machine)?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n             weak_memory.memory_accessed(range, machine.data_race.as_ref().unwrap());\n@@ -1068,19 +1048,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(\n-                alloc_id,\n-                range,\n-                machine.data_race.as_mut().unwrap(),\n-                &machine.threads,\n-            )?;\n+            data_race.deallocate(alloc_id, range, machine)?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().before_memory_deallocation(\n                 alloc_id,\n                 prove_extra,\n                 range,\n-                machine.stacked_borrows.as_ref().unwrap(),\n                 machine,\n             )\n         } else {"}, {"sha": "e412f64506638e9183d1ed4a26700562ce5b17d3", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f72218c89c2af7d6303f3b8cb6bd868c0af334/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=a7f72218c89c2af7d6303f3b8cb6bd868c0af334", "patch": "@@ -644,7 +644,6 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n         machine: &'ecx MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx>\n     where\n@@ -657,7 +656,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::read(machine, tag, range);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &state, dcx, exposed_tags)\n         })\n@@ -669,8 +668,7 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        machine: &'ecx MiriMachine<'mir, 'tcx>,\n+        machine: &'ecx mut MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n@@ -679,7 +677,7 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let dcx = DiagnosticCxBuilder::write(machine, tag, range);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &state, dcx, exposed_tags)\n         })\n@@ -691,12 +689,11 @@ impl Stacks {\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n-        state: &GlobalState,\n-        machine: &'ecx MiriMachine<'mir, 'tcx>,\n+        machine: &'ecx mut MiriMachine<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let dcx = DiagnosticCxBuilder::dealloc(machine, tag);\n-        let state = state.borrow();\n+        let state = machine.stacked_borrows.as_ref().unwrap().borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n         })?;"}]}