{"sha": "127a6ede1dd9622db20bee435221205b3a61d0ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyN2E2ZWRlMWRkOTYyMmRiMjBiZWU0MzUyMjEyMDViM2E2MWQwYmE=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-09-09T05:18:28Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-11T01:44:47Z"}, "message": "Use Places to express closure/generator Captures\n\nCo-authored-by: Archer Zhang <archer.xn@gmail.com>", "tree": {"sha": "d29c556632e4b2f1cef4f57b3e2e00cebd48ef6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d29c556632e4b2f1cef4f57b3e2e00cebd48ef6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/127a6ede1dd9622db20bee435221205b3a61d0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/127a6ede1dd9622db20bee435221205b3a61d0ba", "html_url": "https://github.com/rust-lang/rust/commit/127a6ede1dd9622db20bee435221205b3a61d0ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/127a6ede1dd9622db20bee435221205b3a61d0ba/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf9cf7c923eb01146971429044f216a3ca905e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9cf7c923eb01146971429044f216a3ca905e06", "html_url": "https://github.com/rust-lang/rust/commit/cf9cf7c923eb01146971429044f216a3ca905e06"}], "stats": {"total": 444, "additions": 314, "deletions": 130}, "files": [{"sha": "e9bc4b9b90dd5621b8d8182a7958dfe008befd4d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -415,6 +415,10 @@ pub struct TypeckResults<'tcx> {\n     /// entire variable.\n     pub closure_captures: ty::UpvarListMap,\n \n+    /// Given the closure ID this map provides the list of\n+    /// `Place`s and how/why are they captured by the closure.\n+    pub closure_capture_information: ty::CaptureInformationMap<'tcx>,\n+\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n@@ -442,6 +446,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             tainted_by_errors: None,\n             concrete_opaque_types: Default::default(),\n             closure_captures: Default::default(),\n+            closure_capture_information: Default::default(),\n             generator_interior_types: Default::default(),\n         }\n     }\n@@ -676,6 +681,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors,\n             ref concrete_opaque_types,\n             ref closure_captures,\n+            ref closure_capture_information,\n             ref generator_interior_types,\n         } = *self;\n \n@@ -709,6 +715,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             tainted_by_errors.hash_stable(hcx, hasher);\n             concrete_opaque_types.hash_stable(hcx, hasher);\n             closure_captures.hash_stable(hcx, hasher);\n+            closure_capture_information.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n         })\n     }"}, {"sha": "5f2d3b7818e7f9c8d95e907d563121532645b7bb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -6,6 +6,7 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n+use crate::hir::place::Place as HirPlace;\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n@@ -674,6 +675,12 @@ pub struct UpvarId {\n     pub closure_expr_id: LocalDefId,\n }\n \n+impl UpvarId {\n+    pub fn new(var_hir_id: hir::HirId, closure_def_id: LocalDefId) -> UpvarId {\n+        UpvarId { var_path: UpvarPath { hir_id: var_hir_id }, closure_expr_id: closure_def_id }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -756,9 +763,40 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n+pub struct CaptureInfo<'tcx> {\n+    /// Expr Id pointing to use that resulting in selecting the current capture kind\n+    pub expr_id: Option<hir::HirId>,\n+\n+    /// Capture mode that was selected\n+    pub capture_kind: UpvarCapture<'tcx>,\n+}\n+\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n+/// Consider closure where s.str1 is captured via an ImmutableBorrow and s.str2 via a MutableBorrow\n+///\n+/// ```rust\n+/// // Assume that thte HirId for the variable definition is `V1`\n+/// let mut s = SomeStruct { str1: format!(\"s1\"), str2: format!(\"s2\") }\n+///\n+/// let fix_s = |new_s2| {\n+///     // Assume that the HirId for the expression `s.str1` is `E1`\n+///     println!(\"Updating SomeStruct with str1=\", s.str1);\n+///     // Assume that the HirId for the expression `*s.str2` is `E2`\n+///     s.str2 = new_s2;\n+/// }\n+/// ```\n+///\n+/// For closure `fix_s`, (at a high level) the IndexMap will contain:\n+///\n+/// Place { V1, [ProjectionKind::Field(Index=0, Variant=0)] } : CaptureKind { E1, ImmutableBorrow }\n+/// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n+///\n+pub type CaptureInformationMap<'tcx> =\n+    FxHashMap<DefId, FxIndexMap<HirPlace<'tcx>, CaptureInfo<'tcx>>>;\n+\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),"}, {"sha": "47c0400533bd828f1e46e8b2140a29843d6c8c7b", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -387,8 +387,9 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 }\n             };\n             let upvars = cx\n-                .tcx\n-                .upvars_mentioned(def_id)\n+                .typeck_results()\n+                .closure_captures\n+                .get(&def_id)\n                 .iter()\n                 .flat_map(|upvars| upvars.iter())\n                 .zip(substs.upvar_tys())"}, {"sha": "24bb7756ef36fab34d2e70734d38a3218401e5da", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 225, "deletions": 95, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -32,17 +32,18 @@\n \n use super::FnCtxt;\n \n+use std::env;\n+\n use crate::expr_use_visitor as euv;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n-use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n+use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::{Span, Symbol};\n-use std::collections::hash_map::Entry;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -111,40 +112,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-            let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> =\n-                FxIndexMap::with_capacity_and_hasher(upvars.len(), Default::default());\n-            for (&var_hir_id, _) in upvars.iter() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: closure_def_id.expect_local(),\n-                };\n-                debug!(\"seed upvar_id {:?}\", upvar_id);\n-                // Adding the upvar Id to the list of Upvars, which will be added\n-                // to the map for the closure at the end of the for loop.\n-                closure_captures.insert(var_hir_id, upvar_id);\n-\n-                let capture_kind = match capture_clause {\n-                    hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n-                    hir::CaptureBy::Ref => {\n-                        let origin = UpvarRegion(upvar_id, span);\n-                        let upvar_region = self.next_region_var(origin);\n-                        let upvar_borrow =\n-                            ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-                        ty::UpvarCapture::ByRef(upvar_borrow)\n-                    }\n-                };\n+        let local_def_id = closure_def_id.expect_local();\n \n-                self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n-            }\n-            // Add the vector of upvars to the map keyed with the closure id.\n-            // This gives us an easier access to them without having to call\n-            // tcx.upvars again..\n-            if !closure_captures.is_empty() {\n-                self.typeck_results\n-                    .borrow_mut()\n-                    .closure_captures\n-                    .insert(closure_def_id, closure_captures);\n+        let mut capture_information = FxIndexMap::<Place<'tcx>, ty::CaptureInfo<'tcx>>::default();\n+        if !new_capture_analysis() {\n+            debug!(\"Using old-style capture analysis\");\n+            if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n+                for (&var_hir_id, _) in upvars.iter() {\n+                    let place = self.place_for_root_variable(local_def_id, var_hir_id);\n+\n+                    debug!(\"seed place {:?}\", place);\n+\n+                    let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n+                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let info = ty::CaptureInfo { expr_id: None, capture_kind };\n+\n+                    capture_information.insert(place, info);\n+                }\n             }\n         }\n \n@@ -153,9 +137,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n             closure_def_id,\n+            closure_span: span,\n+            capture_clause,\n             current_closure_kind: ty::ClosureKind::LATTICE_BOTTOM,\n             current_origin: None,\n-            adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n+            capture_information,\n         };\n         euv::ExprUseVisitor::new(\n             &mut delegate,\n@@ -182,7 +168,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.typeck_results.borrow_mut().upvar_capture_map.extend(delegate.adjust_upvar_captures);\n+        self.set_closure_captures(closure_def_id, &delegate);\n+\n+        self.typeck_results\n+            .borrow_mut()\n+            .closure_capture_information\n+            .insert(closure_def_id, delegate.capture_information);\n \n         // Now that we've analyzed the closure, we know how each\n         // variable is borrowed, and we know what traits the closure\n@@ -226,15 +217,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         let closure_def_id = tcx.hir().local_def_id(closure_id);\n \n-        tcx.upvars_mentioned(closure_def_id)\n+        self.typeck_results\n+            .borrow()\n+            .closure_captures\n+            .get(&closure_def_id.to_def_id())\n             .iter()\n             .flat_map(|upvars| {\n                 upvars.iter().map(|(&var_hir_id, _)| {\n                     let upvar_ty = self.node_ty(var_hir_id);\n-                    let upvar_id = ty::UpvarId {\n-                        var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: closure_def_id,\n-                    };\n+                    let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n                     let capture = self.typeck_results.borrow().upvar_capture(upvar_id);\n \n                     debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n@@ -250,6 +241,90 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n             .collect()\n     }\n+\n+    fn set_closure_captures(\n+        &self,\n+        closure_def_id: DefId,\n+        inferred_info: &InferBorrowKind<'_, 'tcx>,\n+    ) {\n+        let mut closure_captures: FxIndexMap<hir::HirId, ty::UpvarId> = Default::default();\n+\n+        for (place, capture_info) in inferred_info.capture_information.iter() {\n+            let upvar_id = match place.base {\n+                PlaceBase::Upvar(upvar_id) => upvar_id,\n+                base => bug!(\"Expected upvar, found={:?}\", base),\n+            };\n+\n+            assert_eq!(upvar_id.closure_expr_id, closure_def_id.expect_local());\n+\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            closure_captures.insert(var_hir_id, upvar_id);\n+\n+            let mut new_capture_kind = capture_info.capture_kind;\n+            if let Some(existing_capture_kind) =\n+                self.typeck_results.borrow_mut().upvar_capture_map.get(&upvar_id)\n+            {\n+                // FIXME(@azhng): refactor this later\n+                new_capture_kind = match (existing_capture_kind, new_capture_kind) {\n+                    (ty::UpvarCapture::ByValue(Some(_)), _) => *existing_capture_kind,\n+                    (_, ty::UpvarCapture::ByValue(Some(_))) => new_capture_kind,\n+                    (ty::UpvarCapture::ByValue(_), _) | (_, ty::UpvarCapture::ByValue(_)) => {\n+                        ty::UpvarCapture::ByValue(None)\n+                    }\n+                    (ty::UpvarCapture::ByRef(existing_ref), ty::UpvarCapture::ByRef(new_ref)) => {\n+                        match (existing_ref.kind, new_ref.kind) {\n+                            // Take RHS:\n+                            (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n+                            | (ty::UniqueImmBorrow, ty::MutBorrow) => new_capture_kind,\n+                            // Take LHS:\n+                            (ty::ImmBorrow, ty::ImmBorrow)\n+                            | (ty::UniqueImmBorrow, ty::ImmBorrow | ty::UniqueImmBorrow)\n+                            | (ty::MutBorrow, _) => *existing_capture_kind,\n+                        }\n+                    }\n+                };\n+            }\n+            self.typeck_results.borrow_mut().upvar_capture_map.insert(upvar_id, new_capture_kind);\n+        }\n+\n+        if !closure_captures.is_empty() {\n+            self.typeck_results\n+                .borrow_mut()\n+                .closure_captures\n+                .insert(closure_def_id, closure_captures);\n+        }\n+    }\n+\n+    fn init_capture_kind(\n+        &self,\n+        capture_clause: hir::CaptureBy,\n+        upvar_id: ty::UpvarId,\n+        closure_span: Span,\n+    ) -> ty::UpvarCapture<'tcx> {\n+        match capture_clause {\n+            hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n+            hir::CaptureBy::Ref => {\n+                let origin = UpvarRegion(upvar_id, closure_span);\n+                let upvar_region = self.next_region_var(origin);\n+                let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n+                ty::UpvarCapture::ByRef(upvar_borrow)\n+            }\n+        }\n+    }\n+\n+    fn place_for_root_variable(\n+        &self,\n+        closure_def_id: LocalDefId,\n+        var_hir_id: hir::HirId,\n+    ) -> Place<'tcx> {\n+        let upvar_id = ty::UpvarId::new(var_hir_id, closure_def_id);\n+\n+        Place {\n+            base_ty: self.node_ty(var_hir_id),\n+            base: PlaceBase::Upvar(upvar_id),\n+            projections: Default::default(),\n+        }\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {\n@@ -258,6 +333,10 @@ struct InferBorrowKind<'a, 'tcx> {\n     // The def-id of the closure whose kind and upvar accesses are being inferred.\n     closure_def_id: DefId,\n \n+    closure_span: Span,\n+\n+    capture_clause: hir::CaptureBy,\n+\n     // The kind that we have inferred that the current closure\n     // requires. Note that we *always* infer a minimal kind, even if\n     // we don't always *use* that in the final result (i.e., sometimes\n@@ -272,7 +351,7 @@ struct InferBorrowKind<'a, 'tcx> {\n \n     // For each upvar that we access, we track the minimal kind of\n     // access we need (ref, ref mut, move, etc).\n-    adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n+    capture_information: FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -314,26 +393,21 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             var_name(tcx, upvar_id.var_path.hir_id),\n         );\n \n-        let new_capture = ty::UpvarCapture::ByValue(Some(usage_span));\n-        match self.adjust_upvar_captures.entry(upvar_id) {\n-            Entry::Occupied(mut e) => {\n-                match e.get() {\n-                    // We always overwrite `ByRef`, since we require\n-                    // that the upvar be available by value.\n-                    //\n-                    // If we had a previous by-value usage without a specific\n-                    // span, use ours instead. Otherwise, keep the first span\n-                    // we encountered, since there isn't an obviously better one.\n-                    ty::UpvarCapture::ByRef(_) | ty::UpvarCapture::ByValue(None) => {\n-                        e.insert(new_capture);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            Entry::Vacant(e) => {\n-                e.insert(new_capture);\n-            }\n-        }\n+        let capture_info = ty::CaptureInfo {\n+            expr_id: Some(diag_expr_id),\n+            capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n+        };\n+\n+        let curr_info = self.capture_information.get(&place_with_id.place);\n+        let updated_info = match curr_info {\n+            Some(info) => match info.capture_kind {\n+                ty::UpvarCapture::ByRef(_) | ty::UpvarCapture::ByValue(None) => capture_info,\n+                _ => *info,\n+            },\n+            None => capture_info,\n+        };\n+\n+        self.capture_information.insert(place_with_id.place.clone(), updated_info);\n     }\n \n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n@@ -349,7 +423,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id\n         );\n \n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             let mut borrow_kind = ty::MutBorrow;\n             for pointer_ty in place_with_id.place.deref_tys() {\n                 match pointer_ty.kind() {\n@@ -363,7 +437,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                     _ => (),\n                 }\n             }\n-            self.adjust_upvar_deref(upvar_id, self.fcx.tcx.hir().span(diag_expr_id), borrow_kind);\n+            self.adjust_upvar_deref(place_with_id, diag_expr_id, borrow_kind);\n         }\n     }\n \n@@ -377,24 +451,20 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id\n         );\n \n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n             if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n                 // Raw pointers don't inherit mutability.\n                 return;\n             }\n             // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(\n-                upvar_id,\n-                self.fcx.tcx.hir().span(diag_expr_id),\n-                ty::UniqueImmBorrow,\n-            );\n+            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::UniqueImmBorrow);\n         }\n     }\n \n     fn adjust_upvar_deref(\n         &mut self,\n-        upvar_id: ty::UpvarId,\n-        place_span: Span,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n         borrow_kind: ty::BorrowKind,\n     ) {\n         assert!(match borrow_kind {\n@@ -411,45 +481,57 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         // upvar, then we need to modify the\n         // borrow_kind of the upvar to make sure it\n         // is inferred to mutable if necessary\n-        self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n+        self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n \n-        // also need to be in an FnMut closure since this is not an ImmBorrow\n-        self.adjust_closure_kind(\n-            upvar_id.closure_expr_id,\n-            ty::ClosureKind::FnMut,\n-            place_span,\n-            var_name(tcx, upvar_id.var_path.hir_id),\n-        );\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            self.adjust_closure_kind(\n+                upvar_id.closure_expr_id,\n+                ty::ClosureKind::FnMut,\n+                tcx.hir().span(diag_expr_id),\n+                var_name(tcx, upvar_id.var_path.hir_id),\n+            );\n+        }\n     }\n \n     /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n     /// The borrow_kind basically follows a lattice of `imm < unique-imm < mut`,\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n-        let upvar_capture = self\n-            .adjust_upvar_captures\n-            .get(&upvar_id)\n-            .copied()\n-            .unwrap_or_else(|| self.fcx.typeck_results.borrow().upvar_capture(upvar_id));\n+    fn adjust_upvar_borrow_kind(\n+        &mut self,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+        kind: ty::BorrowKind,\n+    ) {\n+        let capture_info = self\n+            .capture_information\n+            .get(&place_with_id.place)\n+            .unwrap_or_else(|| bug!(\"Upar capture info missing\"));\n+        // We init capture_information for each element\n+\n         debug!(\n-            \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-            upvar_id, upvar_capture, kind\n+            \"adjust_upvar_borrow_kind(place={:?}, , diag_expr_id={:?}, capture_info={:?}, kind={:?})\",\n+            place_with_id, diag_expr_id, capture_info, kind\n         );\n \n-        match upvar_capture {\n+        match capture_info.capture_kind {\n             ty::UpvarCapture::ByValue(_) => {\n                 // Upvar is already by-value, the strongest criteria.\n             }\n-            ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n                 match (upvar_borrow.kind, kind) {\n                     // Take RHS:\n                     (ty::ImmBorrow, ty::UniqueImmBorrow | ty::MutBorrow)\n                     | (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-                        upvar_borrow.kind = kind;\n-                        self.adjust_upvar_captures\n-                            .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n+                        if let Some(ty::CaptureInfo { expr_id, capture_kind }) =\n+                            self.capture_information.get_mut(&place_with_id.place)\n+                        {\n+                            *expr_id = Some(diag_expr_id);\n+                            if let ty::UpvarCapture::ByRef(borrow_kind) = capture_kind {\n+                                borrow_kind.kind = kind;\n+                            }\n+                        }\n                     }\n                     // Take LHS:\n                     (ty::ImmBorrow, ty::ImmBorrow)\n@@ -501,6 +583,33 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn init_capture_info_for_place(\n+        &mut self,\n+        place_with_id: &PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+    ) {\n+        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n+            assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n+\n+            debug!(\"Capturing new place {:?}\", place_with_id);\n+\n+            let tcx = self.fcx.tcx;\n+            let capture_kind =\n+                self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n+\n+            let expr_id = Some(diag_expr_id);\n+            let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n+\n+            if log_capture_analysis() {\n+                debug!(\"capture_info: {:?}\", capture_info);\n+            }\n+\n+            self.capture_information.insert(place_with_id.place.clone(), capture_info);\n+        } else {\n+            debug!(\"Not upvar: {:?}\", place_with_id);\n+        }\n+    }\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n@@ -514,7 +623,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             \"consume(place_with_id={:?}, diag_expr_id={:?}, mode={:?})\",\n             place_with_id, diag_expr_id, mode\n         );\n-        self.adjust_upvar_borrow_kind_for_consume(&place_with_id, diag_expr_id, mode);\n+        if !self.capture_information.contains_key(&place_with_id.place) {\n+            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+        }\n+\n+        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id, mode);\n     }\n \n     fn borrow(\n@@ -528,6 +641,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        if !self.capture_information.contains_key(&place_with_id.place) {\n+            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+        }\n+\n         match bk {\n             ty::ImmBorrow => {}\n             ty::UniqueImmBorrow => {\n@@ -541,10 +658,23 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n \n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n         debug!(\"mutate(assignee_place={:?}, diag_expr_id={:?})\", assignee_place, diag_expr_id);\n+\n+        if !self.capture_information.contains_key(&assignee_place.place) {\n+            self.init_capture_info_for_place(assignee_place, diag_expr_id);\n+        }\n+\n         self.adjust_upvar_borrow_kind_for_mut(assignee_place, diag_expr_id);\n     }\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n     tcx.hir().name(var_hir_id)\n }\n+\n+fn new_capture_analysis() -> bool {\n+    matches!(env::var(\"SG_NEW\"), Ok(_))\n+}\n+\n+fn log_capture_analysis() -> bool {\n+    matches!(env::var(\"SG_VERBOSE\"), Ok(_))\n+}"}, {"sha": "a8cac3e0fc820222ca2d273df8b79f4bc227c638", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -73,6 +73,7 @@ pub enum MutateMode {\n // This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n+    body_owner: LocalDefId,\n     delegate: &'a mut dyn Delegate<'tcx>,\n }\n \n@@ -110,6 +111,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(infcx, param_env, body_owner, typeck_results),\n+            body_owner,\n             delegate,\n         }\n     }\n@@ -529,7 +531,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n \n         let tcx = self.tcx();\n-        let ExprUseVisitor { ref mc, ref mut delegate } = *self;\n+        let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n@@ -569,50 +571,56 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n-    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, fn_decl_span: Span) {\n+    // FIXME(arora-aman):  fix the fn_decl_span\n+    fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>, _fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id);\n-        if let Some(upvars) = self.tcx().upvars_mentioned(closure_def_id) {\n-            for &var_id in upvars.keys() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_id },\n-                    closure_expr_id: closure_def_id,\n+        // We are currently walking a closure that is within a given body\n+        // We need to process all the captures for this closure.\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n+        let upvars = self.tcx().upvars_mentioned(self.body_owner);\n+        if let Some(closure_capture_information) =\n+            self.mc.typeck_results.closure_capture_information.get(&closure_def_id)\n+        {\n+            for (place, capture_info) in closure_capture_information.iter() {\n+                let var_hir_id = if let PlaceBase::Upvar(upvar_id) = place.base {\n+                    upvar_id.var_path.hir_id\n+                } else {\n+                    continue;\n+                    // FIXME(arora-aman): throw err?\n                 };\n-                let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n-                let captured_place = return_if_err!(self.cat_captured_var(\n-                    closure_expr.hir_id,\n-                    fn_decl_span,\n-                    var_id,\n-                ));\n-                match upvar_capture {\n+\n+                if !upvars.map_or(false, |upvars| upvars.contains_key(&var_hir_id)) {\n+                    // The nested closure might be capturing our local variables\n+                    // Since for the current body these aren't captures, we will ignore them.\n+                    continue;\n+                }\n+\n+                // The place is being captured by the enclosing closure\n+                // FIXME(arora-aman) Make sure this is valid to do when called from clippy.\n+                let upvar_id = ty::UpvarId::new(var_hir_id, self.body_owner);\n+                let place_with_id = PlaceWithHirId::new(\n+                    capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                    place.base_ty,\n+                    PlaceBase::Upvar(upvar_id),\n+                    place.projections.clone(),\n+                );\n+                match capture_info.capture_kind {\n                     ty::UpvarCapture::ByValue(_) => {\n-                        let mode = copy_or_move(&self.mc, &captured_place);\n-                        self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n+                        let mode = copy_or_move(&self.mc, &place_with_id);\n+                        self.delegate.consume(&place_with_id, place_with_id.hir_id, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n                         self.delegate.borrow(\n-                            &captured_place,\n-                            captured_place.hir_id,\n+                            &place_with_id,\n+                            place_with_id.hir_id,\n                             upvar_borrow.kind,\n                         );\n                     }\n                 }\n             }\n         }\n     }\n-\n-    fn cat_captured_var(\n-        &mut self,\n-        closure_hir_id: hir::HirId,\n-        closure_span: Span,\n-        var_id: hir::HirId,\n-    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n-        // Create the place for the variable being borrowed, from the\n-        // perspective of the creator (parent) of the closure.\n-        let var_ty = self.mc.node_ty(var_id)?;\n-        self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))\n-    }\n }\n \n fn copy_or_move<'a, 'tcx>("}, {"sha": "d590f876b8e77c9acfcf6cee3711fd0087f3868b", "filename": "src/test/ui/generator/print/generator-print-verbose-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/127a6ede1dd9622db20bee435221205b3a61d0ba/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/127a6ede1dd9622db20bee435221205b3a61d0ba/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fprint%2Fgenerator-print-verbose-2.stderr?ref=127a6ede1dd9622db20bee435221205b3a61d0ba", "patch": "@@ -8,8 +8,8 @@ LL |     assert_send(|| {\n    |     ^^^^^^^^^^^ `Cell<i32>` cannot be shared between threads safely\n    |\n    = help: the trait `Sync` is not implemented for `Cell<i32>`\n-   = note: required because of the requirements on the impl of `Send` for `&'_#3r Cell<i32>`\n-   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#3r Cell<i32>) _#17t]`\n+   = note: required because of the requirements on the impl of `Send` for `&'_#4r Cell<i32>`\n+   = note: required because it appears within the type `[main::{closure#1} upvar_tys=(&'_#4r Cell<i32>) _#17t]`\n \n error: generator cannot be shared between threads safely\n   --> $DIR/generator-print-verbose-2.rs:12:5"}]}