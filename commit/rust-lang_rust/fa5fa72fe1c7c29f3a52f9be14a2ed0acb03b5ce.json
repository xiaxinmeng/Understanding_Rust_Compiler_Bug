{"sha": "fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "node_id": "C_kwDOAAsO6NoAKGZhNWZhNzJmZTFjN2MyOWYzYTUyZjliZTE0YTJlZDBhY2IwM2I1Y2U", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-18T12:48:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-03-18T12:50:30Z"}, "message": "Miri: implement arbitrary-self dyn receivers", "tree": {"sha": "6de9c5b2c18f28c4284a8b7dbd0a2356f5c6c374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6de9c5b2c18f28c4284a8b7dbd0a2356f5c6c374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "html_url": "https://github.com/rust-lang/rust/commit/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "461e8078010433ff7de2db2aaae8a3cfb0847215", "url": "https://api.github.com/repos/rust-lang/rust/commits/461e8078010433ff7de2db2aaae8a3cfb0847215", "html_url": "https://github.com/rust-lang/rust/commit/461e8078010433ff7de2db2aaae8a3cfb0847215"}], "stats": {"total": 55, "additions": 40, "deletions": 15}, "files": [{"sha": "57a93ed4d55f8efa20ef0e52b0c09d15a81b9f6e", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=fa5fa72fe1c7c29f3a52f9be14a2ed0acb03b5ce", "patch": "@@ -476,22 +476,47 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let mut args = args.to_vec();\n-                // We have to implement all \"object safe receivers\".  Currently we\n-                // support built-in pointers `(&, &mut, Box)` as well as unsized-self.  We do\n-                // not yet support custom self types.\n-                // Also see `compiler/rustc_codegen_llvm/src/abi.rs` and `compiler/rustc_codegen_ssa/src/mir/block.rs`.\n-                let receiver_place = match args[0].layout.ty.builtin_deref(true) {\n-                    Some(_) => {\n-                        // Built-in pointer.\n-                        self.deref_operand(&args[0])?\n-                    }\n-                    None => {\n-                        // Unsized self.\n-                        args[0].assert_mem_place()\n+                // We have to implement all \"object safe receivers\". So we have to go search for a\n+                // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n+                // unwrap those newtypes until we are there.\n+                let mut receiver = args[0];\n+                let receiver_place = loop {\n+                    match receiver.layout.ty.kind() {\n+                        ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n+                        ty::Dynamic(..) => break receiver.assert_mem_place(),\n+                        _ => {\n+                            // Not there yet, search for the only non-ZST field.\n+                            let mut non_zst_field = None;\n+                            for i in 0..receiver.layout.fields.count() {\n+                                let field = self.operand_field(&receiver, i)?;\n+                                if !field.layout.is_zst() {\n+                                    assert!(\n+                                        non_zst_field.is_none(),\n+                                        \"multiple non-ZST fields in dyn receiver type {}\",\n+                                        receiver.layout.ty\n+                                    );\n+                                    non_zst_field = Some(field);\n+                                }\n+                            }\n+                            receiver = non_zst_field.unwrap_or_else(|| {\n+                                panic!(\n+                                    \"no non-ZST fields in dyn receiver type {}\",\n+                                    receiver.layout.ty\n+                                )\n+                            });\n+                        }\n                     }\n                 };\n-                // Find and consult vtable\n-                let vtable = self.scalar_to_ptr(receiver_place.vtable());\n+                // Find and consult vtable. The type now could be something like RcBox<dyn Trait>,\n+                // i.e., it is still not necessarily `ty::Dynamic` (so we cannot use\n+                // `place.vtable()`), but it should have a `dyn Trait` tail.\n+                assert!(matches!(\n+                    self.tcx\n+                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env)\n+                        .kind(),\n+                    ty::Dynamic(..)\n+                ));\n+                let vtable = self.scalar_to_ptr(receiver_place.meta.unwrap_meta());\n                 let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n@@ -505,7 +530,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),\n                     this_receiver_ptr,\n                 ));\n-                trace!(\"Patched self operand to {:#?}\", args[0]);\n+                trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n                     fn_val,"}]}