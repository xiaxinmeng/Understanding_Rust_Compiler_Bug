{"sha": "27fae2b24af48041ceea6e04c7f217d3db372164", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZmFlMmIyNGFmNDgwNDFjZWVhNmUwNGM3ZjIxN2QzZGIzNzIxNjQ=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-02-28T17:59:12Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2018-02-28T17:59:12Z"}, "message": "Remove thread_local_state", "tree": {"sha": "a5359a056d41e36b704766733e8657c282cac07d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5359a056d41e36b704766733e8657c282cac07d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27fae2b24af48041ceea6e04c7f217d3db372164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27fae2b24af48041ceea6e04c7f217d3db372164", "html_url": "https://github.com/rust-lang/rust/commit/27fae2b24af48041ceea6e04c7f217d3db372164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27fae2b24af48041ceea6e04c7f217d3db372164/comments", "author": null, "committer": null, "parents": [{"sha": "c99f4c4c5b9f968b82037cf643b6662b140d9b1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99f4c4c5b9f968b82037cf643b6662b140d9b1f", "html_url": "https://github.com/rust-lang/rust/commit/c99f4c4c5b9f968b82037cf643b6662b140d9b1f"}], "stats": {"total": 153, "additions": 26, "deletions": 127}, "files": [{"sha": "b8fb83ad46597f517a4566ed760ddc90e8ac0960", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=27fae2b24af48041ceea6e04c7f217d3db372164", "patch": "@@ -18,8 +18,6 @@ use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use thread::LocalKey;\n-#[allow(deprecated)]\n-use thread::LocalKeyState;\n \n /// Stdout used by print! and println! macros\n thread_local! {\n@@ -670,25 +668,26 @@ pub fn set_print(sink: Option<Box<Write + Send>>) -> Option<Box<Write + Send>> {\n /// thread, it will just fall back to the global stream.\n ///\n /// However, if the actual I/O causes an error, this function does panic.\n-#[allow(deprecated)]\n-fn print_to<T>(args: fmt::Arguments,\n-               local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n-               global_s: fn() -> T,\n-               label: &str) where T: Write {\n-    let result = match local_s.state() {\n-        LocalKeyState::Uninitialized |\n-        LocalKeyState::Destroyed => global_s().write_fmt(args),\n-        LocalKeyState::Valid => {\n-            local_s.with(|s| {\n-                if let Ok(mut borrowed) = s.try_borrow_mut() {\n-                    if let Some(w) = borrowed.as_mut() {\n-                        return w.write_fmt(args);\n-                    }\n-                }\n-                global_s().write_fmt(args)\n-            })\n+fn print_to<T>(\n+    args: fmt::Arguments,\n+    local_s: &'static LocalKey<RefCell<Option<Box<Write+Send>>>>,\n+    global_s: fn() -> T,\n+    label: &str,\n+)\n+where\n+    T: Write,\n+{\n+    let result = local_s.try_with(|s| {\n+        if let Ok(mut borrowed) = s.try_borrow_mut() {\n+            if let Some(w) = borrowed.as_mut() {\n+                return w.write_fmt(args);\n+            }\n         }\n-    };\n+        global_s().write_fmt(args)\n+    }).unwrap_or_else(|_| {\n+        global_s().write_fmt(args)\n+    });\n+\n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);\n     }"}, {"sha": "25fedcb2772656e59a532d7ad585450bc4f75a5c", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 7, "deletions": 104, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=27fae2b24af48041ceea6e04c7f217d3db372164", "patch": "@@ -195,45 +195,6 @@ macro_rules! __thread_local_inner {\n     }\n }\n \n-/// Indicator of the state of a thread local storage key.\n-#[unstable(feature = \"thread_local_state\",\n-           reason = \"state querying was recently added\",\n-           issue = \"27716\")]\n-#[rustc_deprecated(since = \"1.26.0\", reason = \"use `LocalKey::try_with` instead\")]\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub enum LocalKeyState {\n-    /// All keys are in this state whenever a thread starts. Keys will\n-    /// transition to the `Valid` state once the first call to [`with`] happens\n-    /// and the initialization expression succeeds.\n-    ///\n-    /// Keys in the `Uninitialized` state will yield a reference to the closure\n-    /// passed to [`with`] so long as the initialization routine does not panic.\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Uninitialized,\n-\n-    /// Once a key has been accessed successfully, it will enter the `Valid`\n-    /// state. Keys in the `Valid` state will remain so until the thread exits,\n-    /// at which point the destructor will be run and the key will enter the\n-    /// `Destroyed` state.\n-    ///\n-    /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n-    /// closure passed to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Valid,\n-\n-    /// When a thread exits, the destructors for keys will be run (if\n-    /// necessary). While a destructor is running, and possibly after a\n-    /// destructor has run, a key is in the `Destroyed` state.\n-    ///\n-    /// Keys in the `Destroyed` states will trigger a panic when accessed via\n-    /// [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    Destroyed,\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n pub struct AccessError {\n@@ -307,51 +268,6 @@ impl<T: 'static> LocalKey<T> {\n         (*ptr).as_ref().unwrap()\n     }\n \n-    /// Query the current state of this key.\n-    ///\n-    /// A key is initially in the `Uninitialized` state whenever a thread\n-    /// starts. It will remain in this state up until the first call to [`with`]\n-    /// within a thread has run the initialization expression successfully.\n-    ///\n-    /// Once the initialization expression succeeds, the key transitions to the\n-    /// `Valid` state which will guarantee that future calls to [`with`] will\n-    /// succeed within the thread. Some keys might skip the `Uninitialized`\n-    /// state altogether and start in the `Valid` state as an optimization\n-    /// (e.g. keys initialized with a constant expression), but no guarantees\n-    /// are made.\n-    ///\n-    /// When a thread exits, each key will be destroyed in turn, and as keys are\n-    /// destroyed they will enter the `Destroyed` state just before the\n-    /// destructor starts to run. Keys may remain in the `Destroyed` state after\n-    /// destruction has completed. Keys without destructors (e.g. with types\n-    /// that are [`Copy`]), may never enter the `Destroyed` state.\n-    ///\n-    /// Keys in the `Uninitialized` state can be accessed so long as the\n-    /// initialization does not panic. Keys in the `Valid` state are guaranteed\n-    /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n-    /// any call to [`with`].\n-    ///\n-    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n-    /// [`Copy`]: ../../std/marker/trait.Copy.html\n-    #[unstable(feature = \"thread_local_state\",\n-               reason = \"state querying was recently added\",\n-               issue = \"27716\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use `LocalKey::try_with` instead\")]\n-    #[allow(deprecated)]\n-    pub fn state(&'static self) -> LocalKeyState {\n-        unsafe {\n-            match (self.inner)() {\n-                Some(cell) => {\n-                    match *cell.get() {\n-                        Some(..) => LocalKeyState::Valid,\n-                        None => LocalKeyState::Uninitialized,\n-                    }\n-                }\n-                None => LocalKeyState::Destroyed,\n-            }\n-        }\n-    }\n-\n     /// Acquires a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -527,8 +443,6 @@ pub mod os {\n mod tests {\n     use sync::mpsc::{channel, Sender};\n     use cell::{Cell, UnsafeCell};\n-    #[allow(deprecated)]\n-    use super::LocalKeyState;\n     use thread;\n \n     struct Foo(Sender<()>);\n@@ -563,26 +477,21 @@ mod tests {\n     }\n \n     #[test]\n-    #[allow(deprecated)]\n     fn states() {\n         struct Foo;\n         impl Drop for Foo {\n             fn drop(&mut self) {\n-                assert!(FOO.state() == LocalKeyState::Destroyed);\n+                assert!(FOO.try_with(|_| ()).is_err());\n             }\n         }\n         fn foo() -> Foo {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n+            assert!(FOO.try_with(|_| ()).is_err());\n             Foo\n         }\n         thread_local!(static FOO: Foo = foo());\n \n         thread::spawn(|| {\n-            assert!(FOO.state() == LocalKeyState::Uninitialized);\n-            FOO.with(|_| {\n-                assert!(FOO.state() == LocalKeyState::Valid);\n-            });\n-            assert!(FOO.state() == LocalKeyState::Valid);\n+            assert!(FOO.try_with(|_| ()).is_ok());\n         }).join().ok().unwrap();\n     }\n \n@@ -601,7 +510,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[allow(deprecated)]\n     fn circular() {\n         struct S1;\n         struct S2;\n@@ -612,8 +520,7 @@ mod tests {\n         impl Drop for S1 {\n             fn drop(&mut self) {\n                 unsafe {\n-                    HITS += 1;\n-                    if K2.state() == LocalKeyState::Destroyed {\n+                    if K2.try_with(|_| ()).is_err() {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -629,7 +536,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(K1.state() != LocalKeyState::Destroyed);\n+                    assert!(K1.try_with(|_| ()).is_ok());\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -642,14 +549,13 @@ mod tests {\n     }\n \n     #[test]\n-    #[allow(deprecated)]\n     fn self_referential() {\n         struct S1;\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.state() == LocalKeyState::Destroyed);\n+                assert!(K1.try_with(|_| ()).is_err());\n             }\n         }\n \n@@ -664,7 +570,6 @@ mod tests {\n     // test on macOS.\n     #[test]\n     #[cfg_attr(target_os = \"macos\", ignore)]\n-    #[allow(deprecated)]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n@@ -674,9 +579,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if K2.state() != LocalKeyState::Destroyed {\n-                        K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n-                    }\n+                    let _ = K2.try_with(|s| *s.get() = Some(Foo(tx.clone())));\n                 }\n             }\n         }"}, {"sha": "71aee673cfe3ee57e7893a54c1e1823493713693", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fae2b24af48041ceea6e04c7f217d3db372164/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=27fae2b24af48041ceea6e04c7f217d3db372164", "patch": "@@ -192,9 +192,6 @@ use time::Duration;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{LocalKey, AccessError};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::local::LocalKeyState;\n \n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key"}]}