{"sha": "5a4cb3ef36bc0610284c5e67c239363d3757df71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNGNiM2VmMzZiYzA2MTAyODRjNWU2N2MyMzkzNjNkMzc1N2RmNzE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T21:01:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T21:01:21Z"}, "message": "Translate a modest selection of easy binops.", "tree": {"sha": "a1648adb11d18d0d3767a5ebf0b6b52d75ca8ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1648adb11d18d0d3767a5ebf0b6b52d75ca8ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a4cb3ef36bc0610284c5e67c239363d3757df71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4cb3ef36bc0610284c5e67c239363d3757df71", "html_url": "https://github.com/rust-lang/rust/commit/5a4cb3ef36bc0610284c5e67c239363d3757df71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a4cb3ef36bc0610284c5e67c239363d3757df71/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89", "html_url": "https://github.com/rust-lang/rust/commit/11e72fd4e0a2e46afd9021b8ab4fb071ffb6ee89"}], "stats": {"total": 213, "additions": 176, "deletions": 37}, "files": [{"sha": "98cb7e1ee95300b75330c6c5fd32d4348242afb2", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=5a4cb3ef36bc0610284c5e67c239363d3757df71", "patch": "@@ -250,11 +250,13 @@ state fn parse_prefix_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n \n         case (token.NOT) {\n+            p.bump();\n             auto e = parse_prefix_expr(p);\n             ret @ast.expr_unary(ast.not, e);\n         }\n \n         case (token.TILDE) {\n+            p.bump();\n             auto e = parse_prefix_expr(p);\n             ret @ast.expr_unary(ast.bitnot, e);\n         }\n@@ -263,11 +265,13 @@ state fn parse_prefix_expr(parser p) -> @ast.expr {\n             alt (b) {\n \n                 case (token.MINUS) {\n+                    p.bump();\n                     auto e = parse_prefix_expr(p);\n                     ret @ast.expr_unary(ast.neg, e);\n                 }\n \n                 case (token.STAR) {\n+                    p.bump();\n                     auto e = parse_prefix_expr(p);\n                     ret @ast.expr_unary(ast.deref, e);\n                 }\n@@ -298,19 +302,16 @@ state fn parse_binops(parser p,\n     auto more = true;\n     while (more) {\n         more = false;\n-        auto t = p.peek();\n-        alt (t) {\n-            case (token.BINOP(?op)) {\n-                for (tup(token.binop, ast.binop) pair in ops) {\n+        for (tup(token.binop, ast.binop) pair in ops) {\n+            alt (p.peek()) {\n+                case (token.BINOP(?op)) {\n                     if (pair._0 == op) {\n+                        p.bump();\n                         e = @ast.expr_binary(pair._1, e, sub(p));\n                         more = true;\n-                        t = p.peek();\n                     }\n                 }\n             }\n-            case (_) {\n-            }\n         }\n     }\n     ret e;\n@@ -324,12 +325,11 @@ state fn parse_binary_exprs(parser p,\n     auto more = true;\n     while (more) {\n         more = false;\n-        auto t = p.peek();\n         for (tup(token.token, ast.binop) pair in ops) {\n-            if (pair._0 == t) {\n+            if (pair._0 == p.peek()) {\n+                p.bump();\n                 e = @ast.expr_binary(pair._1, e, sub(p));\n                 more = true;\n-                t = p.peek();\n             }\n         }\n     }"}, {"sha": "f0cb65a208276efc392d9ab4fd7e4133cd972c1f", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=5a4cb3ef36bc0610284c5e67c239363d3757df71", "patch": "@@ -41,6 +41,21 @@ const uint LLVMColdCallConv = 9u;\n const uint LLVMX86StdcallCallConv = 64u;\n const uint LLVMX86FastcallCallConv = 65u;\n \n+// Consts for the LLVM IntPredicate type, pre-cast to uint.\n+// FIXME: as above.\n+\n+const uint LLVMIntEQ = 32;\n+const uint LLVMIntNE = 33;\n+const uint LLVMIntUGT = 34;\n+const uint LLVMIntUGE = 35;\n+const uint LLVMIntULT = 36;\n+const uint LLVMIntULE = 37;\n+const uint LLVMIntSGT = 38;\n+const uint LLVMIntSGE = 39;\n+const uint LLVMIntSLT = 40;\n+const uint LLVMIntSLE = 41;\n+\n+\n native mod llvm = llvm_lib {\n \n     type ModuleRef;\n@@ -626,7 +641,7 @@ native mod llvm = llvm_lib {\n                        TypeRef DestTy, sbuf Name) -> ValueRef;\n \n     /* Comparisons */\n-    fn LLVMBuildICmp(BuilderRef B, IntPredicate Op,\n+    fn LLVMBuildICmp(BuilderRef B, uint Op,\n                      ValueRef LHS, ValueRef RHS,\n                      sbuf Name) -> ValueRef;\n     fn LLVMBuildFCmp(BuilderRef B, RealPredicate Op,\n@@ -981,7 +996,7 @@ obj builder(BuilderRef B) {\n \n \n     /* Comparisons */\n-    fn ICmp(IntPredicate Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+    fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n "}, {"sha": "1fbee72b12f6900d34b1e8b37dc6316e52396c02", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 149, "deletions": 25, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a4cb3ef36bc0610284c5e67c239363d3757df71/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5a4cb3ef36bc0610284c5e67c239363d3757df71", "patch": "@@ -159,6 +159,14 @@ fn C_integral(int i, TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntOfString(t, _str.buf(istr(i)), 10);\n }\n \n+fn C_bool(bool b) -> ValueRef {\n+    if (b) {\n+        ret C_integral(1, T_i8());\n+    } else {\n+        ret C_integral(0, T_i8());\n+    }\n+}\n+\n fn C_int(int i) -> ValueRef {\n     ret C_integral(i, T_int());\n }\n@@ -237,33 +245,148 @@ fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> ValueRef {\n     ret cx.build.Call(llglue, call_args);\n }\n \n+fn trans_lit(@block_ctxt cx, &ast.lit lit) -> ValueRef {\n+    alt (lit) {\n+        case (ast.lit_int(?i)) {\n+            ret C_int(i);\n+        }\n+        case (ast.lit_uint(?u)) {\n+            ret C_int(u as int);\n+        }\n+        case (ast.lit_char(?c)) {\n+            ret C_integral(c as int, T_i32());\n+        }\n+        case (ast.lit_bool(?b)) {\n+            ret C_bool(b);\n+        }\n+        case (ast.lit_str(?s)) {\n+            auto len = (_str.byte_len(s) as int) + 1;\n+            ret trans_upcall(cx, \"upcall_new_str\",\n+                             vec(p2i(C_str(cx.fcx.tcx, s)),\n+                                 C_int(len)));\n+        }\n+    }\n+}\n+\n+fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> ValueRef {\n+    alt (op) {\n+        case (ast.bitnot) {\n+            ret cx.build.Not(trans_expr(cx, e));\n+        }\n+        case (ast.not) {\n+            ret cx.build.And(C_bool(true),\n+                             cx.build.Not(trans_expr(cx, e)));\n+        }\n+        case (ast.neg) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.Neg(trans_expr(cx, e));\n+        }\n+\n+    }\n+    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_unary\");\n+    fail;\n+}\n+\n+fn trans_binary(@block_ctxt cx, ast.binop op,\n+                &ast.expr a, &ast.expr b) -> ValueRef {\n+    alt (op) {\n+        case (ast.add) {\n+            ret cx.build.Add(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.sub) {\n+            ret cx.build.Sub(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.mul) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.Mul(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.div) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.SDiv(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.rem) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.SRem(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.bitor) {\n+            ret cx.build.Or(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.bitand) {\n+            ret cx.build.And(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.bitxor) {\n+            ret cx.build.Xor(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.lsl) {\n+            ret cx.build.Shl(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.lsr) {\n+            ret cx.build.LShr(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.asr) {\n+            ret cx.build.AShr(trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.eq) {\n+            ret cx.build.ICmp(lib.llvm.LLVMIntEQ,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.ne) {\n+            ret cx.build.ICmp(lib.llvm.LLVMIntNE,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.lt) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.ICmp(lib.llvm.LLVMIntSLT,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.le) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.ICmp(lib.llvm.LLVMIntSLE,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.ge) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.ICmp(lib.llvm.LLVMIntSGE,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+\n+        case (ast.gt) {\n+            // FIXME: switch by signedness.\n+            ret cx.build.ICmp(lib.llvm.LLVMIntSGT,\n+                              trans_expr(cx, a), trans_expr(cx, b));\n+        }\n+    }\n+    cx.fcx.tcx.sess.unimpl(\"expr variant in trans_binary\");\n+    fail;\n+}\n+\n fn trans_expr(@block_ctxt cx, &ast.expr e) -> ValueRef {\n     alt (e) {\n         case (ast.expr_lit(?lit)) {\n-            alt (*lit) {\n-                case (ast.lit_int(?i)) {\n-                    ret C_int(i);\n-                }\n-                case (ast.lit_uint(?u)) {\n-                    ret C_int(u as int);\n-                }\n-                case (ast.lit_char(?c)) {\n-                    ret C_integral(c as int, T_i32());\n-                }\n-                case (ast.lit_bool(?b)) {\n-                    if (b) {\n-                        ret C_integral(1, T_i8());\n-                    } else {\n-                        ret C_integral(0, T_i8());\n-                    }\n-                }\n-                case (ast.lit_str(?s)) {\n-                    auto len = (_str.byte_len(s) as int) + 1;\n-                    ret trans_upcall(cx, \"upcall_new_str\",\n-                                     vec(p2i(C_str(cx.fcx.tcx, s)),\n-                                         C_int(len)));\n-                }\n-            }\n+            ret trans_lit(cx, *lit);\n+        }\n+\n+        case (ast.expr_unary(?op, ?x)) {\n+            ret trans_unary(cx, op, *x);\n+        }\n+\n+        case (ast.expr_binary(?op, ?x, ?y)) {\n+            ret trans_binary(cx, op, *x, *y);\n         }\n     }\n     cx.fcx.tcx.sess.unimpl(\"expr variant in trans_expr\");\n@@ -285,7 +408,8 @@ fn trans_log(@block_ctxt cx, &ast.expr e) {\n             }\n         }\n         case (_) {\n-            cx.fcx.tcx.sess.unimpl(\"expr variant in trans_log\");\n+            auto v = trans_expr(cx, e);\n+            trans_upcall(cx, \"upcall_log_int\", vec(v));\n         }\n     }\n }"}]}