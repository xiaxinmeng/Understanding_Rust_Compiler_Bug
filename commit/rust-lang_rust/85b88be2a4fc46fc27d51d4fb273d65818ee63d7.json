{"sha": "85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "node_id": "C_kwDOAAsO6NoAKDg1Yjg4YmUyYTRmYzQ2ZmMyN2Q1MWQ0ZmIyNzNkNjU4MThlZTYzZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T10:42:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-02T10:42:12Z"}, "message": "Auto merge of #8605 - Jarcho:remove-deps, r=xFrednet\n\nRemove deps\n\nThis remove both `regex` and `cargo_metadata` as dependencies making `clippy_dev` compile ~3x faster (~46s -> ~16s locally). `cargo_metadata` was used to extract the `version` field from `Cargo.toml`, which is done trivially without that. `regex` was used to parse `define_clippy_lint` in `update_lints` which is now done using `rustc_lexer`. This isn't any simpler, but it compiles ~15s faster and runs ~3x faster (~2.1s -> ~0.7s locally).\n\nThe next biggest offenders to compile times are `clap` and `winapi` on windows. `clap` could be removed, but re-implementing enough is probably more work than it's worth. `winapi` is used by `opener` and `walkdir` so it's stuck there.\n\nchangelog: none", "tree": {"sha": "e3f28fc56bb67200f7904895f8839ef218cf0765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3f28fc56bb67200f7904895f8839ef218cf0765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "html_url": "https://github.com/rust-lang/rust/commit/85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baaddf2b84008c6128b928472660bafa56e41b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/baaddf2b84008c6128b928472660bafa56e41b37", "html_url": "https://github.com/rust-lang/rust/commit/baaddf2b84008c6128b928472660bafa56e41b37"}, {"sha": "ae5af0cd1a3f59cc3537ade7dfba06989969b918", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5af0cd1a3f59cc3537ade7dfba06989969b918", "html_url": "https://github.com/rust-lang/rust/commit/ae5af0cd1a3f59cc3537ade7dfba06989969b918"}], "stats": {"total": 725, "additions": 313, "deletions": 412}, "files": [{"sha": "bc7833f85816f22ed2ed0cbc4aa84d5450fcca2e", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -21,13 +21,12 @@ name = \"clippy-driver\"\n path = \"src/driver.rs\"\n \n [dependencies]\n-clippy_lints = { version = \"0.1\", path = \"clippy_lints\" }\n+clippy_lints = { path = \"clippy_lints\" }\n semver = \"1.0\"\n-rustc_tools_util = { version = \"0.2\", path = \"rustc_tools_util\" }\n+rustc_tools_util = { path = \"rustc_tools_util\" }\n tempfile = { version = \"3.2\", optional = true }\n \n [dev-dependencies]\n-cargo_metadata = \"0.14\"\n compiletest_rs = { version = \"0.7.1\", features = [\"tmp\"] }\n tester = \"0.9\"\n regex = \"1.5\""}, {"sha": "1f2d8adecee74c39840e2e4f144259e211e8e03b", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -4,15 +4,16 @@ version = \"0.0.1\"\n edition = \"2021\"\n \n [dependencies]\n-bytecount = \"0.6\"\n clap = \"2.33\"\n indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\"\n-regex = \"1.5\"\n shell-escape = \"0.1\"\n walkdir = \"2.3\"\n-cargo_metadata = \"0.14\"\n \n [features]\n deny-warnings = []\n+\n+[package.metadata.rust-analyzer]\n+# This package uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "414b403827d9e3b394990aa46d9b642c0e328840", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -1,8 +1,12 @@\n+#![feature(let_else)]\n #![feature(once_cell)]\n+#![feature(rustc_private)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n \n+extern crate rustc_lexer;\n+\n use std::path::PathBuf;\n \n pub mod bless;"}, {"sha": "7a3fd1317619e39d3021f8dafe8e0281dc4a99a1", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -133,15 +133,23 @@ fn to_camel_case(name: &str) -> String {\n }\n \n fn get_stabilisation_version() -> String {\n-    let mut command = cargo_metadata::MetadataCommand::new();\n-    command.no_deps();\n-    if let Ok(metadata) = command.exec() {\n-        if let Some(pkg) = metadata.packages.iter().find(|pkg| pkg.name == \"clippy\") {\n-            return format!(\"{}.{}.0\", pkg.version.minor, pkg.version.patch);\n-        }\n+    fn parse_manifest(contents: &str) -> Option<String> {\n+        let version = contents\n+            .lines()\n+            .filter_map(|l| l.split_once('='))\n+            .find_map(|(k, v)| (k.trim() == \"version\").then(|| v.trim()))?;\n+        let Some((\"0\", version)) = version.get(1..version.len() - 1)?.split_once('.') else {\n+            return None;\n+        };\n+        let (minor, patch) = version.split_once('.')?;\n+        Some(format!(\n+            \"{}.{}.0\",\n+            minor.parse::<u32>().ok()?,\n+            patch.parse::<u32>().ok()?\n+        ))\n     }\n-\n-    String::from(\"<TODO set version(see doc/adding_lints.md)>\")\n+    let contents = fs::read_to_string(\"Cargo.toml\").expect(\"Unable to read `Cargo.toml`\");\n+    parse_manifest(&contents).expect(\"Unable to find package version in `Cargo.toml`\")\n }\n \n fn get_test_file_contents(lint_name: &str, header_commands: Option<&str>) -> String {"}, {"sha": "4e48b670457e8a436875bd195c9fc0fbdbe8d96b", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 271, "deletions": 380, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -1,9 +1,9 @@\n+use core::fmt::Write;\n use itertools::Itertools;\n-use regex::Regex;\n+use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use std::collections::HashMap;\n use std::ffi::OsStr;\n use std::fs;\n-use std::lazy::SyncLazy;\n use std::path::Path;\n use walkdir::WalkDir;\n \n@@ -13,35 +13,7 @@ const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev u\n      // Use that command to update this file and do not edit by hand.\\n\\\n      // Manual edits will be overwritten.\\n\\n\";\n \n-static DEC_CLIPPY_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_clippy_lint!\\s*[\\{(]\n-    (?:\\s+///.*)*\n-    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    (?P<cat>[a-z_]+)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-\n-static DEC_DEPRECATED_LINT_RE: SyncLazy<Regex> = SyncLazy::new(|| {\n-    Regex::new(\n-        r#\"(?x)\n-    declare_deprecated_lint!\\s*[{(]\\s*\n-    (?:\\s+///.*)*\n-    (?:\\s*\\#\\[clippy::version\\s*=\\s*\"[^\"]*\"\\])?\n-    \\s+pub\\s+(?P<name>[A-Z_][A-Z_0-9]*)\\s*,\\s*\n-    \"(?P<desc>(?:[^\"\\\\]+|\\\\(?s).(?-s))*)\"\\s*[})]\n-\"#,\n-    )\n-    .unwrap()\n-});\n-static NL_ESCAPE_RE: SyncLazy<Regex> = SyncLazy::new(|| Regex::new(r#\"\\\\\\n\\s*\"#).unwrap());\n-\n-static DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n+const DOCS_LINK: &str = \"https://rust-lang.github.io/rust-clippy/master/index.html\";\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum UpdateMode {\n@@ -60,60 +32,52 @@ pub enum UpdateMode {\n /// Panics if a file path could not read from or then written to\n #[allow(clippy::too_many_lines)]\n pub fn run(update_mode: UpdateMode) {\n-    let lint_list: Vec<Lint> = gather_all().collect();\n+    let (lints, deprecated_lints) = gather_all();\n \n-    let internal_lints = Lint::internal_lints(&lint_list);\n-    let deprecated_lints = Lint::deprecated_lints(&lint_list);\n-    let usable_lints = Lint::usable_lints(&lint_list);\n+    let internal_lints = Lint::internal_lints(&lints);\n+    let usable_lints = Lint::usable_lints(&lints);\n     let mut sorted_usable_lints = usable_lints.clone();\n     sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n \n-    let usable_lint_count = round_to_fifty(usable_lints.len());\n-\n-    let mut file_change = false;\n-\n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"README.md\"),\n-        &format!(\n-            r#\"\\[There are over \\d+ lints included in this crate!\\]\\({}\\)\"#,\n-            DOCS_LINK\n-        ),\n-        \"\",\n-        true,\n-        update_mode == UpdateMode::Change,\n-        || {\n-            vec![format!(\n-                \"[There are over {} lints included in this crate!]({})\",\n-                usable_lint_count, DOCS_LINK\n-            )]\n+        \"[There are over \",\n+        \" lints included in this crate!]\",\n+        |res| {\n+            write!(res, \"{}\", round_to_fifty(usable_lints.len())).unwrap();\n         },\n-    )\n-    .changed;\n+    );\n \n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"CHANGELOG.md\"),\n-        \"<!-- begin autogenerated links to lint list -->\",\n+        \"<!-- begin autogenerated links to lint list -->\\n\",\n         \"<!-- end autogenerated links to lint list -->\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || gen_changelog_lint_list(usable_lints.iter().chain(deprecated_lints.iter())),\n-    )\n-    .changed;\n+        |res| {\n+            for lint in usable_lints\n+                .iter()\n+                .map(|l| &l.name)\n+                .chain(deprecated_lints.iter().map(|l| &l.name))\n+                .sorted()\n+            {\n+                writeln!(res, \"[`{}`]: {}#{}\", lint, DOCS_LINK, lint).unwrap();\n+            }\n+        },\n+    );\n \n     // This has to be in lib.rs, otherwise rustfmt doesn't work\n-    file_change |= replace_region_in_file(\n+    replace_region_in_file(\n+        update_mode,\n         Path::new(\"clippy_lints/src/lib.rs\"),\n-        \"begin lints modules\",\n-        \"end lints modules\",\n-        false,\n-        update_mode == UpdateMode::Change,\n-        || gen_modules_list(usable_lints.iter()),\n-    )\n-    .changed;\n-\n-    if file_change && update_mode == UpdateMode::Check {\n-        exit_with_failure();\n-    }\n+        \"// begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\\n\",\n+        \"// end lints modules, do not remove this comment, it\u2019s used in `update_lints`\",\n+        |res| {\n+            for lint_mod in usable_lints.iter().map(|l| &l.module).unique().sorted() {\n+                writeln!(res, \"mod {};\", lint_mod).unwrap();\n+            }\n+        },\n+    );\n \n     process_file(\n         \"clippy_lints/src/lib.register_lints.rs\",\n@@ -123,7 +87,7 @@ pub fn run(update_mode: UpdateMode) {\n     process_file(\n         \"clippy_lints/src/lib.deprecated.rs\",\n         update_mode,\n-        &gen_deprecated(deprecated_lints.iter()),\n+        &gen_deprecated(&deprecated_lints),\n     );\n \n     let all_group_lints = usable_lints.iter().filter(|l| {\n@@ -146,15 +110,12 @@ pub fn run(update_mode: UpdateMode) {\n }\n \n pub fn print_lints() {\n-    let lint_list: Vec<Lint> = gather_all().collect();\n+    let (lint_list, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n     let usable_lint_count = usable_lints.len();\n     let grouped_by_lint_group = Lint::by_lint_group(usable_lints.into_iter());\n \n     for (lint_group, mut lints) in grouped_by_lint_group {\n-        if lint_group == \"Deprecated\" {\n-            continue;\n-        }\n         println!(\"\\n## {}\", lint_group);\n \n         lints.sort_by_key(|l| l.name.clone());\n@@ -198,19 +159,17 @@ struct Lint {\n     name: String,\n     group: String,\n     desc: String,\n-    deprecation: Option<String>,\n     module: String,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, deprecation: Option<&str>, module: &str) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str) -> Self {\n         Self {\n             name: name.to_lowercase(),\n-            group: group.to_string(),\n-            desc: NL_ESCAPE_RE.replace(&desc.replace(\"\\\\\\\"\", \"\\\"\"), \"\").to_string(),\n-            deprecation: deprecation.map(ToString::to_string),\n-            module: module.to_string(),\n+            group: group.into(),\n+            desc: remove_line_splices(desc),\n+            module: module.into(),\n         }\n     }\n \n@@ -219,7 +178,7 @@ impl Lint {\n     fn usable_lints(lints: &[Self]) -> Vec<Self> {\n         lints\n             .iter()\n-            .filter(|l| l.deprecation.is_none() && !l.group.starts_with(\"internal\"))\n+            .filter(|l| !l.group.starts_with(\"internal\"))\n             .cloned()\n             .collect()\n     }\n@@ -230,19 +189,27 @@ impl Lint {\n         lints.iter().filter(|l| l.group == \"internal\").cloned().collect()\n     }\n \n-    /// Returns all deprecated lints\n-    #[must_use]\n-    fn deprecated_lints(lints: &[Self]) -> Vec<Self> {\n-        lints.iter().filter(|l| l.deprecation.is_some()).cloned().collect()\n-    }\n-\n     /// Returns the lints in a `HashMap`, grouped by the different lint groups\n     #[must_use]\n     fn by_lint_group(lints: impl Iterator<Item = Self>) -> HashMap<String, Vec<Self>> {\n         lints.map(|lint| (lint.group.to_string(), lint)).into_group_map()\n     }\n }\n \n+#[derive(Clone, PartialEq, Debug)]\n+struct DeprecatedLint {\n+    name: String,\n+    reason: String,\n+}\n+impl DeprecatedLint {\n+    fn new(name: &str, reason: &str) -> Self {\n+        Self {\n+            name: name.to_lowercase(),\n+            reason: remove_line_splices(reason),\n+        }\n+    }\n+}\n+\n /// Generates the code for registering a group\n fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n     let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n@@ -262,41 +229,20 @@ fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lin\n     output\n }\n \n-/// Generates the module declarations for `lints`\n-#[must_use]\n-fn gen_modules_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    lints\n-        .map(|l| &l.module)\n-        .unique()\n-        .map(|module| format!(\"mod {};\", module))\n-        .sorted()\n-        .collect::<Vec<String>>()\n-}\n-\n-/// Generates the list of lint links at the bottom of the CHANGELOG\n-#[must_use]\n-fn gen_changelog_lint_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n-    lints\n-        .sorted_by_key(|l| &l.name)\n-        .map(|l| format!(\"[`{}`]: {}#{}\", l.name, DOCS_LINK, l.name))\n-        .collect()\n-}\n-\n /// Generates the `register_removed` code\n #[must_use]\n-fn gen_deprecated<'a>(lints: impl Iterator<Item = &'a Lint>) -> String {\n+fn gen_deprecated(lints: &[DeprecatedLint]) -> String {\n     let mut output = GENERATED_FILE_COMMENT.to_string();\n     output.push_str(\"{\\n\");\n-    for Lint { name, deprecation, .. } in lints {\n+    for lint in lints {\n         output.push_str(&format!(\n             concat!(\n                 \"    store.register_removed(\\n\",\n                 \"        \\\"clippy::{}\\\",\\n\",\n                 \"        \\\"{}\\\",\\n\",\n                 \"    );\\n\"\n             ),\n-            name,\n-            deprecation.as_ref().expect(\"`lints` are deprecated\")\n+            lint.name, lint.reason,\n         ));\n     }\n     output.push_str(\"}\\n\");\n@@ -330,61 +276,133 @@ fn gen_register_lint_list<'a>(\n     output\n }\n \n-/// Gathers all files in `src/clippy_lints` and gathers all lints inside\n-fn gather_all() -> impl Iterator<Item = Lint> {\n-    lint_files().flat_map(|f| gather_from_file(&f))\n-}\n+/// Gathers all lints defined in `clippy_lints/src`\n+fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>) {\n+    let mut lints = Vec::with_capacity(1000);\n+    let mut deprecated_lints = Vec::with_capacity(50);\n+    let root_path = clippy_project_root().join(\"clippy_lints/src\");\n \n-fn gather_from_file(dir_entry: &walkdir::DirEntry) -> impl Iterator<Item = Lint> {\n-    let content = fs::read_to_string(dir_entry.path()).unwrap();\n-    let path = dir_entry.path();\n-    let filename = path.file_stem().unwrap();\n-    let path_buf = path.with_file_name(filename);\n-    let mut rel_path = path_buf\n-        .strip_prefix(clippy_project_root().join(\"clippy_lints/src\"))\n-        .expect(\"only files in `clippy_lints/src` should be looked at\");\n-    // If the lints are stored in mod.rs, we get the module name from\n-    // the containing directory:\n-    if filename == \"mod\" {\n-        rel_path = rel_path.parent().unwrap();\n-    }\n+    for (rel_path, file) in WalkDir::new(&root_path)\n+        .into_iter()\n+        .map(Result::unwrap)\n+        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+        .map(|f| (f.path().strip_prefix(&root_path).unwrap().to_path_buf(), f))\n+    {\n+        let path = file.path();\n+        let contents =\n+            fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+        let module = rel_path\n+            .components()\n+            .map(|c| c.as_os_str().to_str().unwrap())\n+            .collect::<Vec<_>>()\n+            .join(\"::\");\n+\n+        // If the lints are stored in mod.rs, we get the module name from\n+        // the containing directory:\n+        let module = if let Some(module) = module.strip_suffix(\"::mod.rs\") {\n+            module\n+        } else {\n+            module.strip_suffix(\".rs\").unwrap_or(&module)\n+        };\n \n-    let module = rel_path\n-        .components()\n-        .map(|c| c.as_os_str().to_str().unwrap())\n-        .collect::<Vec<_>>()\n-        .join(\"::\");\n+        if module == \"deprecated_lints\" {\n+            parse_deprecated_contents(&contents, &mut deprecated_lints);\n+        } else {\n+            parse_contents(&contents, module, &mut lints);\n+        }\n+    }\n+    (lints, deprecated_lints)\n+}\n \n-    parse_contents(&content, &module)\n+macro_rules! match_tokens {\n+    ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n+         {\n+            $($(let $capture =)? if let Some((TokenKind::$token $({$($fields)*})?, _x)) = $iter.next() {\n+                _x\n+            } else {\n+                continue;\n+            };)*\n+            #[allow(clippy::unused_unit)]\n+            { ($($($capture,)?)*) }\n+        }\n+    }\n }\n \n-fn parse_contents(content: &str, module: &str) -> impl Iterator<Item = Lint> {\n-    let lints = DEC_CLIPPY_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], &m[\"cat\"], &m[\"desc\"], None, module));\n-    let deprecated = DEC_DEPRECATED_LINT_RE\n-        .captures_iter(content)\n-        .map(|m| Lint::new(&m[\"name\"], \"Deprecated\", &m[\"desc\"], Some(&m[\"desc\"]), module));\n-    // Removing the `.collect::<Vec<Lint>>().into_iter()` causes some lifetime issues due to the map\n-    lints.chain(deprecated).collect::<Vec<Lint>>().into_iter()\n+/// Parse a source file looking for `declare_clippy_lint` macro invocations.\n+fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n+    let mut offset = 0usize;\n+    let mut iter = tokenize(contents).map(|t| {\n+        let range = offset..offset + t.len;\n+        offset = range.end;\n+        (t.kind, &contents[range])\n+    });\n+\n+    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_clippy_lint\") {\n+        let mut iter = iter\n+            .by_ref()\n+            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        // matches `!{`\n+        match_tokens!(iter, Bang OpenBrace);\n+        match iter.next() {\n+            // #[clippy::version = \"version\"] pub\n+            Some((TokenKind::Pound, _)) => {\n+                match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n+            },\n+            // pub\n+            Some((TokenKind::Ident, _)) => (),\n+            _ => continue,\n+        }\n+        let (name, group, desc) = match_tokens!(\n+            iter,\n+            // LINT_NAME\n+            Ident(name) Comma\n+            // group,\n+            Ident(group) Comma\n+            // \"description\" }\n+            Literal{kind: LiteralKind::Str{..}, ..}(desc) CloseBrace\n+        );\n+        lints.push(Lint::new(name, group, desc, module));\n+    }\n }\n \n-/// Collects all .rs files in the `clippy_lints/src` directory\n-fn lint_files() -> impl Iterator<Item = walkdir::DirEntry> {\n-    // We use `WalkDir` instead of `fs::read_dir` here in order to recurse into subdirectories.\n-    // Otherwise we would not collect all the lints, for example in `clippy_lints/src/methods/`.\n-    let path = clippy_project_root().join(\"clippy_lints/src\");\n-    WalkDir::new(path)\n-        .into_iter()\n-        .filter_map(Result::ok)\n-        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+/// Parse a source file looking for `declare_deprecated_lint` macro invocations.\n+fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n+    let mut offset = 0usize;\n+    let mut iter = tokenize(contents).map(|t| {\n+        let range = offset..offset + t.len;\n+        offset = range.end;\n+        (t.kind, &contents[range])\n+    });\n+    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_deprecated_lint\") {\n+        let mut iter = iter\n+            .by_ref()\n+            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+        let (name, reason) = match_tokens!(\n+            iter,\n+            // !{\n+            Bang OpenBrace\n+            // #[clippy::version = \"version\"]\n+            Pound OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket\n+            // pub LINT_NAME,\n+            Ident Ident(name) Comma\n+            // \"description\"\n+            Literal{kind: LiteralKind::Str{..},..}(reason)\n+            // }\n+            CloseBrace\n+        );\n+        lints.push(DeprecatedLint::new(name, reason));\n+    }\n }\n \n-/// Whether a file has had its text changed or not\n-#[derive(PartialEq, Debug)]\n-struct FileChange {\n-    changed: bool,\n-    new_lines: String,\n+/// Removes the line splices and surrounding quotes from a string literal\n+fn remove_line_splices(s: &str) -> String {\n+    let s = s\n+        .strip_prefix('\"')\n+        .and_then(|s| s.strip_suffix('\"'))\n+        .unwrap_or_else(|| panic!(\"expected quoted string, found `{}`\", s));\n+    let mut res = String::with_capacity(s.len());\n+    unescape::unescape_literal(s, unescape::Mode::Str, &mut |range, _| res.push_str(&s[range]));\n+    res\n }\n \n /// Replaces a region in a file delimited by two lines matching regexes.\n@@ -396,200 +414,115 @@ struct FileChange {\n /// # Panics\n ///\n /// Panics if the path could not read or then written\n-fn replace_region_in_file<F>(\n+fn replace_region_in_file(\n+    update_mode: UpdateMode,\n     path: &Path,\n     start: &str,\n     end: &str,\n-    replace_start: bool,\n-    write_back: bool,\n-    replacements: F,\n-) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from {}: {}\", path.display(), e));\n-    let file_change = replace_region_in_text(&contents, start, end, replace_start, replacements);\n-\n-    if write_back {\n-        if let Err(e) = fs::write(path, file_change.new_lines.as_bytes()) {\n-            panic!(\"Cannot write to {}: {}\", path.display(), e);\n-        }\n-    }\n-    file_change\n-}\n-\n-/// Replaces a region in a text delimited by two lines matching regexes.\n-///\n-/// * `text` is the input text on which you want to perform the replacement\n-/// * `start` is a `&str` that describes the delimiter line before the region you want to replace.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * `end` is a `&str` that describes the delimiter line until where the replacement should happen.\n-///   As the `&str` will be converted to a `Regex`, this can contain regex syntax, too.\n-/// * If `replace_start` is true, the `start` delimiter line is replaced as well. The `end`\n-///   delimiter line is never replaced.\n-/// * `replacements` is a closure that has to return a `Vec<String>` which contains the new text.\n-///\n-/// If you want to perform the replacement on files instead of already parsed text,\n-/// use `replace_region_in_file`.\n-///\n-/// # Example\n-///\n-/// ```ignore\n-/// let the_text = \"replace_start\\nsome text\\nthat will be replaced\\nreplace_end\";\n-/// let result =\n-///     replace_region_in_text(the_text, \"replace_start\", \"replace_end\", false, || {\n-///         vec![\"a different\".to_string(), \"text\".to_string()]\n-///     })\n-///     .new_lines;\n-/// assert_eq!(\"replace_start\\na different\\ntext\\nreplace_end\", result);\n-/// ```\n-///\n-/// # Panics\n-///\n-/// Panics if start or end is not valid regex\n-fn replace_region_in_text<F>(text: &str, start: &str, end: &str, replace_start: bool, replacements: F) -> FileChange\n-where\n-    F: FnOnce() -> Vec<String>,\n-{\n-    let replace_it = replacements();\n-    let mut in_old_region = false;\n-    let mut found = false;\n-    let mut new_lines = vec![];\n-    let start = Regex::new(start).unwrap();\n-    let end = Regex::new(end).unwrap();\n-\n-    for line in text.lines() {\n-        if in_old_region {\n-            if end.is_match(line) {\n-                in_old_region = false;\n-                new_lines.extend(replace_it.clone());\n-                new_lines.push(line.to_string());\n-            }\n-        } else if start.is_match(line) {\n-            if !replace_start {\n-                new_lines.push(line.to_string());\n+    write_replacement: impl FnMut(&mut String),\n+) {\n+    let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n+    let new_contents = match replace_region_in_text(&contents, start, end, write_replacement) {\n+        Ok(x) => x,\n+        Err(delim) => panic!(\"Couldn't find `{}` in file `{}`\", delim, path.display()),\n+    };\n+\n+    match update_mode {\n+        UpdateMode::Check if contents != new_contents => exit_with_failure(),\n+        UpdateMode::Check => (),\n+        UpdateMode::Change => {\n+            if let Err(e) = fs::write(path, new_contents.as_bytes()) {\n+                panic!(\"Cannot write to `{}`: {}\", path.display(), e);\n             }\n-            in_old_region = true;\n-            found = true;\n-        } else {\n-            new_lines.push(line.to_string());\n-        }\n-    }\n-\n-    if !found {\n-        // This happens if the provided regex in `clippy_dev/src/main.rs` does not match in the\n-        // given text or file. Most likely this is an error on the programmer's side and the Regex\n-        // is incorrect.\n-        eprintln!(\"error: regex \\n{:?}\\ndoesn't match. You may have to update it.\", start);\n-        std::process::exit(1);\n-    }\n-\n-    let mut new_lines = new_lines.join(\"\\n\");\n-    if text.ends_with('\\n') {\n-        new_lines.push('\\n');\n+        },\n     }\n-    let changed = new_lines != text;\n-    FileChange { changed, new_lines }\n-}\n-\n-#[test]\n-fn test_parse_contents() {\n-    let result: Vec<Lint> = parse_contents(\n-        r#\"\n-declare_clippy_lint! {\n-    #[clippy::version = \"Hello Clippy!\"]\n-    pub PTR_ARG,\n-    style,\n-    \"really long \\\n-     text\"\n }\n \n-declare_clippy_lint!{\n-    #[clippy::version = \"Test version\"]\n-    pub DOC_MARKDOWN,\n-    pedantic,\n-    \"single line\"\n-}\n-\n-/// some doc comment\n-declare_deprecated_lint! {\n-    #[clippy::version = \"I'm a version\"]\n-    pub SHOULD_ASSERT_EQ,\n-    \"`assert!()` will be more flexible with RFC 2011\"\n-}\n-    \"#,\n-        \"module_name\",\n-    )\n-    .collect();\n-\n-    let expected = vec![\n-        Lint::new(\"ptr_arg\", \"style\", \"really long text\", None, \"module_name\"),\n-        Lint::new(\"doc_markdown\", \"pedantic\", \"single line\", None, \"module_name\"),\n-        Lint::new(\n-            \"should_assert_eq\",\n-            \"Deprecated\",\n-            \"`assert!()` will be more flexible with RFC 2011\",\n-            Some(\"`assert!()` will be more flexible with RFC 2011\"),\n-            \"module_name\",\n-        ),\n-    ];\n-    assert_eq!(expected, result);\n+/// Replaces a region in a text delimited by two strings. Returns the new text if both delimiters\n+/// were found, or the missing delimiter if not.\n+fn replace_region_in_text<'a>(\n+    text: &str,\n+    start: &'a str,\n+    end: &'a str,\n+    mut write_replacement: impl FnMut(&mut String),\n+) -> Result<String, &'a str> {\n+    let (text_start, rest) = text.split_once(start).ok_or(start)?;\n+    let (_, text_end) = rest.split_once(end).ok_or(end)?;\n+\n+    let mut res = String::with_capacity(text.len() + 4096);\n+    res.push_str(text_start);\n+    res.push_str(start);\n+    write_replacement(&mut res);\n+    res.push_str(end);\n+    res.push_str(text_end);\n+\n+    Ok(res)\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_replace_region() {\n-        let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-        let expected = FileChange {\n-            changed: true,\n-            new_lines: \"\\nabc\\nhello world\\ndef\\nghi\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, false, || {\n-            vec![\"hello world\".to_string()]\n-        });\n-        assert_eq!(expected, result);\n-    }\n+    fn test_parse_contents() {\n+        static CONTENTS: &str = r#\"\n+            declare_clippy_lint! {\n+                #[clippy::version = \"Hello Clippy!\"]\n+                pub PTR_ARG,\n+                style,\n+                \"really long \\\n+                text\"\n+            }\n \n-    #[test]\n-    fn test_replace_region_with_start() {\n-        let text = \"\\nabc\\n123\\n789\\ndef\\nghi\";\n-        let expected = FileChange {\n-            changed: true,\n-            new_lines: \"\\nhello world\\ndef\\nghi\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*abc$\"#, r#\"^\\s*def\"#, true, || {\n-            vec![\"hello world\".to_string()]\n-        });\n+            declare_clippy_lint!{\n+                #[clippy::version = \"Test version\"]\n+                pub DOC_MARKDOWN,\n+                pedantic,\n+                \"single line\"\n+            }\n+        \"#;\n+        let mut result = Vec::new();\n+        parse_contents(CONTENTS, \"module_name\", &mut result);\n+\n+        let expected = vec![\n+            Lint::new(\"ptr_arg\", \"style\", \"\\\"really long text\\\"\", \"module_name\"),\n+            Lint::new(\"doc_markdown\", \"pedantic\", \"\\\"single line\\\"\", \"module_name\"),\n+        ];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n-    fn test_replace_region_no_changes() {\n-        let text = \"123\\n456\\n789\";\n-        let expected = FileChange {\n-            changed: false,\n-            new_lines: \"123\\n456\\n789\".to_string(),\n-        };\n-        let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, Vec::new);\n+    fn test_parse_deprecated_contents() {\n+        static DEPRECATED_CONTENTS: &str = r#\"\n+            /// some doc comment\n+            declare_deprecated_lint! {\n+                #[clippy::version = \"I'm a version\"]\n+                pub SHOULD_ASSERT_EQ,\n+                \"`assert!()` will be more flexible with RFC 2011\"\n+            }\n+        \"#;\n+\n+        let mut result = Vec::new();\n+        parse_deprecated_contents(DEPRECATED_CONTENTS, &mut result);\n+\n+        let expected = vec![DeprecatedLint::new(\n+            \"should_assert_eq\",\n+            \"\\\"`assert!()` will be more flexible with RFC 2011\\\"\",\n+        )];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n     fn test_usable_lints() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"Deprecated\", \"abc\", Some(\"Reason\"), \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal_style\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"internal\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let expected = vec![Lint::new(\n             \"should_assert_eq2\",\n             \"Not Deprecated\",\n-            \"abc\",\n-            None,\n+            \"\\\"abc\\\"\",\n             \"module_name\",\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n@@ -598,55 +531,30 @@ mod tests {\n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-                Lint::new(\"incorrect_match\", \"group1\", \"abc\", None, \"module_name\"),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n             ],\n         );\n         expected.insert(\n             \"group2\".to_string(),\n-            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")],\n+            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\")],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n     }\n \n-    #[test]\n-    fn test_gen_changelog_lint_list() {\n-        let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\"),\n-        ];\n-        let expected = vec![\n-            format!(\"[`should_assert_eq`]: {}#should_assert_eq\", DOCS_LINK),\n-            format!(\"[`should_assert_eq2`]: {}#should_assert_eq2\", DOCS_LINK),\n-        ];\n-        assert_eq!(expected, gen_changelog_lint_list(lints.iter()));\n-    }\n-\n     #[test]\n     fn test_gen_deprecated() {\n         let lints = vec![\n-            Lint::new(\n-                \"should_assert_eq\",\n-                \"group1\",\n-                \"abc\",\n-                Some(\"has been superseded by should_assert_eq2\"),\n-                \"module_name\",\n-            ),\n-            Lint::new(\n-                \"another_deprecated\",\n-                \"group2\",\n-                \"abc\",\n-                Some(\"will be removed\"),\n-                \"module_name\",\n-            ),\n+            DeprecatedLint::new(\"should_assert_eq\", \"\\\"has been superseded by should_assert_eq2\\\"\"),\n+            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\"),\n         ];\n \n         let expected = GENERATED_FILE_COMMENT.to_string()\n@@ -665,32 +573,15 @@ mod tests {\n             .join(\"\\n\")\n             + \"\\n\";\n \n-        assert_eq!(expected, gen_deprecated(lints.iter()));\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_gen_deprecated_fail() {\n-        let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n-        let _deprecated_lints = gen_deprecated(lints.iter());\n-    }\n-\n-    #[test]\n-    fn test_gen_modules_list() {\n-        let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"incorrect_stuff\", \"group3\", \"abc\", None, \"another_module\"),\n-        ];\n-        let expected = vec![\"mod another_module;\".to_string(), \"mod module_name;\".to_string()];\n-        assert_eq!(expected, gen_modules_list(lints.iter()));\n+        assert_eq!(expected, gen_deprecated(&lints));\n     }\n \n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"abc\", None, \"module_name\"),\n-            Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n+            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "38498ebdcf2c1ed49f0f22ee3a2be6a2c29d078e", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b88be2a4fc46fc27d51d4fb273d65818ee63d7/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=85b88be2a4fc46fc27d51d4fb273d65818ee63d7", "patch": "@@ -3,34 +3,32 @@\n #![allow(clippy::single_match_else)]\n \n use rustc_tools_util::VersionInfo;\n+use std::fs;\n \n #[test]\n fn check_that_clippy_lints_and_clippy_utils_have_the_same_version_as_clippy() {\n+    fn read_version(path: &str) -> String {\n+        let contents = fs::read_to_string(path).unwrap_or_else(|e| panic!(\"error reading `{}`: {:?}\", path, e));\n+        contents\n+            .lines()\n+            .filter_map(|l| l.split_once('='))\n+            .find_map(|(k, v)| (k.trim() == \"version\").then(|| v.trim()))\n+            .unwrap_or_else(|| panic!(\"error finding version in `{}`\", path))\n+            .to_string()\n+    }\n+\n     // do not run this test inside the upstream rustc repo:\n     // https://github.com/rust-lang/rust-clippy/issues/6683\n     if option_env!(\"RUSTC_TEST_SUITE\").is_some() {\n         return;\n     }\n \n-    let clippy_meta = cargo_metadata::MetadataCommand::new()\n-        .no_deps()\n-        .exec()\n-        .expect(\"could not obtain cargo metadata\");\n+    let clippy_version = read_version(\"Cargo.toml\");\n+    let clippy_lints_version = read_version(\"clippy_lints/Cargo.toml\");\n+    let clippy_utils_version = read_version(\"clippy_utils/Cargo.toml\");\n \n-    for krate in &[\"clippy_lints\", \"clippy_utils\"] {\n-        let krate_meta = cargo_metadata::MetadataCommand::new()\n-            .current_dir(std::env::current_dir().unwrap().join(krate))\n-            .no_deps()\n-            .exec()\n-            .expect(\"could not obtain cargo metadata\");\n-        assert_eq!(krate_meta.packages[0].version, clippy_meta.packages[0].version);\n-        for package in &clippy_meta.packages[0].dependencies {\n-            if package.name == *krate {\n-                assert!(package.req.matches(&krate_meta.packages[0].version));\n-                break;\n-            }\n-        }\n-    }\n+    assert_eq!(clippy_version, clippy_lints_version);\n+    assert_eq!(clippy_version, clippy_utils_version);\n }\n \n #[test]"}]}