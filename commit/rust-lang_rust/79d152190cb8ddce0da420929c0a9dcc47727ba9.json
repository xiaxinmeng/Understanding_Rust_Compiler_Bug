{"sha": "79d152190cb8ddce0da420929c0a9dcc47727ba9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDE1MjE5MGNiOGRkY2UwZGE0MjA5MjljMGE5ZGNjNDc3MjdiYTk=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2020-04-08T13:50:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-08T13:50:28Z"}, "message": "Rollup merge of #5425 - xiongmao86:issue5367, r=flip1995\n\nEhance opt_as_ref_deref lint.\n\n- [x] Added passing UI tests (including committed `.stderr` file)\n- [x] `cargo test` passes locally\n- [x] Run `cargo dev fmt`\n\nLint on opt.as_ref().map(|x| &**x). Fixes #5367.\n\nchangelog: lint on opt.as_ref().map(|x| &**x)", "tree": {"sha": "3dffc63011b996f0df32fb4543026ed11948f01c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dffc63011b996f0df32fb4543026ed11948f01c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d152190cb8ddce0da420929c0a9dcc47727ba9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejdakCRBK7hj4Ov3rIwAAdHIIAASdxz07I0wTcIaHUESCxfRa\n3GGp09hXNvUXDDWAV3/7zeAOck6a0cLDEOcPdfcsX9kMqjjAXjyk8dd+UeXa6gcs\nTHsfvYMeHX1BmaVvCa4a1VaF3TjFsc1UPsRJ8Ml11kmYAjoIfiywehUSq62RsxLI\n0TUSxK9GhG71iCEeaEbMl5lLUIXip5qAitwBgu8VTgUA/jeG0LTT3lSK6IoJWp0e\nxrCxHQGb/AdrEblB/OS823oWYPloo9wLWoVxXZvLoK/zTQ8I8C4+2C4t62yAKwOG\np/SL3u/tLspRM99sTOUfHWkCuF4j4AbpLkbjLbXi17Eiamksngfza72cHV0wbsQ=\n=1WKX\n-----END PGP SIGNATURE-----\n", "payload": "tree 3dffc63011b996f0df32fb4543026ed11948f01c\nparent 8fc592a8e7d214c3c8fb4e6e7711da6992e326f6\nparent d7056f8ffba7ad87622b7fdcc429f33abc5c62a7\nauthor Philipp Krones <hello@philkrones.com> 1586353828 +0200\ncommitter GitHub <noreply@github.com> 1586353828 +0200\n\nRollup merge of #5425 - xiongmao86:issue5367, r=flip1995\n\nEhance opt_as_ref_deref lint.\n\n- [x] Added passing UI tests (including committed `.stderr` file)\n- [x] `cargo test` passes locally\n- [x] Run `cargo dev fmt`\n\nLint on opt.as_ref().map(|x| &**x). Fixes #5367.\n\nchangelog: lint on opt.as_ref().map(|x| &**x)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d152190cb8ddce0da420929c0a9dcc47727ba9", "html_url": "https://github.com/rust-lang/rust/commit/79d152190cb8ddce0da420929c0a9dcc47727ba9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d152190cb8ddce0da420929c0a9dcc47727ba9/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc592a8e7d214c3c8fb4e6e7711da6992e326f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc592a8e7d214c3c8fb4e6e7711da6992e326f6", "html_url": "https://github.com/rust-lang/rust/commit/8fc592a8e7d214c3c8fb4e6e7711da6992e326f6"}, {"sha": "d7056f8ffba7ad87622b7fdcc429f33abc5c62a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7056f8ffba7ad87622b7fdcc429f33abc5c62a7", "html_url": "https://github.com/rust-lang/rust/commit/d7056f8ffba7ad87622b7fdcc429f33abc5c62a7"}], "stats": {"total": 109, "additions": 73, "deletions": 36}, "files": [{"sha": "8e1501956dd068800aea44c54c6a0140639bd1ed", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79d152190cb8ddce0da420929c0a9dcc47727ba9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d152190cb8ddce0da420929c0a9dcc47727ba9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=79d152190cb8ddce0da420929c0a9dcc47727ba9", "patch": "@@ -654,15 +654,15 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr.as_ref().map(|p| &**p));\n+    let expr = once(block.expr.as_deref());\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n         StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n-        StmtKind::Local(ref local) => local.init.as_ref().map(|p| &**p),\n+        StmtKind::Local(ref local) => local.init.as_deref(),\n         _ => None,\n     }\n }"}, {"sha": "3b2f96e4d09fc6acb6663fc1070b9c56e612129a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/79d152190cb8ddce0da420929c0a9dcc47727ba9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d152190cb8ddce0da420929c0a9dcc47727ba9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=79d152190cb8ddce0da420929c0a9dcc47727ba9", "patch": "@@ -3233,6 +3233,8 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n     map_args: &[hir::Expr<'_>],\n     is_mut: bool,\n ) {\n+    let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n+\n     let option_ty = cx.tables.expr_ty(&as_ref_args[0]);\n     if !match_type(cx, option_ty, &paths::OPTION) {\n         return;\n@@ -3255,39 +3257,56 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n         hir::ExprKind::Closure(_, _, body_id, _, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n-            if_chain! {\n-                if let hir::ExprKind::MethodCall(_, _, args) = &closure_expr.kind;\n-                if args.len() == 1;\n-                if let hir::ExprKind::Path(qpath) = &args[0].kind;\n-                if let hir::def::Res::Local(local_id) = cx.tables.qpath_res(qpath, args[0].hir_id);\n-                if closure_body.params[0].pat.hir_id == local_id;\n-                let adj = cx.tables.expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n-                if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n-                then {\n-                    let method_did = cx.tables.type_dependent_def_id(closure_expr.hir_id).unwrap();\n-                    deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n-                } else {\n-                    false\n-                }\n+\n+            match &closure_expr.kind {\n+                hir::ExprKind::MethodCall(_, _, args) => {\n+                    if_chain! {\n+                        if args.len() == 1;\n+                        if let hir::ExprKind::Path(qpath) = &args[0].kind;\n+                        if let hir::def::Res::Local(local_id) = cx.tables.qpath_res(qpath, args[0].hir_id);\n+                        if closure_body.params[0].pat.hir_id == local_id;\n+                        let adj = cx.tables.expr_adjustments(&args[0]).iter().map(|x| &x.kind).collect::<Box<[_]>>();\n+                        if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n+                        then {\n+                            let method_did = cx.tables.type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                    if_chain! {\n+                        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner2) = inner1.kind;\n+                        if let hir::ExprKind::Path(ref qpath) = inner2.kind;\n+                        if let hir::def::Res::Local(local_id) = cx.tables.qpath_res(qpath, inner2.hir_id);\n+                        then {\n+                            closure_body.params[0].pat.hir_id == local_id\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                _ => false,\n             }\n         },\n-\n         _ => false,\n     };\n \n     if is_deref {\n         let current_method = if is_mut {\n-            \".as_mut().map(DerefMut::deref_mut)\"\n+            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n         } else {\n-            \".as_ref().map(Deref::deref)\"\n+            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n         };\n         let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n         let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n         let suggestion = format!(\"try using {} instead\", method_hint);\n \n         let msg = format!(\n-            \"called `{0}` (or with one of deref aliases) on an Option value. \\\n-             This can be done more directly by calling `{1}` instead\",\n+            \"called `{0}` on an Option value. This can be done more directly \\\n+            by calling `{1}` instead\",\n             current_method, hint\n         );\n         span_lint_and_sugg("}, {"sha": "076692e6445175da398e3ae788c803c5b57ba901", "filename": "tests/ui/option_as_ref_deref.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.fixed?ref=79d152190cb8ddce0da420929c0a9dcc47727ba9", "patch": "@@ -35,4 +35,7 @@ fn main() {\n     let _ = Some(1_usize).as_ref().map(|x| vc[*x].as_str()); // should not be linted\n \n     let _: Option<&str> = Some(&String::new()).as_ref().map(|x| x.as_str()); // should not be linted\n+\n+    let _ = opt.as_deref();\n+    let _ = opt.as_deref_mut();\n }"}, {"sha": "3bf5f715f8339525b8ad547d75eea77a96b0c1f2", "filename": "tests/ui/option_as_ref_deref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.rs?ref=79d152190cb8ddce0da420929c0a9dcc47727ba9", "patch": "@@ -38,4 +38,7 @@ fn main() {\n     let _ = Some(1_usize).as_ref().map(|x| vc[*x].as_str()); // should not be linted\n \n     let _: Option<&str> = Some(&String::new()).as_ref().map(|x| x.as_str()); // should not be linted\n+\n+    let _ = opt.as_ref().map(|x| &**x);\n+    let _ = opt.as_mut().map(|x| &mut **x);\n }"}, {"sha": "a106582a633232b4bfcdc95c78308440d2480137", "filename": "tests/ui/option_as_ref_deref.stderr", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/79d152190cb8ddce0da420929c0a9dcc47727ba9/tests%2Fui%2Foption_as_ref_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_as_ref_deref.stderr?ref=79d152190cb8ddce0da420929c0a9dcc47727ba9", "patch": "@@ -1,12 +1,12 @@\n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.clone().as_deref()` instead\n+error: called `.as_ref().map(Deref::deref)` on an Option value. This can be done more directly by calling `opt.clone().as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:13:13\n    |\n LL |     let _ = opt.clone().as_ref().map(Deref::deref).map(str::len);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.clone().as_deref()`\n    |\n    = note: `-D clippy::option-as-ref-deref` implied by `-D warnings`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.clone().as_deref()` instead\n+error: called `.as_ref().map(Deref::deref)` on an Option value. This can be done more directly by calling `opt.clone().as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:16:13\n    |\n LL |       let _ = opt.clone()\n@@ -16,77 +16,89 @@ LL | |             Deref::deref\n LL | |         )\n    | |_________^ help: try using as_deref instead: `opt.clone().as_deref()`\n \n-error: called `.as_mut().map(DerefMut::deref_mut)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n+error: called `.as_mut().map(DerefMut::deref_mut)` on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n   --> $DIR/option_as_ref_deref.rs:22:13\n    |\n LL |     let _ = opt.as_mut().map(DerefMut::deref_mut);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+error: called `.as_ref().map(String::as_str)` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:24:13\n    |\n LL |     let _ = opt.as_ref().map(String::as_str);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+error: called `.as_ref().map(|x| x.as_str())` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:25:13\n    |\n LL |     let _ = opt.as_ref().map(|x| x.as_str());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n \n-error: called `.as_mut().map(DerefMut::deref_mut)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n+error: called `.as_mut().map(String::as_mut_str)` on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n   --> $DIR/option_as_ref_deref.rs:26:13\n    |\n LL |     let _ = opt.as_mut().map(String::as_mut_str);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n \n-error: called `.as_mut().map(DerefMut::deref_mut)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n+error: called `.as_mut().map(|x| x.as_mut_str())` on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n   --> $DIR/option_as_ref_deref.rs:27:13\n    |\n LL |     let _ = opt.as_mut().map(|x| x.as_mut_str());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `Some(CString::new(vec![]).unwrap()).as_deref()` instead\n+error: called `.as_ref().map(CString::as_c_str)` on an Option value. This can be done more directly by calling `Some(CString::new(vec![]).unwrap()).as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:28:13\n    |\n LL |     let _ = Some(CString::new(vec![]).unwrap()).as_ref().map(CString::as_c_str);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `Some(CString::new(vec![]).unwrap()).as_deref()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `Some(OsString::new()).as_deref()` instead\n+error: called `.as_ref().map(OsString::as_os_str)` on an Option value. This can be done more directly by calling `Some(OsString::new()).as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:29:13\n    |\n LL |     let _ = Some(OsString::new()).as_ref().map(OsString::as_os_str);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `Some(OsString::new()).as_deref()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `Some(PathBuf::new()).as_deref()` instead\n+error: called `.as_ref().map(PathBuf::as_path)` on an Option value. This can be done more directly by calling `Some(PathBuf::new()).as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:30:13\n    |\n LL |     let _ = Some(PathBuf::new()).as_ref().map(PathBuf::as_path);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `Some(PathBuf::new()).as_deref()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `Some(Vec::<()>::new()).as_deref()` instead\n+error: called `.as_ref().map(Vec::as_slice)` on an Option value. This can be done more directly by calling `Some(Vec::<()>::new()).as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:31:13\n    |\n LL |     let _ = Some(Vec::<()>::new()).as_ref().map(Vec::as_slice);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `Some(Vec::<()>::new()).as_deref()`\n \n-error: called `.as_mut().map(DerefMut::deref_mut)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `Some(Vec::<()>::new()).as_deref_mut()` instead\n+error: called `.as_mut().map(Vec::as_mut_slice)` on an Option value. This can be done more directly by calling `Some(Vec::<()>::new()).as_deref_mut()` instead\n   --> $DIR/option_as_ref_deref.rs:32:13\n    |\n LL |     let _ = Some(Vec::<()>::new()).as_mut().map(Vec::as_mut_slice);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `Some(Vec::<()>::new()).as_deref_mut()`\n \n-error: called `.as_ref().map(Deref::deref)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+error: called `.as_ref().map(|x| x.deref())` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n   --> $DIR/option_as_ref_deref.rs:34:13\n    |\n LL |     let _ = opt.as_ref().map(|x| x.deref());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n \n-error: called `.as_mut().map(DerefMut::deref_mut)` (or with one of deref aliases) on an Option value. This can be done more directly by calling `opt.clone().as_deref_mut()` instead\n+error: called `.as_mut().map(|x| x.deref_mut())` on an Option value. This can be done more directly by calling `opt.clone().as_deref_mut()` instead\n   --> $DIR/option_as_ref_deref.rs:35:13\n    |\n LL |     let _ = opt.clone().as_mut().map(|x| x.deref_mut()).map(|x| x.len());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.clone().as_deref_mut()`\n \n-error: aborting due to 14 previous errors\n+error: called `.as_ref().map(|x| &**x)` on an Option value. This can be done more directly by calling `opt.as_deref()` instead\n+  --> $DIR/option_as_ref_deref.rs:42:13\n+   |\n+LL |     let _ = opt.as_ref().map(|x| &**x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref instead: `opt.as_deref()`\n+\n+error: called `.as_mut().map(|x| &mut **x)` on an Option value. This can be done more directly by calling `opt.as_deref_mut()` instead\n+  --> $DIR/option_as_ref_deref.rs:43:13\n+   |\n+LL |     let _ = opt.as_mut().map(|x| &mut **x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using as_deref_mut instead: `opt.as_deref_mut()`\n+\n+error: aborting due to 16 previous errors\n "}]}