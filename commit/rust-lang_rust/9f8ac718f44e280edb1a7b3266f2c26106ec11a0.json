{"sha": "9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOGFjNzE4ZjQ0ZTI4MGVkYjFhN2IzMjY2ZjJjMjYxMDZlYzExYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T16:59:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T16:59:50Z"}, "message": "Auto merge of #76575 - lcnr:abstract-const, r=oli-obk\n\ncompare generic constants using `AbstractConst`s\n\nThis is a MVP of rust-lang/compiler-team#340. The changes in this PR should only be relevant if `feature(const_evaluatable_checked)` is enabled.\n\n~~currently based on top of #76559, so blocked on that.~~\n\nr? `@oli-obk` cc `@varkor` `@eddyb`", "tree": {"sha": "df9a6b99ae697a6c3ebb00a25d213ec4c8b56a64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df9a6b99ae697a6c3ebb00a25d213ec4c8b56a64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "html_url": "https://github.com/rust-lang/rust/commit/9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdc3405c20122fd0f077f5a77addabc873f20e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdc3405c20122fd0f077f5a77addabc873f20e4c", "html_url": "https://github.com/rust-lang/rust/commit/fdc3405c20122fd0f077f5a77addabc873f20e4c"}, {"sha": "b7641209d79860172c5bf605d3ebf1377d46db55", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7641209d79860172c5bf605d3ebf1377d46db55", "html_url": "https://github.com/rust-lang/rust/commit/b7641209d79860172c5bf605d3ebf1377d46db55"}], "stats": {"total": 766, "additions": 739, "deletions": 27}, "files": [{"sha": "a2e2cf1ca0219b947a8979ad2947be8363448c3b", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -562,6 +562,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        ty::codec::RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n         ty::codec::RefDecodable::decode(d)\n@@ -1191,6 +1197,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, tcx))\n     }\n \n+    fn get_mir_abstract_const(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        id: DefIndex,\n+    ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+        self.root\n+            .tables\n+            .mir_abstract_consts\n+            .get(self, id)\n+            .filter(|_| !self.is_proc_macro(id))\n+            .map_or(None, |v| Some(v.decode((self, tcx))))\n+    }\n+\n     fn get_unused_generic_params(&self, id: DefIndex) -> FiniteBitSet<u32> {\n         self.root\n             .tables"}, {"sha": "d4f577a7d1b492127ed23e16dc25df2117ecebb8", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -112,6 +112,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n     promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n+    mir_abstract_const => { cdata.get_mir_abstract_const(tcx, def_id.index) }\n     unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }"}, {"sha": "eb091d86b82c6d3ddd84d01ce5e84358254c2b76", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -321,6 +321,12 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        (**self).encode(s)\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         (**self).encode(s)\n@@ -1109,6 +1115,11 @@ impl EncodeContext<'a, 'tcx> {\n             if !unused.is_empty() {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n+\n+            let abstract_const = self.tcx.mir_abstract_const(def_id);\n+            if let Some(abstract_const) = abstract_const {\n+                record!(self.tables.mir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+            }\n         }\n     }\n "}, {"sha": "ba540c944117d1e4ad4fc043d9fce171973a2f58", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -284,6 +284,7 @@ define_tables! {\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire"}, {"sha": "b85f1e6e5ded05aad2c176114f2a10245a3c7e13", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,20 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(&'tcx ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+}"}, {"sha": "be61b67680750a642317481051e183c23a00e82b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -40,6 +40,7 @@ use std::{iter, mem, option};\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n+pub mod abstract_const;\n pub mod coverage;\n pub mod interpret;\n pub mod mono;"}, {"sha": "44d906dada5f05b80974efec0767d407127edd8c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -244,6 +244,35 @@ rustc_queries! {\n             no_hash\n         }\n \n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const(\n+            key: DefId\n+        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+            desc {\n+                |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n+            }\n+        }\n+        /// Try to build an abstract representation of the given constant.\n+        query mir_abstract_const_of_const_arg(\n+            key: (LocalDefId, DefId)\n+        ) -> Option<&'tcx [mir::abstract_const::Node<'tcx>]> {\n+            desc {\n+                |tcx|\n+                \"building an abstract representation for the const argument {}\",\n+                tcx.def_path_str(key.0.to_def_id()),\n+            }\n+        }\n+\n+        query try_unify_abstract_consts(key: (\n+            (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+            (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)\n+        )) -> bool {\n+            desc {\n+                |tcx| \"trying to unify the generic constants {} and {}\",\n+                tcx.def_path_str(key.0.0.did), tcx.def_path_str(key.1.0.did)\n+            }\n+        }\n+\n         query mir_drops_elaborated_and_const_checked(\n             key: ty::WithOptConstParam<LocalDefId>\n         ) -> &'tcx Steal<mir::Body<'tcx>> {"}, {"sha": "8ea34f9161abcf563c06fc0ae8b5f9603ea14af8", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -357,6 +357,26 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>,\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::Node<'tcx>] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::NodeId] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,"}, {"sha": "a005990264cf11176443819ad7e8446804e15cb8", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -193,6 +193,22 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n+impl<'tcx> Key\n+    for (\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+    )\n+{\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        (self.0).0.did.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        (self.0).0.did.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (LocalDefId, DefId, SubstsRef<'tcx>) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "b0c48a860ebafd328e17f0cb141805e132b2e3bd", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -760,6 +760,12 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [mir::abstract_const::Node<'tcx>] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         RefDecodable::decode(d)"}, {"sha": "c4df0bba726cb9d0929c355b7f0021e88061c0e0", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -576,7 +576,20 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             new_val.map(ty::ConstKind::Value)\n         }\n \n-        // FIXME(const_generics): this is wrong, as it is a projection\n+        (\n+            ty::ConstKind::Unevaluated(a_def, a_substs, None),\n+            ty::ConstKind::Unevaluated(b_def, b_substs, None),\n+        ) if tcx.features().const_evaluatable_checked => {\n+            if tcx.try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs))) {\n+                Ok(a.val)\n+            } else {\n+                Err(TypeError::ConstMismatch(expected_found(relation, a, b)))\n+            }\n+        }\n+\n+        // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n+        // and is the better alternative to waiting until `const_evaluatable_checked` can\n+        // be stabilized.\n         (\n             ty::ConstKind::Unevaluated(a_def, a_substs, a_promoted),\n             ty::ConstKind::Unevaluated(b_def, b_substs, b_promoted),"}, {"sha": "226282fe4263c065d267a7f27e07352dd2df128b", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -329,7 +329,11 @@ fn mir_promoted(\n     // this point, before we steal the mir-const result.\n     // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n-\n+    let _ = if let Some(param_did) = def.const_param_did {\n+        tcx.mir_abstract_const_of_const_arg((def.did, param_did))\n+    } else {\n+        tcx.mir_abstract_const(def.did.to_def_id())\n+    };\n     let mut body = tcx.mir_const(def).steal();\n \n     let mut required_consts = Vec::new();"}, {"sha": "1a95992ed8318adf8b33021bec64a1ddab3ceacd", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -97,6 +97,15 @@ where\n                 ty.visit_with(self)\n             }\n             ty::PredicateAtom::RegionOutlives(..) => false,\n+            ty::PredicateAtom::ConstEvaluatable(..)\n+                if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n+            {\n+                // FIXME(const_evaluatable_checked): If the constant used here depends on a\n+                // private function we may have to do something here...\n+                //\n+                // For now, let's just pretend that everything is fine.\n+                false\n+            }\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }"}, {"sha": "da1996b92a60b520f4fab62e38031a9f3bc266f9", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -12,6 +12,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n+#![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "2642358dbc54c4a6b99b7f9ce6d47766bda88fea", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 366, "deletions": 12, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -1,10 +1,25 @@\n+//! Checking that constant values used in types can be successfully evaluated.\n+//!\n+//! For concrete constants, this is fairly simple as we can just try and evaluate it.\n+//!\n+//! When dealing with polymorphic constants, for example `std::mem::size_of::<T>() - 1`,\n+//! this is not as easy.\n+//!\n+//! In this case we try to build an abstract representation of this constant using\n+//! `mir_abstract_const` which can then be checked for structural equality with other\n+//! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_hir::def::DefKind;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::mir::abstract_const::{Node, NodeId};\n use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n \n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -16,18 +31,23 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ) -> Result<(), ErrorHandled> {\n     debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n     if infcx.tcx.features().const_evaluatable_checked {\n-        // FIXME(const_evaluatable_checked): Actually look into generic constants to\n-        // implement const equality.\n-        for pred in param_env.caller_bounds() {\n-            match pred.skip_binders() {\n-                ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n-                    debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n-                    if b_def == def && b_substs == substs {\n-                        debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n-                        return Ok(());\n+        if let Some(ct) = AbstractConst::new(infcx.tcx, def, substs) {\n+            for pred in param_env.caller_bounds() {\n+                match pred.skip_binders() {\n+                    ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n+                        debug!(\"is_const_evaluatable: caller_bound={:?}, {:?}\", b_def, b_substs);\n+                        if b_def == def && b_substs == substs {\n+                            debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n+                            return Ok(());\n+                        } else if AbstractConst::new(infcx.tcx, b_def, b_substs)\n+                            .map_or(false, |b_ct| try_unify(infcx.tcx, ct, b_ct))\n+                        {\n+                            debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                            return Ok(());\n+                        }\n                     }\n+                    _ => {} // don't care\n                 }\n-                _ => {} // don't care\n             }\n         }\n     }\n@@ -76,3 +96,337 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     debug!(?concrete, \"is_const_evaluatable\");\n     concrete.map(drop)\n }\n+\n+/// A tree representing an anonymous constant.\n+///\n+/// This is only able to represent a subset of `MIR`,\n+/// and should not leak any information about desugarings.\n+#[derive(Clone, Copy)]\n+pub struct AbstractConst<'tcx> {\n+    // FIXME: Consider adding something like `IndexSlice`\n+    // and use this here.\n+    inner: &'tcx [Node<'tcx>],\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl AbstractConst<'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<DefId>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        let inner = match (def.did.as_local(), def.const_param_did) {\n+            (Some(did), Some(param_did)) => {\n+                tcx.mir_abstract_const_of_const_arg((did, param_did))?\n+            }\n+            _ => tcx.mir_abstract_const(def.did)?,\n+        };\n+\n+        Some(AbstractConst { inner, substs })\n+    }\n+\n+    #[inline]\n+    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n+        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n+    }\n+\n+    #[inline]\n+    pub fn root(self) -> Node<'tcx> {\n+        self.inner.last().copied().unwrap()\n+    }\n+}\n+\n+struct AbstractConstBuilder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a mir::Body<'tcx>,\n+    /// The current WIP node tree.\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n+    locals: IndexVec<mir::Local, NodeId>,\n+    /// We only allow field accesses if they access\n+    /// the result of a checked operation.\n+    checked_op_locals: BitSet<mir::Local>,\n+}\n+\n+impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, body: &'a mir::Body<'tcx>) -> Option<AbstractConstBuilder<'a, 'tcx>> {\n+        // We only allow consts without control flow, so\n+        // we check for cycles here which simplifies the\n+        // rest of this implementation.\n+        if body.is_cfg_cyclic() {\n+            return None;\n+        }\n+\n+        // We don't have to look at concrete constants, as we\n+        // can just evaluate them.\n+        if !body.is_polymorphic {\n+            return None;\n+        }\n+\n+        Some(AbstractConstBuilder {\n+            tcx,\n+            body,\n+            nodes: IndexVec::new(),\n+            locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n+            checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n+        })\n+    }\n+    fn operand_to_node(&mut self, op: &mir::Operand<'tcx>) -> Option<NodeId> {\n+        debug!(\"operand_to_node: op={:?}\", op);\n+        const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n+        match op {\n+            mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                // Do not allow any projections.\n+                //\n+                // One exception are field accesses on the result of checked operations,\n+                // which are required to support things like `1 + 2`.\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    Some(self.locals[p])\n+                } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n+                    // Only allow field accesses if the given local\n+                    // contains the result of a checked operation.\n+                    if self.checked_op_locals.contains(p.local) {\n+                        Some(self.locals[p.local])\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            }\n+            mir::Operand::Constant(ct) => Some(self.nodes.push(Node::Leaf(ct.literal))),\n+        }\n+    }\n+\n+    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n+    fn check_binop(op: mir::BinOp) -> bool {\n+        use mir::BinOp::*;\n+        match op {\n+            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n+            | Ne | Ge | Gt => true,\n+            Offset => false,\n+        }\n+    }\n+\n+    /// While we currently allow all unary operations, we still want to explicitly guard against\n+    /// future changes here.\n+    fn check_unop(op: mir::UnOp) -> bool {\n+        use mir::UnOp::*;\n+        match op {\n+            Not | Neg => true,\n+        }\n+    }\n+\n+    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Option<()> {\n+        debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        match stmt.kind {\n+            StatementKind::Assign(box (ref place, ref rvalue)) => {\n+                let local = place.as_local()?;\n+                match *rvalue {\n+                    Rvalue::Use(ref operand) => {\n+                        self.locals[local] = self.operand_to_node(operand)?;\n+                        Some(())\n+                    }\n+                    Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n+                        let lhs = self.operand_to_node(lhs)?;\n+                        let rhs = self.operand_to_node(rhs)?;\n+                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        if op.is_checkable() {\n+                            bug!(\"unexpected unchecked checkable binary operation\");\n+                        } else {\n+                            Some(())\n+                        }\n+                    }\n+                    Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n+                        let lhs = self.operand_to_node(lhs)?;\n+                        let rhs = self.operand_to_node(rhs)?;\n+                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        self.checked_op_locals.insert(local);\n+                        Some(())\n+                    }\n+                    Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n+                        let operand = self.operand_to_node(operand)?;\n+                        self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n+                        Some(())\n+                    }\n+                    _ => None,\n+                }\n+            }\n+            // These are not actually relevant for us here, so we can ignore them.\n+            StatementKind::StorageLive(_) | StatementKind::StorageDead(_) => Some(()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Possible return values:\n+    ///\n+    /// - `None`: unsupported terminator, stop building\n+    /// - `Some(None)`: supported terminator, finish building\n+    /// - `Some(Some(block))`: support terminator, build `block` next\n+    fn build_terminator(\n+        &mut self,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> Option<Option<mir::BasicBlock>> {\n+        debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n+        match terminator.kind {\n+            TerminatorKind::Goto { target } => Some(Some(target)),\n+            TerminatorKind::Return => Some(None),\n+            TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                destination: Some((ref place, target)),\n+                // We do not care about `cleanup` here. Any branch which\n+                // uses `cleanup` will fail const-eval and they therefore\n+                // do not matter when checking for const evaluatability.\n+                //\n+                // Do note that even if `panic::catch_unwind` is made const,\n+                // we still do not have to care about this, as we do not look\n+                // into functions.\n+                cleanup: _,\n+                // Do not allow overloaded operators for now,\n+                // we probably do want to allow this in the future.\n+                //\n+                // This is currently fairly irrelevant as it requires `const Trait`s.\n+                from_hir_call: true,\n+                fn_span: _,\n+            } => {\n+                let local = place.as_local()?;\n+                let func = self.operand_to_node(func)?;\n+                let args = self.tcx.arena.alloc_from_iter(\n+                    args.iter()\n+                        .map(|arg| self.operand_to_node(arg))\n+                        .collect::<Option<Vec<NodeId>>>()?,\n+                );\n+                self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n+                Some(Some(target))\n+            }\n+            // We only allow asserts for checked operations.\n+            //\n+            // These asserts seem to all have the form `!_local.0` so\n+            // we only allow exactly that.\n+            TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n+                let p = match cond {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n+                    mir::Operand::Constant(_) => bug!(\"unexpected assert\"),\n+                };\n+\n+                const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n+                debug!(\"proj: {:?}\", p.projection);\n+                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                    // Only allow asserts checking the result of a checked operation.\n+                    if self.checked_op_locals.contains(p.local) {\n+                        return Some(Some(target));\n+                    }\n+                }\n+\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Builds the abstract const by walking the mir from start to finish\n+    /// and bailing out when encountering an unsupported operation.\n+    fn build(mut self) -> Option<&'tcx [Node<'tcx>]> {\n+        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n+        // We checked for a cyclic cfg above, so this should terminate.\n+        loop {\n+            debug!(\"AbstractConstBuilder: block={:?}\", block);\n+            for stmt in block.statements.iter() {\n+                self.build_statement(stmt)?;\n+            }\n+\n+            if let Some(next) = self.build_terminator(block.terminator())? {\n+                block = &self.body.basic_blocks()[next];\n+            } else {\n+                return Some(self.tcx.arena.alloc_from_iter(self.nodes));\n+            }\n+        }\n+    }\n+}\n+\n+/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n+pub(super) fn mir_abstract_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) -> Option<&'tcx [Node<'tcx>]> {\n+    if tcx.features().const_evaluatable_checked {\n+        match tcx.def_kind(def.did) {\n+            // FIXME(const_evaluatable_checked): We currently only do this for anonymous constants,\n+            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n+            // we want to look into them or treat them as opaque projections.\n+            //\n+            // Right now we do neither of that and simply always fail to unify them.\n+            DefKind::AnonConst => (),\n+            _ => return None,\n+        }\n+        let body = tcx.mir_const(def).borrow();\n+        AbstractConstBuilder::new(tcx, &body)?.build()\n+    } else {\n+        None\n+    }\n+}\n+\n+pub(super) fn try_unify_abstract_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ((a, a_substs), (b, b_substs)): (\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+    ),\n+) -> bool {\n+    if let Some(a) = AbstractConst::new(tcx, a, a_substs) {\n+        if let Some(b) = AbstractConst::new(tcx, b, b_substs) {\n+            return try_unify(tcx, a, b);\n+        }\n+    }\n+\n+    false\n+}\n+\n+/// Tries to unify two abstract constants using structural equality.\n+pub(super) fn try_unify<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    a: AbstractConst<'tcx>,\n+    b: AbstractConst<'tcx>,\n+) -> bool {\n+    match (a.root(), b.root()) {\n+        (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+            let a_ct = a_ct.subst(tcx, a.substs);\n+            let b_ct = b_ct.subst(tcx, b.substs);\n+            match (a_ct.val, b_ct.val) {\n+                // We can just unify errors with everything to reduce the amount of\n+                // emitted errors here.\n+                (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                    a_param == b_param\n+                }\n+                (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                // means that we only allow inference variables if they are equal.\n+                (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                // FIXME(const_evaluatable_checked): We may want to either actually try\n+                // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                // this, for now we just return false here.\n+                _ => false,\n+            }\n+        }\n+        (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+            try_unify(tcx, a.subtree(al), b.subtree(bl))\n+                && try_unify(tcx, a.subtree(ar), b.subtree(br))\n+        }\n+        (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+            try_unify(tcx, a.subtree(av), b.subtree(bv))\n+        }\n+        (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+            if a_args.len() == b_args.len() =>\n+        {\n+            try_unify(tcx, a.subtree(a_f), b.subtree(b_f))\n+                && a_args\n+                    .iter()\n+                    .zip(b_args)\n+                    .all(|(&an, &bn)| try_unify(tcx, a.subtree(an), b.subtree(bn)))\n+        }\n+        _ => false,\n+    }\n+}"}, {"sha": "5b4314598deb5e43f7f3f6914895bd6b77df7d6d", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -476,6 +476,25 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n                 ty::PredicateAtom::ConstEquate(c1, c2) => {\n                     debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n+                    if self.selcx.tcx().features().const_evaluatable_checked {\n+                        // FIXME: we probably should only try to unify abstract constants\n+                        // if the constants depend on generic parameters.\n+                        //\n+                        // Let's just see where this breaks :shrug:\n+                        if let (\n+                            ty::ConstKind::Unevaluated(a_def, a_substs, None),\n+                            ty::ConstKind::Unevaluated(b_def, b_substs, None),\n+                        ) = (c1.val, c2.val)\n+                        {\n+                            if self\n+                                .selcx\n+                                .tcx()\n+                                .try_unify_abstract_consts(((a_def, a_substs), (b_def, b_substs)))\n+                            {\n+                                return ProcessResult::Changed(vec![]);\n+                            }\n+                        }\n+                    }\n \n                     let stalled_on = &mut pending_obligation.stalled_on;\n "}, {"sha": "79495ba7f9b30b662ebe2593747f63a1363a7681", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -552,6 +552,21 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_methods,\n         type_implements_trait,\n         subst_and_check_impossible_predicates,\n+        mir_abstract_const: |tcx, def_id| {\n+            let def_id = def_id.expect_local();\n+            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n+                tcx.mir_abstract_const_of_const_arg(def)\n+            } else {\n+                const_evaluatable::mir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+            }\n+        },\n+        mir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            const_evaluatable::mir_abstract_const(\n+                tcx,\n+                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n+            )\n+        },\n+        try_unify_abstract_consts: const_evaluatable::try_unify_abstract_consts,\n         ..*providers\n     };\n }"}, {"sha": "731ccfad2b44f50ec9222772a382b90e82f25feb", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -1693,25 +1693,27 @@ pub fn const_evaluatable_predicates_of<'tcx>(\n ) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n     #[derive(Default)]\n     struct ConstCollector<'tcx> {\n-        ct: SmallVec<[(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>); 4]>,\n+        ct: SmallVec<[(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>, Span); 4]>,\n+        curr_span: Span,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for ConstCollector<'tcx> {\n         fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n             if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n-                self.ct.push((def, substs));\n+                self.ct.push((def, substs, self.curr_span));\n             }\n             false\n         }\n     }\n \n     let mut collector = ConstCollector::default();\n-    for (pred, _span) in predicates.predicates.iter() {\n+    for &(pred, span) in predicates.predicates.iter() {\n+        collector.curr_span = span;\n         pred.visit_with(&mut collector);\n     }\n     warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.ct);\n-    collector.ct.into_iter().map(move |(def_id, subst)| {\n-        (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), DUMMY_SP)\n+    collector.ct.into_iter().map(move |(def_id, subst, span)| {\n+        (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), span)\n     })\n }\n "}, {"sha": "9745dfed46087db4240e168b3a6f129a01e97e3e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/auxiliary/const_evaluatable_lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fauxiliary%2Fconst_evaluatable_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fauxiliary%2Fconst_evaluatable_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fauxiliary%2Fconst_evaluatable_lib.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+where\n+    [u8; std::mem::size_of::<T>() - 1]: Sized,\n+{\n+    [0; std::mem::size_of::<T>() - 1]\n+}"}, {"sha": "53b237843871f1f22c7f2f519ee6b1c3fc404cfe", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:const_evaluatable_lib.rs\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+extern crate const_evaluatable_lib;\n+\n+fn user<T>() where [u8; std::mem::size_of::<T>() - 1]: Sized {\n+    assert_eq!(const_evaluatable_lib::test1::<T>(), [0; std::mem::size_of::<T>() - 1]);\n+}\n+\n+fn main() {\n+    assert_eq!(const_evaluatable_lib::test1::<u32>(), [0; 3]);\n+    user::<u32>();\n+    user::<u64>();\n+}"}, {"sha": "223699233298d4e5a4b28c3172c9c75293bce4f3", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,13 @@\n+// aux-build:const_evaluatable_lib.rs\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+extern crate const_evaluatable_lib;\n+\n+fn user<T>() {\n+    let _ = const_evaluatable_lib::test1::<T>();\n+    //~^ ERROR constant expression depends\n+    //~| ERROR constant expression depends\n+    //~| ERROR constant expression depends\n+}\n+\n+fn main() {}"}, {"sha": "63abb782b93a3f2f98cb49ee0cc9fa091c3630a4", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,36 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/cross_crate_predicate.rs:7:13\n+   |\n+LL |     let _ = const_evaluatable_lib::test1::<T>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | \n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+   |\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |                                         ----- required by this bound in `test1`\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/cross_crate_predicate.rs:7:13\n+   |\n+LL |     let _ = const_evaluatable_lib::test1::<T>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | \n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+   |\n+LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n+   |                                         ----- required by this bound in `test1::{{constant}}#1`\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/cross_crate_predicate.rs:7:13\n+   |\n+LL |     let _ = const_evaluatable_lib::test1::<T>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "1b9ec0108b1e742ae3052ff253a2ecca05d5e7df", "filename": "src/test/ui/const-generics/const_evaluatable_checked/fn_call.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffn_call.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,30 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+const fn test_me<T>(a: usize, b: usize) -> usize {\n+    if a < b {\n+        std::mem::size_of::<T>()\n+    } else {\n+        std::usize::MAX\n+    }\n+}\n+\n+fn test_simple<T>() -> [u8; std::mem::size_of::<T>()]\n+where\n+    [u8; std::mem::size_of::<T>()]: Sized,\n+{\n+    [0; std::mem::size_of::<T>()]\n+}\n+\n+fn test_with_args<T, const N: usize>() -> [u8; test_me::<T>(N, N + 1) + N]\n+where\n+    [u8; test_me::<T>(N, N + 1) + N]: Sized,\n+{\n+    [0; test_me::<T>(N, N + 1) + N]\n+}\n+\n+fn main() {\n+    assert_eq!([0; 8], test_simple::<u64>());\n+    assert_eq!([0; 12], test_with_args::<u64, 4>());\n+}"}, {"sha": "907ea255abb0836ef10e37eec6d5aed852e4d2af", "filename": "src/test/ui/const-generics/const_evaluatable_checked/less_than.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fless_than.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<const B: bool>;\n+\n+fn test<const N: usize>() -> Foo<{ N > 10 }> where Foo<{ N > 10 }>: Sized {\n+    Foo\n+}\n+\n+fn main() {\n+    let _: Foo<true> = test::<12>();\n+    let _: Foo<false> = test::<9>();\n+}"}, {"sha": "d96788f8cd100510437c26612f9368f23313cfa6", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,15 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+// We do not yet want to support let-bindings in abstract consts,\n+// so this test should keep failing for now.\n+fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n+    //~^ ERROR constant expression depends\n+    //~| ERROR constant expression depends\n+    Default::default()\n+}\n+\n+fn main() {\n+    let x = test::<31>();\n+    assert_eq!(x, [0; 32]);\n+}"}, {"sha": "95fb48bd434027c88245a0a1864b74f3f0233822", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,18 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/let-bindings.rs:6:91\n+   |\n+LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n+   |                                                                                           ^^^^^^^ required by this bound in `test::{{constant}}#0`\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/let-bindings.rs:6:30\n+   |\n+LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3cac604a7b33a0d1e1b419c2ba87139c29884344", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple.min.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -1,10 +1,18 @@\n error: generic parameters must not be used inside of non trivial constant values\n-  --> $DIR/simple.rs:8:33\n+  --> $DIR/simple.rs:8:53\n    |\n-LL | type Arr<const N: usize> = [u8; N - 1];\n-   |                                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+LL | fn test<const N: usize>() -> [u8; N - 1] where [u8; N - 1]: Default {\n+   |                                                     ^ non-trivial anonymous constants must not depend on the parameter `N`\n    |\n    = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n \n-error: aborting due to previous error\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/simple.rs:8:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N - 1] where [u8; N - 1]: Default {\n+   |                                   ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "dcf0071cb29b6eb5898367e390d3200939075243", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -5,10 +5,9 @@\n #![feature(const_evaluatable_checked)]\n #![allow(incomplete_features)]\n \n-type Arr<const N: usize> = [u8; N - 1];\n-//[min]~^ ERROR generic parameters must not be used inside of non trivial constant values\n-\n-fn test<const N: usize>() -> Arr<N> where Arr<N>: Default {\n+fn test<const N: usize>() -> [u8; N - 1] where [u8; N - 1]: Default {\n+    //[min]~^ ERROR generic parameters\n+    //[min]~| ERROR generic parameters\n     Default::default()\n }\n "}, {"sha": "8e0768b1c9595d5625b05ff5379a04c66d636c2b", "filename": "src/test/ui/const-generics/const_evaluatable_checked/unop.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8ac718f44e280edb1a7b3266f2c26106ec11a0/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Funop.rs?ref=9f8ac718f44e280edb1a7b3266f2c26106ec11a0", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<const B: bool>;\n+\n+fn test<const N: usize>() -> Foo<{ !(N > 10) }> where Foo<{ !(N > 10) }>: Sized {\n+    Foo\n+}\n+\n+fn main() {\n+    let _: Foo<false> = test::<12>();\n+    let _: Foo<true> = test::<9>();\n+}"}]}