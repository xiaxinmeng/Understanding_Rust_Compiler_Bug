{"sha": "ca098b16a4114fd96a4059ba3f807d33dde5ef07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMDk4YjE2YTQxMTRmZDk2YTQwNTliYTNmODA3ZDMzZGRlNWVmMDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-08T08:28:46Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T14:08:25Z"}, "message": "detach submod_path from Parser", "tree": {"sha": "9fb703efa6852016b34fdcd7c5d14a061d495b68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb703efa6852016b34fdcd7c5d14a061d495b68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca098b16a4114fd96a4059ba3f807d33dde5ef07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca098b16a4114fd96a4059ba3f807d33dde5ef07", "html_url": "https://github.com/rust-lang/rust/commit/ca098b16a4114fd96a4059ba3f807d33dde5ef07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca098b16a4114fd96a4059ba3f807d33dde5ef07/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfcefa49ed5ce5018d279a8d1a60744da67c80c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfcefa49ed5ce5018d279a8d1a60744da67c80c8", "html_url": "https://github.com/rust-lang/rust/commit/dfcefa49ed5ce5018d279a8d1a60744da67c80c8"}], "stats": {"total": 379, "additions": 192, "deletions": 187}, "files": [{"sha": "87255386b9e6602b101f6dbbf069cf43dd2b5c22", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ca098b16a4114fd96a4059ba3f807d33dde5ef07/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca098b16a4114fd96a4059ba3f807d33dde5ef07/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=ca098b16a4114fd96a4059ba3f807d33dde5ef07", "patch": "@@ -18,7 +18,6 @@ use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};\n use std::mem;\n-use std::path::PathBuf;\n \n const TURBOFISH: &str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n \n@@ -41,42 +40,12 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n }\n \n pub enum Error {\n-    FileNotFoundForModule { mod_name: String, default_path: PathBuf },\n-    DuplicatePaths { mod_name: String, default_path: String, secondary_path: String },\n     UselessDocComment,\n }\n \n impl Error {\n     fn span_err(self, sp: impl Into<MultiSpan>, handler: &Handler) -> DiagnosticBuilder<'_> {\n         match self {\n-            Error::FileNotFoundForModule { ref mod_name, ref default_path } => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0583,\n-                    \"file not found for module `{}`\",\n-                    mod_name,\n-                );\n-                err.help(&format!(\n-                    \"to create the module `{}`, create file \\\"{}\\\"\",\n-                    mod_name,\n-                    default_path.display(),\n-                ));\n-                err\n-            }\n-            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0584,\n-                    \"file for module `{}` found at both {} and {}\",\n-                    mod_name,\n-                    default_path,\n-                    secondary_path,\n-                );\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n-            }\n             Error::UselessDocComment => {\n                 let mut err = struct_span_err!(\n                     handler,"}, {"sha": "a30d6da281a25d35212ea2ef6a8033e6337d4d7a", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 192, "deletions": 156, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/ca098b16a4114fd96a4059ba3f807d33dde5ef07/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca098b16a4114fd96a4059ba3f807d33dde5ef07/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=ca098b16a4114fd96a4059ba3f807d33dde5ef07", "patch": "@@ -1,4 +1,3 @@\n-use super::diagnostics::Error;\n use super::item::ItemInfo;\n use super::Parser;\n \n@@ -7,18 +6,19 @@ use crate::{new_sub_parser_from_file, DirectoryOwnership};\n use rustc_ast::ast::{self, Attribute, Crate, Ident, ItemKind, Mod};\n use rustc_ast::attr;\n use rustc_ast::token::{self, TokenKind};\n-use rustc_errors::PResult;\n-use rustc_span::source_map::{FileName, SourceMap, Span, DUMMY_SP};\n+use rustc_errors::{struct_span_err, PResult};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::source_map::{FileName, Span, DUMMY_SP};\n use rustc_span::symbol::sym;\n \n use std::path::{self, Path, PathBuf};\n \n /// Information about the path to a module.\n // Public for rustfmt usage.\n-pub struct ModulePath {\n+pub struct ModulePath<'a> {\n     name: String,\n     path_exists: bool,\n-    pub result: Result<ModulePathSuccess, Error>,\n+    pub result: PResult<'a, ModulePathSuccess>,\n }\n \n // Public for rustfmt usage.\n@@ -45,8 +45,13 @@ impl<'a> Parser<'a> {\n         let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n             if in_cfg && self.recurse_into_file_modules {\n                 // This mod is in an external file. Let's go get it!\n-                let ModulePathSuccess { path, directory_ownership } =\n-                    self.submod_path(id, &attrs)?;\n+                let ModulePathSuccess { path, directory_ownership } = submod_path(\n+                    self.sess,\n+                    id,\n+                    &attrs,\n+                    self.directory.ownership,\n+                    &self.directory.path,\n+                )?;\n                 self.eval_src_mod(path, directory_ownership, id.to_string(), id.span)?\n             } else {\n                 (ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false }, Vec::new())\n@@ -96,155 +101,6 @@ impl<'a> Parser<'a> {\n         Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n     }\n \n-    fn submod_path(\n-        &mut self,\n-        id: ast::Ident,\n-        outer_attrs: &[Attribute],\n-    ) -> PResult<'a, ModulePathSuccess> {\n-        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n-            let directory_ownership = match path.file_name().and_then(|s| s.to_str()) {\n-                // All `#[path]` files are treated as though they are a `mod.rs` file.\n-                // This means that `mod foo;` declarations inside `#[path]`-included\n-                // files are siblings,\n-                //\n-                // Note that this will produce weirdness when a file named `foo.rs` is\n-                // `#[path]` included and contains a `mod foo;` declaration.\n-                // If you encounter this, it's your own darn fault :P\n-                Some(_) => DirectoryOwnership::Owned { relative: None },\n-                _ => DirectoryOwnership::UnownedViaMod,\n-            };\n-            return Ok(ModulePathSuccess { directory_ownership, path });\n-        }\n-\n-        let relative = match self.directory.ownership {\n-            DirectoryOwnership::Owned { relative } => relative,\n-            DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n-        };\n-        let paths =\n-            Parser::default_submod_path(id, relative, &self.directory.path, self.sess.source_map());\n-\n-        match self.directory.ownership {\n-            DirectoryOwnership::Owned { .. } => {\n-                paths.result.map_err(|err| self.span_fatal_err(id.span, err))\n-            }\n-            DirectoryOwnership::UnownedViaBlock => self.error_decl_mod_in_block(id.span, paths),\n-            DirectoryOwnership::UnownedViaMod => self.error_cannot_declare_mod_here(id.span, paths),\n-        }\n-    }\n-\n-    fn error_decl_mod_in_block<T>(&self, id_sp: Span, paths: ModulePath) -> PResult<'a, T> {\n-        let msg =\n-            \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n-        let mut err = self.struct_span_err(id_sp, msg);\n-        if paths.path_exists {\n-            let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", paths.name);\n-            err.span_note(id_sp, &msg);\n-        }\n-        Err(err)\n-    }\n-\n-    fn error_cannot_declare_mod_here<T>(&self, id_sp: Span, paths: ModulePath) -> PResult<'a, T> {\n-        let mut err = self.struct_span_err(id_sp, \"cannot declare a new module at this location\");\n-        if !id_sp.is_dummy() {\n-            if let FileName::Real(src_path) = self.sess.source_map().span_to_filename(id_sp) {\n-                if let Some(stem) = src_path.file_stem() {\n-                    let mut dest_path = src_path.clone();\n-                    dest_path.set_file_name(stem);\n-                    dest_path.push(\"mod.rs\");\n-                    err.span_note(\n-                        id_sp,\n-                        &format!(\n-                            \"maybe move this module `{}` to its own \\\n-                                    directory via `{}`\",\n-                            src_path.display(),\n-                            dest_path.display()\n-                        ),\n-                    );\n-                }\n-            }\n-        }\n-        if paths.path_exists {\n-            err.span_note(\n-                id_sp,\n-                &format!(\n-                    \"... or maybe `use` the module `{}` instead \\\n-                                of possibly redeclaring it\",\n-                    paths.name\n-                ),\n-            );\n-        }\n-        Err(err)\n-    }\n-\n-    /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n-    /// The provided `dir_path` is joined with the `path_string`.\n-    // Public for rustfmt usage.\n-    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        // Extract path string from first `#[path = \"path_string\"]` attribute.\n-        let path_string = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n-        let path_string = path_string.as_str();\n-\n-        // On windows, the base path might have the form\n-        // `\\\\?\\foo\\bar` in which case it does not tolerate\n-        // mixed `/` and `\\` separators, so canonicalize\n-        // `/` to `\\`.\n-        #[cfg(windows)]\n-        let path_string = path_string.replace(\"/\", \"\\\\\");\n-\n-        Some(dir_path.join(&*path_string))\n-    }\n-\n-    /// Returns a path to a module.\n-    // Public for rustfmt usage.\n-    pub fn default_submod_path(\n-        id: ast::Ident,\n-        relative: Option<ast::Ident>,\n-        dir_path: &Path,\n-        source_map: &SourceMap,\n-    ) -> ModulePath {\n-        // If we're in a foo.rs file instead of a mod.rs file,\n-        // we need to look for submodules in\n-        // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-        // `./<id>.rs` and `./<id>/mod.rs`.\n-        let relative_prefix_string;\n-        let relative_prefix = if let Some(ident) = relative {\n-            relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n-            &relative_prefix_string\n-        } else {\n-            \"\"\n-        };\n-\n-        let mod_name = id.name.to_string();\n-        let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n-        let secondary_path_str =\n-            format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n-        let default_path = dir_path.join(&default_path_str);\n-        let secondary_path = dir_path.join(&secondary_path_str);\n-        let default_exists = source_map.file_exists(&default_path);\n-        let secondary_exists = source_map.file_exists(&secondary_path);\n-\n-        let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess {\n-                path: default_path,\n-                directory_ownership: DirectoryOwnership::Owned { relative: Some(id) },\n-            }),\n-            (false, true) => Ok(ModulePathSuccess {\n-                path: secondary_path,\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n-            }),\n-            (false, false) => {\n-                Err(Error::FileNotFoundForModule { mod_name: mod_name.clone(), default_path })\n-            }\n-            (true, true) => Err(Error::DuplicatePaths {\n-                mod_name: mod_name.clone(),\n-                default_path: default_path_str,\n-                secondary_path: secondary_path_str,\n-            }),\n-        };\n-\n-        ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n-    }\n-\n     /// Reads a module from a source file.\n     fn eval_src_mod(\n         &mut self,\n@@ -308,3 +164,183 @@ impl<'a> Parser<'a> {\n         }\n     }\n }\n+\n+fn submod_path<'a>(\n+    sess: &'a ParseSess,\n+    id: ast::Ident,\n+    outer_attrs: &[Attribute],\n+    directory_ownership: DirectoryOwnership,\n+    dir_path: &Path,\n+) -> PResult<'a, ModulePathSuccess> {\n+    if let Some(path) = submod_path_from_attr(outer_attrs, dir_path) {\n+        let directory_ownership = match path.file_name().and_then(|s| s.to_str()) {\n+            // All `#[path]` files are treated as though they are a `mod.rs` file.\n+            // This means that `mod foo;` declarations inside `#[path]`-included\n+            // files are siblings,\n+            //\n+            // Note that this will produce weirdness when a file named `foo.rs` is\n+            // `#[path]` included and contains a `mod foo;` declaration.\n+            // If you encounter this, it's your own darn fault :P\n+            Some(_) => DirectoryOwnership::Owned { relative: None },\n+            _ => DirectoryOwnership::UnownedViaMod,\n+        };\n+        return Ok(ModulePathSuccess { directory_ownership, path });\n+    }\n+\n+    let relative = match directory_ownership {\n+        DirectoryOwnership::Owned { relative } => relative,\n+        DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n+    };\n+    let ModulePath { path_exists, name, result } =\n+        default_submod_path(sess, id, relative, dir_path);\n+    match directory_ownership {\n+        DirectoryOwnership::Owned { .. } => Ok(result?),\n+        DirectoryOwnership::UnownedViaBlock => {\n+            let _ = result.map_err(|mut err| err.cancel());\n+            error_decl_mod_in_block(sess, id.span, path_exists, &name)\n+        }\n+        DirectoryOwnership::UnownedViaMod => {\n+            let _ = result.map_err(|mut err| err.cancel());\n+            error_cannot_declare_mod_here(sess, id.span, path_exists, &name)\n+        }\n+    }\n+}\n+\n+fn error_decl_mod_in_block<'a, T>(\n+    sess: &'a ParseSess,\n+    id_sp: Span,\n+    path_exists: bool,\n+    name: &str,\n+) -> PResult<'a, T> {\n+    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n+    let mut err = sess.span_diagnostic.struct_span_err(id_sp, msg);\n+    if path_exists {\n+        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n+        err.span_note(id_sp, &msg);\n+    }\n+    Err(err)\n+}\n+\n+fn error_cannot_declare_mod_here<'a, T>(\n+    sess: &'a ParseSess,\n+    id_sp: Span,\n+    path_exists: bool,\n+    name: &str,\n+) -> PResult<'a, T> {\n+    let mut err =\n+        sess.span_diagnostic.struct_span_err(id_sp, \"cannot declare a new module at this location\");\n+    if !id_sp.is_dummy() {\n+        if let FileName::Real(src_path) = sess.source_map().span_to_filename(id_sp) {\n+            if let Some(stem) = src_path.file_stem() {\n+                let mut dest_path = src_path.clone();\n+                dest_path.set_file_name(stem);\n+                dest_path.push(\"mod.rs\");\n+                err.span_note(\n+                    id_sp,\n+                    &format!(\n+                        \"maybe move this module `{}` to its own \\\n+                                directory via `{}`\",\n+                        src_path.display(),\n+                        dest_path.display()\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+    if path_exists {\n+        err.span_note(\n+            id_sp,\n+            &format!(\"... or maybe `use` the module `{}` instead of possibly redeclaring it\", name),\n+        );\n+    }\n+    Err(err)\n+}\n+\n+/// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n+/// The provided `dir_path` is joined with the `path_string`.\n+// Public for rustfmt usage.\n+pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+    // Extract path string from first `#[path = \"path_string\"]` attribute.\n+    let path_string = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n+    let path_string = path_string.as_str();\n+\n+    // On windows, the base path might have the form\n+    // `\\\\?\\foo\\bar` in which case it does not tolerate\n+    // mixed `/` and `\\` separators, so canonicalize\n+    // `/` to `\\`.\n+    #[cfg(windows)]\n+    let path_string = path_string.replace(\"/\", \"\\\\\");\n+\n+    Some(dir_path.join(&*path_string))\n+}\n+\n+/// Returns a path to a module.\n+// Public for rustfmt usage.\n+pub fn default_submod_path<'a>(\n+    sess: &'a ParseSess,\n+    id: ast::Ident,\n+    relative: Option<ast::Ident>,\n+    dir_path: &Path,\n+) -> ModulePath<'a> {\n+    // If we're in a foo.rs file instead of a mod.rs file,\n+    // we need to look for submodules in\n+    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n+    // `./<id>.rs` and `./<id>/mod.rs`.\n+    let relative_prefix_string;\n+    let relative_prefix = if let Some(ident) = relative {\n+        relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n+        &relative_prefix_string\n+    } else {\n+        \"\"\n+    };\n+\n+    let mod_name = id.name.to_string();\n+    let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n+    let secondary_path_str =\n+        format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n+    let default_path = dir_path.join(&default_path_str);\n+    let secondary_path = dir_path.join(&secondary_path_str);\n+    let default_exists = sess.source_map().file_exists(&default_path);\n+    let secondary_exists = sess.source_map().file_exists(&secondary_path);\n+\n+    let result = match (default_exists, secondary_exists) {\n+        (true, false) => Ok(ModulePathSuccess {\n+            path: default_path,\n+            directory_ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+        }),\n+        (false, true) => Ok(ModulePathSuccess {\n+            path: secondary_path,\n+            directory_ownership: DirectoryOwnership::Owned { relative: None },\n+        }),\n+        (false, false) => {\n+            let mut err = struct_span_err!(\n+                sess.span_diagnostic,\n+                id.span,\n+                E0583,\n+                \"file not found for module `{}`\",\n+                mod_name,\n+            );\n+            err.help(&format!(\n+                \"to create the module `{}`, create file \\\"{}\\\"\",\n+                mod_name,\n+                default_path.display(),\n+            ));\n+            Err(err)\n+        }\n+        (true, true) => {\n+            let mut err = struct_span_err!(\n+                sess.span_diagnostic,\n+                id.span,\n+                E0584,\n+                \"file for module `{}` found at both {} and {}\",\n+                mod_name,\n+                default_path_str,\n+                secondary_path_str,\n+            );\n+            err.help(\"delete or rename one of them to remove the ambiguity\");\n+            Err(err)\n+        }\n+    };\n+\n+    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+}"}]}