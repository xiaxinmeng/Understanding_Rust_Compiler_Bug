{"sha": "d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "node_id": "C_kwDOAAsO6NoAKGQwZWNlNDRjZmEzYmUwZjJlZGZlYmUyODZkNjFmMTViOGFmZmEwYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T22:42:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T22:42:07Z"}, "message": "Auto merge of #102040 - TaKO8Ki:separate-definitions-and-hir-owners, r=cjgillot\n\nSeparate definitions and HIR owners in the type system\n\nFixes #83158\n\nr? `@cjgillot`", "tree": {"sha": "425236296769dc2cdc17b16d0f7066122026335f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/425236296769dc2cdc17b16d0f7066122026335f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "html_url": "https://github.com/rust-lang/rust/commit/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f83906b30798bf61513fa340524cebf6676f9db", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f83906b30798bf61513fa340524cebf6676f9db", "html_url": "https://github.com/rust-lang/rust/commit/3f83906b30798bf61513fa340524cebf6676f9db"}, {"sha": "8fe936099a3a2ea236d40212a340fc4a326eb506", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe936099a3a2ea236d40212a340fc4a326eb506", "html_url": "https://github.com/rust-lang/rust/commit/8fe936099a3a2ea236d40212a340fc4a326eb506"}], "stats": {"total": 1177, "additions": 659, "deletions": 518}, "files": [{"sha": "85306d7184d893fa5657b8d4c3712eb1ac562694", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                            self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "94137391568c926354a21e1b5b2ee222b4b0fea4", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -359,7 +359,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));"}, {"sha": "6d71679634331e90039ada4f32c9bd02cb0d67e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -24,7 +24,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: hir::ItemLocalId,\n \n-    owner: LocalDefId,\n+    owner: OwnerId,\n \n     definitions: &'a definitions::Definitions,\n }\n@@ -81,9 +81,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node,\n-                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(self.owner.def_id).to_string_no_crate_verbose(),\n                     self.owner,\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n@@ -112,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id);\n+        self.insert_nested(item.def_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id);\n+        self.insert_nested(foreign_id.def_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {"}, {"sha": "1251702c1ff6b88af2080b9fdb5ea811cada245c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             bodies: Vec::new(),\n             attrs: SortedMap::default(),\n             children: FxHashMap::default(),\n-            current_hir_id_owner: CRATE_DEF_ID,\n+            current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n             local_id_to_def_id: SortedMap::new(),\n@@ -177,7 +177,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n+        let mut node_ids =\n+            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -193,7 +194,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -202,7 +205,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                 }\n             }\n         }\n@@ -553,7 +558,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_id,\n+                            def_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -627,7 +632,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_hir_id,\n+                            def_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -689,7 +694,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -851,7 +856,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n+        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -931,7 +936,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {"}, {"sha": "186c10065f3060b10a0b78a9a535421edae0e987", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -126,7 +126,7 @@ struct LoweringContext<'a, 'hir> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    current_hir_id_owner: LocalDefId,\n+    current_hir_id_owner: hir::OwnerId,\n     item_local_id_counter: hir::ItemLocalId,\n     local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n@@ -572,7 +572,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n         let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let current_trait_map = std::mem::take(&mut self.trait_map);\n-        let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n+        let current_owner =\n+            std::mem::replace(&mut self.current_hir_id_owner, hir::OwnerId { def_id });\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n@@ -587,7 +588,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert_eq!(_old, None);\n \n         let item = f(self);\n-        debug_assert_eq!(def_id, item.def_id());\n+        debug_assert_eq!(def_id, item.def_id().def_id);\n         // `f` should have consumed all the elements in these vectors when constructing `item`.\n         debug_assert!(self.impl_trait_defs.is_empty());\n         debug_assert!(self.impl_trait_bounds.is_empty());\n@@ -786,7 +787,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n         if self.tcx.sess.opts.unstable_opts.incremental_relative_spans {\n-            span.with_parent(Some(self.current_hir_id_owner))\n+            span.with_parent(Some(self.current_hir_id_owner.def_id))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n             span\n@@ -812,7 +813,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Fresh { param, .. } => {\n                 // Late resolution delegates to us the creation of the `LocalDefId`.\n                 let _def_id = self.create_def(\n-                    self.current_hir_id_owner,\n+                    self.current_hir_id_owner.def_id,\n                     param,\n                     DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n                 );\n@@ -1062,7 +1063,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                     let parent_def_id = self.current_hir_id_owner;\n                     let impl_trait_node_id = self.next_node_id();\n-                    self.create_def(parent_def_id, impl_trait_node_id, DefPathData::ImplTrait);\n+                    self.create_def(\n+                        parent_def_id.def_id,\n+                        impl_trait_node_id,\n+                        DefPathData::ImplTrait,\n+                    );\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let node_id = this.next_node_id();\n@@ -1154,7 +1159,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                                self.create_def(\n+                                    parent_def_id.def_id,\n+                                    node_id,\n+                                    DefPathData::AnonConst,\n+                                );\n \n                                 let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n@@ -1551,7 +1560,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?lifetimes);\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-        hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes, in_trait)\n+        hir::TyKind::OpaqueDef(\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            lifetimes,\n+            in_trait,\n+        )\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n@@ -1567,7 +1580,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: opaque_ty_id,\n+            def_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -2018,7 +2031,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: opaque_ty_def_id },\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             generic_args,\n             in_trait,\n         );"}, {"sha": "8ad40c0aa0a5d032f3e2f5b9af56a6ee3cacc189", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -932,7 +932,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let opt_suggestions = self\n                     .infcx\n                     .tcx\n-                    .typeck(path_segment.hir_id.owner)\n+                    .typeck(path_segment.hir_id.owner.def_id)\n                     .type_dependent_def_id(*hir_id)\n                     .and_then(|def_id| self.infcx.tcx.impl_of_method(def_id))\n                     .map(|def_id| self.infcx.tcx.associated_items(def_id))\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if look_at_return && hir.get_return_block(closure_id).is_some() {\n             // ...otherwise we are probably in the tail expression of the function, point at the\n             // return type.\n-            match hir.get_by_def_id(hir.get_parent_item(fn_call_id)) {\n+            match hir.get_by_def_id(hir.get_parent_item(fn_call_id).def_id) {\n                 hir::Node::Item(hir::Item { ident, kind: hir::ItemKind::Fn(sig, ..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem {\n                     ident,"}, {"sha": "43d67bfa72991eb70bd330b539c39fb3552337dc", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -281,7 +281,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+                {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -291,7 +292,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             Some(Node::TraitItem(trait_item)) => {\n                 let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did) {\n+                match tcx.hir().find_by_def_id(trait_did.def_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point"}, {"sha": "419e6c817915f0d6163ed0f93ac89bc02d41a158", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -707,7 +707,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         hir::AsyncGeneratorKind::Block => \" of async block\",\n                         hir::AsyncGeneratorKind::Closure => \" of async closure\",\n                         hir::AsyncGeneratorKind::Fn => {\n-                            let parent_item = hir.get_by_def_id(hir.get_parent_item(mir_hir_id));\n+                            let parent_item =\n+                                hir.get_by_def_id(hir.get_parent_item(mir_hir_id).def_id);\n                             let output = &parent_item\n                                 .fn_decl()\n                                 .expect(\"generator lowered from async fn should be in fn\")"}, {"sha": "6b90f2daeea3c81b17f9bf4acc58e73741b8b461", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -134,7 +134,7 @@ fn mir_borrowck<'tcx>(\n \n     let opt_closure_req = tcx\n         .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner))\n+        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n         .enter(|infcx| {\n             let input_body: &Body<'_> = &input_body.borrow();\n             let promoted: &IndexVec<_, _> = &promoted.borrow();"}, {"sha": "e97da4322fa01483536018949d0cb70b77cc07bd", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n             let typeck_results = self.maybe_typeck_results.get().or_else(|| {\n                 self.tcx\n                     .hir()\n-                    .maybe_body_owned_by(expr.hir_id.owner)\n+                    .maybe_body_owned_by(expr.hir_id.owner.def_id)\n                     .map(|body_id| self.tcx.typeck_body(body_id))\n             });\n "}, {"sha": "018b7cc5d9dfeaf3be527dfdd4a16d5d9a4a09ca", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-pub(crate) use crate::hir_id::{HirId, ItemLocalId};\n+pub(crate) use crate::hir_id::{HirId, ItemLocalId, OwnerId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n \n@@ -2206,14 +2206,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2224,7 +2224,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2235,7 +2235,7 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n@@ -2270,22 +2270,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2297,7 +2297,7 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n@@ -2888,14 +2888,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2905,7 +2905,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2915,7 +2915,7 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n@@ -3132,14 +3132,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -3160,7 +3160,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3169,7 +3169,7 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n@@ -3263,7 +3263,7 @@ impl<'hir> OwnerNode<'hir> {\n         Node::generics(self.into())\n     }\n \n-    pub fn def_id(self) -> LocalDefId {\n+    pub fn def_id(self) -> OwnerId {\n         match self {\n             OwnerNode::Item(Item { def_id, .. })\n             | OwnerNode::TraitItem(TraitItem { def_id, .. })"}, {"sha": "752f760ea9719395fcf8982ea0600b8f45aa2fc4", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1,6 +1,43 @@\n-use crate::def_id::{LocalDefId, CRATE_DEF_ID};\n+use crate::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_span::{def_id::DefPathHash, HashStableContext};\n use std::fmt;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub struct OwnerId {\n+    pub def_id: LocalDefId,\n+}\n+\n+impl From<OwnerId> for HirId {\n+    fn from(owner: OwnerId) -> HirId {\n+        HirId { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n+impl OwnerId {\n+    #[inline]\n+    pub fn to_def_id(self) -> DefId {\n+        self.def_id.to_def_id()\n+    }\n+}\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for OwnerId {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for OwnerId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        hcx.def_path_hash(self.to_def_id())\n+    }\n+}\n+\n /// Uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the `LocalDefId` of the directly enclosing\n /// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n@@ -15,22 +52,23 @@ use std::fmt;\n #[derive(Encodable, Decodable, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub struct HirId {\n-    pub owner: LocalDefId,\n+    pub owner: OwnerId,\n     pub local_id: ItemLocalId,\n }\n \n impl HirId {\n     /// Signal local id which should never be used.\n-    pub const INVALID: HirId = HirId { owner: CRATE_DEF_ID, local_id: ItemLocalId::INVALID };\n+    pub const INVALID: HirId =\n+        HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::INVALID };\n \n     #[inline]\n-    pub fn expect_owner(self) -> LocalDefId {\n+    pub fn expect_owner(self) -> OwnerId {\n         assert_eq!(self.local_id.index(), 0);\n         self.owner\n     }\n \n     #[inline]\n-    pub fn as_owner(self) -> Option<LocalDefId> {\n+    pub fn as_owner(self) -> Option<OwnerId> {\n         if self.local_id.index() == 0 { Some(self.owner) } else { None }\n     }\n \n@@ -41,11 +79,14 @@ impl HirId {\n \n     #[inline]\n     pub fn make_owner(owner: LocalDefId) -> Self {\n-        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+        Self { owner: OwnerId { def_id: owner }, local_id: ItemLocalId::from_u32(0) }\n     }\n \n     pub fn index(self) -> (usize, usize) {\n-        (rustc_index::vec::Idx::index(self.owner), rustc_index::vec::Idx::index(self.local_id))\n+        (\n+            rustc_index::vec::Idx::index(self.owner.def_id),\n+            rustc_index::vec::Idx::index(self.local_id),\n+        )\n     }\n }\n \n@@ -94,4 +135,7 @@ impl ItemLocalId {\n }\n \n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_ID`.\n-pub const CRATE_HIR_ID: HirId = HirId { owner: CRATE_DEF_ID, local_id: ItemLocalId::from_u32(0) };\n+pub const CRATE_HIR_ID: HirId =\n+    HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::from_u32(0) };\n+\n+pub const CRATE_OWNER_ID: OwnerId = OwnerId { def_id: CRATE_DEF_ID };"}, {"sha": "06b7a65662e7cbe5b3573cf176d8aefbfbe0fcd4", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -20,7 +20,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        let def_path_hash = self.owner.to_stable_hash_key(hcx);\n+        let def_path_hash = self.owner.def_id.to_stable_hash_key(hcx);\n         (def_path_hash, self.local_id)\n     }\n }\n@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "09163e4f25f3ccb9e5bfd60e439ede025396b1a9", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -149,19 +149,19 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            dirty_clean_visitor.check_item(id.def_id);\n+            dirty_clean_visitor.check_item(id.def_id.def_id);\n         }\n \n         let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };"}, {"sha": "0208c364e4388c221bd9251fcc11736649c7bf05", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -2440,7 +2440,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n                         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner);\n+                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner.def_id);\n                         let bounds =\n                             ast_generics.and_then(|g| g.bounds_span_for_suggestions(def_id));\n                         // `sp` only covers `T`, change it so that it covers"}, {"sha": "2ccfcd51b1152a20165e76920a40eada4631f93e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -185,8 +185,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n-                let parent_id = tcx.hir().local_def_id_to_hir_id(parent_id);\n-                if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id) {\n+                if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n@@ -415,7 +414,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+                {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -425,7 +425,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             Some(Node::TraitItem(trait_item)) => {\n                 let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did) {\n+                match tcx.hir().find_by_def_id(trait_did.def_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point"}, {"sha": "efc9c1ca46fe49da56b2f5fb1352c7a698643dd9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -16,6 +16,7 @@ use rustc_data_structures::undo_log::Rollback;\n use rustc_data_structures::unify as ut;\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::hir_id::OwnerId;\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n@@ -583,9 +584,9 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_typeck_results` with fresh `TypeckResults`.\n     /// Will also change the scope for opaque type defining use checks to the given owner.\n-    pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {\n+    pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: OwnerId) -> Self {\n         self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n-        self.with_opaque_type_inference(DefiningAnchor::Bind(table_owner))\n+        self.with_opaque_type_inference(DefiningAnchor::Bind(table_owner.def_id))\n     }\n \n     /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,"}, {"sha": "9bf92f08aa54b63095ff0efd3fd78879e6275050", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -616,7 +616,7 @@ fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hi\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n-        hir_id = tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(hir_id));\n+        hir_id = tcx.hir().get_parent_item(hir_id).into();\n     }\n     // Syntactically, we are allowed to define the concrete type if:\n     let res = hir_id == scope;"}, {"sha": "2b1b931b7326b9e2b15e5a7fff78b12875b96723", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1,4 +1,3 @@\n-use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -10,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n     for id in tcx.hir().items() {\n         let attrs = finder.tcx.hir().attrs(id.hir_id());\n         if finder.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n-            finder.decls = Some(id.def_id);\n+            finder.decls = Some(id.def_id.def_id);\n         }\n     }\n \n@@ -19,7 +18,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n \n struct Finder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    decls: Option<hir::def_id::LocalDefId>,\n+    decls: Option<LocalDefId>,\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "5fba1d3d3c7acc2ac835b0f4941e0193eae29bb7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -606,7 +606,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if cx.tcx.visibility(it.def_id)\n                     == ty::Visibility::Restricted(\n-                        cx.tcx.parent_module_from_def_id(it.def_id).to_def_id(),\n+                        cx.tcx.parent_module_from_def_id(it.def_id.def_id).to_def_id(),\n                     )\n                 {\n                     return;\n@@ -627,13 +627,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, it.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, it.def_id.def_id, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, trait_item.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, trait_item.def_id.def_id, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -661,12 +661,12 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         }\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, impl_item.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, impl_item.def_id.def_id, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, foreign_item.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, foreign_item.def_id.def_id, article, desc);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, sf: &hir::FieldDef<'_>) {\n@@ -719,7 +719,7 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id) {\n+        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n@@ -809,7 +809,7 @@ impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.def_id) {\n+        if !cx.access_levels.is_reachable(item.def_id.def_id) {\n             return;\n         }\n \n@@ -836,7 +836,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.def_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.def_id.def_id) {\n             cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n                 lint.build(fluent::lint::builtin_missing_debug_impl)\n                     .set_arg(\"debug\", cx.tcx.def_path_str(debug))\n@@ -1206,7 +1206,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n                                 Some(generics),\n-                                cx.tcx.hir().get_generics(it.id.def_id).unwrap(),\n+                                cx.tcx.hir().get_generics(it.id.def_id.def_id).unwrap(),\n                                 it.span,\n                             );\n                         }\n@@ -1389,11 +1389,11 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n         if let hir::ItemKind::Use(_, hir::UseKind::ListStem) = &item.kind {\n             return;\n         }\n-        self.perform_lint(cx, \"item\", item.def_id, item.vis_span, true);\n+        self.perform_lint(cx, \"item\", item.def_id.def_id, item.vis_span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n-        self.perform_lint(cx, \"item\", foreign_item.def_id, foreign_item.vis_span, true);\n+        self.perform_lint(cx, \"item\", foreign_item.def_id.def_id, foreign_item.vis_span, true);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n@@ -1404,7 +1404,7 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // Only lint inherent impl items.\n         if cx.tcx.associated_item(impl_item.def_id).trait_item_def_id.is_none() {\n-            self.perform_lint(cx, \"item\", impl_item.def_id, impl_item.vis_span, false);\n+            self.perform_lint(cx, \"item\", impl_item.def_id.def_id, impl_item.vis_span, false);\n         }\n     }\n }\n@@ -1841,7 +1841,7 @@ declare_lint! {\n }\n \n pub struct UnnameableTestItems {\n-    boundary: Option<LocalDefId>, // Id of the item under which things are not nameable\n+    boundary: Option<hir::OwnerId>, // Id of the item under which things are not nameable\n     items_nameable: bool,\n }\n \n@@ -2138,7 +2138,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n-        let def_id = item.def_id;\n+        let def_id = item.def_id.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind"}, {"sha": "cbab56f2066f01ad8b23ed774920b6b3f97d3b10", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1048,7 +1048,7 @@ impl<'tcx> LateContext<'tcx> {\n                 .filter(|typeck_results| typeck_results.hir_owner == id.owner)\n                 .or_else(|| {\n                     if self.tcx.has_typeck_results(id.owner.to_def_id()) {\n-                        Some(self.tcx.typeck(id.owner))\n+                        Some(self.tcx.typeck(id.owner.def_id))\n                     } else {\n                         None\n                     }"}, {"sha": "9abb5c74895d0e61996f29059379f03a9fd98557", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -382,7 +382,7 @@ impl<'tcx> Collector<'tcx> {\n                             let link_ordinal_attr = self\n                                 .tcx\n                                 .hir()\n-                                .attrs(self.tcx.hir().local_def_id_to_hir_id(child_item.id.def_id))\n+                                .attrs(child_item.id.def_id.into())\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();"}, {"sha": "7cf00ca41fefb5990b5fd5e0d331dc05f8957df9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1217,14 +1217,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // from name resolution point of view.\n                         hir::ItemKind::ForeignMod { items, .. } => {\n                             for foreign_item in items {\n-                                yield foreign_item.id.def_id.local_def_index;\n+                                yield foreign_item.id.def_id.def_id.local_def_index;\n                             }\n                         }\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n                         _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n-                            yield item_id.def_id.local_def_index;\n+                            yield item_id.def_id.def_id.local_def_index;\n                         }\n                         _ => continue,\n                     }\n@@ -1446,7 +1446,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.def_id, m);\n+                return self.encode_info_for_mod(item.def_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1840,7 +1840,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         for id in tcx.hir().items() {\n             if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-                if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id.to_def_id()) {\n+                if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id) {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n@@ -1850,7 +1850,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     fx_hash_map\n                         .entry(trait_ref.def_id)\n                         .or_default()\n-                        .push((id.def_id.local_def_index, simplified_self_ty));\n+                        .push((id.def_id.def_id.local_def_index, simplified_self_ty));\n                 }\n             }\n         }"}, {"sha": "ac106764c0217e1b6f30c680cdf6a924cbb30597", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -62,7 +62,7 @@ use crate::ty::TyCtxt;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::definitions::DefPathHash;\n-use rustc_hir::HirId;\n+use rustc_hir::{HirId, OwnerId};\n use rustc_query_system::dep_graph::FingerprintStyle;\n use rustc_span::symbol::Symbol;\n use std::hash::Hash;\n@@ -355,6 +355,28 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n     }\n }\n \n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for OwnerId {\n+    #[inline(always)]\n+    fn fingerprint_style() -> FingerprintStyle {\n+        FingerprintStyle::DefPathHash\n+    }\n+\n+    #[inline(always)]\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n+        self.to_def_id().to_fingerprint(tcx)\n+    }\n+\n+    #[inline(always)]\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        self.to_def_id().to_debug_str(tcx)\n+    }\n+\n+    #[inline(always)]\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| OwnerId { def_id: id.expect_local() })\n+    }\n+}\n+\n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n     #[inline(always)]\n     fn fingerprint_style() -> FingerprintStyle {"}, {"sha": "b5f7b26ea7ab6b839e0d0917aad0fbc47aae2ba1", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -93,7 +93,7 @@ pub struct ParentOwnerIterator<'hir> {\n }\n \n impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n-    type Item = (LocalDefId, OwnerNode<'hir>);\n+    type Item = (OwnerId, OwnerNode<'hir>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id.local_id.index() != 0 {\n@@ -107,13 +107,13 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n         }\n         loop {\n             // There are nodes that do not have entries, so we need to skip them.\n-            let parent_id = self.map.def_key(self.current_id.owner).parent;\n+            let parent_id = self.map.def_key(self.current_id.owner.def_id).parent;\n \n-            let parent_id = parent_id.map_or(CRATE_HIR_ID.owner, |local_def_index| {\n+            let parent_id = parent_id.map_or(CRATE_OWNER_ID, |local_def_index| {\n                 let def_id = LocalDefId { local_def_index };\n                 self.map.local_def_id_to_hir_id(def_id).owner\n             });\n-            self.current_id = HirId::make_owner(parent_id);\n+            self.current_id = HirId::make_owner(parent_id.def_id);\n \n             // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n             if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n@@ -131,7 +131,7 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn root_module(self) -> &'hir Mod<'hir> {\n-        match self.tcx.hir_owner(CRATE_DEF_ID).map(|o| o.node) {\n+        match self.tcx.hir_owner(CRATE_OWNER_ID).map(|o| o.node) {\n             Some(OwnerNode::Crate(item)) => item,\n             _ => bug!(),\n         }\n@@ -186,7 +186,7 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n         if hir_id.local_id == ItemLocalId::new(0) {\n-            Some(hir_id.owner)\n+            Some(hir_id.owner.def_id)\n         } else {\n             self.tcx\n                 .hir_owner_nodes(hir_id.owner)\n@@ -352,7 +352,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_generics(self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n-        let node = self.tcx.hir_owner(id)?;\n+        let node = self.tcx.hir_owner(OwnerId { def_id: id })?;\n         node.node.generics()\n     }\n \n@@ -532,7 +532,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n-        match self.tcx.hir_owner(module).map(|o| o.node) {\n+        match self.tcx.hir_owner(hir_id.owner).map(|o| o.node) {\n             Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n                 (m, span, hir_id)\n             }\n@@ -622,14 +622,14 @@ impl<'hir> Map<'hir> {\n     pub fn for_each_module(self, mut f: impl FnMut(LocalDefId)) {\n         let crate_items = self.tcx.hir_crate_items(());\n         for module in crate_items.submodules.iter() {\n-            f(*module)\n+            f(module.def_id)\n         }\n     }\n \n     #[inline]\n     pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + Sync + Send) {\n         let crate_items = self.tcx.hir_crate_items(());\n-        par_for_each_in(&crate_items.submodules[..], |module| f(*module))\n+        par_for_each_in(&crate_items.submodules[..], |module| f(module.def_id))\n     }\n \n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n@@ -721,27 +721,27 @@ impl<'hir> Map<'hir> {\n         None\n     }\n \n-    /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `OwnerId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent_item(self, hir_id: HirId) -> LocalDefId {\n+    pub fn get_parent_item(self, hir_id: HirId) -> OwnerId {\n         if let Some((def_id, _node)) = self.parent_owner_iter(hir_id).next() {\n             def_id\n         } else {\n-            CRATE_DEF_ID\n+            CRATE_OWNER_ID\n         }\n     }\n \n-    /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `OwnerId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub(super) fn get_module_parent_node(self, hir_id: HirId) -> LocalDefId {\n+    pub(super) fn get_module_parent_node(self, hir_id: HirId) -> OwnerId {\n         for (def_id, node) in self.parent_owner_iter(hir_id) {\n             if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return def_id;\n             }\n         }\n-        CRATE_DEF_ID\n+        CRATE_OWNER_ID\n     }\n \n     /// When on an if expression, a match arm tail expression or a match arm, give back\n@@ -814,30 +814,30 @@ impl<'hir> Map<'hir> {\n         }\n         bug!(\n             \"expected foreign mod or inlined parent, found {}\",\n-            self.node_to_string(HirId::make_owner(parent))\n+            self.node_to_string(HirId::make_owner(parent.def_id))\n         )\n     }\n \n-    pub fn expect_owner(self, id: LocalDefId) -> OwnerNode<'hir> {\n+    pub fn expect_owner(self, id: OwnerId) -> OwnerNode<'hir> {\n         self.tcx.hir_owner(id).unwrap_or_else(|| bug!(\"expected owner for {:?}\", id)).node\n     }\n \n     pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {\n-        match self.tcx.hir_owner(id) {\n+        match self.tcx.hir_owner(OwnerId { def_id: id }) {\n             Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n     pub fn expect_impl_item(self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n-        match self.tcx.hir_owner(id) {\n+        match self.tcx.hir_owner(OwnerId { def_id: id }) {\n             Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n     pub fn expect_trait_item(self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n-        match self.tcx.hir_owner(id) {\n+        match self.tcx.hir_owner(OwnerId { def_id: id }) {\n             Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n@@ -850,11 +850,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_foreign_item(self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n+    pub fn expect_foreign_item(self, id: OwnerId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => {\n-                bug!(\"expected foreign item, found {}\", self.node_to_string(HirId::make_owner(id)))\n+                bug!(\n+                    \"expected foreign item, found {}\",\n+                    self.node_to_string(HirId::make_owner(id.def_id))\n+                )\n             }\n         }\n     }\n@@ -1290,7 +1293,7 @@ pub(crate) fn hir_crate_items(tcx: TyCtxt<'_>, _: ()) -> ModuleItems {\n     // A \"crate collector\" and \"module collector\" start at a\n     // module item (the former starts at the crate root) but only\n     // the former needs to collect it. ItemCollector does not do this for us.\n-    collector.submodules.push(CRATE_DEF_ID);\n+    collector.submodules.push(CRATE_OWNER_ID);\n     tcx.hir().walk_toplevel_module(&mut collector);\n \n     let ItemCollector {\n@@ -1318,7 +1321,7 @@ struct ItemCollector<'tcx> {\n     // otherwise it collects items in some module.\n     crate_collector: bool,\n     tcx: TyCtxt<'tcx>,\n-    submodules: Vec<LocalDefId>,\n+    submodules: Vec<OwnerId>,\n     items: Vec<ItemId>,\n     trait_items: Vec<TraitItemId>,\n     impl_items: Vec<ImplItemId>,\n@@ -1350,7 +1353,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_item(&mut self, item: &'hir Item<'hir>) {\n         if associated_body(Node::Item(item)).is_some() {\n-            self.body_owners.push(item.def_id);\n+            self.body_owners.push(item.def_id.def_id);\n         }\n \n         self.items.push(item.item_id());\n@@ -1386,7 +1389,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n         if associated_body(Node::TraitItem(item)).is_some() {\n-            self.body_owners.push(item.def_id);\n+            self.body_owners.push(item.def_id.def_id);\n         }\n \n         self.trait_items.push(item.trait_item_id());\n@@ -1395,7 +1398,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n         if associated_body(Node::ImplItem(item)).is_some() {\n-            self.body_owners.push(item.def_id);\n+            self.body_owners.push(item.def_id.def_id);\n         }\n \n         self.impl_items.push(item.impl_item_id());"}, {"sha": "1ce98a03c8a6ccc2971a8ec845b0798d1c79a518", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n /// bodies.  The Ids are in visitor order.  This is used to partition a pass between modules.\n #[derive(Debug, HashStable, Encodable, Decodable)]\n pub struct ModuleItems {\n-    submodules: Box<[LocalDefId]>,\n+    submodules: Box<[OwnerId]>,\n     items: Box<[ItemId]>,\n     trait_items: Box<[TraitItemId]>,\n     impl_items: Box<[ImplItemId]>,\n@@ -67,10 +67,10 @@ impl ModuleItems {\n     pub fn definitions(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n         self.items\n             .iter()\n-            .map(|id| id.def_id)\n-            .chain(self.trait_items.iter().map(|id| id.def_id))\n-            .chain(self.impl_items.iter().map(|id| id.def_id))\n-            .chain(self.foreign_items.iter().map(|id| id.def_id))\n+            .map(|id| id.def_id.def_id)\n+            .chain(self.trait_items.iter().map(|id| id.def_id.def_id))\n+            .chain(self.impl_items.iter().map(|id| id.def_id.def_id))\n+            .chain(self.foreign_items.iter().map(|id| id.def_id.def_id))\n     }\n \n     pub fn par_items(&self, f: impl Fn(ItemId) + Send + Sync) {\n@@ -97,7 +97,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn parent_module(self, id: HirId) -> LocalDefId {\n-        self.parent_module_from_def_id(id.owner)\n+        self.parent_module_from_def_id(id.owner.def_id)\n     }\n \n     pub fn impl_subject(self, def_id: DefId) -> ImplSubject<'tcx> {\n@@ -110,13 +110,13 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.get_module_parent_node(hir.local_def_id_to_hir_id(id))\n+        hir.get_module_parent_node(hir.local_def_id_to_hir_id(id)).def_id\n     };\n     providers.hir_crate_items = map::hir_crate_items;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.hir_crate(()).owners.get(id)?.as_owner()?;\n+        let owner = tcx.hir_crate(()).owners.get(id.def_id)?.as_owner()?;\n         let node = owner.node();\n         Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n     };\n@@ -128,21 +128,24 @@ pub fn provide(providers: &mut Providers) {\n             MaybeOwner::NonOwner(hir_id) => hir_id,\n         }\n     };\n-    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].map(|i| &i.nodes);\n+    providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id.def_id].map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n         // Accessing the local_parent is ok since its value is hashed as part of `id`'s DefPathHash.\n-        tcx.opt_local_parent(id).map_or(CRATE_HIR_ID, |parent| {\n+        tcx.opt_local_parent(id.def_id).map_or(CRATE_HIR_ID, |parent| {\n             let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent);\n-            if let Some(local_id) =\n-                tcx.hir_crate(()).owners[parent_hir_id.owner].unwrap().parenting.get(&id)\n+            if let Some(local_id) = tcx.hir_crate(()).owners[parent_hir_id.owner.def_id]\n+                .unwrap()\n+                .parenting\n+                .get(&id.def_id)\n             {\n                 parent_hir_id.local_id = *local_id;\n             }\n             parent_hir_id\n         })\n     };\n-    providers.hir_attrs =\n-        |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n+    providers.hir_attrs = |tcx, id| {\n+        tcx.hir_crate(()).owners[id.def_id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs)\n+    };\n     providers.source_span =\n         |tcx, def_id| tcx.resolutions(()).source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n     providers.def_span = |tcx, def_id| {\n@@ -177,6 +180,7 @@ pub fn provide(providers: &mut Providers) {\n         let id = id.expect_local();\n         tcx.resolutions(()).expn_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n     };\n-    providers.in_scope_traits_map =\n-        |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map(|owner_info| &owner_info.trait_map);\n+    providers.in_scope_traits_map = |tcx, id| {\n+        tcx.hir_crate(()).owners[id.def_id].as_owner().map(|owner_info| &owner_info.trait_map)\n+    };\n }"}, {"sha": "c3bf1c717d9afcbe9f811e0d4a64b03fd1421019", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -3,8 +3,8 @@\n use crate::ty;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::ItemLocalId;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{ItemLocalId, OwnerId};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n@@ -49,7 +49,7 @@ pub enum ObjectLifetimeDefault {\n pub struct ResolveLifetimes {\n     /// Maps from every use of a named (not anonymous) lifetime to a\n     /// `Region` describing how that region is bound\n-    pub defs: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Region>>,\n+    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Region>>,\n \n-    pub late_bound_vars: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n+    pub late_bound_vars: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }"}, {"sha": "fdda62719ee10c4a2fc9e7ffa64076ef6367b93d", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -182,7 +182,7 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => def.def_id().as_local(),\n             MonoItem::Static(def_id) => def_id.as_local(),\n-            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id),\n         }\n         .map(|def_id| tcx.def_span(def_id))\n     }\n@@ -373,7 +373,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),\n-                    MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.index()),\n+                    MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id.index()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "eed44240f83572f4a8ba6a4bd393f204d11350ff", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -73,7 +73,7 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner(key: LocalDefId) -> Option<crate::hir::Owner<'tcx>> {\n+    query hir_owner(key: hir::OwnerId) -> Option<crate::hir::Owner<'tcx>> {\n         desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -89,23 +89,23 @@ rustc_queries! {\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner_parent(key: LocalDefId) -> hir::HirId {\n+    query hir_owner_parent(key: hir::OwnerId) -> hir::HirId {\n         desc { |tcx| \"HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_owner_nodes(key: LocalDefId) -> hir::MaybeOwner<&'tcx hir::OwnerNodes<'tcx>> {\n+    query hir_owner_nodes(key: hir::OwnerId) -> hir::MaybeOwner<&'tcx hir::OwnerNodes<'tcx>> {\n         desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR attributes inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query hir_attrs(key: LocalDefId) -> &'tcx hir::AttributeMap<'tcx> {\n+    query hir_attrs(key: hir::OwnerId) -> &'tcx hir::AttributeMap<'tcx> {\n         desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -1404,7 +1404,7 @@ rustc_queries! {\n     query specializes(_: (DefId, DefId)) -> bool {\n         desc { \"computing whether impls specialize one another\" }\n     }\n-    query in_scope_traits_map(_: LocalDefId)\n+    query in_scope_traits_map(_: hir::OwnerId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Box<[TraitCandidate]>>> {\n         desc { \"traits in scope at a block\" }\n     }\n@@ -1419,7 +1419,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query check_well_formed(key: LocalDefId) -> () {\n+    query check_well_formed(key: hir::OwnerId) -> () {\n         desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n@@ -1586,7 +1586,7 @@ rustc_queries! {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n-    query named_region_map(_: LocalDefId) ->\n+    query named_region_map(_: hir::OwnerId) ->\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n@@ -1602,7 +1602,7 @@ rustc_queries! {\n         desc { \"looking up lifetime defaults for generic parameter `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }\n-    query late_bound_vars_map(_: LocalDefId)\n+    query late_bound_vars_map(_: hir::OwnerId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {\n         desc { \"looking up late bound vars\" }\n     }"}, {"sha": "69bb9bb6fe04e32dad943eeccb0ecab847aaa604", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -40,6 +40,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n+use rustc_hir::hir_id::OwnerId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -289,7 +290,7 @@ pub struct CommonConsts<'tcx> {\n }\n \n pub struct LocalTableInContext<'a, V> {\n-    hir_owner: LocalDefId,\n+    hir_owner: OwnerId,\n     data: &'a ItemLocalMap<V>,\n }\n \n@@ -301,15 +302,15 @@ pub struct LocalTableInContext<'a, V> {\n /// would result in lookup errors, or worse, in silently wrong data being\n /// stored/returned.\n #[inline]\n-fn validate_hir_id_for_typeck_results(hir_owner: LocalDefId, hir_id: hir::HirId) {\n+fn validate_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n     if hir_id.owner != hir_owner {\n         invalid_hir_id_for_typeck_results(hir_owner, hir_id);\n     }\n }\n \n #[cold]\n #[inline(never)]\n-fn invalid_hir_id_for_typeck_results(hir_owner: LocalDefId, hir_id: hir::HirId) {\n+fn invalid_hir_id_for_typeck_results(hir_owner: OwnerId, hir_id: hir::HirId) {\n     ty::tls::with(|tcx| {\n         bug!(\n             \"node {} with HirId::owner {:?} cannot be placed in TypeckResults with hir_owner {:?}\",\n@@ -345,7 +346,7 @@ impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n }\n \n pub struct LocalTableInContextMut<'a, V> {\n-    hir_owner: LocalDefId,\n+    hir_owner: OwnerId,\n     data: &'a mut ItemLocalMap<V>,\n }\n \n@@ -417,7 +418,7 @@ pub struct GeneratorDiagnosticData<'tcx> {\n #[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct TypeckResults<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n-    pub hir_owner: LocalDefId,\n+    pub hir_owner: OwnerId,\n \n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n@@ -592,7 +593,7 @@ pub struct TypeckResults<'tcx> {\n }\n \n impl<'tcx> TypeckResults<'tcx> {\n-    pub fn new(hir_owner: LocalDefId) -> TypeckResults<'tcx> {\n+    pub fn new(hir_owner: OwnerId) -> TypeckResults<'tcx> {\n         TypeckResults {\n             hir_owner,\n             type_dependent_defs: Default::default(),\n@@ -1726,7 +1727,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn local_visibility(self, def_id: LocalDefId) -> Visibility {\n-        self.visibility(def_id.to_def_id()).expect_local()\n+        self.visibility(def_id).expect_local()\n     }\n }\n \n@@ -2907,7 +2908,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner).map_or(false, |set| {\n+        self.is_late_bound_map(id.owner.def_id).map_or(false, |set| {\n             let def_id = self.hir().local_def_id(id);\n             set.contains(&def_id)\n         })"}, {"sha": "52f16ad88f693017be3ebf573ce29ad9d0ac1132", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -861,7 +861,7 @@ fn foo(&self) -> Self::T { String::new() }\n         // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n         // `expected` and point at it.\n         let parent_id = self.hir().get_parent_item(hir_id);\n-        let item = self.hir().find_by_def_id(parent_id);\n+        let item = self.hir().find_by_def_id(parent_id.def_id);\n         debug!(\"expected_projection parent item {:?}\", item);\n         match item {\n             Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {"}, {"sha": "169da348a293aedb55f49a1b40c51dfde43a8225", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -44,6 +44,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n+use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n@@ -336,7 +337,7 @@ macro_rules! define_callbacks {\n rustc_query_append! { define_callbacks! }\n \n mod sealed {\n-    use super::{DefId, LocalDefId};\n+    use super::{DefId, LocalDefId, OwnerId};\n \n     /// An analogue of the `Into` trait that's intended only for query parameters.\n     ///\n@@ -366,6 +367,13 @@ mod sealed {\n             self.to_def_id()\n         }\n     }\n+\n+    impl IntoQueryParam<DefId> for OwnerId {\n+        #[inline(always)]\n+        fn into_query_param(self) -> DefId {\n+            self.to_def_id()\n+        }\n+    }\n }\n \n use sealed::IntoQueryParam;"}, {"sha": "5cd7a7f760f5d334bd3add2df2283073d97e708c", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1246,15 +1246,15 @@ impl<'v> RootCollector<'_, 'v> {\n                 }\n             }\n             DefKind::Fn => {\n-                self.push_if_root(id.def_id);\n+                self.push_if_root(id.def_id.def_id);\n             }\n             _ => {}\n         }\n     }\n \n     fn process_impl_item(&mut self, id: hir::ImplItemId) {\n         if matches!(self.tcx.def_kind(id.def_id), DefKind::AssocFn) {\n-            self.push_if_root(id.def_id);\n+            self.push_if_root(id.def_id.def_id);\n         }\n     }\n "}, {"sha": "a21521ff68b190c0e56795895a90535a1dc7cbcf", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -11,9 +11,11 @@ use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID};\n+use rustc_hir::{\n+    self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID, CRATE_OWNER_ID,\n+};\n use rustc_hir::{MethodKind, Target};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n@@ -35,7 +37,7 @@ pub(crate) fn target_from_impl_item<'tcx>(\n     match impl_item.kind {\n         hir::ImplItemKind::Const(..) => Target::AssocConst,\n         hir::ImplItemKind::Fn(..) => {\n-            let parent_def_id = tcx.hir().get_parent_item(impl_item.hir_id());\n+            let parent_def_id = tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n             let containing_item = tcx.hir().expect_item(parent_def_id);\n             let containing_impl_is_for_trait = match &containing_item.kind {\n                 hir::ItemKind::Impl(impl_) => impl_.of_trait.is_some(),\n@@ -640,7 +642,7 @@ impl CheckAttrVisitor<'_> {\n         let span = meta.span();\n         if let Some(location) = match target {\n             Target::AssocTy => {\n-                let parent_def_id = self.tcx.hir().get_parent_item(hir_id);\n+                let parent_def_id = self.tcx.hir().get_parent_item(hir_id).def_id;\n                 let containing_item = self.tcx.hir().expect_item(parent_def_id);\n                 if Target::from_item(containing_item) == Target::Impl {\n                     Some(\"type alias in implementation block\")\n@@ -649,7 +651,7 @@ impl CheckAttrVisitor<'_> {\n                 }\n             }\n             Target::AssocConst => {\n-                let parent_def_id = self.tcx.hir().get_parent_item(hir_id);\n+                let parent_def_id = self.tcx.hir().get_parent_item(hir_id).def_id;\n                 let containing_item = self.tcx.hir().expect_item(parent_def_id);\n                 // We can't link to trait impl's consts.\n                 let err = \"associated constant in trait implementation block\";\n@@ -878,7 +880,7 @@ impl CheckAttrVisitor<'_> {\n             self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n                 let mut err = lint.build(fluent::passes::attr_crate_level);\n                 if attr.style == AttrStyle::Outer\n-                    && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID\n+                    && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n                 {\n                     if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n                         src.insert(1, '!');"}, {"sha": "e9d71bc93ac109f096ead1d2a9da66d4ce1d1288", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -317,7 +317,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n             Node::ImplItem(impl_item) => {\n-                let item = self.tcx.local_parent(impl_item.def_id);\n+                let item = self.tcx.local_parent(impl_item.def_id.def_id);\n                 if self.tcx.impl_trait_ref(item).is_none() {\n                     //// If it's a type whose items are live, then it's live, too.\n                     //// This is done to handle the case where, for example, the static\n@@ -374,7 +374,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n             if has_repr_c || (f.is_positional() && has_repr_simd) {\n                 return Some(def_id);\n             }\n-            if !tcx.visibility(f.hir_id.owner).is_public() {\n+            if !tcx.visibility(f.hir_id.owner.def_id).is_public() {\n                 return None;\n             }\n             if tcx.visibility(def_id).is_public() { Some(def_id) } else { None }\n@@ -528,7 +528,7 @@ fn check_item<'tcx>(\n ) {\n     let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.hir_id());\n     if allow_dead_code {\n-        worklist.push(id.def_id);\n+        worklist.push(id.def_id.def_id);\n     }\n \n     match tcx.def_kind(id.def_id) {\n@@ -554,7 +554,7 @@ fn check_item<'tcx>(\n             let of_trait = tcx.impl_trait_ref(id.def_id);\n \n             if of_trait.is_some() {\n-                worklist.push(id.def_id);\n+                worklist.push(id.def_id.def_id);\n             }\n \n             // get DefIds from another query\n@@ -577,12 +577,12 @@ fn check_item<'tcx>(\n             if let hir::ItemKind::Struct(ref variant_data, _) = item.kind\n                 && let Some(ctor_hir_id) = variant_data.ctor_hir_id()\n             {\n-                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.def_id);\n+                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.def_id.def_id);\n             }\n         }\n         DefKind::GlobalAsm => {\n             // global_asm! is always live.\n-            worklist.push(id.def_id);\n+            worklist.push(id.def_id.def_id);\n         }\n         _ => {}\n     }\n@@ -595,7 +595,7 @@ fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id:\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n             && has_allow_dead_code_or_lang_attr(tcx, trait_item.hir_id())\n         {\n-            worklist.push(trait_item.def_id);\n+            worklist.push(trait_item.def_id.def_id);\n         }\n     }\n }\n@@ -608,7 +608,7 @@ fn check_foreign_item<'tcx>(\n     if matches!(tcx.def_kind(id.def_id), DefKind::Static(_) | DefKind::Fn)\n         && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n     {\n-        worklist.push(id.def_id);\n+        worklist.push(id.def_id.def_id);\n     }\n }\n \n@@ -871,13 +871,13 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let module_items = tcx.hir_module_items(module);\n \n     for item in module_items.items() {\n-        if !live_symbols.contains(&item.def_id) {\n-            let parent = tcx.local_parent(item.def_id);\n+        if !live_symbols.contains(&item.def_id.def_id) {\n+            let parent = tcx.local_parent(item.def_id.def_id);\n             if parent != module && !live_symbols.contains(&parent) {\n                 // We already have diagnosed something.\n                 continue;\n             }\n-            visitor.check_definition(item.def_id);\n+            visitor.check_definition(item.def_id.def_id);\n             continue;\n         }\n \n@@ -926,16 +926,21 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n                 visitor.warn_dead_fields_and_variants(def_id, \"read\", dead_fields, is_positional)\n             }\n \n-            visitor.warn_dead_fields_and_variants(item.def_id, \"constructed\", dead_variants, false);\n+            visitor.warn_dead_fields_and_variants(\n+                item.def_id.def_id,\n+                \"constructed\",\n+                dead_variants,\n+                false,\n+            );\n         }\n     }\n \n     for impl_item in module_items.impl_items() {\n-        visitor.check_definition(impl_item.def_id);\n+        visitor.check_definition(impl_item.def_id.def_id);\n     }\n \n     for foreign_item in module_items.foreign_items() {\n-        visitor.check_definition(foreign_item.def_id);\n+        visitor.check_definition(foreign_item.def_id.def_id);\n     }\n \n     // We do not warn trait items."}, {"sha": "e428d9293db17087d2355265c5ddf67a2bfaa375", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -74,19 +74,19 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n     }\n \n     for id in crate_items.trait_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n     }\n \n     for id in crate_items.impl_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n     }\n \n     for id in crate_items.foreign_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n     }\n \n     diagnostic_items"}, {"sha": "eec37d19a88319d81c6ee35e8c493eb133a2b601", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -82,7 +82,7 @@ fn err_if_attr_found(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol, details:\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n-    let at_root = ctxt.tcx.opt_local_parent(id.def_id) == Some(CRATE_DEF_ID);\n+    let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n@@ -99,7 +99,7 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((id.def_id, ctxt.tcx.def_span(id.def_id.to_def_id())));\n+                ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n                 struct_span_err!(\n                     ctxt.tcx.sess,\n@@ -118,11 +118,11 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n         EntryPointType::Start => {\n             err_if_attr_found(ctxt, id, sym::unix_sigpipe, \"can only be used on `fn main()`\");\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((id.def_id, ctxt.tcx.def_span(id.def_id.to_def_id())));\n+                ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n             } else {\n                 struct_span_err!(\n                     ctxt.tcx.sess,\n-                    ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    ctxt.tcx.def_span(id.def_id),\n                     E0138,\n                     \"multiple `start` functions\"\n                 )"}, {"sha": "3ee8c8bcb1dea936049e01bb7b73ac1c15c51f56", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1,6 +1,5 @@\n use rustc_data_structures::sync::Lock;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit;\n use rustc_hir::{HirId, ItemLocalId};\n use rustc_index::bit_set::GrowableBitSet;\n@@ -42,7 +41,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n \n struct HirIdValidator<'a, 'hir> {\n     hir_map: Map<'hir>,\n-    owner: Option<LocalDefId>,\n+    owner: Option<hir::OwnerId>,\n     hir_ids_seen: GrowableBitSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n@@ -63,12 +62,12 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n         self.errors.lock().push(f());\n     }\n \n-    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, owner: LocalDefId, walk: F) {\n+    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, owner: hir::OwnerId, walk: F) {\n         assert!(self.owner.is_none());\n         self.owner = Some(owner);\n         walk(self);\n \n-        if owner == CRATE_DEF_ID {\n+        if owner == hir::CRATE_OWNER_ID {\n             return;\n         }\n \n@@ -97,14 +96,14 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n                 missing_items.push(format!(\n                     \"[local_id: {}, owner: {}]\",\n                     local_id,\n-                    self.hir_map.def_path(owner).to_string_no_crate_verbose()\n+                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose()\n                 ));\n             }\n             self.error(|| {\n                 format!(\n                     \"ItemLocalIds not assigned densely in {}. \\\n                 Max ItemLocalId = {}, missing IDs = {:#?}; seens IDs = {:#?}\",\n-                    self.hir_map.def_path(owner).to_string_no_crate_verbose(),\n+                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose(),\n                     max,\n                     missing_items,\n                     self.hir_ids_seen\n@@ -138,8 +137,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n                 format!(\n                     \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n                     self.hir_map.node_to_string(hir_id),\n-                    self.hir_map.def_path(hir_id.owner).to_string_no_crate_verbose(),\n-                    self.hir_map.def_path(owner).to_string_no_crate_verbose()\n+                    self.hir_map.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n+                    self.hir_map.def_path(owner.def_id).to_string_no_crate_verbose()\n                 )\n             });\n         }"}, {"sha": "46c4a702fde954bcb2a4bdbbf63744d8e7365fa4", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -16,7 +16,7 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n                 DefKind::TyAlias | DefKind::Enum | DefKind::Struct | DefKind::Union\n             ) {\n                 for attr in tcx.get_attrs(id.def_id.to_def_id(), sym::rustc_layout) {\n-                    dump_layout_of(tcx, id.def_id, attr);\n+                    dump_layout_of(tcx, id.def_id.def_id, attr);\n                 }\n             }\n         }"}, {"sha": "16055641aca9f27dc1d15a6824a884041e7d0fb8", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -153,7 +153,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                 hir::ImplItemKind::Fn(..) => {\n                     let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                     let impl_did = self.tcx.hir().get_parent_item(hir_id);\n-                    method_might_be_inlined(self.tcx, impl_item, impl_did)\n+                    method_might_be_inlined(self.tcx, impl_item, impl_did.def_id)\n                 }\n                 hir::ImplItemKind::TyAlias(_) => false,\n             },\n@@ -305,8 +305,8 @@ fn check_item<'tcx>(\n     worklist: &mut Vec<LocalDefId>,\n     access_levels: &privacy::AccessLevels,\n ) {\n-    if has_custom_linkage(tcx, id.def_id) {\n-        worklist.push(id.def_id);\n+    if has_custom_linkage(tcx, id.def_id.def_id) {\n+        worklist.push(id.def_id.def_id);\n     }\n \n     if !matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n@@ -318,8 +318,8 @@ fn check_item<'tcx>(\n     if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n         item.kind\n     {\n-        if !access_levels.is_reachable(item.def_id) {\n-            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n+        if !access_levels.is_reachable(item.def_id.def_id) {\n+            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id.def_id));\n \n             let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n                 unreachable!();\n@@ -403,8 +403,8 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         }\n \n         for id in crate_items.impl_items() {\n-            if has_custom_linkage(tcx, id.def_id) {\n-                reachable_context.worklist.push(id.def_id);\n+            if has_custom_linkage(tcx, id.def_id.def_id) {\n+                reachable_context.worklist.push(id.def_id.def_id);\n             }\n         }\n     }"}, {"sha": "e50beb27d2a8802829ec2a0f446b74daf318167b", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -385,7 +385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.def_id,\n+            i.def_id.def_id,\n             i.span,\n             fn_sig,\n             kind,\n@@ -404,7 +404,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ti.def_id,\n+            ti.def_id.def_id,\n             ti.span,\n             fn_sig,\n             AnnotationKind::Required,\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ii.def_id,\n+            ii.def_id.def_id,\n             ii.span,\n             fn_sig,\n             kind,\n@@ -485,7 +485,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n-            i.def_id,\n+            i.def_id.def_id,\n             i.span,\n             None,\n             AnnotationKind::Required,\n@@ -573,25 +573,25 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.def_id, i.span);\n+            self.check_missing_stability(i.def_id.def_id, i.span);\n         }\n \n         // Ensure stable `const fn` have a const stability attribute.\n-        self.check_missing_const_stability(i.def_id, i.span);\n+        self.check_missing_const_stability(i.def_id.def_id, i.span);\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.def_id, ti.span);\n+        self.check_missing_stability(ti.def_id.def_id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().get_parent_item(ii.hir_id());\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.def_id, ii.span);\n-            self.check_missing_const_stability(ii.def_id, ii.span);\n+            self.check_missing_stability(ii.def_id.def_id, ii.span);\n+            self.check_missing_const_stability(ii.def_id.def_id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -610,7 +610,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.def_id, i.span);\n+        self.check_missing_stability(i.def_id.def_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n@@ -716,7 +716,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.def_id) else {\n+                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.def_id.def_id) else {\n                     return;\n                 };\n                 let def_id = cnum.as_def_id();\n@@ -869,7 +869,7 @@ fn is_unstable_reexport<'tcx>(tcx: TyCtxt<'tcx>, id: hir::HirId) -> bool {\n     }\n \n     // If this is a path that isn't a use, we don't need to do anything special\n-    if !matches!(tcx.hir().item(hir::ItemId { def_id }).kind, ItemKind::Use(..)) {\n+    if !matches!(tcx.hir().expect_item(def_id).kind, ItemKind::Use(..)) {\n         return false;\n     }\n "}, {"sha": "728674472505c1c2bc1a5eb18a42960a6d73ee80", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -506,8 +506,8 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.def_id);\n-            let vis = self.tcx.local_visibility(item_id.def_id);\n-            self.update_macro_reachable_def(item_id.def_id, def_kind, vis, defining_mod);\n+            let vis = self.tcx.local_visibility(item_id.def_id.def_id);\n+            self.update_macro_reachable_def(item_id.def_id.def_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n             for export in exports {\n@@ -627,11 +627,14 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n-                let impl_level =\n-                    Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels);\n-                self.update(item.def_id, impl_level)\n+                let impl_level = Option::<AccessLevel>::of_impl(\n+                    item.def_id.def_id,\n+                    self.tcx,\n+                    &self.access_levels,\n+                );\n+                self.update(item.def_id.def_id, impl_level)\n             }\n-            _ => self.get(item.def_id),\n+            _ => self.get(item.def_id.def_id),\n         };\n \n         // Update levels of nested things.\n@@ -652,13 +655,13 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     if impl_.of_trait.is_some()\n                         || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n                     {\n-                        self.update(impl_item_ref.id.def_id, item_level);\n+                        self.update(impl_item_ref.id.def_id.def_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.def_id, item_level);\n+                    self.update(trait_item_ref.id.def_id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n@@ -674,12 +677,12 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.def_id, macro_def);\n+                self.update_reachability_from_macro(item.def_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     if self.tcx.visibility(foreign_item.id.def_id).is_public() {\n-                        self.update(foreign_item.id.def_id, item_level);\n+                        self.update(foreign_item.id.def_id.def_id, item_level);\n                     }\n                 }\n             }\n@@ -717,7 +720,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level =\n                         cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                    self.reach(item.def_id, exist_level).generics().predicates().ty();\n+                    self.reach(item.def_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -726,16 +729,16 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates().ty();\n+                    self.reach(item.def_id.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates();\n+                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.def_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.def_id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -750,18 +753,22 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates();\n+                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.def_id.def_id, item_level)\n+                        .generics()\n+                        .predicates()\n+                        .ty()\n+                        .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.def_id);\n+                        let impl_item_level = self.get(impl_item_ref.id.def_id.def_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.def_id, impl_item_level)\n+                            self.reach(impl_item_ref.id.def_id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -773,7 +780,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates();\n+                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n@@ -784,23 +791,23 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.def_id, variant_level).ty();\n+                        self.reach(item.def_id.def_id, variant_level).ty();\n                     }\n                     if let Some(hir_id) = variant.data.ctor_hir_id() {\n                         let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                         let ctor_level = self.get(ctor_def_id);\n                         if ctor_level.is_some() {\n-                            self.reach(item.def_id, ctor_level).ty();\n+                            self.reach(item.def_id.def_id, ctor_level).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.def_id);\n+                    let foreign_item_level = self.get(foreign_item.id.def_id.def_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.def_id, foreign_item_level)\n+                        self.reach(foreign_item.id.def_id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -810,7 +817,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id, item_level).generics().predicates();\n+                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                         let field_level = self.get(def_id);\n@@ -823,7 +830,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                     let ctor_level = self.get(ctor_def_id);\n                     if ctor_level.is_some() {\n-                        self.reach(item.def_id, ctor_level).ty();\n+                        self.reach(item.def_id.def_id, ctor_level).ty();\n                     }\n                 }\n             }\n@@ -945,7 +952,7 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n \n impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.access_level_diagnostic(item.def_id);\n+        self.access_level_diagnostic(item.def_id.def_id);\n \n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n@@ -969,13 +976,13 @@ impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id);\n+        self.access_level_diagnostic(item.def_id.def_id);\n     }\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id);\n+        self.access_level_diagnostic(item.def_id.def_id);\n     }\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.access_level_diagnostic(item.def_id);\n+        self.access_level_diagnostic(item.def_id.def_id);\n     }\n }\n \n@@ -1058,7 +1065,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1361,7 +1368,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n         let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n@@ -1503,7 +1510,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., bounds, _) => {\n-                if !self.trait_is_public(item.def_id) {\n+                if !self.trait_is_public(item.def_id.def_id) {\n                     return;\n                 }\n \n@@ -1564,7 +1571,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n-                                self.access_levels.is_reachable(impl_item_ref.id.def_id)\n+                                self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n                             }\n                             hir::ImplItemKind::TyAlias(_) => false,\n                         }\n@@ -1584,7 +1591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self.item_is_public(impl_item.def_id) =>\n+                                        if self.item_is_public(impl_item.def_id.def_id) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1625,7 +1632,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.access_levels.is_reachable(impl_item_ref.id.def_id)\n+                        if self.access_levels.is_reachable(impl_item_ref.id.def_id.def_id)\n                             || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n                         {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n@@ -1654,7 +1661,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(item.def_id) => {\n+            _ if !self.item_is_public(item.def_id.def_id) => {\n                 return;\n             }\n \n@@ -1685,7 +1692,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.access_levels.is_reachable(item.def_id) {\n+        if self.access_levels.is_reachable(item.def_id.def_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1922,43 +1929,44 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n \n     pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.local_visibility(id.def_id);\n-        let def_kind = tcx.def_kind(id.def_id);\n+        let def_id = id.def_id.def_id;\n+        let item_visibility = tcx.local_visibility(def_id);\n+        let def_kind = tcx.def_kind(def_id);\n \n         match def_kind {\n             DefKind::Const | DefKind::Static(_) | DefKind::Fn | DefKind::TyAlias => {\n-                self.check(id.def_id, item_visibility).generics().predicates().ty();\n+                self.check(def_id, item_visibility).generics().predicates().ty();\n             }\n             DefKind::OpaqueTy => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(id.def_id, item_visibility).generics().bounds();\n+                self.check(def_id, item_visibility).generics().bounds();\n             }\n             DefKind::Trait => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Trait(.., trait_item_refs) = item.kind {\n-                    self.check(item.def_id, item_visibility).generics().predicates();\n+                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         self.check_assoc_item(\n-                            trait_item_ref.id.def_id,\n+                            trait_item_ref.id.def_id.def_id,\n                             trait_item_ref.kind,\n                             item_visibility,\n                         );\n \n                         if let AssocItemKind::Type = trait_item_ref.kind {\n-                            self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n+                            self.check(trait_item_ref.id.def_id.def_id, item_visibility).bounds();\n                         }\n                     }\n                 }\n             }\n             DefKind::TraitAlias => {\n-                self.check(id.def_id, item_visibility).generics().predicates();\n+                self.check(def_id, item_visibility).generics().predicates();\n             }\n             DefKind::Enum => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Enum(ref def, _) = item.kind {\n-                    self.check(item.def_id, item_visibility).generics().predicates();\n+                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n \n                     for variant in def.variants {\n                         for field in variant.data.fields() {\n@@ -1973,8 +1981,8 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n                     for foreign_item in items {\n-                        let vis = tcx.local_visibility(foreign_item.id.def_id);\n-                        self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n+                        let vis = tcx.local_visibility(foreign_item.id.def_id.def_id);\n+                        self.check(foreign_item.id.def_id.def_id, vis).generics().predicates().ty();\n                     }\n                 }\n             }\n@@ -1984,7 +1992,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 if let hir::ItemKind::Struct(ref struct_def, _)\n                 | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                 {\n-                    self.check(item.def_id, item_visibility).generics().predicates();\n+                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n \n                     for field in struct_def.fields() {\n                         let def_id = tcx.hir().local_def_id(field.hir_id);\n@@ -2000,20 +2008,21 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             DefKind::Impl => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-                    let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n+                    let impl_vis =\n+                        ty::Visibility::of_impl(item.def_id.def_id, tcx, &Default::default());\n                     // check that private components do not appear in the generics or predicates of inherent impls\n                     // this check is intentionally NOT performed for impls of traits, per #90586\n                     if impl_.of_trait.is_none() {\n-                        self.check(item.def_id, impl_vis).generics().predicates();\n+                        self.check(item.def_id.def_id, impl_vis).generics().predicates();\n                     }\n                     for impl_item_ref in impl_.items {\n                         let impl_item_vis = if impl_.of_trait.is_none() {\n-                            min(tcx.local_visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n+                            min(tcx.local_visibility(impl_item_ref.id.def_id.def_id), impl_vis, tcx)\n                         } else {\n                             impl_vis\n                         };\n                         self.check_assoc_item(\n-                            impl_item_ref.id.def_id,\n+                            impl_item_ref.id.def_id.def_id,\n                             impl_item_ref.kind,\n                             impl_item_vis,\n                         );\n@@ -2061,7 +2070,7 @@ fn local_visibility(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Visibility {\n                 // Visibilities of trait impl items are inherited from their traits\n                 // and are not filled in resolve.\n                 Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(hir_id)) {\n+                    match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(hir_id).def_id) {\n                         Node::Item(hir::Item {\n                             kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(tr), .. }),\n                             .."}, {"sha": "47762440e290b659a82b0dff776628fac1971e44", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1,6 +1,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::hir_id::OwnerId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n use rustc_middle::traits;\n@@ -104,6 +105,19 @@ impl Key for CrateNum {\n     }\n }\n \n+impl Key for OwnerId {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.to_def_id().default_span(tcx)\n+    }\n+    fn key_as_def_id(&self) -> Option<DefId> {\n+        Some(self.to_def_id())\n+    }\n+}\n+\n impl Key for LocalDefId {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "8140c243453bd4cbc5ef9365019386f4efa0458f", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -41,7 +41,10 @@ pub struct StableHashingContext<'a> {\n pub(super) enum BodyResolver<'tcx> {\n     Forbidden,\n     Ignore,\n-    Traverse { owner: LocalDefId, bodies: &'tcx SortedMap<hir::ItemLocalId, &'tcx hir::Body<'tcx>> },\n+    Traverse {\n+        owner: hir::OwnerId,\n+        bodies: &'tcx SortedMap<hir::ItemLocalId, &'tcx hir::Body<'tcx>>,\n+    },\n }\n \n impl<'a> StableHashingContext<'a> {\n@@ -103,7 +106,7 @@ impl<'a> StableHashingContext<'a> {\n     #[inline]\n     pub fn with_hir_bodies(\n         &mut self,\n-        owner: LocalDefId,\n+        owner: hir::OwnerId,\n         bodies: &SortedMap<hir::ItemLocalId, &hir::Body<'_>>,\n         f: impl FnOnce(&mut StableHashingContext<'_>),\n     ) {"}, {"sha": "9fb1af20ac976a41f090661fcff4725d9c8ed9a7", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -339,24 +339,25 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n /// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n /// other than the trait itself (like the trait methods or associated types), then we just use the regular\n /// `resolve_lifetimes`.\n-fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx ResolveLifetimes {\n-    let item_id = item_for(tcx, def_id);\n-    if item_id == def_id {\n-        let item = tcx.hir().item(hir::ItemId { def_id: item_id });\n+fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n+    let item_id = item_for(tcx, def_id.def_id);\n+    let local_def_id = item_id.def_id.def_id;\n+    if item_id.def_id == def_id {\n+        let item = tcx.hir().item(item_id);\n         match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(item_id),\n-            _ => tcx.resolve_lifetimes(item_id),\n+            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n+            _ => tcx.resolve_lifetimes(local_def_id),\n         }\n     } else {\n-        tcx.resolve_lifetimes(item_id)\n+        tcx.resolve_lifetimes(local_def_id)\n     }\n }\n \n /// Finds the `Item` that contains the given `LocalDefId`\n-fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n+fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> hir::ItemId {\n     match tcx.hir().find_by_def_id(local_def_id) {\n         Some(Node::Item(item)) => {\n-            return item.def_id;\n+            return item.item_id();\n         }\n         _ => {}\n     }\n@@ -366,7 +367,7 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n         loop {\n             let node = parent_iter.next().map(|n| n.1);\n             match node {\n-                Some(hir::Node::Item(item)) => break item.def_id,\n+                Some(hir::Node::Item(item)) => break item.item_id(),\n                 Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n                 _ => {}\n             }\n@@ -566,13 +567,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in\n-                    self.tcx.hir().parent_iter(self.tcx.hir().local_def_id_to_hir_id(item.def_id))\n-                {\n+                for (_hir_id, node) in self.tcx.hir().parent_iter(item.def_id.into()) {\n                     match node {\n                         hir::Node::Item(parent_item) => {\n-                            let resolved_lifetimes: &ResolveLifetimes =\n-                                self.tcx.resolve_lifetimes(item_for(self.tcx, parent_item.def_id));\n+                            let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n+                                item_for(self.tcx, parent_item.def_id.def_id).def_id.def_id,\n+                            );\n                             // We need to add *all* deps, since opaque tys may want them from *us*\n                             for (&owner, defs) in resolved_lifetimes.defs.iter() {\n                                 defs.iter().for_each(|(&local_id, region)| {\n@@ -1315,7 +1315,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     // regular fns.\n                     if let Some(hir::PredicateOrigin::ImplTrait) = where_bound_origin\n                         && let hir::LifetimeName::Param(_, hir::ParamName::Fresh) = lifetime_ref.name\n-                        && let hir::IsAsync::NotAsync = self.tcx.asyncness(lifetime_ref.hir_id.owner)\n+                        && let hir::IsAsync::NotAsync = self.tcx.asyncness(lifetime_ref.hir_id.owner.def_id)\n                         && !self.tcx.features().anonymous_lifetime_in_impl_trait\n                     {\n                         rustc_session::parse::feature_err("}, {"sha": "adbc119387dba42b3a4e46960767825a157e273d", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -345,14 +345,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id, |v| {\n+        self.nest_typeck_results(item.def_id.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -373,10 +373,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_typeck_results(item.def_id, |v| {\n+        self.nest_typeck_results(item.def_id.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -473,7 +473,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id.def_id),\n                 Def {\n                     kind,\n                     id: id_from_def_id(item.def_id.to_def_id()),\n@@ -491,7 +491,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_typeck_results(item.def_id, |v| {\n+        self.nest_typeck_results(item.def_id.def_id, |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.hir_id());\n                 v.visit_ty(&field.ty);\n@@ -513,7 +513,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -612,7 +612,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id, |v| {\n+        self.nest_typeck_results(item.def_id.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n@@ -648,7 +648,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id),\n+                &access_from!(self.save_ctxt, item.def_id.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -710,7 +710,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id.def_id), mod_data);\n         }\n     }\n \n@@ -980,7 +980,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = body.map(|b| self.tcx.hir().body(b).value);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n-                    trait_item.def_id,\n+                    trait_item.def_id.def_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -994,7 +994,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.def_id,\n+                    trait_item.def_id.def_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n                     trait_item.span,\n@@ -1050,7 +1050,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = self.tcx.hir().body(body);\n                 let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n-                    impl_item.def_id,\n+                    impl_item.def_id.def_id,\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1062,7 +1062,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.def_id,\n+                    impl_item.def_id.def_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     impl_item.span,\n@@ -1136,10 +1136,10 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item.def_id);\n+                    let access = access_from!(self.save_ctxt, item.def_id.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n@@ -1157,16 +1157,16 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let names = self.tcx.names_imported_by_glob_use(item.def_id);\n+                let names = self.tcx.names_imported_by_glob_use(item.def_id.def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item.def_id);\n+                        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n                         let span = self.span_from_span(sub_span);\n-                        let parent = self.save_ctxt.tcx.local_parent(item.def_id);\n+                        let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1187,7 +1187,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n                     self.dumper.import(\n                         &Access { public: false, reachable: false },\n                         Import {\n@@ -1235,7 +1235,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item.def_id),\n+                        &access_from!(self.save_ctxt, item.def_id.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1323,7 +1323,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _, _) => {\n                 let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(item_id.def_id, |v| v.visit_item(item));\n+                self.nest_typeck_results(item_id.def_id.def_id, |v| v.visit_item(item));\n             }\n             _ => intravisit::walk_ty(self, t),\n         }\n@@ -1430,7 +1430,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item.def_id);\n+        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "1a3511a1dc8bc920977ff7ab1349fa60c080939d", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -622,7 +622,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n                     // #75962: `self.typeck_results` may be different from the `hir_id`'s result.\n                     if self.tcx.has_typeck_results(hir_id.owner.to_def_id()) {\n-                        self.tcx.typeck(hir_id.owner).qpath_res(qpath, hir_id)\n+                        self.tcx.typeck(hir_id.owner.def_id).qpath_res(qpath, hir_id)\n                     } else {\n                         Res::Err\n                     }\n@@ -1041,7 +1041,7 @@ fn id_from_hir_id(id: hir::HirId, scx: &SaveContext<'_>) -> rls_data::Id {\n         // crate (very unlikely to actually happen).\n         rls_data::Id {\n             krate: LOCAL_CRATE.as_u32(),\n-            index: id.owner.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n+            index: id.owner.def_id.local_def_index.as_u32() | id.local_id.as_u32().reverse_bits(),\n         }\n     })\n }"}, {"sha": "c8c6fe2bf85263dddb6782c216768fbc60d0d624", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -26,19 +26,19 @@ pub fn report_symbol_names(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            symbol_names.process_attrs(id.def_id);\n+            symbol_names.process_attrs(id.def_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            symbol_names.process_attrs(id.def_id);\n+            symbol_names.process_attrs(id.def_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            symbol_names.process_attrs(id.def_id);\n+            symbol_names.process_attrs(id.def_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            symbol_names.process_attrs(id.def_id);\n+            symbol_names.process_attrs(id.def_id.def_id);\n         }\n     })\n }"}, {"sha": "b0cabc6275f5af4195bbe19be3ccabf426095895", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1898,7 +1898,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         // FIXME(compiler-errors): This could be generalized, both to\n                         // be more granular, and probably look past other `#[fundamental]`\n                         // types, too.\n-                        self.tcx.visibility(def.did()).is_accessible_from(body_id.owner, self.tcx)\n+                        self.tcx\n+                            .visibility(def.did())\n+                            .is_accessible_from(body_id.owner.def_id, self.tcx)\n                     } else {\n                         true\n                     }"}, {"sha": "fff26547be075a8de5d741c0bad563fe048953ab", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            hir_id = self.tcx.hir().local_def_id_to_hir_id(self.tcx.hir().get_parent_item(hir_id));\n+            hir_id = self.tcx.hir().get_parent_item(hir_id).into();\n         }\n     }\n \n@@ -2712,7 +2712,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     let parent_id = hir.get_parent_item(arg_hir_id);\n                     let typeck_results: &TypeckResults<'tcx> = match &in_progress_typeck_results {\n                         Some(t) if t.hir_owner == parent_id => t,\n-                        _ => self.tcx.typeck(parent_id),\n+                        _ => self.tcx.typeck(parent_id.def_id),\n                     };\n                     let expr = expr.peel_blocks();\n                     let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());"}, {"sha": "3e2553c425eddaaa400363580f250b5775296e68", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -42,7 +42,7 @@ fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId\n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let parent_def_id = tcx.hir().get_parent_item(id);\n-    let parent_item = tcx.hir().expect_item(parent_def_id);\n+    let parent_item = tcx.hir().expect_item(parent_def_id.def_id);\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n             if let Some(impl_item_ref) ="}, {"sha": "2c06ac2e13939d5eafea8f8bfa684ed3d1ea0700", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -3003,7 +3003,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Make sure that we are in the condition to suggest the blanket implementation.\n     fn maybe_lint_blanket_trait_impl(&self, self_ty: &hir::Ty<'_>, diag: &mut Diagnostic) {\n         let tcx = self.tcx();\n-        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id);\n+        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id).def_id;\n         if let hir::Node::Item(hir::Item {\n             kind:\n                 hir::ItemKind::Impl(hir::Impl {"}, {"sha": "201927091a60a489e0d11aee3554aa9d0ec459f8", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let Some(ret) = self\n                         .tcx\n                         .hir()\n-                        .find_by_def_id(self.body_id.owner)\n+                        .find_by_def_id(self.body_id.owner.def_id)\n                         .and_then(|owner| owner.fn_decl())\n                         .map(|decl| decl.output.span())\n                     else { return; };\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .typeck_results\n                     .borrow()\n                     .liberated_fn_sigs()\n-                    .get(hir::HirId::make_owner(self.body_id.owner))?;\n+                    .get(hir::HirId::make_owner(self.body_id.owner.def_id))?;\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()"}, {"sha": "d82ee8f48c52bf790eccf82cb926e4f9af581ace", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -782,19 +782,19 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     let _indenter = indenter();\n     match tcx.def_kind(id.def_id) {\n         DefKind::Static(..) => {\n-            tcx.ensure().typeck(id.def_id);\n-            maybe_check_static_with_link_section(tcx, id.def_id);\n-            check_static_inhabited(tcx, id.def_id);\n+            tcx.ensure().typeck(id.def_id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.def_id.def_id);\n+            check_static_inhabited(tcx, id.def_id.def_id);\n         }\n         DefKind::Const => {\n-            tcx.ensure().typeck(id.def_id);\n+            tcx.ensure().typeck(id.def_id.def_id);\n         }\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n                 return;\n             };\n-            check_enum(tcx, &enum_definition.variants, item.def_id);\n+            check_enum(tcx, &enum_definition.variants, item.def_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -807,7 +807,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    it.def_id,\n+                    it.def_id.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -845,10 +845,10 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             }\n         }\n         DefKind::Struct => {\n-            check_struct(tcx, id.def_id);\n+            check_struct(tcx, id.def_id.def_id);\n         }\n         DefKind::Union => {\n-            check_union(tcx, id.def_id);\n+            check_union(tcx, id.def_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n             let item = tcx.hir().item(id);\n@@ -861,7 +861,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             // See https://github.com/rust-lang/rust/issues/75100\n             if !tcx.sess.opts.actually_rustdoc {\n                 let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n-                check_opaque(tcx, item.def_id, substs, &origin);\n+                check_opaque(tcx, item.def_id.def_id, substs, &origin);\n             }\n         }\n         DefKind::TyAlias => {\n@@ -888,7 +888,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = item.id.def_id;\n+                    let def_id = item.id.def_id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {"}, {"sha": "d738e56325613de26a07c91ad77d0957a24cb08b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1683,7 +1683,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     expected,\n                     found,\n                     can_suggest,\n-                    fcx.tcx.hir().local_def_id_to_hir_id(fcx.tcx.hir().get_parent_item(id)),\n+                    fcx.tcx.hir().get_parent_item(id).into(),\n                 );\n             }\n             if !pointing_at_return_type {\n@@ -1692,7 +1692,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         }\n \n         let parent_id = fcx.tcx.hir().get_parent_item(id);\n-        let parent_item = fcx.tcx.hir().get_by_def_id(parent_id);\n+        let parent_item = fcx.tcx.hir().get_by_def_id(parent_id.def_id);\n \n         if let (Some(expr), Some(_), Some((fn_decl, _, _))) =\n             (expression, blk_id, fcx.get_node_fn_decl(parent_item))\n@@ -1704,7 +1704,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 expected,\n                 found,\n                 id,\n-                fcx.tcx.hir().local_def_id_to_hir_id(parent_id),\n+                parent_id.into(),\n             );\n         }\n "}, {"sha": "264df8b914b06cd1b1ac8393db279f2986a9fb0b", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible =\n-                        sole_field.vis.is_accessible_from(expr.hir_id.owner, self.tcx)\n+                        sole_field.vis.is_accessible_from(expr.hir_id.owner.def_id, self.tcx)\n                         // Skip suggestions for unstable public fields (for example `Pin::pointer`)\n                         && matches!(self.tcx.eval_stability(sole_field.did, None, expr.span, None), EvalResult::Allow | EvalResult::Unmarked);\n "}, {"sha": "48a4f40780bf43e9ff101ccb6acd7e9fd32663fd", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -752,7 +752,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 kind: hir::ImplItemKind::Fn(..),\n                 span: encl_fn_span,\n                 ..\n-            })) = self.tcx.hir().find_by_def_id(encl_item_id)\n+            })) = self.tcx.hir().find_by_def_id(encl_item_id.def_id)\n             {\n                 // We are inside a function body, so reporting \"return statement\n                 // outside of function body\" needs an explanation.\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // If this didn't hold, we would not have to report an error in\n                 // the first place.\n-                assert_ne!(encl_item_id, encl_body_owner_id);\n+                assert_ne!(encl_item_id.def_id, encl_body_owner_id);\n \n                 let encl_body_id = self.tcx.hir().body_owned_by(encl_body_owner_id);\n                 let encl_body = self.tcx.hir().body(encl_body_id);\n@@ -2338,7 +2338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Adt(def, _) = output_ty.kind() && !def.is_enum() {\n                 def.non_enum_variant().fields.iter().any(|field| {\n                     field.ident(self.tcx) == ident\n-                        && field.vis.is_accessible_from(expr.hir_id.owner, self.tcx)\n+                        && field.vis.is_accessible_from(expr.hir_id.owner.def_id, self.tcx)\n                 })\n             } else if let ty::Tuple(tys) = output_ty.kind()\n                 && let Ok(idx) = ident.as_str().parse::<usize>()"}, {"sha": "64e7fa1a42bf7b0e5c0f1fc7380f5bd7e172cbc0", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1543,7 +1543,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n-        let node = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(id));\n+        let node = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(id).def_id);\n         match node {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n             | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n@@ -1559,7 +1559,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n     fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n-        let parent = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(blk_id));\n+        let parent = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(blk_id).def_id);\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n "}, {"sha": "0e77ed0a4fe28b34e6c95a7a7f823cd45c845aa1", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -2077,7 +2077,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Colon,\n                                 Nothing,\n                             }\n-                            let ast_generics = hir.get_generics(id.owner).unwrap();\n+                            let ast_generics = hir.get_generics(id.owner.def_id).unwrap();\n                             let (sp, mut introducer) = if let Some(span) =\n                                 ast_generics.bounds_span_for_suggestions(def_id)\n                             {"}, {"sha": "593a9776bde30fc48f91389a53516e8b85561e9b", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -519,7 +519,7 @@ fn get_owner_return_paths<'tcx>(\n     def_id: LocalDefId,\n ) -> Option<(LocalDefId, ReturnsVisitor<'tcx>)> {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let parent_id = tcx.hir().get_parent_item(hir_id);\n+    let parent_id = tcx.hir().get_parent_item(hir_id).def_id;\n     tcx.hir().find_by_def_id(parent_id).and_then(|node| node.body_id()).map(|body_id| {\n         let body = tcx.hir().body(body_id);\n         let mut visitor = ReturnsVisitor::default();"}, {"sha": "7965ec1b43f414120cf33e5d8d890b010e2c7d26", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -116,7 +116,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     })\n }\n \n-fn check_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n     let node = tcx.hir().expect_owner(def_id);\n     match node {\n         hir::OwnerNode::Crate(_) => {}\n@@ -148,7 +148,7 @@ fn check_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n /// the types first.\n #[instrument(skip(tcx), level = \"debug\")]\n fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-    let def_id = item.def_id;\n+    let def_id = item.def_id.def_id;\n \n     debug!(\n         ?item.def_id,\n@@ -175,7 +175,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         // for `T`\n         hir::ItemKind::Impl(ref impl_) => {\n             let is_auto = tcx\n-                .impl_trait_ref(item.def_id)\n+                .impl_trait_ref(def_id)\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n@@ -211,13 +211,13 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n             }\n         }\n         hir::ItemKind::Fn(ref sig, ..) => {\n-            check_item_fn(tcx, item.def_id, item.ident, item.span, sig.decl);\n+            check_item_fn(tcx, def_id, item.ident, item.span, sig.decl);\n         }\n         hir::ItemKind::Static(ty, ..) => {\n-            check_item_type(tcx, item.def_id, ty.span, false);\n+            check_item_type(tcx, def_id, ty.span, false);\n         }\n         hir::ItemKind::Const(ty, ..) => {\n-            check_item_type(tcx, item.def_id, ty.span, false);\n+            check_item_type(tcx, def_id, ty.span, false);\n         }\n         hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n             check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n@@ -247,7 +247,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n }\n \n fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n-    let def_id = item.def_id;\n+    let def_id = item.def_id.def_id;\n \n     debug!(\n         ?item.def_id,\n@@ -256,23 +256,23 @@ fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n \n     match item.kind {\n         hir::ForeignItemKind::Fn(decl, ..) => {\n-            check_item_fn(tcx, item.def_id, item.ident, item.span, decl)\n+            check_item_fn(tcx, def_id, item.ident, item.span, decl)\n         }\n-        hir::ForeignItemKind::Static(ty, ..) => check_item_type(tcx, item.def_id, ty.span, true),\n+        hir::ForeignItemKind::Static(ty, ..) => check_item_type(tcx, def_id, ty.span, true),\n         hir::ForeignItemKind::Type => (),\n     }\n }\n \n fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n-    let def_id = trait_item.def_id;\n+    let def_id = trait_item.def_id.def_id;\n \n     let (method_sig, span) = match trait_item.kind {\n         hir::TraitItemKind::Fn(ref sig, _) => (Some(sig), trait_item.span),\n         hir::TraitItemKind::Type(_bounds, Some(ty)) => (None, ty.span),\n         _ => (None, trait_item.span),\n     };\n     check_object_unsafe_self_trait_by_name(tcx, trait_item);\n-    check_associated_item(tcx, trait_item.def_id, span, method_sig);\n+    check_associated_item(tcx, def_id, span, method_sig);\n \n     let encl_trait_def_id = tcx.local_parent(def_id);\n     let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n@@ -393,7 +393,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             // We also assume that all of the function signature's parameter types\n                             // are well formed.\n                             &sig.inputs().iter().copied().collect(),\n-                            gat_def_id,\n+                            gat_def_id.def_id,\n                             gat_generics,\n                         )\n                     }\n@@ -416,7 +416,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                                 .copied()\n                                 .collect::<Vec<_>>(),\n                             &FxHashSet::default(),\n-                            gat_def_id,\n+                            gat_def_id.def_id,\n                             gat_generics,\n                         )\n                     }\n@@ -456,7 +456,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n     }\n \n     for (gat_def_id, required_bounds) in required_bounds_by_item {\n-        let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id);\n+        let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id.def_id);\n         debug!(?required_bounds);\n         let param_env = tcx.param_env(gat_def_id);\n         let gat_hir = gat_item_hir.hir_id();\n@@ -786,7 +786,7 @@ fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n /// When this is done, suggest using `Self` instead.\n fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem<'_>) {\n     let (trait_name, trait_def_id) =\n-        match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id())) {\n+        match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id()).def_id) {\n             hir::Node::Item(item) => match item.kind {\n                 hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n                 _ => return,\n@@ -796,18 +796,18 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     let mut trait_should_be_self = vec![];\n     match &item.kind {\n         hir::TraitItemKind::Const(ty, _) | hir::TraitItemKind::Type(_, Some(ty))\n-            if could_be_self(trait_def_id, ty) =>\n+            if could_be_self(trait_def_id.def_id, ty) =>\n         {\n             trait_should_be_self.push(ty.span)\n         }\n         hir::TraitItemKind::Fn(sig, _) => {\n             for ty in sig.decl.inputs {\n-                if could_be_self(trait_def_id, ty) {\n+                if could_be_self(trait_def_id.def_id, ty) {\n                     trait_should_be_self.push(ty.span);\n                 }\n             }\n             match sig.decl.output {\n-                hir::FnRetTy::Return(ty) if could_be_self(trait_def_id, ty) => {\n+                hir::FnRetTy::Return(ty) if could_be_self(trait_def_id.def_id, ty) => {\n                     trait_should_be_self.push(ty.span);\n                 }\n                 _ => {}\n@@ -836,16 +836,14 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n }\n \n fn check_impl_item(tcx: TyCtxt<'_>, impl_item: &hir::ImplItem<'_>) {\n-    let def_id = impl_item.def_id;\n-\n     let (method_sig, span) = match impl_item.kind {\n         hir::ImplItemKind::Fn(ref sig, _) => (Some(sig), impl_item.span),\n         // Constrain binding and overflow error spans to `<Ty>` in `type foo = <Ty>`.\n         hir::ImplItemKind::TyAlias(ty) if ty.span != DUMMY_SP => (None, ty.span),\n         _ => (None, impl_item.span),\n     };\n \n-    check_associated_item(tcx, def_id, span, method_sig);\n+    check_associated_item(tcx, impl_item.def_id.def_id, span, method_sig);\n }\n \n fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n@@ -1045,7 +1043,7 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n         let variants = lookup_fields(wfcx);\n         let packed = tcx.adt_def(item.def_id).repr().packed();\n \n@@ -1124,19 +1122,20 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id);\n+        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n     });\n }\n \n #[instrument(skip(tcx, item))]\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     debug!(?item.def_id);\n \n-    let trait_def = tcx.trait_def(item.def_id);\n+    let def_id = item.def_id.def_id;\n+    let trait_def = tcx.trait_def(def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n     {\n-        for associated_def_id in &*tcx.associated_item_def_ids(item.def_id) {\n+        for associated_def_id in &*tcx.associated_item_def_ids(def_id) {\n             struct_span_err!(\n                 tcx.sess,\n                 tcx.def_span(*associated_def_id),\n@@ -1147,8 +1146,8 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n         }\n     }\n \n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n-        check_where_clauses(wfcx, item.span, item.def_id)\n+    enter_wf_checking_ctxt(tcx, item.span, def_id, |wfcx| {\n+        check_where_clauses(wfcx, item.span, def_id)\n     });\n \n     // Only check traits, don't check trait aliases\n@@ -1242,7 +1241,7 @@ fn check_impl<'tcx>(\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n     constness: hir::Constness,\n ) {\n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n@@ -1273,18 +1272,18 @@ fn check_impl<'tcx>(\n                 let self_ty = tcx.type_of(item.def_id);\n                 let self_ty = wfcx.normalize(\n                     item.span,\n-                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n                     self_ty,\n                 );\n                 wfcx.register_wf_obligation(\n                     ast_self_ty.span,\n-                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n                     self_ty.into(),\n                 );\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id);\n+        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n     });\n }\n "}, {"sha": "308ad5d5fc2c238efc3825a4959f8bd4251a80c3", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             }\n \n             if let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsInfer) {\n-                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n+                self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id.def_id);\n             } else {\n                 bug!(\"unexpected self type: {:?}\", self_ty);\n             }\n@@ -220,7 +220,9 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Ref(..)\n             | ty::Never\n             | ty::FnPtr(_)\n-            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n+            | ty::Tuple(..) => {\n+                self.check_primitive_impl(item.def_id.def_id, self_ty, items, ty.span)\n+            }\n             ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "7d15e5a7f3c223fb2c851191a002d8becc051ac4", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -42,7 +42,7 @@ fn do_orphan_check_impl<'tcx>(\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_def_id = trait_ref.def_id;\n \n-    let item = tcx.hir().item(hir::ItemId { def_id });\n+    let item = tcx.hir().expect_item(def_id);\n     let hir::ItemKind::Impl(ref impl_) = item.kind else {\n         bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };"}, {"sha": "23369b2f1b43e24188db2dd7cdf8e47a78b533fa", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::weak_lang_items;\n use rustc_hir::{GenericParamKind, HirId, Node};\n@@ -449,8 +449,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n \n             match self.node() {\n                 hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n-                    let item =\n-                        self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(self.hir_id()));\n+                    let item = self\n+                        .tcx\n+                        .hir()\n+                        .expect_item(self.tcx.hir().get_parent_item(self.hir_id()).def_id);\n                     match &item.kind {\n                         hir::ItemKind::Enum(_, generics)\n                         | hir::ItemKind::Struct(_, generics)\n@@ -728,7 +730,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     let it = tcx.hir().item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n-    let def_id = item_id.def_id;\n+    let def_id = item_id.def_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -840,20 +842,21 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n \n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n     let trait_item = tcx.hir().trait_item(trait_item_id);\n-    tcx.ensure().generics_of(trait_item_id.def_id);\n+    let def_id = trait_item_id.def_id;\n+    tcx.ensure().generics_of(def_id);\n \n     match trait_item.kind {\n         hir::TraitItemKind::Fn(..) => {\n-            tcx.ensure().type_of(trait_item_id.def_id);\n-            tcx.ensure().fn_sig(trait_item_id.def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().fn_sig(def_id);\n         }\n \n         hir::TraitItemKind::Const(.., Some(_)) => {\n-            tcx.ensure().type_of(trait_item_id.def_id);\n+            tcx.ensure().type_of(def_id);\n         }\n \n         hir::TraitItemKind::Const(hir_ty, _) => {\n-            tcx.ensure().type_of(trait_item_id.def_id);\n+            tcx.ensure().type_of(def_id);\n             // Account for `const C: _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n@@ -863,16 +866,16 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n-            tcx.ensure().item_bounds(trait_item_id.def_id);\n-            tcx.ensure().type_of(trait_item_id.def_id);\n+            tcx.ensure().item_bounds(def_id);\n+            tcx.ensure().type_of(def_id);\n             // Account for `type T = _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n-            tcx.ensure().item_bounds(trait_item_id.def_id);\n+            tcx.ensure().item_bounds(def_id);\n             // #74612: Visit and try to find bad placeholders\n             // even if there is no concrete type.\n             let mut visitor = HirPlaceholderCollector::default();\n@@ -882,7 +885,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n         }\n     };\n \n-    tcx.ensure().predicates_of(trait_item_id.def_id);\n+    tcx.ensure().predicates_of(def_id);\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n@@ -1595,7 +1598,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             }\n             ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n-                assert_ne!(parent_id, CRATE_DEF_ID);\n+                assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n                 // Opaque types are always nested within another item, and\n                 // inherit the generics of the item.\n@@ -3386,7 +3389,7 @@ fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span:\n     let node = tcx.hir().get(hir_id);\n     if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n         let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id);\n+        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n             tcx.sess\n                 .struct_span_err("}, {"sha": "24fb0b1fd26b58ff0c6b607a6e56a90f30cc66e6", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -569,22 +569,22 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id != self.def_id {\n-                self.check(it.def_id);\n+            if it.def_id.def_id != self.def_id {\n+                self.check(it.def_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id != self.def_id {\n-                self.check(it.def_id);\n+            if it.def_id.def_id != self.def_id {\n+                self.check(it.def_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             trace!(?it.def_id);\n-            self.check(it.def_id);\n+            self.check(it.def_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n@@ -688,22 +688,22 @@ fn find_opaque_ty_constraints_for_rpit(\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id != self.def_id {\n-                self.check(it.def_id);\n+            if it.def_id.def_id != self.def_id {\n+                self.check(it.def_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id != self.def_id {\n-                self.check(it.def_id);\n+            if it.def_id.def_id != self.def_id {\n+                self.check(it.def_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             trace!(?it.def_id);\n-            self.check(it.def_id);\n+            self.check(it.def_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "c499364056ff9569b61034fd39fb0b1d6158a3c2", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -58,10 +58,10 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n         if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-            enforce_impl_params_are_constrained(tcx, id.def_id);\n-            enforce_impl_items_are_distinct(tcx, id.def_id);\n+            enforce_impl_params_are_constrained(tcx, id.def_id.def_id);\n+            enforce_impl_items_are_distinct(tcx, id.def_id.def_id);\n             if min_specialization {\n-                check_min_specialization(tcx, id.def_id);\n+                check_min_specialization(tcx, id.def_id.def_id);\n             }\n         }\n     }"}, {"sha": "bd68dffb823d146bb1ec9fffb0850e0e2ada4784", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -1080,7 +1080,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n         let mut what_rustc_thinks =\n             Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n \n-        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id));\n+        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id.def_id));\n \n         // Trait impl items always inherit the impl's visibility --\n         // we don't want to show `pub`.\n@@ -1325,7 +1325,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 segments: trait_segments.iter().map(|x| clean_path_segment(x, cx)).collect(),\n             };\n             register_res(cx, trait_.res);\n-            let self_def_id = DefId::local(qself.hir_id.owner.local_def_index);\n+            let self_def_id = DefId::local(qself.hir_id.owner.def_id.local_def_index);\n             let self_type = clean_ty(qself, cx);\n             let should_show_cast = compute_should_show_cast(Some(self_def_id), &trait_, &self_type);\n             Type::QPath(Box::new(QPathData {\n@@ -2037,7 +2037,7 @@ fn clean_extern_crate<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n-    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = cnum.as_def_id();\n     let attrs = cx.tcx.hir().attrs(krate.hir_id());\n@@ -2099,7 +2099,7 @@ fn clean_use_statement<'tcx>(\n     let attrs = cx.tcx.hir().attrs(import.hir_id());\n     let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);\n     let pub_underscore = visibility.is_public() && name == kw::Underscore;\n-    let current_mod = cx.tcx.parent_module_from_def_id(import.def_id);\n+    let current_mod = cx.tcx.parent_module_from_def_id(import.def_id.def_id);\n \n     // The parent of the module in which this import resides. This\n     // is the same as `current_mod` if that's already the top"}, {"sha": "de3a4b33905953c469e8831f8db80cd2e6e67680", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n             let expected_parent = hir.get_parent_item(hir_id);\n             // If parents are different, it means that `item` is a reexport and we need\n             // to compute the actual `cfg` by iterating through its \"real\" parents.\n-            if self.parent == Some(expected_parent) {\n+            if self.parent == Some(expected_parent.def_id) {\n                 return;\n             }\n         }"}, {"sha": "dfa6ba38b883b11559e2a8b03f97a90817aa7852", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -143,14 +143,14 @@ where\n         // then we need to exit before calling typeck (which will panic). See\n         // test/run-make/rustdoc-scrape-examples-invalid-expr for an example.\n         let hir = tcx.hir();\n-        if hir.maybe_body_owned_by(ex.hir_id.owner).is_none() {\n+        if hir.maybe_body_owned_by(ex.hir_id.owner.def_id).is_none() {\n             return;\n         }\n \n         // Get type of function if expression is a function call\n         let (ty, call_span, ident_span) = match ex.kind {\n             hir::ExprKind::Call(f, _) => {\n-                let types = tcx.typeck(ex.hir_id.owner);\n+                let types = tcx.typeck(ex.hir_id.owner.def_id);\n \n                 if let Some(ty) = types.node_type_opt(f.hir_id) {\n                     (ty, ex.span, f.span)\n@@ -160,7 +160,7 @@ where\n                 }\n             }\n             hir::ExprKind::MethodCall(path, _, _, call_span) => {\n-                let types = tcx.typeck(ex.hir_id.owner);\n+                let types = tcx.typeck(ex.hir_id.owner.def_id);\n                 let Some(def_id) = types.type_dependent_def_id(ex.hir_id) else {\n                     trace!(\"type_dependent_def_id({}) = None\", ex.hir_id);\n                     return;\n@@ -183,9 +183,8 @@ where\n \n         // If the enclosing item has a span coming from a proc macro, then we also don't want to include\n         // the example.\n-        let enclosing_item_span = tcx\n-            .hir()\n-            .span_with_body(tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(ex.hir_id)));\n+        let enclosing_item_span =\n+            tcx.hir().span_with_body(tcx.hir().get_parent_item(ex.hir_id).into());\n         if enclosing_item_span.from_expansion() {\n             trace!(\"Rejecting expr ({call_span:?}) from macro item: {enclosing_item_span:?}\");\n             return;"}, {"sha": "03da804bd1c1f0916ea02ac30ef2c170addb1868", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingAllowedAttrPass {\n     ) {\n         let item = match cx.tcx.hir().get(id) {\n             Node::Item(item) => item,\n-            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n+            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id).def_id),\n         };\n \n         let allowed = |attr| pprust::attribute_to_string(attr).contains(\"allowed_attr\");"}, {"sha": "7fb90581f8a8fdf43115d1a0b92683e853f24af2", "filename": "src/test/ui/thir-tree.stdout", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftest%2Fui%2Fthir-tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftest%2Fui%2Fthir-tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthir-tree.stdout?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -33,7 +33,9 @@ Thir {\n                 region_scope: Node(2),\n                 lint_level: Explicit(\n                     HirId {\n-                        owner: DefId(0:3 ~ thir_tree[8f1d]::main),\n+                        owner: OwnerId {\n+                            def_id: DefId(0:3 ~ thir_tree[8f1d]::main),\n+                        },\n                         local_id: 2,\n                     },\n                 ),"}, {"sha": "e54d71fc8e417576b83895617d72f30b570fe36e", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -704,7 +704,7 @@ fn walk_parents<'tcx>(\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let ty = cx.tcx.type_of(def_id);\n+                let ty = cx.tcx.type_of(def_id.def_id);\n                 Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n "}, {"sha": "f48ba526d51e1693daf593a777ccf4956273128d", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -233,11 +233,11 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     let body = cx.tcx.hir().body(body_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n-                        typeck_results: cx.tcx.typeck(item.def_id),\n+                        typeck_results: cx.tcx.typeck(item.def_id.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(body.value);\n-                    lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+                    lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n             hir::ItemKind::Impl(impl_) => {\n@@ -268,7 +268,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, None, None);\n             }\n         }\n     }\n@@ -283,11 +283,11 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n             let body = cx.tcx.hir().body(body_id);\n             let mut fpu = FindPanicUnwrap {\n                 cx,\n-                typeck_results: cx.tcx.typeck(item.def_id),\n+                typeck_results: cx.tcx.typeck(item.def_id.def_id),\n                 panic_span: None,\n             };\n             fpu.visit_expr(body.value);\n-            lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n+            lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n         }\n     }\n }"}, {"sha": "c39a909b3ccb990d490f2b87e1e835986bdfcb03", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -297,7 +297,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id)) {\n+            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id.def_id)) {\n                 check_variant(cx, self.threshold, def, item_name, item.span);\n             }\n         }"}, {"sha": "a6ddb26e2dee3486eac4a8c99ef88d14c08d41b4", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n             }\n         }\n \n-        let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n+        let parent_id = cx.tcx.hir().get_parent_item(hir_id).def_id;\n         let parent_node = cx.tcx.hir().find_by_def_id(parent_id);\n \n         let mut trait_self_ty = None;"}, {"sha": "f3d9ebc5f12de4cda2ba2b8dedb077d02e22d3e7", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.def_id);\n+            if cx.access_levels.is_exported(item.def_id.def_id);\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {"}, {"sha": "407dd1b39575f4d63596ea341c8be18a2d7917f1", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> LateLintPass<'tcx> for Exit {\n             if let ExprKind::Path(ref path) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);\n-            let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+            let parent = cx.tcx.hir().get_parent_item(e.hir_id).def_id;\n             if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find_by_def_id(parent);\n             // If the next item up is a function we check if it is an entry point\n             // and only then emit a linter warning"}, {"sha": "ef24a5d06ad0b58f5f6d612e4eae5477ed5d53a5", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -107,7 +107,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                 let body = cx.tcx.hir().body(body_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    typeck_results: cx.tcx.typeck(impl_item.id.def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item.id.def_id.def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(body.value);"}, {"sha": "d6d33bda173817713ce8941edd67d25813c619a7", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -21,7 +21,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n+        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n@@ -31,7 +31,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id,\n+                item.def_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this function could have a `#[must_use]` attribute\",\n             );\n@@ -41,19 +41,19 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n \n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n+        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id).is_none() {\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id,\n+                item.def_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this method could have a `#[must_use]` attribute\",\n             );\n@@ -63,7 +63,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n \n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.def_id);\n+        let is_public = cx.access_levels.is_exported(item.def_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n@@ -78,7 +78,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n                     sig.decl,\n                     body,\n                     item.span,\n-                    item.def_id,\n+                    item.def_id.def_id,\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this method could have a `#[must_use]` attribute\",\n                 );\n@@ -171,7 +171,7 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet)\n         return false; // ignore `_` patterns\n     }\n     if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n+        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner.def_id).pat_ty(pat), pat.span, tys)\n     } else {\n         false\n     }\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n                     if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n                         && is_mutable_ty(\n                             self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            self.cx.tcx.typeck(arg.hir_id.owner.def_id).expr_ty(arg),\n                             arg.span,\n                             &mut tys,\n                         )"}, {"sha": "0b50431fbaaba5b03eaa560af954b18160fc3bd8", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check_fn<'tcx>(\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n-        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id);\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id.def_id);\n     }\n }\n "}, {"sha": "113c4e9f50910859e65f857ebfb405c0e11573ed", "filename": "src/tools/clippy/clippy_lints/src/functions/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -34,9 +34,9 @@ fn result_err_ty<'tcx>(\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, large_err_threshold: u64) {\n     if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span)\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n     {\n-        if cx.access_levels.is_exported(item.def_id) {\n+        if cx.access_levels.is_exported(item.def_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -47,10 +47,10 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, l\n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem<'tcx>, large_err_threshold: u64) {\n     // Don't lint if method is a trait's implementation, we can't do anything about those\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span)\n-        && trait_ref_of_method(cx, item.def_id).is_none()\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n+        && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n     {\n-        if cx.access_levels.is_exported(item.def_id) {\n+        if cx.access_levels.is_exported(item.def_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -61,8 +61,8 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitItem<'tcx>, large_err_threshold: u64) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id, item.span) {\n-            if cx.access_levels.is_exported(item.def_id) {\n+        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span) {\n+            if cx.access_levels.is_exported(item.def_id.def_id) {\n                 check_result_unit_err(cx, err_ty, fn_header_span);\n             }\n             check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);"}, {"sha": "804fdc2da08897ebda1573b206487f978434448c", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.def_id) {\n+        if !cx.access_levels.is_exported(item.def_id.def_id) {\n             return;\n         }\n "}, {"sha": "cb6c2ec0fb98539e3bdf4ad3883f66902d65600b", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::String);\n \n             // Filters instances of to_string which are required by a trait\n-            if trait_ref_of_method(cx, impl_item.def_id).is_none();\n+            if trait_ref_of_method(cx, impl_item.def_id.def_id).is_none();\n \n             then {\n                 show_lint(cx, impl_item);"}, {"sha": "2027c23d328c9714397d55b7e8b0fcabd05718d1", "filename": "src/tools/clippy/clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n         let name = item.ident.name.as_str();\n         if matches!(name, \"iter\" | \"iter_mut\") {\n             if let TraitItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id);\n+                check_sig(cx, name, fn_sig, item.def_id.def_id);\n             }\n         }\n     }\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n             )\n         {\n             if let ImplItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id);\n+                check_sig(cx, name, fn_sig, item.def_id.def_id);\n             }\n         }\n     }"}, {"sha": "7d15dd4cb216488caf619bd3c3afcf625459645e", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n-            if cx.access_levels.is_exported(item.def_id);\n+            if cx.access_levels.is_exported(item.def_id.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n             if imp.of_trait.is_none();\n@@ -210,7 +210,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.def_id) && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n+    if cx.access_levels.is_exported(visited_trait.def_id.def_id) && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);"}, {"sha": "399a03187d9937083403655ffd51b7e8b1077e64", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n-            let report_extra_lifetimes = trait_ref_of_method(cx, item.def_id).is_none();\n+            let report_extra_lifetimes = trait_ref_of_method(cx, item.def_id.def_id).is_none();\n             check_fn_inner(\n                 cx,\n                 sig.decl,\n@@ -276,7 +276,7 @@ fn could_use_elision<'tcx>(\n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n-        checker.visit_expr(body.value);\n+        checker.visit_expr(&body.value);\n         if checker.lifetimes_used_in_body {\n             return false;\n         }"}, {"sha": "be7f96e9bb07742c5b058fbbebeae5be649eadeb", "filename": "src/tools/clippy/clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -69,7 +69,7 @@ fn check_for_mutation<'tcx>(\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            body.hir_id.owner,\n+            body.hir_id.owner.def_id,\n             cx.param_env,\n             cx.typeck_results(),\n         )"}, {"sha": "53e7565bd33f33d88065948e14c31290b9bc1974", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -166,7 +166,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n             if let Some((id, span)) = iter.next()\n                 && iter.next().is_none()\n             {\n-                self.potential_enums.push((item.def_id, id, item.span, span));\n+                self.potential_enums.push((item.def_id.def_id, id, item.span, span));\n             }\n         }\n     }"}, {"sha": "ddb6d1ca26c91030f738cf96b910ee2b4951fd4c", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -3250,7 +3250,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             return;\n         }\n         let name = impl_item.ident.name.as_str();\n-        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n@@ -3259,7 +3259,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next();\n \n-            let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n+            let method_sig = cx.tcx.fn_sig(impl_item.def_id.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n             let first_arg_ty = method_sig.inputs().iter().next();\n@@ -3269,7 +3269,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             then {\n                 // if this impl block implements a trait, lint in trait definition instead\n-                if !implements_trait && cx.access_levels.is_exported(impl_item.def_id) {\n+                if !implements_trait && cx.access_levels.is_exported(impl_item.def_id.def_id) {\n                     // check missing trait implementations\n                     for method_config in &TRAIT_METHODS {\n                         if name == method_config.method_name &&\n@@ -3301,7 +3301,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n                 if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                        && cx.access_levels.is_exported(impl_item.def_id))\n+                        && cx.access_levels.is_exported(impl_item.def_id.def_id))\n                 {\n                     wrong_self_convention::check(\n                         cx,"}, {"sha": "f24b41411c8168e78afbbfbef6ffea6ab6d67724", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -136,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         // Const fns are not allowed as methods in a trait.\n         {\n-            let parent = cx.tcx.hir().get_parent_item(hir_id);\n+            let parent = cx.tcx.hir().get_parent_item(hir_id).def_id;\n             if parent != CRATE_DEF_ID {\n                 if let hir::Node::Item(item) = cx.tcx.hir().get_by_def_id(parent) {\n                     if let hir::ItemKind::Trait(..) = &item.kind {"}, {"sha": "47219556676889518b49f52485e08cb33424eb28", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let at_root = cx.tcx.local_parent(it.def_id) == CRATE_DEF_ID;\n+                    let at_root = cx.tcx.local_parent(it.def_id.def_id) == CRATE_DEF_ID;\n                     if at_root {\n                         return;\n                     }"}, {"sha": "9d5764ac0926071c5b1b35185ce4e04794b16349", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.def_id) {\n+        if !cx.access_levels.is_exported(it.def_id.def_id) {\n             return;\n         }\n         match it.kind {\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.def_id) {\n+        if !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n             return;\n         }\n \n@@ -159,7 +159,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.def_id) {\n+            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.def_id.def_id) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "25d6ca83a94bc7e2d099e8a9e1a81b1a071e2e1d", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n-            if trait_ref_of_method(cx, item.def_id).is_none() {\n+            if trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n                 check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }"}, {"sha": "357a71693d2c38e1e0e4f71c41453967fa518520", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if cx.tcx.is_doc_hidden(impl_item.def_id) {\n+                        if cx.tcx.is_doc_hidden(impl_item.def_id.def_id) {\n                             // shouldn't be implemented when it is hidden in docs\n                             return;\n                         }\n@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                         if_chain! {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n-                            if cx.access_levels.is_reachable(impl_item.def_id);\n+                            if cx.access_levels.is_reachable(impl_item.def_id.def_id);\n                             let self_def_id = cx.tcx.hir().get_parent_item(id);\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if self_ty == return_ty(cx, id);"}, {"sha": "616ef9e2f867f825d83a05cdc643f3b985a70952", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, body_id) = &impl_item.kind {\n-            let item_def_id = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+            let item_def_id = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n             let item = cx.tcx.hir().expect_item(item_def_id);\n \n             match &item.kind {"}, {"sha": "d64a9cf71e17a9a036530de5a09688643094224f", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -243,7 +243,7 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                 ..\n             })) => {\n                 #[allow(trivial_casts)]\n-                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, cx.tcx.hir().local_def_id_to_hir_id(def_id))\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, def_id.into())\n                     && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n                     && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n                 {"}, {"sha": "2c22c8b3d081997a3953511a2ff99c36c0dffc73", "filename": "src/tools/clippy/clippy_lints/src/operators/assign_op_pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fassign_op_pattern.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -28,7 +28,7 @@ pub(super) fn check<'tcx>(\n             if_chain! {\n                 if let Some((_, lang_item)) = binop_traits(op.node);\n                 if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n-                let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id).def_id;\n                 if trait_ref_of_method(cx, parent_fn)\n                     .map_or(true, |t| t.path.res.def_id() != trait_id);\n                 if implements_trait(cx, ty, trait_id, &[rty.into()]);"}, {"sha": "6b2eea48932250b6b9ebf79b633a9f6e5c21641b", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -261,7 +261,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.def_id, method_sig.decl, None);\n+            self.check_poly_fn(cx, item.def_id.def_id, method_sig.decl, None);\n         }\n     }\n "}, {"sha": "3c6ca9d98975d3631ec254a2c8040f9d119ba434", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -46,8 +46,8 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if_chain! {\n-            if cx.tcx.visibility(item.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n-            if !cx.access_levels.is_exported(item.def_id) && self.is_exported.last() == Some(&false);\n+            if cx.tcx.visibility(item.def_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n+            if !cx.access_levels.is_exported(item.def_id.def_id) && self.is_exported.last() == Some(&false);\n             if is_not_macro_export(item);\n             then {\n                 let span = item.span.with_hi(item.ident.span.hi());\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.def_id));\n+            self.is_exported.push(cx.access_levels.is_exported(item.def_id.def_id));\n         }\n     }\n "}, {"sha": "16d702a3868d183c400ef972c9827e06849d3110", "filename": "src/tools/clippy/clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n         if let TraitItemKind::Fn(ref sig, _) = item.kind {\n-            check_method(cx, sig.decl, item.def_id, item.span, item.hir_id());\n+            check_method(cx, sig.decl, item.def_id.def_id, item.span, item.hir_id());\n         }\n     }\n }"}, {"sha": "1ac538f4c7c074cff2e64222d6876d9624e1be2f", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n             _ => return,\n         }\n \n-        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n         let ret_ty = return_ty(cx, impl_item.hir_id());"}, {"sha": "d47ed459387ef9c123088d9962be8abed61f00db", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -64,11 +64,11 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n \n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n-            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n+            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id).def_id;\n             if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get_by_def_id(parent_fn);\n             if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n             let body = cx.tcx.hir().body(body_id);\n-            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n+            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id).def_id;\n             if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n             let trait_id = trait_ref.path.res.def_id();\n             if ![binop_trait_id, op_assign_trait_id].contains(&trait_id);"}, {"sha": "8e90d20265ce13a05284a5d405200c204846b670", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -42,7 +42,7 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n /// messages. This function will panic if that occurs.\n fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n     let hir_id = e.hir_id;\n-    let local_def_id = hir_id.owner;\n+    let local_def_id = hir_id.owner.def_id;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n         let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);"}, {"sha": "1268c23206a6f77cf1fc671393a86799a1253fbc", "filename": "src/tools/clippy/clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -104,7 +104,7 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic;\n-        if let Some(generics) = cx.tcx.hir().get_generics(id.owner);\n+        if let Some(generics) = cx.tcx.hir().get_generics(id.owner.def_id);\n         if let Some(pred) = generics.bounds_for_param(did.expect_local()).next();\n         then {\n             Some(pred.bounds)"}, {"sha": "aca55817c52503bb102ff69c7ad0b78e66c5e2cb", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -313,7 +313,7 @@ impl_lint_pass!(Types => [BOX_COLLECTION, VEC_BOX, OPTION_OPTION, LINKEDLIST, BO\n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n         let is_in_trait_impl =\n-            if let Some(hir::Node::Item(item)) = cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(id)) {\n+            if let Some(hir::Node::Item(item)) = cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(id).def_id) {\n                 matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n             } else {\n                 false\n@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id);\n+        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n \n         match item.kind {\n             ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n@@ -353,7 +353,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n         match item.kind {\n             ImplItemKind::Const(ty, _) => {\n                 let is_in_trait_impl = if let Some(hir::Node::Item(item)) =\n-                    cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(item.hir_id()))\n+                    cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(item.hir_id()).def_id)\n                 {\n                     matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n                 } else {\n@@ -390,7 +390,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n-        let is_exported = cx.access_levels.is_exported(item.def_id);\n+        let is_exported = cx.access_levels.is_exported(item.def_id.def_id);\n \n         let context = CheckTyContext {\n             is_exported,"}, {"sha": "713fe06bad436985d6a0d3cfc04a6aee97aaa620", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -54,14 +54,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         if impl_item.span.from_expansion() {\n             return;\n         }\n-        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let parent_item = cx.tcx.hir().expect_item(parent);\n         let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            if !cx.access_levels.is_exported(impl_item.def_id) || !self.avoid_breaking_exported_api;\n+            if !cx.access_levels.is_exported(impl_item.def_id.def_id) || !self.avoid_breaking_exported_api;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n             if !is_local_used(cx, body, self_param.pat.hir_id);"}, {"sha": "baa53ba664f6944becd037eb9ad6b92911dc2264", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -111,7 +111,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tc\n         let body = cx.tcx.hir().body(body_id);\n         let mut fpu = FindExpectUnwrap {\n             lcx: cx,\n-            typeck_results: cx.tcx.typeck(impl_item.def_id),\n+            typeck_results: cx.tcx.typeck(impl_item.def_id.def_id),\n             result: Vec::new(),\n         };\n         fpu.visit_expr(body.value);"}, {"sha": "2c71f35d490cb2554f1a545b00d500ba23903526", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -105,7 +105,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n         if in_external_macro(cx.sess(), it.span)\n-            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.def_id))\n+            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.def_id.def_id))\n         {\n             return;\n         }"}, {"sha": "ce51cb693fc0255ef273fc45a15f87ad4e0a0239", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if !is_from_proc_macro(cx, item); // expensive, should be last check\n             then {\n                 StackItem::Check {\n-                    impl_id: item.def_id,\n+                    impl_id: item.def_id.def_id,\n                     in_body: 0,\n                     types_to_skip: std::iter::once(self_ty.hir_id).collect(),\n                 }"}, {"sha": "1df3135c962d122c9ecc6064fd0a8733d83be17d", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -140,7 +140,7 @@ impl<'tcx> LateLintPass<'tcx> for Author {\n \n fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n     let hir = cx.tcx.hir();\n-    if let Some(body_id) = hir.maybe_body_owned_by(hir_id.expect_owner()) {\n+    if let Some(body_id) = hir.maybe_body_owned_by(hir_id.expect_owner().def_id) {\n         check_node(cx, hir_id, |v| {\n             v.expr(&v.bind(\"expr\", hir.body(body_id).value));\n         });"}, {"sha": "2604b1ee7c56aa2c1a38691f7a33de556304f080", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -120,14 +120,14 @@ impl LateLintPass<'_> for WildcardImports {\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n-        let module = cx.tcx.parent_module_from_def_id(item.def_id);\n-        if cx.tcx.visibility(item.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n+        let module = cx.tcx.parent_module_from_def_id(item.def_id.def_id);\n+        if cx.tcx.visibility(item.def_id.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n             return;\n         }\n         if_chain! {\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n             if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n-            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id);\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id.def_id);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "386f3c527f1741244fad52cf23ef0242160bb230", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -72,7 +72,7 @@ fn in_trait_impl(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n     let second_parent_id = cx\n         .tcx\n         .hir()\n-        .get_parent_item(cx.tcx.hir().local_def_id_to_hir_id(parent_id));\n+        .get_parent_item(parent_id.into()).def_id;\n     if let Some(Node::Item(item)) = cx.tcx.hir().find_by_def_id(second_parent_id) {\n         if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n             return true;"}, {"sha": "9343cf457b341277011cfea5d115fe7aa3533303", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -78,7 +78,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n@@ -212,7 +212,7 @@ pub fn find_binding_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<\n /// }\n /// ```\n pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n-    let parent_id = cx.tcx.hir().get_parent_item(id);\n+    let parent_id = cx.tcx.hir().get_parent_item(id).def_id;\n     match cx.tcx.hir().get_by_def_id(parent_id) {\n         Node::Item(&Item {\n             kind: ItemKind::Const(..) | ItemKind::Static(..),\n@@ -597,8 +597,8 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, def_id: LocalDefId) ->\n     let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n     if_chain! {\n-        if parent_impl != CRATE_DEF_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get_by_def_id(parent_impl);\n+        if parent_impl != hir::CRATE_OWNER_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get_by_def_id(parent_impl.def_id);\n         if let hir::ItemKind::Impl(impl_) = &item.kind;\n         then {\n             return impl_.of_trait.as_ref();\n@@ -1104,7 +1104,7 @@ pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n \n /// Gets the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n-    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id).def_id;\n     match cx.tcx.hir().find_by_def_id(parent_id) {\n         Some(\n             Node::Item(Item { ident, .. })\n@@ -1648,7 +1648,7 @@ pub fn any_parent_has_attr(tcx: TyCtxt<'_>, node: HirId, symbol: Symbol) -> bool\n             return true;\n         }\n         prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.local_def_id_to_hir_id(map.get_parent_item(enclosing_node));\n+        enclosing_node = map.get_parent_item(enclosing_node).into();\n     }\n \n     false"}, {"sha": "a7c08839f5241f189dc8659e669a5696432ab441", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ece44cfa3be0f2edfebe286d61f15b8affa0c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=d0ece44cfa3be0f2edfebe286d61f15b8affa0c6", "patch": "@@ -21,7 +21,7 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n         ExprUseVisitor::new(\n             &mut delegate,\n             &infcx,\n-            expr.hir_id.owner,\n+            expr.hir_id.owner.def_id,\n             cx.param_env,\n             cx.typeck_results(),\n         )"}]}