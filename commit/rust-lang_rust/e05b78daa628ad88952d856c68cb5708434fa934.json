{"sha": "e05b78daa628ad88952d856c68cb5708434fa934", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNWI3OGRhYTYyOGFkODg5NTJkODU2YzY4Y2I1NzA4NDM0ZmE5MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T01:30:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-27T01:30:10Z"}, "message": "Auto merge of #49420 - nox:enum-scalarpair, r=eddyb\n\nUse ScalarPair for tagged enums", "tree": {"sha": "816e5cca12b01840b785a71031b86a3011d3d025", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/816e5cca12b01840b785a71031b86a3011d3d025"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e05b78daa628ad88952d856c68cb5708434fa934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e05b78daa628ad88952d856c68cb5708434fa934", "html_url": "https://github.com/rust-lang/rust/commit/e05b78daa628ad88952d856c68cb5708434fa934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e05b78daa628ad88952d856c68cb5708434fa934/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d8f0e22f574c7ffb4b6544cc96c066b7de3b6be", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d8f0e22f574c7ffb4b6544cc96c066b7de3b6be", "html_url": "https://github.com/rust-lang/rust/commit/7d8f0e22f574c7ffb4b6544cc96c066b7de3b6be"}, {"sha": "3ca6ad922eb6d8c3139d961c844a0194eaf58770", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca6ad922eb6d8c3139d961c844a0194eaf58770", "html_url": "https://github.com/rust-lang/rust/commit/3ca6ad922eb6d8c3139d961c844a0194eaf58770"}], "stats": {"total": 104, "additions": 90, "deletions": 14}, "files": [{"sha": "55137e2891123a3b8c2bc453fff76345b603dc89", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e05b78daa628ad88952d856c68cb5708434fa934/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05b78daa628ad88952d856c68cb5708434fa934/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e05b78daa628ad88952d856c68cb5708434fa934", "patch": "@@ -897,7 +897,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Create the set of structs that represent each variant.\n-                let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n+                let mut layout_variants = variants.iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // Patch up the variants' first few fields.\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n-                    for variant in &mut variants {\n+                    for variant in &mut layout_variants {\n                         if variant.abi == Abi::Uninhabited {\n                             continue;\n                         }\n@@ -985,15 +985,80 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     value: Int(ity, signed),\n                     valid_range: (min as u128 & tag_mask)..=(max as u128 & tag_mask),\n                 };\n-                let abi = if tag.value.size(dl) == size {\n-                    Abi::Scalar(tag.clone())\n-                } else {\n-                    Abi::Aggregate { sized: true }\n-                };\n+                let mut abi = Abi::Aggregate { sized: true };\n+                if tag.value.size(dl) == size {\n+                    abi = Abi::Scalar(tag.clone());\n+                } else if !tag.is_bool() {\n+                    // HACK(nox): Blindly using ScalarPair for all tagged enums\n+                    // where applicable leads to Option<u8> being handled as {i1, i8},\n+                    // which later confuses SROA and some loop optimisations,\n+                    // ultimately leading to the repeat-trusted-len test\n+                    // failing. We make the trade-off of using ScalarPair only\n+                    // for types where the tag isn't a boolean.\n+                    let mut common_prim = None;\n+                    for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n+                        let offsets = match layout_variant.fields {\n+                            FieldPlacement::Arbitrary { ref offsets, .. } => offsets,\n+                            _ => bug!(),\n+                        };\n+                        let mut fields = field_layouts\n+                            .iter()\n+                            .zip(offsets)\n+                            .filter(|p| !p.0.is_zst());\n+                        let (field, offset) = match (fields.next(), fields.next()) {\n+                            (None, None) => continue,\n+                            (Some(pair), None) => pair,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        let prim = match field.details.abi {\n+                            Abi::Scalar(ref scalar) => scalar.value,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        if let Some(pair) = common_prim {\n+                            // This is pretty conservative. We could go fancier\n+                            // by conflating things like i32 and u32, or even\n+                            // realising that (u8, u8) could just cohabit with\n+                            // u16 or even u32.\n+                            if pair != (prim, offset) {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        } else {\n+                            common_prim = Some((prim, offset));\n+                        }\n+                    }\n+                    if let Some((prim, offset)) = common_prim {\n+                        let pair = scalar_pair(tag.clone(), scalar_unit(prim));\n+                        let pair_offsets = match pair.fields {\n+                            FieldPlacement::Arbitrary {\n+                                ref offsets,\n+                                ref memory_index\n+                            } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n+                            }\n+                            _ => bug!()\n+                        };\n+                        if pair_offsets[0] == Size::from_bytes(0) &&\n+                            pair_offsets[1] == *offset &&\n+                            align == pair.align &&\n+                            size == pair.size {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                }\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n                         discr: tag,\n-                        variants\n+                        variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n                         offsets: vec![Size::from_bytes(0)],"}, {"sha": "f306608f4328eca67009df4d9ed38b54bcae8bd7", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=e05b78daa628ad88952d856c68cb5708434fa934", "patch": "@@ -29,7 +29,6 @@ pub enum Enum4 {\n     A(i32),\n     B(i32),\n }\n-// CHECK: %Enum4 = type { [0 x i32], i32, [1 x i32] }\n // CHECK: %\"Enum4::A\" = type { [1 x i32], i32, [0 x i32] }\n \n pub enum Enum64 {\n@@ -59,7 +58,7 @@ pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n // CHECK-LABEL: @enum4\n #[no_mangle]\n pub fn enum4(a: i32) -> Enum4 {\n-// CHECK: %e4 = alloca %Enum4, align 4\n+// CHECK: %e4 = alloca { i32, i32 }, align 4\n     let e4 = Enum4::A(a);\n     e4\n }"}, {"sha": "40a9ea5a181392313fa415910297f5a107a6b39c", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=e05b78daa628ad88952d856c68cb5708434fa934", "patch": "@@ -145,6 +145,18 @@ pub fn return_slice(x: &[u16]) -> &[u16] {\n   x\n }\n \n+// CHECK: { i16, i16 } @enum_id_1(i16 %x.0, i16 %x.1)\n+#[no_mangle]\n+pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n+  x\n+}\n+\n+// CHECK: i16 @enum_id_2(i16)\n+#[no_mangle]\n+pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n+  x\n+}\n+\n // CHECK: noalias i8* @allocator()\n #[no_mangle]\n #[allocator]"}, {"sha": "ea3f0de5d082ecf114fc4c0dae9d18ab1f3f4370", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e05b78daa628ad88952d856c68cb5708434fa934/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=e05b78daa628ad88952d856c68cb5708434fa934", "patch": "@@ -25,16 +25,16 @@ pub fn test() {\n         let b = &Some(a);\n         &b; // keep variable in an alloca\n \n-// CHECK: [[S_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n+// CHECK: [[S_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n // CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_b]])\n \n-// CHECK: [[S__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: [[S__4:%[0-9]+]] = bitcast { i32, i32 }* %_4 to i8*\n // CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S__4]])\n \n-// CHECK: [[E_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n+// CHECK: [[E_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n // CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_b]])\n \n-// CHECK: [[E__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: [[E__4:%[0-9]+]] = bitcast { i32, i32 }* %_4 to i8*\n // CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E__4]])\n     }\n "}]}