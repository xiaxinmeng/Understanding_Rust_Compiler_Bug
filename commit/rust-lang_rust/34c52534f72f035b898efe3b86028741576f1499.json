{"sha": "34c52534f72f035b898efe3b86028741576f1499", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzUyNTM0ZjcyZjAzNWI4OThlZmUzYjg2MDI4NzQxNTc2ZjE0OTk=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-05T16:36:02Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T22:13:52Z"}, "message": "Move the rest of core::unicode::char to core::unicode", "tree": {"sha": "a9880390ee9eb3215612bc4e574851643ec9b47f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9880390ee9eb3215612bc4e574851643ec9b47f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c52534f72f035b898efe3b86028741576f1499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c52534f72f035b898efe3b86028741576f1499", "html_url": "https://github.com/rust-lang/rust/commit/34c52534f72f035b898efe3b86028741576f1499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c52534f72f035b898efe3b86028741576f1499/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1800d695b9bd2c256f2d081da07a94e7a6cba832", "url": "https://api.github.com/repos/rust-lang/rust/commits/1800d695b9bd2c256f2d081da07a94e7a6cba832", "html_url": "https://github.com/rust-lang/rust/commit/1800d695b9bd2c256f2d081da07a94e7a6cba832"}], "stats": {"total": 540, "additions": 266, "deletions": 274}, "files": [{"sha": "0958c67ea05d9abf780d96a72bc85c8a8ec9324f", "filename": "src/libcore/char/methods.rs", "status": "renamed", "additions": 128, "deletions": 123, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=34c52534f72f035b898efe3b86028741576f1499", "patch": "@@ -8,150 +8,155 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A character type.\n-//!\n-//! The `char` type represents a single character. More specifically, since\n-//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n-//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n-//! point]'.\n-//!\n-//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n-//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n-//!\n-//! This module exists for technical reasons, the primary documentation for\n-//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n-//! itself.\n-//!\n-//! This module is the home of the iterator implementations for the iterators\n-//! implemented on `char`, as well as some useful constants and conversion\n-//! functions that convert various types to `char`.\n+//! impl char {}\n \n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use char::*;\n-use char::CharExt as C;\n-use iter::FusedIterator;\n-use fmt::{self, Write};\n+use slice;\n+use str::from_utf8_unchecked_mut;\n+use super::*;\n+use super::CharExt as C;\n+use super::printable::is_printable;\n use unicode::tables::{conversions, derived_property, general_category, property};\n \n-/// Returns an iterator that yields the lowercase equivalent of a `char`.\n-///\n-/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n-/// [`char`]: ../../std/primitive.char.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone)]\n-pub struct ToLowercase(CaseMappingIter);\n+#[stable(feature = \"core\", since = \"1.6.0\")]\n+impl CharExt for char {\n+    #[inline]\n+    fn is_digit(self, radix: u32) -> bool {\n+        self.to_digit(radix).is_some()\n+    }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for ToLowercase {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        self.0.next()\n+    #[inline]\n+    fn to_digit(self, radix: u32) -> Option<u32> {\n+        if radix > 36 {\n+            panic!(\"to_digit: radix is too high (maximum 36)\");\n+        }\n+        let val = match self {\n+          '0' ... '9' => self as u32 - '0' as u32,\n+          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n+          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n+          _ => return None,\n+        };\n+        if val < radix { Some(val) }\n+        else { None }\n     }\n-}\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for ToLowercase {}\n+    #[inline]\n+    fn escape_unicode(self) -> EscapeUnicode {\n+        let c = self as u32;\n \n-/// Returns an iterator that yields the uppercase equivalent of a `char`.\n-///\n-/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n-/// its documentation for more.\n-///\n-/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n-/// [`char`]: ../../std/primitive.char.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Debug, Clone)]\n-pub struct ToUppercase(CaseMappingIter);\n+        // or-ing 1 ensures that for c==0 the code computes that one\n+        // digit should be printed and (which is the same) avoids the\n+        // (31 - 32) underflow\n+        let msb = 31 - (c | 1).leading_zeros();\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for ToUppercase {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        self.0.next()\n+        // the index of the most significant hex digit\n+        let ms_hex_digit = msb / 4;\n+        EscapeUnicode {\n+            c: self,\n+            state: EscapeUnicodeState::Backslash,\n+            hex_digit_idx: ms_hex_digit as usize,\n+        }\n     }\n-}\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for ToUppercase {}\n+    #[inline]\n+    fn escape_default(self) -> EscapeDefault {\n+        let init_state = match self {\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n+            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+        };\n+        EscapeDefault { state: init_state }\n+    }\n \n-#[derive(Debug, Clone)]\n-enum CaseMappingIter {\n-    Three(char, char, char),\n-    Two(char, char),\n-    One(char),\n-    Zero,\n-}\n+    #[inline]\n+    fn escape_debug(self) -> EscapeDebug {\n+        let init_state = match self {\n+            '\\t' => EscapeDefaultState::Backslash('t'),\n+            '\\r' => EscapeDefaultState::Backslash('r'),\n+            '\\n' => EscapeDefaultState::Backslash('n'),\n+            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n+            c if is_printable(c) => EscapeDefaultState::Char(c),\n+            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n+        };\n+        EscapeDebug(EscapeDefault { state: init_state })\n+    }\n \n-impl CaseMappingIter {\n-    fn new(chars: [char; 3]) -> CaseMappingIter {\n-        if chars[2] == '\\0' {\n-            if chars[1] == '\\0' {\n-                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n-            } else {\n-                CaseMappingIter::Two(chars[0], chars[1])\n-            }\n+    #[inline]\n+    fn len_utf8(self) -> usize {\n+        let code = self as u32;\n+        if code < MAX_ONE_B {\n+            1\n+        } else if code < MAX_TWO_B {\n+            2\n+        } else if code < MAX_THREE_B {\n+            3\n         } else {\n-            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n+            4\n         }\n     }\n-}\n \n-impl Iterator for CaseMappingIter {\n-    type Item = char;\n-    fn next(&mut self) -> Option<char> {\n-        match *self {\n-            CaseMappingIter::Three(a, b, c) => {\n-                *self = CaseMappingIter::Two(b, c);\n-                Some(a)\n-            }\n-            CaseMappingIter::Two(b, c) => {\n-                *self = CaseMappingIter::One(c);\n-                Some(b)\n-            }\n-            CaseMappingIter::One(c) => {\n-                *self = CaseMappingIter::Zero;\n-                Some(c)\n-            }\n-            CaseMappingIter::Zero => None,\n-        }\n+    #[inline]\n+    fn len_utf16(self) -> usize {\n+        let ch = self as u32;\n+        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n     }\n-}\n \n-impl fmt::Display for CaseMappingIter {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            CaseMappingIter::Three(a, b, c) => {\n-                f.write_char(a)?;\n-                f.write_char(b)?;\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::Two(b, c) => {\n-                f.write_char(b)?;\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::One(c) => {\n-                f.write_char(c)\n-            }\n-            CaseMappingIter::Zero => Ok(()),\n+    #[inline]\n+    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n+        let code = self as u32;\n+        unsafe {\n+            let len =\n+            if code < MAX_ONE_B && !dst.is_empty() {\n+                *dst.get_unchecked_mut(0) = code as u8;\n+                1\n+            } else if code < MAX_TWO_B && dst.len() >= 2 {\n+                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n+                2\n+            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n+                3\n+            } else if dst.len() >= 4 {\n+                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n+                4\n+            } else {\n+                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf8(),\n+                    code,\n+                    dst.len())\n+            };\n+            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n         }\n     }\n-}\n-\n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for ToLowercase {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n-    }\n-}\n \n-#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n-impl fmt::Display for ToUppercase {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.0, f)\n+    #[inline]\n+    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n+        let mut code = self as u32;\n+        unsafe {\n+            if (code & 0xFFFF) == code && !dst.is_empty() {\n+                // The BMP falls through (assuming non-surrogate, as it should)\n+                *dst.get_unchecked_mut(0) = code as u16;\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n+            } else if dst.len() >= 2 {\n+                // Supplementary planes break into surrogates.\n+                code -= 0x1_0000;\n+                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n+                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n+            } else {\n+                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf16(),\n+                    code,\n+                    dst.len())\n+            }\n+        }\n     }\n }\n ", "previous_filename": "src/libcore/unicode/char.rs"}, {"sha": "7b4f0dc454882a34b81c74c5f69ea079dcd41670", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 138, "deletions": 150, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=34c52534f72f035b898efe3b86028741576f1499", "patch": "@@ -8,15 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Character manipulation.\n+//! A character type.\n //!\n-//! For more details, see ::core::unicode::char (a.k.a. std::char)\n+//! The `char` type represents a single character. More specifically, since\n+//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n+//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n+//! point]'.\n+//!\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n+//!\n+//! This module exists for technical reasons, the primary documentation for\n+//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n+//! itself.\n+//!\n+//! This module is the home of the iterator implementations for the iterators\n+//! implemented on `char`, as well as some useful constants and conversion\n+//! functions that convert various types to `char`.\n \n #![allow(non_snake_case)]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n mod convert;\n mod decode;\n+mod methods;\n mod printable;\n \n // stable re-exports\n@@ -28,8 +43,6 @@ pub use self::convert::from_u32_unchecked;\n pub use self::convert::ParseCharError;\n #[stable(feature = \"try_from\", since = \"1.26.0\")]\n pub use self::convert::CharTryFromError;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use unicode::char::{ToLowercase, ToUppercase};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n@@ -41,10 +54,7 @@ pub use unicode::version::UnicodeVersion;\n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n \n-use self::printable::is_printable;\n use fmt::{self, Write};\n-use slice;\n-use str::from_utf8_unchecked_mut;\n use iter::FusedIterator;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -137,149 +147,6 @@ pub trait CharExt {\n     fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n }\n \n-#[stable(feature = \"core\", since = \"1.6.0\")]\n-impl CharExt for char {\n-    #[inline]\n-    fn is_digit(self, radix: u32) -> bool {\n-        self.to_digit(radix).is_some()\n-    }\n-\n-    #[inline]\n-    fn to_digit(self, radix: u32) -> Option<u32> {\n-        if radix > 36 {\n-            panic!(\"to_digit: radix is too high (maximum 36)\");\n-        }\n-        let val = match self {\n-          '0' ... '9' => self as u32 - '0' as u32,\n-          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n-          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n-          _ => return None,\n-        };\n-        if val < radix { Some(val) }\n-        else { None }\n-    }\n-\n-    #[inline]\n-    fn escape_unicode(self) -> EscapeUnicode {\n-        let c = self as u32;\n-\n-        // or-ing 1 ensures that for c==0 the code computes that one\n-        // digit should be printed and (which is the same) avoids the\n-        // (31 - 32) underflow\n-        let msb = 31 - (c | 1).leading_zeros();\n-\n-        // the index of the most significant hex digit\n-        let ms_hex_digit = msb / 4;\n-        EscapeUnicode {\n-            c: self,\n-            state: EscapeUnicodeState::Backslash,\n-            hex_digit_idx: ms_hex_digit as usize,\n-        }\n-    }\n-\n-    #[inline]\n-    fn escape_default(self) -> EscapeDefault {\n-        let init_state = match self {\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ... '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n-        };\n-        EscapeDefault { state: init_state }\n-    }\n-\n-    #[inline]\n-    fn escape_debug(self) -> EscapeDebug {\n-        let init_state = match self {\n-            '\\t' => EscapeDefaultState::Backslash('t'),\n-            '\\r' => EscapeDefaultState::Backslash('r'),\n-            '\\n' => EscapeDefaultState::Backslash('n'),\n-            '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            c if is_printable(c) => EscapeDefaultState::Char(c),\n-            c => EscapeDefaultState::Unicode(c.escape_unicode()),\n-        };\n-        EscapeDebug(EscapeDefault { state: init_state })\n-    }\n-\n-    #[inline]\n-    fn len_utf8(self) -> usize {\n-        let code = self as u32;\n-        if code < MAX_ONE_B {\n-            1\n-        } else if code < MAX_TWO_B {\n-            2\n-        } else if code < MAX_THREE_B {\n-            3\n-        } else {\n-            4\n-        }\n-    }\n-\n-    #[inline]\n-    fn len_utf16(self) -> usize {\n-        let ch = self as u32;\n-        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n-    }\n-\n-    #[inline]\n-    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n-        let code = self as u32;\n-        unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n-                *dst.get_unchecked_mut(0) = code as u8;\n-                1\n-            } else if code < MAX_TWO_B && dst.len() >= 2 {\n-                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n-                2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n-                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n-                3\n-            } else if dst.len() >= 4 {\n-                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n-                4\n-            } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n-                    from_u32_unchecked(code).len_utf8(),\n-                    code,\n-                    dst.len())\n-            };\n-            from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n-        }\n-    }\n-\n-    #[inline]\n-    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n-        let mut code = self as u32;\n-        unsafe {\n-            if (code & 0xFFFF) == code && !dst.is_empty() {\n-                // The BMP falls through (assuming non-surrogate, as it should)\n-                *dst.get_unchecked_mut(0) = code as u16;\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n-            } else if dst.len() >= 2 {\n-                // Supplementary planes break into surrogates.\n-                code -= 0x1_0000;\n-                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n-                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n-                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n-            } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n-                    from_u32_unchecked(code).len_utf16(),\n-                    code,\n-                    dst.len())\n-            }\n-        }\n-    }\n-}\n-\n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s.\n ///\n@@ -545,3 +412,124 @@ impl fmt::Display for EscapeDebug {\n         fmt::Display::fmt(&self.0, f)\n     }\n }\n+\n+/// Returns an iterator that yields the lowercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n+/// [`char`]: ../../std/primitive.char.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug, Clone)]\n+pub struct ToLowercase(CaseMappingIter);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToLowercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for ToLowercase {}\n+\n+/// Returns an iterator that yields the uppercase equivalent of a `char`.\n+///\n+/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n+/// its documentation for more.\n+///\n+/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n+/// [`char`]: ../../std/primitive.char.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Debug, Clone)]\n+pub struct ToUppercase(CaseMappingIter);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for ToUppercase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for ToUppercase {}\n+\n+#[derive(Debug, Clone)]\n+enum CaseMappingIter {\n+    Three(char, char, char),\n+    Two(char, char),\n+    One(char),\n+    Zero,\n+}\n+\n+impl CaseMappingIter {\n+    fn new(chars: [char; 3]) -> CaseMappingIter {\n+        if chars[2] == '\\0' {\n+            if chars[1] == '\\0' {\n+                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+            } else {\n+                CaseMappingIter::Two(chars[0], chars[1])\n+            }\n+        } else {\n+            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n+        }\n+    }\n+}\n+\n+impl Iterator for CaseMappingIter {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                *self = CaseMappingIter::Two(b, c);\n+                Some(a)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                *self = CaseMappingIter::One(c);\n+                Some(b)\n+            }\n+            CaseMappingIter::One(c) => {\n+                *self = CaseMappingIter::Zero;\n+                Some(c)\n+            }\n+            CaseMappingIter::Zero => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CaseMappingIter {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                f.write_char(a)?;\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                f.write_char(b)?;\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::One(c) => {\n+                f.write_char(c)\n+            }\n+            CaseMappingIter::Zero => Ok(()),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for ToLowercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\n+impl fmt::Display for ToUppercase {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}"}, {"sha": "060c55286fecf592ba120330e174d789c09454c6", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c52534f72f035b898efe3b86028741576f1499/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=34c52534f72f035b898efe3b86028741576f1499", "patch": "@@ -16,7 +16,6 @@ pub(crate) mod tables;\n pub(crate) mod version;\n \n pub mod str;\n-pub(crate) mod char;\n \n // For use in liballoc, not re-exported in libstd.\n pub mod derived_property {"}]}