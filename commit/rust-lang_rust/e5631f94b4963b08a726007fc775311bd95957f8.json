{"sha": "e5631f94b4963b08a726007fc775311bd95957f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NjMxZjk0YjQ5NjNiMDhhNzI2MDA3ZmM3NzUzMTFiZDk1OTU3Zjg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-15T15:34:39Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-15T15:50:35Z"}, "message": "TRPL: move semantics", "tree": {"sha": "57a66da94e14519ca9dd8c749ff767b4f4bf7d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57a66da94e14519ca9dd8c749ff767b4f4bf7d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5631f94b4963b08a726007fc775311bd95957f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5631f94b4963b08a726007fc775311bd95957f8", "html_url": "https://github.com/rust-lang/rust/commit/e5631f94b4963b08a726007fc775311bd95957f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5631f94b4963b08a726007fc775311bd95957f8/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54abe4ce915d00ffc07d9077aebeedd052be29fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/54abe4ce915d00ffc07d9077aebeedd052be29fa", "html_url": "https://github.com/rust-lang/rust/commit/54abe4ce915d00ffc07d9077aebeedd052be29fa"}], "stats": {"total": 104, "additions": 103, "deletions": 1}, "files": [{"sha": "0e7a1130561ebb2d0d61969fc0b3a2a35302b894", "filename": "src/doc/trpl/move-semantics.md", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e5631f94b4963b08a726007fc775311bd95957f8/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/e5631f94b4963b08a726007fc775311bd95957f8/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=e5631f94b4963b08a726007fc775311bd95957f8", "patch": "@@ -1,3 +1,105 @@\n % Move Semantics\n \n-Coming Soon\n+An important aspect of [ownership][ownership] is \u2018move semantics\u2019. Move\n+semantics control how and when ownership is transferred between bindings.\n+\n+[ownership]: ownership.html\n+\n+For example, consider a type like `Vec<T>`, which owns its contents:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+```\n+\n+I can assign this vector to another binding:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+```\n+\n+But, if we try to use `v` afterwards, we get an error:\n+\n+```rust,ignore\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+\n+println!(\"v[0] is: {}\", v[0]);\n+```\n+\n+It looks like this:\n+\n+```text\n+error: use of moved value: `v`\n+println!(\"v[0] is: {}\", v[0]);\n+                        ^\n+```\n+\n+A similar thing happens if we define a function which takes ownership, and\n+try to use something after we\u2019ve passed it as an argument:\n+\n+```rust\n+fn take(v: Vec<i32>) {\n+    // what happens here isn\u2019t important.\n+}\n+\n+let v = vec![1, 2, 3];\n+\n+take(v);\n+\n+println!(\"v[0] is: {}\", v[0]);\n+```\n+\n+Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+special annotation here, it\u2019s the default thing that Rust does.\n+\n+# The details\n+\n+The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n+important. When we write code like this:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+```\n+\n+The first line creates some data for the vector on the stack, `v`. The vector\u2019s\n+data, however, is stored on the heap, and so it contains a pointer to that\n+data. When we move `v` to `v2`, it creates a copy of that data, for `v2`. Which\n+would mean two pointers to the contents of the vector on the heap. That would\n+be a problem: it would violate Rust\u2019s safety guarantees by introducing a data\n+race. Therefore, Rust forbids using `v` after we\u2019ve done the move.\n+\n+It\u2019s also important to note that optimizations may remove the actual copy of\n+the bytes, depending on circumstances. So it may not be as inefficient as it\n+initially seems.\n+\n+# `Copy` types\n+\n+We\u2019ve established that when ownership is transferred to another binding, you\n+cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n+behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n+you can think of them as an annotation to a particular type that adds extra\n+behavior. For example:\n+\n+```rust\n+let v = 1;\n+\n+let v2 = v;\n+\n+println!(\"v is: {}\", v);\n+```\n+\n+In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n+that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n+But, unlike a move, we can still use `v` afterward. This is because an `i32`\n+has no pointers to data somewhere else, copying it is a full copy.\n+\n+We will discuss how to make your own types `Copy` in the [traits][traits]\n+section.\n+\n+[traits]: traits.html"}]}