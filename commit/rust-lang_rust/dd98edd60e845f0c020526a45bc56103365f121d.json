{"sha": "dd98edd60e845f0c020526a45bc56103365f121d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkOThlZGQ2MGU4NDVmMGMwMjA1MjZhNDViYzU2MTAzMzY1ZjEyMWQ=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-03T06:57:28Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-03T06:57:28Z"}, "message": "lifetiiiiimes", "tree": {"sha": "cd2d3003ef638f4bb936c2425eb6c41ac409d5ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2d3003ef638f4bb936c2425eb6c41ac409d5ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd98edd60e845f0c020526a45bc56103365f121d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd98edd60e845f0c020526a45bc56103365f121d", "html_url": "https://github.com/rust-lang/rust/commit/dd98edd60e845f0c020526a45bc56103365f121d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd98edd60e845f0c020526a45bc56103365f121d/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4f718ad1c91e4da0438cf925a2baad39fa70181", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f718ad1c91e4da0438cf925a2baad39fa70181", "html_url": "https://github.com/rust-lang/rust/commit/e4f718ad1c91e4da0438cf925a2baad39fa70181"}], "stats": {"total": 386, "additions": 321, "deletions": 65}, "files": [{"sha": "25d849dfbc18944b709fc252ac95409ed45c29c8", "filename": "conversions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd98edd60e845f0c020526a45bc56103365f121d/conversions.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd98edd60e845f0c020526a45bc56103365f121d/conversions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/conversions.md?ref=dd98edd60e845f0c020526a45bc56103365f121d", "patch": "@@ -61,7 +61,7 @@ only implemented automatically, and enables the following transformations:\n * `T` => `Trait` where `T: Trait`\n * `SubTrait` => `Trait` where `SubTrait: Trait` (TODO: is this now implied by the previous?)\n * `Foo<..., T, ...>` => `Foo<..., U, ...>` where:\n-    * T: Unsize<U>\n+    * `T: Unsize<U>`\n     * `Foo` is a struct\n     * Only the last field has type `T`\n     * `T` is not part of the type of any other fields"}, {"sha": "976b4d53e2c91fab3a6d82aff3cd5ddc8ee25ccb", "filename": "lifetimes.md", "status": "modified", "additions": 320, "deletions": 64, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/dd98edd60e845f0c020526a45bc56103365f121d/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/dd98edd60e845f0c020526a45bc56103365f121d/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=dd98edd60e845f0c020526a45bc56103365f121d", "patch": "@@ -2,106 +2,360 @@\n \n Ownership is the breakout feature of Rust. It allows Rust to be completely\n memory-safe and efficient, while avoiding garbage collection. Before getting\n-into the ownership system in detail, we will consider a simple but *fundamental*\n-language-design problem.\n+into the ownership system in detail, we will consider the motivation of this\n+design.\n \n+TODO: Interior Mutability section\n \n \n-# The Tagged Union Problem\n \n-TODO: rewrite this to use Box instead?\n \n-The core of the lifetime and mutability system derives from a simple problem:\n-internal pointers to tagged unions. For instance, consider the following code:\n+# Living Without Garbage Collection\n+\n+We will assume that you accept that garbage collection is not always an optimal\n+solution, and that it is desirable to manually manage memory to some extent.\n+If you do not accept this, might I interest you in a different language?\n+\n+Regardless of your feelings on GC, it is pretty clearly a *massive* boon to\n+making code safe. You never have to worry about things going away *too soon*\n+(although whether you still *wanted* to be pointing at that thing is a different\n+issue...). This is a pervasive problem that C and C++ need to deal with.\n+Consider this simple mistake that all of us who have used a non-GC'd language\n+have made at one point:\n+\n+```rust,ignore\n+fn as_str(data: &u32) -> &str {\n+    // compute the string\n+    let s = format!(\"{}\", data);\n+\n+    // OH NO! We returned a reference to something that\n+    // exists only in this function!\n+    // Dangling pointer! Use after free! Alas!\n+    // (this does not compile in Rust)\n+    &s\n+}\n+```\n+\n+This is exactly what Rust's ownership system was built to solve.\n+Rust knows the scope in which the `&s` lives, and as such can prevent it from\n+escaping. However this is a simple case that even a C compiler could plausibly\n+catch. Things get more complicated as code gets bigger and pointers get fed through\n+various functions. Eventually, a C compiler will fall down and won't be able to\n+perform sufficient escape analysis to prove your code unsound. It will consequently\n+be forced to accept your program on the assumption that it is correct.\n+\n+This will never happen to Rust. It's up to the programmer to prove to the\n+compiler that everything is sound.\n+\n+Of course, rust's story around ownership is much more complicated than just\n+verifying that references don't escape the scope of their referrent. That's\n+because ensuring pointers are always valid is much more complicated than this.\n+For instance in this code,\n+\n+```rust,ignore\n+let mut data = vec![1, 2, 3];\n+// get an internal reference\n+let x = &data[0];\n+\n+// OH NO! `push` causes the backing storage of `data` to be reallocated.\n+// Dangling pointer! User after free! Alas!\n+// (this does not compile in Rust)\n+data.push(4);\n+\n+println!(\"{}\", x);\n+```\n+\n+naive scope analysis would be insufficient to prevent this bug, because `data`\n+does in fact live as long as we needed. However it was *changed* while we had\n+a reference into it. This is why Rust requires any references to freeze the\n+referrent and its owners.\n+\n+\n+\n+# References\n+\n+There are two kinds of reference:\n+\n+* Shared reference: `&`\n+* Mutable reference: `&mut`\n+\n+Which obey the following rules:\n+\n+* A reference cannot outlive its referrent\n+* A mutable reference cannot be aliased\n+\n+To define aliasing, we must define the notion of *paths* and *liveness*.\n+\n+\n+\n+\n+## Paths\n+\n+If all Rust had were values, then every value would be uniquely owned\n+by a variable or composite structure. From this we naturally derive a *tree*\n+of ownership. The stack itself is the root of the tree, with every variable\n+as its direct children. Each variable's direct children would be their fields\n+(if any), and so on.\n+\n+From this view, every value in Rust has a unique *path* in the tree of ownership.\n+References to a value can subsequently be interpretted as a path in this tree.\n+Of particular interest are *prefixes*: `x` is a prefix of `y` if `x` owns `y`\n+\n+However much data doesn't reside on the stack, and we must also accomodate this.\n+Globals and thread-locals are simple enough to model as residing at the bottom\n+of the stack. However data on the heap poses a different problem.\n+\n+If all Rust had on the heap was data uniquely by a pointer on the stack,\n+then we can just treat that pointer as a struct that owns the value on\n+the heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n+own data on the heap.\n+\n+Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance\n+introduces a notion of *shared* ownership. Shared ownership means there is no\n+unique path. A value with no unique path limits what we can do with it. In general, only\n+shared references can be created to these values. However mechanisms which ensure\n+mutual exclusion may establish One True Owner temporarily, establishing a unique path\n+to that value (and therefore all its children).\n+\n+The most common way to establish such a path is through *interior mutability*,\n+in contrast to the *inherited mutability* that everything in Rust normally uses.\n+Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types. These\n+types provide exclusive access through runtime restrictions. However it is also\n+possible to establish unique ownership without interior mutability. For instance,\n+if an Rc has refcount 1, then it is safe to mutate or move its internals.\n+\n+\n+\n+\n+## Liveness\n+\n+Roughly, a reference is *live* at some point in a program if it can be\n+dereferenced. Shared references are always live unless they are literally unreachable\n+(for instance, they reside in freed or leaked memory). Mutable references can be\n+reachable but *not* live through the process of *reborrowing*.\n+\n+A mutable reference can be reborrowed to either a shared or mutable reference.\n+Further, the reborrow can produce exactly the same reference, or point to a\n+path it is a prefix of. For instance, a mutable reference can be reborrowed\n+to point to a field of its referrent:\n \n ```rust\n-enum Foo {\n-    A(u32),\n-    B(f64),\n+let x = &mut (1, 2);\n+{\n+    // reborrow x to a subfield\n+    let y = &mut x.0;\n+    // y is now live, but x isn't\n+    *y = 3;\n }\n+// y goes out of scope, so x is live again\n+*x = (5, 7);\n+```\n \n-let mut x = B(2.0);\n-if let B(ref mut y) = x {\n-    *x = A(7);\n-    // OH NO! a u32 has been interpretted as an f64! Type-safety hole!\n-    // (this does not actually compile)\n-    println!(\"{}\", y);\n+It is also possible to reborrow into *multiple* mutable references, as long as\n+they are to *disjoint*: no reference is a prefix of another. Rust\n+explicitly enables this to be done with disjoint struct fields, because\n+disjointness can be statically proven:\n \n+```\n+let x = &mut (1, 2);\n+{\n+    // reborrow x to two disjoint subfields\n+    let y = &mut x.0;\n+    let z = &mut x.1;\n+    // y and z are now live, but x isn't\n+    *y = 3;\n+    *z = 4;\n }\n+// y and z go out of scope, so x is live again\n+*x = (5, 7);\n ```\n \n-The problem here is an intersection of 3 choices:\n+However it's often the case that Rust isn't sufficiently smart to prove that\n+multiple borrows are disjoint. *This does not mean it is fundamentally illegal\n+to make such a borrow*, just that Rust isn't as smart as you want.\n \n-* data in a tagged union is inline with the tag\n-* tagged unions are mutable\n-* being able to take a pointer into a tagged union\n+To simplify things, we can model variables as a fake type of reference: *owned*\n+references. Owned references have much the same semantics as mutable references:\n+they can be re-borrowed in a mutable or shared manner, which makes them no longer\n+live. Live owned references have the unique property that they can be moved\n+out of (though mutable references *can* be swapped out of). This is\n+only given to *live* owned references because moving its referrent would of\n+course invalidate all outstanding references prematurely.\n \n-Remove *any* of these 3 and the problem goes away. Traditionally, functional\n-languages have avoided this problem by removing the mutable\n-option. This means that they can in principle keep their data inline (ghc has\n-a pragma for this). A garbage collected imperative language like Java could alternatively\n-solve this problem by just keeping all variants elsewhere, so that changing the\n-variant of a tagged union just overwrites a pointer, and anyone with an outstanding\n-pointer to the inner data is unaffected thanks to The Magic Of Garbage Collection.\n+As a local lint against inappropriate mutation, only variables that are marked\n+as `mut` can be borrowed mutably.\n \n-Rust, by contrast, takes a subtler approach. Rust allows mutation,\n-allows pointers to inner data, and its enums have their data allocated inline.\n-However it prevents anything from being mutated while there are outstanding\n-pointers to it! And this is all done at compile time.\n+It is also interesting to note that Box behaves exactly like an owned\n+reference. It can be moved out of, and Rust understands it sufficiently to\n+reason about its paths like a normal variable.\n \n-Interestingly, Rust's `std::cell` module exposes two types that offer an alternative\n-approach to this problem:\n \n-* The `Cell` type allows mutation of aliased data, but\n-instead forbids internal pointers to that data. The only way to read or write\n-a Cell is to copy the bits in or out.\n \n-* The `RefCell` type allows mutation of aliased data *and* internal pointers, but\n-manages this through *runtime* checks. It is effectively a thread-unsafe\n-read-write lock.\n \n-For more details see Dan Grossman's *Existential Types for Imperative Languages*:\n+## Aliasing\n \n-* [paper][grossman-paper] (Advanced)\n-* [slides][grossman-slides] (Simple)\n+With liveness and paths defined, we can now properly define *aliasing*:\n \n-[grossman-paper]: http://homes.cs.washington.edu/~djg/papers/exists_imp.pdf\n-[grossman-slides]: https://homes.cs.washington.edu/~djg/slides/esop02_talk.pdf\n+**A mutable reference is aliased if there exists another live reference to it or\n+one of its prefixes.**\n+\n+That's it. Super simple right? Except for the fact that it took us two pages\n+to define all of the terms in that defintion. You know: Super. Simple.\n+\n+Actually it's a bit more complicated than that. In addition to references,\n+Rust has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent\n+ownership or aliasing semantics. As a result, Rust makes absolutely no effort\n+to track that they are used correctly, and they are wildly unsafe.\n+\n+**It is an open question to what degree raw pointers have alias semantics.\n+However it is important for these definitions to be sound that the existence\n+of a raw pointer does not imply some kind of live path.**\n \n \n \n \n # Lifetimes\n \n-Rust's static checks are managed by the *borrow checker* (borrowck), which tracks\n-mutability and outstanding loans. This analysis can in principle be done without\n-any help locally. However as soon as data starts crossing the function boundary,\n-we have some serious trouble. In principle, borrowck could be a massive\n-whole-program analysis engine to handle this problem, but this would be an\n-atrocious solution. It would be terribly slow, and errors would be horribly\n-non-local.\n+Rust enforces these rules through *lifetimes*. Lifetimes are effectively\n+just names for scopes on the stack, somewhere in the program. Each reference,\n+and anything that contains a reference, is tagged with a lifetime specifying\n+the scope it's valid for.\n \n-Instead, Rust tracks ownership through *lifetimes*. Every single reference and value\n-in Rust is tagged with a lifetime that indicates the scope it is valid for.\n-Rust has two kinds of reference:\n+Within a function body, Rust generally doesn't let you explicitly name the\n+lifetimes involved. This is because it's generally not really *necessary*\n+to talk about lifetimes in a local context; rust has all the information and\n+can work out everything.\n \n-* Shared reference: `&`\n-* Mutable reference: `&mut`\n+However once you cross the function boundary, you need to start talking about\n+lifetimes. Lifetimes are denoted with an apostrophe: `'a`, `'static`. To dip\n+our toes with lifetimes, we're going to pretend that we're actually allowed\n+to label scopes with lifetimes, and desugar the examples from the start of\n+this chapter.\n \n-The main rules are as follows:\n+Our examples made use of *aggressive* sugar around scopes and lifetimes,\n+because writing everything out explicitly is *extremely noisy*. All rust code\n+relies on aggressive inference and elision of \"obvious\" things.\n \n-* A shared reference can be aliased\n-* A mutable reference cannot be aliased\n-* A reference cannot outlive its referrent (`&'a T -> T: 'a`)\n+One particularly interesting piece of sugar is that each `let` statement implicitly\n+introduces a scope. For the most part, this doesn't really matter. However it\n+does matter for variables that refer to each other. As a simple example, let's\n+completely desugar this simple piece of Rust code:\n \n-However non-mutable variables have some special rules:\n+```rust\n+let x = 0;\n+let y = &x;\n+let z = &y;\n+```\n \n-* You cannot mutate or mutably borrow a non-mut variable,\n+becomes:\n \n-Only variables marked as mutable can be borrowed mutably, though this is little\n-more than a local lint against incorrect usage of a value.\n+```rust,ignore\n+// NOTE: `'a:` and `&'a x` is not valid syntax!\n+'a: {\n+    let x: i32 = 0;\n+    'b: {\n+        let y: &'a i32 = &'a x;\n+        'c: {\n+            let z: &'b &'a i32 = &'b y;\n+        }\n+    }\n+}\n+```\n \n+Wow. That's... awful. Let's all take a moment to thank Rust for being a huge\n+pile of sugar with sugar on top.\n \n+Anyway, let's look at some of those examples from before:\n+\n+```rust,ignore\n+fn as_str(data: &u32) -> &str {\n+    let s = format!(\"{}\", data);\n+    &s\n+}\n+```\n+\n+desugars to:\n+\n+```rust,ignore\n+fn as_str<'a>(data: &'a u32) -> &'a str {\n+    'b: {\n+        let s = format!(\"{}\", data);\n+        return &'b s\n+    }\n+}\n+```\n+\n+This signature of `as_str` takes a reference to a u32 with *some* lifetime, and\n+promises that it can produce a reference to a str that can live *just as long*.\n+Already we can see why this signature might be trouble. That basically implies\n+that we're going to *find* a str somewhere in the scope that u32 originated in,\n+or somewhere *even* earlier. That's uh... a big ask.\n+\n+We then proceed to compute the string `s`, and return a reference to it.\n+Unfortunately, since `s` was defined in the scope `'b`, the reference we're\n+returning can only live for that long. From the perspective of the compiler,\n+we've failed *twice* here. We've failed to fulfill the contract we were asked\n+to fulfill (`'b` is unrelated to `'a`); and we've also tried to make a reference\n+outlive its referrent by returning an `&'b`, where `'b` is in our function.\n+\n+Shoot!\n+\n+Of course, the right way to right this function is as follows:\n+\n+```rust\n+fn to_string(data: &u32) -> String {\n+    format!(\"{}\", data)\n+}\n+```\n+\n+We must produce an owned value inside the function to return it! The only way\n+we could have returned an `&'a str` would have been if it was in a field of the\n+`&'a u32`, which is obviously not the case.\n+\n+(Actually we could have also just returned a string literal, though this limits\n+the behaviour of our function *just a bit*.)\n+\n+How about the other example:\n+\n+```rust,ignore\n+let mut data = vec![1, 2, 3];\n+let x = &data[0];\n+data.push(4);\n+println!(\"{}\", x);\n+```\n+\n+```rust,ignore\n+'a: {\n+    let mut data: Vec<i32> = vec![1, 2, 3];\n+    'b: {\n+        let x: &'a i32 = Index::index(&'a data, 0);\n+        'c: {\n+            // Exactly what the desugar for Vec::push is is up to Rust.\n+            // This particular desugar is a decent approximation for our\n+            // purpose. In particular methods oft invoke a temporary borrow.\n+            let temp: &'c mut Vec = &'c mut data;\n+            // NOTE: Vec::push is not valid syntax\n+            Vec::push(temp, 4);\n+        }\n+        println!(\"{}\", x);\n+    }\n+}\n+```\n+\n+Here the problem is that we're trying to mutably borrow the `data` path, while\n+we have a reference into something it's a prefix of. Rust subsequently throws\n+up its hands in disgust and rejects our program. The correct way to write this\n+is to just re-order the code so that we make `x` *after* we push:\n+\n+TODO: convince myself of this.\n+\n+```rust\n+let mut data = vec![1, 2, 3];\n+data.push(4);\n+\n+let x = &data[0];\n+println!(\"{}\", x);\n+```\n \n \n \n@@ -213,7 +467,9 @@ these are unstable due to their awkward nature and questionable utility.\n \n \n \n-# Higher-Rank Lifetimes\n+# Higher-Rank Trait Bounds\n+\n+// TODO: make aturon less mad\n \n Generics in Rust generally allow types to be instantiated with arbitrary\n associated lifetimes, but this fixes the lifetimes they work with once"}]}