{"sha": "efec545293b9263be9edfb283a7aa66350b3acbf", "node_id": "C_kwDOAAsO6NoAKGVmZWM1NDUyOTNiOTI2M2JlOWVkZmIyODNhN2FhNjYzNTBiM2FjYmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-04T13:23:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-04T13:23:50Z"}, "message": "Auto merge of #91517 - matthiaskrgr:rollup-3fmp4go, r=matthiaskrgr\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #87054 (Add a `try_reduce` method to the Iterator trait)\n - #89701 (Updated error message for accidental uses of derive attribute as a crate attribute)\n - #90519 (Keep spans for generics in `#[derive(_)]` desugaring)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9cec8a6ff34e219b97d4f32ed62812b50533be54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cec8a6ff34e219b97d4f32ed62812b50533be54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efec545293b9263be9edfb283a7aa66350b3acbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efec545293b9263be9edfb283a7aa66350b3acbf", "html_url": "https://github.com/rust-lang/rust/commit/efec545293b9263be9edfb283a7aa66350b3acbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efec545293b9263be9edfb283a7aa66350b3acbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "887999d163bace7e79370b952bdd1f930ff4cdd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/887999d163bace7e79370b952bdd1f930ff4cdd5", "html_url": "https://github.com/rust-lang/rust/commit/887999d163bace7e79370b952bdd1f930ff4cdd5"}, {"sha": "0311cfa88cd4f86493b197ad4d337eb6085c8c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/0311cfa88cd4f86493b197ad4d337eb6085c8c03", "html_url": "https://github.com/rust-lang/rust/commit/0311cfa88cd4f86493b197ad4d337eb6085c8c03"}], "stats": {"total": 879, "additions": 731, "deletions": 148}, "files": [{"sha": "1427a2aada3fc485d77d326b6c9ad25391dd9d74", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 76, "deletions": 78, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -567,8 +567,11 @@ impl<'a> TraitDef<'a> {\n             })\n         });\n \n-        let Generics { mut params, mut where_clause, span } =\n+        let Generics { mut params, mut where_clause, .. } =\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n+        where_clause.span = generics.where_clause.span;\n+        let ctxt = self.span.ctxt();\n+        let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n         params.extend(generics.params.iter().map(|param| match &param.kind {\n@@ -589,12 +592,12 @@ impl<'a> TraitDef<'a> {\n                         param.bounds.iter().cloned()\n                     ).collect();\n \n-                cx.typaram(self.span, param.ident, vec![], bounds, None)\n+                cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, vec![], bounds, None)\n             }\n             GenericParamKind::Const { ty, kw_span, .. } => {\n                 let const_nodefault_kind = GenericParamKind::Const {\n                     ty: ty.clone(),\n-                    kw_span: *kw_span,\n+                    kw_span: kw_span.with_ctxt(ctxt),\n \n                     // We can't have default values inside impl block\n                     default: None,\n@@ -607,28 +610,27 @@ impl<'a> TraitDef<'a> {\n \n         // and similarly for where clauses\n         where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n-            match *clause {\n-                ast::WherePredicate::BoundPredicate(ref wb) => {\n+            match clause {\n+                ast::WherePredicate::BoundPredicate(wb) => {\n+                    let span = wb.span.with_ctxt(ctxt);\n                     ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                        span: self.span,\n-                        bound_generic_params: wb.bound_generic_params.clone(),\n-                        bounded_ty: wb.bounded_ty.clone(),\n-                        bounds: wb.bounds.to_vec(),\n+                        span,\n+                        ..wb.clone()\n                     })\n                 }\n-                ast::WherePredicate::RegionPredicate(ref rb) => {\n+                ast::WherePredicate::RegionPredicate(wr) => {\n+                    let span = wr.span.with_ctxt(ctxt);\n                     ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n-                        span: self.span,\n-                        lifetime: rb.lifetime,\n-                        bounds: rb.bounds.to_vec(),\n+                        span,\n+                        ..wr.clone()\n                     })\n                 }\n-                ast::WherePredicate::EqPredicate(ref we) => {\n+                ast::WherePredicate::EqPredicate(we) => {\n+                    let span = we.span.with_ctxt(ctxt);\n                     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         id: ast::DUMMY_NODE_ID,\n-                        span: self.span,\n-                        lhs_ty: we.lhs_ty.clone(),\n-                        rhs_ty: we.rhs_ty.clone(),\n+                        span,\n+                        ..we.clone()\n                     })\n                 }\n             }\n@@ -691,13 +693,13 @@ impl<'a> TraitDef<'a> {\n             .iter()\n             .map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n-                    GenericArg::Lifetime(cx.lifetime(self.span, param.ident))\n+                    GenericArg::Lifetime(cx.lifetime(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n                 GenericParamKind::Type { .. } => {\n-                    GenericArg::Type(cx.ty_ident(self.span, param.ident))\n+                    GenericArg::Type(cx.ty_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n                 GenericParamKind::Const { .. } => {\n-                    GenericArg::Const(cx.const_ident(self.span, param.ident))\n+                    GenericArg::Const(cx.const_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n                 }\n             })\n             .collect();\n@@ -845,16 +847,17 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         fields: &SubstructureFields<'_>,\n     ) -> P<Expr> {\n+        let span = trait_.span;\n         let substructure = Substructure {\n             type_ident,\n-            method_ident: Ident::new(self.name, trait_.span),\n+            method_ident: Ident::new(self.name, span),\n             self_args,\n             nonself_args,\n             fields,\n         };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n-        f(cx, trait_.span, &substructure)\n+        f(cx, span, &substructure)\n     }\n \n     fn get_ret_ty(\n@@ -882,9 +885,10 @@ impl<'a> MethodDef<'a> {\n         let mut nonself_args = Vec::new();\n         let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n+        let span = trait_.span;\n \n         let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n-            let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_.span, self_ptr);\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n \n             self_args.push(self_expr);\n             nonstatic = true;\n@@ -893,11 +897,11 @@ impl<'a> MethodDef<'a> {\n         });\n \n         for (ty, name) in self.args.iter() {\n-            let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = Ident::new(*name, trait_.span);\n+            let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n+            let ident = Ident::new(*name, span);\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = cx.expr_ident(trait_.span, ident);\n+            let arg_expr = cx.expr_ident(span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -906,7 +910,7 @@ impl<'a> MethodDef<'a> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(ref ty, _) if matches!(**ty, Self_) && nonstatic => {\n-                    self_args.push(cx.expr_deref(trait_.span, arg_expr))\n+                    self_args.push(cx.expr_deref(span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -927,41 +931,41 @@ impl<'a> MethodDef<'a> {\n         arg_types: Vec<(Ident, P<ast::Ty>)>,\n         body: P<Expr>,\n     ) -> P<ast::AssocItem> {\n+        let span = trait_.span;\n         // Create the generics that aren't for `Self`.\n-        let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n+                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(span);\n                 ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n             });\n-            let nonself_args =\n-                arg_types.into_iter().map(|(name, ty)| cx.param(trait_.span, name, ty));\n+            let nonself_args = arg_types.into_iter().map(|(name, ty)| cx.param(span, name, ty));\n             self_args.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = Ident::new(self.name, trait_.span);\n+        let method_ident = Ident::new(self.name, span);\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n-        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(trait_.span) } else { ast::Unsafe::No };\n+        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(span) } else { ast::Unsafe::No };\n \n-        let trait_lo_sp = trait_.span.shrink_to_lo();\n+        let trait_lo_sp = span.shrink_to_lo();\n \n         let sig = ast::FnSig {\n             header: ast::FnHeader { unsafety, ext: ast::Extern::None, ..ast::FnHeader::default() },\n             decl: fn_decl,\n-            span: trait_.span,\n+            span,\n         };\n         let defaultness = ast::Defaultness::Final;\n \n         // Create the method.\n         P(ast::AssocItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n-            span: trait_.span,\n+            span,\n             vis: ast::Visibility {\n                 span: trait_lo_sp,\n                 kind: ast::VisibilityKind::Inherited,\n@@ -1024,11 +1028,11 @@ impl<'a> MethodDef<'a> {\n         nonself_args: &[P<Expr>],\n         use_temporaries: bool,\n     ) -> P<Expr> {\n-        let mut raw_fields = Vec::new(); // Vec<[fields of self],\n-        // [fields of next Self arg], [etc]>\n+        let mut raw_fields = Vec::new(); // Vec<[fields of self], [fields of next Self arg], [etc]>\n+        let span = trait_.span;\n         let mut patterns = Vec::new();\n         for i in 0..self_args.len() {\n-            let struct_path = cx.path(trait_.span, vec![type_ident]);\n+            let struct_path = cx.path(span, vec![type_ident]);\n             let (pat, ident_expr) = trait_.create_struct_pattern(\n                 cx,\n                 struct_path,\n@@ -1048,7 +1052,7 @@ impl<'a> MethodDef<'a> {\n             let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n             first_field\n                 .map(|(span, opt_id, field, attrs)| FieldInfo {\n-                    span,\n+                    span: span.with_ctxt(trait_.span.ctxt()),\n                     name: opt_id,\n                     self_: field,\n                     other: other_fields\n@@ -1062,7 +1066,7 @@ impl<'a> MethodDef<'a> {\n                 })\n                 .collect()\n         } else {\n-            cx.span_bug(trait_.span, \"no `self` parameter for method in generic `derive`\")\n+            cx.span_bug(span, \"no `self` parameter for method in generic `derive`\")\n         };\n \n         // body of the inner most destructuring match\n@@ -1079,11 +1083,7 @@ impl<'a> MethodDef<'a> {\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n         for (arg_expr, pat) in iter::zip(self_args, patterns) {\n-            body = cx.expr_match(\n-                trait_.span,\n-                arg_expr.clone(),\n-                vec![cx.arm(trait_.span, pat.clone(), body)],\n-            )\n+            body = cx.expr_match(span, arg_expr.clone(), vec![cx.arm(span, pat.clone(), body)])\n         }\n \n         body\n@@ -1193,7 +1193,7 @@ impl<'a> MethodDef<'a> {\n         mut self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>],\n     ) -> P<Expr> {\n-        let sp = trait_.span;\n+        let span = trait_.span;\n         let variants = &enum_def.variants;\n \n         let self_arg_names = iter::once(\"__self\".to_string())\n@@ -1208,7 +1208,7 @@ impl<'a> MethodDef<'a> {\n \n         let self_arg_idents = self_arg_names\n             .iter()\n-            .map(|name| Ident::from_str_and_span(name, sp))\n+            .map(|name| Ident::from_str_and_span(name, span))\n             .collect::<Vec<Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n@@ -1218,7 +1218,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|name| {\n                 let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                Ident::from_str_and_span(&vi_suffix, trait_.span)\n+                Ident::from_str_and_span(&vi_suffix, span)\n             })\n             .collect::<Vec<Ident>>();\n \n@@ -1248,7 +1248,7 @@ impl<'a> MethodDef<'a> {\n                         self_arg_name,\n                         ast::Mutability::Not,\n                     );\n-                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Not)), idents)\n+                    (cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1267,7 +1267,7 @@ impl<'a> MethodDef<'a> {\n                 }\n \n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n-                let single_pat = cx.pat_tuple(sp, subpats);\n+                let single_pat = cx.pat_tuple(span, subpats);\n \n                 // For the BodyK, we need to delegate to our caller,\n                 // passing it an EnumMatching to indicate which case\n@@ -1284,7 +1284,7 @@ impl<'a> MethodDef<'a> {\n                     .into_iter()\n                     .enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (sp, opt_ident, self_getter_expr, attrs))| {\n+                    .map(|(field_index, (span, opt_ident, self_getter_expr, attrs))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n                         // so walk across the *other* self_pats_idents\n@@ -1307,7 +1307,7 @@ impl<'a> MethodDef<'a> {\n                             .collect::<Vec<P<Expr>>>();\n \n                         FieldInfo {\n-                            span: sp,\n+                            span,\n                             name: opt_ident,\n                             self_: self_getter_expr,\n                             other: others,\n@@ -1330,7 +1330,7 @@ impl<'a> MethodDef<'a> {\n                     &substructure,\n                 );\n \n-                cx.arm(sp, single_pat, arm_expr)\n+                cx.arm(span, single_pat, arm_expr)\n             })\n             .collect();\n \n@@ -1353,12 +1353,12 @@ impl<'a> MethodDef<'a> {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n-                Some(deriving::call_unreachable(cx, sp))\n+                Some(deriving::call_unreachable(cx, span))\n             }\n             _ => None,\n         };\n         if let Some(arm) = default {\n-            match_arms.push(cx.arm(sp, cx.pat_wild(sp), arm));\n+            match_arms.push(cx.arm(span, cx.pat_wild(span), arm));\n         }\n \n         // We will usually need the catch-all after matching the\n@@ -1392,23 +1392,23 @@ impl<'a> MethodDef<'a> {\n \n             // We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n-            let mut discriminant_test = cx.expr_bool(sp, true);\n+            let mut discriminant_test = cx.expr_bool(span, true);\n \n             let mut first_ident = None;\n             for (&ident, self_arg) in iter::zip(&vi_idents, &self_args) {\n-                let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n+                let self_addr = cx.expr_addr_of(span, self_arg.clone());\n                 let variant_value =\n-                    deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n+                    deriving::call_intrinsic(cx, span, sym::discriminant_value, vec![self_addr]);\n+                let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n                 match first_ident {\n                     Some(first) => {\n-                        let first_expr = cx.expr_ident(sp, first);\n-                        let id = cx.expr_ident(sp, ident);\n-                        let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n+                        let first_expr = cx.expr_ident(span, first);\n+                        let id = cx.expr_ident(span, ident);\n+                        let test = cx.expr_binary(span, BinOpKind::Eq, first_expr, id);\n                         discriminant_test =\n-                            cx.expr_binary(sp, BinOpKind::And, discriminant_test, test)\n+                            cx.expr_binary(span, BinOpKind::And, discriminant_test, test)\n                     }\n                     None => {\n                         first_ident = Some(ident);\n@@ -1430,8 +1430,8 @@ impl<'a> MethodDef<'a> {\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n \n             // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n@@ -1445,10 +1445,10 @@ impl<'a> MethodDef<'a> {\n             //  else {\n             //      <delegated expression referring to __self0_vi, et al.>\n             //  }\n-            let all_match = cx.expr_match(sp, match_arg, match_arms);\n-            let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n+            let all_match = cx.expr_match(span, match_arg, match_arms);\n+            let arm_expr = cx.expr_if(span, discriminant_test, all_match, Some(arm_expr));\n             index_let_stmts.push(cx.stmt_expr(arm_expr));\n-            cx.expr_block(cx.block(sp, index_let_stmts))\n+            cx.expr_block(cx.block(span, index_let_stmts))\n         } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n@@ -1499,16 +1499,16 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_unreachable(cx, sp)\n+            deriving::call_unreachable(cx, span)\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n-            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n-            cx.expr_match(sp, match_arg, match_arms)\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(span, self_arg));\n+            let match_arg = cx.expr(span, ast::ExprKind::Tup(self_args));\n+            cx.expr_match(span, match_arg, match_arms)\n         }\n     }\n \n@@ -1556,11 +1556,9 @@ impl<'a> TraitDef<'a> {\n \n         let is_tuple = matches!(struct_def, ast::VariantData::Tuple(..));\n         match (just_spans.is_empty(), named_idents.is_empty()) {\n-            (false, false) => cx.span_bug(\n-                self.span,\n-                \"a struct with named and unnamed \\\n-                                          fields in generic `derive`\",\n-            ),\n+            (false, false) => {\n+                cx.span_bug(self.span, \"a struct with named and unnamed fields in generic `derive`\")\n+            }\n             // named fields\n             (_, false) => Named(named_idents),\n             // unnamed fields"}, {"sha": "7a418003250841fdb2e1fbe71777a495f3b5c4c6", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -211,14 +211,6 @@ fn mk_ty_param(\n     cx.typaram(span, Ident::new(name, span), attrs.to_owned(), bounds, None)\n }\n \n-fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n-    Generics {\n-        params,\n-        where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n-        span,\n-    }\n-}\n-\n /// Bounds on type parameters.\n #[derive(Clone)]\n pub struct Bounds {\n@@ -236,7 +228,7 @@ impl Bounds {\n         self_ty: Ident,\n         self_generics: &Generics,\n     ) -> Generics {\n-        let generic_params = self\n+        let params = self\n             .bounds\n             .iter()\n             .map(|t| {\n@@ -245,7 +237,11 @@ impl Bounds {\n             })\n             .collect();\n \n-        mk_generics(generic_params, span)\n+        Generics {\n+            params,\n+            where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+            span,\n+        }\n     }\n }\n "}, {"sha": "487ae87052ba30f0206ec1662bce2bcdb8ccf387", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -17,8 +17,7 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{def_id::LocalDefId, BytePos};\n-use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{def_id::LocalDefId, BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use rustc_target::spec::abi::Abi;\n \n@@ -526,12 +525,20 @@ pub struct GenericParam<'hir> {\n }\n \n impl GenericParam<'hir> {\n-    pub fn bounds_span(&self) -> Option<Span> {\n-        self.bounds.iter().fold(None, |span, bound| {\n-            let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n-\n-            Some(span)\n-        })\n+    pub fn bounds_span_for_suggestions(&self) -> Option<Span> {\n+        self.bounds\n+            .iter()\n+            .fold(None, |span: Option<Span>, bound| {\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                if !bound.span().can_be_used_for_suggestions() {\n+                    None\n+                } else {\n+                    let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n+                    Some(span)\n+                }\n+            })\n+            .map(|sp| sp.shrink_to_hi())\n     }\n }\n "}, {"sha": "8803370251b38929f5acf2123573cb394db12f68", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -270,7 +270,7 @@ pub fn suggest_constraining_type_param(\n         // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n         && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n     {\n-        if let Some(bounds_span) = param.bounds_span() {\n+        if let Some(span) = param.bounds_span_for_suggestions() {\n             // If user has provided some bounds, suggest restricting them:\n             //\n             //   fn foo<T: Foo>(t: T) { ... }\n@@ -284,7 +284,7 @@ pub fn suggest_constraining_type_param(\n             //          --\n             //          |\n             //          replace with: `T: Bar +`\n-            suggest_restrict(bounds_span.shrink_to_hi());\n+            suggest_restrict(span);\n         } else {\n             // If user hasn't provided any bounds, suggest adding a new one:\n             //"}, {"sha": "49e6a7df103012e7f773ca32555d05ff899fa08d", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1953,28 +1953,52 @@ fn is_c_like_enum(item: &Item<'_>) -> bool {\n     }\n }\n \n+// FIXME: Fix \"Cannot determine resolution\" error and remove built-in macros\n+// from this check.\n fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n+    // Check for builtin attributes at the crate level\n+    // which were unsuccessfully resolved due to cannot determine\n+    // resolution for the attribute macro error.\n     const ATTRS_TO_CHECK: &[Symbol] = &[\n         sym::macro_export,\n         sym::repr,\n         sym::path,\n         sym::automatically_derived,\n         sym::start,\n         sym::rustc_main,\n+        sym::derive,\n+        sym::test,\n+        sym::test_case,\n+        sym::global_allocator,\n+        sym::bench,\n     ];\n \n     for attr in attrs {\n-        for attr_to_check in ATTRS_TO_CHECK {\n-            if attr.has_name(*attr_to_check) {\n-                tcx.sess\n-                    .struct_span_err(\n+        // This function should only be called with crate attributes\n+        // which are inner attributes always but lets check to make sure\n+        if attr.style == AttrStyle::Inner {\n+            for attr_to_check in ATTRS_TO_CHECK {\n+                if attr.has_name(*attr_to_check) {\n+                    let mut err = tcx.sess.struct_span_err(\n                         attr.span,\n                         &format!(\n                             \"`{}` attribute cannot be used at crate level\",\n                             attr_to_check.to_ident_string()\n                         ),\n-                    )\n-                    .emit();\n+                    );\n+                    // Only emit an error with a suggestion if we can create a\n+                    // string out of the attribute span\n+                    if let Ok(src) = tcx.sess.source_map().span_to_snippet(attr.span) {\n+                        let replacement = src.replace(\"#!\", \"#\");\n+                        err.span_suggestion_verbose(\n+                            attr.span,\n+                            \"perhaps you meant to use an outer attribute\",\n+                            replacement,\n+                            rustc_errors::Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    err.emit()\n+                }\n             }\n         }\n     }"}, {"sha": "72ba3f7b980cbc464de015724d1e2d31d27e7db0", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1735,7 +1735,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         (generics.span, format!(\"<{}>\", ident))\n                     };\n                     // Do not suggest if this is coming from macro expansion.\n-                    if !span.from_expansion() {\n+                    if span.can_be_used_for_suggestions() {\n                         return Some((\n                             span.shrink_to_hi(),\n                             msg,\n@@ -1803,7 +1803,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         );\n         err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n         let mut suggests_in_band = false;\n-        let mut suggest_note = true;\n+        let mut suggested_spans = vec![];\n         for missing in &self.missing_named_lifetime_spots {\n             match missing {\n                 MissingLifetimeSpot::Generics(generics) => {\n@@ -1821,23 +1821,17 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         suggests_in_band = true;\n                         (generics.span, format!(\"<{}>\", lifetime_ref))\n                     };\n-                    if !span.from_expansion() {\n+                    if suggested_spans.contains(&span) {\n+                        continue;\n+                    }\n+                    suggested_spans.push(span);\n+                    if span.can_be_used_for_suggestions() {\n                         err.span_suggestion(\n                             span,\n                             &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n                             sugg,\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if suggest_note {\n-                        suggest_note = false; // Avoid displaying the same help multiple times.\n-                        err.span_label(\n-                            span,\n-                            &format!(\n-                                \"lifetime `{}` is missing in item created through this procedural \\\n-                                 macro\",\n-                                lifetime_ref,\n-                            ),\n-                        );\n                     }\n                 }\n                 MissingLifetimeSpot::HigherRanked { span, span_type } => {"}, {"sha": "98478cf5dec692ae393431fb4ed2a1b80ecdc19c", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -551,6 +551,16 @@ impl Span {\n         matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n     }\n \n+    /// Gate suggestions that would not be appropriate in a context the user didn't write.\n+    pub fn can_be_used_for_suggestions(self) -> bool {\n+        !self.from_expansion()\n+        // FIXME: If this span comes from a `derive` macro but it points at code the user wrote,\n+        // the callsite span and the span will be pointing at different places. It also means that\n+        // we can safely provide suggestions on this span.\n+            || (matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n+                && self.parent_callsite().map(|p| (p.lo(), p.hi())) != Some((self.lo(), self.hi())))\n+    }\n+\n     #[inline]\n     pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n         Span::new(lo, hi, SyntaxContext::root(), None)"}, {"sha": "2e87d6fdd3dc20e787ac0a3a4405b4c5e4272ade", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -262,16 +262,16 @@ fn suggest_restriction(\n             match generics\n                 .params\n                 .iter()\n-                .map(|p| p.bounds_span().unwrap_or(p.span))\n-                .filter(|&span| generics.span.contains(span) && span.desugaring_kind().is_none())\n+                .map(|p| p.bounds_span_for_suggestions().unwrap_or(p.span.shrink_to_hi()))\n+                .filter(|&span| generics.span.contains(span) && span.can_be_used_for_suggestions())\n                 .max_by_key(|span| span.hi())\n             {\n                 // `fn foo(t: impl Trait)`\n                 //        ^ suggest `<T: Trait>` here\n                 None => (generics.span, format!(\"<{}>\", type_param)),\n                 // `fn foo<A>(t: impl Trait)`\n                 //        ^^^ suggest `<A, T: Trait>` here\n-                Some(span) => (span.shrink_to_hi(), format!(\", {}\", type_param)),\n+                Some(span) => (span, format!(\", {}\", type_param)),\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`"}, {"sha": "eaa69b7eb608646ba4cb8a82086edf60fc3603ab", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -177,11 +177,9 @@ crate fn placeholder_type_error(\n         sugg.push((arg.span, (*type_name).to_string()));\n     } else {\n         let last = generics.iter().last().unwrap();\n-        sugg.push((\n-            // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n-            last.bounds_span().unwrap_or(last.span).shrink_to_hi(),\n-            format!(\", {}\", type_name),\n-        ));\n+        // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n+        let span = last.bounds_span_for_suggestions().unwrap_or(last.span.shrink_to_hi());\n+        sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n     let mut err = bad_placeholder_type(tcx, placeholder_types, kind);"}, {"sha": "267fa4067983693c6c043e19533a477190484ae2", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -2216,6 +2216,86 @@ pub trait Iterator {\n         Some(self.fold(first, f))\n     }\n \n+    /// Reduces the elements to a single one by repeatedly applying a reducing operation. If the\n+    /// closure returns a failure, the failure is propagated back to the caller immediately.\n+    ///\n+    /// The return type of this method depends on the return type of the closure. If the closure\n+    /// returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,\n+    /// E>`. If the closure returns `Option<Self::Item>`, then this function will return\n+    /// `Option<Option<Self::Item>>`.\n+    ///\n+    /// When called on an empty iterator, this function will return either `Some(None)` or\n+    /// `Ok(None)` depending on the type of the provided closure.\n+    ///\n+    /// For iterators with at least one element, this is essentially the same as calling\n+    /// [`try_fold()`] with the first element of the iterator as the initial accumulator value.\n+    ///\n+    /// [`try_fold()`]: Iterator::try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Safely calculate the sum of a series of numbers:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_reduce)]\n+    ///\n+    /// let numbers: Vec<usize> = vec![10, 20, 5, 23, 0];\n+    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    /// assert_eq!(sum, Some(Some(58)));\n+    /// ```\n+    ///\n+    /// Determine when a reduction short circuited:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_reduce)]\n+    ///\n+    /// let numbers = vec![1, 2, 3, usize::MAX, 4, 5];\n+    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    /// assert_eq!(sum, None);\n+    /// ```\n+    ///\n+    /// Determine when a reduction was not performed because there are no elements:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_reduce)]\n+    ///\n+    /// let numbers: Vec<usize> = Vec::new();\n+    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    /// assert_eq!(sum, Some(None));\n+    /// ```\n+    ///\n+    /// Use a [`Result`] instead of an [`Option`]:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_reduce)]\n+    ///\n+    /// let numbers = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];\n+    /// let max: Result<Option<_>, <usize as std::str::FromStr>::Err> =\n+    ///     numbers.into_iter().try_reduce(|x, y| {\n+    ///         if x.parse::<usize>()? > y.parse::<usize>()? { Ok(x) } else { Ok(y) }\n+    ///     });\n+    /// assert_eq!(max, Ok(Some(\"5\")));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_reduce\", reason = \"new API\", issue = \"87053\")]\n+    fn try_reduce<F, R>(&mut self, f: F) -> ChangeOutputType<R, Option<R::Output>>\n+    where\n+        Self: Sized,\n+        F: FnMut(Self::Item, Self::Item) -> R,\n+        R: Try<Output = Self::Item>,\n+        R::Residual: Residual<Option<Self::Item>>,\n+    {\n+        let first = match self.next() {\n+            Some(i) => i,\n+            None => return Try::from_output(None),\n+        };\n+\n+        match self.try_fold(first, f).branch() {\n+            ControlFlow::Break(r) => FromResidual::from_residual(r),\n+            ControlFlow::Continue(i) => Try::from_output(Some(i)),\n+        }\n+    }\n+\n     /// Tests if every element of the iterator matches a predicate.\n     ///\n     /// `all()` takes a closure that returns `true` or `false`. It applies"}, {"sha": "d38bca1e3b3ea9265ad1c410c3d6704e5d08bcf9", "filename": "library/core/tests/iter/traits/iterator.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Ftraits%2Fiterator.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -454,6 +454,34 @@ fn test_find_map() {\n     }\n }\n \n+#[test]\n+fn test_try_reduce() {\n+    let v: Vec<usize> = vec![1, 2, 3, 4, 5];\n+    let sum = v.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    assert_eq!(sum, Some(Some(15)));\n+\n+    let v: Vec<usize> = vec![1, 2, 3, 4, 5, usize::MAX];\n+    let sum = v.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    assert_eq!(sum, None);\n+\n+    let v: Vec<usize> = Vec::new();\n+    let sum = v.into_iter().try_reduce(|x, y| x.checked_add(y));\n+    assert_eq!(sum, Some(None));\n+\n+    let v = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];\n+    let max = v.into_iter().try_reduce(|x, y| {\n+        if x.parse::<usize>().ok()? > y.parse::<usize>().ok()? { Some(x) } else { Some(y) }\n+    });\n+    assert_eq!(max, Some(Some(\"5\")));\n+\n+    let v = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];\n+    let max: Result<Option<_>, <usize as std::str::FromStr>::Err> =\n+        v.into_iter().try_reduce(|x, y| {\n+            if x.parse::<usize>()? > y.parse::<usize>()? { Ok(x) } else { Ok(y) }\n+        });\n+    assert_eq!(max, Ok(Some(\"5\")));\n+}\n+\n #[test]\n fn test_iterator_len() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "9ab98ba88865a07c7913f2260b879eeb2a136011", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -56,6 +56,7 @@\n #![feature(iter_intersperse)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]\n+#![feature(iterator_try_reduce)]\n #![feature(const_mut_refs)]\n #![feature(const_pin)]\n #![feature(const_slice_from_raw_parts)]"}, {"sha": "08f293d2ebb06150d38ab7e6561fdc8e672b6d87", "filename": "src/test/ui/derives/issue-36617.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-36617.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1,3 +1,16 @@\n #![derive(Copy)] //~ ERROR cannot determine resolution for the attribute macro `derive`\n+//~^ ERROR `derive` attribute cannot be used at crate level\n+\n+#![test]//~ ERROR cannot determine resolution for the attribute macro `test`\n+//~^ ERROR `test` attribute cannot be used at crate level\n+\n+#![test_case]//~ ERROR cannot determine resolution for the attribute macro `test_case`\n+//~^ ERROR `test_case` attribute cannot be used at crate level\n+\n+#![bench]//~ ERROR cannot determine resolution for the attribute macro `bench`\n+//~^ ERROR `bench` attribute cannot be used at crate level\n+\n+#![global_allocator]//~ ERROR cannot determine resolution for the attribute macro `global_allocator`\n+//~^ ERROR `global_allocator` attribute cannot be used at crate level\n \n fn main() {}"}, {"sha": "9cc0a29b0651db9c487e9005183318d70775b98e", "filename": "src/test/ui/derives/issue-36617.stderr", "status": "modified", "additions": 88, "deletions": 1, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-36617.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,92 @@ LL | #![derive(Copy)]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to previous error\n+error: cannot determine resolution for the attribute macro `test`\n+  --> $DIR/issue-36617.rs:4:4\n+   |\n+LL | #![test]\n+   |    ^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: cannot determine resolution for the attribute macro `test_case`\n+  --> $DIR/issue-36617.rs:7:4\n+   |\n+LL | #![test_case]\n+   |    ^^^^^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: cannot determine resolution for the attribute macro `bench`\n+  --> $DIR/issue-36617.rs:10:4\n+   |\n+LL | #![bench]\n+   |    ^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: cannot determine resolution for the attribute macro `global_allocator`\n+  --> $DIR/issue-36617.rs:13:4\n+   |\n+LL | #![global_allocator]\n+   |    ^^^^^^^^^^^^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: `derive` attribute cannot be used at crate level\n+  --> $DIR/issue-36617.rs:1:1\n+   |\n+LL | #![derive(Copy)]\n+   | ^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[derive(Copy)]\n+   | ~~~~~~~~~~~~~~~\n+\n+error: `test` attribute cannot be used at crate level\n+  --> $DIR/issue-36617.rs:4:1\n+   |\n+LL | #![test]\n+   | ^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[test]\n+   | ~~~~~~~\n+\n+error: `test_case` attribute cannot be used at crate level\n+  --> $DIR/issue-36617.rs:7:1\n+   |\n+LL | #![test_case]\n+   | ^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[test_case]\n+   | ~~~~~~~~~~~~\n+\n+error: `bench` attribute cannot be used at crate level\n+  --> $DIR/issue-36617.rs:10:1\n+   |\n+LL | #![bench]\n+   | ^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[bench]\n+   | ~~~~~~~~\n+\n+error: `global_allocator` attribute cannot be used at crate level\n+  --> $DIR/issue-36617.rs:13:1\n+   |\n+LL | #![global_allocator]\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[global_allocator]\n+   | ~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "796325b79af66cf6b60c4ba6c9ed09029baf2609", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,5 @@\n \n #![bench                   = \"4100\"]\n //~^ ERROR cannot determine resolution for the attribute macro `bench`\n-\n+//~^^ ERROR `bench` attribute cannot be used at crate level\n fn main() {}"}, {"sha": "6b33221194221263fd467ce61739a55ad0d048c4", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-bench.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-bench.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,16 @@ LL | #![bench                   = \"4100\"]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to previous error\n+error: `bench` attribute cannot be used at crate level\n+  --> $DIR/issue-43106-gating-of-bench.rs:7:1\n+   |\n+LL | #![bench                   = \"4100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[bench                   = \"4100\"]\n+   |\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "f94ec7d47041b38141d798b4e5864abe42056a85", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs-error.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs-error.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -129,36 +129,66 @@ error: `macro_export` attribute cannot be used at crate level\n    |\n LL | #![macro_export]\n    | ^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[macro_export]\n+   |\n \n error: `rustc_main` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:14:1\n    |\n LL | #![rustc_main]\n    | ^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[rustc_main]\n+   | ~~~~~~~~~~~~~\n \n error: `start` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:16:1\n    |\n LL | #![start]\n    | ^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[start]\n+   |\n \n error: `repr` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:18:1\n    |\n LL | #![repr()]\n    | ^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[repr()]\n+   |\n \n error: `path` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:20:1\n    |\n LL | #![path = \"3800\"]\n    | ^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[path = \"3800\"]\n+   |\n \n error: `automatically_derived` attribute cannot be used at crate level\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:22:1\n    |\n LL | #![automatically_derived]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[automatically_derived]\n+   |\n \n error[E0518]: attribute should be applied to function or closure\n   --> $DIR/issue-43106-gating-of-builtin-attrs-error.rs:36:17"}, {"sha": "39835c9268eef89324b9af59ca0f8aae0547e605", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -3,5 +3,5 @@\n #![allow(soft_unstable)]\n #![test                    = \"4200\"]\n //~^ ERROR cannot determine resolution for the attribute macro `test`\n-\n+//~^^ ERROR `test` attribute cannot be used at crate level\n fn main() {}"}, {"sha": "300a9966dd880910dc9253d59e5a9cc725011996", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-test.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-test.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,16 @@ LL | #![test                    = \"4200\"]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to previous error\n+error: `test` attribute cannot be used at crate level\n+  --> $DIR/issue-43106-gating-of-test.rs:4:1\n+   |\n+LL | #![test                    = \"4200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[test                    = \"4200\"]\n+   |\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "ef2a5d634a678a00a21d49fd3880740b161067b1", "filename": "src/test/ui/imports/issue-28134.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fimports%2Fissue-28134.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fimports%2Fissue-28134.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-28134.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -2,3 +2,4 @@\n \n #![allow(soft_unstable)]\n #![test] //~ ERROR cannot determine resolution for the attribute macro `test`\n+//~^ ERROR 4:1: 4:9: `test` attribute cannot be used at crate level"}, {"sha": "33cb53f202a30d36ec655c578beb046d1ffd6607", "filename": "src/test/ui/imports/issue-28134.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fimports%2Fissue-28134.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fimports%2Fissue-28134.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-28134.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,16 @@ LL | #![test]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to previous error\n+error: `test` attribute cannot be used at crate level\n+  --> $DIR/issue-28134.rs:4:1\n+   |\n+LL | #![test]\n+   | ^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[test]\n+   | ~~~~~~~\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "cdf1f0dfc536108e9f2fbd0df1b5d5876bbf82a1", "filename": "src/test/ui/issues/issue-38821.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -10,6 +10,10 @@ note: required because of the requirements on the impl of `IntoNullable` for `<C\n LL | impl<T: NotNull> IntoNullable for T {\n    |                  ^^^^^^^^^^^^     ^\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider further restricting the associated type\n+   |\n+LL |     Expr: Expression<SqlType=<Col::SqlType as IntoNullable>::Nullable>, <Col as Expression>::SqlType: NotNull,\n+   |                                                                       +++++++++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "10597caf5b2dc09759e2a3430a26f592b7938e68", "filename": "src/test/ui/issues/issue-50480.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-50480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-50480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50480.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1,8 +1,17 @@\n #[derive(Clone, Copy)]\n //~^ ERROR the trait `Copy` may not be implemented for this type\n-struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n //~^ ERROR cannot find type `NotDefined` in this scope\n //~| ERROR cannot find type `NotDefined` in this scope\n+//~| ERROR cannot find type `N` in this scope\n+//~| ERROR cannot find type `N` in this scope\n+//~| ERROR `i32` is not an iterator\n+\n+#[derive(Clone, Copy)]\n+//~^ ERROR the trait `Copy` may not be implemented for this type\n+struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+//~^ ERROR cannot find type `NotDefined` in this scope\n+//~| ERROR cannot find type `N` in this scope\n //~| ERROR `i32` is not an iterator\n \n fn main() {}"}, {"sha": "0bb1f9ae03500236017838440ae4aa0125dd5801", "filename": "src/test/ui/issues/issue-50480.stderr", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-50480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fissues%2Fissue-50480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50480.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1,20 +1,61 @@\n-error[E0412]: cannot find type `NotDefined` in this scope\n+error[E0412]: cannot find type `N` in this scope\n   --> $DIR/issue-50480.rs:3:12\n    |\n-LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |            ^^^^^^^^^^ not found in this scope\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |           -^ not found in this scope\n+   |           |\n+   |           help: you might be missing a type parameter: `<N>`\n \n error[E0412]: cannot find type `NotDefined` in this scope\n+  --> $DIR/issue-50480.rs:3:15\n+   |\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |               ^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `N` in this scope\n   --> $DIR/issue-50480.rs:3:12\n    |\n-LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |            ^^^^^^^^^^ not found in this scope\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |           -^ not found in this scope\n+   |           |\n+   |           help: you might be missing a type parameter: `<N>`\n+\n+error[E0412]: cannot find type `NotDefined` in this scope\n+  --> $DIR/issue-50480.rs:3:15\n+   |\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |           -   ^^^^^^^^^^ not found in this scope\n+   |           |\n+   |           help: you might be missing a type parameter: `<NotDefined>`\n+\n+error[E0412]: cannot find type `N` in this scope\n+  --> $DIR/issue-50480.rs:12:18\n+   |\n+LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |            -     ^\n+   |            |\n+   |            similarly named type parameter `T` defined here\n+   |\n+help: a type parameter with a similar name exists\n+   |\n+LL | struct Bar<T>(T, T, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                  ~\n+help: you might be missing a type parameter\n+   |\n+LL | struct Bar<T, N>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |             +++\n+\n+error[E0412]: cannot find type `NotDefined` in this scope\n+  --> $DIR/issue-50480.rs:12:21\n+   |\n+LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                     ^^^^^^^^^^ not found in this scope\n \n error[E0277]: `i32` is not an iterator\n-  --> $DIR/issue-50480.rs:3:24\n+  --> $DIR/issue-50480.rs:3:27\n    |\n-LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `i32`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n@@ -25,14 +66,36 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n LL | #[derive(Clone, Copy)]\n    |                 ^^^^\n LL |\n-LL | struct Foo(NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |                                                 --------  ------ this field does not implement `Copy`\n-   |                                                 |\n-   |                                                 this field does not implement `Copy`\n+LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                                                    --------  ------ this field does not implement `Copy`\n+   |                                                    |\n+   |                                                    this field does not implement `Copy`\n+   |\n+   = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `i32` is not an iterator\n+  --> $DIR/issue-50480.rs:12:33\n+   |\n+LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `i32`\n+   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/issue-50480.rs:10:17\n+   |\n+LL | #[derive(Clone, Copy)]\n+   |                 ^^^^\n+LL |\n+LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n+   |                                                          --------  ------ this field does not implement `Copy`\n+   |                                                          |\n+   |                                                          this field does not implement `Copy`\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 10 previous errors\n \n Some errors have detailed explanations: E0204, E0277, E0412.\n For more information about an error, try `rustc --explain E0204`."}, {"sha": "a208689523401ad3f5a6947174a518dbc3e86532", "filename": "src/test/ui/lifetimes/undeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fundeclared-lifetime-used-in-debug-macro-issue-70152.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -11,9 +11,8 @@ LL |     a: &'b str,\n error[E0261]: use of undeclared lifetime name `'b`\n   --> $DIR/undeclared-lifetime-used-in-debug-macro-issue-70152.rs:3:9\n    |\n-LL | #[derive(Eq, PartialEq)]\n-   |          -- lifetime `'b` is missing in item created through this procedural macro\n LL | struct Test {\n+   |            - help: consider introducing lifetime `'b` here: `<'b>`\n LL |     a: &'b str,\n    |         ^^ undeclared lifetime\n    |"}, {"sha": "935bfa001bfc6135d16ccc49525c55da0a55ea2f", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -1,5 +1,6 @@\n #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n //~^ ERROR cannot determine resolution for the attribute macro `derive`\n+//~^^ ERROR `derive` attribute cannot be used at crate level\n struct DerivedOn;\n \n fn main() {}"}, {"sha": "e3ae37e368937997a54090390628b6dbdab97723", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -6,5 +6,16 @@ LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: aborting due to previous error\n+error: `derive` attribute cannot be used at crate level\n+  --> $DIR/issue-43927-non-ADT-derive.rs:1:1\n+   |\n+LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: perhaps you meant to use an outer attribute\n+   |\n+LL | #[derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n+   | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "56c218f97ebf8cab45c1a3cc1fdf024e4162ec97", "filename": "src/test/ui/suggestions/derive-macro-missing-bounds.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.rs?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -0,0 +1,89 @@\n+mod a {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+\n+    impl Debug for Inner<()> {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>); //~ ERROR `a::Inner<T>` doesn't implement `Debug`\n+}\n+\n+mod b {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+\n+    impl<T: Debug> Debug for Inner<T> {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>);\n+}\n+\n+mod c {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+    trait Trait {}\n+\n+    impl<T: Debug + Trait> Debug for Inner<T> {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>); //~ ERROR the trait bound `T: c::Trait` is not satisfied\n+}\n+\n+mod d {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+    trait Trait {}\n+\n+    impl<T> Debug for Inner<T> where T: Debug, T: Trait {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>); //~ ERROR the trait bound `T: d::Trait` is not satisfied\n+}\n+\n+mod e {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+    trait Trait {}\n+\n+    impl<T> Debug for Inner<T> where T: Debug + Trait {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>); //~ ERROR the trait bound `T: e::Trait` is not satisfied\n+}\n+\n+mod f {\n+    use std::fmt::{Debug, Formatter, Result};\n+    struct Inner<T>(T);\n+    trait Trait {}\n+\n+    impl<T: Debug> Debug for Inner<T> where T: Trait {\n+        fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+            todo!()\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    struct Outer<T>(Inner<T>); //~ ERROR the trait bound `T: f::Trait` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "7a4f7e209c1957f7d0b58f647ad5cebc18154048", "filename": "src/test/ui/suggestions/derive-macro-missing-bounds.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efec545293b9263be9edfb283a7aa66350b3acbf/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fderive-macro-missing-bounds.stderr?ref=efec545293b9263be9edfb283a7aa66350b3acbf", "patch": "@@ -0,0 +1,107 @@\n+error[E0277]: `a::Inner<T>` doesn't implement `Debug`\n+  --> $DIR/derive-macro-missing-bounds.rs:12:21\n+   |\n+LL |     #[derive(Debug)]\n+   |              ----- in this derive macro expansion\n+LL |     struct Outer<T>(Inner<T>);\n+   |                     ^^^^^^^^ `a::Inner<T>` cannot be formatted using `{:?}`\n+   |\n+   = help: the trait `Debug` is not implemented for `a::Inner<T>`\n+   = note: add `#[derive(Debug)]` to `a::Inner<T>` or manually `impl Debug for a::Inner<T>`\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL |     struct Outer<T>(Inner<T>) where a::Inner<T>: Debug;\n+   |                               ++++++++++++++++++++++++\n+\n+error[E0277]: the trait bound `T: c::Trait` is not satisfied\n+  --> $DIR/derive-macro-missing-bounds.rs:41:21\n+   |\n+LL |     #[derive(Debug)]\n+   |              ----- in this derive macro expansion\n+LL |     struct Outer<T>(Inner<T>);\n+   |                     ^^^^^^^^ the trait `c::Trait` is not implemented for `T`\n+   |\n+note: required because of the requirements on the impl of `Debug` for `c::Inner<T>`\n+  --> $DIR/derive-macro-missing-bounds.rs:34:28\n+   |\n+LL |     impl<T: Debug + Trait> Debug for Inner<T> {\n+   |                            ^^^^^     ^^^^^^^^\n+   = note: 1 redundant requirement hidden\n+   = note: required because of the requirements on the impl of `Debug` for `&c::Inner<T>`\n+   = note: required for the cast to the object type `dyn Debug`\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider restricting type parameter `T`\n+   |\n+LL |     struct Outer<T: c::Trait>(Inner<T>);\n+   |                   ++++++++++\n+\n+error[E0277]: the trait bound `T: d::Trait` is not satisfied\n+  --> $DIR/derive-macro-missing-bounds.rs:56:21\n+   |\n+LL |     #[derive(Debug)]\n+   |              ----- in this derive macro expansion\n+LL |     struct Outer<T>(Inner<T>);\n+   |                     ^^^^^^^^ the trait `d::Trait` is not implemented for `T`\n+   |\n+note: required because of the requirements on the impl of `Debug` for `d::Inner<T>`\n+  --> $DIR/derive-macro-missing-bounds.rs:49:13\n+   |\n+LL |     impl<T> Debug for Inner<T> where T: Debug, T: Trait {\n+   |             ^^^^^     ^^^^^^^^\n+   = note: 1 redundant requirement hidden\n+   = note: required because of the requirements on the impl of `Debug` for `&d::Inner<T>`\n+   = note: required for the cast to the object type `dyn Debug`\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider restricting type parameter `T`\n+   |\n+LL |     struct Outer<T: d::Trait>(Inner<T>);\n+   |                   ++++++++++\n+\n+error[E0277]: the trait bound `T: e::Trait` is not satisfied\n+  --> $DIR/derive-macro-missing-bounds.rs:71:21\n+   |\n+LL |     #[derive(Debug)]\n+   |              ----- in this derive macro expansion\n+LL |     struct Outer<T>(Inner<T>);\n+   |                     ^^^^^^^^ the trait `e::Trait` is not implemented for `T`\n+   |\n+note: required because of the requirements on the impl of `Debug` for `e::Inner<T>`\n+  --> $DIR/derive-macro-missing-bounds.rs:64:13\n+   |\n+LL |     impl<T> Debug for Inner<T> where T: Debug + Trait {\n+   |             ^^^^^     ^^^^^^^^\n+   = note: 1 redundant requirement hidden\n+   = note: required because of the requirements on the impl of `Debug` for `&e::Inner<T>`\n+   = note: required for the cast to the object type `dyn Debug`\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider restricting type parameter `T`\n+   |\n+LL |     struct Outer<T: e::Trait>(Inner<T>);\n+   |                   ++++++++++\n+\n+error[E0277]: the trait bound `T: f::Trait` is not satisfied\n+  --> $DIR/derive-macro-missing-bounds.rs:86:21\n+   |\n+LL |     #[derive(Debug)]\n+   |              ----- in this derive macro expansion\n+LL |     struct Outer<T>(Inner<T>);\n+   |                     ^^^^^^^^ the trait `f::Trait` is not implemented for `T`\n+   |\n+note: required because of the requirements on the impl of `Debug` for `f::Inner<T>`\n+  --> $DIR/derive-macro-missing-bounds.rs:79:20\n+   |\n+LL |     impl<T: Debug> Debug for Inner<T> where T: Trait {\n+   |                    ^^^^^     ^^^^^^^^\n+   = note: 1 redundant requirement hidden\n+   = note: required because of the requirements on the impl of `Debug` for `&f::Inner<T>`\n+   = note: required for the cast to the object type `dyn Debug`\n+   = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider restricting type parameter `T`\n+   |\n+LL |     struct Outer<T: f::Trait>(Inner<T>);\n+   |                   ++++++++++\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}