{"sha": "742e458102ff5236ecf24a05ab94898c76d6d1cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MmU0NTgxMDJmZjUyMzZlY2YyNGEwNWFiOTQ4OThjNzZkNmQxY2Y=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-07T07:43:39Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-12T07:05:28Z"}, "message": "Add proper support for early/late distinction for lifetime bindings.\nUses newly added Vec::partition method to simplify resolve_lifetime.", "tree": {"sha": "bd30e2f94400161cca4a934d69de409142696bd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd30e2f94400161cca4a934d69de409142696bd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/742e458102ff5236ecf24a05ab94898c76d6d1cf", "comment_count": 11, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/742e458102ff5236ecf24a05ab94898c76d6d1cf", "html_url": "https://github.com/rust-lang/rust/commit/742e458102ff5236ecf24a05ab94898c76d6d1cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/742e458102ff5236ecf24a05ab94898c76d6d1cf/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "586b619c76a3e5798283408954a0306d86ebc1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/586b619c76a3e5798283408954a0306d86ebc1ef", "html_url": "https://github.com/rust-lang/rust/commit/586b619c76a3e5798283408954a0306d86ebc1ef"}], "stats": {"total": 766, "additions": 566, "deletions": 200}, "files": [{"sha": "88eaf256be8cfde39466a5368d63ece9856a6b2e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 164, "deletions": 44, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -23,6 +23,8 @@ use std::vec_ng::Vec;\n use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::opt_vec;\n+use syntax::opt_vec::OptVec;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_str};\n@@ -33,14 +35,25 @@ use syntax::visit::Visitor;\n // that it corresponds to\n pub type NamedRegionMap = NodeMap<ast::DefRegion>;\n \n+// Returns an instance of some type that implements std::fmt::Show\n+fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n+    token::get_name(*lt_name)\n+}\n+\n struct LifetimeContext {\n     sess: session::Session,\n     named_region_map: @RefCell<NamedRegionMap>,\n }\n \n enum ScopeChain<'a> {\n-    ItemScope(&'a Vec<ast::Lifetime>),\n-    FnScope(ast::NodeId, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n+    /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n+    EarlyScope(uint, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    /// LateScope(binder_id, ['a, 'b, ...], s) extends s with late-bound\n+    /// lifetimes introduced by the declaration binder_id.\n+    LateScope(ast::NodeId, &'a Vec<ast::Lifetime>, Scope<'a>),\n+    /// lifetimes introduced by items within a code block are scoped\n+    /// to that block.\n     BlockScope(ast::NodeId, Scope<'a>),\n     RootScope\n }\n@@ -62,6 +75,7 @@ impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n     fn visit_item(&mut self,\n                   item: &ast::Item,\n                   _: Scope<'a>) {\n+        let root = RootScope;\n         let scope = match item.node {\n             ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n             ast::ItemMod(..) |\n@@ -76,7 +90,7 @@ impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n             ast::ItemImpl(ref generics, _, _, _) |\n             ast::ItemTrait(ref generics, _, _) => {\n                 self.check_lifetime_names(&generics.lifetimes);\n-                ItemScope(&generics.lifetimes)\n+                EarlyScope(0, &generics.lifetimes, &root)\n             }\n         };\n         debug!(\"entering scope {:?}\", scope);\n@@ -90,49 +104,41 @@ impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n         match *fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                let scope1 = FnScope(n, &generics.lifetimes, scope);\n-                self.check_lifetime_names(&generics.lifetimes);\n-                debug!(\"pushing fn scope id={} due to item/method\", n);\n-                visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n-                debug!(\"popping fn scope id={} due to item/method\", n);\n+                self.visit_fn_decl(\n+                    n, generics, scope,\n+                    |this, scope1| visit::walk_fn(this, fk, fd, b, s, n, scope1))\n             }\n             visit::FkFnBlock(..) => {\n-                visit::walk_fn(self, fk, fd, b, s, n, scope);\n+                visit::walk_fn(self, fk, fd, b, s, n, scope)\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &ast::Ty,\n-                scope: Scope<'a>) {\n+    fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n         match ty.node {\n-            ast::TyClosure(closure) => {\n-                let scope1 = FnScope(ty.id, &closure.lifetimes, scope);\n-                self.check_lifetime_names(&closure.lifetimes);\n-                debug!(\"pushing fn scope id={} due to type\", ty.id);\n-                visit::walk_ty(self, ty, &scope1);\n-                debug!(\"popping fn scope id={} due to type\", ty.id);\n-            }\n-            ast::TyBareFn(bare_fn) => {\n-                let scope1 = FnScope(ty.id, &bare_fn.lifetimes, scope);\n-                self.check_lifetime_names(&bare_fn.lifetimes);\n-                debug!(\"pushing fn scope id={} due to type\", ty.id);\n-                visit::walk_ty(self, ty, &scope1);\n-                debug!(\"popping fn scope id={} due to type\", ty.id);\n-            }\n-            _ => {\n-                visit::walk_ty(self, ty, scope);\n-            }\n+            ast::TyClosure(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            _ => visit::walk_ty(self, ty, scope),\n+        }\n+\n+        fn push_fn_scope(this: &mut LifetimeContext,\n+                         ty: &ast::Ty,\n+                         scope: Scope,\n+                         lifetimes: &Vec<ast::Lifetime>) {\n+            let scope1 = LateScope(ty.id, lifetimes, scope);\n+            this.check_lifetime_names(lifetimes);\n+            debug!(\"pushing fn scope id={} due to type\", ty.id);\n+            visit::walk_ty(this, ty, &scope1);\n+            debug!(\"popping fn scope id={} due to type\", ty.id);\n         }\n     }\n \n     fn visit_ty_method(&mut self,\n                        m: &ast::TypeMethod,\n                        scope: Scope<'a>) {\n-        let scope1 = FnScope(m.id, &m.generics.lifetimes, scope);\n-        self.check_lifetime_names(&m.generics.lifetimes);\n-        debug!(\"pushing fn scope id={} due to ty_method\", m.id);\n-        visit::walk_ty_method(self, m, &scope1);\n-        debug!(\"popping fn scope id={} due to ty_method\", m.id);\n+        self.visit_fn_decl(\n+            m.id, &m.generics, scope,\n+            |this, scope1| visit::walk_ty_method(this, m, scope1))\n     }\n \n     fn visit_block(&mut self,\n@@ -155,7 +161,82 @@ impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n     }\n }\n \n+impl<'a> ScopeChain<'a> {\n+    fn count_early_params(&self) -> uint {\n+        /*!\n+         * Counts the number of early-bound parameters that are in\n+         * scope.  Used when checking methods: the early-bound\n+         * lifetime parameters declared on the method are assigned\n+         * indices that come after the indices from the type.  Given\n+         * something like `impl<'a> Foo { ... fn bar<'b>(...) }`\n+         * then `'a` gets index 0 and `'b` gets index 1.\n+         */\n+\n+        match *self {\n+            RootScope => 0,\n+            EarlyScope(base, lifetimes, _) => base + lifetimes.len(),\n+            LateScope(_, _, s) => s.count_early_params(),\n+            BlockScope(_, _) => 0,\n+        }\n+    }\n+}\n+\n impl LifetimeContext {\n+    /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n+    fn visit_fn_decl(&mut self,\n+                     n: ast::NodeId,\n+                     generics: &ast::Generics,\n+                     scope: Scope,\n+                     walk: |&mut LifetimeContext, Scope|) {\n+        /*!\n+         * Handles visiting fns and methods. These are a bit\n+         * complicated because we must distinguish early- vs late-bound\n+         * lifetime parameters. We do this by checking which lifetimes\n+         * appear within type bounds; those are early bound lifetimes,\n+         * and the rest are late bound.\n+         *\n+         * For example:\n+         *\n+         *    fn foo<'a,'b,'c,T:Trait<'b>>(...)\n+         *\n+         * Here `'a` and `'c` are late bound but `'b` is early\n+         * bound. Note that early- and late-bound lifetimes may be\n+         * interspersed together.\n+         *\n+         * If early bound lifetimes are present, we separate them into\n+         * their own list (and likewise for late bound). They will be\n+         * numbered sequentially, starting from the lowest index that\n+         * is already in scope (for a fn item, that will be 0, but for\n+         * a method it might not be). Late bound lifetimes are\n+         * resolved by name and associated with a binder id (`n`), so\n+         * the ordering is not important there.\n+         */\n+\n+        self.check_lifetime_names(&generics.lifetimes);\n+\n+        let early_count = scope.count_early_params();\n+        let referenced_idents = free_lifetimes(&generics.ty_params);\n+        debug!(\"pushing fn scope id={} due to fn item/method\\\n+               referenced_idents={:?} \\\n+               early_count={}\",\n+               n,\n+               referenced_idents.map(lifetime_show),\n+               early_count);\n+        if referenced_idents.is_empty() {\n+            let scope1 = LateScope(n, &generics.lifetimes, scope);\n+            walk(self, &scope1)\n+        } else {\n+            let (early, late) = generics.lifetimes.clone().partition(\n+                |l| referenced_idents.iter().any(|&i| i == l.name));\n+\n+            let scope1 = EarlyScope(early_count, &early, scope);\n+            let scope2 = LateScope(n, &late, &scope1);\n+\n+            walk(self, &scope2);\n+        }\n+        debug!(\"popping fn scope id={} due to fn item/method\", n);\n+    }\n+\n     fn resolve_lifetime_ref(&self,\n                             lifetime_ref: &ast::Lifetime,\n                             scope: Scope) {\n@@ -177,23 +258,25 @@ impl LifetimeContext {\n                     break;\n                 }\n \n-                ItemScope(lifetimes) => {\n+                EarlyScope(base, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, decl_id)) => {\n+                        Some((offset, decl_id)) => {\n+                            let index = base + offset;\n                             let def = ast::DefEarlyBoundRegion(index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n                         None => {\n-                            break;\n+                            depth += 1;\n+                            scope = s;\n                         }\n                     }\n                 }\n \n-                FnScope(id, lifetimes, s) => {\n+                LateScope(binder_id, lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = ast::DefLateBoundRegion(id, depth, decl_id);\n+                            let def = ast::DefLateBoundRegion(binder_id, depth, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -231,12 +314,8 @@ impl LifetimeContext {\n                     break;\n                 }\n \n-                ItemScope(lifetimes) => {\n-                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n-                    break;\n-                }\n-\n-                FnScope(_, lifetimes, s) => {\n+                EarlyScope(_, lifetimes, s) |\n+                LateScope(_, lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n                         break;\n@@ -323,3 +402,44 @@ fn search_lifetimes(lifetimes: &Vec<ast::Lifetime>,\n     }\n     return None;\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub fn early_bound_lifetimes<'a>(generics: &'a ast::Generics) -> Vec<ast::Lifetime> {\n+    let referenced_idents = free_lifetimes(&generics.ty_params);\n+    if referenced_idents.is_empty() {\n+        return Vec::new();\n+    }\n+\n+    generics.lifetimes.iter()\n+        .filter(|l| referenced_idents.iter().any(|&i| i == l.name))\n+        .map(|l| *l)\n+        .collect()\n+}\n+\n+pub fn free_lifetimes(ty_params: &OptVec<ast::TyParam>) -> OptVec<ast::Name> {\n+    /*!\n+     * Gathers up and returns the names of any lifetimes that appear\n+     * free in `ty_params`. Of course, right now, all lifetimes appear\n+     * free, since we don't currently have any binders in type parameter\n+     * declarations; just being forwards compatible with future extensions.\n+     */\n+\n+    let mut collector = FreeLifetimeCollector { names: opt_vec::Empty };\n+    for ty_param in ty_params.iter() {\n+        visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n+    }\n+    return collector.names;\n+\n+    struct FreeLifetimeCollector {\n+        names: OptVec<ast::Name>,\n+    }\n+\n+    impl Visitor<()> for FreeLifetimeCollector {\n+        fn visit_lifetime_ref(&mut self,\n+                              lifetime_ref: &ast::Lifetime,\n+                              _: ()) {\n+            self.names.push(lifetime_ref.name);\n+        }\n+    }\n+}"}, {"sha": "b0cf17c5b5467f6362c18f8b31d2f58029de8031", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -276,7 +276,7 @@ impl Subst for ty::Region {\n         // bound in *fn types*. Region substitution of the bound\n         // regions that appear in a function signature is done using\n         // the specialized routine\n-        // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n+        // `middle::typeck::check::regionmanip::replace_late_regions_in_fn_sig()`.\n         match self {\n             &ty::ReEarlyBound(_, i, _) => {\n                 match substs.regions {"}, {"sha": "b2a879b1946e1c566c7e55a09cbb524ff04ae8e4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -1008,6 +1008,7 @@ pub struct Generics {\n     type_param_defs: Rc<Vec<TypeParameterDef> >,\n \n     /// List of region parameters declared on the item.\n+    /// For a fn or method, only includes *early-bound* lifetimes.\n     region_param_defs: Rc<Vec<RegionParameterDef> >,\n }\n \n@@ -5077,6 +5078,7 @@ pub fn construct_parameter_environment(\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],\n     item_region_params: &[RegionParameterDef],\n+    method_region_params: &[RegionParameterDef],\n     free_id: ast::NodeId)\n     -> ParameterEnvironment\n {\n@@ -5104,11 +5106,24 @@ pub fn construct_parameter_environment(\n         });\n \n     // map bound 'a => free 'a\n-    let region_params = item_region_params.iter().\n-        map(|r| ty::ReFree(ty::FreeRegion {\n-                scope_id: free_id,\n-                bound_region: ty::BrNamed(r.def_id, r.name)})).\n-        collect();\n+    let region_params = {\n+        fn push_region_params(accum: OptVec<ty::Region>,\n+                              free_id: ast::NodeId,\n+                              region_params: &[RegionParameterDef])\n+                              -> OptVec<ty::Region> {\n+            let mut accum = accum;\n+            for r in region_params.iter() {\n+                accum.push(\n+                    ty::ReFree(ty::FreeRegion {\n+                            scope_id: free_id,\n+                            bound_region: ty::BrNamed(r.def_id, r.name)}));\n+            }\n+            accum\n+        }\n+\n+        let t = push_region_params(opt_vec::Empty, free_id, item_region_params);\n+        push_region_params(t, free_id, method_region_params)\n+    };\n \n     let free_substs = substs {\n         self_ty: self_ty,\n@@ -5130,6 +5145,15 @@ pub fn construct_parameter_environment(\n         }\n     });\n \n+    debug!(\"construct_parameter_environment: free_id={} \\\n+           free_subst={} \\\n+           self_param_bound={} \\\n+           type_param_bound={}\",\n+           free_id,\n+           free_substs.repr(tcx),\n+           self_bound_substd.repr(tcx),\n+           type_param_bounds_substd.repr(tcx));\n+\n     ty::ParameterEnvironment {\n         free_substs: free_substs,\n         self_param_bound: self_bound_substd,"}, {"sha": "ca36fca687abd5afe1d54cf18118c98793ac35ad", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -93,7 +93,7 @@ use middle::typeck::MethodCallee;\n use middle::typeck::{MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n use middle::typeck::{param_numbered, param_self, param_index};\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n@@ -428,7 +428,7 @@ impl<'a> LookupContext<'a> {\n                                             substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n-               substs_to_str(self.tcx(), substs));\n+               substs.repr(self.tcx()));\n         let _indenter = indenter();\n \n         // It is illegal to invoke a method on a trait instance that\n@@ -554,7 +554,8 @@ impl<'a> LookupContext<'a> {\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n-                            debug!(\"pushing inherent candidate for param: {:?}\", cand);\n+                            debug!(\"pushing inherent candidate for param: {}\",\n+                                   cand.repr(self.tcx()));\n                             self.inherent_candidates.borrow_mut().get().push(cand);\n                         }\n                         None => {}\n@@ -938,8 +939,9 @@ impl<'a> LookupContext<'a> {\n             let mut j = i + 1;\n             while j < candidates.len() {\n                 let candidate_b = &candidates[j];\n-                debug!(\"attempting to merge {:?} and {:?}\",\n-                       candidate_a, candidate_b);\n+                debug!(\"attempting to merge {} and {}\",\n+                       candidate_a.repr(self.tcx()),\n+                       candidate_b.repr(self.tcx()));\n                 let candidates_same = match (&candidate_a.origin,\n                                              &candidate_b.origin) {\n                     (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n@@ -984,19 +986,20 @@ impl<'a> LookupContext<'a> {\n \n         let tcx = self.tcx();\n \n-        debug!(\"confirm_candidate(expr={}, candidate={})\",\n+        debug!(\"confirm_candidate(expr={}, rcvr_ty={}, candidate={})\",\n                self.expr.repr(tcx),\n-               self.cand_to_str(candidate));\n+               self.ty_to_str(rcvr_ty),\n+               candidate.repr(self.tcx()));\n \n         self.enforce_object_limitations(candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n         assert!(candidate.method_ty.explicit_self != SelfStatic);\n \n-        // Determine the values for the type parameters of the method.\n+        // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n-        // type variables.\n+        // variables.\n         let num_supplied_tps = self.supplied_tps.len();\n         let num_method_tps = candidate.method_ty.generics.type_param_defs().len();\n         let m_substs = {\n@@ -1018,12 +1021,26 @@ impl<'a> LookupContext<'a> {\n             }\n         };\n \n+        // Determine values for the early-bound lifetime parameters.\n+        // FIXME -- permit users to manually specify lifetimes\n+        let mut all_regions = match candidate.rcvr_substs.regions {\n+            NonerasedRegions(ref v) => v.clone(),\n+            ErasedRegions => tcx.sess.span_bug(self.expr.span, \"ErasedRegions\")\n+        };\n+        let m_regions =\n+            self.fcx.infcx().region_vars_for_defs(\n+                self.expr.span,\n+                candidate.method_ty.generics.region_param_defs.borrow().as_slice());\n+        for &r in m_regions.iter() {\n+            all_regions.push(r);\n+        }\n+\n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n             tps: vec_ng::append(candidate.rcvr_substs.tps.clone(),\n                                 m_substs.as_slice()),\n-            regions: candidate.rcvr_substs.regions.clone(),\n+            regions: NonerasedRegions(all_regions),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n \n@@ -1057,10 +1074,10 @@ impl<'a> LookupContext<'a> {\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_bound_regions_in_fn_sig( tcx, &fn_sig, |br| {\n-            self.fcx.infcx().next_region_var(\n-                infer::BoundRegionInFnCall(self.expr.span, br))\n-        });\n+        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(\n+            tcx, &fn_sig,\n+            |br| self.fcx.infcx().next_region_var(\n+                infer::LateBoundRegion(self.expr.span, br)));\n         let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n@@ -1245,7 +1262,7 @@ impl<'a> LookupContext<'a> {\n     // candidate method's `self_ty`.\n     fn is_relevant(&self, rcvr_ty: ty::t, candidate: &Candidate) -> bool {\n         debug!(\"is_relevant(rcvr_ty={}, candidate={})\",\n-               self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n+               self.ty_to_str(rcvr_ty), candidate.repr(self.tcx()));\n \n         return match candidate.method_ty.explicit_self {\n             SelfStatic => {\n@@ -1385,13 +1402,6 @@ impl<'a> LookupContext<'a> {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n-        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n-             cand.rcvr_match_condition.repr(self.tcx()),\n-             ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n-             cand.origin)\n-    }\n-\n     fn did_to_str(&self, did: DefId) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n@@ -1401,6 +1411,15 @@ impl<'a> LookupContext<'a> {\n     }\n }\n \n+impl Repr for Candidate {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n+                self.rcvr_match_condition.repr(tcx),\n+                self.rcvr_substs.repr(tcx),\n+                self.origin)\n+    }\n+}\n+\n impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {"}, {"sha": "026d2d5d73454bd26383a7f161f11c69f1da7a72", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -97,7 +97,7 @@ use middle::typeck::check::method::{AutoderefReceiver};\n use middle::typeck::check::method::{AutoderefReceiverFlag};\n use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n use middle::typeck::check::method::{DontAutoderefReceiver};\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::check::regionmanip::relate_free_regions;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n@@ -439,7 +439,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let (_, fn_sig) = replace_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n+    let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(tcx, fn_sig, |br| {\n         ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n     });\n \n@@ -563,13 +563,13 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n       ast::ItemFn(decl, _, _, _, body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n-        // FIXME(#5121) -- won't work for lifetimes that appear in type bounds\n         let param_env = ty::construct_parameter_environment(\n                 ccx.tcx,\n                 None,\n                 fn_tpt.generics.type_param_defs(),\n                 [],\n                 [],\n+                fn_tpt.generics.region_param_defs.borrow().as_slice(),\n                 body.id);\n \n         check_bare_fn(ccx, decl, body, it.id, fn_tpt.ty, param_env);\n@@ -679,6 +679,7 @@ fn check_method_body(ccx: @CrateCtxt,\n             item_generics.type_param_defs(),\n             method_generics.type_param_defs(),\n             item_generics.region_param_defs(),\n+            method_generics.region_param_defs(),\n             method.body.id);\n \n     // Compute the fty from point of view of inside fn\n@@ -1439,21 +1440,17 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n-    let (n_tps, n_rps, raw_ty) = {\n-        let ity = ty::lookup_item_type(tcx, did);\n+    let ity = ty::lookup_item_type(tcx, did);\n+    let (n_tps, rps, raw_ty) =\n         (ity.generics.type_param_defs().len(),\n-         ity.generics.region_param_defs().len(),\n-         ity.ty)\n-    };\n+         ity.generics.region_param_defs(),\n+         ity.ty);\n \n-    let rps =\n-        vcx.infcx.next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(location_info.span),\n-            n_rps);\n+    let rps = vcx.infcx.region_vars_for_defs(location_info.span, rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n     let substs = substs {\n-        regions: ty::NonerasedRegions(opt_vec::from(rps.move_iter().collect())),\n+        regions: ty::NonerasedRegions(rps),\n         self_ty: None,\n         tps: tps,\n     };\n@@ -1887,9 +1884,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // Replace any bound regions that appear in the function\n         // signature with region variables\n-        let (_, fn_sig) = replace_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n-            fcx.infcx()\n-               .next_region_var(infer::BoundRegionInFnCall(call_expr.span, br))\n+        let (_, fn_sig) = replace_late_bound_regions_in_fn_sig(fcx.tcx(), fn_sig, |br| {\n+            fcx.infcx().next_region_var(infer::LateBoundRegion(call_expr.span, br))\n         });\n \n         // Call the generic checker.\n@@ -2213,7 +2209,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n                     let (_, sig) =\n-                        replace_bound_regions_in_fn_sig(\n+                        replace_late_bound_regions_in_fn_sig(\n                             tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     (Some(sig), cenv.purity, cenv.sigil,\n@@ -2461,16 +2457,14 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         // determine whether the class is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, class_id);\n         let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_parameter_count = item_type.generics.region_param_defs().len();\n+        let region_param_defs = item_type.generics.region_param_defs();\n         let raw_type = item_type.ty;\n \n         // Generate the struct type.\n-        let regions = fcx.infcx().next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count).move_iter().collect();\n+        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n+            regions: ty::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -2519,16 +2513,14 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         // determine whether the enum is region-parameterized.\n         let item_type = ty::lookup_item_type(tcx, enum_id);\n         let type_parameter_count = item_type.generics.type_param_defs().len();\n-        let region_parameter_count = item_type.generics.region_param_defs().len();\n+        let region_param_defs = item_type.generics.region_param_defs();\n         let raw_type = item_type.ty;\n \n         // Generate the enum type.\n-        let regions = fcx.infcx().next_region_vars(\n-            infer::BoundRegionInTypeOrImpl(span),\n-            region_parameter_count).move_iter().collect();\n+        let regions = fcx.infcx().region_vars_for_defs(span, region_param_defs);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n+            regions: ty::NonerasedRegions(regions),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -3726,8 +3718,8 @@ pub fn instantiate_path(fcx: @FnCtxt,\n     let num_expected_regions = tpt.generics.region_param_defs().len();\n     let num_supplied_regions = pth.segments.last().unwrap().lifetimes.len();\n     let regions = if num_expected_regions == num_supplied_regions {\n-        pth.segments.last().unwrap().lifetimes.map(\n-            |l| ast_region_to_region(fcx.tcx(), l))\n+        opt_vec::from(pth.segments.last().unwrap().lifetimes.map(\n+            |l| ast_region_to_region(fcx.tcx(), l)))\n     } else {\n         if num_supplied_regions != 0 {\n             fcx.ccx.tcx.sess.span_err(\n@@ -3740,11 +3732,9 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                         nsupplied = num_supplied_regions));\n         }\n \n-        fcx.infcx().next_region_vars(\n-                infer::BoundRegionInTypeOrImpl(span),\n-                num_expected_regions).move_iter().collect()\n+        fcx.infcx().region_vars_for_defs(span, tpt.generics.region_param_defs.borrow().as_slice())\n     };\n-    let regions = ty::NonerasedRegions(opt_vec::from(regions));\n+    let regions = ty::NonerasedRegions(regions);\n \n     // Special case: If there is a self parameter, omit it from the list of\n     // type parameters."}, {"sha": "c8a126382f4b4cec26b9a2fd1ca5b166e0395cbe", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -21,12 +21,12 @@ use util::ppaux;\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_bound_regions_in_fn_sig(\n+pub fn replace_late_bound_regions_in_fn_sig(\n         tcx: ty::ctxt,\n         fn_sig: &ty::FnSig,\n         mapf: |ty::BoundRegion| -> ty::Region)\n         -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n-    debug!(\"replace_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n+    debug!(\"replace_late_bound_regions_in_fn_sig({})\", fn_sig.repr(tcx));\n \n     let mut map = HashMap::new();\n     let fn_sig = {"}, {"sha": "57e85ab55d3bc0705b28fbaf91c81c64227e65f1", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -777,6 +777,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n         impl_generics.type_param_defs(),\n         [],\n         impl_generics.region_param_defs(),\n+        [],\n         impl_item.id);\n \n     let impl_trait_ref = @impl_trait_ref.subst(tcx, &param_env.free_substs);\n@@ -832,7 +833,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n     if has_trait_bounds(type_param_defs.as_slice()) {\n         let vcx = VtableContext {\n             infcx: &infer::new_infer_ctxt(tcx),\n-            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], id)\n+            param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], [], id)\n         };\n         let loc_info = LocationInfo {\n             id: id,"}, {"sha": "ca5befa8d4e06949b54fbc067d316e0e3746e421", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -42,7 +42,6 @@ use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::Span;\n-use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::visit;\n \n@@ -516,18 +515,17 @@ impl CoherenceChecker {\n     // type variables. Returns the monotype and the type variables created.\n     fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n                                      -> UniversalQuantificationResult {\n-        let region_parameter_count = polytype.generics.region_param_defs().len();\n         let region_parameters =\n-            self.inference_context.next_region_vars(\n-                infer::BoundRegionInCoherence,\n-                region_parameter_count);\n+            polytype.generics.region_param_defs().iter()\n+            .map(|d| self.inference_context.next_region_var(\n+                infer::BoundRegionInCoherence(d.name)))\n+            .collect();\n \n         let bounds_count = polytype.generics.type_param_defs().len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(opt_vec::from(\n-                             region_parameters.move_iter().collect())),\n+            regions: ty::NonerasedRegions(region_parameters),\n             self_ty: None,\n             tps: type_parameters\n         };"}, {"sha": "234e6e92bac9fd8fa2c786339d224bf67db0b6b0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 67, "deletions": 55, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -32,6 +32,7 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n+use middle::resolve_lifetime;\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n@@ -45,7 +46,6 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n-use std::vec;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use syntax::abi::AbiSet;\n@@ -160,7 +160,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::StructVariantKind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, generics, 0),\n+                    generics: ty_generics_for_type(ccx, generics),\n                     ty: enum_ty\n                 };\n \n@@ -173,7 +173,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         };\n \n         let tpt = ty_param_bounds_and_ty {\n-            generics: ty_generics(ccx, generics, 0),\n+            generics: ty_generics_for_type(ccx, generics),\n             ty: result_ty\n         };\n \n@@ -192,7 +192,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         ast_map::NodeItem(item) => {\n             match item.node {\n                 ast::ItemTrait(ref generics, _, ref ms) => {\n-                    let trait_ty_generics = ty_generics(ccx, generics, 0);\n+                    let trait_ty_generics = ty_generics_for_type(ccx, generics);\n \n                     // For each method, construct a suitable ty::Method and\n                     // store it into the `tcx.methods` table:\n@@ -293,7 +293,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs().len();\n-        let non_shifted_trait_tps = vec::from_fn(num_trait_bounds, |i| {\n+        let non_shifted_trait_tps = Vec::from_fn(num_trait_bounds, |i| {\n             ty::mk_param(tcx, i, trait_ty_generics.type_param_defs()[i].def_id)\n         });\n \n@@ -303,7 +303,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // Represents [E',F',G']\n         let num_method_bounds = m.generics.type_param_defs().len();\n-        let shifted_method_tps = vec::from_fn(num_method_bounds, |i| {\n+        let shifted_method_tps = Vec::from_fn(num_method_bounds, |i| {\n             ty::mk_param(tcx, i + num_trait_bounds + 1,\n                          m.generics.type_param_defs()[i].def_id)\n         });\n@@ -326,8 +326,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let substs = substs {\n             regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n-            tps: vec_ng::append(Vec::from_slice(non_shifted_trait_tps),\n-                                shifted_method_tps)\n+            tps: vec_ng::append(non_shifted_trait_tps,\n+                                shifted_method_tps.as_slice())\n         };\n \n         // create the type of `foo`, applying the substitution above\n@@ -394,10 +394,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let fty = astconv::ty_of_method(this, *m_id, *m_purity, trait_self_ty,\n                                         *m_explicit_self, m_decl);\n         let num_trait_type_params = trait_generics.type_param_defs().len();\n+        let ty_generics = ty_generics_for_fn_or_method(this, m_generics,\n+                                                       num_trait_type_params);\n         ty::Method::new(\n             *m_ident,\n-            // FIXME(#5121) -- distinguish early vs late lifetime params\n-            ty_generics(this, m_generics, num_trait_type_params),\n+            ty_generics,\n             fty,\n             m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n@@ -477,7 +478,8 @@ fn convert_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     for m in ms.iter() {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n-        let m_ty_generics = ty_generics(ccx, &m.generics, num_rcvr_ty_params);\n+        let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n+                                                         num_rcvr_ty_params);\n         let mty = @ty_of_method(ccx,\n                                 container,\n                                 *m,\n@@ -503,7 +505,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                             Vec::from_slice(\n                                 rcvr_ty_generics.type_param_defs()),\n                             m_ty_generics.type_param_defs())),\n-                        region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n+                        region_param_defs: Rc::new(vec_ng::append(\n+                                Vec::from_slice(rcvr_ty_generics.region_param_defs()),\n+                                m_ty_generics.region_param_defs())),\n                     },\n                     ty: fty\n                 });\n@@ -533,10 +537,11 @@ fn convert_methods(ccx: &CrateCtxt,\n         let method_vis = m.vis.inherit_from(rcvr_visibility);\n \n         let num_rcvr_type_params = rcvr_generics.ty_params.len();\n+        let m_ty_generics =\n+            ty_generics_for_fn_or_method(ccx, &m.generics, num_rcvr_type_params);\n         ty::Method::new(\n             m.ident,\n-            // FIXME(#5121) -- distinguish early vs late lifetime params\n-            ty_generics(ccx, &m.generics, num_rcvr_type_params),\n+            m_ty_generics,\n             fty,\n             m.explicit_self.node,\n             method_vis,\n@@ -588,15 +593,15 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                    generics);\n         },\n         ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n-            let i_ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             {\n                 let mut tcache = tcx.tcache.borrow_mut();\n                 tcache.get().insert(local_def(it.id),\n                                     ty_param_bounds_and_ty {\n-                                        generics: i_ty_generics.clone(),\n+                                        generics: ty_generics.clone(),\n                                         ty: selfty});\n             }\n \n@@ -615,7 +620,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             ImplContainer(local_def(it.id)),\n                             ms.as_slice(),\n                             selfty,\n-                            &i_ty_generics,\n+                            &ty_generics,\n                             generics,\n                             parent_visibility);\n \n@@ -813,7 +818,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n     match it.node {\n         ast::ItemTrait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n             let bounds = ensure_supertraits(ccx,\n                                             it.id,\n@@ -857,17 +862,14 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return tpt;\n         }\n         ast::ItemFn(decl, purity, abi, ref generics, _) => {\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_fn_or_method(ccx, generics, 0);\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n                                               purity,\n                                               abi,\n                                               decl);\n             let tpt = ty_param_bounds_and_ty {\n-                generics: ty::Generics {\n-                    type_param_defs: ty_generics.type_param_defs.clone(),\n-                    region_param_defs: Rc::new(Vec::new()),\n-                },\n+                generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n@@ -891,7 +893,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let tpt = {\n                 let ty = ccx.to_ty(&ExplicitRscope, t);\n                 ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, generics, 0),\n+                    generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n                 }\n             };\n@@ -902,7 +904,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n             let t = ty::mk_enum(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n@@ -920,7 +922,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                 format!(\"invoked ty_of_item on trait\"));\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics(ccx, generics, 0);\n+            let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n             let tpt = ty_param_bounds_and_ty {\n@@ -961,42 +963,51 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n+pub fn ty_generics_for_type(ccx: &CrateCtxt,\n+                            generics: &ast::Generics)\n+                            -> ty::Generics {\n+    ty_generics(ccx, &generics.lifetimes, &generics.ty_params, 0)\n+}\n+\n+pub fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n+                                    generics: &ast::Generics,\n+                                    base_index: uint)\n+                                    -> ty::Generics {\n+    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n+    ty_generics(ccx, &early_lifetimes, &generics.ty_params, base_index)\n+}\n+\n pub fn ty_generics(ccx: &CrateCtxt,\n-                   generics: &ast::Generics,\n+                   lifetimes: &Vec<ast::Lifetime>,\n+                   ty_params: &OptVec<ast::TyParam>,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n-        region_param_defs: Rc::new(generics.lifetimes.iter().map(|l| {\n+        region_param_defs: Rc::new(lifetimes.iter().map(|l| {\n                 ty::RegionParameterDef { name: l.name,\n                                          def_id: local_def(l.id) }\n             }).collect()),\n-        type_param_defs: Rc::new(generics.ty_params.mapi_to_vec(|offset, param| {\n+        type_param_defs: Rc::new(ty_params.mapi_to_vec(|offset, param| {\n             let existing_def_opt = {\n                 let ty_param_defs = ccx.tcx.ty_param_defs.borrow();\n-                ty_param_defs.get().find(&param.id).map(|def| *def)\n+                ty_param_defs.get().find(&param.id).map(|&def| def)\n             };\n-            match existing_def_opt {\n-                Some(def) => def,\n-                None => {\n-                    let param_ty = ty::param_ty {idx: base_index + offset,\n-                                                 def_id: local_def(param.id)};\n-                    let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n-                    let default = param.default.map(|x| ast_ty_to_ty(ccx, &ExplicitRscope, x));\n-                    let def = ty::TypeParameterDef {\n-                        ident: param.ident,\n-                        def_id: local_def(param.id),\n-                        bounds: bounds,\n-                        default: default\n-                    };\n-                    debug!(\"def for param: {}\", def.repr(ccx.tcx));\n-\n-                    let mut ty_param_defs = ccx.tcx\n-                                               .ty_param_defs\n-                                               .borrow_mut();\n-                    ty_param_defs.get().insert(param.id, def);\n-                    def\n-                }\n-            }\n-        }).move_iter().collect())\n+            existing_def_opt.unwrap_or_else(|| {\n+                let param_ty = ty::param_ty {idx: base_index + offset,\n+                                             def_id: local_def(param.id)};\n+                let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n+                let default = param.default.map(|x| ast_ty_to_ty(ccx, &ExplicitRscope, x));\n+                let def = ty::TypeParameterDef {\n+                    ident: param.ident,\n+                    def_id: local_def(param.id),\n+                    bounds: bounds,\n+                    default: default\n+                };\n+                debug!(\"def for param: {}\", def.repr(ccx.tcx));\n+                let mut ty_param_defs = ccx.tcx.ty_param_defs.borrow_mut();\n+                ty_param_defs.get().insert(param.id, def);\n+                def\n+            })\n+        }).move_iter().collect()),\n     };\n \n     fn compute_bounds(\n@@ -1056,7 +1067,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         }\n     }\n \n-    let ty_generics = ty_generics(ccx, ast_generics, 0);\n+    let ty_generics_for_fn_or_method =\n+        ty_generics_for_fn_or_method(ccx, ast_generics, 0);\n     let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs\n                         .iter()\n@@ -1076,7 +1088,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                             variadic: decl.variadic}\n         });\n     let tpt = ty_param_bounds_and_ty {\n-        generics: ty_generics,\n+        generics: ty_generics_for_fn_or_method,\n         ty: t_fn\n     };\n "}, {"sha": "0dea3460012c199b445db55c4f76b57d5b61360c", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -72,6 +72,7 @@ use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n use syntax::opt_vec::OptVec;\n+use syntax::parse::token;\n use util::ppaux::UserString;\n use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n@@ -479,19 +480,21 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::AddrOfSlice(_) => ~\" for slice expression\",\n             infer::Autoref(_) => ~\" for autoref\",\n             infer::Coercion(_) => ~\" for automatic coercion\",\n-            infer::BoundRegionInFnCall(_, br) => {\n+            infer::LateBoundRegion(_, br) => {\n                 format!(\" for {}in function call\",\n-                        bound_region_to_str(self.tcx, \"region \", true, br))\n+                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::BoundRegionInFnType(_, br) => {\n                 format!(\" for {}in function type\",\n-                        bound_region_to_str(self.tcx, \"region \", true, br))\n+                        bound_region_to_str(self.tcx, \"lifetime parameter \", true, br))\n             }\n-            infer::BoundRegionInTypeOrImpl(_) => {\n-                format!(\" for region in type/impl\")\n+            infer::EarlyBoundRegion(_, name) => {\n+                format!(\" for lifetime parameter `{}\",\n+                        token::get_name(name).get())\n             }\n-            infer::BoundRegionInCoherence(..) => {\n-                format!(\" for coherence check\")\n+            infer::BoundRegionInCoherence(name) => {\n+                format!(\" for lifetime parameter `{} in coherence check\",\n+                        token::get_name(name).get())\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\","}, {"sha": "ac73c30802557d4d3b9838a1bb79af1025d4b7ab", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -136,11 +136,11 @@ impl<'f> Combine for Glb<'f> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, b);\n         let b_vars = var_ids(self, &b_map);\n "}, {"sha": "7d772065da61e91e3b7f0167ab14b61c3579388f", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -126,10 +126,10 @@ impl<'f> Combine for Lub<'f> {\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n         let (b_with_fresh, _) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, b);\n \n         // Collect constraints."}, {"sha": "d3ae7d697e69984e051985dbb43bca7eaad54451", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -27,7 +27,7 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n@@ -44,6 +44,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n+use syntax::opt_vec::OptVec;\n use util::common::indent;\n use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr};\n \n@@ -221,19 +222,20 @@ pub enum RegionVariableOrigin {\n     // Regions created as part of an automatic coercion\n     Coercion(TypeTrace),\n \n+    // Region variables created as the values for early-bound regions\n+    EarlyBoundRegion(Span, ast::Name),\n+\n     // Region variables created for bound regions\n     // in a function or method that is called\n-    BoundRegionInFnCall(Span, ty::BoundRegion),\n+    LateBoundRegion(Span, ty::BoundRegion),\n \n     // Region variables created for bound regions\n     // when doing subtyping/lub/glb computations\n     BoundRegionInFnType(Span, ty::BoundRegion),\n \n     UpvarRegion(ty::UpvarId, Span),\n \n-    BoundRegionInTypeOrImpl(Span),\n-\n-    BoundRegionInCoherence,\n+    BoundRegionInCoherence(ast::Name),\n }\n \n pub enum fixup_err {\n@@ -663,6 +665,15 @@ impl InferCtxt {\n         Vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n+    pub fn region_vars_for_defs(&self,\n+                                span: Span,\n+                                defs: &[ty::RegionParameterDef])\n+                                -> OptVec<ty::Region> {\n+        defs.iter()\n+            .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n+            .collect()\n+    }\n+\n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n         self.region_vars.new_bound(binder_id)\n     }\n@@ -809,14 +820,14 @@ impl InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    pub fn replace_bound_regions_with_fresh_regions(&self,\n-                                                    trace: TypeTrace,\n-                                                    fsig: &ty::FnSig)\n+    pub fn replace_late_bound_regions_with_fresh_regions(&self,\n+                                                         trace: TypeTrace,\n+                                                         fsig: &ty::FnSig)\n                                                     -> (ty::FnSig,\n                                                         HashMap<ty::BoundRegion,\n                                                                 ty::Region>) {\n         let (map, fn_sig) =\n-            replace_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n+            replace_late_bound_regions_in_fn_sig(self.tcx, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\",\n@@ -932,10 +943,10 @@ impl RegionVariableOrigin {\n             AddrOfSlice(a) => a,\n             Autoref(a) => a,\n             Coercion(a) => a.span(),\n-            BoundRegionInFnCall(a, _) => a,\n+            EarlyBoundRegion(a, _) => a,\n+            LateBoundRegion(a, _) => a,\n             BoundRegionInFnType(a, _) => a,\n-            BoundRegionInTypeOrImpl(a) => a,\n-            BoundRegionInCoherence => codemap::DUMMY_SP,\n+            BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n             UpvarRegion(_, a) => a\n         }\n     }\n@@ -950,13 +961,14 @@ impl Repr for RegionVariableOrigin {\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n             Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n-            BoundRegionInFnCall(a, b) => format!(\"bound_regionInFnCall({},{})\",\n+            EarlyBoundRegion(a, b) => format!(\"EarlyBoundRegion({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n+            LateBoundRegion(a, b) => format!(\"LateBoundRegion({},{})\",\n+                                             a.repr(tcx), b.repr(tcx)),\n             BoundRegionInFnType(a, b) => format!(\"bound_regionInFnType({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n-            BoundRegionInTypeOrImpl(a) => format!(\"bound_regionInTypeOrImpl({})\",\n-                                               a.repr(tcx)),\n-            BoundRegionInCoherence => format!(\"bound_regionInCoherence\"),\n+            BoundRegionInCoherence(a) => format!(\"bound_regionInCoherence({})\",\n+                                                 a.repr(tcx)),\n             UpvarRegion(a, b) => format!(\"UpvarRegion({}, {})\",\n                                          a.repr(tcx),\n                                          b.repr(tcx)),"}, {"sha": "2233e680bc99e801d59704012b76a3589b85e1a7", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -12,7 +12,7 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::ty::TyVar;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n+use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::glb::Glb;\n@@ -166,13 +166,13 @@ impl<'f> Combine for Sub<'f> {\n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+            self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n                 self.get_ref().trace, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, b_sig) = {\n-            replace_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n+            replace_late_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, b, |br| {\n                 let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.get_ref().infcx.tcx, \"\", false, br),"}, {"sha": "2f06ab67a3bab52811601df67d00c8be0369b054", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -841,6 +841,12 @@ impl Repr for ty::Method {\n     }\n }\n \n+impl Repr for ast::Name {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        token::get_name(*self).get().to_str()\n+    }\n+}\n+\n impl Repr for ast::Ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         token::get_ident(*self).get().to_str()\n@@ -1010,6 +1016,12 @@ impl UserString for ty::t {\n     }\n }\n \n+impl UserString for ast::Ident {\n+    fn user_string(&self, _tcx: ctxt) -> ~str {\n+        token::get_name(self.name).get().to_owned()\n+    }\n+}\n+\n impl Repr for AbiSet {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         self.to_str()"}, {"sha": "9c8f8f8c30cc5b0fbe52bfe224e1887bea4f2013", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a> {\n+    fn get(&self) -> &'a int;\n+}\n+\n+struct Box<'a> {\n+    t: &'a int\n+}\n+\n+impl<'a> GetRef<'a> for Box<'a> {\n+    fn get(&self) -> &'a int {\n+        self.t\n+    }\n+}\n+\n+impl<'a> Box<'a> {\n+    fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a int {\n+        g2.get() //~ ERROR lifetime mismatch\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "9cff4849cbeb2b6bf339c38062376f276bcd7a98", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a, T> {\n+    fn get(&self) -> &'a T;\n+}\n+\n+struct Box<'a, T> {\n+    t: &'a T\n+}\n+\n+impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n+    fn get(&self) -> &'a T {\n+        self.t\n+    }\n+}\n+\n+fn get<'a,'b,G:GetRef<'a, int>>(g1: G, b: &'b int) -> &'b int {\n+    g1.get() //~ ERROR lifetime mismatch\n+}\n+\n+fn main() {\n+}"}, {"sha": "c011d11749b60318f4bd859881bce3300813fd6c", "filename": "src/test/run-pass/regions-early-bound-used-in-bound-method.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound-method.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a> {\n+    fn get(&self) -> &'a int;\n+}\n+\n+struct Box<'a> {\n+    t: &'a int\n+}\n+\n+impl<'a> GetRef<'a> for Box<'a> {\n+    fn get(&self) -> &'a int {\n+        self.t\n+    }\n+}\n+\n+impl<'a> Box<'a> {\n+    fn add<'b,G:GetRef<'b>>(&self, g2: G) -> int {\n+        *self.t + *g2.get()\n+    }\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(b1.add(b1), 6);\n+}"}, {"sha": "22ea87c8d2809009b07aa7779eb4119cacb00fe1", "filename": "src/test/run-pass/regions-early-bound-used-in-bound.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-bound.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait GetRef<'a, T> {\n+    fn get(&self) -> &'a T;\n+}\n+\n+struct Box<'a, T> {\n+    t: &'a T\n+}\n+\n+impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n+    fn get(&self) -> &'a T {\n+        self.t\n+    }\n+}\n+\n+fn add<'a,G:GetRef<'a, int>>(g1: G, g2: G) -> int {\n+    *g1.get() + *g2.get()\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(add(b1, b1), 6);\n+}"}, {"sha": "592f48223938584194a19a5fb0a59d67cf37819c", "filename": "src/test/run-pass/regions-early-bound-used-in-type-param.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/742e458102ff5236ecf24a05ab94898c76d6d1cf/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-used-in-type-param.rs?ref=742e458102ff5236ecf24a05ab94898c76d6d1cf", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that you can use a fn lifetime parameter as part of\n+// the value for a type parameter in a bound.\n+\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+struct Box<T> {\n+    t: T\n+}\n+\n+impl<T:Clone> Get<T> for Box<T> {\n+    fn get(&self) -> T {\n+        self.t.clone()\n+    }\n+}\n+\n+fn add<'a,G:Get<&'a int>>(g1: G, g2: G) -> int {\n+    *g1.get() + *g2.get()\n+}\n+\n+pub fn main() {\n+    let b1 = Box { t: &3 };\n+    assert_eq!(add(b1, b1), 6);\n+}"}]}