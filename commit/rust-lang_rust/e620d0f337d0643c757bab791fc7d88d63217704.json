{"sha": "e620d0f337d0643c757bab791fc7d88d63217704", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MjBkMGYzMzdkMDY0M2M3NTdiYWI3OTFmYzdkODhkNjMyMTc3MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-18T17:51:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-18T17:51:29Z"}, "message": "Auto merge of #69262 - Dylan-DPC:rollup-m6dt9cn, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #69181 (Change const eval to just return the value )\n - #69192 (Add more regression tests)\n - #69200 (Fix printing of `Yield` terminator)\n - #69205 (Allow whitespaces in revision flags)\n - #69233 (Clean up E0310 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d818d3abfb3a7a894dd5d497f9d3e00c15eb29c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d818d3abfb3a7a894dd5d497f9d3e00c15eb29c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e620d0f337d0643c757bab791fc7d88d63217704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e620d0f337d0643c757bab791fc7d88d63217704", "html_url": "https://github.com/rust-lang/rust/commit/e620d0f337d0643c757bab791fc7d88d63217704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e620d0f337d0643c757bab791fc7d88d63217704/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0d5813fd7fe4696b6eb61acf473a7f7a5f9b5a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d5813fd7fe4696b6eb61acf473a7f7a5f9b5a0", "html_url": "https://github.com/rust-lang/rust/commit/b0d5813fd7fe4696b6eb61acf473a7f7a5f9b5a0"}, {"sha": "210b18118e3e59ed84b87de4716b98dc4cc393bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/210b18118e3e59ed84b87de4716b98dc4cc393bd", "html_url": "https://github.com/rust-lang/rust/commit/210b18118e3e59ed84b87de4716b98dc4cc393bd"}], "stats": {"total": 495, "additions": 358, "deletions": 137}, "files": [{"sha": "a23ff6bd66d4b8bef638e664a5da9d731a89d780", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -2,6 +2,7 @@ use super::{CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n \n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n+use crate::mir::interpret::ConstValue;\n use crate::ty::layout::{Align, LayoutError, Size};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::{self, layout, Ty};\n@@ -40,7 +41,7 @@ CloneTypeFoldableImpls! {\n }\n \n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n-pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n+pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n #[derive(Debug)]\n pub struct ConstEvalErr<'tcx> {"}, {"sha": "2c146b5d7b42647b3ca95de088976a9331e16ebc", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n use crate::ty::{\n     layout::{HasDataLayout, Size},\n-    Ty,\n+    ParamEnv, Ty, TyCtxt,\n };\n \n use super::{sign_extend, truncate, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n@@ -66,6 +66,32 @@ impl<'tcx> ConstValue<'tcx> {\n             ConstValue::Scalar(val) => Some(val),\n         }\n     }\n+\n+    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n+        self.try_to_scalar()?.to_bits(size).ok()\n+    }\n+\n+    pub fn try_to_bits_for_ty(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<u128> {\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.try_to_bits(size)\n+    }\n+\n+    pub fn from_bool(b: bool) -> Self {\n+        ConstValue::Scalar(Scalar::from_bool(b))\n+    }\n+\n+    pub fn from_u64(i: u64) -> Self {\n+        ConstValue::Scalar(Scalar::from_u64(i))\n+    }\n+\n+    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        ConstValue::Scalar(Scalar::from_machine_usize(i, cx))\n+    }\n }\n \n /// A `Scalar` represents an immediate, primitive value existing outside of a\n@@ -287,6 +313,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: i as u128, size: 8 }\n     }\n \n+    #[inline]\n+    pub fn from_machine_usize(i: u64, cx: &impl HasDataLayout) -> Self {\n+        Self::from_uint(i, cx.data_layout().pointer_size)\n+    }\n+\n     #[inline]\n     pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n         let i = i.into();\n@@ -306,6 +337,11 @@ impl<'tcx, Tag> Scalar<Tag> {\n             .unwrap_or_else(|| bug!(\"Signed value {:#x} does not fit in {} bits\", i, size.bits()))\n     }\n \n+    #[inline]\n+    pub fn from_machine_isize(i: i64, cx: &impl HasDataLayout) -> Self {\n+        Self::from_int(i, cx.data_layout().pointer_size)\n+    }\n+\n     #[inline]\n     pub fn from_f32(f: Single) -> Self {\n         // We trust apfloat to give us properly truncated data."}, {"sha": "9b94f92acd4760caa4b6a75fa12ed8b9d580e0d0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1468,21 +1468,21 @@ impl<'tcx> TerminatorKind<'tcx> {\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n         use self::TerminatorKind::*;\n-        match *self {\n+        match self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n+            SwitchInt { discr, .. } => write!(fmt, \"switchInt({:?})\", discr),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n             Abort => write!(fmt, \"abort\"),\n-            Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n+            Yield { value, resume_arg, .. } => write!(fmt, \"{:?} = yield({:?})\", resume_arg, value),\n             Unreachable => write!(fmt, \"unreachable\"),\n-            Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace { ref location, ref value, .. } => {\n+            Drop { location, .. } => write!(fmt, \"drop({:?})\", location),\n+            DropAndReplace { location, value, .. } => {\n                 write!(fmt, \"replace({:?} <- {:?})\", location, value)\n             }\n-            Call { ref func, ref args, ref destination, .. } => {\n-                if let Some((ref destination, _)) = *destination {\n+            Call { func, args, destination, .. } => {\n+                if let Some((destination, _)) = destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n                 }\n                 write!(fmt, \"{:?}(\", func)?;\n@@ -1494,7 +1494,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n-            Assert { ref cond, expected, ref msg, .. } => {\n+            Assert { cond, expected, msg, .. } => {\n                 write!(fmt, \"assert(\")?;\n                 if !expected {\n                     write!(fmt, \"!\")?;"}, {"sha": "45ab3fc0b85a6985fafaf0de9c13658b42d95221", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -519,7 +519,7 @@ rustc_queries! {\n         /// Extracts a field of a (variant of a) const.\n         query const_field(\n             key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n-        ) -> &'tcx ty::Const<'tcx> {\n+        ) -> ConstValue<'tcx> {\n             no_force\n             desc { \"extract field of const\" }\n         }\n@@ -533,7 +533,7 @@ rustc_queries! {\n             desc { \"destructure constant\" }\n         }\n \n-        query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> &'tcx ty::Const<'tcx> {\n+        query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n             no_force\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }"}, {"sha": "a4b4e1d65742977e66ea331c15858f2a0602dffa", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -2388,10 +2388,10 @@ impl<'tcx> AdtDef {\n         let repr_type = self.repr.discr_type();\n         match tcx.const_eval_poly(expr_did) {\n             Ok(val) => {\n-                // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.try_eval_bits(tcx, param_env, val.ty) {\n+                let ty = repr_type.to_ty(tcx);\n+                if let Some(b) = val.try_to_bits_for_ty(tcx, param_env, ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                    Some(Discr { val: b, ty: val.ty })\n+                    Some(Discr { val: b, ty })\n                 } else {\n                     info!(\"invalid enum discriminant: {:#?}\", val);\n                     crate::mir::interpret::struct_error("}, {"sha": "21698cd73748524d68192b84b59241dded4dbc4e", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -14,7 +14,7 @@ use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLife\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult};\n+use crate::mir::interpret::{ConstEvalRawResult, ConstEvalResult, ConstValue};\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};"}, {"sha": "9cf61ebe88a165e07b9a580b166b567086cf62df", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -2417,9 +2417,14 @@ pub struct Const<'tcx> {\n static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n+    #[inline]\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n+    }\n+\n     #[inline]\n     pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n-        tcx.mk_const(Self { val: ConstKind::Value(ConstValue::Scalar(val)), ty })\n+        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n@@ -2473,7 +2478,9 @@ impl<'tcx> Const<'tcx> {\n \n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            tcx.const_eval_resolve(param_env, did, substs, promoted, None).ok()\n+            tcx.const_eval_resolve(param_env, did, substs, promoted, None)\n+                .ok()\n+                .map(|val| Const::from_value(tcx, val, self.ty))\n         };\n \n         match self.val {"}, {"sha": "09a84aff16811a80f14db9fd288fcbdfadee73ac", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -78,11 +78,9 @@ pub fn codegen_static_initializer(\n     cx: &CodegenCx<'ll, 'tcx>,\n     def_id: DefId,\n ) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n-    let static_ = cx.tcx.const_eval_poly(def_id)?;\n-\n-    let alloc = match static_.val {\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) if offset.bytes() == 0 => alloc,\n-        _ => bug!(\"static const eval returned {:#?}\", static_),\n+    let alloc = match cx.tcx.const_eval_poly(def_id)? {\n+        ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => alloc,\n+        val => bug!(\"static const eval returned {:#?}\", val),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }"}, {"sha": "3d1e72e1c73d735c1b00faa32e5d855b22f70965", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -193,7 +193,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     .tcx\n                     .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n                     .unwrap();\n-                OperandRef::from_const(self, ty_name).immediate_or_packed_pair(self)\n+                OperandRef::from_const(self, ty_name, ret_ty).immediate_or_packed_pair(self)\n             }\n             \"init\" => {\n                 let ty = substs.type_at(0);"}, {"sha": "d684f842ddc69e0df96f81c53bc258d915f67585", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -991,7 +991,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 caller.line as u32,\n                 caller.col_display as u32 + 1,\n             ));\n-            OperandRef::from_const(bx, const_loc)\n+            OperandRef::from_const(bx, const_loc, bx.tcx().caller_location_ty())\n         })\n     }\n "}, {"sha": "9ceb75a603bc465276c2f5f3acdfecdc7c67b722", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1,7 +1,7 @@\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n use rustc::mir;\n-use rustc::mir::interpret::ErrorHandled;\n+use rustc::mir::interpret::{ConstValue, ErrorHandled};\n use rustc::ty::layout::{self, HasTyCtxt};\n use rustc::ty::{self, Ty};\n use rustc_index::vec::Idx;\n@@ -30,15 +30,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => {\n                 let val = self.eval_mir_constant(constant)?;\n-                Ok(OperandRef::from_const(bx, val))\n+                let ty = self.monomorphize(&constant.literal.ty);\n+                Ok(OperandRef::from_const(bx, val.clone(), ty))\n             }\n         }\n     }\n \n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n+    ) -> Result<ConstValue<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n             ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n                 let substs = self.monomorphize(&substs);\n@@ -55,7 +56,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         err\n                     })\n             }\n-            _ => Ok(self.monomorphize(&constant.literal)),\n+            ty::ConstKind::Value(value) => Ok(value),\n+            _ => {\n+                let const_ = self.monomorphize(&constant.literal);\n+                if let ty::ConstKind::Value(value) = const_.val {\n+                    Ok(value)\n+                } else {\n+                    span_bug!(constant.span, \"encountered bad ConstKind in codegen: {:?}\", const_);\n+                }\n+            }\n         }\n     }\n \n@@ -65,21 +74,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &Bx,\n         span: Span,\n         ty: Ty<'tcx>,\n-        constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n+        constant: Result<ConstValue<'tcx>, ErrorHandled>,\n     ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n-            .map(|c| {\n-                let field_ty = c.ty.builtin_index().unwrap();\n-                let fields = match c.ty.kind {\n+            .map(|val| {\n+                let field_ty = ty.builtin_index().unwrap();\n+                let fields = match ty.kind {\n                     ty::Array(_, n) => n.eval_usize(bx.tcx(), ty::ParamEnv::reveal_all()),\n-                    _ => bug!(\"invalid simd shuffle type: {}\", c.ty),\n+                    _ => bug!(\"invalid simd shuffle type: {}\", ty),\n                 };\n+                let c = ty::Const::from_value(bx.tcx(), val, ty);\n                 let values: Vec<_> = (0..fields)\n                     .map(|field| {\n                         let field = bx.tcx().const_field(\n                             ty::ParamEnv::reveal_all().and((&c, mir::Field::new(field as usize))),\n                         );\n-                        if let Some(prim) = field.val.try_to_scalar() {\n+                        if let Some(prim) = field.try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n                             let scalar = match layout.abi {\n                                 layout::Abi::Scalar(ref x) => x,"}, {"sha": "07c8829e7d88352bb6edf0ce4c9e6075d7e0cb58", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -8,8 +8,8 @@ use crate::MemFlags;\n \n use rustc::mir;\n use rustc::mir::interpret::{ConstValue, ErrorHandled, Pointer, Scalar};\n-use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n+use rustc::ty::Ty;\n \n use std::fmt;\n \n@@ -66,20 +66,16 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        val: &'tcx ty::Const<'tcx>,\n+        val: ConstValue<'tcx>,\n+        ty: Ty<'tcx>,\n     ) -> Self {\n-        let layout = bx.layout_of(val.ty);\n+        let layout = bx.layout_of(ty);\n \n         if layout.is_zst() {\n             return OperandRef::new_zst(bx, layout);\n         }\n \n-        let val_val = match val.val {\n-            ty::ConstKind::Value(val_val) => val_val,\n-            _ => bug!(\"encountered bad ConstKind in codegen\"),\n-        };\n-\n-        let val = match val_val {\n+        let val = match val {\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,"}, {"sha": "8d4311d018b210296a1c4c6308c31ccf90acc389", "filename": "src/librustc_error_codes/error_codes/E0310.md", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1,7 +1,7 @@\n-Types in type definitions have lifetimes associated with them that represent\n-how long the data stored within them is guaranteed to be live. This lifetime\n-must be as long as the data needs to be alive, and missing the constraint that\n-denotes this will cause this error.\n+A parameter type is missing a lifetime constraint or has a lifetime that\n+does not live long enough.\n+\n+Erroneous code example:\n \n ```compile_fail,E0310\n // This won't compile because T is not constrained to the static lifetime\n@@ -11,6 +11,11 @@ struct Foo<T> {\n }\n ```\n \n+Type parameters in type definitions have lifetimes associated with them that\n+represent how long the data stored within them is guaranteed to live. This\n+lifetime must be as long as the data needs to be alive, and missing the\n+constraint that denotes this will cause this error.\n+\n This will compile, because it has the constraint on the type parameter:\n \n ```"}, {"sha": "04e2558a308b3c81d62e43aa696fd46ee51b69db", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn const_field<'tcx>(\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: &'tcx ty::Const<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n+) -> ConstValue<'tcx> {\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     // get the operand again\n@@ -46,19 +46,13 @@ pub(crate) fn const_field<'tcx>(\n pub(crate) fn const_caller_location<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (file, line, col): (Symbol, u32, u32),\n-) -> &'tcx ty::Const<'tcx> {\n+) -> ConstValue<'tcx> {\n     trace!(\"const_caller_location: {}:{}:{}\", file, line, col);\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n-    let loc_ty = tcx.caller_location_ty();\n     let loc_place = ecx.alloc_caller_location(file, line, col);\n     intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n-    let loc_const = ty::Const {\n-        ty: loc_ty,\n-        val: ty::ConstKind::Value(ConstValue::Scalar(loc_place.ptr.into())),\n-    };\n-\n-    tcx.mk_const(loc_const)\n+    ConstValue::Scalar(loc_place.ptr.into())\n }\n \n // this function uses `unwrap` copiously, because an already validated constant\n@@ -84,7 +78,8 @@ pub(crate) fn destructure_const<'tcx>(\n     let down = ecx.operand_downcast(op, variant).unwrap();\n     let fields_iter = (0..field_count).map(|i| {\n         let field_op = ecx.operand_field(down, i).unwrap();\n-        op_to_const(&ecx, field_op)\n+        let val = op_to_const(&ecx, field_op);\n+        ty::Const::from_value(tcx, val, field_op.layout.ty)\n     });\n     let fields = tcx.arena.alloc_from_iter(fields_iter);\n "}, {"sha": "4d5464f774ff54dc2871cd731591a3b2dd0a4617", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -97,7 +97,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n+) -> ConstValue<'tcx> {\n     // We do not have value optimizations for everything.\n     // Only scalars and slices, since they are very common.\n     // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n@@ -144,7 +144,7 @@ pub(super) fn op_to_const<'tcx>(\n             ConstValue::Scalar(Scalar::zst())\n         }\n     };\n-    let val = match immediate {\n+    match immediate {\n         Ok(mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n@@ -166,8 +166,7 @@ pub(super) fn op_to_const<'tcx>(\n             let len: usize = len.try_into().unwrap();\n             ConstValue::Slice { data, start, end: start + len }\n         }\n-    };\n-    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n+    }\n }\n \n fn validate_and_turn_into_const<'tcx>(\n@@ -195,13 +194,10 @@ fn validate_and_turn_into_const<'tcx>(\n         // whether they become immediates.\n         if is_static || cid.promoted.is_some() {\n             let ptr = mplace.ptr.assert_ptr();\n-            Ok(tcx.mk_const(ty::Const {\n-                val: ty::ConstKind::Value(ConstValue::ByRef {\n-                    alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                    offset: ptr.offset,\n-                }),\n-                ty: mplace.layout.ty,\n-            }))\n+            Ok(ConstValue::ByRef {\n+                alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                offset: ptr.offset,\n+            })\n         } else {\n             Ok(op_to_const(&ecx, mplace.into()))\n         }"}, {"sha": "fc4ba4d6cd9783c432f486e5ce015aefe7b17a31", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -756,6 +756,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub(super) fn const_eval(\n         &self,\n         gid: GlobalId<'tcx>,\n+        ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // For statics we pick `ParamEnv::reveal_all`, because statics don't have generics\n         // and thus don't care about the parameter environment. While we could just use\n@@ -777,7 +778,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // recursion deeper than one level, because the `tcx.const_eval` above is guaranteed to not\n         // return `ConstValue::Unevaluated`, which is the only way that `eval_const_to_op` will call\n         // `ecx.const_eval`.\n-        self.eval_const_to_op(val, None)\n+        let const_ = ty::Const { val: ty::ConstKind::Value(val), ty };\n+        self.eval_const_to_op(&const_, None)\n     }\n \n     pub fn const_eval_raw("}, {"sha": "04f0f92d67ff26ce032d09595dab5bbafceabdf3", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -48,22 +48,15 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n-) -> InterpResult<'tcx, &'tcx ty::Const<'tcx>> {\n+) -> InterpResult<'tcx, ConstValue<'tcx>> {\n     let tp_ty = substs.type_at(0);\n     let name = tcx.item_name(def_id);\n     Ok(match name {\n         sym::type_name => {\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n-            tcx.mk_const(ty::Const {\n-                val: ty::ConstKind::Value(ConstValue::Slice {\n-                    data: alloc,\n-                    start: 0,\n-                    end: alloc.len(),\n-                }),\n-                ty: tcx.mk_static_str(),\n-            })\n+            ConstValue::Slice { data: alloc, start: 0, end: alloc.len() }\n         }\n-        sym::needs_drop => ty::Const::from_bool(tcx, tp_ty.needs_drop(tcx, param_env)),\n+        sym::needs_drop => ConstValue::from_bool(tp_ty.needs_drop(tcx, param_env)),\n         sym::size_of | sym::min_align_of | sym::pref_align_of => {\n             let layout = tcx.layout_of(param_env.and(tp_ty)).map_err(|e| err_inval!(Layout(e)))?;\n             let n = match name {\n@@ -72,11 +65,9 @@ crate fn eval_nullary_intrinsic<'tcx>(\n                 sym::size_of => layout.size.bytes(),\n                 _ => bug!(),\n             };\n-            ty::Const::from_usize(tcx, n)\n-        }\n-        sym::type_id => {\n-            ty::Const::from_bits(tcx, tcx.type_id_hash(tp_ty).into(), param_env.and(tcx.types.u64))\n+            ConstValue::from_machine_usize(n, &tcx)\n         }\n+        sym::type_id => ConstValue::from_u64(tcx.type_id_hash(tp_ty).into()),\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n }\n@@ -119,7 +110,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::type_id\n             | sym::type_name => {\n                 let gid = GlobalId { instance, promoted: None };\n-                let val = self.const_eval(gid)?;\n+                let ty = match intrinsic_name {\n+                    sym::min_align_of | sym::pref_align_of | sym::size_of => self.tcx.types.usize,\n+                    sym::needs_drop => self.tcx.types.bool,\n+                    sym::type_id => self.tcx.types.u64,\n+                    sym::type_name => self.tcx.mk_static_str(),\n+                    _ => span_bug!(span, \"Already checked for nullary intrinsics\"),\n+                };\n+                let val = self.const_eval(gid, ty)?;\n                 self.copy_op(val, dest)?;\n             }\n "}, {"sha": "14b8a341e26a0e82841c9961be2e74b0050edf23", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -518,7 +518,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// \"universe\" (param_env).\n     crate fn eval_const_to_op(\n         &self,\n-        val: &'tcx ty::Const<'tcx>,\n+        val: &ty::Const<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let tag_scalar = |scalar| match scalar {\n@@ -536,7 +536,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // potentially requiring the current static to be evaluated again. This is not a\n                 // problem here, because we are building an operand which means an actual read is\n                 // happening.\n-                return Ok(OpTy::from(self.const_eval(GlobalId { instance, promoted })?));\n+                return Ok(self.const_eval(GlobalId { instance, promoted }, val.ty)?);\n             }\n             ty::ConstKind::Infer(..)\n             | ty::ConstKind::Bound(..)"}, {"sha": "0fa7d6a9b72236080cb97e2a952865e1ee246d60", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -357,7 +357,7 @@ fn collect_items_rec<'tcx>(\n             recursion_depth_reset = None;\n \n             if let Ok(val) = tcx.const_eval_poly(def_id) {\n-                collect_const(tcx, val, InternalSubsts::empty(), &mut neighbors);\n+                collect_const_value(tcx, val, &mut neighbors);\n             }\n         }\n         MonoItem::Fn(instance) => {\n@@ -971,7 +971,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n \n                 if let Ok(val) = self.tcx.const_eval_poly(def_id) {\n-                    collect_const(self.tcx, val, InternalSubsts::empty(), &mut self.output);\n+                    collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n@@ -1185,18 +1185,10 @@ fn collect_const<'tcx>(\n         tcx.subst_and_normalize_erasing_regions(param_substs, param_env, &constant);\n \n     match substituted_constant.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Ptr(ptr))) => {\n-            collect_miri(tcx, ptr.alloc_id, output)\n-        }\n-        ty::ConstKind::Value(ConstValue::Slice { data: alloc, start: _, end: _ })\n-        | ty::ConstKind::Value(ConstValue::ByRef { alloc, .. }) => {\n-            for &((), id) in alloc.relocations().values() {\n-                collect_miri(tcx, id, output);\n-            }\n-        }\n+        ty::ConstKind::Value(val) => collect_const_value(tcx, val, output),\n         ty::ConstKind::Unevaluated(def_id, substs, promoted) => {\n             match tcx.const_eval_resolve(param_env, def_id, substs, promoted, None) {\n-                Ok(val) => collect_const(tcx, val, param_substs, output),\n+                Ok(val) => collect_const_value(tcx, val, output),\n                 Err(ErrorHandled::Reported) => {}\n                 Err(ErrorHandled::TooGeneric) => {\n                     span_bug!(tcx.def_span(def_id), \"collection encountered polymorphic constant\",)\n@@ -1206,3 +1198,19 @@ fn collect_const<'tcx>(\n         _ => {}\n     }\n }\n+\n+fn collect_const_value<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    value: ConstValue<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n+    match value {\n+        ConstValue::Scalar(Scalar::Ptr(ptr)) => collect_miri(tcx, ptr.alloc_id, output),\n+        ConstValue::Slice { data: alloc, start: _, end: _ } | ConstValue::ByRef { alloc, .. } => {\n+            for &((), id) in alloc.relocations().values() {\n+                collect_miri(tcx, id, output);\n+            }\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "e594e1eeed07e3b95e6d84d589f31a20ea7bb432", "filename": "src/librustc_mir_build/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -65,7 +65,7 @@ crate fn lit_to_const<'tcx>(\n         ast::LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n         ast::LitKind::Err(_) => return Err(LitToConstError::Reported),\n     };\n-    Ok(tcx.mk_const(ty::Const { val: ty::ConstKind::Value(lit), ty }))\n+    Ok(ty::Const::from_value(tcx, lit, ty))\n }\n \n fn parse_float<'tcx>(num: Symbol, fty: ast::FloatTy, neg: bool) -> Result<ConstValue<'tcx>, ()> {"}, {"sha": "74006c883716c7bbc446c2419142f6d422b62508", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -418,7 +418,17 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                 None,\n                 Some(span),\n             ) {\n-                Ok(cv) => cv.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()),\n+                Ok(cv) => {\n+                    if let Some(count) = cv.try_to_bits_for_ty(\n+                        cx.tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        cx.tcx.types.usize,\n+                    ) {\n+                        count as u64\n+                    } else {\n+                        bug!(\"repeat count constant value can't be converted to usize\");\n+                    }\n+                }\n                 Err(ErrorHandled::Reported) => 0,\n                 Err(ErrorHandled::TooGeneric) => {\n                     let span = cx.tcx.def_span(def_id);"}, {"sha": "85f03629b646a4cdbdd1855896ba56d6d2c3fd29", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -343,12 +343,11 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n                         ty: rty,\n                         span: pat.span,\n                         kind: box PatKind::Constant {\n-                            value: self.tcx.mk_const(Const {\n-                                val: ty::ConstKind::Value(\n-                                    self.fold_const_value_deref(*val, rty, crty),\n-                                ),\n-                                ty: rty,\n-                            }),\n+                            value: Const::from_value(\n+                                self.tcx,\n+                                self.fold_const_value_deref(*val, rty, crty),\n+                                rty,\n+                            ),\n                         },\n                     },\n                 },"}, {"sha": "9101174646959f24991347b47934675bd9fca5d4", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -769,7 +769,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     Some(span),\n                 ) {\n                     Ok(value) => {\n-                        let pattern = self.const_to_pat(value, id, span);\n+                        let const_ =\n+                            ty::Const::from_value(self.tcx, value, self.tables.node_type(id));\n+\n+                        let pattern = self.const_to_pat(&const_, id, span);\n                         if !is_associated_const {\n                             return pattern;\n                         }\n@@ -789,7 +792,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                                         user_ty_span: span,\n                                     },\n                                 }),\n-                                ty: value.ty,\n+                                ty: const_.ty,\n                             }\n                         } else {\n                             pattern"}, {"sha": "38d73256469fe964ea3de10f20dc0790a7cad1ef", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1012,6 +1012,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(self.to_const(count, tcx.type_of(count_def_id)))\n         } else {\n             tcx.const_eval_poly(count_def_id)\n+                .map(|val| ty::Const::from_value(tcx, val, tcx.type_of(count_def_id)))\n         };\n \n         let uty = match expected {"}, {"sha": "f714514040141476d13b34981878964933d35cc4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1832,18 +1832,17 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    if let Ok(static_) = tcx.const_eval_poly(id) {\n-        let alloc = if let ty::ConstKind::Value(ConstValue::ByRef { alloc, .. }) = static_.val {\n-            alloc\n-        } else {\n-            bug!(\"Matching on non-ByRef static\")\n-        };\n-        if alloc.relocations().len() != 0 {\n-            let msg = \"statics with a custom `#[link_section]` must be a \\\n+    match tcx.const_eval_poly(id) {\n+        Ok(ConstValue::ByRef { alloc, .. }) => {\n+            if alloc.relocations().len() != 0 {\n+                let msg = \"statics with a custom `#[link_section]` must be a \\\n                        simple list of bytes on the wasm target with no \\\n                        extra levels of indirection such as references\";\n-            tcx.sess.span_err(span, msg);\n+                tcx.sess.span_err(span, msg);\n+            }\n         }\n+        Ok(_) => bug!(\"Matching on non-ByRef static\"),\n+        Err(_) => {}\n     }\n }\n "}, {"sha": "af81087b53ed6cef88479f43d62361968afcac81", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1332,7 +1332,9 @@ impl Clean<Type> for hir::Ty<'_> {\n             TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir().local_def_id(length.hir_id);\n                 let length = match cx.tcx.const_eval_poly(def_id) {\n-                    Ok(length) => print_const(cx, length),\n+                    Ok(length) => {\n+                        print_const(cx, ty::Const::from_value(cx.tcx, length, cx.tcx.types.usize))\n+                    }\n                     Err(_) => cx\n                         .sess()\n                         .source_map()"}, {"sha": "9863a7db6eabe8e1a46e3e4e6ae90ac94f75f35b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -457,7 +457,7 @@ pub fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-pub fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n+pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def_id, _, promoted) => {\n             let mut s = if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n@@ -487,15 +487,18 @@ pub fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n }\n \n pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n-    let value =\n-        cx.tcx.const_eval_poly(def_id).ok().and_then(|value| match (value.val, &value.ty.kind) {\n-            (_, ty::Ref(..)) => None,\n-            (ty::ConstKind::Value(ConstValue::Scalar(_)), ty::Adt(_, _)) => None,\n-            (ty::ConstKind::Value(ConstValue::Scalar(_)), _) => {\n-                Some(print_const_with_custom_print_scalar(cx, value))\n+    let value = cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n+        let ty = cx.tcx.type_of(def_id);\n+        match (val, &ty.kind) {\n+            (_, &ty::Ref(..)) => None,\n+            (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,\n+            (ConstValue::Scalar(_), _) => {\n+                let const_ = ty::Const::from_value(cx.tcx, val, ty);\n+                Some(print_const_with_custom_print_scalar(cx, const_))\n             }\n             _ => None,\n-        });\n+        }\n+    });\n \n     value\n }"}, {"sha": "82b216a99cf555ad9439ae1ec62a11c8676dd8ac", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -49,7 +49,7 @@ fn main() {\n //     StorageLive(_4);\n //     _4 = Bar(const 6i32,);\n //     ...\n-//     _1 = suspend(move _6) -> [resume: bb2, drop: bb4];\n+//     _5 = yield(move _6) -> [resume: bb2, drop: bb4];\n // }\n // bb1 (cleanup): {\n //     resume;"}, {"sha": "35cbc7003f095183119ed320c2289901efa82ac3", "filename": "src/test/ui/consts/issue-63952.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #63952, shouldn't hang.\n+\n+use std::usize;\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct SliceRepr {\n+    ptr: *const u8,\n+    len: usize,\n+}\n+\n+union SliceTransmute {\n+    repr: SliceRepr,\n+    slice: &'static [u8],\n+}\n+\n+// bad slice: length too big to even exist anywhere\n+const SLICE_WAY_TOO_LONG: &[u8] = unsafe { //~ ERROR: it is undefined behavior to use this value\n+    SliceTransmute {\n+        repr: SliceRepr {\n+            ptr: &42,\n+            len: usize::MAX,\n+        },\n+    }\n+    .slice\n+};\n+\n+fn main() {}"}, {"sha": "d5ed970fc3533d09ca7283f74d2e3487057dead4", "filename": "src/test/ui/consts/issue-63952.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-63952.stderr?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,17 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/issue-63952.rs:18:1\n+   |\n+LL | / const SLICE_WAY_TOO_LONG: &[u8] = unsafe {\n+LL | |     SliceTransmute {\n+LL | |         repr: SliceRepr {\n+LL | |             ptr: &42,\n+...  |\n+LL | |     .slice\n+LL | | };\n+   | |__^ invalid slice: total size is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "01f4c95639d195ced536abd5fe25f74af186397b", "filename": "src/test/ui/generic-associated-types/issue-68653.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68653.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,16 @@\n+// A regression test for #68653, which was fixed by #68938.\n+\n+// check-pass\n+\n+#![allow(incomplete_features)]\n+#![feature(generic_associated_types)]\n+\n+trait Fun {\n+    type F<'a: 'a>;\n+}\n+\n+impl <T> Fun for T {\n+    type F<'a> = Self;\n+}\n+\n+fn main() {}"}, {"sha": "fef5213db9f7a51d057da27fa9f6710d2c395d4a", "filename": "src/test/ui/issues/auxiliary/issue-51798.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-51798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-51798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fauxiliary%2Fissue-51798.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,3 @@\n+#![crate_type = \"lib\"]\n+\n+pub fn vec() -> Vec<u8> { vec![] }"}, {"sha": "b075809e93ac29ba62663c1294b0207d49e87ae0", "filename": "src/test/ui/issues/issue-51798.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fissues%2Fissue-51798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fissues%2Fissue-51798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51798.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,14 @@\n+// edition:2018\n+// aux-build:issue-51798.rs\n+// check-pass\n+\n+extern crate issue_51798;\n+\n+mod server {\n+    fn f() {\n+        let mut v = issue_51798::vec();\n+        v.clear();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b9c0bf834ddb251e19ec6f614f1427b12a15fe07", "filename": "src/test/ui/parser/issue-62894.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,7 @@\n+// Regression test for #62894, shouldn't crash.\n+// error-pattern: this file contains an unclosed delimiter\n+// error-pattern: expected one of `(`, `[`, or `{`, found keyword `fn`\n+\n+fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n+\n+fn main() {}"}, {"sha": "6db380f7a7fe22c42fb9c93bc52debbc7a40d008", "filename": "src/test/ui/parser/issue-62894.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62894.stderr?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,47 @@\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-62894.rs:7:14\n+   |\n+LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n+   |        -           -                   - unclosed delimiter\n+   |        |           |\n+   |        |           unclosed delimiter\n+   |        unclosed delimiter\n+LL | \n+LL | fn main() {}\n+   |              ^\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-62894.rs:7:14\n+   |\n+LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n+   |        -           -                   - unclosed delimiter\n+   |        |           |\n+   |        |           unclosed delimiter\n+   |        unclosed delimiter\n+LL | \n+LL | fn main() {}\n+   |              ^\n+\n+error: this file contains an unclosed delimiter\n+  --> $DIR/issue-62894.rs:7:14\n+   |\n+LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n+   |        -           -                   - unclosed delimiter\n+   |        |           |\n+   |        |           unclosed delimiter\n+   |        unclosed delimiter\n+LL | \n+LL | fn main() {}\n+   |              ^\n+\n+error: expected one of `(`, `[`, or `{`, found keyword `fn`\n+  --> $DIR/issue-62894.rs:7:1\n+   |\n+LL | fn f() { assert_eq!(f(), (), assert_eq!(assert_eq!\n+   |                                                   - expected one of `(`, `[`, or `{`\n+LL | \n+LL | fn main() {}\n+   | ^^ unexpected token\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "20e81e4359bacf0e177b28c8971796f4553c31d2", "filename": "src/test/ui/specialization/issue-39618.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fspecialization%2Fissue-39618.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fspecialization%2Fissue-39618.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-39618.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -0,0 +1,27 @@\n+// Regression test for #39618, shouldn't crash.\n+// FIXME(JohnTitor): Centril pointed out this looks suspicions, we should revisit here.\n+// More context: https://github.com/rust-lang/rust/pull/69192#discussion_r379846796\n+\n+// check-pass\n+\n+#![feature(specialization)]\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+trait Bar {\n+    fn bar(&self);\n+}\n+\n+impl<T> Bar for T where T: Foo {\n+    fn bar(&self) {}\n+}\n+\n+impl<T> Foo for T where T: Bar {\n+    fn foo(&self) {}\n+}\n+\n+impl Foo for u64 {}\n+\n+fn main() {}"}, {"sha": "2a24a8c3c9485c60b7f74e90ea3bf32887178d11", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -631,10 +631,6 @@ fn iter_header<R: Read>(testfile: &Path, cfg: Option<&str>, rdr: R, it: &mut dyn\n \n     let comment = if testfile.to_string_lossy().ends_with(\".rs\") { \"//\" } else { \"#\" };\n \n-    // FIXME: would be nice to allow some whitespace between comment and brace :)\n-    // It took me like 2 days to debug why compile-flags weren\u2019t taken into account for my test :)\n-    let comment_with_brace = comment.to_string() + \"[\";\n-\n     let mut rdr = BufReader::new(rdr);\n     let mut ln = String::new();\n \n@@ -650,7 +646,7 @@ fn iter_header<R: Read>(testfile: &Path, cfg: Option<&str>, rdr: R, it: &mut dyn\n         let ln = ln.trim();\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return;\n-        } else if ln.starts_with(&comment_with_brace) {\n+        } else if ln.starts_with(comment) && ln[comment.len()..].trim_start().starts_with('[') {\n             // A comment like `//[foo]` is specific to revision `foo`\n             if let Some(close_brace) = ln.find(']') {\n                 let open_brace = ln.find('[').unwrap();\n@@ -663,10 +659,7 @@ fn iter_header<R: Read>(testfile: &Path, cfg: Option<&str>, rdr: R, it: &mut dyn\n                     it(ln[(close_brace + 1)..].trim_start());\n                 }\n             } else {\n-                panic!(\n-                    \"malformed condition directive: expected `{}foo]`, found `{}`\",\n-                    comment_with_brace, ln\n-                )\n+                panic!(\"malformed condition directive: expected `{}[foo]`, found `{}`\", comment, ln)\n             }\n         } else if ln.starts_with(comment) {\n             it(ln[comment.len()..].trim_start());"}]}