{"sha": "c38ddb8040edce1b05bc09a0e8439472e9f67623", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOGRkYjgwNDBlZGNlMWIwNWJjMDlhMGU4NDM5NDcyZTlmNjc2MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-18T02:28:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-18T02:28:21Z"}, "message": "Auto merge of #74480 - yoshuawuyts:hardware_threads, r=dtolnay\n\nAdd std::thread::available_concurrency\n\nThis PR adds a counterpart to [C++'s `std::thread::hardware_concurrency`](https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency) to Rust, tracking issue https://github.com/rust-lang/rust/issues/74479.\n\ncc/ `@rust-lang/libs`\n\n## Motivation\n\nBeing able to know how many hardware threads a platform supports is a core part of building multi-threaded code. In C++ 11 this has become available through the [`std::thread::hardware_concurrency`](https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency) API. Currently in Rust most of the ecosystem depends on the [`num_cpus` crate](https://docs.rs/num_cpus/1.13.0/num_cpus/) ([no.35 in top 500 crates](https://docs.google.com/spreadsheets/d/1wwahRMHG3buvnfHjmPQFU4Kyfq15oTwbfsuZpwHUKc4/edit#gid=1253069234)) to provide this functionality. This PR proposes an API to provide access to the number of hardware threads available on a given platform.\n\n__edit (2020-07-24):__ The purpose of this PR is to provide a hint for how many threads to spawn to saturate the processor. There's value in introducing APIs for NUMA and Windows processor groups, but those are intentionally out of scope for this PR. See: https://github.com/rust-lang/rust/pull/74480#issuecomment-662116186.\n\n## Naming\n\nDiscussing the naming of the API on Zulip surfaced two options:\n\n- `std::thread::hardware_concurrency`\n- `std::thread::hardware_threads`\n\nBoth options seemed acceptable, but overall people seem to gravitate the most towards `hardware_threads`. Additionally `@jonas-schievink` pointed out that the \"hardware threads\" terminology is well-established and is used in among other the [RISC-V specification](https://riscv.org/specifications/isa-spec-pdf/) (page 20):\n\n> A component is termed a core if it contains an independent instruction fetch unit. A RISC-V-compatible core might support multiple RISC-V-compatible __hardware threads__, or harts, through multithreading.\n\nIt's also worth noting that [the original paper introducing C++'s `std::thread` submodule](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html) unfortunately doesn't feature any discussion on the naming of `hardware_concurrency`, so we can't use that to help inform our decision here.\n\n## Return type\n\nAn important consideration `@joshtriplett` brought up is that we don't want to default to `1` for platforms where the number of available threads cannot be retrieved. Instead we want to inform the users of the fact that we don't know and allow them to handle that case. Which is why this PR uses `Option<NonZeroUsize>` as its return type, where `None` is returned on platforms where we don't know the number of hardware threads available.\n\nThe reasoning for `NonZeroUsize` vs `usize` is that if the number of threads for a platform are known, they'll always be at least 1. As evidenced by the example the `NonZero*` family of APIs may currently not be the most ergonomic to use, but improving the ergonomics of them is something that I think we can address separately.\n\n## Implementation\n\n`@Mark-Simulacrum` pointed out that most of the code we wanted to expose here was already available under `libtest`. So this PR mostly moves the internal code of libtest into a public API.", "tree": {"sha": "3be180f50cbdf5626bb9b0cee4bc646f2ee14cd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3be180f50cbdf5626bb9b0cee4bc646f2ee14cd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c38ddb8040edce1b05bc09a0e8439472e9f67623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c38ddb8040edce1b05bc09a0e8439472e9f67623", "html_url": "https://github.com/rust-lang/rust/commit/c38ddb8040edce1b05bc09a0e8439472e9f67623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c38ddb8040edce1b05bc09a0e8439472e9f67623/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc42a0f3eae5103888dbc10f3a7cf213977468c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc42a0f3eae5103888dbc10f3a7cf213977468c", "html_url": "https://github.com/rust-lang/rust/commit/cbc42a0f3eae5103888dbc10f3a7cf213977468c"}, {"sha": "3717646366a91ee9ca0b574973ec090670f9a4f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3717646366a91ee9ca0b574973ec090670f9a4f8", "html_url": "https://github.com/rust-lang/rust/commit/3717646366a91ee9ca0b574973ec090670f9a4f8"}], "stats": {"total": 267, "additions": 166, "deletions": 101}, "files": [{"sha": "4e805e4f599a85239aa3f01b1ec72afa37d2fbfb", "filename": "library/std/src/thread/available_concurrency.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs?ref=c38ddb8040edce1b05bc09a0e8439472e9f67623", "patch": "@@ -0,0 +1,157 @@\n+use crate::io;\n+use crate::num::NonZeroUsize;\n+\n+/// Returns the number of hardware threads available to the program.\n+///\n+/// This value should be considered only a hint.\n+///\n+/// # Platform-specific behavior\n+///\n+/// If interpreted as the number of actual hardware threads, it may undercount on\n+/// Windows systems with more than 64 hardware threads. If interpreted as the\n+/// available concurrency for that process, it may overcount on Windows systems\n+/// when limited by a process wide affinity mask or job object limitations, and\n+/// it may overcount on Linux systems when limited by a process wide affinity\n+/// mask or affected by cgroups limits.\n+///\n+/// # Errors\n+///\n+/// This function will return an error in the following situations, but is not\n+/// limited to just these cases:\n+///\n+/// - If the number of hardware threads is not known for the target platform.\n+/// - The process lacks permissions to view the number of hardware threads\n+///   available.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// #![feature(available_concurrency)]\n+/// use std::thread;\n+///\n+/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n+/// ```\n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    available_concurrency_internal()\n+}\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(windows)] {\n+        #[allow(nonstandard_style)]\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            #[repr(C)]\n+            struct SYSTEM_INFO {\n+                wProcessorArchitecture: u16,\n+                wReserved: u16,\n+                dwPageSize: u32,\n+                lpMinimumApplicationAddress: *mut u8,\n+                lpMaximumApplicationAddress: *mut u8,\n+                dwActiveProcessorMask: *mut u8,\n+                dwNumberOfProcessors: u32,\n+                dwProcessorType: u32,\n+                dwAllocationGranularity: u32,\n+                wProcessorLevel: u16,\n+                wProcessorRevision: u16,\n+            }\n+            extern \"system\" {\n+                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+            }\n+            let res = unsafe {\n+                let mut sysinfo = crate::mem::zeroed();\n+                GetSystemInfo(&mut sysinfo);\n+                sysinfo.dwNumberOfProcessors as usize\n+            };\n+            match res {\n+                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n+            }\n+        }\n+    } else if #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"cloudabi\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+    ))] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n+                -1 => Err(io::Error::last_os_error()),\n+                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n+            }\n+        }\n+    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+\n+            unsafe {\n+                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+            }\n+\n+            // Fallback approach in case of errors or no hardware threads.\n+            if cpus < 1 {\n+                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+                let res = unsafe {\n+                    libc::sysctl(\n+                        mib.as_mut_ptr(),\n+                        2,\n+                        &mut cpus as *mut _ as *mut _,\n+                        &mut cpus_size as *mut _ as *mut _,\n+                        ptr::null_mut(),\n+                        0,\n+                    )\n+                };\n+\n+                // Handle errors if any.\n+                if res == -1 {\n+                    return Err(io::Error::last_os_error());\n+                } else if cpus == 0 {\n+                    return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+                }\n+            }\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        }\n+    } else if #[cfg(target_os = \"openbsd\")] {\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+            let res = unsafe {\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                )\n+            };\n+\n+            // Handle errors if any.\n+            if res == -1 {\n+                return Err(io::Error::last_os_error());\n+            } else if cpus == 0 {\n+                return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+            }\n+\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        }\n+    } else {\n+        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n+        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n+            Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"))\n+        }\n+    }\n+}"}, {"sha": "45c10266ba2551a513f830292eb6a821da39d03d", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=c38ddb8040edce1b05bc09a0e8439472e9f67623", "patch": "@@ -175,9 +175,15 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+mod available_concurrency;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+pub use available_concurrency::available_concurrency;\n+\n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n // type is accessed via platform-specific API calls and is slow, while the fast"}, {"sha": "7e9bd50f5566e04514699476ca85025bdeaae5fa", "filename": "library/test/src/helpers/concurrency.rs", "status": "modified", "additions": 2, "deletions": 101, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs?ref=c38ddb8040edce1b05bc09a0e8439472e9f67623", "patch": "@@ -1,6 +1,7 @@\n //! Helper module which helps to determine amount of threads to be used\n //! during tests execution.\n use std::env;\n+use std::thread;\n \n #[allow(deprecated)]\n pub fn get_concurrency() -> usize {\n@@ -12,106 +13,6 @@ pub fn get_concurrency() -> usize {\n                 _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s),\n             }\n         }\n-        Err(..) => num_cpus(),\n-    }\n-}\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(windows)] {\n-        #[allow(nonstandard_style)]\n-        fn num_cpus() -> usize {\n-            #[repr(C)]\n-            struct SYSTEM_INFO {\n-                wProcessorArchitecture: u16,\n-                wReserved: u16,\n-                dwPageSize: u32,\n-                lpMinimumApplicationAddress: *mut u8,\n-                lpMaximumApplicationAddress: *mut u8,\n-                dwActiveProcessorMask: *mut u8,\n-                dwNumberOfProcessors: u32,\n-                dwProcessorType: u32,\n-                dwAllocationGranularity: u32,\n-                wProcessorLevel: u16,\n-                wProcessorRevision: u16,\n-            }\n-            extern \"system\" {\n-                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n-            }\n-            unsafe {\n-                let mut sysinfo = std::mem::zeroed();\n-                GetSystemInfo(&mut sysinfo);\n-                sysinfo.dwNumberOfProcessors as usize\n-            }\n-        }\n-    } else if #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"cloudabi\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"macos\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-    ))] {\n-        fn num_cpus() -> usize {\n-            unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n-        }\n-    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n-        fn num_cpus() -> usize {\n-            use std::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = std::mem::size_of_val(&cpus);\n-\n-            unsafe {\n-                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n-            }\n-            if cpus < 1 {\n-                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-                unsafe {\n-                    libc::sysctl(\n-                        mib.as_mut_ptr(),\n-                        2,\n-                        &mut cpus as *mut _ as *mut _,\n-                        &mut cpus_size as *mut _ as *mut _,\n-                        ptr::null_mut(),\n-                        0,\n-                    );\n-                }\n-                if cpus < 1 {\n-                    cpus = 1;\n-                }\n-            }\n-            cpus as usize\n-        }\n-    } else if #[cfg(target_os = \"openbsd\")] {\n-        fn num_cpus() -> usize {\n-            use std::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = std::mem::size_of_val(&cpus);\n-            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-\n-            unsafe {\n-                libc::sysctl(\n-                    mib.as_mut_ptr(),\n-                    2,\n-                    &mut cpus as *mut _ as *mut _,\n-                    &mut cpus_size as *mut _ as *mut _,\n-                    ptr::null_mut(),\n-                    0,\n-                );\n-            }\n-            if cpus < 1 {\n-                cpus = 1;\n-            }\n-            cpus as usize\n-        }\n-    } else {\n-        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n-        fn num_cpus() -> usize {\n-            1\n-        }\n+        Err(..) => thread::available_concurrency().map(|n| n.get()).unwrap_or(1),\n     }\n }"}, {"sha": "9c5bb8957b5480cc02407b52e9db7c9e8cd23f99", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38ddb8040edce1b05bc09a0e8439472e9f67623/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=c38ddb8040edce1b05bc09a0e8439472e9f67623", "patch": "@@ -24,6 +24,7 @@\n #![feature(rustc_private)]\n #![feature(nll)]\n #![feature(bool_to_option)]\n+#![feature(available_concurrency)]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]"}]}