{"sha": "9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "node_id": "C_kwDOAAsO6NoAKDk2MzUzMTJiZDBhZjdiNWI3ZDRmZGIyMmMzMGNjYWU3NTU4ZjYyZGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T09:19:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T09:19:01Z"}, "message": "Auto merge of #2845 - oli-obk:rustup, r=oli-obk\n\nRustup", "tree": {"sha": "18006351134b7daa596398510c7bd50cc0f3503d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18006351134b7daa596398510c7bd50cc0f3503d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "html_url": "https://github.com/rust-lang/rust/commit/9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd53a43a867da489f877479161442e87a951af73", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd53a43a867da489f877479161442e87a951af73", "html_url": "https://github.com/rust-lang/rust/commit/cd53a43a867da489f877479161442e87a951af73"}, {"sha": "b1e74f4fafa763801bb64c8f3a431beba9cd6760", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e74f4fafa763801bb64c8f3a431beba9cd6760", "html_url": "https://github.com/rust-lang/rust/commit/b1e74f4fafa763801bb64c8f3a431beba9cd6760"}], "stats": {"total": 219, "additions": 174, "deletions": 45}, "files": [{"sha": "640a953dac9cbc9c4a187719bcd0302f68920f89", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -301,18 +301,22 @@ environment variable. We first document the most relevant and most commonly used\n * `-Zmiri-disable-isolation` disables host isolation.  As a consequence,\n   the program has access to host resources such as environment variables, file\n   systems, and randomness.\n+* `-Zmiri-disable-leak-backtraces` disables backtraces reports for memory leaks. By default, a\n+  backtrace is captured for every allocation when it is created, just in case it leaks. This incurs\n+  some memory overhead to store data that is almost never used. This flag is implied by\n+  `-Zmiri-ignore-leaks`.\n+* `-Zmiri-env-forward=<var>` forwards the `var` environment variable to the interpreted program. Can\n+  be used multiple times to forward several variables. Execution will still be deterministic if the\n+  value of forwarded variables stays the same. Has no effect if `-Zmiri-disable-isolation` is set.\n+* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n+  remaining threads to exist when the main thread exits.\n * `-Zmiri-isolation-error=<action>` configures Miri's response to operations\n   requiring host access while isolation is enabled. `abort`, `hide`, `warn`,\n   and `warn-nobacktrace` are the supported actions. The default is to `abort`,\n   which halts the machine. Some (but not all) operations also support continuing\n   execution with a \"permission denied\" error being returned to the program.\n   `warn` prints a full backtrace when that happens; `warn-nobacktrace` is less\n   verbose. `hide` hides the warning entirely.\n-* `-Zmiri-env-forward=<var>` forwards the `var` environment variable to the interpreted program. Can\n-  be used multiple times to forward several variables. Execution will still be deterministic if the\n-  value of forwarded variables stays the same. Has no effect if `-Zmiri-disable-isolation` is set.\n-* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n-  remaining threads to exist when the main thread exits.\n * `-Zmiri-num-cpus` states the number of available CPUs to be reported by miri. By default, the\n   number of available CPUs is `1`. Note that this flag does not affect how miri handles threads in\n   any way."}, {"sha": "6e0092308fa3b87501747e1cdc9bad4b66aac9c9", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1 +1 @@\n-71ef9ecbdedb67c32f074884f503f8e582855c2f\n+53ac4f8e2fc15e49ef3a04f98622a9b9db755fd4"}, {"sha": "e4ca40570b7fe024905a98baa75b83a73ebb46e5", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -359,6 +359,8 @@ fn main() {\n                 isolation_enabled = Some(false);\n             }\n             miri_config.isolated_op = miri::IsolatedOp::Allow;\n+        } else if arg == \"-Zmiri-disable-leak-backtraces\" {\n+            miri_config.collect_leak_backtraces = false;\n         } else if arg == \"-Zmiri-disable-weak-memory-emulation\" {\n             miri_config.weak_memory_emulation = false;\n         } else if arg == \"-Zmiri-track-weak-memory-loads\" {\n@@ -385,6 +387,7 @@ fn main() {\n             };\n         } else if arg == \"-Zmiri-ignore-leaks\" {\n             miri_config.ignore_leaks = true;\n+            miri_config.collect_leak_backtraces = false;\n         } else if arg == \"-Zmiri-panic-on-unsupported\" {\n             miri_config.panic_on_unsupported = true;\n         } else if arg == \"-Zmiri-tag-raw-pointers\" {"}, {"sha": "ffc49eedb5a982091ec539be176f9ac822cb4769", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -352,7 +352,7 @@ pub enum AllocState {\n     TreeBorrows(Box<RefCell<tree_borrows::AllocState>>),\n }\n \n-impl machine::AllocExtra {\n+impl machine::AllocExtra<'_> {\n     #[track_caller]\n     pub fn borrow_tracker_sb(&self) -> &RefCell<stacked_borrows::AllocState> {\n         match self.borrow_tracker {"}, {"sha": "7a726be00da4e0222c14074598b09103bde53743", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -105,7 +105,7 @@ pub enum NonHaltingDiagnostic {\n }\n \n /// Level of Miri specific diagnostics\n-enum DiagLevel {\n+pub enum DiagLevel {\n     Error,\n     Warning,\n     Note,\n@@ -114,7 +114,7 @@ enum DiagLevel {\n /// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n /// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n /// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n-fn prune_stacktrace<'tcx>(\n+pub fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n     machine: &MiriMachine<'_, 'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n@@ -338,12 +338,45 @@ pub fn report_error<'tcx, 'mir>(\n     None\n }\n \n+pub fn report_leaks<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n+    leaks: Vec<(AllocId, MemoryKind<MiriMemoryKind>, Allocation<Provenance, AllocExtra<'tcx>>)>,\n+) {\n+    let mut any_pruned = false;\n+    for (id, kind, mut alloc) in leaks {\n+        let Some(backtrace) = alloc.extra.backtrace.take() else {\n+            continue;\n+        };\n+        let (backtrace, pruned) = prune_stacktrace(backtrace, &ecx.machine);\n+        any_pruned |= pruned;\n+        report_msg(\n+            DiagLevel::Error,\n+            &format!(\n+                \"memory leaked: {id:?} ({}, size: {:?}, align: {:?}), allocated here:\",\n+                kind,\n+                alloc.size().bytes(),\n+                alloc.align.bytes()\n+            ),\n+            vec![],\n+            vec![],\n+            vec![],\n+            &backtrace,\n+            &ecx.machine,\n+        );\n+    }\n+    if any_pruned {\n+        ecx.tcx.sess.diagnostic().note_without_error(\n+            \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n+        );\n+    }\n+}\n+\n /// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'tcx>(\n+pub fn report_msg<'tcx>(\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,"}, {"sha": "43d8f221ce3d20e631de05ff1756fac7acc45800", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -10,6 +10,7 @@ use std::thread;\n use log::info;\n \n use crate::borrow_tracker::RetagFields;\n+use crate::diagnostics::report_leaks;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n@@ -145,6 +146,8 @@ pub struct MiriConfig {\n     pub num_cpus: u32,\n     /// Requires Miri to emulate pages of a certain size\n     pub page_size: Option<u64>,\n+    /// Whether to collect a backtrace when each allocation is created, just in case it leaks.\n+    pub collect_leak_backtraces: bool,\n }\n \n impl Default for MiriConfig {\n@@ -179,6 +182,7 @@ impl Default for MiriConfig {\n             gc_interval: 10_000,\n             num_cpus: 1,\n             page_size: None,\n+            collect_leak_backtraces: true,\n         }\n     }\n }\n@@ -457,10 +461,17 @@ pub fn eval_entry<'tcx>(\n         }\n         // Check for memory leaks.\n         info!(\"Additional static roots: {:?}\", ecx.machine.static_roots);\n-        let leaks = ecx.leak_report(&ecx.machine.static_roots);\n-        if leaks != 0 {\n-            tcx.sess.err(\"the evaluated program leaked memory\");\n-            tcx.sess.note_without_error(\"pass `-Zmiri-ignore-leaks` to disable this check\");\n+        let leaks = ecx.find_leaked_allocations(&ecx.machine.static_roots);\n+        if !leaks.is_empty() {\n+            report_leaks(&ecx, leaks);\n+            let leak_message = \"the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\";\n+            if ecx.machine.collect_leak_backtraces {\n+                // If we are collecting leak backtraces, each leak is a distinct error diagnostic.\n+                tcx.sess.note_without_error(leak_message);\n+            } else {\n+                // If we do not have backtraces, we just report an error without any span.\n+                tcx.sess.err(leak_message);\n+            };\n             // Ignore the provided return code - let the reported error\n             // determine the return code.\n             return None;"}, {"sha": "21c5a9c1b7029f56198fa38339d499ab5a682cae", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -259,20 +259,25 @@ impl ProvenanceExtra {\n \n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n-pub struct AllocExtra {\n+pub struct AllocExtra<'tcx> {\n     /// Global state of the borrow tracker, if enabled.\n     pub borrow_tracker: Option<borrow_tracker::AllocState>,\n-    /// Data race detection via the use of a vector-clock,\n-    ///  this is only added if it is enabled.\n+    /// Data race detection via the use of a vector-clock.\n+    /// This is only added if it is enabled.\n     pub data_race: Option<data_race::AllocState>,\n-    /// Weak memory emulation via the use of store buffers,\n-    ///  this is only added if it is enabled.\n+    /// Weak memory emulation via the use of store buffers.\n+    /// This is only added if it is enabled.\n     pub weak_memory: Option<weak_memory::AllocState>,\n+    /// A backtrace to where this allocation was allocated.\n+    /// As this is recorded for leak reports, it only exists\n+    /// if this allocation is leakable. The backtrace is not\n+    /// pruned yet; that should be done before printing it.\n+    pub backtrace: Option<Vec<FrameInfo<'tcx>>>,\n }\n \n-impl VisitTags for AllocExtra {\n+impl VisitTags for AllocExtra<'_> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n-        let AllocExtra { borrow_tracker, data_race, weak_memory } = self;\n+        let AllocExtra { borrow_tracker, data_race, weak_memory, backtrace: _ } = self;\n \n         borrow_tracker.visit_tags(visit);\n         data_race.visit_tags(visit);\n@@ -473,12 +478,17 @@ pub struct MiriMachine<'mir, 'tcx> {\n     pub(crate) gc_interval: u32,\n     /// The number of blocks that passed since the last BorTag GC pass.\n     pub(crate) since_gc: u32,\n+\n     /// The number of CPUs to be reported by miri.\n     pub(crate) num_cpus: u32,\n+\n     /// Determines Miri's page size and associated values\n     pub(crate) page_size: u64,\n     pub(crate) stack_addr: u64,\n     pub(crate) stack_size: u64,\n+\n+    /// Whether to collect a backtrace when each allocation is created, just in case it leaks.\n+    pub(crate) collect_leak_backtraces: bool,\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n@@ -587,6 +597,7 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             page_size,\n             stack_addr,\n             stack_size,\n+            collect_leak_backtraces: config.collect_leak_backtraces,\n         }\n     }\n \n@@ -734,6 +745,7 @@ impl VisitTags for MiriMachine<'_, '_> {\n             page_size: _,\n             stack_addr: _,\n             stack_size: _,\n+            collect_leak_backtraces: _,\n         } = self;\n \n         threads.visit_tags(visit);\n@@ -779,7 +791,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type ExtraFnVal = Dlsym;\n \n     type FrameExtra = FrameExtra<'tcx>;\n-    type AllocExtra = AllocExtra;\n+    type AllocExtra = AllocExtra<'tcx>;\n \n     type Provenance = Provenance;\n     type ProvenanceExtra = ProvenanceExtra;\n@@ -973,9 +985,24 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n             )\n         });\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n+\n+        // If an allocation is leaked, we want to report a backtrace to indicate where it was\n+        // allocated. We don't need to record a backtrace for allocations which are allowed to\n+        // leak.\n+        let backtrace = if kind.may_leak() || !ecx.machine.collect_leak_backtraces {\n+            None\n+        } else {\n+            Some(ecx.generate_stacktrace())\n+        };\n+\n         let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n-            AllocExtra { borrow_tracker, data_race: race_alloc, weak_memory: buffer_alloc },\n+            AllocExtra {\n+                borrow_tracker,\n+                data_race: race_alloc,\n+                weak_memory: buffer_alloc,\n+                backtrace,\n+            },\n             |ptr| ecx.global_base_pointer(ptr),\n         )?;\n         Ok(Cow::Owned(alloc))\n@@ -1055,7 +1082,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_read(\n         _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n-        alloc_extra: &AllocExtra,\n+        alloc_extra: &AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1075,7 +1102,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_write(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n@@ -1095,7 +1122,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn before_memory_deallocation(\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n-        alloc_extra: &mut AllocExtra,\n+        alloc_extra: &mut AllocExtra<'tcx>,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {"}, {"sha": "cefdcc2b5b83d051882ba0b0210952cedc6ccbd9", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -125,7 +125,7 @@ impl VisitTags for Operand<Provenance> {\n     }\n }\n \n-impl VisitTags for Allocation<Provenance, AllocExtra> {\n+impl VisitTags for Allocation<Provenance, AllocExtra<'_>> {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         for prov in self.provenance().provenances() {\n             prov.visit_tags(visit);"}, {"sha": "cbeb163b56c317c7f4167b2adba5a0b8810d68aa", "filename": "src/tools/miri/tests/fail/memleak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n \n fn main() {"}, {"sha": "6d9b664c8f48338d081accc6ad75bf36a44b3b5e", "filename": "src/tools/miri/tests/fail/memleak.stderr", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak.stderr?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1,10 +1,23 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 4, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 4, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<i32>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak.rs:LL:CC\n+   |\n+LL |     std::mem::forget(Box::new(42));\n+   |                      ^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "24d4a02df712ceb5d339d5a2c29a58f9fa368862", "filename": "src/tools/miri/tests/fail/memleak_no_backtrace.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -0,0 +1,7 @@\n+//@compile-flags: -Zmiri-disable-leak-backtraces\n+//@error-pattern: the evaluated program leaked memory\n+//@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n+\n+fn main() {\n+    std::mem::forget(Box::new(42));\n+}"}, {"sha": "f44e6ce07977917aaafe306614c3662caa734f16", "filename": "src/tools/miri/tests/fail/memleak_no_backtrace.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_no_backtrace.stderr?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -0,0 +1,4 @@\n+error: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n+\n+error: aborting due to previous error\n+"}, {"sha": "0e1146cf4ad93755e873adc3c8bfd60dff6f121e", "filename": "src/tools/miri/tests/fail/memleak_rc.32bit.stderr", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.32bit.stderr?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1,10 +1,24 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 16, align: 4) {\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 16, align: 4), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "4979588f370ff5f53c595478ce75d9ff4b66f886", "filename": "src/tools/miri/tests/fail/memleak_rc.64bit.stderr", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.64bit.stderr?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1,11 +1,24 @@\n-The following memory was leaked: ALLOC (Rust heap, size: 32, align: 8) {\n-$stripped$\n-$stripped$\n-}\n+error: memory leaked: ALLOC (Rust heap, size: 32, align: 8), allocated here:\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_alloc(layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: inside `std::alloc::alloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::alloc::Global::alloc_impl` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::allocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::exchange_malloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::boxed::Box::<std::rc::RcBox<std::cell::RefCell<std::option::Option<Dummy>>>>::new` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n+   = note: inside `std::rc::Rc::<std::cell::RefCell<std::option::Option<Dummy>>>::new` at RUSTLIB/alloc/src/rc.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/memleak_rc.rs:LL:CC\n+   |\n+LL |     let x = Dummy(Rc::new(RefCell::new(None)));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the evaluated program leaked memory\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n \n-note: pass `-Zmiri-ignore-leaks` to disable this check\n+note: the evaluated program leaked memory, pass `-Zmiri-ignore-leaks` to disable this check\n \n error: aborting due to previous error\n "}, {"sha": "cf4671912ada8057c2fbc50f7e7bc3cef265e498", "filename": "src/tools/miri/tests/fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9635312bd0af7b5b7d4fdb22c30ccae7558f62da/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fmemleak_rc.rs?ref=9635312bd0af7b5b7d4fdb22c30ccae7558f62da", "patch": "@@ -1,4 +1,4 @@\n-//@error-pattern: the evaluated program leaked memory\n+//@error-pattern: memory leaked\n //@stderr-per-bitwidth\n //@normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n "}]}