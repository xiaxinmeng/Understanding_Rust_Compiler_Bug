{"sha": "cdeb4b0d258c19f57ee6fb089126656e18324367", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZWI0YjBkMjU4YzE5ZjU3ZWU2ZmIwODkxMjY2NTZlMTgzMjQzNjc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-06T07:25:35Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:32Z"}, "message": "rustc: encode scalar pairs in layout ABI.", "tree": {"sha": "39b1e45990bf63df626bebe3c020360f2df5356c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39b1e45990bf63df626bebe3c020360f2df5356c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdeb4b0d258c19f57ee6fb089126656e18324367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeb4b0d258c19f57ee6fb089126656e18324367", "html_url": "https://github.com/rust-lang/rust/commit/cdeb4b0d258c19f57ee6fb089126656e18324367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdeb4b0d258c19f57ee6fb089126656e18324367/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2", "html_url": "https://github.com/rust-lang/rust/commit/f1b7cd99254dd11ff7370fe423cca6fd8046f7d2"}], "stats": {"total": 403, "additions": 266, "deletions": 137}, "files": [{"sha": "21ba7995332b79a70438d7c554b940726838672d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 95, "deletions": 43, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -757,6 +757,7 @@ impl FieldPlacement {\n pub enum Abi {\n     Uninhabited,\n     Scalar(Scalar),\n+    ScalarPair(Scalar, Scalar),\n     Vector,\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n@@ -769,15 +770,21 @@ impl Abi {\n     /// Returns true if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n-            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector => false,\n+            Abi::Uninhabited |\n+            Abi::Scalar(_) |\n+            Abi::ScalarPair(..) |\n+            Abi::Vector => false,\n             Abi::Aggregate { sized, .. } => !sized\n         }\n     }\n \n     /// Returns true if the fields of the layout are packed.\n     pub fn is_packed(&self) -> bool {\n         match *self {\n-            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector => false,\n+            Abi::Uninhabited |\n+            Abi::Scalar(_) |\n+            Abi::ScalarPair(..) |\n+            Abi::Vector => false,\n             Abi::Aggregate { packed, .. } => packed\n         }\n     }\n@@ -905,13 +912,32 @@ impl<'a, 'tcx> CachedLayout {\n                         -> Result<&'tcx Self, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n-        let scalar = |value: Primitive| {\n+        let scalar_unit = |value: Primitive| {\n             let bits = value.size(dl).bits();\n             assert!(bits <= 128);\n-            tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+            Scalar {\n                 value,\n                 valid_range: 0..=(!0 >> (128 - bits))\n-            }))\n+            }\n+        };\n+        let scalar = |value: Primitive| {\n+            tcx.intern_layout(CachedLayout::scalar(cx, scalar_unit(value)))\n+        };\n+        let scalar_pair = |a: Scalar, b: Scalar| {\n+            let align = a.value.align(dl).max(b.value.align(dl)).max(dl.aggregate_align);\n+            let b_offset = a.value.size(dl).abi_align(b.value.align(dl));\n+            let size = (b_offset + b.value.size(dl)).abi_align(align);\n+            CachedLayout {\n+                variants: Variants::Single { index: 0 },\n+                fields: FieldPlacement::Arbitrary {\n+                    offsets: vec![Size::from_bytes(0), b_offset],\n+                    memory_index: vec![0, 1]\n+                },\n+                abi: Abi::ScalarPair(a, b),\n+                align,\n+                primitive_align: align,\n+                size\n+            }\n         };\n \n         #[derive(Copy, Clone, Debug)]\n@@ -1049,19 +1075,54 @@ impl<'a, 'tcx> CachedLayout {\n                 memory_index = inverse_memory_index;\n             }\n \n+            let size = min_size.abi_align(align);\n+            let mut abi = Abi::Aggregate {\n+                sized,\n+                packed\n+            };\n+\n+            // Look for a scalar pair, as an ABI optimization.\n+            // FIXME(eddyb) ignore extra ZST fields and field ordering.\n+            if sized && !packed && fields.len() == 2 {\n+                match (&fields[0].abi, &fields[1].abi) {\n+                    (&Abi::Scalar(ref a), &Abi::Scalar(ref b)) => {\n+                        let pair = scalar_pair(a.clone(), b.clone());\n+                        let pair_offsets = match pair.fields {\n+                            FieldPlacement::Arbitrary {\n+                                ref offsets,\n+                                ref memory_index\n+                            } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n+                            }\n+                            _ => bug!()\n+                        };\n+                        if offsets[0] == pair_offsets[0] &&\n+                           offsets[1] == pair_offsets[1] &&\n+                           memory_index[0] == 0 &&\n+                           memory_index[1] == 1 &&\n+                           align == pair.align &&\n+                           primitive_align == pair.primitive_align &&\n+                           size == pair.size {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n             Ok(CachedLayout {\n                 variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets,\n                     memory_index\n                 },\n-                abi: Abi::Aggregate {\n-                    sized,\n-                    packed\n-                },\n+                abi,\n                 align,\n                 primitive_align,\n-                size: min_size.abi_align(align)\n+                size\n             })\n         };\n         let univariant = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n@@ -1070,45 +1131,34 @@ impl<'a, 'tcx> CachedLayout {\n         assert!(!ty.has_infer_types());\n \n         let ptr_layout = |pointee: Ty<'tcx>| {\n+            let mut data_ptr = scalar_unit(Pointer);\n+            if !ty.is_unsafe_ptr() {\n+                data_ptr.valid_range.start = 1;\n+            }\n+\n             let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n             if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n-                let non_zero = !ty.is_unsafe_ptr();\n-                let bits = Pointer.size(dl).bits();\n-                return Ok(tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n-                    value: Pointer,\n-                    valid_range: (non_zero as u128)..=(!0 >> (128 - bits))\n-                })));\n+                return Ok(tcx.intern_layout(CachedLayout::scalar(cx, data_ptr)));\n             }\n \n             let unsized_part = tcx.struct_tail(pointee);\n             let metadata = match unsized_part.sty {\n-                ty::TyForeign(..) => return Ok(scalar(Pointer)),\n+                ty::TyForeign(..) => {\n+                    return Ok(tcx.intern_layout(CachedLayout::scalar(cx, data_ptr)));\n+                }\n                 ty::TySlice(_) | ty::TyStr => {\n-                    Int(dl.ptr_sized_integer(), false)\n+                    scalar_unit(Int(dl.ptr_sized_integer(), false))\n+                }\n+                ty::TyDynamic(..) => {\n+                    let mut vtable = scalar_unit(Pointer);\n+                    vtable.valid_range.start = 1;\n+                    vtable\n                 }\n-                ty::TyDynamic(..) => Pointer,\n                 _ => return Err(LayoutError::Unknown(unsized_part))\n             };\n \n             // Effectively a (ptr, meta) tuple.\n-            let align = Pointer.align(dl).max(metadata.align(dl));\n-            let meta_offset = Pointer.size(dl);\n-            assert_eq!(meta_offset, meta_offset.abi_align(metadata.align(dl)));\n-            let fields = FieldPlacement::Arbitrary {\n-                offsets: vec![Size::from_bytes(0), meta_offset],\n-                memory_index: vec![0, 1]\n-            };\n-            Ok(tcx.intern_layout(CachedLayout {\n-                variants: Variants::Single { index: 0 },\n-                fields,\n-                abi: Abi::Aggregate {\n-                    sized: true,\n-                    packed: false\n-                },\n-                align,\n-                primitive_align: align,\n-                size: (meta_offset + metadata.size(dl)).abi_align(align)\n-            }))\n+            Ok(tcx.intern_layout(scalar_pair(data_ptr, metadata)))\n         };\n \n         Ok(match ty.sty {\n@@ -1134,11 +1184,9 @@ impl<'a, 'tcx> CachedLayout {\n             ty::TyFloat(FloatTy::F32) => scalar(F32),\n             ty::TyFloat(FloatTy::F64) => scalar(F64),\n             ty::TyFnPtr(_) => {\n-                let bits = Pointer.size(dl).bits();\n-                tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n-                    value: Pointer,\n-                    valid_range: 1..=(!0 >> (128 - bits))\n-                }))\n+                let mut ptr = scalar_unit(Pointer);\n+                ptr.valid_range.start = 1;\n+                tcx.intern_layout(CachedLayout::scalar(cx, ptr))\n             }\n \n             // The never type.\n@@ -2194,7 +2242,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n             Abi::Uninhabited => true,\n-            Abi::Scalar(_) => false,\n+            Abi::Scalar(_) | Abi::ScalarPair(..) => false,\n             Abi::Vector => self.size.bytes() == 0,\n             Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n         }\n@@ -2347,6 +2395,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n             Scalar(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n+            ScalarPair(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n             Vector => {}\n             Aggregate { packed, sized } => {\n                 packed.hash_stable(hcx, hasher);"}, {"sha": "d69103bbb529d829c4fc2c8c54afc80bbecbf12a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -311,6 +311,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n             layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n             layout::Abi::Vector => false,\n+            layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => true\n         }\n     }\n@@ -340,6 +341,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 })\n             }\n \n+            layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => {\n                 let mut total = Size::from_bytes(0);\n                 let mut result = None;\n@@ -745,10 +747,13 @@ impl<'a, 'tcx> FnType<'tcx> {\n                         arg.attrs.set(ArgAttribute::NonNull);\n                     }\n                 }\n-                _ => {}\n+                _ => {\n+                    // Nothing to do for non-pointer types.\n+                    return;\n+                }\n             }\n \n-            if let Some(pointee) = arg.layout.pointee_info(ccx) {\n+            if let Some(pointee) = arg.layout.pointee_info_at(ccx, Size::from_bytes(0)) {\n                 if let Some(kind) = pointee.safe {\n                     arg.attrs.pointee_size = pointee.size;\n                     arg.attrs.pointee_align = Some(pointee.align);"}, {"sha": "eeb69276500f5ddde32e998feab083ce4fbe1340", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -88,6 +88,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 }\n             }\n \n+            layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => {\n                 match layout.variants {\n                     layout::Variants::Single { .. } => {"}, {"sha": "473c00120a740c6b2d3e3e4068a975f36c373ce1", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -18,6 +18,7 @@ pub fn compute_abi_info(fty: &mut FnType) {\n     let fixup = |a: &mut ArgType| {\n         match a.layout.abi {\n             layout::Abi::Uninhabited => {}\n+            layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => {\n                 match a.layout.size.bits() {\n                     8 => a.cast_to(Reg::i8()),"}, {"sha": "8a2c1ed2dc2f2931e37847eef8170f8c322e5be8", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -232,16 +232,9 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n }\n \n pub fn C_fat_ptr(cx: &CrateContext, ptr: ValueRef, meta: ValueRef) -> ValueRef {\n-    let empty = C_array(Type::i8(cx), &[]);\n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n     assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-    C_struct(cx, &[\n-        empty,\n-        ptr,\n-        empty,\n-        meta,\n-        empty\n-    ], false)\n+    C_struct(cx, &[ptr, meta], false)\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {"}, {"sha": "b2bb605d01b462cee3d90c05e89a353a9d7af540", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -31,7 +31,7 @@ use rustc::middle::trans::Stats;\n use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n+use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_trans_utils;\n@@ -103,7 +103,7 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n \n     lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n     scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    pointee_infos: RefCell<FxHashMap<Ty<'tcx>, Option<PointeeInfo>>>,\n+    pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     isize_ty: Type,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n@@ -516,7 +516,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().scalar_lltypes\n     }\n \n-    pub fn pointee_infos<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, Option<PointeeInfo>>> {\n+    pub fn pointee_infos<'a>(&'a self)\n+                             -> &'a RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>> {\n         &self.local().pointee_infos\n     }\n "}, {"sha": "3129ed028d4d1005e94d39dc37304f33dcd9a888", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -35,7 +35,7 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n         if layout.is_llvm_immediate() {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-        } else if layout.is_llvm_scalar_pair(mircx.ccx) {\n+        } else if layout.is_llvm_scalar_pair() {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n@@ -146,7 +146,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n                         let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n                         let layout = self.cx.ccx.layout_of(ty);\n-                        if layout.is_llvm_scalar_pair(self.cx.ccx) {\n+                        if layout.is_llvm_scalar_pair() {\n                             return;\n                         }\n                     }"}, {"sha": "318e36dc71a4d2d3793c726f53639ec3c489d691", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -117,7 +117,12 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n-        const_get_elt(self.llval, ccx.layout_of(self.ty).llvm_field_index(i))\n+        let layout = ccx.layout_of(self.ty);\n+        if let layout::Abi::ScalarPair(..) = layout.abi {\n+            const_get_elt(self.llval, i as u64)\n+        } else {\n+            const_get_elt(self.llval, layout.llvm_field_index(i))\n+        }\n     }\n \n     fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n@@ -143,7 +148,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         let llty = layout.immediate_llvm_type(ccx);\n         let llvalty = val_ty(self.llval);\n \n-        let val = if llty == llvalty && layout.is_llvm_scalar_pair(ccx) {\n+        let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n             let (a, b) = self.get_pair(ccx);\n             OperandValue::Pair(a, b)\n         } else if llty == llvalty && layout.is_llvm_immediate() {\n@@ -1174,6 +1179,14 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 -> Const<'tcx> {\n     assert_eq!(vals.len(), layout.fields.count());\n \n+    if let layout::Abi::ScalarPair(..) = layout.abi {\n+        assert_eq!(vals.len(), 2);\n+        return Const::new(C_struct(ccx, &[\n+            vals[0].llval,\n+            vals[1].llval,\n+        ], false), layout.ty);\n+    }\n+\n     // offset of current value\n     let mut offset = Size::from_bytes(0);\n     let mut cfields = Vec::new();"}, {"sha": "ff0b4482678203c623d6a0f2486b0fffa507ff24", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -175,10 +175,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 load\n             };\n             OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n-        } else if self.layout.is_llvm_scalar_pair(bcx.ccx) {\n-            OperandValue::Pair(\n-                self.project_field(bcx, 0).load(bcx).immediate(),\n-                self.project_field(bcx, 1).load(bcx).immediate())\n+        } else if self.layout.is_llvm_scalar_pair() {\n+            let load = |i| {\n+                let x = self.project_field(bcx, i).load(bcx).immediate();\n+                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                bcx.bitcast(x, self.layout.scalar_pair_element_llvm_type(bcx.ccx, i))\n+            };\n+            OperandValue::Pair(load(0), load(1))\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };\n@@ -190,17 +193,23 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n         let field = self.layout.field(ccx, ix);\n-        let offset = self.layout.fields.offset(ix).bytes();\n+        let offset = self.layout.fields.offset(ix);\n         let alignment = self.alignment | Alignment::from(self.layout);\n \n         let simple = || {\n+            // Unions and newtypes only use an offset of 0.\n+            let llval = if offset.bytes() == 0 {\n+                self.llval\n+            } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n+                // Offsets have to match either first or second field.\n+                assert_eq!(offset, a.value.size(ccx).abi_align(b.value.align(ccx)));\n+                bcx.struct_gep(self.llval, 1)\n+            } else {\n+                bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n+            };\n             LvalueRef {\n-                // Unions and newtypes only use an offset of 0.\n-                llval: if offset == 0 {\n-                    bcx.pointercast(self.llval, field.llvm_type(ccx).ptr_to())\n-                } else {\n-                    bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n-                },\n+                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                llval: bcx.pointercast(llval, field.llvm_type(ccx).ptr_to()),\n                 llextra: if ccx.shared().type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n@@ -249,7 +258,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = C_usize(ccx, offset);\n+        let unaligned_offset = C_usize(ccx, offset.bytes());\n \n         // Get the alignment of the field\n         let (_, align) = glue::size_and_align_of_dst(bcx, field.ty, meta);"}, {"sha": "b9d4148acf67e79ee53436dbaf68576aa65f75eb", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -123,11 +123,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n-            let elems = [a, b];\n-            for i in 0..2 {\n-                let elem = base::from_immediate(bcx, elems[i]);\n-                llpair = bcx.insert_value(llpair, elem, self.layout.llvm_field_index(i));\n-            }\n+            llpair = bcx.insert_value(llpair, a, 0);\n+            llpair = bcx.insert_value(llpair, b, 1);\n             llpair\n         } else {\n             self.immediate()\n@@ -139,18 +136,13 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                                          llval: ValueRef,\n                                          layout: TyLayout<'tcx>)\n                                          -> OperandRef<'tcx> {\n-        let val = if layout.is_llvm_scalar_pair(bcx.ccx) {\n+        let val = if layout.is_llvm_scalar_pair() {\n             debug!(\"Operand::from_immediate_or_packed_pair: unpacking {:?} @ {:?}\",\n                     llval, layout);\n \n             // Deconstruct the immediate aggregate.\n-            let a = bcx.extract_value(llval, layout.llvm_field_index(0));\n-            let a = base::to_immediate(bcx, a, layout.field(bcx.ccx, 0));\n-\n-            let b = bcx.extract_value(llval, layout.llvm_field_index(1));\n-            let b = base::to_immediate(bcx, b, layout.field(bcx.ccx, 1));\n-\n-            OperandValue::Pair(a, b)\n+            OperandValue::Pair(bcx.extract_value(llval, 0),\n+                               bcx.extract_value(llval, 1))\n         } else {\n             OperandValue::Immediate(llval)\n         };\n@@ -175,8 +167,11 @@ impl<'a, 'tcx> OperandValue {\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n-                    OperandValue::Immediate(x)\n-                        .store(bcx, dest.project_field(bcx, i));\n+                    let field = dest.project_field(bcx, i);\n+                    // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                    let x = bcx.bitcast(x, field.layout.immediate_llvm_type(bcx.ccx));\n+                    bcx.store(base::from_immediate(bcx, x),\n+                              field.llval, field.alignment.non_abi());\n                 }\n             }\n         }\n@@ -214,10 +209,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     match (o.val, &proj.elem) {\n                         (OperandValue::Pair(a, b),\n                          &mir::ProjectionElem::Field(ref f, ty)) => {\n+                            let layout = bcx.ccx.layout_of(self.monomorphize(&ty));\n                             let llval = [a, b][f.index()];\n+                            // HACK(eddyb) have to bitcast pointers\n+                            // until LLVM removes pointee types.\n+                            let llval = bcx.bitcast(llval,\n+                                layout.immediate_llvm_type(bcx.ccx));\n                             return OperandRef {\n                                 val: OperandValue::Immediate(llval),\n-                                layout: bcx.ccx.layout_of(self.monomorphize(&ty))\n+                                layout\n                             };\n                         }\n                         _ => {}"}, {"sha": "d62e2ac1552ec28aaf355fae84dee54c0136e037", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 96, "deletions": 39, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -29,6 +29,12 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n                                 layout.fields.count() as u64);\n         }\n+        layout::Abi::ScalarPair(..) => {\n+            return Type::struct_(ccx, &[\n+                layout.scalar_pair_element_llvm_type(ccx, 0),\n+                layout.scalar_pair_element_llvm_type(ccx, 1),\n+            ], false);\n+        }\n         layout::Abi::Uninhabited |\n         layout::Abi::Aggregate { .. } => {}\n     }\n@@ -174,12 +180,15 @@ pub struct PointeeInfo {\n \n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n-    fn is_llvm_scalar_pair<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> bool;\n+    fn is_llvm_scalar_pair<'a>(&self) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                                         index: usize) -> Type;\n     fn over_align(&self) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n-    fn pointee_info<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<PointeeInfo>;\n+    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+                           -> Option<PointeeInfo>;\n }\n \n impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n@@ -188,26 +197,18 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n             layout::Abi::Vector => true,\n-\n+            layout::Abi::ScalarPair(..) => false,\n             layout::Abi::Aggregate { .. } => self.is_zst()\n         }\n     }\n \n-    fn is_llvm_scalar_pair<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> bool {\n-        match self.fields {\n-            layout::FieldPlacement::Arbitrary { .. } => {\n-                // There must be only 2 fields.\n-                if self.fields.count() != 2 {\n-                    return false;\n-                }\n-\n-                // The two fields must be both scalars.\n-                match (&self.field(ccx, 0).abi, &self.field(ccx, 1).abi) {\n-                    (&layout::Abi::Scalar(_), &layout::Abi::Scalar(_)) => true,\n-                    _ => false\n-                }\n-            }\n-            _ => false\n+    fn is_llvm_scalar_pair<'a>(&self) -> bool {\n+        match self.abi {\n+            layout::Abi::ScalarPair(..) => true,\n+            layout::Abi::Uninhabited |\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector |\n+            layout::Abi::Aggregate { .. } => false\n         }\n     }\n \n@@ -248,7 +249,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         }\n                         _ => {\n                             // If we know the alignment, pick something better than i8.\n-                            if let Some(pointee) = self.pointee_info(ccx) {\n+                            if let Some(pointee) = self.pointee_info_at(ccx, Size::from_bytes(0)) {\n                                 Type::pointee_for_abi_align(ccx, pointee.align)\n                             } else {\n                                 Type::i8(ccx)\n@@ -310,6 +311,59 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         self.llvm_type(ccx)\n     }\n \n+    fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                                         index: usize) -> Type {\n+        // HACK(eddyb) special-case fat pointers until LLVM removes\n+        // pointee types, to avoid bitcasting every `OperandRef::deref`.\n+        match self.ty.sty {\n+            ty::TyRef(..) |\n+            ty::TyRawPtr(_) => {\n+                return self.field(ccx, index).llvm_type(ccx);\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                return self.field(ccx, index).llvm_type(ccx);\n+            }\n+            _ => {}\n+        }\n+\n+        let (a, b) = match self.abi {\n+            layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+            _ => bug!(\"TyLayout::scalar_pair_element_llty({:?}): not applicable\", self)\n+        };\n+        let scalar = [a, b][index];\n+\n+        // Make sure to return the same type `immediate_llvm_type` would,\n+        // to avoid dealing with two types and the associated conversions.\n+        // This means that `(bool, bool)` is represented as `{i1, i1}`,\n+        // both in memory and as an immediate, while `bool` is typically\n+        // `i8` in memory and only `i1` when immediate. While we need to\n+        // load/store `bool` as `i8` to avoid crippling LLVM optimizations,\n+        // `i1` in a LLVM aggregate is valid and mostly equivalent to `i8`.\n+        if scalar.is_bool() {\n+            return Type::i1(ccx);\n+        }\n+\n+        match scalar.value {\n+            layout::Int(i, _) => Type::from_integer(ccx, i),\n+            layout::F32 => Type::f32(ccx),\n+            layout::F64 => Type::f64(ccx),\n+            layout::Pointer => {\n+                // If we know the alignment, pick something better than i8.\n+                let offset = if index == 0 {\n+                    Size::from_bytes(0)\n+                } else {\n+                    a.value.size(ccx).abi_align(b.value.align(ccx))\n+                };\n+                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n+                    Type::pointee_for_abi_align(ccx, pointee.align)\n+                } else {\n+                    Type::i8(ccx)\n+                };\n+                pointee.ptr_to()\n+            }\n+        }\n+    }\n+\n     fn over_align(&self) -> Option<Align> {\n         if self.align != self.primitive_align {\n             Some(self.align)\n@@ -319,8 +373,12 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn llvm_field_index(&self, index: usize) -> u64 {\n-        if let layout::Abi::Scalar(_) = self.abi {\n-            bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self);\n+        match self.abi {\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::ScalarPair(..) => {\n+                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            }\n+            _ => {}\n         }\n         match self.fields {\n             layout::FieldPlacement::Union(_) => {\n@@ -337,20 +395,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn pointee_info<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<PointeeInfo> {\n-        // We only handle thin pointers here.\n-        match self.abi {\n-            layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {}\n-            _ => return None\n-        }\n-\n-        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&self.ty) {\n+    fn pointee_info_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>, offset: Size)\n+                           -> Option<PointeeInfo> {\n+        if let Some(&pointee) = ccx.pointee_infos().borrow().get(&(self.ty, offset)) {\n             return pointee;\n         }\n \n         let mut result = None;\n         match self.ty.sty {\n-            ty::TyRawPtr(mt) => {\n+            ty::TyRawPtr(mt) if offset.bytes() == 0 => {\n                 let (size, align) = ccx.size_and_align_of(mt.ty);\n                 result = Some(PointeeInfo {\n                     size,\n@@ -359,7 +412,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyRef(_, mt) => {\n+            ty::TyRef(_, mt) if offset.bytes() == 0 => {\n                 let (size, align) = ccx.size_and_align_of(mt.ty);\n \n                 let kind = match mt.mutbl {\n@@ -385,7 +438,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 });\n             }\n \n-            ty::TyAdt(def, _) if def.is_box() => {\n+            ty::TyAdt(def, _) if def.is_box() && offset.bytes() == 0 => {\n                 let (size, align) = ccx.size_and_align_of(self.ty.boxed_ty());\n                 result = Some(PointeeInfo {\n                     size,\n@@ -408,7 +461,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         // to work as long as we don't start using more\n                         // niches than just null (e.g. the first page\n                         // of the address space, or unaligned pointers).\n-                        if self.fields.offset(0).bytes() == 0 {\n+                        if self.fields.offset(0) == offset {\n                             Some(self.for_variant(ccx, dataful_variant))\n                         } else {\n                             None\n@@ -425,12 +478,16 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                 }\n \n                 if let Some(variant) = data_variant {\n+                    let ptr_end = offset + layout::Pointer.size(ccx);\n                     for i in 0..variant.fields.count() {\n-                        let field = variant.field(ccx, i);\n-                        if field.size == self.size {\n-                            // We found the pointer field, use its information.\n-                            result = field.pointee_info(ccx);\n-                            break;\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(ccx, i);\n+                            if ptr_end <= field_start + field.size {\n+                                // We found the right field, look inside it.\n+                                result = field.pointee_info_at(ccx, offset - field_start);\n+                                break;\n+                            }\n                         }\n                     }\n                 }\n@@ -447,7 +504,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             }\n         }\n \n-        ccx.pointee_infos().borrow_mut().insert(self.ty, result);\n+        ccx.pointee_infos().borrow_mut().insert((self.ty, offset), result);\n         result\n     }\n }"}, {"sha": "2b35d4547395a0d08b5ddab9aeb717ef511c0720", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -24,9 +24,9 @@ pub fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %0 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } undef, [0 x i8]* %x.0, 1\n-// CHECK: %1 = insertvalue { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %0, [[USIZE]] %x.1, 3\n-// CHECK: ret { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] } %1\n+// CHECK: %0 = insertvalue { [0 x i8]*, [[USIZE]] } undef, [0 x i8]* %x.0, 0\n+// CHECK: %1 = insertvalue { [0 x i8]*, [[USIZE]] } %0, [[USIZE]] %x.1, 1\n+// CHECK: ret { [0 x i8]*, [[USIZE]] } %1\n     { x }\n }\n "}, {"sha": "428cbdddb220976484de698075ef10b6e12f010d", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -133,7 +133,7 @@ pub fn trait_borrow(_: &Drop) {\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { [0 x i8], [0 x i16]*, [0 x i8], [[USIZE]], [0 x i8] } @return_slice([0 x i16]* noalias nonnull readonly %x.0, [[USIZE]] %x.1)\n+// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias nonnull readonly %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "64e842b026e2410fdd07307bae8dbb4473c2c6d9", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -54,9 +54,6 @@ pub struct PackedPair(u8, u32);\n // CHECK-LABEL: @pkd_pair\n #[no_mangle]\n pub fn pkd_pair(pair1: &mut PackedPair, pair2: &mut PackedPair) {\n-    // CHECK: [[V1:%[a-z0-9]+]] = load i8, i8* %{{.*}}, align 1\n-    // CHECK: [[V2:%[a-z0-9]+]] = load i32, i32* %{{.*}}, align 1\n-    // CHECK: store i8 [[V1]], i8* {{.*}}, align 1\n-    // CHECK: store i32 [[V2]], i32* {{.*}}, align 1\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 5, i32 1, i1 false)\n     *pair2 = *pair1;\n }"}, {"sha": "0c084131ea3f27f82d09239eb2868e8ae616f8bb", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdeb4b0d258c19f57ee6fb089126656e18324367/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=cdeb4b0d258c19f57ee6fb089126656e18324367", "patch": "@@ -24,9 +24,9 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = bitcast { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] }* %x to [0 x i8]**\n+// CHECK: [[X0:%[0-9]+]] = bitcast { [0 x i8]*, [[USIZE]] }* %x to [0 x i8]**\n // CHECK: store [0 x i8]* %s.0, [0 x i8]** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8], [0 x i8]*, [0 x i8], [[USIZE]], [0 x i8] }* %x, i32 0, i32 3\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 1\n // CHECK: store [[USIZE]] %s.1, [[USIZE]]* [[X1]]\n \n     let x = &*s;"}]}