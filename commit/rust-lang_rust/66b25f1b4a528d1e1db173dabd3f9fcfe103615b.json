{"sha": "66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YjI1ZjFiNGE1MjhkMWUxZGIxNzNkYWJkM2Y5ZmNmZTEwMzYxNWI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-07T13:48:52Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-02-07T13:48:52Z"}, "message": "Create rustfmt_config crate", "tree": {"sha": "e4e45e64947f1aeb034e064d26a28369dbe46cfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4e45e64947f1aeb034e064d26a28369dbe46cfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "html_url": "https://github.com/rust-lang/rust/commit/66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836", "html_url": "https://github.com/rust-lang/rust/commit/4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836"}], "stats": {"total": 1815, "additions": 1032, "deletions": 783}, "files": [{"sha": "c7e5c9d83158fd1cd0782548e8f06d425a28cfd2", "filename": "rustfmt-config/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2FCargo.toml?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+name = \"rustfmt-config\"\n+version = \"0.4.0\"\n+authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n+description = \"A library for configuring and customizing rustfmt\"\n+repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n+readme = \"README.md\"\n+license = \"Apache-2.0/MIT\"\n+categories = [\"development-tools\"]\n+\n+[dependencies]\n+rustc-ap-syntax = \"29.0.0\"\n+serde = \"1.0\"\n+serde_derive = \"1.0\"\n+serde_json = \"1.0\"\n+toml = \"0.4\"\n\\ No newline at end of file"}, {"sha": "51642570fdfda215c3ab5c2976cc590b22d76133", "filename": "rustfmt-config/src/config_type.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Fconfig_type.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,380 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use file_lines::FileLines;\n+use options::WidthHeuristics;\n+\n+/// Trait for types that can be used in `Config`.\n+pub trait ConfigType: Sized {\n+    /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n+    /// pipe-separated list of variants; for other types it returns \"<type>\".\n+    fn doc_hint() -> String;\n+}\n+\n+impl ConfigType for bool {\n+    fn doc_hint() -> String {\n+        String::from(\"<boolean>\")\n+    }\n+}\n+\n+impl ConfigType for usize {\n+    fn doc_hint() -> String {\n+        String::from(\"<unsigned integer>\")\n+    }\n+}\n+\n+impl ConfigType for isize {\n+    fn doc_hint() -> String {\n+        String::from(\"<signed integer>\")\n+    }\n+}\n+\n+impl ConfigType for String {\n+    fn doc_hint() -> String {\n+        String::from(\"<string>\")\n+    }\n+}\n+\n+impl ConfigType for FileLines {\n+    fn doc_hint() -> String {\n+        String::from(\"<json>\")\n+    }\n+}\n+\n+impl ConfigType for WidthHeuristics {\n+    fn doc_hint() -> String {\n+        String::new()\n+    }\n+}\n+\n+/// Check if we're in a nightly build.\n+///\n+/// The environment variable `CFG_RELEASE_CHANNEL` is set during the rustc bootstrap\n+/// to \"stable\", \"beta\", or \"nightly\" depending on what toolchain is being built.\n+/// If we are being built as part of the stable or beta toolchains, we want\n+/// to disable unstable configuration options.\n+///\n+/// If we're being built by cargo (e.g. `cargo +nightly install rustfmt-nightly`),\n+/// `CFG_RELEASE_CHANNEL` is not set. As we only support being built against the\n+/// nightly compiler when installed from crates.io, default to nightly mode.\n+macro_rules! is_nightly_channel {\n+    () => {\n+        option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\")\n+            .unwrap_or(true)\n+    };\n+}\n+\n+macro_rules! create_config {\n+    ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+        #[derive(Clone)]\n+        pub struct Config {\n+            // For each config item, we store a bool indicating whether it has\n+            // been accessed and the value, and a bool whether the option was\n+            // manually initialised, or taken from the default,\n+            $($i: (Cell<bool>, bool, $ty, bool)),+\n+        }\n+\n+        // Just like the Config struct but with each property wrapped\n+        // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n+        // specify all properties of `Config`.\n+        // We first parse into `PartialConfig`, then create a default `Config`\n+        // and overwrite the properties with corresponding values from `PartialConfig`.\n+        #[derive(Deserialize, Serialize, Clone)]\n+        pub struct PartialConfig {\n+            $(pub $i: Option<$ty>),+\n+        }\n+\n+        impl PartialConfig {\n+            pub fn to_toml(&self) -> Result<String, String> {\n+                // Non-user-facing options can't be specified in TOML\n+                let mut cloned = self.clone();\n+                cloned.file_lines = None;\n+                cloned.verbose = None;\n+                cloned.width_heuristics = None;\n+\n+                toml::to_string(&cloned)\n+                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n+            }\n+        }\n+\n+        // Macro hygiene won't allow us to make `set_$i()` methods on Config\n+        // for each item, so this struct is used to give the API to set values:\n+        // `config.get().option(false)`. It's pretty ugly. Consider replacing\n+        // with `config.set_option(false)` if we ever get a stable/usable\n+        // `concat_idents!()`.\n+        pub struct ConfigSetter<'a>(&'a mut Config);\n+\n+        impl<'a> ConfigSetter<'a> {\n+            $(\n+            pub fn $i(&mut self, value: $ty) {\n+                (self.0).$i.2 = value;\n+                if stringify!($i) == \"use_small_heuristics\" {\n+                    self.0.set_heuristics();\n+                }\n+            }\n+            )+\n+        }\n+\n+        // Query each option, returns true if the user set the option, false if\n+        // a default was used.\n+        pub struct ConfigWasSet<'a>(&'a Config);\n+\n+        impl<'a> ConfigWasSet<'a> {\n+            $(\n+            pub fn $i(&self) -> bool {\n+                (self.0).$i.1\n+            }\n+            )+\n+        }\n+\n+        impl Config {\n+            pub fn version_meets_requirement(&self, error_summary: &mut Summary) -> bool {\n+                if self.was_set().required_version() {\n+                    let version = env!(\"CARGO_PKG_VERSION\");\n+                    let required_version = self.required_version();\n+                    if version != required_version {\n+                        println!(\n+                            \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n+                            version,\n+                            required_version,\n+                        );\n+                        error_summary.add_formatting_error();\n+                        return false;\n+                    }\n+                }\n+\n+                true\n+            }\n+\n+            $(\n+            pub fn $i(&self) -> $ty {\n+                self.$i.0.set(true);\n+                self.$i.2.clone()\n+            }\n+            )+\n+\n+            pub fn set<'a>(&'a mut self) -> ConfigSetter<'a> {\n+                ConfigSetter(self)\n+            }\n+\n+            pub fn was_set<'a>(&'a self) -> ConfigWasSet<'a> {\n+                ConfigWasSet(self)\n+            }\n+\n+            fn fill_from_parsed_config(mut self, parsed: PartialConfig) -> Config {\n+            $(\n+                if let Some(val) = parsed.$i {\n+                    if self.$i.3 {\n+                        self.$i.1 = true;\n+                        self.$i.2 = val;\n+                    } else {\n+                        if is_nightly_channel!() {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val;\n+                        } else {\n+                            eprintln!(\"Warning: can't set `{} = {:?}`, unstable features are only \\\n+                                       available in nightly channel.\", stringify!($i), val);\n+                        }\n+                    }\n+                }\n+            )+\n+                self.set_heuristics();\n+                self\n+            }\n+\n+            pub fn from_toml(toml: &str) -> Result<Config, String> {\n+                let parsed: toml::Value =\n+                    toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n+                let mut err: String = String::new();\n+                {\n+                    let table = parsed\n+                        .as_table()\n+                        .ok_or(String::from(\"Parsed config was not table\"))?;\n+                    for key in table.keys() {\n+                        match &**key {\n+                            $(\n+                                stringify!($i) => (),\n+                            )+\n+                            _ => {\n+                                let msg =\n+                                    &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n+                                err.push_str(msg)\n+                            }\n+                        }\n+                    }\n+                }\n+                match parsed.try_into() {\n+                    Ok(parsed_config) => {\n+                        if !err.is_empty() {\n+                            eprint!(\"{}\", err);\n+                        }\n+                        Ok(Config::default().fill_from_parsed_config(parsed_config))\n+                    }\n+                    Err(e) => {\n+                        err.push_str(\"Error: Decoding config file failed:\\n\");\n+                        err.push_str(format!(\"{}\\n\", e).as_str());\n+                        err.push_str(\"Please check your config file.\");\n+                        Err(err)\n+                    }\n+                }\n+            }\n+\n+            pub fn used_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: if self.$i.0.get() {\n+                                Some(self.$i.2.clone())\n+                            } else {\n+                                None\n+                            },\n+                    )+\n+                }\n+            }\n+\n+            pub fn all_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: Some(self.$i.2.clone()),\n+                    )+\n+                }\n+            }\n+\n+            pub fn override_value(&mut self, key: &str, val: &str)\n+            {\n+                match key {\n+                    $(\n+                        stringify!($i) => {\n+                            self.$i.2 = val.parse::<$ty>()\n+                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n+                                                 stringify!($i),\n+                                                 val,\n+                                                 stringify!($ty)));\n+                        }\n+                    )+\n+                    _ => panic!(\"Unknown config key in override: {}\", key)\n+                }\n+\n+                if key == \"use_small_heuristics\" {\n+                    self.set_heuristics();\n+                }\n+            }\n+\n+            /// Construct a `Config` from the toml file specified at `file_path`.\n+            ///\n+            /// This method only looks at the provided path, for a method that\n+            /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n+            ///\n+            /// Return a `Config` if the config could be read and parsed from\n+            /// the file, Error otherwise.\n+            pub fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+                let mut file = File::open(&file_path)?;\n+                let mut toml = String::new();\n+                file.read_to_string(&mut toml)?;\n+                Config::from_toml(&toml).map_err(|err| Error::new(ErrorKind::InvalidData, err))\n+            }\n+\n+            /// Resolve the config for input in `dir`.\n+            ///\n+            /// Searches for `rustfmt.toml` beginning with `dir`, and\n+            /// recursively checking parents of `dir` if no config file is found.\n+            /// If no config file exists in `dir` or in any parent, a\n+            /// default `Config` will be returned (and the returned path will be empty).\n+            ///\n+            /// Returns the `Config` to use, and the path of the project file if there was\n+            /// one.\n+            pub fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n+\n+                /// Try to find a project file in the given directory and its parents.\n+                /// Returns the path of a the nearest project file if one exists,\n+                /// or `None` if no project file was found.\n+                fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+                    let mut current = if dir.is_relative() {\n+                        env::current_dir()?.join(dir)\n+                    } else {\n+                        dir.to_path_buf()\n+                    };\n+\n+                    current = fs::canonicalize(current)?;\n+\n+                    loop {\n+                        match get_toml_path(&current) {\n+                            Ok(Some(path)) => return Ok(Some(path)),\n+                            Err(e) => return Err(e),\n+                            _ => ()\n+                        }\n+\n+                        // If the current directory has no parent, we're done searching.\n+                        if !current.pop() {\n+                            return Ok(None);\n+                        }\n+                    }\n+                }\n+\n+                match resolve_project_file(dir)? {\n+                    None => Ok((Config::default(), None)),\n+                    Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n+                }\n+            }\n+\n+\n+            pub fn print_docs() {\n+                use std::cmp;\n+                const HIDE_OPTIONS: [&str; 3] = [\"verbose\", \"file_lines\", \"width_heuristics\"];\n+                let max = 0;\n+                $( let max = cmp::max(max, stringify!($i).len()+1); )+\n+                let mut space_str = String::with_capacity(max);\n+                for _ in 0..max {\n+                    space_str.push(' ');\n+                }\n+                println!(\"Configuration Options:\");\n+                $(\n+                    let name_raw = stringify!($i);\n+\n+                    if !HIDE_OPTIONS.contains(&name_raw) {\n+                        let mut name_out = String::with_capacity(max);\n+                        for _ in name_raw.len()..max-1 {\n+                            name_out.push(' ')\n+                        }\n+                        name_out.push_str(name_raw);\n+                        name_out.push(' ');\n+                        println!(\"{}{} Default: {:?}\",\n+                                name_out,\n+                                <$ty>::doc_hint(),\n+                                $def);\n+                        $(\n+                            println!(\"{}{}\", space_str, $dstring);\n+                        )+\n+                        println!();\n+                    }\n+                )+\n+            }\n+\n+            fn set_heuristics(&mut self) {\n+                if self.use_small_heuristics.2 {\n+                    self.set().width_heuristics(WidthHeuristics::default());\n+                } else {\n+                    self.set().width_heuristics(WidthHeuristics::null());\n+                }\n+            }\n+        }\n+\n+        // Template for the default configuration\n+        impl Default for Config {\n+            fn default() -> Config {\n+                Config {\n+                    $(\n+                        $i: (Cell::new(false), false, $def, $stb),\n+                    )+\n+                }\n+            }\n+        }\n+    )\n+}"}, {"sha": "87e201345deefdb587e31eb44d11b27c165e6378", "filename": "rustfmt-config/src/file_lines.rs", "status": "renamed", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Ffile_lines.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -12,12 +12,25 @@\n \n use std::{cmp, iter, str};\n use std::collections::HashMap;\n+use std::rc::Rc;\n \n use serde::de::{Deserialize, Deserializer};\n use serde_json as json;\n \n-use codemap::LineRange;\n-use syntax::codemap::FileName;\n+use syntax::codemap::{FileMap, FileName};\n+\n+/// A range of lines in a file, inclusive of both ends.\n+pub struct LineRange {\n+    pub file: Rc<FileMap>,\n+    pub lo: usize,\n+    pub hi: usize,\n+}\n+\n+impl LineRange {\n+    pub fn file_name(&self) -> &FileName {\n+        &self.file.name\n+    }\n+}\n \n /// A range that is inclusive of both ends.\n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Deserialize)]", "previous_filename": "src/file_lines.rs"}, {"sha": "cbfd236dc37e8a4610331ffd2b1cd583c42c2d42", "filename": "rustfmt-config/src/lib.rs", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Flib.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,252 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate serde;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde_json;\n+extern crate syntax;\n+extern crate toml;\n+\n+use std::{env, fs};\n+use std::cell::Cell;\n+use std::default::Default;\n+use std::fs::File;\n+use std::io::{Error, ErrorKind, Read};\n+use std::path::{Path, PathBuf};\n+\n+#[macro_use]\n+mod config_type;\n+#[macro_use]\n+mod options;\n+\n+pub mod file_lines;\n+pub mod lists;\n+pub mod summary;\n+\n+use config_type::ConfigType;\n+use file_lines::FileLines;\n+pub use lists::*;\n+pub use options::*;\n+use summary::Summary;\n+\n+/// This macro defines configuration options used in rustfmt. Each option\n+/// is defined as follows:\n+///\n+/// `name: value type, default value, is stable, description;`\n+create_config! {\n+    // Fundamental stuff\n+    max_width: usize, 100, true, \"Maximum width of each line\";\n+    hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n+    tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n+    newline_style: NewlineStyle, NewlineStyle::Unix, true, \"Unix or Windows line endings\";\n+    indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items.\";\n+    use_small_heuristics: bool, true, false, \"Whether to use different formatting for items and\\\n+        expressions if they satisfy a heuristic notion of 'small'.\";\n+\n+    // strings and comments\n+    format_strings: bool, false, false, \"Format string literals where necessary\";\n+    wrap_comments: bool, false, true, \"Break comments to fit on the line\";\n+    comment_width: usize, 80, false,\n+        \"Maximum length of comments. No effect unless wrap_comments = true\";\n+    normalize_comments: bool, false, true, \"Convert /* */ comments to // comments where possible\";\n+\n+    // Single line expressions and items.\n+    empty_item_single_line: bool, true, false,\n+        \"Put empty-body functions and impls on a single line\";\n+    struct_lit_single_line: bool, true, false,\n+        \"Put small struct literals on a single line\";\n+    fn_single_line: bool, false, false, \"Put single-expression functions on a single line\";\n+    where_single_line: bool, false, false, \"To force single line where layout\";\n+\n+    // Imports\n+    imports_indent: IndentStyle, IndentStyle::Visual, false, \"Indent of imports\";\n+    imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n+\n+    // Ordering\n+    reorder_extern_crates: bool, true, false, \"Reorder extern crate statements alphabetically\";\n+    reorder_extern_crates_in_group: bool, true, false, \"Reorder extern crate statements in group\";\n+    reorder_imports: bool, false, false, \"Reorder import statements alphabetically\";\n+    reorder_imports_in_group: bool, false, false, \"Reorder import statements in group\";\n+    reorder_imported_names: bool, true, false,\n+        \"Reorder lists of names in import statements alphabetically\";\n+    reorder_modules: bool, false, false, \"Reorder module statemtents alphabetically in group\";\n+\n+    // Spaces around punctuation\n+    binop_separator: SeparatorPlace, SeparatorPlace::Front, false,\n+        \"Where to put a binary operator when a binary expression goes multiline.\";\n+    type_punctuation_density: TypeDensity, TypeDensity::Wide, false,\n+        \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n+    space_before_colon: bool, false, false, \"Leave a space before the colon\";\n+    space_after_colon: bool, true, false, \"Leave a space after the colon\";\n+    spaces_around_ranges: bool, false, false, \"Put spaces around the  .. and ... range operators\";\n+    spaces_within_parens_and_brackets: bool, false, false,\n+        \"Put spaces within non-empty parentheses or brackets\";\n+\n+    // Misc.\n+    combine_control_expr: bool, true, false, \"Combine control expressions with function calls.\";\n+    struct_field_align_threshold: usize, 0, false, \"Align struct fields if their diffs fits within \\\n+                                             threshold.\";\n+    remove_blank_lines_at_start_or_end_of_block: bool, true, false,\n+        \"Remove blank lines at start or end of a block\";\n+    match_arm_blocks: bool, true, false, \"Wrap the body of arms in blocks when it does not fit on \\\n+        the same line with the pattern of arms\";\n+    force_multiline_blocks: bool, false, false,\n+        \"Force multiline closure bodies and match arms to be wrapped in a block\";\n+    fn_args_density: Density, Density::Tall, false, \"Argument density in functions\";\n+    brace_style: BraceStyle, BraceStyle::SameLineWhere, false, \"Brace style for items\";\n+    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine, false,\n+        \"Brace style for control flow constructs\";\n+    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical, false,\n+        \"How to handle trailing commas for lists\";\n+    trailing_semicolon: bool, true, false,\n+        \"Add trailing semicolon after break, continue and return\";\n+    match_block_trailing_comma: bool, false, false,\n+        \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n+    blank_lines_upper_bound: usize, 1, false,\n+        \"Maximum number of blank lines which can be put between items.\";\n+    blank_lines_lower_bound: usize, 0, false,\n+        \"Minimum number of blank lines which must be put between items.\";\n+\n+    // Options that can change the source code beyond whitespace/blocks (somewhat linty things)\n+    merge_derives: bool, true, true, \"Merge multiple `#[derive(...)]` into a single one\";\n+    use_try_shorthand: bool, false, false, \"Replace uses of the try! macro by the ? shorthand\";\n+    condense_wildcard_suffixes: bool, false, false, \"Replace strings of _ wildcards by a single .. \\\n+                                              in tuple patterns\";\n+    force_explicit_abi: bool, true, true, \"Always print the abi for extern items\";\n+    use_field_init_shorthand: bool, false, false, \"Use field initialization shorthand if possible\";\n+\n+    // Control options (changes the operation of rustfmt, rather than the formatting)\n+    write_mode: WriteMode, WriteMode::Overwrite, false,\n+        \"What Write Mode to use when none is supplied: \\\n+         Replace, Overwrite, Display, Plain, Diff, Coverage\";\n+    color: Color, Color::Auto, false,\n+        \"What Color option to use when none is supplied: Always, Never, Auto\";\n+    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n+        \"Require a specific version of rustfmt.\";\n+    unstable_features: bool, false, true,\n+            \"Enables unstable features. Only available on nightly channel\";\n+    disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n+    skip_children: bool, false, false, \"Don't reformat out of line modules\";\n+    hide_parse_errors: bool, false, false, \"Hide errors from the parser\";\n+    error_on_line_overflow: bool, true, false, \"Error if unable to get all lines within max_width\";\n+    error_on_unformatted: bool, false, false,\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\";\n+    report_todo: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n+    report_fixme: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n+\n+    // Not user-facing.\n+    verbose: bool, false, false, \"Use verbose output\";\n+    file_lines: FileLines, FileLines::all(), false,\n+        \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n+         via the --file-lines option\";\n+    width_heuristics: WidthHeuristics, WidthHeuristics::default(), false,\n+        \"'small' heuristic values\";\n+}\n+\n+/// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n+///\n+/// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n+pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+    const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n+    for config_file_name in &CONFIG_FILE_NAMES {\n+        let config_file = dir.join(config_file_name);\n+        match fs::metadata(&config_file) {\n+            // Only return if it's a file to handle the unlikely situation of a directory named\n+            // `rustfmt.toml`.\n+            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+            // Return the error if it's something other than `NotFound`; otherwise we didn't\n+            // find the project file yet, and continue searching.\n+            Err(e) => {\n+                if e.kind() != ErrorKind::NotFound {\n+                    return Err(e);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(None)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Config;\n+\n+    #[test]\n+    fn test_config_set() {\n+        let mut config = Config::default();\n+        config.set().verbose(false);\n+        assert_eq!(config.verbose(), false);\n+        config.set().verbose(true);\n+        assert_eq!(config.verbose(), true);\n+    }\n+\n+    #[test]\n+    fn test_config_used_to_toml() {\n+        let config = Config::default();\n+\n+        let merge_derives = config.merge_derives();\n+        let skip_children = config.skip_children();\n+\n+        let used_options = config.used_options();\n+        let toml = used_options.to_toml().unwrap();\n+        assert_eq!(\n+            toml,\n+            format!(\n+                \"merge_derives = {}\\nskip_children = {}\\n\",\n+                merge_derives, skip_children,\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_was_set() {\n+        let config = Config::from_toml(\"hard_tabs = true\").unwrap();\n+\n+        assert_eq!(config.was_set().hard_tabs(), true);\n+        assert_eq!(config.was_set().verbose(), false);\n+    }\n+\n+    // FIXME(#2183) these tests cannot be run in parallel because they use env vars\n+    // #[test]\n+    // fn test_as_not_nightly_channel() {\n+    //     let mut config = Config::default();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    // }\n+\n+    // #[test]\n+    // fn test_as_nightly_channel() {\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     let mut config = Config::default();\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+\n+    // #[test]\n+    // fn test_unstable_from_toml() {\n+    //     let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+}"}, {"sha": "2ddc2e59261258af744b1109aaf2d5249460fea0", "filename": "rustfmt-config/src/lists.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Flists.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Configuration options related to rewriting a list.\n+\n+use IndentStyle;\n+use config_type::ConfigType;\n+\n+/// The definitive formatting tactic for lists.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum DefinitiveListTactic {\n+    Vertical,\n+    Horizontal,\n+    Mixed,\n+    /// Special case tactic for `format!()`, `write!()` style macros.\n+    SpecialMacro(usize),\n+}\n+\n+impl DefinitiveListTactic {\n+    pub fn ends_with_newline(&self, indent_style: IndentStyle) -> bool {\n+        match indent_style {\n+            IndentStyle::Block => *self != DefinitiveListTactic::Horizontal,\n+            IndentStyle::Visual => false,\n+        }\n+    }\n+}\n+\n+/// Formatting tactic for lists. This will be cast down to a\n+/// `DefinitiveListTactic` depending on the number and length of the items and\n+/// their comments.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum ListTactic {\n+    // One item per row.\n+    Vertical,\n+    // All items on one row.\n+    Horizontal,\n+    // Try Horizontal layout, if that fails then vertical.\n+    HorizontalVertical,\n+    // HorizontalVertical with a soft limit of n characters.\n+    LimitedHorizontalVertical(usize),\n+    // Pack as many items as possible per row over (possibly) many rows.\n+    Mixed,\n+}\n+\n+impl_enum_serialize_and_deserialize!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorTactic {\n+    Always,\n+    Never,\n+    Vertical,\n+}\n+\n+impl_enum_serialize_and_deserialize!(SeparatorTactic, Always, Never, Vertical);\n+\n+impl SeparatorTactic {\n+    pub fn from_bool(b: bool) -> SeparatorTactic {\n+        if b {\n+            SeparatorTactic::Always\n+        } else {\n+            SeparatorTactic::Never\n+        }\n+    }\n+}\n+\n+/// Where to put separator.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorPlace {\n+    Front,\n+    Back,\n+}\n+\n+impl_enum_serialize_and_deserialize!(SeparatorPlace, Front, Back);\n+\n+impl SeparatorPlace {\n+    pub fn is_front(&self) -> bool {\n+        *self == SeparatorPlace::Front\n+    }\n+\n+    pub fn is_back(&self) -> bool {\n+        *self == SeparatorPlace::Back\n+    }\n+\n+    pub fn from_tactic(\n+        default: SeparatorPlace,\n+        tactic: DefinitiveListTactic,\n+        sep: &str,\n+    ) -> SeparatorPlace {\n+        match tactic {\n+            DefinitiveListTactic::Vertical => default,\n+            _ => if sep == \",\" {\n+                SeparatorPlace::Back\n+            } else {\n+                default\n+            },\n+        }\n+    }\n+}"}, {"sha": "6391db85dc5134bdf64adad0dd08d3289261add7", "filename": "rustfmt-config/src/macros.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Fmacros.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+"}, {"sha": "bff6d2298d3b61bba18509e72ca69c711a970694", "filename": "rustfmt-config/src/options.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Foptions.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use config_type::ConfigType;\n+use lists::*;\n+\n+/// Macro for deriving implementations of Serialize/Deserialize for enums\n+#[macro_export]\n+macro_rules! impl_enum_serialize_and_deserialize {\n+    ( $e:ident, $( $x:ident ),* ) => {\n+        impl ::serde::ser::Serialize for $e {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+                where S: ::serde::ser::Serializer\n+            {\n+                use serde::ser::Error;\n+\n+                // We don't know whether the user of the macro has given us all options.\n+                #[allow(unreachable_patterns)]\n+                match *self {\n+                    $(\n+                        $e::$x => serializer.serialize_str(stringify!($x)),\n+                    )*\n+                    _ => {\n+                        Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self)))\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl<'de> ::serde::de::Deserialize<'de> for $e {\n+            fn deserialize<D>(d: D) -> Result<Self, D::Error>\n+                    where D: ::serde::Deserializer<'de> {\n+                use serde::de::{Error, Visitor};\n+                use std::marker::PhantomData;\n+                use std::fmt;\n+                struct StringOnly<T>(PhantomData<T>);\n+                impl<'de, T> Visitor<'de> for StringOnly<T>\n+                        where T: ::serde::Deserializer<'de> {\n+                    type Value = String;\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"string\")\n+                    }\n+                    fn visit_str<E>(self, value: &str) -> Result<String, E> {\n+                        Ok(String::from(value))\n+                    }\n+                }\n+                let s = d.deserialize_string(StringOnly::<D>(PhantomData))?;\n+                $(\n+                    if stringify!($x).eq_ignore_ascii_case(&s) {\n+                      return Ok($e::$x);\n+                    }\n+                )*\n+                static ALLOWED: &'static[&str] = &[$(stringify!($x),)*];\n+                Err(D::Error::unknown_variant(&s, ALLOWED))\n+            }\n+        }\n+\n+        impl ::std::str::FromStr for $e {\n+            type Err = &'static str;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                $(\n+                    if stringify!($x).eq_ignore_ascii_case(s) {\n+                        return Ok($e::$x);\n+                    }\n+                )*\n+                Err(\"Bad variant\")\n+            }\n+        }\n+\n+        impl ConfigType for $e {\n+            fn doc_hint() -> String {\n+                let mut variants = Vec::new();\n+                $(\n+                    variants.push(stringify!($x));\n+                )*\n+                format!(\"[{}]\", variants.join(\"|\"))\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! configuration_option_enum{\n+    ($e:ident: $( $x:ident ),+ $(,)*) => {\n+        #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+        pub enum $e {\n+            $( $x ),+\n+        }\n+\n+        impl_enum_serialize_and_deserialize!($e, $( $x ),+);\n+    }\n+}\n+\n+configuration_option_enum! { NewlineStyle:\n+    Windows, // \\r\\n\n+    Unix, // \\n\n+    Native, // \\r\\n in Windows, \\n on other platforms\n+}\n+\n+configuration_option_enum! { BraceStyle:\n+    AlwaysNextLine,\n+    PreferSameLine,\n+    // Prefer same line except where there is a where clause, in which case force\n+    // the brace to the next line.\n+    SameLineWhere,\n+}\n+\n+configuration_option_enum! { ControlBraceStyle:\n+    // K&R style, Rust community default\n+    AlwaysSameLine,\n+    // Stroustrup style\n+    ClosingNextLine,\n+    // Allman style\n+    AlwaysNextLine,\n+}\n+\n+configuration_option_enum! { IndentStyle:\n+    // First line on the same line as the opening brace, all lines aligned with\n+    // the first line.\n+    Visual,\n+    // First line is on a new line and all lines align with block indent.\n+    Block,\n+}\n+\n+configuration_option_enum! { Density:\n+    // Fit as much on one line as possible.\n+    Compressed,\n+    // Use more lines.\n+    Tall,\n+    // Place every item on a separate line.\n+    Vertical,\n+}\n+\n+configuration_option_enum! { TypeDensity:\n+    // No spaces around \"=\" and \"+\"\n+    Compressed,\n+    // Spaces around \" = \" and \" + \"\n+    Wide,\n+}\n+\n+impl Density {\n+    pub fn to_list_tactic(self) -> ListTactic {\n+        match self {\n+            Density::Compressed => ListTactic::Mixed,\n+            Density::Tall => ListTactic::HorizontalVertical,\n+            Density::Vertical => ListTactic::Vertical,\n+        }\n+    }\n+}\n+\n+configuration_option_enum! { ReportTactic:\n+    Always,\n+    Unnumbered,\n+    Never,\n+}\n+\n+configuration_option_enum! { WriteMode:\n+    // Backs the original file up and overwrites the original.\n+    Replace,\n+    // Overwrites original file without backup.\n+    Overwrite,\n+    // Writes the output to stdout.\n+    Display,\n+    // Writes the diff to stdout.\n+    Diff,\n+    // Displays how much of the input file was processed\n+    Coverage,\n+    // Unfancy stdout\n+    Plain,\n+    // Outputs a checkstyle XML file.\n+    Checkstyle,\n+}\n+\n+configuration_option_enum! { Color:\n+    // Always use color, whether it is a piped or terminal output\n+    Always,\n+    // Never use color\n+    Never,\n+    // Automatically use color, if supported by terminal\n+    Auto,\n+}\n+\n+#[derive(Deserialize, Serialize, Clone, Debug)]\n+pub struct WidthHeuristics {\n+    // Maximum width of the args of a function call before falling back\n+    // to vertical formatting.\n+    pub fn_call_width: usize,\n+    // Maximum width in the body of a struct lit before falling back to\n+    // vertical formatting.\n+    pub struct_lit_width: usize,\n+    // Maximum width in the body of a struct variant before falling back\n+    // to vertical formatting.\n+    pub struct_variant_width: usize,\n+    // Maximum width of an array literal before falling back to vertical\n+    // formatting.\n+    pub array_width: usize,\n+    // Maximum length of a chain to fit on a single line.\n+    pub chain_width: usize,\n+    // Maximum line length for single line if-else expressions. A value\n+    // of zero means always break if-else expressions.\n+    pub single_line_if_else_max_width: usize,\n+}\n+\n+impl WidthHeuristics {\n+    // Using this WidthHeuristics means we ignore heuristics.\n+    pub fn null() -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: usize::max_value(),\n+            struct_lit_width: 0,\n+            struct_variant_width: 0,\n+            array_width: usize::max_value(),\n+            chain_width: usize::max_value(),\n+            single_line_if_else_max_width: 0,\n+        }\n+    }\n+}\n+\n+impl Default for WidthHeuristics {\n+    fn default() -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: 60,\n+            struct_lit_width: 18,\n+            struct_variant_width: 35,\n+            array_width: 60,\n+            chain_width: 60,\n+            single_line_if_else_max_width: 50,\n+        }\n+    }\n+}\n+\n+impl ::std::str::FromStr for WidthHeuristics {\n+    type Err = &'static str;\n+\n+    fn from_str(_: &str) -> Result<Self, Self::Err> {\n+        Err(\"WidthHeuristics is not parsable\")\n+    }\n+}"}, {"sha": "b0be5678a0b5382a383118b684a742d7d86d1d22", "filename": "rustfmt-config/src/summary.rs", "status": "renamed", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b25f1b4a528d1e1db173dabd3f9fcfe103615b/rustfmt-config%2Fsrc%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Fsummary.rs?ref=66b25f1b4a528d1e1db173dabd3f9fcfe103615b", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::time::{Duration, Instant};\n use std::default::Default;\n ", "previous_filename": "src/summary.rs"}, {"sha": "cca1779a4a8d0fb6d2f8b04df06c65dbe0ff710f", "filename": "src/config.rs", "status": "removed", "additions": 0, "deletions": 781, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=4af2aa3a9e2ab32e584c3d7bc97d74bdc8b35836", "patch": "@@ -1,781 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate toml;\n-\n-use std::{env, fs};\n-use std::cell::Cell;\n-use std::default::Default;\n-use std::fs::File;\n-use std::io::{Error, ErrorKind, Read};\n-use std::path::{Path, PathBuf};\n-\n-use Summary;\n-use file_lines::FileLines;\n-use lists::{ListTactic, SeparatorPlace, SeparatorTactic};\n-\n-/// Check if we're in a nightly build.\n-///\n-/// The environment variable `CFG_RELEASE_CHANNEL` is set during the rustc bootstrap\n-/// to \"stable\", \"beta\", or \"nightly\" depending on what toolchain is being built.\n-/// If we are being built as part of the stable or beta toolchains, we want\n-/// to disable unstable configuration options.\n-///\n-/// If we're being built by cargo (e.g. `cargo +nightly install rustfmt-nightly`),\n-/// `CFG_RELEASE_CHANNEL` is not set. As we only support being built against the\n-/// nightly compiler when installed from crates.io, default to nightly mode.\n-macro_rules! is_nightly_channel {\n-    () => {\n-        option_env!(\"CFG_RELEASE_CHANNEL\")\n-            .map(|c| c == \"nightly\")\n-            .unwrap_or(true)\n-    };\n-}\n-\n-macro_rules! configuration_option_enum{\n-    ($e:ident: $( $x:ident ),+ $(,)*) => {\n-        #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n-        pub enum $e {\n-            $( $x ),+\n-        }\n-\n-        impl_enum_serialize_and_deserialize!($e, $( $x ),+);\n-    }\n-}\n-\n-configuration_option_enum! { NewlineStyle:\n-    Windows, // \\r\\n\n-    Unix, // \\n\n-    Native, // \\r\\n in Windows, \\n on other platforms\n-}\n-\n-configuration_option_enum! { BraceStyle:\n-    AlwaysNextLine,\n-    PreferSameLine,\n-    // Prefer same line except where there is a where clause, in which case force\n-    // the brace to the next line.\n-    SameLineWhere,\n-}\n-\n-configuration_option_enum! { ControlBraceStyle:\n-    // K&R style, Rust community default\n-    AlwaysSameLine,\n-    // Stroustrup style\n-    ClosingNextLine,\n-    // Allman style\n-    AlwaysNextLine,\n-}\n-\n-configuration_option_enum! { IndentStyle:\n-    // First line on the same line as the opening brace, all lines aligned with\n-    // the first line.\n-    Visual,\n-    // First line is on a new line and all lines align with block indent.\n-    Block,\n-}\n-\n-configuration_option_enum! { Density:\n-    // Fit as much on one line as possible.\n-    Compressed,\n-    // Use more lines.\n-    Tall,\n-    // Place every item on a separate line.\n-    Vertical,\n-}\n-\n-configuration_option_enum! { TypeDensity:\n-    // No spaces around \"=\" and \"+\"\n-    Compressed,\n-    // Spaces around \" = \" and \" + \"\n-    Wide,\n-}\n-\n-impl Density {\n-    pub fn to_list_tactic(self) -> ListTactic {\n-        match self {\n-            Density::Compressed => ListTactic::Mixed,\n-            Density::Tall => ListTactic::HorizontalVertical,\n-            Density::Vertical => ListTactic::Vertical,\n-        }\n-    }\n-}\n-\n-configuration_option_enum! { ReportTactic:\n-    Always,\n-    Unnumbered,\n-    Never,\n-}\n-\n-configuration_option_enum! { WriteMode:\n-    // Backs the original file up and overwrites the original.\n-    Replace,\n-    // Overwrites original file without backup.\n-    Overwrite,\n-    // Writes the output to stdout.\n-    Display,\n-    // Writes the diff to stdout.\n-    Diff,\n-    // Displays how much of the input file was processed\n-    Coverage,\n-    // Unfancy stdout\n-    Plain,\n-    // Outputs a checkstyle XML file.\n-    Checkstyle,\n-}\n-\n-configuration_option_enum! { Color:\n-    // Always use color, whether it is a piped or terminal output\n-    Always,\n-    // Never use color\n-    Never,\n-    // Automatically use color, if supported by terminal\n-    Auto,\n-}\n-\n-#[derive(Deserialize, Serialize, Clone, Debug)]\n-pub struct WidthHeuristics {\n-    // Maximum width of the args of a function call before falling back\n-    // to vertical formatting.\n-    pub fn_call_width: usize,\n-    // Maximum width in the body of a struct lit before falling back to\n-    // vertical formatting.\n-    pub struct_lit_width: usize,\n-    // Maximum width in the body of a struct variant before falling back\n-    // to vertical formatting.\n-    pub struct_variant_width: usize,\n-    // Maximum width of an array literal before falling back to vertical\n-    // formatting.\n-    pub array_width: usize,\n-    // Maximum length of a chain to fit on a single line.\n-    pub chain_width: usize,\n-    // Maximum line length for single line if-else expressions. A value\n-    // of zero means always break if-else expressions.\n-    pub single_line_if_else_max_width: usize,\n-}\n-\n-impl WidthHeuristics {\n-    // Using this WidthHeuristics means we ignore heuristics.\n-    fn null() -> WidthHeuristics {\n-        WidthHeuristics {\n-            fn_call_width: usize::max_value(),\n-            struct_lit_width: 0,\n-            struct_variant_width: 0,\n-            array_width: usize::max_value(),\n-            chain_width: usize::max_value(),\n-            single_line_if_else_max_width: 0,\n-        }\n-    }\n-}\n-\n-impl Default for WidthHeuristics {\n-    fn default() -> WidthHeuristics {\n-        WidthHeuristics {\n-            fn_call_width: 60,\n-            struct_lit_width: 18,\n-            struct_variant_width: 35,\n-            array_width: 60,\n-            chain_width: 60,\n-            single_line_if_else_max_width: 50,\n-        }\n-    }\n-}\n-\n-impl ::std::str::FromStr for WidthHeuristics {\n-    type Err = &'static str;\n-\n-    fn from_str(_: &str) -> Result<Self, Self::Err> {\n-        Err(\"WidthHeuristics is not parsable\")\n-    }\n-}\n-\n-impl ::config::ConfigType for WidthHeuristics {\n-    fn doc_hint() -> String {\n-        String::new()\n-    }\n-}\n-\n-/// Trait for types that can be used in `Config`.\n-pub trait ConfigType: Sized {\n-    /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n-    /// pipe-separated list of variants; for other types it returns \"<type>\".\n-    fn doc_hint() -> String;\n-}\n-\n-impl ConfigType for bool {\n-    fn doc_hint() -> String {\n-        String::from(\"<boolean>\")\n-    }\n-}\n-\n-impl ConfigType for usize {\n-    fn doc_hint() -> String {\n-        String::from(\"<unsigned integer>\")\n-    }\n-}\n-\n-impl ConfigType for isize {\n-    fn doc_hint() -> String {\n-        String::from(\"<signed integer>\")\n-    }\n-}\n-\n-impl ConfigType for String {\n-    fn doc_hint() -> String {\n-        String::from(\"<string>\")\n-    }\n-}\n-\n-impl ConfigType for FileLines {\n-    fn doc_hint() -> String {\n-        String::from(\"<json>\")\n-    }\n-}\n-\n-pub struct ConfigHelpItem {\n-    option_name: &'static str,\n-    doc_string: &'static str,\n-    variant_names: String,\n-    default: &'static str,\n-}\n-\n-impl ConfigHelpItem {\n-    pub fn option_name(&self) -> &'static str {\n-        self.option_name\n-    }\n-\n-    pub fn doc_string(&self) -> &'static str {\n-        self.doc_string\n-    }\n-\n-    pub fn variant_names(&self) -> &String {\n-        &self.variant_names\n-    }\n-\n-    pub fn default(&self) -> &'static str {\n-        self.default\n-    }\n-}\n-\n-macro_rules! create_config {\n-    ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n-        #[derive(Clone)]\n-        pub struct Config {\n-            // For each config item, we store a bool indicating whether it has\n-            // been accessed and the value, and a bool whether the option was\n-            // manually initialised, or taken from the default,\n-            $($i: (Cell<bool>, bool, $ty, bool)),+\n-        }\n-\n-        // Just like the Config struct but with each property wrapped\n-        // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n-        // specify all properties of `Config`.\n-        // We first parse into `PartialConfig`, then create a default `Config`\n-        // and overwrite the properties with corresponding values from `PartialConfig`.\n-        #[derive(Deserialize, Serialize, Clone)]\n-        pub struct PartialConfig {\n-            $(pub $i: Option<$ty>),+\n-        }\n-\n-        impl PartialConfig {\n-            pub fn to_toml(&self) -> Result<String, String> {\n-                // Non-user-facing options can't be specified in TOML\n-                let mut cloned = self.clone();\n-                cloned.file_lines = None;\n-                cloned.verbose = None;\n-                cloned.width_heuristics = None;\n-\n-                toml::to_string(&cloned)\n-                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n-            }\n-        }\n-\n-        // Macro hygiene won't allow us to make `set_$i()` methods on Config\n-        // for each item, so this struct is used to give the API to set values:\n-        // `config.get().option(false)`. It's pretty ugly. Consider replacing\n-        // with `config.set_option(false)` if we ever get a stable/usable\n-        // `concat_idents!()`.\n-        pub struct ConfigSetter<'a>(&'a mut Config);\n-\n-        impl<'a> ConfigSetter<'a> {\n-            $(\n-            pub fn $i(&mut self, value: $ty) {\n-                (self.0).$i.2 = value;\n-                if stringify!($i) == \"use_small_heuristics\" {\n-                    self.0.set_heuristics();\n-                }\n-            }\n-            )+\n-        }\n-\n-        // Query each option, returns true if the user set the option, false if\n-        // a default was used.\n-        pub struct ConfigWasSet<'a>(&'a Config);\n-\n-        impl<'a> ConfigWasSet<'a> {\n-            $(\n-            pub fn $i(&self) -> bool {\n-                (self.0).$i.1\n-            }\n-            )+\n-        }\n-\n-        impl Config {\n-            pub fn version_meets_requirement(&self, error_summary: &mut Summary) -> bool {\n-                if self.was_set().required_version() {\n-                    let version = env!(\"CARGO_PKG_VERSION\");\n-                    let required_version = self.required_version();\n-                    if version != required_version {\n-                        println!(\n-                            \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n-                            version,\n-                            required_version,\n-                        );\n-                        error_summary.add_formatting_error();\n-                        return false;\n-                    }\n-                }\n-\n-                true\n-            }\n-\n-            $(\n-            pub fn $i(&self) -> $ty {\n-                self.$i.0.set(true);\n-                self.$i.2.clone()\n-            }\n-            )+\n-\n-            pub fn set<'a>(&'a mut self) -> ConfigSetter<'a> {\n-                ConfigSetter(self)\n-            }\n-\n-            pub fn was_set<'a>(&'a self) -> ConfigWasSet<'a> {\n-                ConfigWasSet(self)\n-            }\n-\n-            fn fill_from_parsed_config(mut self, parsed: PartialConfig) -> Config {\n-            $(\n-                if let Some(val) = parsed.$i {\n-                    if self.$i.3 {\n-                        self.$i.1 = true;\n-                        self.$i.2 = val;\n-                    } else {\n-                        if is_nightly_channel!() {\n-                            self.$i.1 = true;\n-                            self.$i.2 = val;\n-                        } else {\n-                            eprintln!(\"Warning: can't set `{} = {:?}`, unstable features are only \\\n-                                       available in nightly channel.\", stringify!($i), val);\n-                        }\n-                    }\n-                }\n-            )+\n-                self.set_heuristics();\n-                self\n-            }\n-\n-            pub fn from_toml(toml: &str) -> Result<Config, String> {\n-                let parsed: toml::Value =\n-                    toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n-                let mut err: String = String::new();\n-                {\n-                    let table = parsed\n-                        .as_table()\n-                        .ok_or(String::from(\"Parsed config was not table\"))?;\n-                    for key in table.keys() {\n-                        match &**key {\n-                            $(\n-                                stringify!($i) => (),\n-                            )+\n-                            _ => {\n-                                let msg =\n-                                    &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n-                                err.push_str(msg)\n-                            }\n-                        }\n-                    }\n-                }\n-                match parsed.try_into() {\n-                    Ok(parsed_config) => {\n-                        if !err.is_empty() {\n-                            eprint!(\"{}\", err);\n-                        }\n-                        Ok(Config::default().fill_from_parsed_config(parsed_config))\n-                    }\n-                    Err(e) => {\n-                        err.push_str(\"Error: Decoding config file failed:\\n\");\n-                        err.push_str(format!(\"{}\\n\", e).as_str());\n-                        err.push_str(\"Please check your config file.\");\n-                        Err(err)\n-                    }\n-                }\n-            }\n-\n-            pub fn used_options(&self) -> PartialConfig {\n-                PartialConfig {\n-                    $(\n-                        $i: if self.$i.0.get() {\n-                                Some(self.$i.2.clone())\n-                            } else {\n-                                None\n-                            },\n-                    )+\n-                }\n-            }\n-\n-            pub fn all_options(&self) -> PartialConfig {\n-                PartialConfig {\n-                    $(\n-                        $i: Some(self.$i.2.clone()),\n-                    )+\n-                }\n-            }\n-\n-            pub fn override_value(&mut self, key: &str, val: &str)\n-            {\n-                match key {\n-                    $(\n-                        stringify!($i) => {\n-                            self.$i.2 = val.parse::<$ty>()\n-                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n-                                                 stringify!($i),\n-                                                 val,\n-                                                 stringify!($ty)));\n-                        }\n-                    )+\n-                    _ => panic!(\"Unknown config key in override: {}\", key)\n-                }\n-\n-                if key == \"use_small_heuristics\" {\n-                    self.set_heuristics();\n-                }\n-            }\n-\n-            /// Construct a `Config` from the toml file specified at `file_path`.\n-            ///\n-            /// This method only looks at the provided path, for a method that\n-            /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n-            ///\n-            /// Return a `Config` if the config could be read and parsed from\n-            /// the file, Error otherwise.\n-            pub fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n-                let mut file = File::open(&file_path)?;\n-                let mut toml = String::new();\n-                file.read_to_string(&mut toml)?;\n-                Config::from_toml(&toml).map_err(|err| Error::new(ErrorKind::InvalidData, err))\n-            }\n-\n-            /// Resolve the config for input in `dir`.\n-            ///\n-            /// Searches for `rustfmt.toml` beginning with `dir`, and\n-            /// recursively checking parents of `dir` if no config file is found.\n-            /// If no config file exists in `dir` or in any parent, a\n-            /// default `Config` will be returned (and the returned path will be empty).\n-            ///\n-            /// Returns the `Config` to use, and the path of the project file if there was\n-            /// one.\n-            pub fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n-\n-                /// Try to find a project file in the given directory and its parents.\n-                /// Returns the path of a the nearest project file if one exists,\n-                /// or `None` if no project file was found.\n-                fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n-                    let mut current = if dir.is_relative() {\n-                        env::current_dir()?.join(dir)\n-                    } else {\n-                        dir.to_path_buf()\n-                    };\n-\n-                    current = fs::canonicalize(current)?;\n-\n-                    loop {\n-                        match get_toml_path(&current) {\n-                            Ok(Some(path)) => return Ok(Some(path)),\n-                            Err(e) => return Err(e),\n-                            _ => ()\n-                        }\n-\n-                        // If the current directory has no parent, we're done searching.\n-                        if !current.pop() {\n-                            return Ok(None);\n-                        }\n-                    }\n-                }\n-\n-                match resolve_project_file(dir)? {\n-                    None => Ok((Config::default(), None)),\n-                    Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n-                }\n-            }\n-\n-\n-            pub fn print_docs() {\n-                use std::cmp;\n-                const HIDE_OPTIONS: [&str; 3] = [\"verbose\", \"file_lines\", \"width_heuristics\"];\n-                let max = 0;\n-                $( let max = cmp::max(max, stringify!($i).len()+1); )+\n-                let mut space_str = String::with_capacity(max);\n-                for _ in 0..max {\n-                    space_str.push(' ');\n-                }\n-                println!(\"Configuration Options:\");\n-                $(\n-                    let name_raw = stringify!($i);\n-\n-                    if !HIDE_OPTIONS.contains(&name_raw) {\n-                        let mut name_out = String::with_capacity(max);\n-                        for _ in name_raw.len()..max-1 {\n-                            name_out.push(' ')\n-                        }\n-                        name_out.push_str(name_raw);\n-                        name_out.push(' ');\n-                        println!(\"{}{} Default: {:?}\",\n-                                name_out,\n-                                <$ty>::doc_hint(),\n-                                $def);\n-                        $(\n-                            println!(\"{}{}\", space_str, $dstring);\n-                        )+\n-                        println!();\n-                    }\n-                )+\n-            }\n-\n-            fn set_heuristics(&mut self) {\n-                if self.use_small_heuristics.2 {\n-                    self.set().width_heuristics(WidthHeuristics::default());\n-                } else {\n-                    self.set().width_heuristics(WidthHeuristics::null());\n-                }\n-            }\n-        }\n-\n-        // Template for the default configuration\n-        impl Default for Config {\n-            fn default() -> Config {\n-                Config {\n-                    $(\n-                        $i: (Cell::new(false), false, $def, $stb),\n-                    )+\n-                }\n-            }\n-        }\n-    )\n-}\n-\n-/// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n-///\n-/// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n-pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n-    const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n-    for config_file_name in &CONFIG_FILE_NAMES {\n-        let config_file = dir.join(config_file_name);\n-        match fs::metadata(&config_file) {\n-            // Only return if it's a file to handle the unlikely situation of a directory named\n-            // `rustfmt.toml`.\n-            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n-            // Return the error if it's something other than `NotFound`; otherwise we didn't\n-            // find the project file yet, and continue searching.\n-            Err(e) => {\n-                if e.kind() != ErrorKind::NotFound {\n-                    return Err(e);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    Ok(None)\n-}\n-\n-create_config! {\n-    // Fundamental stuff\n-    max_width: usize, 100, true, \"Maximum width of each line\";\n-    hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n-    tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n-    newline_style: NewlineStyle, NewlineStyle::Unix, true, \"Unix or Windows line endings\";\n-    indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items.\";\n-    use_small_heuristics: bool, true, false, \"Whether to use different formatting for items and\\\n-        expressions if they satisfy a heuristic notion of 'small'.\";\n-\n-    // strings and comments\n-    format_strings: bool, false, false, \"Format string literals where necessary\";\n-    wrap_comments: bool, false, true, \"Break comments to fit on the line\";\n-    comment_width: usize, 80, false,\n-        \"Maximum length of comments. No effect unless wrap_comments = true\";\n-    normalize_comments: bool, false, true, \"Convert /* */ comments to // comments where possible\";\n-\n-    // Single line expressions and items.\n-    empty_item_single_line: bool, true, false,\n-        \"Put empty-body functions and impls on a single line\";\n-    struct_lit_single_line: bool, true, false,\n-        \"Put small struct literals on a single line\";\n-    fn_single_line: bool, false, false, \"Put single-expression functions on a single line\";\n-    where_single_line: bool, false, false, \"To force single line where layout\";\n-\n-    // Imports\n-    imports_indent: IndentStyle, IndentStyle::Visual, false, \"Indent of imports\";\n-    imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n-\n-    // Ordering\n-    reorder_extern_crates: bool, true, false, \"Reorder extern crate statements alphabetically\";\n-    reorder_extern_crates_in_group: bool, true, false, \"Reorder extern crate statements in group\";\n-    reorder_imports: bool, false, false, \"Reorder import statements alphabetically\";\n-    reorder_imports_in_group: bool, false, false, \"Reorder import statements in group\";\n-    reorder_imported_names: bool, true, false,\n-        \"Reorder lists of names in import statements alphabetically\";\n-    reorder_modules: bool, false, false, \"Reorder module statemtents alphabetically in group\";\n-\n-    // Spaces around punctuation\n-    binop_separator: SeparatorPlace, SeparatorPlace::Front, false,\n-        \"Where to put a binary operator when a binary expression goes multiline.\";\n-    type_punctuation_density: TypeDensity, TypeDensity::Wide, false,\n-        \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n-    space_before_colon: bool, false, false, \"Leave a space before the colon\";\n-    space_after_colon: bool, true, false, \"Leave a space after the colon\";\n-    spaces_around_ranges: bool, false, false, \"Put spaces around the  .. and ... range operators\";\n-    spaces_within_parens_and_brackets: bool, false, false,\n-        \"Put spaces within non-empty parentheses or brackets\";\n-\n-    // Misc.\n-    combine_control_expr: bool, true, false, \"Combine control expressions with function calls.\";\n-    struct_field_align_threshold: usize, 0, false, \"Align struct fields if their diffs fits within \\\n-                                             threshold.\";\n-    remove_blank_lines_at_start_or_end_of_block: bool, true, false,\n-        \"Remove blank lines at start or end of a block\";\n-    match_arm_blocks: bool, true, false, \"Wrap the body of arms in blocks when it does not fit on \\\n-        the same line with the pattern of arms\";\n-    force_multiline_blocks: bool, false, false,\n-        \"Force multiline closure bodies and match arms to be wrapped in a block\";\n-    fn_args_density: Density, Density::Tall, false, \"Argument density in functions\";\n-    brace_style: BraceStyle, BraceStyle::SameLineWhere, false, \"Brace style for items\";\n-    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine, false,\n-        \"Brace style for control flow constructs\";\n-    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical, false,\n-        \"How to handle trailing commas for lists\";\n-    trailing_semicolon: bool, true, false,\n-        \"Add trailing semicolon after break, continue and return\";\n-    match_block_trailing_comma: bool, false, false,\n-        \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n-    blank_lines_upper_bound: usize, 1, false,\n-        \"Maximum number of blank lines which can be put between items.\";\n-    blank_lines_lower_bound: usize, 0, false,\n-        \"Minimum number of blank lines which must be put between items.\";\n-\n-    // Options that can change the source code beyond whitespace/blocks (somewhat linty things)\n-    merge_derives: bool, true, true, \"Merge multiple `#[derive(...)]` into a single one\";\n-    use_try_shorthand: bool, false, false, \"Replace uses of the try! macro by the ? shorthand\";\n-    condense_wildcard_suffixes: bool, false, false, \"Replace strings of _ wildcards by a single .. \\\n-                                              in tuple patterns\";\n-    force_explicit_abi: bool, true, true, \"Always print the abi for extern items\";\n-    use_field_init_shorthand: bool, false, false, \"Use field initialization shorthand if possible\";\n-\n-    // Control options (changes the operation of rustfmt, rather than the formatting)\n-    write_mode: WriteMode, WriteMode::Overwrite, false,\n-        \"What Write Mode to use when none is supplied: \\\n-         Replace, Overwrite, Display, Plain, Diff, Coverage\";\n-    color: Color, Color::Auto, false,\n-        \"What Color option to use when none is supplied: Always, Never, Auto\";\n-    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n-        \"Require a specific version of rustfmt.\";\n-    unstable_features: bool, false, true,\n-            \"Enables unstable features. Only available on nightly channel\";\n-    disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n-    skip_children: bool, false, false, \"Don't reformat out of line modules\";\n-    hide_parse_errors: bool, false, false, \"Hide errors from the parser\";\n-    error_on_line_overflow: bool, true, false, \"Error if unable to get all lines within max_width\";\n-    error_on_unformatted: bool, false, false,\n-        \"Error if unable to get comments or string literals within max_width, \\\n-         or they are left with trailing whitespaces\";\n-    report_todo: ReportTactic, ReportTactic::Never, false,\n-        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n-    report_fixme: ReportTactic, ReportTactic::Never, false,\n-        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n-\n-    // Not user-facing.\n-    verbose: bool, false, false, \"Use verbose output\";\n-    file_lines: FileLines, FileLines::all(), false,\n-        \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n-         via the --file-lines option\";\n-    width_heuristics: WidthHeuristics, WidthHeuristics::default(), false,\n-        \"'small' heuristic values\";\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Config;\n-\n-    #[test]\n-    fn test_config_set() {\n-        let mut config = Config::default();\n-        config.set().verbose(false);\n-        assert_eq!(config.verbose(), false);\n-        config.set().verbose(true);\n-        assert_eq!(config.verbose(), true);\n-    }\n-\n-    #[test]\n-    fn test_config_used_to_toml() {\n-        let config = Config::default();\n-\n-        let merge_derives = config.merge_derives();\n-        let skip_children = config.skip_children();\n-\n-        let used_options = config.used_options();\n-        let toml = used_options.to_toml().unwrap();\n-        assert_eq!(\n-            toml,\n-            format!(\n-                \"merge_derives = {}\\nskip_children = {}\\n\",\n-                merge_derives, skip_children,\n-            )\n-        );\n-    }\n-\n-    #[test]\n-    fn test_was_set() {\n-        let config = Config::from_toml(\"hard_tabs = true\").unwrap();\n-\n-        assert_eq!(config.was_set().hard_tabs(), true);\n-        assert_eq!(config.was_set().verbose(), false);\n-    }\n-\n-    // FIXME(#2183) these tests cannot be run in parallel because they use env vars\n-    // #[test]\n-    // fn test_as_not_nightly_channel() {\n-    //     let mut config = Config::default();\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    // }\n-\n-    // #[test]\n-    // fn test_as_nightly_channel() {\n-    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n-    //     let mut config = Config::default();\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     config.set().unstable_features(true);\n-    //     assert_eq!(config.unstable_features(), true);\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n-    // }\n-\n-    // #[test]\n-    // fn test_unstable_from_toml() {\n-    //     let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n-    //     assert_eq!(config.was_set().unstable_features(), false);\n-    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n-    //     config = Config::from_toml(\"unstable_features = true\").unwrap();\n-    //     assert_eq!(config.was_set().unstable_features(), true);\n-    //     assert_eq!(config.unstable_features(), true);\n-    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n-    // }\n-}"}]}