{"sha": "c86df3a65cc239fd69b9a8d628808498cdb07e0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NmRmM2E2NWNjMjM5ZmQ2OWI5YThkNjI4ODA4NDk4Y2RiMDdlMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T19:02:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-29T19:02:05Z"}, "message": "auto merge of #7342 : alexcrichton/rust/assort-cleanup, r=cmr\n\nThis removes usage of `&const` throughout the standard libraries/compiler, and it removes some extraneous fields in the AST now that unique boxes always inherit their mutability.", "tree": {"sha": "b2557de482d3c0946cd683bd92dff65a1adf15f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2557de482d3c0946cd683bd92dff65a1adf15f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c86df3a65cc239fd69b9a8d628808498cdb07e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c86df3a65cc239fd69b9a8d628808498cdb07e0d", "html_url": "https://github.com/rust-lang/rust/commit/c86df3a65cc239fd69b9a8d628808498cdb07e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c86df3a65cc239fd69b9a8d628808498cdb07e0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88830996d811be3ff833ba590c98f28daaf31f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/88830996d811be3ff833ba590c98f28daaf31f43", "html_url": "https://github.com/rust-lang/rust/commit/88830996d811be3ff833ba590c98f28daaf31f43"}, {"sha": "3bad7129ebb13d7a4c0a7965aeb5bd536cc0f5f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bad7129ebb13d7a4c0a7965aeb5bd536cc0f5f0", "html_url": "https://github.com/rust-lang/rust/commit/3bad7129ebb13d7a4c0a7965aeb5bd536cc0f5f0"}], "stats": {"total": 300, "additions": 135, "deletions": 165}, "files": [{"sha": "13d159d8fed33ddc7511b9fff7f5034b9f5ed2aa", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -436,8 +436,8 @@ impl<T:Freeze + Send> RWARC<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Freeze + Send>(state: *const RWARCInner<T>) -> *RWlock {\n-    unsafe { cast::transmute(&const (*state).lock) }\n+fn borrow_rwlock<T:Freeze + Send>(state: *mut RWARCInner<T>) -> *RWlock {\n+    unsafe { cast::transmute(&(*state).lock) }\n }\n \n /// The \"write permission\" token used for RWARC.write_downgrade()."}, {"sha": "92ee3fb43c688ba585ca3626f3388a9bba8225dd", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -705,8 +705,8 @@ impl cmp::Eq for BitvSet {\n }\n \n impl Container for BitvSet {\n-    fn len(&const self) -> uint { self.size }\n-    fn is_empty(&const self) -> bool { self.size == 0 }\n+    fn len(&self) -> uint { self.size }\n+    fn is_empty(&self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {"}, {"sha": "cf7b188cb1d9291961c894539c6b52a0c422bf67", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -28,10 +28,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    fn len(&const self) -> uint { self.nelts }\n+    fn len(&self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {"}, {"sha": "fe8f4bee75e762941264f5f609a1f7237bfb45f4", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -44,8 +44,8 @@ static lz_fast : c_int = 0x1;   // LZ with only one probe\n static lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n-pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -62,8 +62,8 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res ="}, {"sha": "fcee3a2b796847cccd16bd70efd3131854c94652", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -87,10 +87,10 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint { self.length }\n+    fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.root.is_none() }\n+    fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -265,11 +265,11 @@ impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline]\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {"}, {"sha": "b08186349319dae602073a72c16dffaf862c9bf5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -786,7 +786,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n         's' => { return ast::sty_static; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n-        '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n+        '~' => { return ast::sty_uniq; }\n         '&' => {\n             // FIXME(#4846) expl. region\n             return ast::sty_region(None, get_mutability(string[1]));"}, {"sha": "7735a7e39561f13cb872abf54bcf68738a682b6c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -630,9 +630,8 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explic\n             ebml_w.writer.write(&[ '@' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_uniq(m) => {\n+        sty_uniq => {\n             ebml_w.writer.write(&[ '~' as u8 ]);\n-            encode_mutability(ebml_w, m);\n         }\n     }\n "}, {"sha": "8ad61fe1f61cd0f535c1a8355234674bdc54af00", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -92,7 +92,7 @@ pub fn check_expr(sess: Session,\n     if is_const {\n         match e.node {\n           expr_unary(_, deref, _) => { }\n-          expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) => {\n+          expr_unary(_, box(_), _) | expr_unary(_, uniq, _) => {\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             return;"}, {"sha": "b167a22992cf17d792a5a053ddc13ef6d9f13a09", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -152,122 +152,122 @@ impl LanguageItems {\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn freeze_trait(&const self) -> def_id {\n+    pub fn freeze_trait(&self) -> def_id {\n         self.items[FreezeTraitLangItem as uint].get()\n     }\n-    pub fn copy_trait(&const self) -> def_id {\n+    pub fn copy_trait(&self) -> def_id {\n         self.items[CopyTraitLangItem as uint].get()\n     }\n-    pub fn send_trait(&const self) -> def_id {\n+    pub fn send_trait(&self) -> def_id {\n         self.items[SendTraitLangItem as uint].get()\n     }\n-    pub fn sized_trait(&const self) -> def_id {\n+    pub fn sized_trait(&self) -> def_id {\n         self.items[SizedTraitLangItem as uint].get()\n     }\n \n-    pub fn drop_trait(&const self) -> def_id {\n+    pub fn drop_trait(&self) -> def_id {\n         self.items[DropTraitLangItem as uint].get()\n     }\n \n-    pub fn add_trait(&const self) -> def_id {\n+    pub fn add_trait(&self) -> def_id {\n         self.items[AddTraitLangItem as uint].get()\n     }\n-    pub fn sub_trait(&const self) -> def_id {\n+    pub fn sub_trait(&self) -> def_id {\n         self.items[SubTraitLangItem as uint].get()\n     }\n-    pub fn mul_trait(&const self) -> def_id {\n+    pub fn mul_trait(&self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn div_trait(&const self) -> def_id {\n+    pub fn div_trait(&self) -> def_id {\n         self.items[DivTraitLangItem as uint].get()\n     }\n-    pub fn rem_trait(&const self) -> def_id {\n+    pub fn rem_trait(&self) -> def_id {\n         self.items[RemTraitLangItem as uint].get()\n     }\n-    pub fn neg_trait(&const self) -> def_id {\n+    pub fn neg_trait(&self) -> def_id {\n         self.items[NegTraitLangItem as uint].get()\n     }\n-    pub fn not_trait(&const self) -> def_id {\n+    pub fn not_trait(&self) -> def_id {\n         self.items[NotTraitLangItem as uint].get()\n     }\n-    pub fn bitxor_trait(&const self) -> def_id {\n+    pub fn bitxor_trait(&self) -> def_id {\n         self.items[BitXorTraitLangItem as uint].get()\n     }\n-    pub fn bitand_trait(&const self) -> def_id {\n+    pub fn bitand_trait(&self) -> def_id {\n         self.items[BitAndTraitLangItem as uint].get()\n     }\n-    pub fn bitor_trait(&const self) -> def_id {\n+    pub fn bitor_trait(&self) -> def_id {\n         self.items[BitOrTraitLangItem as uint].get()\n     }\n-    pub fn shl_trait(&const self) -> def_id {\n+    pub fn shl_trait(&self) -> def_id {\n         self.items[ShlTraitLangItem as uint].get()\n     }\n-    pub fn shr_trait(&const self) -> def_id {\n+    pub fn shr_trait(&self) -> def_id {\n         self.items[ShrTraitLangItem as uint].get()\n     }\n-    pub fn index_trait(&const self) -> def_id {\n+    pub fn index_trait(&self) -> def_id {\n         self.items[IndexTraitLangItem as uint].get()\n     }\n \n-    pub fn eq_trait(&const self) -> def_id {\n+    pub fn eq_trait(&self) -> def_id {\n         self.items[EqTraitLangItem as uint].get()\n     }\n-    pub fn ord_trait(&const self) -> def_id {\n+    pub fn ord_trait(&self) -> def_id {\n         self.items[OrdTraitLangItem as uint].get()\n     }\n \n-    pub fn str_eq_fn(&const self) -> def_id {\n+    pub fn str_eq_fn(&self) -> def_id {\n         self.items[StrEqFnLangItem as uint].get()\n     }\n-    pub fn uniq_str_eq_fn(&const self) -> def_id {\n+    pub fn uniq_str_eq_fn(&self) -> def_id {\n         self.items[UniqStrEqFnLangItem as uint].get()\n     }\n-    pub fn annihilate_fn(&const self) -> def_id {\n+    pub fn annihilate_fn(&self) -> def_id {\n         self.items[AnnihilateFnLangItem as uint].get()\n     }\n-    pub fn log_type_fn(&const self) -> def_id {\n+    pub fn log_type_fn(&self) -> def_id {\n         self.items[LogTypeFnLangItem as uint].get()\n     }\n-    pub fn fail_fn(&const self) -> def_id {\n+    pub fn fail_fn(&self) -> def_id {\n         self.items[FailFnLangItem as uint].get()\n     }\n-    pub fn fail_bounds_check_fn(&const self) -> def_id {\n+    pub fn fail_bounds_check_fn(&self) -> def_id {\n         self.items[FailBoundsCheckFnLangItem as uint].get()\n     }\n-    pub fn exchange_malloc_fn(&const self) -> def_id {\n+    pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n-    pub fn exchange_free_fn(&const self) -> def_id {\n+    pub fn exchange_free_fn(&self) -> def_id {\n         self.items[ExchangeFreeFnLangItem as uint].get()\n     }\n-    pub fn malloc_fn(&const self) -> def_id {\n+    pub fn malloc_fn(&self) -> def_id {\n         self.items[MallocFnLangItem as uint].get()\n     }\n-    pub fn free_fn(&const self) -> def_id {\n+    pub fn free_fn(&self) -> def_id {\n         self.items[FreeFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_imm_fn(&const self) -> def_id {\n+    pub fn borrow_as_imm_fn(&self) -> def_id {\n         self.items[BorrowAsImmFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_mut_fn(&const self) -> def_id {\n+    pub fn borrow_as_mut_fn(&self) -> def_id {\n         self.items[BorrowAsMutFnLangItem as uint].get()\n     }\n-    pub fn return_to_mut_fn(&const self) -> def_id {\n+    pub fn return_to_mut_fn(&self) -> def_id {\n         self.items[ReturnToMutFnLangItem as uint].get()\n     }\n-    pub fn check_not_borrowed_fn(&const self) -> def_id {\n+    pub fn check_not_borrowed_fn(&self) -> def_id {\n         self.items[CheckNotBorrowedFnLangItem as uint].get()\n     }\n-    pub fn strdup_uniq_fn(&const self) -> def_id {\n+    pub fn strdup_uniq_fn(&self) -> def_id {\n         self.items[StrDupUniqFnLangItem as uint].get()\n     }\n-    pub fn record_borrow_fn(&const self) -> def_id {\n+    pub fn record_borrow_fn(&self) -> def_id {\n         self.items[RecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn unrecord_borrow_fn(&const self) -> def_id {\n+    pub fn unrecord_borrow_fn(&self) -> def_id {\n         self.items[UnrecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn start_fn(&const self) -> def_id {\n+    pub fn start_fn(&self) -> def_id {\n         self.items[StartFnLangItem as uint].get()\n     }\n     pub fn ty_desc(&const self) -> def_id {"}, {"sha": "e431784f1e63ad3264ac35678455e601756d5353", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -368,7 +368,7 @@ fn visit_fn(fk: &visit::fn_kind,\n     match *fk {\n         fk_method(_, _, method) => {\n             match method.explicit_self.node {\n-                sty_value | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n+                sty_value | sty_region(*) | sty_box(_) | sty_uniq => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }"}, {"sha": "6780c51e5062aa6de6a677fb1f082da3a0330a5b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -340,7 +340,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n             let is_float = ty::type_is_fp(ty);\n             return match u {\n               ast::box(_)  |\n-              ast::uniq(_) |\n+              ast::uniq |\n               ast::deref  => {\n                 let (dv, _dt) = const_deref(cx, te, ty, true);\n                 dv"}, {"sha": "297a466c7cb0a19cc6a3f88f5df962aa459dae6e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -1314,7 +1314,7 @@ fn trans_unary_datum(bcx: block,\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty,\n                              heap_managed)\n         }\n-        ast::uniq(_) => {\n+        ast::uniq => {\n             let heap  = heap_for_unique(bcx, un_ty);\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap)\n         }"}, {"sha": "75e9dbe48619d4b953391aee8dfb34c4383b43e8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -532,7 +532,7 @@ pub fn trans_trait_callee(bcx: block,\n     let llpair = match explicit_self {\n         ast::sty_region(*) => Load(bcx, llpair),\n         ast::sty_static | ast::sty_value |\n-        ast::sty_box(_) | ast::sty_uniq(_) => llpair\n+        ast::sty_box(_) | ast::sty_uniq => llpair\n     };\n \n     let callee_ty = node_id_type(bcx, callee_id);\n@@ -622,7 +622,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n             self_mode = ty::ByRef;\n         }\n-        ast::sty_uniq(_) => {\n+        ast::sty_uniq => {\n             // Pass the unique pointer.\n             match store {\n                 ty::UniqTraitStore => llself = llbox,"}, {"sha": "d8d539764620367aef31a1b95d9304a8657bd8d0", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -278,7 +278,7 @@ pub fn mark_for_method_call(cx: &Context, e_id: node_id, callee_id: node_id) {\n pub fn mark_for_expr(cx: &Context, e: &expr) {\n     match e.node {\n       expr_vstore(_, _) | expr_vec(_, _) | expr_struct(*) | expr_tup(_) |\n-      expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) |\n+      expr_unary(_, box(_), _) | expr_unary(_, uniq, _) |\n       expr_binary(_, add, _, _) | expr_copy(_) | expr_repeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }"}, {"sha": "48e841353c084faae2417fb652318427c896a137", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -3696,14 +3696,14 @@ pub enum DtorKind {\n }\n \n impl DtorKind {\n-    pub fn is_not_present(&const self) -> bool {\n+    pub fn is_not_present(&self) -> bool {\n         match *self {\n             NoDtor => true,\n             _ => false\n         }\n     }\n \n-    pub fn is_present(&const self) -> bool {\n+    pub fn is_present(&self) -> bool {\n         !self.is_not_present()\n     }\n "}, {"sha": "1e236c620a0e52eb7e17a7a5e56f26de298c2bb2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -662,10 +662,10 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n                                 ty::mt {ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability}))\n             }\n-            ast::sty_uniq(mutability) => {\n+            ast::sty_uniq => {\n                 Some(ty::mk_uniq(this.tcx(),\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n-                                         mutbl: mutability}))\n+                                         mutbl: ast::m_imm}))\n             }\n         }\n     }"}, {"sha": "7489882ab768c01c137256cc782d762326832afe", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -1123,11 +1123,11 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n \n-            sty_uniq(m) => {\n+            sty_uniq => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n-                        mutability_matches(mt.mutbl, m) &&\n+                        mutability_matches(mt.mutbl, ast::m_imm) &&\n                         self.fcx.can_mk_subty(mt.ty, candidate.rcvr_ty).is_ok()\n                     }\n "}, {"sha": "0cd9aac379892c1904351921df16178be245c53a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -2301,7 +2301,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_unary(callee_id, unop, oprnd) => {\n         let exp_inner = do unpack_expected(fcx, expected) |sty| {\n             match unop {\n-              ast::box(_) | ast::uniq(_) => match *sty {\n+              ast::box(_) | ast::uniq => match *sty {\n                 ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n                 _ => None\n               },\n@@ -2318,9 +2318,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     oprnd_t = ty::mk_box(tcx,\n                                          ty::mt {ty: oprnd_t, mutbl: mutbl});\n                 }\n-                ast::uniq(mutbl) => {\n+                ast::uniq => {\n                     oprnd_t = ty::mk_uniq(tcx,\n-                                          ty::mt {ty: oprnd_t, mutbl: mutbl});\n+                                          ty::mt {ty: oprnd_t,\n+                                                  mutbl: ast::m_imm});\n                 }\n                 ast::deref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);"}, {"sha": "a46d2f28b1390f93593a375561e71c1700297d91", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -64,7 +64,7 @@ pub struct VtableContext {\n }\n \n impl VtableContext {\n-    pub fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n+    pub fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {"}, {"sha": "325ce097cd5a0f0407680699ba1860efd2d4e51c", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -108,7 +108,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n+pub fn append<T:Copy>(lhs: @[T], rhs: &[T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for lhs.iter().advance |x| { push(copy *x); }\n         for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n@@ -180,9 +180,9 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<'self,T:Copy> Add<&'self const [T],@[T]> for @[T] {\n+    impl<'self,T:Copy> Add<&'self [T],@[T]> for @[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self const [T]) -> @[T] {\n+        fn add(&self, rhs: & &'self [T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }"}, {"sha": "35db229b65d304bf5d04cf14a37e35d3a6b7d4ac", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -282,10 +282,10 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint { self.size }\n+    fn len(&self) -> uint { self.size }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n@@ -623,10 +623,10 @@ impl<T:Hash + Eq> Eq for HashSet<T> {\n \n impl<T:Hash + Eq> Container for HashSet<T> {\n     /// Return the number of elements in the set\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T:Hash + Eq> Mutable for HashSet<T> {"}, {"sha": "40793ff1af7b16e4f1e8fbe962df8f7429338528", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -1152,7 +1152,7 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n-            do vec::as_const_buf(v) |vbuf, len| {\n+            do vec::as_imm_buf(v) |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n                                         1,\n                                         len as size_t,\n@@ -1203,9 +1203,9 @@ impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n-            do vec::as_const_buf(v) |vbuf, len| {\n+            do vec::as_imm_buf(v) |vbuf, len| {\n                 while count < len {\n-                    let vb = ptr::const_offset(vbuf, count) as *c_void;\n+                    let vb = ptr::offset(vbuf, count) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);\n                     if nout < 0 as ssize_t {\n                         error!(\"error writing buffer\");"}, {"sha": "643812312582e30d33bdb66713f52ac133e329e3", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -121,13 +121,13 @@ impl<T> Option<T> {\n \n     /// Returns true if the option equals `none`\n     #[inline]\n-    pub fn is_none(&const self) -> bool {\n+    pub fn is_none(&self) -> bool {\n         match *self { None => true, Some(_) => false }\n     }\n \n     /// Returns true if the option contains some value\n     #[inline]\n-    pub fn is_some(&const self) -> bool { !self.is_none() }\n+    pub fn is_some(&self) -> bool { !self.is_none() }\n \n     /// Update an optional value by optionally running its content through a\n     /// function that returns an option."}, {"sha": "473f56ddd7984f1bfea0846210ff7a31f1aaea8e", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -232,21 +232,21 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n \n #[allow(missing_doc)]\n pub trait RawPtr<T> {\n-    fn is_null(&const self) -> bool;\n-    fn is_not_null(&const self) -> bool;\n-    unsafe fn to_option(&const self) -> Option<&T>;\n+    fn is_null(&self) -> bool;\n+    fn is_not_null(&self) -> bool;\n+    unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -259,7 +259,7 @@ impl<T> RawPtr<T> for *T {\n     /// be pointing to invalid memory.\n     ///\n     #[inline]\n-    unsafe fn to_option(&const self) -> Option<&T> {\n+    unsafe fn to_option(&self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n@@ -274,11 +274,11 @@ impl<T> RawPtr<T> for *T {\n impl<T> RawPtr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -291,7 +291,7 @@ impl<T> RawPtr<T> for *mut T {\n     /// be pointing to invalid memory.\n     ///\n     #[inline]\n-    unsafe fn to_option(&const self) -> Option<&T> {\n+    unsafe fn to_option(&self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }"}, {"sha": "a06d858e4243b4985f86e9ec6fe6eb1c805be83d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -569,7 +569,7 @@ Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pub fn is_utf8(v: &const [u8]) -> bool {\n+pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = v.len();\n     while i < total {\n@@ -815,7 +815,7 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::copy_memory(vbuf, buf as *u8, len)\n@@ -838,8 +838,8 @@ pub mod raw {\n     }\n \n     /// Converts a vector of bytes to a new owned string.\n-    pub unsafe fn from_bytes(v: &const [u8]) -> ~str {\n-        do vec::as_const_buf(v) |buf, len| {\n+    pub unsafe fn from_bytes(v: &[u8]) -> ~str {\n+        do vec::as_imm_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }"}, {"sha": "190485a720aa726e849d0ad4476656cdc19a0e9d", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -129,7 +129,7 @@ type TaskGroupInner<'self> = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n-    (&const tg.members).is_empty()\n+    tg.members.is_empty()\n }\n \n // A list-like structure by which taskgroups keep track of all ancestor groups"}, {"sha": "8ce02d59ab15c6fab53db596d02086147da8da9e", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -35,11 +35,11 @@ pub struct TrieMap<T> {\n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline]\n-    fn len(&const self) -> uint { self.length }\n+    fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n@@ -179,11 +179,11 @@ pub struct TrieSet {\n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline]\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {"}, {"sha": "4196fbac0beb5a7bc391784364858dc75d09f54d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -64,7 +64,7 @@ pub mod rustrt {\n }\n \n /// Returns true if two vectors have the same length\n-pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n+pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n     xs.len() == ys.len()\n }\n \n@@ -350,10 +350,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n         if v.len() < 1 { return; }\n         let mut last_written = 0;\n         let mut next_to_read = 1;\n-        do as_const_buf(*v) |p, ln| {\n-            // We have a mutable reference to v, so we can make arbitrary\n-            // changes. (cf. push and pop)\n-            let p = p as *mut T;\n+        do as_mut_buf(*v) |p, ln| {\n             // last_written < next_to_read <= ln\n             while next_to_read < ln {\n                 // last_written < next_to_read < ln\n@@ -384,7 +381,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n+pub fn append<T:Copy>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n     v\n@@ -831,7 +828,7 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n+pub fn zip_slice<T:Copy,U:Copy>(v: &[T], u: &[U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = v.len();\n@@ -893,7 +890,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n+pub fn reversed<T:Copy>(v: &[T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = v.len();\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1003,16 +1000,6 @@ pub fn as_imm_buf<T,U>(s: &[T],\n     }\n }\n \n-/// Similar to `as_imm_buf` but passing a `*const T`\n-#[inline]\n-pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*const T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n-    }\n-}\n-\n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n@@ -1198,39 +1185,39 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<'self,T:Copy> Add<&'self const [T],~[T]> for ~[T] {\n+    impl<'self,T:Copy> Add<&'self [T],~[T]> for ~[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self const [T]) -> ~[T] {\n+        fn add(&self, rhs: & &'self [T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<'self, T> Container for &'self const [T] {\n+impl<'self, T> Container for &'self [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_const_buf(*self, |_p, len| len == 0u)\n+        as_imm_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_const_buf(*self, |_p, len| len)\n+        as_imm_buf(*self, |_p, len| len)\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_const_buf(*self, |_p, len| len == 0u)\n+        as_imm_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_const_buf(*self, |_p, len| len)\n+        as_imm_buf(*self, |_p, len| len)\n     }\n }\n \n@@ -1843,7 +1830,7 @@ impl<T> Mutable for ~[T] {\n \n #[allow(missing_doc)]\n pub trait OwnedCopyableVector<T:Copy> {\n-    fn push_all(&mut self, rhs: &const [T]);\n+    fn push_all(&mut self, rhs: &[T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n@@ -1860,7 +1847,7 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     /// assert!(a == ~[1, 2, 3, 4]);\n     /// ~~~\n     #[inline]\n-    fn push_all(&mut self, rhs: &const [T]) {\n+    fn push_all(&mut self, rhs: &[T]) {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n \n@@ -2017,7 +2004,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, with_capacity};\n+    use vec::{UnboxedVecRepr, as_imm_buf, as_mut_buf, with_capacity};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -2065,15 +2052,6 @@ pub mod raw {\n         }\n     }\n \n-    /** see `to_ptr()` */\n-    #[inline]\n-    pub fn to_const_ptr<T>(v: &const [T]) -> *const T {\n-        unsafe {\n-            let repr: **SliceRepr = transmute(&v);\n-            transmute(&((**repr).data))\n-        }\n-    }\n-\n     /** see `to_ptr()` */\n     #[inline]\n     pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n@@ -2113,8 +2091,8 @@ pub mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline]\n-    pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n-        as_const_buf(v, |p, _len| copy *ptr::const_offset(p, i))\n+    pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n+        as_imm_buf(v, |p, _len| copy *ptr::offset(p, i))\n     }\n \n     /**\n@@ -2156,13 +2134,13 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[T],\n                                  count: uint) {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n-            do as_const_buf(src) |p_src, _len_src| {\n+            do as_imm_buf(src) |p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n@@ -2238,7 +2216,7 @@ pub mod bytes {\n       * may overlap.\n       */\n     #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &const [u8], count: uint) {\n+    pub fn copy_memory(dst: &mut [u8], src: &[u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n@@ -3690,16 +3668,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_as_const_buf_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_const_buf(v) |_buf, _i| {\n-            fail!()\n-        }\n-    }\n-\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]"}, {"sha": "2603cbb2dd7c519c91f1db72e27b8606b76a87b5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -333,7 +333,7 @@ pub enum binop {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum unop {\n     box(mutability),\n-    uniq(mutability),\n+    uniq,\n     deref,\n     not,\n     neg\n@@ -805,7 +805,7 @@ pub enum explicit_self_ {\n     sty_value,                                 // `self`\n     sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n     sty_box(mutability),                       // `@self`\n-    sty_uniq(mutability)                       // `~self`\n+    sty_uniq                                   // `~self`\n }\n \n pub type explicit_self = spanned<explicit_self_>;"}, {"sha": "ee7c7180f8db2d3e5ca1a8c3b4706eca3d7d19e9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -135,7 +135,7 @@ pub fn is_shift_binop(b: binop) -> bool {\n pub fn unop_to_str(op: unop) -> ~str {\n     match op {\n       box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n-      uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n+      uniq => ~\"~\",\n       deref => ~\"*\",\n       not => ~\"!\",\n       neg => ~\"-\""}, {"sha": "e210853bfb4dcbd886290b1bb3bf753f119d5ef8", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -248,7 +248,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::sty_uniq(ast::m_imm),\n+                    Send => ast::sty_uniq,\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| @cx.lifetime(span,"}, {"sha": "cc0baa28e20d75a076ffafcc53c7d2102ca7f2e9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -2071,9 +2071,8 @@ impl Parser {\n             ex = match e.node {\n               expr_vec(*) |\n               expr_lit(@codemap::spanned { node: lit_str(_), span: _}) |\n-              expr_repeat(*)\n-              if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n-              _ => self.mk_unary(uniq(m), e)\n+              expr_repeat(*) => expr_vstore(e, expr_vstore_uniq),\n+              _ => self.mk_unary(uniq, e)\n             };\n           }\n           _ => return self.parse_dot_or_call_expr()\n@@ -3366,7 +3365,12 @@ impl Parser {\n             maybe_parse_explicit_self(sty_box, self)\n           }\n           token::TILDE => {\n-            maybe_parse_explicit_self(sty_uniq, self)\n+            maybe_parse_explicit_self(|mutability| {\n+                if mutability != m_imm {\n+                    self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+                }\n+                sty_uniq\n+            }, self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();"}, {"sha": "978561eaa67c6056fec39ee0524f8d675c931fae", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86df3a65cc239fd69b9a8d628808498cdb07e0d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c86df3a65cc239fd69b9a8d628808498cdb07e0d", "patch": "@@ -1653,6 +1653,7 @@ pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n     match explicit_self {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, \"self\"); }\n+        ast::sty_uniq => { word(s.s, \"~self\"); }\n         ast::sty_region(lt, m) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, lt);\n@@ -1662,9 +1663,6 @@ pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n         ast::sty_box(m) => {\n             word(s.s, \"@\"); print_mutability(s, m); word(s.s, \"self\");\n         }\n-        ast::sty_uniq(m) => {\n-            word(s.s, \"~\"); print_mutability(s, m); word(s.s, \"self\");\n-        }\n     }\n     return true;\n }"}]}