{"sha": "57e0908af395af1c10e28600b785b5366a43660c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZTA5MDhhZjM5NWFmMWMxMGUyODYwMGI3ODViNTM2NmE0MzY2MGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-02T08:19:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-03T20:43:45Z"}, "message": "syntax: Remove AbiSet, use one Abi\n\nThis change removes the AbiSet from the AST, converting all usage to have just\none Abi value. The current scheme selects a relevant ABI given a list of ABIs\nbased on the target architecture and how relevant each ABI is to that\narchitecture.\n\nInstead of this mildly complicated scheme, only one ABI will be allowed in abi\nstrings, and pseudo-abis will be created for special cases as necessary. For\nexample the \"system\" abi exists for stdcall on win32 and C on win64.\n\nCloses #10049", "tree": {"sha": "c872d85d99734e7e12369f3b00e7ee81f8866b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c872d85d99734e7e12369f3b00e7ee81f8866b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e0908af395af1c10e28600b785b5366a43660c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e0908af395af1c10e28600b785b5366a43660c", "html_url": "https://github.com/rust-lang/rust/commit/57e0908af395af1c10e28600b785b5366a43660c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e0908af395af1c10e28600b785b5366a43660c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1c47b91824bae040ddc2d799e14365b5415762", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1c47b91824bae040ddc2d799e14365b5415762", "html_url": "https://github.com/rust-lang/rust/commit/1a1c47b91824bae040ddc2d799e14365b5415762"}], "stats": {"total": 665, "additions": 205, "deletions": 460}, "files": [{"sha": "cfbe772a165db032ed4596f701f5511e24300054", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -90,7 +90,7 @@ fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n     ast::ForeignMod {\n-        abis: nm.abis,\n+        abi: nm.abi,\n         view_items: filtered_view_items,\n         items: filtered_items\n     }"}, {"sha": "d957850264681d5c00f730fc221d0124ac4359c2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -187,7 +187,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n fn visit_item(e: &Env, i: &ast::Item) {\n     match i.node {\n         ast::ItemForeignMod(ref fm) => {\n-            if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n+            if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n                 return;\n             }\n "}, {"sha": "ec6bb7de380f88fc6a5e9e9602cbe934f38d9980", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -33,7 +33,7 @@ use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n use collections::HashMap;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathElems};\n@@ -1217,7 +1217,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 nitem: &ForeignItem,\n                                 index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n-                                abi: AbiSet) {\n+                                abi: abi::Abi) {\n     index.borrow_mut().push(entry {\n         val: nitem.id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n@@ -1231,7 +1231,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ebml_w, nitem.ident.name);\n-        if abi.is_intrinsic() {\n+        if abi == abi::RustIntrinsic {\n             (ecx.encode_inlined_item)(ecx, ebml_w, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n@@ -1279,11 +1279,11 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n     let mut ebml_w = unsafe {\n         ebml_w.unsafe_clone()\n     };\n-    let abis = ecx.tcx.map.get_foreign_abis(ni.id);\n+    let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n         encode_info_for_foreign_item(ecx, &mut ebml_w,\n                                      ni, index,\n-                                     path, abis);\n+                                     path, abi);\n     });\n }\n "}, {"sha": "409957b8625d531e9b8ab080d22f3c34fcd88823", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -20,7 +20,6 @@ use middle::ty;\n \n use std::str;\n use std::uint;\n-use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n@@ -460,18 +459,12 @@ fn parse_purity(c: char) -> Purity {\n     }\n }\n \n-fn parse_abi_set(st: &mut PState) -> AbiSet {\n+fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n-    let mut abis = AbiSet::empty();\n-    while peek(st) != ']' {\n-         scan(st, |c| c == ',', |bytes| {\n-                 let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n-                 let abi = abi::lookup(abi_str).expect(abi_str);\n-                 abis.add(abi);\n-              });\n-    }\n-    assert_eq!(next(st), ']');\n-    return abis;\n+    scan(st, |c| c == ']', |bytes| {\n+        let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n+        abi::lookup(abi_str).expect(abi_str)\n+    })\n }\n \n fn parse_onceness(c: char) -> ast::Onceness {\n@@ -505,7 +498,7 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::BareFnTy {\n         purity: purity,\n-        abis: abi,\n+        abi: abi,\n         sig: sig\n     }\n }"}, {"sha": "4053db72a28cd31ffafec5c29684351538f6ad66", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use middle::ty::param_ty;\n use middle::ty;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n@@ -341,12 +341,9 @@ fn enc_purity(w: &mut MemWriter, p: Purity) {\n     }\n }\n \n-fn enc_abi_set(w: &mut MemWriter, abis: AbiSet) {\n+fn enc_abi(w: &mut MemWriter, abi: Abi) {\n     mywrite!(w, \"[\");\n-    abis.each(|abi| {\n-        mywrite!(w, \"{},\", abi.name());\n-        true\n-    });\n+    mywrite!(w, \"{}\", abi.name());\n     mywrite!(w, \"]\")\n }\n \n@@ -359,7 +356,7 @@ fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n \n pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n-    enc_abi_set(w, ft.abis);\n+    enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n "}, {"sha": "da74d0c7729e6f1727076a835132c58db21efcc6", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -59,6 +59,7 @@ use std::u32;\n use std::u64;\n use std::u8;\n use collections::SmallIntMap;\n+use syntax::abi;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::{AttrMetaMethods, AttributeMethods};\n@@ -892,7 +893,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n     }\n \n     match it.node {\n-      ast::ItemForeignMod(ref nmod) if !nmod.abis.is_intrinsic() => {\n+      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n                 ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),"}, {"sha": "09bbb95fdd04e29ca825434ff1d3c9b8abe245c3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -855,8 +855,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            match fn_ty.abis.for_target(ccx.sess().targ_cfg.os,\n-                                        ccx.sess().targ_cfg.arch) {\n+            match fn_ty.abi.for_target(ccx.sess().targ_cfg.os,\n+                                       ccx.sess().targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n                     get_extern_rust_fn(ccx,\n                                        fn_ty.sig.inputs.as_slice(),\n@@ -865,7 +865,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                                        did)\n                 }\n                 Some(..) | None => {\n-                    let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n+                    let c = foreign::llvm_calling_convention(ccx, fn_ty.abi);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n                     get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod,\n@@ -1601,7 +1601,7 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n-      ast::ItemFn(decl, purity, _abis, ref generics, body) => {\n+      ast::ItemFn(decl, purity, _abi, ref generics, body) => {\n         if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n@@ -1721,7 +1721,7 @@ fn register_fn(ccx: &CrateContext,\n                -> ValueRef {\n     let f = match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            assert!(f.abi == Rust || f.abi == RustIntrinsic);\n             f\n         }\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n@@ -1997,8 +1997,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n-                    let abis = ccx.tcx.map.get_foreign_abis(id);\n-                    foreign::register_foreign_item_fn(ccx, abis, ni)\n+                    let abi = ccx.tcx.map.get_foreign_abi(id);\n+                    foreign::register_foreign_item_fn(ccx, abi, ni)\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, ni)"}, {"sha": "13fcaa486f172296db41c16f41034d5f79a903ce", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -50,7 +50,7 @@ use util::ppaux::Repr;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n-use syntax::abi::AbiSet;\n+use synabi = syntax::abi;\n use syntax::ast_map;\n \n pub struct MethodData {\n@@ -363,7 +363,7 @@ pub fn trans_fn_ref_with_vtables(\n \n         match map_node {\n             ast_map::NodeForeignItem(_) => {\n-                tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n+                tcx.map.get_foreign_abi(def_id.node) == synabi::RustIntrinsic\n             }\n             _ => false\n         }\n@@ -572,13 +572,11 @@ pub fn trans_call_inner<'a>(\n     };\n \n     let (abi, ret_ty) = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) => (f.abis, f.sig.output),\n-        ty::ty_closure(ref f) => (AbiSet::Rust(), f.sig.output),\n+        ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n+        ty::ty_closure(ref f) => (synabi::Rust, f.sig.output),\n         _ => fail!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n-    let is_rust_fn =\n-        abi.is_rust() ||\n-        abi.is_intrinsic();\n+    let is_rust_fn = abi == synabi::Rust || abi == synabi::RustIntrinsic;\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot."}, {"sha": "e70d7bf7568a8880773e9b0f1431b1fd654d5308", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -27,7 +27,7 @@ use middle::ty::FnSig;\n use middle::ty;\n use std::cmp;\n use std::libc::c_uint;\n-use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n+use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n@@ -73,10 +73,10 @@ struct LlvmSignature {\n // Calls to external functions\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n-                               abis: AbiSet) -> Option<CallConv> {\n+                               abi: Abi) -> Option<CallConv> {\n     let os = ccx.sess().targ_cfg.os;\n     let arch = ccx.sess().targ_cfg.arch;\n-    abis.for_target(os, arch).map(|abi| {\n+    abi.for_target(os, arch).map(|abi| {\n         match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n@@ -180,27 +180,27 @@ pub fn register_static(ccx: &CrateContext,\n     }\n }\n \n-pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n+pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi,\n                                 foreign_item: &ast::ForeignItem) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n      */\n \n-    debug!(\"register_foreign_item_fn(abis={}, \\\n+    debug!(\"register_foreign_item_fn(abi={}, \\\n             path={}, \\\n             foreign_item.id={})\",\n-           abis.repr(ccx.tcx()),\n+           abi.repr(ccx.tcx()),\n            ccx.tcx.map.path_to_str(foreign_item.id),\n            foreign_item.id);\n \n-    let cc = match llvm_calling_convention(ccx, abis) {\n+    let cc = match llvm_calling_convention(ccx, abi) {\n         Some(cc) => cc,\n         None => {\n             ccx.sess().span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable calling convention \\\n                       for target architecture\",\n-                      abis.user_string(ccx.tcx())));\n+                      abi.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -263,8 +263,8 @@ pub fn trans_native_call<'a>(\n            ccx.tn.val_to_str(llfn),\n            ccx.tn.val_to_str(llretptr));\n \n-    let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n+    let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n@@ -354,14 +354,14 @@ pub fn trans_native_call<'a>(\n         llargs_foreign.push(llarg_foreign);\n     }\n \n-    let cc = match llvm_calling_convention(ccx, fn_abis) {\n+    let cc = match llvm_calling_convention(ccx, fn_abi) {\n         Some(cc) => cc,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n                         for target architecture\",\n-                        fn_abis.user_string(ccx.tcx())));\n+                        fn_abi.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -435,9 +435,9 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {\n-                let abis = foreign_mod.abis;\n-                if !(abis.is_rust() || abis.is_intrinsic()) {\n-                    register_foreign_item_fn(ccx, abis, foreign_item);\n+                match foreign_mod.abi {\n+                    Rust | RustIntrinsic => {}\n+                    abi => { register_foreign_item_fn(ccx, abi, foreign_item); }\n                 }\n             }\n             _ => {}\n@@ -486,7 +486,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let (cconv, output) = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let c = llvm_calling_convention(ccx, fn_ty.abis);\n+            let c = llvm_calling_convention(ccx, fn_ty.abi);\n             (c.unwrap_or(lib::llvm::CCallConv), fn_ty.sig.output)\n         }\n         _ => fail!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -534,7 +534,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // normal Rust function. This will be the type of the wrappee fn.\n         let f = match ty::get(t).sty {\n             ty::ty_bare_fn(ref f) => {\n-                assert!(!f.abis.is_rust() && !f.abis.is_intrinsic());\n+                assert!(f.abi != Rust && f.abi != RustIntrinsic);\n                 f\n             }\n             _ => {"}, {"sha": "851f8207cb68b79647cda2c2e10214586198ca71", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -34,6 +34,7 @@ use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use syntax::abi::Rust;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n \n@@ -393,7 +394,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or ~Self) with an opaque pointer.\n     let llcallee_ty = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) if f.abis.is_rust() => {\n+        ty::ty_bare_fn(ref f) if f.abi == Rust => {\n             type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n         }\n         _ => {"}, {"sha": "6f2dbc182b04f3000852d8196b3af4cbbef87bd5", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n+use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -99,7 +100,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     match map_node {\n         ast_map::NodeForeignItem(_) => {\n-            if !ccx.tcx.map.get_foreign_abis(fn_id.node).is_intrinsic() {\n+            if ccx.tcx.map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n                 // Foreign externs don't have to be monomorphized.\n                 return (get_item_val(ccx, fn_id.node), true);\n             }\n@@ -150,7 +151,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let f = match ty::get(mono_ty).sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            assert!(f.abi == abi::Rust || f.abi == abi::RustIntrinsic);\n             f\n         }\n         _ => fail!(\"expected bare rust fn or an intrinsic\")"}, {"sha": "f45ef45720483deb273d75be39d8e8e3a2bbf59b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -19,6 +19,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n \n@@ -75,7 +76,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n             type_of_rust_fn(cx, true, f.sig.inputs.as_slice(), f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n-            if f.abis.is_rust() || f.abis.is_intrinsic() {\n+            if f.abi == abi::Rust || f.abi == abi::RustIntrinsic {\n                 type_of_rust_fn(cx,\n                                 false,\n                                 f.sig.inputs.as_slice(),"}, {"sha": "85d47424e2b9ace93dbee763429e76c4c8850222", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -51,7 +51,7 @@ use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax;\n use collections::enum_set::{EnumSet, CLike};\n \n@@ -416,8 +416,8 @@ pub fn type_id(t: t) -> uint { get(t).id }\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct BareFnTy {\n     pub purity: ast::Purity,\n-    pub abis: AbiSet,\n-    pub sig: FnSig\n+    pub abi: abi::Abi,\n+    pub sig: FnSig,\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n@@ -796,7 +796,7 @@ pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<Purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n-    terr_abi_mismatch(expected_found<AbiSet>),\n+    terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n     terr_sigil_mismatch(expected_found<ast::Sigil>),\n     terr_box_mutability,\n@@ -1409,7 +1409,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::ImpureFn,\n-                   abis: AbiSet::Rust(),\n+                   abi: abi::Rust,\n                    sig: FnSig {\n                     binder_id: binder_id,\n                     inputs: input_args,\n@@ -4677,7 +4677,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_bare_fn(ref b) => {\n                 byte!(14);\n                 hash!(b.purity);\n-                hash!(b.abis);\n+                hash!(b.abi);\n             }\n             ty_closure(ref c) => {\n                 byte!(15);"}, {"sha": "02c4ffe68c1ee3f1c8e241a158c77d7529f29249", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -48,7 +48,7 @@ pub trait TypeFolder {\n                        fty: &ty::BareFnTy)\n                        -> ty::BareFnTy {\n         ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n-                       abis: fty.abis,\n+                       abi: fty.abi,\n                        purity: fty.purity }\n     }\n "}, {"sha": "82be783616888aec3e1cdbba8f7d45eb412dbcbb", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -60,7 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n@@ -519,12 +519,12 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_tup(tcx, flds)\n             }\n             ast::TyBareFn(ref bf) => {\n-                if bf.decl.variadic && !bf.abis.is_c() {\n+                if bf.decl.variadic && bf.abi != abi::C {\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n-                                                  bf.abis, bf.decl))\n+                                                  bf.abi, bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 if f.sigil == ast::ManagedSigil {\n@@ -666,20 +666,20 @@ pub fn ty_of_method<AC:AstConv>(\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::ExplicitSelf,\n     decl: &ast::FnDecl) -> ty::BareFnTy {\n-    ty_of_method_or_bare_fn(this, id, purity, AbiSet::Rust(), Some(SelfInfo {\n+    ty_of_method_or_bare_fn(this, id, purity, abi::Rust, Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self\n     }), decl)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                 purity: ast::Purity, abi: AbiSet,\n+                                 purity: ast::Purity, abi: abi::Abi,\n                                  decl: &ast::FnDecl) -> ty::BareFnTy {\n     ty_of_method_or_bare_fn(this, id, purity, abi, None, decl)\n }\n \n fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                       purity: ast::Purity, abi: AbiSet,\n+                                       purity: ast::Purity, abi: abi::Abi,\n                                        opt_self_info: Option<SelfInfo>,\n                                        decl: &ast::FnDecl) -> ty::BareFnTy {\n     debug!(\"ty_of_method_or_bare_fn\");\n@@ -726,7 +726,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n \n     return ty::BareFnTy {\n         purity: purity,\n-        abis: abi,\n+        abi: abi,\n         sig: ty::FnSig {\n             binder_id: id,\n             inputs: self_and_input_tys,"}, {"sha": "dce4e7fb06b94f627a3e9e8b8a59e050040ba306", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -1164,7 +1164,7 @@ impl<'a> LookupContext<'a> {\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,\n-            abis: bare_fn_ty.abis.clone(),\n+            abi: bare_fn_ty.abi.clone(),\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n "}, {"sha": "20ab2b699c2b6525eca9f30ea34c5b1212fcd84e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -120,7 +120,7 @@ use std::mem::replace;\n use std::result;\n use std::slice;\n use std::vec::Vec;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -599,7 +599,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n       ast::ItemForeignMod(ref m) => {\n-        if m.abis.is_intrinsic() {\n+        if m.abi == abi::RustIntrinsic {\n             for item in m.items.iter() {\n                 check_intrinsic_type(ccx, *item);\n             }\n@@ -612,7 +612,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n                 match item.node {\n                     ast::ForeignItemFn(ref fn_decl, _) => {\n-                        if fn_decl.variadic && !m.abis.is_c() {\n+                        if fn_decl.variadic && m.abi != abi::C {\n                             ccx.tcx.sess.span_err(\n                                 item.span, \"variadic function must have C calling convention\");\n                         }\n@@ -4224,7 +4224,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::UnsafeFn,\n-        abis: AbiSet::Intrinsic(),\n+        abi: abi::RustIntrinsic,\n         sig: FnSig {binder_id: it.id,\n                     inputs: inputs,\n                     output: output,"}, {"sha": "274f88ad4c37d919bd4d6426ac4fd6cbc29b682d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -48,7 +48,7 @@ use util::ppaux::Repr;\n use std::rc::Rc;\n use collections::HashSet;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n@@ -116,8 +116,8 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         match self.tcx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => ty_of_item(self, item),\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n-                let abis = self.tcx.map.get_foreign_abis(id.node);\n-                ty_of_foreign_item(self, foreign_item, abis)\n+                let abi = self.tcx.map.get_foreign_abi(id.node);\n+                ty_of_foreign_item(self, foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n@@ -550,10 +550,10 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n fn ensure_generics_abi(ccx: &CrateCtxt,\n                        span: Span,\n-                       abis: AbiSet,\n+                       abi: abi::Abi,\n                        generics: &ast::Generics) {\n     if generics.ty_params.len() > 0 &&\n-       !(abis.is_rust() || abis.is_intrinsic()) {\n+       !(abi == abi::Rust || abi == abi::RustIntrinsic) {\n         ccx.tcx.sess.span_err(span,\n                               \"foreign functions may not use type parameters\");\n     }\n@@ -717,9 +717,9 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let abis = ccx.tcx.map.get_foreign_abis(i.id);\n+    let abi = ccx.tcx.map.get_foreign_abi(i.id);\n \n-    let tpt = ty_of_foreign_item(ccx, i, abis);\n+    let tpt = ty_of_foreign_item(ccx, i, abi);\n     write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n \n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), tpt);\n@@ -891,15 +891,15 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n \n pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           it: &ast::ForeignItem,\n-                          abis: AbiSet) -> ty::ty_param_bounds_and_ty\n+                          abi: abi::Abi) -> ty::ty_param_bounds_and_ty\n {\n     match it.node {\n         ast::ForeignItemFn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n                                   fn_decl,\n                                   local_def(it.id),\n                                   generics,\n-                                  abis)\n+                                  abi)\n         }\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n@@ -1003,7 +1003,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::FnDecl,\n                              def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n-                             abis: AbiSet)\n+                             abi: abi::Abi)\n                           -> ty::ty_param_bounds_and_ty {\n \n     for i in decl.inputs.iter() {\n@@ -1028,7 +1028,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n         ty::BareFnTy {\n-            abis: abis,\n+            abi: abi,\n             purity: ast::UnsafeFn,\n             sig: ty::FnSig {binder_id: def_id.node,\n                             inputs: input_tys,"}, {"sha": "dac018fb848a996505a247f24ef5694128e50b7c", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -77,6 +77,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n \n+use syntax::abi;\n use syntax::ast::MutImmutable;\n use syntax::ast;\n \n@@ -384,7 +385,7 @@ impl<'f> Coerce<'f> {\n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                    a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n-            if !fn_ty_a.abis.is_rust() || fn_ty_a.purity != ast::ImpureFn {\n+            if fn_ty_a.abi != abi::Rust || fn_ty_a.purity != ast::ImpureFn {\n                 return self.subtype(a, b);\n             }\n "}, {"sha": "749c1ee69387c886acbf160712e0c3cbe1d40541", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -67,7 +67,7 @@ use std::result;\n use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n \n pub trait Combine {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n@@ -195,10 +195,10 @@ pub trait Combine {\n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n         let purity = if_ok!(self.purities(a.purity, b.purity));\n-        let abi = if_ok!(self.abis(a.abis, b.abis));\n+        let abi = if_ok!(self.abi(a.abi, b.abi));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {purity: purity,\n-                abis: abi,\n+                abi: abi,\n                 sig: sig})\n     }\n \n@@ -248,7 +248,7 @@ pub trait Combine {\n \n     fn purities(&self, a: Purity, b: Purity) -> cres<Purity>;\n \n-    fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet> {\n+    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {\n         if a == b {\n             Ok(a)\n         } else {"}, {"sha": "d635a9bdec41e03ae058fa06efb55ceb074c691e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -358,7 +358,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             }\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::ImpureFn,\n-                abis: abi::AbiSet::Rust(),\n+                abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n                     inputs: Vec::new(),\n@@ -404,7 +404,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::ImpureFn,\n-                abis: abi::AbiSet::Rust(),\n+                abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: start_id,\n                     inputs: vec!("}, {"sha": "4a1be783d9d1d3563dec2a76d259a2c9dc0a41de", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -23,7 +23,7 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n@@ -253,14 +253,14 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n                       purity: ast::Purity,\n-                      abis: AbiSet,\n+                      abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n                       -> ~str {\n-        let mut s = if abis.is_rust() {\n+        let mut s = if abi == abi::Rust {\n             ~\"\"\n         } else {\n-            format!(\"extern {} \", abis.to_str())\n+            format!(\"extern {} \", abi.to_str())\n         };\n \n         match purity {\n@@ -406,7 +406,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n           closure_to_str(cx, *f)\n       }\n       ty_bare_fn(ref f) => {\n-          bare_fn_to_str(cx, f.purity, f.abis, None, &f.sig)\n+          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n@@ -813,9 +813,9 @@ impl Repr for ast::Visibility {\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n+        format!(\"BareFnTy \\\\{purity: {:?}, abi: {}, sig: {}\\\\}\",\n              self.purity,\n-             self.abis.to_str(),\n+             self.abi.to_str(),\n              self.sig.repr(tcx))\n     }\n }\n@@ -968,13 +968,13 @@ impl UserString for ast::Ident {\n     }\n }\n \n-impl Repr for AbiSet {\n+impl Repr for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n-impl UserString for AbiSet {\n+impl UserString for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }"}, {"sha": "e92aec8e25c7c438d86f981bae30221836d22bb0", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -975,7 +975,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n                 type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n-            abi: self.abis.to_str(),\n+            abi: self.abi.to_str(),\n         }\n     }\n }"}, {"sha": "a6c1ece6400edee9e7a323f3e1670e1640ec2f9d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -11,7 +11,7 @@\n //! Rust AST Visitor. Extracts useful information and massages it into a form\n //! usable for clean\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n@@ -95,7 +95,7 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n-                    purity: &ast::Purity, _abi: &AbiSet,\n+                    purity: &ast::Purity, _abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {"}, {"sha": "a40899de931c95213c5465f10694006ba697538d", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 21, "deletions": 253, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n use std::fmt;\n-use std::fmt::Show;\n \n #[deriving(Eq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Eq, TotalEq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -65,11 +64,6 @@ pub enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n-pub struct AbiSet {\n-    bits: u32   // each bit represents one of the abis below\n-}\n-\n static AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n     AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},\n@@ -136,12 +130,20 @@ impl Abi {\n         self.data().name\n     }\n \n-    pub fn for_target(&self, os: Os, arch: Architecture) -> Abi {\n-        match (*self, os, arch) {\n+    pub fn for_target(&self, os: Os, arch: Architecture) -> Option<Abi> {\n+        // If this ABI isn't actually for the specified architecture, then we\n+        // short circuit early\n+        match self.data().abi_arch {\n+            Archs(a) if a & arch.bit() == 0 => return None,\n+            Archs(_) | RustArch | AllArch => {}\n+        }\n+        // Transform this ABI as appropriate for the requested os/arch\n+        // combination.\n+        Some(match (*self, os, arch) {\n             (System, OsWin32, X86) => Stdcall,\n             (System, _, _) => C,\n             (me, _, _) => me,\n-        }\n+        })\n     }\n }\n \n@@ -151,138 +153,9 @@ impl Architecture {\n     }\n }\n \n-impl AbiSet {\n-    pub fn from(abi: Abi) -> AbiSet {\n-        AbiSet { bits: (1 << abi.index()) }\n-    }\n-\n-    #[inline]\n-    pub fn Rust() -> AbiSet {\n-        AbiSet::from(Rust)\n-    }\n-\n-    #[inline]\n-    pub fn C() -> AbiSet {\n-        AbiSet::from(C)\n-    }\n-\n-    #[inline]\n-    pub fn Intrinsic() -> AbiSet {\n-        AbiSet::from(RustIntrinsic)\n-    }\n-\n-    pub fn default() -> AbiSet {\n-        AbiSet::C()\n-    }\n-\n-    pub fn empty() -> AbiSet {\n-        AbiSet { bits: 0 }\n-    }\n-\n-    #[inline]\n-    pub fn is_rust(&self) -> bool {\n-        self.bits == 1 << Rust.index()\n-    }\n-\n-    #[inline]\n-    pub fn is_c(&self) -> bool {\n-        self.bits == 1 << C.index()\n-    }\n-\n-    #[inline]\n-    pub fn is_intrinsic(&self) -> bool {\n-        self.bits == 1 << RustIntrinsic.index()\n-    }\n-\n-    pub fn contains(&self, abi: Abi) -> bool {\n-        (self.bits & (1 << abi.index())) != 0\n-    }\n-\n-    pub fn subset_of(&self, other_abi_set: AbiSet) -> bool {\n-        (self.bits & other_abi_set.bits) == self.bits\n-    }\n-\n-    pub fn add(&mut self, abi: Abi) {\n-        self.bits |= 1 << abi.index();\n-    }\n-\n-    pub fn each(&self, op: |abi: Abi| -> bool) -> bool {\n-        each_abi(|abi| !self.contains(abi) || op(abi))\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.bits == 0\n-    }\n-\n-    pub fn for_target(&self, os: Os, arch: Architecture) -> Option<Abi> {\n-        // NB---Single platform ABIs come first\n-\n-        let mut res = None;\n-\n-        self.each(|abi| {\n-            let data = abi.data();\n-            match data.abi_arch {\n-                Archs(a) if (a & arch.bit()) != 0 => { res = Some(abi); false }\n-                Archs(_) => { true }\n-                RustArch | AllArch => { res = Some(abi); false }\n-            }\n-        });\n-\n-        res.map(|r| r.for_target(os, arch))\n-    }\n-\n-    pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n-        let mut abis = Vec::new();\n-        self.each(|abi| { abis.push(abi); true });\n-\n-        for (i, abi) in abis.iter().enumerate() {\n-            let data = abi.data();\n-            for other_abi in abis.slice(0, i).iter() {\n-                let other_data = other_abi.data();\n-                debug!(\"abis=({:?},{:?}) datas=({:?},{:?})\",\n-                       abi, data.abi_arch,\n-                       other_abi, other_data.abi_arch);\n-                match (&data.abi_arch, &other_data.abi_arch) {\n-                    (&AllArch, &AllArch) => {\n-                        // Two cross-architecture ABIs\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    (_, &RustArch) |\n-                    (&RustArch, _) => {\n-                        // Cannot combine Rust or Rust-Intrinsic with\n-                        // anything else.\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    (&Archs(is), &Archs(js)) if (is & js) != 0 => {\n-                        // Two ABIs for same architecture\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        return None;\n-    }\n-}\n-\n impl fmt::Show for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.data().name.fmt(f)\n-    }\n-}\n-\n-impl fmt::Show for AbiSet {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"\\\"\"));\n-        let mut first = true;\n-        self.each(|abi| {\n-            if first { first = false; }\n-            else { let _ = write!(f.buf, \" \"); }\n-            let _ = write!(f.buf, \"{}\", abi.data().name);\n-            true\n-        });\n-        write!(f.buf, \"\\\"\")\n+        write!(f.buf, \"\\\"{}\\\"\", self.name())\n     }\n }\n \n@@ -304,95 +177,6 @@ fn lookup_baz() {\n     assert!(abi.is_none());\n }\n \n-#[cfg(test)]\n-fn cannot_combine(n: Abi, m: Abi) {\n-    let mut set = AbiSet::empty();\n-    set.add(n);\n-    set.add(m);\n-    match set.check_valid() {\n-        Some((a, b)) => {\n-            assert!((n == a && m == b) ||\n-                         (m == a && n == b));\n-        }\n-        None => {\n-            fail!(\"invalid match not detected\");\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-fn can_combine(n: Abi, m: Abi) {\n-    let mut set = AbiSet::empty();\n-    set.add(n);\n-    set.add(m);\n-    match set.check_valid() {\n-        Some((_, _)) => {\n-            fail!(\"valid match declared invalid\");\n-        }\n-        None => {}\n-    }\n-}\n-\n-#[test]\n-fn cannot_combine_cdecl_and_stdcall() {\n-    cannot_combine(Cdecl, Stdcall);\n-}\n-\n-#[test]\n-fn cannot_combine_c_and_rust() {\n-    cannot_combine(C, Rust);\n-}\n-\n-#[test]\n-fn cannot_combine_rust_and_cdecl() {\n-    cannot_combine(Rust, Cdecl);\n-}\n-\n-#[test]\n-fn cannot_combine_rust_intrinsic_and_cdecl() {\n-    cannot_combine(RustIntrinsic, Cdecl);\n-}\n-\n-#[test]\n-fn can_combine_system_and_cdecl() {\n-    can_combine(System, Cdecl);\n-}\n-\n-#[test]\n-fn can_combine_c_and_stdcall() {\n-    can_combine(C, Stdcall);\n-}\n-\n-#[test]\n-fn can_combine_aapcs_and_stdcall() {\n-    can_combine(Aapcs, Stdcall);\n-}\n-\n-#[test]\n-fn abi_to_str_stdcall_aaps() {\n-    let mut set = AbiSet::empty();\n-    set.add(Aapcs);\n-    set.add(Stdcall);\n-    assert!(set.to_str() == ~\"\\\"stdcall aapcs\\\"\");\n-}\n-\n-#[test]\n-fn abi_to_str_c_aaps() {\n-    let mut set = AbiSet::empty();\n-    set.add(Aapcs);\n-    set.add(C);\n-    debug!(\"set = {}\", set.to_str());\n-    assert!(set.to_str() == ~\"\\\"aapcs C\\\"\");\n-}\n-\n-#[test]\n-fn abi_to_str_rust() {\n-    let mut set = AbiSet::empty();\n-    set.add(Rust);\n-    debug!(\"set = {}\", set.to_str());\n-    assert!(set.to_str() == ~\"\\\"Rust\\\"\");\n-}\n-\n #[test]\n fn indices_are_correct() {\n     for (i, abi_data) in AbiDatas.iter().enumerate() {\n@@ -407,30 +191,14 @@ fn indices_are_correct() {\n     assert_eq!(ArmBits, bits);\n }\n \n-#[cfg(test)]\n-fn get_arch(abis: &[Abi], os: Os, arch: Architecture) -> Option<Abi> {\n-    let mut set = AbiSet::empty();\n-    for &abi in abis.iter() {\n-        set.add(abi);\n-    }\n-    set.for_target(os, arch)\n-}\n-\n-#[test]\n-fn pick_multiplatform() {\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, X86), Some(Cdecl));\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, X86_64), Some(Cdecl));\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, Arm), Some(C));\n-}\n-\n #[test]\n fn pick_uniplatform() {\n-    assert_eq!(get_arch([Stdcall], OsLinux, X86), Some(Stdcall));\n-    assert_eq!(get_arch([Stdcall], OsLinux, Arm), None);\n-    assert_eq!(get_arch([System], OsLinux, X86), Some(C));\n-    assert_eq!(get_arch([System], OsWin32, X86), Some(Stdcall));\n-    assert_eq!(get_arch([System], OsWin32, X86_64), Some(C));\n-    assert_eq!(get_arch([System], OsWin32, Arm), Some(C));\n-    assert_eq!(get_arch([Stdcall], OsWin32, X86), Some(Stdcall));\n-    assert_eq!(get_arch([Stdcall], OsWin32, X86_64), Some(Stdcall));\n+    assert_eq!(Stdcall.for_arch(OsLinux, X86), Some(Stdcall));\n+    assert_eq!(Stdcall.for_arch(OsLinux, Arm), None);\n+    assert_eq!(System.for_arch(OsLinux, X86), Some(C));\n+    assert_eq!(System.for_arch(OsWin32, X86), Some(Stdcall));\n+    assert_eq!(System.for_arch(OsWin32, X86_64), Some(C));\n+    assert_eq!(System.for_arch(OsWin32, Arm), Some(C));\n+    assert_eq!(Stdcall.for_arch(OsWin32, X86), Some(Stdcall));\n+    assert_eq!(Stdcall.for_arch(OsWin32, X86_64), Some(Stdcall));\n }"}, {"sha": "4612f8e6673643186d8ff301b449b56971606832", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -11,7 +11,7 @@\n // The Rust abstract syntax tree.\n \n use codemap::{Span, Spanned, DUMMY_SP};\n-use abi::AbiSet;\n+use abi::Abi;\n use ast_util;\n use owned_slice::OwnedSlice;\n use parse::token::{InternedString, special_idents, str_to_ident};\n@@ -807,7 +807,7 @@ pub struct ClosureTy {\n #[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     pub purity: Purity,\n-    pub abis: AbiSet,\n+    pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n@@ -941,7 +941,7 @@ pub struct Mod {\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n-    pub abis: AbiSet,\n+    pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<@ForeignItem>,\n }\n@@ -1119,7 +1119,7 @@ pub struct Item {\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n-    ItemFn(P<FnDecl>, Purity, AbiSet, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Purity, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),"}, {"sha": "e098dcd99fd8814083d7de2d6abbb7b705beb55a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::*;\n use ast_util;\n use codemap::Span;\n@@ -224,19 +224,19 @@ impl Map {\n         }\n     }\n \n-    pub fn get_foreign_abis(&self, id: NodeId) -> AbiSet {\n+    pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n         let parent = self.get_parent(id);\n-        let abis = match self.find_entry(parent) {\n+        let abi = match self.find_entry(parent) {\n             Some(EntryItem(_, i)) => match i.node {\n-                ItemForeignMod(ref nm) => Some(nm.abis),\n+                ItemForeignMod(ref nm) => Some(nm.abi),\n                 _ => None\n             },\n             // Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(AbiSet::Intrinsic()),\n+            Some(RootInlinedParent(_)) => Some(abi::RustIntrinsic),\n             _ => None\n         };\n-        match abis {\n-            Some(abis) => abis,\n+        match abi {\n+            Some(abi) => abi,\n             None => fail!(\"expected foreign mod or inlined parent, found {}\",\n                           self.node_to_str(parent))\n         }"}, {"sha": "ef62f0a01f6c1fdb12a8bcdfdf553cd7c34157d1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::{P, Ident};\n use ast;\n use ast_util;\n@@ -826,7 +826,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n                               ast::ImpureFn,\n-                              AbiSet::Rust(),\n+                              abi::Rust,\n                               generics,\n                               body))\n     }"}, {"sha": "06bf892771dc6b6e6971c367e3d2cf9b5075f4d8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -170,7 +170,7 @@ pub trait Folder {\n                 TyBareFn(@BareFnTy {\n                     lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n                     purity: f.purity,\n-                    abis: f.abis,\n+                    abi: f.abi,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n@@ -198,7 +198,7 @@ pub trait Folder {\n \n     fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n         ast::ForeignMod {\n-            abis: nm.abis,\n+            abi: nm.abi,\n             view_items: nm.view_items\n                           .iter()\n                           .map(|x| self.fold_view_item(x))"}, {"sha": "dbb85972774e71b9e3dfcda0f394c28f94bf6bd6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -657,7 +657,7 @@ mod test {\n                                 variadic: false\n                             }),\n                                     ast::ImpureFn,\n-                                    abi::AbiSet::Rust(),\n+                                    abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n                                         ty_params: OwnedSlice::empty(),"}, {"sha": "2d78bfe5694c1130233afad698feef2c68d7f937", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -11,7 +11,6 @@\n #![macro_escape]\n \n use abi;\n-use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -873,17 +872,17 @@ impl<'a> Parser<'a> {\n \n         */\n \n-        let abis = if self.eat_keyword(keywords::Extern) {\n-            self.parse_opt_abis().unwrap_or(AbiSet::C())\n+        let abi = if self.eat_keyword(keywords::Extern) {\n+            self.parse_opt_abi().unwrap_or(abi::C)\n         } else {\n-            AbiSet::Rust()\n+            abi::Rust\n         };\n \n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n         return TyBareFn(@BareFnTy {\n-            abis: abis,\n+            abi: abi,\n             purity: purity,\n             lifetimes: lifetimes,\n             decl: decl\n@@ -3770,11 +3769,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an item-position function declaration.\n-    fn parse_item_fn(&mut self, purity: Purity, abis: AbiSet) -> ItemInfo {\n+    fn parse_item_fn(&mut self, purity: Purity, abi: abi::Abi) -> ItemInfo {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        (ident, ItemFn(decl, purity, abis, generics, body), Some(inner_attrs))\n+        (ident, ItemFn(decl, purity, abi, generics, body), Some(inner_attrs))\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n@@ -4237,7 +4236,7 @@ impl<'a> Parser<'a> {\n     // at this point, this is essentially a wrapper for\n     // parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n-                               abis: AbiSet,\n+                               abi: abi::Abi,\n                                first_item_attrs: Vec<Attribute> )\n                                -> ForeignMod {\n         let ParsedItemsAndViewItems {\n@@ -4252,7 +4251,7 @@ impl<'a> Parser<'a> {\n         }\n         assert!(self.token == token::RBRACE);\n         ast::ForeignMod {\n-            abis: abis,\n+            abi: abi,\n             view_items: view_items,\n             items: foreign_items\n         }\n@@ -4310,17 +4309,17 @@ impl<'a> Parser<'a> {\n     /// extern {}\n     fn parse_item_foreign_mod(&mut self,\n                               lo: BytePos,\n-                              opt_abis: Option<AbiSet>,\n+                              opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n                               attrs: Vec<Attribute> )\n                               -> ItemOrViewItem {\n \n         self.expect(&token::LBRACE);\n \n-        let abis = opt_abis.unwrap_or(AbiSet::C());\n+        let abi = opt_abi.unwrap_or(abi::C);\n \n         let (inner, next) = self.parse_inner_attrs_and_next();\n-        let m = self.parse_foreign_mod_items(abis, next);\n+        let m = self.parse_foreign_mod_items(abi, next);\n         self.expect(&token::RBRACE);\n \n         let item = self.mk_item(lo,\n@@ -4440,45 +4439,29 @@ impl<'a> Parser<'a> {\n \n     // Parses a string as an ABI spec on an extern type or module. Consumes\n     // the `extern` keyword, if one is found.\n-    fn parse_opt_abis(&mut self) -> Option<AbiSet> {\n+    fn parse_opt_abi(&mut self) -> Option<abi::Abi> {\n         match self.token {\n-            token::LIT_STR(s)\n-            | token::LIT_STR_RAW(s, _) => {\n+            token::LIT_STR(s) | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n                 let identifier_string = token::get_ident(s);\n                 let the_string = identifier_string.get();\n-                let mut abis = AbiSet::empty();\n-                for word in the_string.words() {\n-                    match abi::lookup(word) {\n-                        Some(abi) => {\n-                            if abis.contains(abi) {\n-                                self.span_err(\n-                                    self.span,\n-                                    format!(\"ABI `{}` appears twice\",\n-                                         word));\n-                            } else {\n-                                abis.add(abi);\n-                            }\n-                        }\n-\n-                        None => {\n-                            self.span_err(\n-                                self.span,\n-                                format!(\"illegal ABI: \\\n-                                      expected one of [{}], \\\n-                                      found `{}`\",\n-                                     abi::all_names().connect(\", \"),\n-                                     word));\n-                        }\n-                     }\n-                 }\n-                Some(abis)\n+                match abi::lookup(the_string) {\n+                    Some(abi) => Some(abi),\n+                    None => {\n+                        self.span_err(\n+                            self.span,\n+                            format!(\"illegal ABI: \\\n+                                  expected one of [{}], \\\n+                                  found `{}`\",\n+                                 abi::all_names().connect(\", \"),\n+                                 the_string));\n+                        None\n+                    }\n+                }\n             }\n \n-            _ => {\n-                None\n-             }\n-         }\n+            _ => None,\n+        }\n     }\n \n     // parse one of the items or view items allowed by the\n@@ -4531,13 +4514,13 @@ impl<'a> Parser<'a> {\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n \n-            let opt_abis = self.parse_opt_abis();\n+            let opt_abi = self.parse_opt_abi();\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.unwrap_or(AbiSet::C());\n+                let abi = opt_abi.unwrap_or(abi::C);\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(ExternFn, abis);\n+                    self.parse_item_fn(ExternFn, abi);\n                 let item = self.mk_item(lo,\n                                         self.last_span.hi,\n                                         ident,\n@@ -4546,7 +4529,7 @@ impl<'a> Parser<'a> {\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n             } else if self.token == token::LBRACE {\n-                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs);\n+                return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n             let token_str = self.this_token_to_str();\n@@ -4572,7 +4555,7 @@ impl<'a> Parser<'a> {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(ImpureFn, AbiSet::Rust());\n+                self.parse_item_fn(ImpureFn, abi::Rust);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n@@ -4587,7 +4570,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(UnsafeFn, AbiSet::Rust());\n+                self.parse_item_fn(UnsafeFn, abi::Rust);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,"}, {"sha": "1eee0fb87d6bf15a7edab52d6369ee6edd35ee9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::{P, RegionTyParamBound, TraitTyParamBound, Required, Provided};\n use ast;\n use ast_util;\n@@ -190,7 +190,7 @@ pub fn fun_to_str(decl: &ast::FnDecl, purity: ast::Purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> ~str {\n     to_str(|s| {\n-        try!(s.print_fn(decl, Some(purity), AbiSet::Rust(),\n+        try!(s.print_fn(decl, Some(purity), abi::Rust,\n                         name, generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n@@ -478,7 +478,7 @@ impl<'a> State<'a> {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty()\n                 };\n-                try!(self.print_ty_fn(Some(f.abis), None, &None,\n+                try!(self.print_ty_fn(Some(f.abi), None, &None,\n                                    f.purity, ast::Many, f.decl, None, &None,\n                                    Some(&generics), None));\n             }\n@@ -524,7 +524,7 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         match item.node {\n             ast::ForeignItemFn(decl, ref generics) => {\n-                try!(self.print_fn(decl, None, AbiSet::Rust(), item.ident, generics,\n+                try!(self.print_fn(decl, None, abi::Rust, item.ident, generics,\n                 None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n@@ -590,7 +590,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abis.to_str()));\n+                try!(self.word_nbsp(nmod.abi.to_str()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n@@ -883,7 +883,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(meth.decl, Some(meth.purity), AbiSet::Rust(),\n+        try!(self.print_fn(meth.decl, Some(meth.purity), abi::Rust,\n                         meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                         meth.vis));\n         try!(word(&mut self.s, \" \"));\n@@ -1717,14 +1717,14 @@ impl<'a> State<'a> {\n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n                     purity: Option<ast::Purity>,\n-                    abis: AbiSet,\n+                    abi: abi::Abi,\n                     name: ast::Ident,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, purity, abis,\n-                                    ast::Many, None, vis));\n+        try!(self.print_fn_header_info(opt_explicit_self, purity, abi,\n+                                       ast::Many, None, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n@@ -2016,7 +2016,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_fn(&mut self,\n-                       opt_abis: Option<AbiSet>,\n+                       opt_abi: Option<abi::Abi>,\n                        opt_sigil: Option<ast::Sigil>,\n                        opt_region: &Option<ast::Lifetime>,\n                        purity: ast::Purity,\n@@ -2034,14 +2034,14 @@ impl<'a> State<'a> {\n         if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n             try!(word(&mut self.s, \"proc\"));\n         } else if opt_sigil == Some(ast::BorrowedSigil) {\n-            try!(self.print_extern_opt_abis(opt_abis));\n+            try!(self.print_extern_opt_abi(opt_abi));\n             for lifetime in opt_region.iter() {\n                 try!(self.print_lifetime(lifetime));\n             }\n             try!(self.print_purity(purity));\n             try!(self.print_onceness(onceness));\n         } else {\n-            try!(self.print_opt_abis_and_extern_if_nondefault(opt_abis));\n+            try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_opt_sigil(opt_sigil));\n             try!(self.print_opt_lifetime(opt_region));\n             try!(self.print_purity(purity));\n@@ -2303,24 +2303,25 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_abis_and_extern_if_nondefault(&mut self,\n-                                                   opt_abis: Option<AbiSet>)\n+    pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n+                                                  opt_abi: Option<abi::Abi>)\n         -> IoResult<()> {\n-        match opt_abis {\n-            Some(abis) if !abis.is_rust() => {\n+        match opt_abi {\n+            Some(abi::Rust) => Ok(()),\n+            Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abis.to_str())\n+                self.word_nbsp(abi.to_str())\n             }\n-            Some(_) | None => Ok(())\n+            None => Ok(())\n         }\n     }\n \n-    pub fn print_extern_opt_abis(&mut self,\n-                                 opt_abis: Option<AbiSet>) -> IoResult<()> {\n-        match opt_abis {\n-            Some(abis) => {\n+    pub fn print_extern_opt_abi(&mut self,\n+                                opt_abi: Option<abi::Abi>) -> IoResult<()> {\n+        match opt_abi {\n+            Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abis.to_str())\n+                self.word_nbsp(abi.to_str())\n             }\n             None => Ok(())\n         }\n@@ -2339,15 +2340,15 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 _opt_explicit_self: Option<ast::ExplicitSelf_>,\n                                 opt_purity: Option<ast::Purity>,\n-                                abis: AbiSet,\n+                                abi: abi::Abi,\n                                 onceness: ast::Onceness,\n                                 opt_sigil: Option<ast::Sigil>,\n                                 vis: ast::Visibility) -> IoResult<()> {\n         try!(word(&mut self.s, visibility_qualified(vis, \"\")));\n \n-        if abis != AbiSet::Rust() {\n+        if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abis.to_str()));\n+            try!(self.word_nbsp(abi.to_str()));\n \n             if opt_purity != Some(ast::ExternFn) {\n                 try!(self.print_opt_purity(opt_purity));"}, {"sha": "eb03bb1f0bbe046db848bc624599fb47fbc98f23", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e0908af395af1c10e28600b785b5366a43660c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=57e0908af395af1c10e28600b785b5366a43660c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi::Abi;\n use ast::*;\n use ast;\n use codemap::Span;\n@@ -29,7 +29,7 @@ use owned_slice::OwnedSlice;\n \n pub enum FnKind<'a> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    FkItemFn(Ident, &'a Generics, Purity, AbiSet),\n+    FkItemFn(Ident, &'a Generics, Purity, Abi),\n \n     // fn foo(&self)\n     FkMethod(Ident, &'a Generics, &'a Method),"}]}