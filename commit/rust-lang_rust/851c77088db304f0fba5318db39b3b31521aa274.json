{"sha": "851c77088db304f0fba5318db39b3b31521aa274", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MWM3NzA4OGRiMzA0ZjBmYmE1MzE4ZGIzOWIzYjMxNTIxYWEyNzQ=", "commit": {"author": {"name": "Tobias Schottdorf", "email": "tobias.schottdorf@gmail.com", "date": "2017-07-21T23:29:43Z"}, "committer": {"name": "Tobias Schottdorf", "email": "tobias.schottdorf@gmail.com", "date": "2017-07-30T14:19:53Z"}, "message": "default binding modes: add pat_binding_modes\n\nThis PR kicks off the implementation of the [default binding modes RFC][1] by\nintroducing the `pat_binding_modes` typeck table mentioned in the [mentoring\ninstructions][2].\n\n`pat_binding_modes` is populated in `librustc_typeck/check/_match.rs` and\nused wherever the HIR would be scraped prior to this PR. Unfortunately, one\nblemish, namely a two callers to `contains_explicit_ref_binding`, remains.\nThis will likely have to be removed when the second part of [1], the\n`pat_adjustments` table, is tackled. Appropriate comments have been added.\n\nSee #42640.\n\n[1]: https://github.com/rust-lang/rfcs/pull/2005\n[2]: https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089", "tree": {"sha": "7786739983a567c2bf9488991e99b7aaaa12393c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7786739983a567c2bf9488991e99b7aaaa12393c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/851c77088db304f0fba5318db39b3b31521aa274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/851c77088db304f0fba5318db39b3b31521aa274", "html_url": "https://github.com/rust-lang/rust/commit/851c77088db304f0fba5318db39b3b31521aa274", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/851c77088db304f0fba5318db39b3b31521aa274/comments", "author": {"login": "tbg", "id": 5076964, "node_id": "MDQ6VXNlcjUwNzY5NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5076964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbg", "html_url": "https://github.com/tbg", "followers_url": "https://api.github.com/users/tbg/followers", "following_url": "https://api.github.com/users/tbg/following{/other_user}", "gists_url": "https://api.github.com/users/tbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbg/subscriptions", "organizations_url": "https://api.github.com/users/tbg/orgs", "repos_url": "https://api.github.com/users/tbg/repos", "events_url": "https://api.github.com/users/tbg/events{/privacy}", "received_events_url": "https://api.github.com/users/tbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbg", "id": 5076964, "node_id": "MDQ6VXNlcjUwNzY5NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5076964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbg", "html_url": "https://github.com/tbg", "followers_url": "https://api.github.com/users/tbg/followers", "following_url": "https://api.github.com/users/tbg/following{/other_user}", "gists_url": "https://api.github.com/users/tbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbg/subscriptions", "organizations_url": "https://api.github.com/users/tbg/orgs", "repos_url": "https://api.github.com/users/tbg/repos", "events_url": "https://api.github.com/users/tbg/events{/privacy}", "received_events_url": "https://api.github.com/users/tbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9", "html_url": "https://github.com/rust-lang/rust/commit/5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9"}], "stats": {"total": 374, "additions": 268, "deletions": 106}, "files": [{"sha": "421a81c0d23422f572965c2d8edfffd20bef961b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -2191,7 +2191,7 @@ impl<'a> LoweringContext<'a> {\n                 let next_ident = self.str_to_ident(\"__next\");\n                 let next_pat = self.pat_ident_binding_mode(e.span,\n                                                            next_ident,\n-                                                           hir::BindByValue(hir::MutMutable));\n+                                                           hir::BindingAnnotation::Mutable);\n \n                 // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n@@ -2215,8 +2215,9 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat = self.pat_ident_binding_mode(e.span, iter,\n-                                                           hir::BindByValue(hir::MutMutable));\n+                let iter_pat = self.pat_ident_binding_mode(e.span,\n+                                                           iter,\n+                                                           hir::BindingAnnotation::Mutable);\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n@@ -2503,10 +2504,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingMode {\n+    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n         match *b {\n-            BindingMode::ByRef(m) => hir::BindByRef(self.lower_mutability(m)),\n-            BindingMode::ByValue(m) => hir::BindByValue(self.lower_mutability(m)),\n+            BindingMode::ByValue(Mutability::Immutable) =>\n+                hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Immutable) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mutable) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mutable) => hir::BindingAnnotation::RefMut,\n         }\n     }\n \n@@ -2647,7 +2651,7 @@ impl<'a> LoweringContext<'a> {\n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n                 -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n+            self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -2703,10 +2707,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n-        self.pat_ident_binding_mode(span, name, hir::BindByValue(hir::MutImmutable))\n+        self.pat_ident_binding_mode(span, name, hir::BindingAnnotation::Unannotated)\n     }\n \n-    fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n+    fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n         let id = self.next_id();\n         let parent_def = self.parent_def.unwrap();"}, {"sha": "7f1d1480d46a7d6cacc6c996bdc41a2b6bd20833", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust HIR.\n \n-pub use self::BindingMode::*;\n pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n@@ -628,10 +627,28 @@ pub struct FieldPat {\n     pub is_shorthand: bool,\n }\n \n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum BindingMode {\n-    BindByRef(Mutability),\n-    BindByValue(Mutability),\n+pub enum BindingAnnotation {\n+  /// No binding annotation given: this means that the final binding mode\n+  /// will depend on whether we have skipped through a `&` reference\n+  /// when matching. For example, the `x` in `Some(x)` will have binding\n+  /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+  /// ultimately be inferred to be by-reference.\n+  ///\n+  /// Note that implicit reference skipping is not implemented yet (#42640).\n+  Unannotated,\n+\n+  /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+  Mutable,\n+\n+  /// Annotated as `ref`, like `ref x`\n+  Ref,\n+\n+  /// Annotated as `ref mut x`.\n+  RefMut,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -647,7 +664,7 @@ pub enum PatKind {\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `DefId` is for the definition of the variable being bound.\n-    Binding(BindingMode, DefId, Spanned<Name>, Option<P<Pat>>),\n+    Binding(BindingAnnotation, DefId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`."}, {"sha": "144cb34ee356e221162cca6eaf8ab36f2fb4f645", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -87,7 +87,7 @@ impl hir::Pat {\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+        where F: FnMut(hir::BindingAnnotation, ast::NodeId, Span, &Spanned<ast::Name>),\n     {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n@@ -130,12 +130,10 @@ impl hir::Pat {\n \n     pub fn simple_name(&self) -> Option<ast::Name> {\n         match self.node {\n-            PatKind::Binding(hir::BindByValue(..), _, ref path1, None) => {\n-                Some(path1.node)\n-            }\n-            _ => {\n-                None\n-            }\n+            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ref path1, None) |\n+            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ref path1, None) =>\n+                Some(path1.node),\n+            _ => None,\n         }\n     }\n \n@@ -163,16 +161,22 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-    /// and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+    /// and if yes whether it contains mutable or just immutables ones.\n+    ///\n+    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped,\n+    /// but ref bindings may be implicit after #42640.\n+    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n-        self.each_binding(|mode, _, _, _| {\n-            if let hir::BindingMode::BindByRef(m) = mode {\n-                // Pick Mutable as maximum\n-                match result {\n-                    None | Some(hir::MutImmutable) => result = Some(m),\n-                    _ => (),\n+        self.each_binding(|annotation, _, _, _| {\n+            match annotation {\n+                hir::BindingAnnotation::Ref => {\n+                    match result {\n+                        None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                        _ => (),\n+                    }\n                 }\n+                hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n+                _ => (),\n             }\n         });\n         result\n@@ -182,9 +186,11 @@ impl hir::Pat {\n impl hir::Arm {\n     /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n     /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n+        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n+        // for #42640.\n         self.pats.iter()\n-                 .filter_map(|pat| pat.contains_ref_binding())\n+                 .filter_map(|pat| pat.contains_explicit_ref_binding())\n                  .max_by_key(|m| match *m {\n                     hir::MutMutable => 1,\n                     hir::MutImmutable => 0,"}, {"sha": "abfb00a24a115364b7f825a1ae5d1f7c1117ac1b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -1651,12 +1651,16 @@ impl<'a> State<'a> {\n             PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n-                    hir::BindByRef(mutbl) => {\n+                    hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\")?;\n-                        self.print_mutability(mutbl)?;\n+                        self.print_mutability(hir::MutImmutable)?;\n                     }\n-                    hir::BindByValue(hir::MutImmutable) => {}\n-                    hir::BindByValue(hir::MutMutable) => {\n+                    hir::BindingAnnotation::RefMut => {\n+                        self.word_nbsp(\"ref\")?;\n+                        self.print_mutability(hir::MutMutable)?;\n+                    }\n+                    hir::BindingAnnotation::Unannotated => {}\n+                    hir::BindingAnnotation::Mutable => {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }"}, {"sha": "b344084f580bf37e52e7a08af1f433b62191860d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -442,9 +442,11 @@ impl_stable_hash_for!(struct hir::FieldPat {\n     is_shorthand\n });\n \n-impl_stable_hash_for!(enum hir::BindingMode {\n-    BindByRef(mutability),\n-    BindByValue(mutability)\n+impl_stable_hash_for!(enum hir::BindingAnnotation {\n+    Unannotated,\n+    Mutable,\n+    Ref,\n+    RefMut\n });\n \n impl_stable_hash_for!(enum hir::RangeEnd {"}, {"sha": "e03cbb45414d13ef4a731baca8a12716cfdde480", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -617,6 +617,7 @@ for ty::TypeckTables<'tcx> {\n             ref node_types,\n             ref node_substs,\n             ref adjustments,\n+            ref pat_binding_modes,\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n@@ -637,6 +638,7 @@ for ty::TypeckTables<'tcx> {\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n             ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n+            ich::hash_stable_nodemap(hcx, hasher, pat_binding_modes);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "87e933e85e2289526a507535e5adb867f6abf905", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -796,16 +796,19 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Binding(hir::BindByRef(..), ..) =>\n-                    mode.lub(BorrowingMatch),\n-                PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n-                        Copy => mode.lub(CopyingMatch),\n-                        Move(..) => mode.lub(MovingMatch),\n+            if let PatKind::Binding(..) = pat.node {\n+                let bm = *self.mc.tables.pat_binding_modes.get(&pat.id)\n+                                                          .expect(\"missing binding mode\");\n+                match bm {\n+                    ty::BindByReference(..) =>\n+                        mode.lub(BorrowingMatch),\n+                    ty::BindByValue(..) => {\n+                        match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n+                            Copy => mode.lub(CopyingMatch),\n+                            Move(..) => mode.lub(MovingMatch),\n+                        }\n                     }\n                 }\n-                _ => {}\n             }\n         }));\n     }\n@@ -818,8 +821,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n+            if let PatKind::Binding(_, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n+                let bm = *mc.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(mc.node_ty(pat.id));\n@@ -832,14 +836,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n \n                 // It is also a borrow or copy/move of the value being matched.\n-                match bmode {\n-                    hir::BindByRef(m) => {\n+                match bm {\n+                    ty::BindByReference(m) => {\n                         if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n-                    hir::BindByValue(..) => {\n+                    ty::BindByValue(..) => {\n                         let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);"}, {"sha": "b4993aafc4c9ed379f692e6848b1e74d4890e4b7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -330,11 +330,12 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n             hir_map::NodeLocal(p) => match p.node {\n-                PatKind::Binding(bind_mode, ..) => {\n-                    if bind_mode == hir::BindByValue(hir::MutMutable) {\n+                PatKind::Binding(..) => {\n+                    let bm = *tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                    if bm == ty::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n                         McImmutable\n@@ -475,16 +476,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), ..) => {\n-                // a bind-by-ref means that the base_ty will be the type of the ident itself,\n-                // but what we want here is the type of the underlying value being borrowed.\n-                // So peel off one-level, turning the &T into T.\n-                match base_ty.builtin_deref(false, ty::NoPreference) {\n-                    Some(t) => t.ty,\n-                    None => {\n-                        debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n-                        return Err(());\n+            PatKind::Binding(..) => {\n+                let bm = *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                if let ty::BindByReference(_) = bm {\n+                    // a bind-by-ref means that the base_ty will be the type of the ident itself,\n+                    // but what we want here is the type of the underlying value being borrowed.\n+                    // So peel off one-level, turning the &T into T.\n+                    match base_ty.builtin_deref(false, ty::NoPreference) {\n+                        Some(t) => t.ty,\n+                        None => {\n+                            debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n+                            return Err(());\n+                        }\n                     }\n+                } else {\n+                    base_ty\n                 }\n             }\n             _ => base_ty,\n@@ -659,7 +665,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 id,\n                 span,\n                 cat: Categorization::Local(vid),\n-                mutbl: MutabilityCategory::from_local(self.tcx, vid),\n+                mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n             }))\n@@ -711,7 +717,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx, var_id);\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n \n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar"}, {"sha": "9133a5e777db2743deea169f9a4a943dd5c27eb7", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -889,8 +889,32 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | ( ..., P&, ... )\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n+        // Note that the code below looks for *explicit* refs only, that is, it won't\n+        // know about *implicit* refs as introduced in #42640.\n+        //\n+        // This is not a problem. For example, consider\n+        //\n+        //      let (ref x, ref y) = (Foo { .. }, Bar { .. });\n+        //\n+        // Due to the explicit refs on the left hand side, the below code would signal\n+        // that the temporary value on the right hand side should live until the end of\n+        // the enclosing block (as opposed to being dropped after the let is complete).\n+        //\n+        // To create an implicit ref, however, you must have a borrowed value on the RHS\n+        // already, as in this example (which won't compile before #42640):\n+        //\n+        //      let Foo { x, .. } = &Foo { x: ..., ... };\n+        //\n+        // in place of\n+        //\n+        //      let Foo { ref x, .. } = Foo { ... };\n+        //\n+        // In the former case (the implicit ref version), the temporary is created by the\n+        // & expression, and its lifetime would be extended to the end of the block (due\n+        // to a different rule, not the below code).\n         match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), ..) => true,\n+            PatKind::Binding(hir::BindingAnnotation::Ref, ..) |\n+            PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))"}, {"sha": "3db61b76cc55c57e3a7f8ce54672bbe7f75f05ec", "filename": "src/librustc/ty/binding.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::BindingAnnotation::*;\n+use hir::BindingAnnotation;\n+use hir::Mutability;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum BindingMode {\n+    BindByReference(Mutability),\n+    BindByValue(Mutability),\n+}\n+\n+impl BindingMode {\n+    pub fn convert(ba: BindingAnnotation) -> BindingMode {\n+        match ba {\n+            Unannotated => BindingMode::BindByValue(Mutability::MutImmutable),\n+            Mutable => BindingMode::BindByValue(Mutability::MutMutable),\n+            Ref => BindingMode::BindByReference(Mutability::MutImmutable),\n+            RefMut => BindingMode::BindByReference(Mutability::MutMutable),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum self::BindingMode {\n+    BindByReference(mutability),\n+    BindByValue(mutability)\n+});"}, {"sha": "be3cd99426d4df4867956bd343774d9abb17d0aa", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -40,6 +40,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n+use ty::BindingMode;\n use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -223,6 +224,9 @@ pub struct TypeckTables<'tcx> {\n \n     pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n+    // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    pub pat_binding_modes: NodeMap<BindingMode>,\n+\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n@@ -274,6 +278,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             node_types: FxHashMap(),\n             node_substs: NodeMap(),\n             adjustments: NodeMap(),\n+            pat_binding_modes: NodeMap(),\n             upvar_capture_map: FxHashMap(),\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),"}, {"sha": "914419ede361b40c7654b44e1b47d80ec8e6a541", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -74,6 +74,9 @@ pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TypeVariants::*;\n \n+pub use self::binding::BindingMode;\n+pub use self::binding::BindingMode::*;\n+\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n@@ -84,6 +87,7 @@ pub use self::trait_def::TraitDef;\n pub use self::maps::queries;\n \n pub mod adjustment;\n+pub mod binding;\n pub mod cast;\n pub mod error;\n pub mod fast_reject;"}, {"sha": "0124a77349ca5a22e8c16436c90c30f33ac06c89", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -871,14 +871,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_binding_mode(&self, node_id: ast::NodeId) -> hir::BindingMode {\n+    fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n             hir_map::Node::NodeLocal(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n         match pat.node {\n-            hir::PatKind::Binding(mode, ..) => mode,\n+            hir::PatKind::Binding(..) =>\n+                *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\"),\n             _ => bug!(\"local is not a binding: {:?}\", pat)\n         }\n     }\n@@ -913,7 +914,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n             Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n                 let let_span = self.tcx.hir.span(node_id);\n-                if let hir::BindingMode::BindByValue(..) = self.local_binding_mode(node_id) {\n+                if let ty::BindByValue(..) = self.local_binding_mode(node_id) {\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n                         let (_, is_implicit_self) = self.local_ty(node_id);\n                         if is_implicit_self && snippet != \"self\" {\n@@ -930,7 +931,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n                 let let_span = self.tcx.hir.span(node_id);\n                 match self.local_binding_mode(node_id) {\n-                    hir::BindingMode::BindByRef(..) => {\n+                    ty::BindByReference(..) => {\n                         let snippet = self.tcx.sess.codemap().span_to_snippet(let_span);\n                         if let Ok(snippet) = snippet {\n                             db.span_label(\n@@ -940,7 +941,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    hir::BindingMode::BindByValue(..) => {\n+                    ty::BindByValue(..) => {\n                         if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {"}, {"sha": "060ff503d4e5889cdb61984056459a23e26f0ad6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -268,7 +268,12 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n+        if let PatKind::Binding(_, _, name, None) = p.node {\n+            let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+            if bm != ty::BindByValue(hir::MutImmutable) {\n+                // Nothing to check.\n+                return true;\n+            }\n             let pat_ty = cx.tables.pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() && edef.variants.iter().any(|variant| {\n@@ -452,8 +457,9 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat.each_binding(|bm, _, span, _path| {\n-            if let hir::BindByRef(..) = bm {\n+        pat.each_binding(|_, id, span, _path| {\n+            let bm = *cx.tables.pat_binding_modes.get(&id).expect(\"missing binding mode\");\n+            if let ty::BindByReference(..) = bm {\n                 by_ref_span = Some(span);\n             }\n         })\n@@ -484,10 +490,16 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n-                let pat_ty = cx.tables.node_id_to_type(p.id);\n-                if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n-                    check_move(p, sub.as_ref().map(|p| &**p));\n+            if let PatKind::Binding(_, _, _, ref sub) = p.node {\n+                let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                match bm {\n+                    ty::BindByValue(..) => {\n+                        let pat_ty = cx.tables.node_id_to_type(p.id);\n+                        if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                            check_move(p, sub.as_ref().map(|p| &**p));\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n             true"}, {"sha": "f37a112a596ac57e3f24fd0fc57ca7fe617fc8b6", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -374,27 +374,31 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n+            PatKind::Binding(_, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tables.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n+                let bm = *self.tables.pat_binding_modes.get(&pat.id)\n+                                                       .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    hir::BindByValue(hir::MutMutable) =>\n+                    ty::BindByValue(hir::MutMutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n-                    hir::BindByValue(hir::MutImmutable) =>\n+                    ty::BindByValue(hir::MutImmutable) =>\n                         (Mutability::Not, BindingMode::ByValue),\n-                    hir::BindByRef(hir::MutMutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Mut)),\n-                    hir::BindByRef(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n+                    ty::BindByReference(hir::MutMutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Mut)),\n+                    ty::BindByReference(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Shared)),\n                 };\n \n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n-                if let hir::BindByRef(_) = bm {\n+                if let ty::BindByReference(_) = bm {\n                     if let ty::TyRef(_, mt) = ty.sty {\n                         ty = mt.ty;\n                     } else {"}, {"sha": "d7d0dc7cb352b78d93354adbefd3f25cb92eeca4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -44,9 +44,13 @@ impl UnusedMut {\n \n         let mut mutables = FxHashMap();\n         for p in pats {\n-            p.each_binding(|mode, id, _, path1| {\n+            p.each_binding(|_, id, span, path1| {\n+                let bm = match cx.tables.pat_binding_modes.get(&id) {\n+                    Some(&bm) => bm,\n+                    None => span_bug!(span, \"missing binding mode\"),\n+                };\n                 let name = path1.node;\n-                if let hir::BindByValue(hir::MutMutable) = mode {\n+                if let ty::BindByValue(hir::MutMutable) = bm {\n                     if !name.as_str().starts_with(\"_\") {\n                         match mutables.entry(name) {\n                             Vacant(entry) => {"}, {"sha": "349a21af895864a49ae0f2c2400c301819af0695", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -2277,8 +2277,9 @@ impl<'a> Resolver<'a> {\n                                                                       false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n+                        let ivmode = BindingMode::ByValue(Mutability::Immutable);\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n-                                             bmode != BindingMode::ByValue(Mutability::Immutable);\n+                                             bmode != ivmode;\n                         match def {\n                             Def::StructCtor(_, CtorKind::Const) |\n                             Def::VariantCtor(_, CtorKind::Const) |"}, {"sha": "01d2986a53ca7602d56178a347c6c45f804f4d7e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -113,10 +113,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n                 common_type\n             }\n-            PatKind::Binding(bm, def_id, _, ref sub) => {\n+            PatKind::Binding(ba, def_id, _, ref sub) => {\n+                // Note the binding mode in the typeck tables. For now, what we store is always\n+                // identical to what could be scraped from the HIR, but this will change with\n+                // default binding modes (#42640).\n+                let bm = ty::BindingMode::convert(ba);\n+                self.inh.tables.borrow_mut().pat_binding_modes.insert(pat.id, bm);\n+\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n-                    hir::BindByRef(mutbl) => {\n+                    ty::BindByReference(mutbl) => {\n                         // if the binding is like\n                         //    ref x | ref const x | ref mut x\n                         // then `x` is assigned a value of type `&M T` where M is the mutability\n@@ -131,7 +137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.demand_eqtype(pat.span, region_ty, typ);\n                     }\n                     // otherwise the type of x is the expected type T\n-                    hir::BindByValue(_) => {\n+                    ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n                         self.demand_eqtype(pat.span, expected, typ);\n@@ -396,11 +402,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        match_src: hir::MatchSource) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        // Not entirely obvious: if matches may create ref bindings, we\n-        // want to use the *precise* type of the discriminant, *not* some\n-        // supertype, as the \"discriminant type\" (issue #23116).\n+        // Not entirely obvious: if matches may create ref bindings, we want to\n+        // use the *precise* type of the discriminant, *not* some supertype, as\n+        // the \"discriminant type\" (issue #23116).\n+        //\n+        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n+        // is problematic as the HIR is being scraped, but ref bindings may be\n+        // implicit after #42640. We need to make sure that pat_adjustments\n+        // (once introduced) is populated by the time we get here.\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_ref_binding())\n+                                        .filter_map(|a| a.contains_explicit_ref_binding())\n                                         .max_by_key(|m| match *m {\n                                             hir::MutMutable => 1,\n                                             hir::MutImmutable => 0,"}, {"sha": "37fd0dd15861f20b142e88a982a73588c3be154a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -3999,7 +3999,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   local: &'gcx hir::Local,\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        let ref_bindings = local.pat.contains_ref_binding();\n+        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n+        // for #42640.\n+        let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n         let local_ty = self.local_ty(init.span, local.id);\n         if let Some(m) = ref_bindings {"}, {"sha": "9b7ecc194ca881b6e2810fe1cc9ccccb927ea3bb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -1196,9 +1196,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n-                    PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n-                        self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n-                                                        mutbl, sub_cmt);\n+                    PatKind::Binding(..) => {\n+                        let bm = *mc.tables.pat_binding_modes.get(&sub_pat.id)\n+                                                             .expect(\"missing binding mode\");\n+                        if let ty::BindByReference(mutbl) = bm {\n+                            self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                                                            mutbl, sub_cmt);\n+                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "0a323efabec1dd6c90d5697df6320621e8838899", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -178,6 +178,15 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n+        match p.node {\n+            hir::PatKind::Binding(..) => {\n+                let bm = *self.fcx.tables.borrow().pat_binding_modes.get(&p.id)\n+                                                                    .expect(\"missing binding mode\");\n+                self.tables.pat_binding_modes.insert(p.id, bm);\n+            }\n+            _ => {}\n+        };\n+\n         self.visit_node_id(p.span, p.id);\n         intravisit::walk_pat(self, p);\n     }"}, {"sha": "893bada2670df2799c9918d257a41673496e59ea", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/851c77088db304f0fba5318db39b3b31521aa274/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=851c77088db304f0fba5318db39b3b31521aa274", "patch": "@@ -867,13 +867,14 @@ mod tests {\n                                     pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: PatKind::Ident(\n-                                            ast::BindingMode::ByValue(ast::Mutability::Immutable),\n-                                                Spanned{\n-                                                    span: sp(6,7),\n-                                                    node: Ident::from_str(\"b\")},\n-                                                None\n-                                                    ),\n-                                            span: sp(6,7)\n+                                            ast::BindingMode::ByValue(\n+                                                ast::Mutability::Immutable),\n+                                            Spanned{\n+                                                span: sp(6,7),\n+                                                node: Ident::from_str(\"b\")},\n+                                            None\n+                                        ),\n+                                        span: sp(6,7)\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }],"}]}