{"sha": "95e00bfed801e264e9c4ac817004153ca0f19eb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZTAwYmZlZDgwMWUyNjRlOWM0YWM4MTcwMDQxNTNjYTBmMTllYjY=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-24T09:43:32Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-27T07:02:11Z"}, "message": "Format libcore with rustfmt\n\nThis commit applies rustfmt with default settings to files in\nsrc/libcore *that are not involved in any currently open PR* to minimize\nmerge conflicts. The list of files involved in open PRs was determined\nby querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in `outstanding_files`, the\nrelevant commands were:\n\n    $ find src/libcore -name '*.rs' | xargs rustfmt --edition=2018\n    $ rg libcore outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of libcore.", "tree": {"sha": "79549f727c3fc8bb0b09779a7dc3f94df43654f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79549f727c3fc8bb0b09779a7dc3f94df43654f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95e00bfed801e264e9c4ac817004153ca0f19eb6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl3eH3MACgkQ+boUO5X/\nbYI4nA/9GQYa6KPKW3zHdm9/070F5uBJvja9F8UEt7nElXdLoGFt6ju3LnaodxNf\nUPRooSDvzBq5DSdMDFoXtm7uOGYVftsUPpixCV2tQcK9h3zUY4WPtCak/J67+TnV\nckSZ091Kzh4B0ThFedqL04aVpLm0pBOiuxsxDw0JeM5ekvsScUh+EMWadPD2ZMD+\n4zVUuSgk3eZdoEYx5712/y5yo00+xDueOtq68428plOYWYsOvt+e/yHstrjMt1cd\npAnCoZkafvKWDRP5NuQsTA8TbGWtABz0iYX6/0P7AglYg04syiVSeWOCzKMCv5Yw\nf80Os7k7C84Lnwddfu+GgRsyembspJ6Pt7d+jUcCWpIcVDD8pYH+JZL+tu2Ck8JO\nUfGKbcOtAxArSrroeBYYPYQ2mL0luGQVP768szDkto2zHJLDkmDndKe+QwnN+mSN\nSR/C9kzyXgmYlWhmXUbCY5TAUKETdW+kRIE4WORkjuFGc2gRKo/M6ntbDvihfkI0\n5/ZFVQecAkCIdpwIitVOxY8p3Hu//WhjL8oJT54hjIMDSA2I3POh4lbyOk2t6rVw\nNLfewZjQu6pSYpcmVaXGDU75WnsmxeIqGjcmjfochcpF9BnG8OR1ZnTkIKC9dwJP\nbIFw9BGhM95gAvmf/ghIyp7h7syMbdQzHXidJ8r0e+3wDfvZGVo=\n=vG1+\n-----END PGP SIGNATURE-----", "payload": "tree 79549f727c3fc8bb0b09779a7dc3f94df43654f2\nparent 809e180a76ce97340bf4354ff357bc59e3ca40b2\nauthor David Tolnay <dtolnay@gmail.com> 1574588612 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1574838131 -0800\n\nFormat libcore with rustfmt\n\nThis commit applies rustfmt with default settings to files in\nsrc/libcore *that are not involved in any currently open PR* to minimize\nmerge conflicts. The list of files involved in open PRs was determined\nby querying GitHub's GraphQL API with this script:\nhttps://gist.github.com/dtolnay/aa9c34993dc051a4f344d1b10e4487e8\n\nWith the list of files from the script in `outstanding_files`, the\nrelevant commands were:\n\n    $ find src/libcore -name '*.rs' | xargs rustfmt --edition=2018\n    $ rg libcore outstanding_files | xargs git checkout --\n\nRepeating this process several months apart should get us coverage of\nmost of the rest of libcore.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95e00bfed801e264e9c4ac817004153ca0f19eb6", "html_url": "https://github.com/rust-lang/rust/commit/95e00bfed801e264e9c4ac817004153ca0f19eb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95e00bfed801e264e9c4ac817004153ca0f19eb6/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809e180a76ce97340bf4354ff357bc59e3ca40b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/809e180a76ce97340bf4354ff357bc59e3ca40b2", "html_url": "https://github.com/rust-lang/rust/commit/809e180a76ce97340bf4354ff357bc59e3ca40b2"}], "stats": {"total": 3094, "additions": 1800, "deletions": 1294}, "files": [{"sha": "e78dfd1ed4abfca43a6b2d1d304b78ff505790ca", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -12,8 +12,8 @@\n #![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n use crate::fmt;\n-use crate::ops::Range;\n use crate::iter::FusedIterator;\n+use crate::ops::Range;\n use crate::str::from_utf8_unchecked;\n \n /// An iterator over the escaped version of a byte.\n@@ -100,15 +100,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n         b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n         b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n         b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n-        b'\\x20' ..= b'\\x7e' => ([c, 0, 0, 0], 1),\n+        b'\\x20'..=b'\\x7e' => ([c, 0, 0, 0], 1),\n         _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n     };\n \n     return EscapeDefault { range: 0..len, data };\n \n     fn hexify(b: u8) -> u8 {\n         match b {\n-            0 ..= 9 => b'0' + b,\n+            0..=9 => b'0' + b,\n             _ => b'a' + b - 10,\n         }\n     }\n@@ -117,9 +117,15 @@ pub fn escape_default(c: u8) -> EscapeDefault {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for EscapeDefault {\n     type Item = u8;\n-    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-    fn last(mut self) -> Option<u8> { self.next_back() }\n+    fn next(&mut self) -> Option<u8> {\n+        self.range.next().map(|i| self.data[i])\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.range.size_hint()\n+    }\n+    fn last(mut self) -> Option<u8> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DoubleEndedIterator for EscapeDefault {"}, {"sha": "dd21c72e745dd70498f59caf1220b999ff4be538", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -158,7 +158,6 @@ impl From<u8> for char {\n     }\n }\n \n-\n /// An error which can be returned when parsing a char.\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -167,16 +166,16 @@ pub struct ParseCharError {\n }\n \n impl ParseCharError {\n-    #[unstable(feature = \"char_error_internals\",\n-               reason = \"this method should not be available publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"char_error_internals\",\n+        reason = \"this method should not be available publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n-            CharErrorKind::EmptyString => {\n-                \"cannot parse char from empty string\"\n-            },\n-            CharErrorKind::TooManyChars => \"too many characters in string\"\n+            CharErrorKind::EmptyString => \"cannot parse char from empty string\",\n+            CharErrorKind::TooManyChars => \"too many characters in string\",\n         }\n     }\n }\n@@ -194,7 +193,6 @@ impl fmt::Display for ParseCharError {\n     }\n }\n \n-\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n impl FromStr for char {\n     type Err = ParseCharError;\n@@ -203,18 +201,13 @@ impl FromStr for char {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         let mut chars = s.chars();\n         match (chars.next(), chars.next()) {\n-            (None, _) => {\n-                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n-            },\n+            (None, _) => Err(ParseCharError { kind: CharErrorKind::EmptyString }),\n             (Some(c), None) => Ok(c),\n-            _ => {\n-                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n-            }\n+            _ => Err(ParseCharError { kind: CharErrorKind::TooManyChars }),\n         }\n     }\n }\n \n-\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;\n@@ -304,11 +297,7 @@ pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     }\n     if num < radix {\n         let num = num as u8;\n-        if num < 10 {\n-            Some((b'0' + num) as char)\n-        } else {\n-            Some((b'a' + num - 10) as char)\n-        }\n+        if num < 10 { Some((b'0' + num) as char) } else { Some((b'a' + num - 10) as char) }\n     } else {\n         None\n     }"}, {"sha": "5e7784730e3c9c56141712d816641ac68690c0bc", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -8,7 +8,8 @@ use super::from_u32_unchecked;\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone, Debug)]\n pub struct DecodeUtf16<I>\n-    where I: Iterator<Item = u16>\n+where\n+    I: Iterator<Item = u16>,\n {\n     iter: I,\n     buf: Option<u16>,\n@@ -70,10 +71,7 @@ pub struct DecodeUtf16Error {\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[inline]\n pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n-    DecodeUtf16 {\n-        iter: iter.into_iter(),\n-        buf: None,\n-    }\n+    DecodeUtf16 { iter: iter.into_iter(), buf: None }\n }\n \n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n@@ -83,7 +81,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n     fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n-            None => self.iter.next()?\n+            None => self.iter.next()?,\n         };\n \n         if u < 0xD800 || 0xDFFF < u {"}, {"sha": "1ec614edbe2ebdd1d67728e2e613fcda3f946489", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -130,11 +130,7 @@ impl char {\n             }\n         };\n \n-        if val < radix {\n-            Some(val)\n-        } else {\n-            None\n-        }\n+        if val < radix { Some(val) } else { None }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -950,11 +946,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_uppercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_uppercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_uppercase() as char } else { *self }\n     }\n \n     /// Makes a copy of the value in its ASCII lower case equivalent.\n@@ -982,11 +974,7 @@ impl char {\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n     pub fn to_ascii_lowercase(&self) -> char {\n-        if self.is_ascii() {\n-            (*self as u8).to_ascii_lowercase() as char\n-        } else {\n-            *self\n-        }\n+        if self.is_ascii() { (*self as u8).to_ascii_lowercase() as char } else { *self }\n     }\n \n     /// Checks that two values are an ASCII case-insensitive match."}, {"sha": "a655ee6e7e32ae542c353662dadeea32a4194930", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -24,14 +24,14 @@ mod decode;\n mod methods;\n \n // stable re-exports\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::convert::{from_u32, from_digit};\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub use self::convert::from_u32_unchecked;\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-pub use self::convert::ParseCharError;\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub use self::convert::CharTryFromError;\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+pub use self::convert::ParseCharError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::convert::{from_digit, from_u32};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n@@ -45,13 +45,13 @@ use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;\n \n // UTF-8 ranges and tags for encoding characters\n-const TAG_CONT: u8     = 0b1000_0000;\n-const TAG_TWO_B: u8    = 0b1100_0000;\n-const TAG_THREE_B: u8  = 0b1110_0000;\n-const TAG_FOUR_B: u8   = 0b1111_0000;\n-const MAX_ONE_B: u32   =     0x80;\n-const MAX_TWO_B: u32   =    0x800;\n-const MAX_THREE_B: u32 =  0x10000;\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -190,11 +190,11 @@ impl Iterator for EscapeUnicode {\n         match self.state {\n             EscapeUnicodeState::Done => None,\n \n-            EscapeUnicodeState::RightBrace |\n-            EscapeUnicodeState::Value |\n-            EscapeUnicodeState::LeftBrace |\n-            EscapeUnicodeState::Type |\n-            EscapeUnicodeState::Backslash => Some('}'),\n+            EscapeUnicodeState::RightBrace\n+            | EscapeUnicodeState::Value\n+            | EscapeUnicodeState::LeftBrace\n+            | EscapeUnicodeState::Type\n+            | EscapeUnicodeState::Backslash => Some('}'),\n         }\n     }\n }\n@@ -204,14 +204,15 @@ impl ExactSizeIterator for EscapeUnicode {\n     #[inline]\n     fn len(&self) -> usize {\n         // The match is a single memory access with no branching\n-        self.hex_digit_idx + match self.state {\n-            EscapeUnicodeState::Done => 0,\n-            EscapeUnicodeState::RightBrace => 1,\n-            EscapeUnicodeState::Value => 2,\n-            EscapeUnicodeState::LeftBrace => 3,\n-            EscapeUnicodeState::Type => 4,\n-            EscapeUnicodeState::Backslash => 5,\n-        }\n+        self.hex_digit_idx\n+            + match self.state {\n+                EscapeUnicodeState::Done => 0,\n+                EscapeUnicodeState::RightBrace => 1,\n+                EscapeUnicodeState::Value => 2,\n+                EscapeUnicodeState::LeftBrace => 3,\n+                EscapeUnicodeState::Type => 4,\n+                EscapeUnicodeState::Backslash => 5,\n+            }\n     }\n }\n \n@@ -238,7 +239,7 @@ impl fmt::Display for EscapeUnicode {\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct EscapeDefault {\n-    state: EscapeDefaultState\n+    state: EscapeDefaultState,\n }\n \n #[derive(Clone, Debug)]\n@@ -284,24 +285,20 @@ impl Iterator for EscapeDefault {\n             EscapeDefaultState::Backslash(c) if n == 0 => {\n                 self.state = EscapeDefaultState::Char(c);\n                 Some('\\\\')\n-            },\n+            }\n             EscapeDefaultState::Backslash(c) if n == 1 => {\n                 self.state = EscapeDefaultState::Done;\n                 Some(c)\n-            },\n+            }\n             EscapeDefaultState::Backslash(_) => {\n                 self.state = EscapeDefaultState::Done;\n                 None\n-            },\n+            }\n             EscapeDefaultState::Char(c) => {\n                 self.state = EscapeDefaultState::Done;\n \n-                if n == 0 {\n-                    Some(c)\n-                } else {\n-                    None\n-                }\n-            },\n+                if n == 0 { Some(c) } else { None }\n+            }\n             EscapeDefaultState::Done => None,\n             EscapeDefaultState::Unicode(ref mut i) => i.nth(n),\n         }\n@@ -355,12 +352,16 @@ pub struct EscapeDebug(EscapeDefault);\n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n impl Iterator for EscapeDebug {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.0.size_hint() }\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n-impl ExactSizeIterator for EscapeDebug { }\n+impl ExactSizeIterator for EscapeDebug {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EscapeDebug {}\n@@ -440,7 +441,7 @@ impl CaseMappingIter {\n     fn new(chars: [char; 3]) -> CaseMappingIter {\n         if chars[2] == '\\0' {\n             if chars[1] == '\\0' {\n-                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+                CaseMappingIter::One(chars[0]) // Including if chars[0] == '\\0'\n             } else {\n                 CaseMappingIter::Two(chars[0], chars[1])\n             }\n@@ -493,9 +494,7 @@ impl fmt::Display for CaseMappingIter {\n                 f.write_char(b)?;\n                 f.write_char(c)\n             }\n-            CaseMappingIter::One(c) => {\n-                f.write_char(c)\n-            }\n+            CaseMappingIter::One(c) => f.write_char(c),\n             CaseMappingIter::Zero => Ok(()),\n         }\n     }"}, {"sha": "6e7a46ba62aabf2c39f77e0103d5cd6a13650d56", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -107,7 +107,7 @@\n /// [impls]: #implementors\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"clone\"]\n-pub trait Clone : Sized {\n+pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n     /// # Examples\n@@ -137,24 +137,34 @@ pub trait Clone : Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n-pub macro Clone($item:item) { /* compiler built-in */ }\n+pub macro Clone($item:item) {\n+    /* compiler built-in */\n+}\n \n // FIXME(aburka): these structs are used solely by #[derive] to\n // assert that every component of a type implements Clone or Copy.\n //\n // These structs should never appear in user code.\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n #[doc(hidden)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: crate::marker::PhantomData<T> }\n+#[unstable(\n+    feature = \"derive_clone_copy\",\n+    reason = \"deriving hack, should not be public\",\n+    issue = \"0\"\n+)]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n+    _field: crate::marker::PhantomData<T>,\n+}\n \n /// Implementations of `Clone` for primitive types.\n ///\n@@ -217,5 +227,4 @@ mod impls {\n             *self\n         }\n     }\n-\n }"}, {"sha": "08802b3a97a0c0b88a3dc88ee0471856de7ca8c3", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -95,7 +95,9 @@\n /// ```\n #[stable(feature = \"convert_id\", since = \"1.33.0\")]\n #[inline]\n-pub const fn identity<T>(x: T) -> T { x }\n+pub const fn identity<T>(x: T) -> T {\n+    x\n+}\n \n /// Used to do a cheap reference-to-reference conversion.\n ///\n@@ -364,12 +366,10 @@ pub trait Into<T>: Sized {\n /// [`from`]: trait.From.html#tymethod.from\n /// [book]: ../../book/ch09-00-error-handling.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"&str\", T=\"std::string::String\"),\n-        note=\"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n-    )\n-)]\n+#[rustc_on_unimplemented(on(\n+    all(_Self = \"&str\", T = \"std::string::String\"),\n+    note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n+))]\n pub trait From<T>: Sized {\n     /// Performs the conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -490,7 +490,9 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -499,7 +501,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &T where T: AsRef<U>\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\n+where\n+    T: AsRef<U>,\n {\n     fn as_ref(&self) -> &U {\n         <T as AsRef<U>>::as_ref(*self)\n@@ -516,7 +520,9 @@ impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T where T: AsRef<U>\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n+impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\n+where\n+    T: AsMut<U>,\n {\n     fn as_mut(&mut self) -> &mut U {\n         (*self).as_mut()\n@@ -533,7 +539,9 @@ impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T where T: AsMut<U>\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, U> Into<U> for T where U: From<T>\n+impl<T, U> Into<U> for T\n+where\n+    U: From<T>,\n {\n     fn into(self) -> U {\n         U::from(self)\n@@ -543,7 +551,9 @@ impl<T, U> Into<U> for T where U: From<T>\n // From (and thus Into) is reflexive\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> From<T> for T {\n-    fn from(t: T) -> T { t }\n+    fn from(t: T) -> T {\n+        t\n+    }\n }\n \n /// **Stability note:** This impl does not yet exist, but we are\n@@ -552,15 +562,19 @@ impl<T> From<T> for T {\n ///\n /// [#64715]: https://github.com/rust-lang/rust/issues/64715\n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_reservation_impl=\"permitting this impl would forbid us from adding \\\n-`impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n+#[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n+                            `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n impl<T> From<!> for T {\n-    fn from(t: !) -> T { t }\n+    fn from(t: !) -> T {\n+        t\n+    }\n }\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryInto<U> for T where U: TryFrom<T>\n+impl<T, U> TryInto<U> for T\n+where\n+    U: TryFrom<T>,\n {\n     type Error = U::Error;\n \n@@ -572,7 +586,10 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-impl<T, U> TryFrom<U> for T where U: Into<T> {\n+impl<T, U> TryFrom<U> for T\n+where\n+    U: Into<T>,\n+{\n     type Error = Infallible;\n \n     fn try_from(value: U) -> Result<Self, Self::Error> {"}, {"sha": "15ac3aea8b7baa2832e726fdd31325a5ab43dfb8", "filename": "src/libcore/default.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -119,7 +119,9 @@ pub trait Default: Sized {\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n-pub macro Default($item:item) { /* compiler built-in */ }\n+pub macro Default($item:item) {\n+    /* compiler built-in */\n+}\n \n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {"}, {"sha": "74ec24939a3109716e91f1c7d61cdc192480a876", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 164, "deletions": 119, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,5 +1,4 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n-\n #![allow(non_camel_case_types)]\n \n //! Utilities related to FFI bindings.\n@@ -36,12 +35,20 @@ use crate::ops::{Deref, DerefMut};\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant1,\n-    #[unstable(feature = \"c_void_variant\", reason = \"temporary implementation detail\",\n-               issue = \"0\")]\n-    #[doc(hidden)] __variant2,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant1,\n+    #[unstable(\n+        feature = \"c_void_variant\",\n+        reason = \"temporary implementation detail\",\n+        issue = \"0\"\n+    )]\n+    #[doc(hidden)]\n+    __variant2,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -53,17 +60,20 @@ impl fmt::Debug for c_void {\n \n /// Basic implementation of a `va_list`.\n // The name is WIP, using `VaListImpl` for now.\n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n #[repr(transparent)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     ptr: *mut c_void,\n@@ -73,16 +83,19 @@ pub struct VaListImpl<'f> {\n     _marker: PhantomData<&'f mut &'f c_void>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> fmt::Debug for VaListImpl<'f> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"va_list* {:p}\", self.ptr)\n@@ -97,10 +110,12 @@ impl<'f> fmt::Debug for VaListImpl<'f> {\n #[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     stack: *mut c_void,\n@@ -115,10 +130,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"powerpc\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gpr: u8,\n@@ -133,10 +150,12 @@ pub struct VaListImpl<'f> {\n #[cfg(all(target_arch = \"x86_64\", not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n #[lang = \"va_list\"]\n pub struct VaListImpl<'f> {\n     gp_offset: i32,\n@@ -149,76 +168,86 @@ pub struct VaListImpl<'f> {\n /// A wrapper for a `va_list`\n #[repr(transparent)]\n #[derive(Debug)]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n pub struct VaList<'a, 'f: 'a> {\n-    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-                  not(target_arch = \"x86_64\")),\n-              all(target_arch = \"aarch64\", target_os = \"ios\"),\n-              target_arch = \"wasm32\",\n-              target_arch = \"asmjs\",\n-              windows))]\n+    #[cfg(any(\n+        all(\n+            not(target_arch = \"aarch64\"),\n+            not(target_arch = \"powerpc\"),\n+            not(target_arch = \"x86_64\")\n+        ),\n+        all(target_arch = \"aarch64\", target_os = \"ios\"),\n+        target_arch = \"wasm32\",\n+        target_arch = \"asmjs\",\n+        windows\n+    ))]\n     inner: VaListImpl<'f>,\n \n-    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-                  target_arch = \"x86_64\"),\n-              any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-              not(target_arch = \"wasm32\"),\n-              not(target_arch = \"asmjs\"),\n-              not(windows)))]\n+    #[cfg(all(\n+        any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+        any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+        not(target_arch = \"wasm32\"),\n+        not(target_arch = \"asmjs\"),\n+        not(windows)\n+    ))]\n     inner: &'a mut VaListImpl<'f>,\n \n     _marker: PhantomData<&'a mut VaListImpl<'f>>,\n }\n \n-#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n-              not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch64\", target_os = \"ios\"),\n-          target_arch = \"wasm32\",\n-          target_arch = \"asmjs\",\n-          windows))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(any(\n+    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n+    all(target_arch = \"aarch64\", target_os = \"ios\"),\n+    target_arch = \"wasm32\",\n+    target_arch = \"asmjs\",\n+    windows\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: VaListImpl { ..*self },\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: VaListImpl { ..*self }, _marker: PhantomData }\n     }\n }\n \n-#[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\",\n-              target_arch = \"x86_64\"),\n-          any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n-          not(target_arch = \"wasm32\"),\n-          not(target_arch = \"asmjs\"),\n-          not(windows)))]\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[cfg(all(\n+    any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+    any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n+    not(target_arch = \"wasm32\"),\n+    not(target_arch = \"asmjs\"),\n+    not(windows)\n+))]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n     #[inline]\n     pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n-        VaList {\n-            inner: self,\n-            _marker: PhantomData,\n-        }\n+        VaList { inner: self, _marker: PhantomData }\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     type Target = VaListImpl<'f>;\n \n@@ -228,10 +257,12 @@ impl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n@@ -252,10 +283,12 @@ mod sealed_trait {\n     /// Trait which whitelists the allowed types to be used with [VaList::arg]\n     ///\n     /// [VaList::va_arg]: struct.VaList.html#method.arg\n-    #[unstable(feature = \"c_variadic\",\n-               reason = \"the `c_variadic` feature has not been properly tested on \\\n-                         all supported platforms\",\n-               issue = \"44930\")]\n+    #[unstable(\n+        feature = \"c_variadic\",\n+        reason = \"the `c_variadic` feature has not been properly tested on \\\n+                  all supported platforms\",\n+        issue = \"44930\"\n+    )]\n     pub trait VaArgSafe {}\n }\n \n@@ -271,25 +304,31 @@ macro_rules! impl_va_arg_safe {\n     }\n }\n \n-impl_va_arg_safe!{i8, i16, i32, i64, usize}\n-impl_va_arg_safe!{u8, u16, u32, u64, isize}\n-impl_va_arg_safe!{f64}\n+impl_va_arg_safe! {i8, i16, i32, i64, usize}\n+impl_va_arg_safe! {u8, u16, u32, u64, isize}\n+impl_va_arg_safe! {f64}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *mut T {}\n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<T> sealed_trait::VaArgSafe for *const T {}\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n@@ -299,18 +338,22 @@ impl<'f> VaListImpl<'f> {\n \n     /// Copies the `va_list` at the current location.\n     pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n-            where F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R {\n+    where\n+        F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R,\n+    {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n         va_end(&mut ap);\n         ret\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Clone for VaListImpl<'f> {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -323,10 +366,12 @@ impl<'f> Clone for VaListImpl<'f> {\n     }\n }\n \n-#[unstable(feature = \"c_variadic\",\n-           reason = \"the `c_variadic` feature has not been properly tested on \\\n-                     all supported platforms\",\n-           issue = \"44930\")]\n+#[unstable(\n+    feature = \"c_variadic\",\n+    reason = \"the `c_variadic` feature has not been properly tested on \\\n+              all supported platforms\",\n+    issue = \"44930\"\n+)]\n impl<'f> Drop for VaListImpl<'f> {\n     fn drop(&mut self) {\n         // FIXME: this should call `va_end`, but there's no clean way to"}, {"sha": "284e94926dc8524f173dc13ea263a5488fbf50e6", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 86, "deletions": 37, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,4 +1,4 @@\n-use crate::fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n+use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n@@ -7,9 +7,14 @@ use crate::num::flt2dec;\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                    sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n@@ -19,43 +24,65 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n         // we decided whether that is valid or not.\n         // We can do this only because we are libstd and coupled to the compiler.\n         // (FWIW, using `freeze` would not be enough; `flt2dec::Part` is an enum!)\n-        let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n-                                                    *num, sign, precision,\n-                                                    false, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_fixed_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                       sign: flt2dec::Sign, precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n-                                                 sign, precision, false, buf.get_mut(),\n-                                                 parts.get_mut());\n+        let formatted = flt2dec::to_shortest_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            precision,\n+            false,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n-                              negative_zero: bool, min_precision: usize) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_decimal_common<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    negative_zero: bool,\n+    min_precision: usize,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match (force_sign, negative_zero) {\n         (false, false) => flt2dec::Sign::Minus,\n-        (false, true)  => flt2dec::Sign::MinusRaw,\n-        (true,  false) => flt2dec::Sign::MinusPlus,\n-        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+        (false, true) => flt2dec::Sign::MinusRaw,\n+        (true, false) => flt2dec::Sign::MinusPlus,\n+        (true, true) => flt2dec::Sign::MinusPlusRaw,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -68,50 +95,72 @@ fn float_to_decimal_common<T>(fmt: &mut Formatter<'_>, num: &T,\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n-fn float_to_exponential_common_exact<T>(fmt: &mut Formatter<'_>, num: &T,\n-                                        sign: flt2dec::Sign, precision: usize,\n-                                        upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_exact<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    precision: usize,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n-                                                  *num, sign, precision,\n-                                                  upper, buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_exact_exp_str(\n+            flt2dec::strategy::grisu::format_exact,\n+            *num,\n+            sign,\n+            precision,\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Don't inline this so callers that call both this and the above won't wind\n // up using the combined stack space of both functions in some cases.\n #[inline(never)]\n-fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter<'_>,\n-                                           num: &T, sign: flt2dec::Sign,\n-                                           upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+fn float_to_exponential_common_shortest<T>(\n+    fmt: &mut Formatter<'_>,\n+    num: &T,\n+    sign: flt2dec::Sign,\n+    upper: bool,\n+) -> Result\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n         // FIXME(#53491)\n-        let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n-                                                     *num, sign, (0, 0), upper,\n-                                                     buf.get_mut(), parts.get_mut());\n+        let formatted = flt2dec::to_shortest_exp_str(\n+            flt2dec::strategy::grisu::format_shortest,\n+            *num,\n+            sign,\n+            (0, 0),\n+            upper,\n+            buf.get_mut(),\n+            parts.get_mut(),\n+        );\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n \n // Common code of floating point LowerExp and UpperExp.\n fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n+where\n+    T: flt2dec::DecodableFloat,\n {\n     let force_sign = fmt.sign_plus();\n     let sign = match force_sign {\n         false => flt2dec::Sign::Minus,\n-        true  => flt2dec::Sign::MinusPlus,\n+        true => flt2dec::Sign::MinusPlus,\n     };\n \n     if let Some(precision) = fmt.precision {\n@@ -123,7 +172,7 @@ fn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool)\n }\n \n macro_rules! floating {\n-    ($ty:ident) => (\n+    ($ty:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Debug for $ty {\n             fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n@@ -151,7 +200,7 @@ macro_rules! floating {\n                 float_to_exponential_common(fmt, self, true)\n             }\n         }\n-    )\n+    };\n }\n \n floating! { f32 }"}, {"sha": "4c941e2dfe6dec8df0fd84212b6c0cf59db3d221", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -4,7 +4,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::cell::{UnsafeCell, Cell, RefCell, Ref, RefMut};\n+use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n use crate::marker::PhantomData;\n use crate::mem;\n use crate::num::flt2dec;\n@@ -13,9 +13,9 @@ use crate::result;\n use crate::slice;\n use crate::str;\n \n+mod builders;\n mod float;\n mod num;\n-mod builders;\n \n #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n /// Possible alignments returned by `Formatter::align`\n@@ -33,10 +33,9 @@ pub enum Alignment {\n }\n \n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n+pub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub mod rt {\n     pub mod v1;\n@@ -234,7 +233,7 @@ pub struct Formatter<'a> {\n     width: Option<usize>,\n     precision: Option<usize>,\n \n-    buf: &'a mut (dyn Write+'a),\n+    buf: &'a mut (dyn Write + 'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n     args: &'a [ArgumentV1<'a>],\n }\n@@ -260,8 +259,7 @@ struct Void {\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[derive(Copy, Clone)]\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-           issue = \"0\")]\n+#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n #[doc(hidden)]\n pub struct ArgumentV1<'a> {\n     value: &'a Void,\n@@ -275,21 +273,13 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new<'b, T>(x: &'b T,\n-                      f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n-        unsafe {\n-            ArgumentV1 {\n-                formatter: mem::transmute(f),\n-                value: mem::transmute(x)\n-            }\n-        }\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n+        unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n         ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n@@ -305,21 +295,23 @@ impl<'a> ArgumentV1<'a> {\n \n // flags available in the v1 format of format_args\n #[derive(Copy, Clone)]\n-enum FlagV1 { SignPlus, SignMinus, Alternate, SignAwareZeroPad, DebugLowerHex, DebugUpperHex }\n+enum FlagV1 {\n+    SignPlus,\n+    SignMinus,\n+    Alternate,\n+    SignAwareZeroPad,\n+    DebugLowerHex,\n+    DebugUpperHex,\n+}\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1(pieces: &'a [&'a str],\n-                  args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: None,\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        Arguments { pieces, fmt: None, args }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n@@ -328,29 +320,26 @@ impl<'a> Arguments<'a> {\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n     /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n-    pub fn new_v1_formatted(pieces: &'a [&'a str],\n-                            args: &'a [ArgumentV1<'a>],\n-                            fmt: &'a [rt::v1::Argument]) -> Arguments<'a> {\n-        Arguments {\n-            pieces,\n-            fmt: Some(fmt),\n-            args,\n-        }\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n+    pub fn new_v1_formatted(\n+        pieces: &'a [&'a str],\n+        args: &'a [ArgumentV1<'a>],\n+        fmt: &'a [rt::v1::Argument],\n+    ) -> Arguments<'a> {\n+        Arguments { pieces, fmt: Some(fmt), args }\n     }\n \n     /// Estimates the length of the formatted text.\n     ///\n     /// This is intended to be used for setting initial `String` capacity\n     /// when using `format!`. Note: this is neither the lower nor upper bound.\n-    #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n-               issue = \"0\")]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"0\")]\n     pub fn estimated_capacity(&self) -> usize {\n-        let pieces_length: usize = self.pieces.iter()\n-            .map(|x| x.len()).sum();\n+        let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();\n \n         if self.args.is_empty() {\n             pieces_length\n@@ -514,10 +503,13 @@ impl Display for Arguments<'_> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(crate_local, label=\"`{Self}` cannot be formatted using `{{:?}}`\",\n-                    note=\"add `#[derive(Debug)]` or manually implement `{Debug}`\"),\n-    message=\"`{Self}` doesn't implement `{Debug}`\",\n-    label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n+    on(\n+        crate_local,\n+        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n+        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n+    ),\n+    message = \"`{Self}` doesn't implement `{Debug}`\",\n+    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n )]\n #[doc(alias = \"{:?}\")]\n #[rustc_diagnostic_item = \"debug_trait\"]\n@@ -553,7 +545,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Debug($item:item) { /* compiler built-in */ }\n+    pub macro Debug($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -594,14 +588,14 @@ pub use macros::Debug;\n /// ```\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"std::path::Path\",\n-        label=\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n-        note=\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n-              as they may contain non-Unicode data\"\n+        _Self = \"std::path::Path\",\n+        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n+        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n+                as they may contain non-Unicode data\"\n     ),\n-    message=\"`{Self}` doesn't implement `{Display}`\",\n-    label=\"`{Self}` cannot be formatted with the default formatter\",\n-    note=\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\",\n+    message = \"`{Self}` doesn't implement `{Display}`\",\n+    label = \"`{Self}` cannot be formatted with the default formatter\",\n+    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n )]\n #[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1073,7 +1067,9 @@ impl PostPadding {\n \n impl<'a> Formatter<'a> {\n     fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n-        where 'b: 'c, F: FnOnce(&'b mut (dyn Write+'b)) -> &'c mut (dyn Write+'c)\n+    where\n+        'b: 'c,\n+        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n     {\n         Formatter {\n             // We want to change this\n@@ -1106,7 +1102,7 @@ impl<'a> Formatter<'a> {\n \n         // Extract the correct argument\n         let value = match arg.position {\n-            rt::v1::Position::Next => { *self.curarg.next().unwrap() }\n+            rt::v1::Position::Next => *self.curarg.next().unwrap(),\n             rt::v1::Position::At(i) => self.args[i],\n         };\n \n@@ -1118,12 +1114,8 @@ impl<'a> Formatter<'a> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n-            rt::v1::Count::Param(i) => {\n-                self.args[i].as_usize()\n-            }\n-            rt::v1::Count::NextParam => {\n-                self.curarg.next()?.as_usize()\n-            }\n+            rt::v1::Count::Param(i) => self.args[i].as_usize(),\n+            rt::v1::Count::NextParam => self.curarg.next()?.as_usize(),\n         }\n     }\n \n@@ -1174,18 +1166,16 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pad_integral(&mut self,\n-                        is_nonnegative: bool,\n-                        prefix: &str,\n-                        buf: &str)\n-                        -> Result {\n+    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n         let mut width = buf.len();\n \n         let mut sign = None;\n         if !is_nonnegative {\n-            sign = Some('-'); width += 1;\n+            sign = Some('-');\n+            width += 1;\n         } else if self.sign_plus() {\n-            sign = Some('+'); width += 1;\n+            sign = Some('+');\n+            width += 1;\n         }\n \n         let prefix = if self.alternate() {\n@@ -1201,11 +1191,7 @@ impl<'a> Formatter<'a> {\n             if let Some(c) = sign {\n                 f.buf.write_char(c)?;\n             }\n-            if let Some(prefix) = prefix {\n-                f.buf.write_str(prefix)\n-            } else {\n-                Ok(())\n-            }\n+            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n         }\n \n         // The `width` field is more of a `min-width` parameter at this point.\n@@ -1301,9 +1287,7 @@ impl<'a> Formatter<'a> {\n             None => self.buf.write_str(s),\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.chars().count() >= width => {\n-                self.buf.write_str(s)\n-            }\n+            Some(width) if s.chars().count() >= width => self.buf.write_str(s),\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n@@ -1321,17 +1305,16 @@ impl<'a> Formatter<'a> {\n     fn padding(\n         &mut self,\n         padding: usize,\n-        default: rt::v1::Alignment\n+        default: rt::v1::Alignment,\n     ) -> result::Result<PostPadding, Error> {\n         let align = match self.align {\n             rt::v1::Alignment::Unknown => default,\n-            _ => self.align\n+            _ => self.align,\n         };\n \n         let (pre_pad, post_pad) = match align {\n             rt::v1::Alignment::Left => (0, padding),\n-            rt::v1::Alignment::Right |\n-            rt::v1::Alignment::Unknown => (padding, 0),\n+            rt::v1::Alignment::Right | rt::v1::Alignment::Unknown => (padding, 0),\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n@@ -1368,7 +1351,8 @@ impl<'a> Formatter<'a> {\n \n             // remaining parts go through the ordinary padding process.\n             let len = formatted.len();\n-            let ret = if width <= len { // no padding\n+            let ret = if width <= len {\n+                // no padding\n                 self.write_formatted_parts(&formatted)\n             } else {\n                 let post_padding = self.padding(width - len, align)?;\n@@ -1473,10 +1457,14 @@ impl<'a> Formatter<'a> {\n \n     /// Flags for formatting\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.24.0\",\n-                       reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n-                                 or `sign_aware_zero_pad` methods instead\")]\n-    pub fn flags(&self) -> u32 { self.flags }\n+    #[rustc_deprecated(\n+        since = \"1.24.0\",\n+        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n+                  or `sign_aware_zero_pad` methods instead\"\n+    )]\n+    pub fn flags(&self) -> u32 {\n+        self.flags\n+    }\n \n     /// Character used as 'fill' whenever there is alignment.\n     ///\n@@ -1506,7 +1494,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn fill(&self) -> char { self.fill }\n+    pub fn fill(&self) -> char {\n+        self.fill\n+    }\n \n     /// Flag indicating what form of alignment was requested.\n     ///\n@@ -1574,7 +1564,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn width(&self) -> Option<usize> { self.width }\n+    pub fn width(&self) -> Option<usize> {\n+        self.width\n+    }\n \n     /// Optionally specified precision for numeric types.\n     ///\n@@ -1601,7 +1593,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn precision(&self) -> Option<usize> { self.precision }\n+    pub fn precision(&self) -> Option<usize> {\n+        self.precision\n+    }\n \n     /// Determines if the `+` flag was specified.\n     ///\n@@ -1629,7 +1623,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n+    pub fn sign_plus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignPlus as u32) != 0\n+    }\n \n     /// Determines if the `-` flag was specified.\n     ///\n@@ -1655,7 +1651,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n+    pub fn sign_minus(&self) -> bool {\n+        self.flags & (1 << FlagV1::SignMinus as u32) != 0\n+    }\n \n     /// Determines if the `#` flag was specified.\n     ///\n@@ -1680,7 +1678,9 @@ impl<'a> Formatter<'a> {\n     /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n     /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n-    pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n+    pub fn alternate(&self) -> bool {\n+        self.flags & (1 << FlagV1::Alternate as u32) != 0\n+    }\n \n     /// Determines if the `0` flag was specified.\n     ///\n@@ -1709,9 +1709,13 @@ impl<'a> Formatter<'a> {\n \n     // FIXME: Decide what public API we want for these two flags.\n     // https://github.com/rust-lang/rust/issues/48584\n-    fn debug_lower_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0 }\n+    fn debug_lower_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugLowerHex as u32) != 0\n+    }\n \n-    fn debug_upper_hex(&self) -> bool { self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0 }\n+    fn debug_upper_hex(&self) -> bool {\n+        self.flags & (1 << FlagV1::DebugUpperHex as u32) != 0\n+    }\n \n     /// Creates a [`DebugStruct`] builder designed to assist with creation of\n     /// [`fmt::Debug`] implementations for structs.\n@@ -2067,11 +2071,15 @@ impl<T: ?Sized> Pointer for &mut T {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *const T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Debug for *mut T {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> Result { Pointer::fmt(self, f) }\n+    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n+        Pointer::fmt(self, f)\n+    }\n }\n \n macro_rules! peel {\n@@ -2129,21 +2137,15 @@ impl<T: ?Sized> Debug for PhantomData<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n-        f.debug_struct(\"Cell\")\n-            .field(\"value\", &self.get())\n-            .finish()\n+        f.debug_struct(\"Cell\").field(\"value\", &self.get()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n         match self.try_borrow() {\n-            Ok(borrow) => {\n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &borrow)\n-                    .finish()\n-            }\n+            Ok(borrow) => f.debug_struct(\"RefCell\").field(\"value\", &borrow).finish(),\n             Err(_) => {\n                 // The RefCell is mutably borrowed so we can't look at its value\n                 // here. Show a placeholder instead.\n@@ -2155,9 +2157,7 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n                     }\n                 }\n \n-                f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &BorrowedPlaceholder)\n-                    .finish()\n+                f.debug_struct(\"RefCell\").field(\"value\", &BorrowedPlaceholder).finish()\n             }\n         }\n     }"}, {"sha": "0db8d86ebbf529cc56f89ece36e15ff4275478b5", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -192,7 +192,8 @@ pub trait Hash {\n     /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n-        where Self: Sized\n+    where\n+        Self: Sized,\n     {\n         for piece in data {\n             piece.hash(state);\n@@ -206,7 +207,9 @@ pub(crate) mod macros {\n     #[rustc_builtin_macro]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro Hash($item:item) { /* compiler built-in */ }\n+    pub macro Hash($item:item) {\n+        /* compiler built-in */\n+    }\n }\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(inline)]\n@@ -666,7 +669,6 @@ mod impls {\n         }\n     }\n \n-\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized + Hash> Hash for &T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n@@ -689,9 +691,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }\n@@ -706,9 +706,7 @@ mod impls {\n                 state.write_usize(*self as *const () as usize);\n             } else {\n                 // Fat pointer\n-                let (a, b) = unsafe {\n-                    *(self as *const Self as *const (usize, usize))\n-                };\n+                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n                 state.write_usize(a);\n                 state.write_usize(b);\n             }"}, {"sha": "0aa3b97ebcf15d6725ad2598f537dd5259c9cae6", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -4,10 +4,10 @@\n \n #![allow(deprecated)] // the types in this module are deprecated\n \n-use crate::marker::PhantomData;\n-use crate::ptr;\n use crate::cmp;\n+use crate::marker::PhantomData;\n use crate::mem;\n+use crate::ptr;\n \n /// An implementation of SipHash 1-3.\n ///\n@@ -16,8 +16,10 @@ use crate::mem;\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n #[doc(hidden)]\n pub struct SipHasher13 {\n@@ -28,8 +30,10 @@ pub struct SipHasher13 {\n ///\n /// See: <https://131002.net/siphash/>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -48,8 +52,10 @@ struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.13.0\",\n-                   reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+#[rustc_deprecated(\n+    since = \"1.13.0\",\n+    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+)]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -58,9 +64,9 @@ struct Hasher<S: Sip> {\n     k0: u64,\n     k1: u64,\n     length: usize, // how many bytes we've processed\n-    state: State, // hash State\n-    tail: u64, // unprocessed bytes le\n-    ntail: usize, // how many bytes in tail are valid\n+    state: State,  // hash State\n+    tail: u64,     // unprocessed bytes le\n+    ntail: usize,  // how many bytes in tail are valid\n     _marker: PhantomData<S>,\n }\n \n@@ -78,18 +84,23 @@ struct State {\n }\n \n macro_rules! compress {\n-    ($state:expr) => ({\n-        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n-    });\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-    ({\n-        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+    ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n+        $v0 = $v0.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(13);\n+        $v1 ^= $v0;\n         $v0 = $v0.rotate_left(32);\n-        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n-        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n-        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(16);\n+        $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(21);\n+        $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(17);\n+        $v1 ^= $v2;\n         $v2 = $v2.rotate_left(32);\n-    });\n+    }};\n }\n \n /// Loads an integer of the desired type from a byte stream, in LE order. Uses\n@@ -98,15 +109,16 @@ macro_rules! compress {\n ///\n /// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) =>\n-    ({\n-       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-       let mut data = 0 as $int_ty;\n-       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n-                                &mut data as *mut _ as *mut u8,\n-                                mem::size_of::<$int_ty>());\n-       data.to_le()\n-    });\n+    ($buf:expr, $i:expr, $int_ty:ident) => {{\n+        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+        let mut data = 0 as $int_ty;\n+        ptr::copy_nonoverlapping(\n+            $buf.get_unchecked($i),\n+            &mut data as *mut _ as *mut u8,\n+            mem::size_of::<$int_ty>(),\n+        );\n+        data.to_le()\n+    }};\n }\n \n /// Loads an u64 using up to 7 bytes of a byte slice.\n@@ -137,43 +149,47 @@ impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher(SipHasher24 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        })\n+        SipHasher(SipHasher24 { hasher: Hasher::new_with_keys(key0, key1) })\n     }\n }\n \n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n-    #[rustc_deprecated(since = \"1.13.0\",\n-                       reason = \"use `std::collections::hash_map::DefaultHasher` instead\")]\n+    #[rustc_deprecated(\n+        since = \"1.13.0\",\n+        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n+    )]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n-        SipHasher13 {\n-            hasher: Hasher::new_with_keys(key0, key1)\n-        }\n+        SipHasher13 { hasher: Hasher::new_with_keys(key0, key1) }\n     }\n }\n \n@@ -184,12 +200,7 @@ impl<S: Sip> Hasher<S> {\n             k0: key0,\n             k1: key1,\n             length: 0,\n-            state: State {\n-                v0: 0,\n-                v1: 0,\n-                v2: 0,\n-                v3: 0,\n-            },\n+            state: State { v0: 0, v1: 0, v2: 0, v3: 0 },\n             tail: 0,\n             ntail: 0,\n             _marker: PhantomData,\n@@ -294,7 +305,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n                 self.ntail += length;\n-                return\n+                return;\n             } else {\n                 self.state.v3 ^= self.tail;\n                 S::c_rounds(&mut self.state);"}, {"sha": "0a7a9f26f891257211a68aff95006aed783eb152", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 91, "deletions": 37, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,7 +1,7 @@\n use crate::fmt;\n use crate::ops::Try;\n \n-use super::super::{Iterator, DoubleEndedIterator, FusedIterator};\n+use super::super::{DoubleEndedIterator, FusedIterator, Iterator};\n use super::Map;\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -15,7 +15,7 @@ use super::Map;\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct FlatMap<I, U: IntoIterator, F> {\n-    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n     pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n@@ -28,7 +28,9 @@ impl<I: Clone, U, F: Clone> Clone for FlatMap<I, U, F>\n where\n     U: Clone + IntoIterator<IntoIter: Clone>,\n {\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        FlatMap { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -43,26 +45,35 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n+where\n+    F: FnMut(I::Item) -> U,\n {\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -75,26 +86,37 @@ where\n     U: IntoIterator<IntoIter: DoubleEndedIterator>,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+where\n+    I: FusedIterator,\n+    U: IntoIterator,\n+    F: FnMut(I::Item) -> U,\n+{\n+}\n \n /// An iterator that flattens one level of nesting in an iterator of things\n /// that can be turned into iterators.\n@@ -133,7 +155,9 @@ where\n     I: Clone + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Clone + Iterator,\n {\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+    fn clone(&self) -> Self {\n+        Flatten { inner: self.inner.clone() }\n+    }\n }\n \n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n@@ -145,21 +169,29 @@ where\n     type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+    fn next(&mut self) -> Option<U::Item> {\n+        self.inner.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_fold(init, fold)\n     }\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.fold(init, fold)\n     }\n@@ -172,18 +204,24 @@ where\n     U: DoubleEndedIterator,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        self.inner.next_back()\n+    }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         self.inner.try_rfold(init, fold)\n     }\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         self.inner.rfold(init, fold)\n     }\n@@ -194,7 +232,8 @@ impl<I, U> FusedIterator for Flatten<I>\n where\n     I: FusedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n     U: Iterator,\n-{}\n+{\n+}\n \n /// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n /// this type.\n@@ -222,7 +261,9 @@ where\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n+                if let elt @ Some(_) = inner.next() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next() {\n                 None => return self.backiter.as_mut()?.next(),\n@@ -238,13 +279,16 @@ where\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n+            _ => (lo, None),\n         }\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n@@ -277,7 +321,8 @@ where\n \n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: Iterator, Acc>(\n@@ -286,7 +331,8 @@ where\n             move |acc, iter| iter.fold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .fold(init, flatten(fold))\n@@ -302,7 +348,9 @@ where\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n+                if let elt @ Some(_) = inner.next_back() {\n+                    return elt;\n+                }\n             }\n             match self.iter.next_back() {\n                 None => return self.frontiter.as_mut()?.next_back(),\n@@ -312,14 +360,18 @@ where\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n     {\n         #[inline]\n         fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n             backiter: &'a mut Option<T::IntoIter>,\n             fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n-        ) -> impl FnMut(Acc, T) -> R + 'a where\n+        ) -> impl FnMut(Acc, T) -> R + 'a\n+        where\n             T::IntoIter: DoubleEndedIterator,\n         {\n             move |acc, x| {\n@@ -348,7 +400,8 @@ where\n \n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         #[inline]\n         fn flatten<U: DoubleEndedIterator, Acc>(\n@@ -357,7 +410,8 @@ where\n             move |acc, iter| iter.rfold(acc, &mut *fold)\n         }\n \n-        self.frontiter.into_iter()\n+        self.frontiter\n+            .into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n             .rfold(init, flatten(fold))"}, {"sha": "ffac7d4e995389981fcb65d557cba78457751df4", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -12,23 +12,29 @@ use super::{FusedIterator, TrustedLen};\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat<A> {\n-    element: A\n+    element: A,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -91,7 +97,7 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat{element: elt}\n+    Repeat { element: elt }\n }\n \n /// An iterator that repeats elements of type `A` endlessly by\n@@ -104,18 +110,22 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n pub struct RepeatWith<F> {\n-    repeater: F\n+    repeater: F,\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { Some((self.repeater)()) }\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n }\n \n #[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n@@ -213,7 +223,7 @@ impl<T> Iterator for Empty<T> {\n         None\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>){\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, Some(0))\n     }\n }\n@@ -283,7 +293,7 @@ pub const fn empty<T>() -> Empty<T> {\n #[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>\n+    inner: crate::option::IntoIter<T>,\n }\n \n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n@@ -530,7 +540,8 @@ pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n #[inline]\n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     FromFn(f)\n }\n@@ -547,7 +558,8 @@ pub struct FromFn<F>(F);\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n impl<T, F> Iterator for FromFn<F>\n-    where F: FnMut() -> Option<T>\n+where\n+    F: FnMut() -> Option<T>,\n {\n     type Item = T;\n \n@@ -577,15 +589,13 @@ impl<F> fmt::Debug for FromFn<F> {\n /// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     // If this function returned `impl Iterator<Item=T>`\n     // it could be based on `unfold` and not need a dedicated type.\n     // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors {\n-        next: first,\n-        succ,\n-    }\n+    Successors { next: first, succ }\n }\n \n /// An new iterator where each successive item is computed based on the preceding one.\n@@ -603,7 +613,8 @@ pub struct Successors<T, F> {\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T, F> Iterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n+where\n+    F: FnMut(&T) -> Option<T>,\n {\n     type Item = T;\n \n@@ -616,24 +627,16 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() {\n-            (1, None)\n-        } else {\n-            (0, Some(0))\n-        }\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n     }\n }\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F>\n-    where F: FnMut(&T) -> Option<T>\n-{}\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n \n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\")\n-            .field(\"next\", &self.next)\n-            .finish()\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n     }\n }"}, {"sha": "65af671ddf2045005f24cf1a8b92a1eea5eb7e4b", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,6 +1,6 @@\n-use crate::ops::{Mul, Add};\n-use crate::num::Wrapping;\n use crate::iter;\n+use crate::num::Wrapping;\n+use crate::ops::{Add, Mul};\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///\n@@ -17,7 +17,7 @@ pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// \"summing up\" the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn sum<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n /// Trait to represent types that can be created by multiplying elements of an\n@@ -36,7 +36,7 @@ pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// multiplying the items.\n     #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+    fn product<I: Iterator<Item = A>>(iter: I) -> Self;\n }\n \n // N.B., explicitly use Add and Mul here to inherit overflow checks\n@@ -115,9 +115,10 @@ macro_rules! float_sum_product {\n integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n float_sum_product! { f32 f64 }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n-    where T: Sum<U>,\n+where\n+    T: Sum<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n@@ -137,21 +138,24 @@ impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n     /// assert_eq!(res, Ok(3));\n     /// ```\n     fn sum<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.sum())\n     }\n }\n \n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\n impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n-    where T: Product<U>,\n+where\n+    T: Product<U>,\n {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n     /// the product of all elements is returned.\n     fn product<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n+    where\n+        I: Iterator<Item = Result<U, E>>,\n     {\n         iter::process_results(iter, |i| i.product())\n     }"}, {"sha": "104724d9fb63a2bae43f7e5c14f0fa08a0928054", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,5 +1,5 @@\n-use crate::ops::Try;\n use crate::iter::LoopState;\n+use crate::ops::Try;\n \n /// An iterator able to yield elements from both ends.\n ///\n@@ -113,7 +113,9 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n     fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in self.rev() {\n-            if n == 0 { return Some(x) }\n+            if n == 0 {\n+                return Some(x);\n+            }\n             n -= 1;\n         }\n         None\n@@ -157,7 +159,7 @@ pub trait DoubleEndedIterator: Iterator {\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok=B>\n+        R: Try<Ok = B>,\n     {\n         let mut accum = init;\n         while let Some(x) = self.next_back() {\n@@ -279,7 +281,7 @@ pub trait DoubleEndedIterator: Iterator {\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n-        P: FnMut(&Self::Item) -> bool\n+        P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n         fn check<T>("}, {"sha": "cf460745ffa3032faea6500731a7c0cffcbeda80", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 141, "deletions": 64, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -337,13 +337,17 @@ macro_rules! matches {\n #[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n #[doc(alias = \"?\")]\n macro_rules! r#try {\n-    ($expr:expr) => (match $expr {\n-        $crate::result::Result::Ok(val) => val,\n-        $crate::result::Result::Err(err) => {\n-            return $crate::result::Result::Err($crate::convert::From::from(err))\n+    ($expr:expr) => {\n+        match $expr {\n+            $crate::result::Result::Ok(val) => val,\n+            $crate::result::Result::Err(err) => {\n+                return $crate::result::Result::Err($crate::convert::From::from(err));\n+            }\n         }\n-    });\n-    ($expr:expr,) => ($crate::r#try!($expr));\n+    };\n+    ($expr:expr,) => {\n+        $crate::r#try!($expr)\n+    };\n }\n \n /// Writes formatted data into a buffer.\n@@ -734,8 +738,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ })\n+        ($msg:expr) => {{ /* compiler built-in */ }};\n+        ($msg:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n@@ -788,20 +792,23 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Same as `format_args`, but adds a newline in the end.\n-    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n-               reason = \"`format_args_nl` is only for internal \\\n-                         language use and is subject to change\")]\n+    #[unstable(\n+        feature = \"format_args_nl\",\n+        issue = \"0\",\n+        reason = \"`format_args_nl` is only for internal \\\n+                  language use and is subject to change\"\n+    )]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! format_args_nl {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+        ($fmt:expr) => {{ /* compiler built-in */ }};\n+        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inspects an environment variable at compile time.\n@@ -839,8 +846,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n@@ -866,8 +873,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ })\n+        ($name:expr) => {{ /* compiler built-in */ }};\n+        ($name:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates identifiers into one identifier.\n@@ -894,13 +901,16 @@ pub(crate) mod builtin {\n     /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n     /// # }\n     /// ```\n-    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n-               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"concat_idents\",\n+        issue = \"29599\",\n+        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ })\n+        ($($e:ident),+) => {{ /* compiler built-in */ }};\n+        ($($e:ident,)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Concatenates literals into a static string slice.\n@@ -922,8 +932,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ })\n+        ($($e:expr),*) => {{ /* compiler built-in */ }};\n+        ($($e:expr,)*) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to the line number on which it was invoked.\n@@ -950,7 +960,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! line { () => { /* compiler built-in */ } }\n+    macro_rules! line {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the column number at which it was invoked.\n     ///\n@@ -976,7 +990,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! column { () => { /* compiler built-in */ } }\n+    macro_rules! column {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Expands to the file name in which it was invoked.\n     ///\n@@ -1001,7 +1019,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! file { () => { /* compiler built-in */ } }\n+    macro_rules! file {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Stringifies its arguments.\n     ///\n@@ -1021,7 +1043,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! stringify { ($($t:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! stringify {\n+        ($($t:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n@@ -1057,8 +1083,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Includes a file as a reference to a byte array.\n@@ -1095,8 +1121,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Expands to a string that represents the current module path.\n@@ -1119,7 +1145,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! module_path { () => { /* compiler built-in */ } }\n+    macro_rules! module_path {\n+        () => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n     ///\n@@ -1144,7 +1174,11 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! cfg { ($($cfg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! cfg {\n+        ($($cfg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n@@ -1189,8 +1223,8 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ })\n+        ($file:expr) => {{ /* compiler built-in */ }};\n+        ($file:expr,) => {{ /* compiler built-in */ }};\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n@@ -1242,85 +1276,128 @@ pub(crate) mod builtin {\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n+        ($cond:expr) => {{ /* compiler built-in */ }};\n+        ($cond:expr,) => {{ /* compiler built-in */ }};\n+        ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};\n     }\n \n     /// Inline assembly.\n     ///\n     /// Read the [unstable book] for the usage.\n     ///\n     /// [unstable book]: ../unstable-book/library-features/asm.html\n-    #[unstable(feature = \"asm\", issue = \"29722\",\n-               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"asm\",\n+        issue = \"29722\",\n+        reason = \"inline assembly is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! asm { (\"assembly template\"\n+    macro_rules! asm {\n+        (\"assembly template\"\n                         : $(\"output\"(operand),)*\n                         : $(\"input\"(operand),)*\n                         : $(\"clobbers\",)*\n-                        : $(\"options\",)*) => { /* compiler built-in */ } }\n+                        : $(\"options\",)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Module-level inline assembly.\n-    #[unstable(feature = \"global_asm\", issue = \"35119\",\n-               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"global_asm\",\n+        issue = \"35119\",\n+        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! global_asm { (\"assembly\") => { /* compiler built-in */ } }\n+    macro_rules! global_asm {\n+        (\"assembly\") => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Prints passed tokens into the standard output.\n-    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n-               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"log_syntax\",\n+        issue = \"29598\",\n+        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    macro_rules! log_syntax { ($($arg:tt)*) => { /* compiler built-in */ } }\n+    macro_rules! log_syntax {\n+        ($($arg:tt)*) => {\n+            /* compiler built-in */\n+        };\n+    }\n \n     /// Enables or disables tracing functionality used for debugging other macros.\n-    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n-               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[unstable(\n+        feature = \"trace_macros\",\n+        issue = \"29598\",\n+        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n+    )]\n     #[rustc_builtin_macro]\n     #[macro_export]\n     macro_rules! trace_macros {\n-        (true) => ({ /* compiler built-in */ });\n-        (false) => ({ /* compiler built-in */ })\n+        (true) => {{ /* compiler built-in */ }};\n+        (false) => {{ /* compiler built-in */ }};\n     }\n \n     /// Attribute macro applied to a function to turn it into a unit test.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test($item:item) { /* compiler built-in */ }\n+    pub macro test($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(soft, feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[unstable(\n+        feature = \"test\",\n+        issue = \"50297\",\n+        soft,\n+        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro bench($item:item) { /* compiler built-in */ }\n+    pub macro bench($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n-    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n-               reason = \"custom test frameworks are an unstable feature\")]\n+    #[unstable(\n+        feature = \"custom_test_frameworks\",\n+        issue = \"50297\",\n+        reason = \"custom test frameworks are an unstable feature\"\n+    )]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro test_case($item:item) { /* compiler built-in */ }\n+    pub macro test_case($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+    pub macro global_allocator($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n-    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcDecodable($item:item) {\n+        /* compiler built-in */\n+    }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n-    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n+    pub macro RustcEncodable($item:item) {\n+        /* compiler built-in */\n+    }\n }"}, {"sha": "34fc0618ea2ae182655e4db3e02b95a2ef9c846f", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,5 +1,5 @@\n-use crate::ptr;\n use crate::ops::{Deref, DerefMut};\n+use crate::ptr;\n \n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///"}, {"sha": "b8ddd5322a1da04245272c1dfdc98f0c8aa99d67", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -12,13 +12,15 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_bignum\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_bignum\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n #![macro_use]\n \n-use crate::mem;\n use crate::intrinsics;\n+use crate::mem;\n \n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n@@ -36,10 +38,8 @@ pub trait FullOps: Sized {\n \n     /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n     /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n-    fn full_div_rem(self,\n-                    other: Self,\n-                    borrow: Self)\n-                    -> (Self /* quotient */, Self /* remainder */);\n+    fn full_div_rem(self, other: Self, borrow: Self)\n+    -> (Self /* quotient */, Self /* remainder */);\n }\n \n macro_rules! impl_full_ops {\n@@ -98,7 +98,7 @@ impl_full_ops! {\n const SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n \n macro_rules! define_bignum {\n-    ($name:ident: type=$ty:ty, n=$n:expr) => (\n+    ($name:ident: type=$ty:ty, n=$n:expr) => {\n         /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n         ///\n         /// This is backed by a fixed-size array of given type (\"digit\").\n@@ -115,7 +115,7 @@ macro_rules! define_bignum {\n             size: usize,\n             /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n             /// where `W` is the number of bits in the digit type.\n-            base: [$ty; $n]\n+            base: [$ty; $n],\n         }\n \n         impl $name {\n@@ -180,7 +180,7 @@ macro_rules! define_bignum {\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's\n                 // probably not worth the hassle.\n-                let digitbits = mem::size_of::<$ty>()* 8;\n+                let digitbits = mem::size_of::<$ty>() * 8;\n                 let mut i = nonzero.len() * digitbits - 1;\n                 while self.get_bit(i) == 0 {\n                     i -= 1;\n@@ -272,12 +272,12 @@ macro_rules! define_bignum {\n                 let bits = bits % digitbits;\n \n                 assert!(digits < $n);\n-                debug_assert!(self.base[$n-digits..].iter().all(|&v| v == 0));\n-                debug_assert!(bits == 0 || (self.base[$n-digits-1] >> (digitbits - bits)) == 0);\n+                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n+                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n \n                 // shift by `digits * digitbits` bits\n                 for i in (0..self.size).rev() {\n-                    self.base[i+digits] = self.base[i];\n+                    self.base[i + digits] = self.base[i];\n                 }\n                 for i in 0..digits {\n                     self.base[i] = 0;\n@@ -287,14 +287,14 @@ macro_rules! define_bignum {\n                 let mut sz = self.size + digits;\n                 if bits > 0 {\n                     let last = sz;\n-                    let overflow = self.base[last-1] >> (digitbits - bits);\n+                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                     if overflow > 0 {\n                         self.base[last] = overflow;\n                         sz += 1;\n                     }\n-                    for i in (digits+1..last).rev() {\n-                        self.base[i] = (self.base[i] << bits) |\n-                                       (self.base[i-1] >> (digitbits - bits));\n+                    for i in (digits + 1..last).rev() {\n+                        self.base[i] =\n+                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                     }\n                     self.base[digits] <<= bits;\n                     // self.base[..digits] is zero, no need to shift\n@@ -331,7 +331,6 @@ macro_rules! define_bignum {\n                 self\n             }\n \n-\n             /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n             /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n             /// and returns its own mutable reference.\n@@ -342,7 +341,9 @@ macro_rules! define_bignum {\n \n                     let mut retsz = 0;\n                     for (i, &a) in aa.iter().enumerate() {\n-                        if a == 0 { continue; }\n+                        if a == 0 {\n+                            continue;\n+                        }\n                         let mut sz = bb.len();\n                         let mut carry = 0;\n                         for (j, &b) in bb.iter().enumerate() {\n@@ -430,11 +431,12 @@ macro_rules! define_bignum {\n         }\n \n         impl crate::cmp::PartialEq for $name {\n-            fn eq(&self, other: &$name) -> bool { self.base[..] == other.base[..] }\n+            fn eq(&self, other: &$name) -> bool {\n+                self.base[..] == other.base[..]\n+            }\n         }\n \n-        impl crate::cmp::Eq for $name {\n-        }\n+        impl crate::cmp::Eq for $name {}\n \n         impl crate::cmp::PartialOrd for $name {\n             fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n@@ -462,17 +464,17 @@ macro_rules! define_bignum {\n             fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n                 use crate::mem;\n \n-                let sz = if self.size < 1 {1} else {self.size};\n+                let sz = if self.size < 1 { 1 } else { self.size };\n                 let digitlen = mem::size_of::<$ty>() * 2;\n \n-                write!(f, \"{:#x}\", self.base[sz-1])?;\n-                for &v in self.base[..sz-1].iter().rev() {\n+                write!(f, \"{:#x}\", self.base[sz - 1])?;\n+                for &v in self.base[..sz - 1].iter().rev() {\n                     write!(f, \"_{:01$x}\", v, digitlen)?;\n                 }\n                 crate::result::Result::Ok(())\n             }\n         }\n-    )\n+    };\n }\n \n /// The digit type for `Big32x40`."}, {"sha": "c5f6903f379c405cc294695ddb5d129044ba67c0", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,11 +1,11 @@\n //! The various algorithms from the paper.\n \n use crate::cmp::min;\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n-use crate::num::diy_float::Fp;\n-use crate::num::dec2flt::table;\n-use crate::num::dec2flt::rawfp::{self, Unpacked, RawFloat, fp_to_float, next_float, prev_float};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::num::dec2flt::num::{self, Big};\n+use crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\n+use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n \n /// Number of significand bits in Fp\n const P: u32 = 64;\n@@ -23,17 +23,17 @@ fn power_of_ten(e: i16) -> Fp {\n \n // In most architectures, floating point operations have an explicit bit size, therefore the\n // precision of the computation is determined on a per-operation basis.\n-#[cfg(any(not(target_arch=\"x86\"), target_feature=\"sse2\"))]\n+#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\n mod fpu_precision {\n-    pub fn set_precision<T>() { }\n+    pub fn set_precision<T>() {}\n }\n \n // On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n // The x87 FPU operates with 80 bits of precision by default, which means that operations will\n // round to 80 bits causing double rounding to happen when values are eventually represented as\n // 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n // computations are performed in the desired precision.\n-#[cfg(all(target_arch=\"x86\", not(target_feature=\"sse2\")))]\n+#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\n mod fpu_precision {\n     use crate::mem::size_of;\n "}, {"sha": "6fe9af8cbd8ee93bd2cd00067a398a0f594a233d", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -78,23 +78,25 @@\n //! turned into {positive,negative} {zero,infinity}.\n \n #![doc(hidden)]\n-#![unstable(feature = \"dec2flt\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"dec2flt\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::parse::{parse_decimal, Decimal, Sign, ParseResult};\n use self::num::digits_to_big;\n+use self::parse::{parse_decimal, Decimal, ParseResult, Sign};\n use self::rawfp::RawFloat;\n \n mod algorithm;\n-mod table;\n mod num;\n+mod table;\n // These two have their own tests.\n-pub mod rawfp;\n pub mod parse;\n+pub mod rawfp;\n \n macro_rules! from_str_float_impl {\n     ($t:ty) => {\n@@ -155,7 +157,7 @@ macro_rules! from_str_float_impl {\n                 dec2flt(src)\n             }\n         }\n-    }\n+    };\n }\n from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n@@ -171,7 +173,7 @@ from_str_float_impl!(f64);\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n-    kind: FloatErrorKind\n+    kind: FloatErrorKind,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -181,10 +183,12 @@ enum FloatErrorKind {\n }\n \n impl ParseFloatError {\n-    #[unstable(feature = \"int_error_internals\",\n-               reason = \"available through Error trait and this method should \\\n-                         not be exposed publicly\",\n-               issue = \"0\")]\n+    #[unstable(\n+        feature = \"int_error_internals\",\n+        reason = \"available through Error trait and this method should \\\n+                  not be exposed publicly\",\n+        issue = \"0\"\n+    )]\n     #[doc(hidden)]\n     pub fn __description(&self) -> &str {\n         match self.kind {\n@@ -222,7 +226,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n /// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n-        return Err(pfe_empty())\n+        return Err(pfe_empty());\n     }\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n@@ -232,8 +236,10 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n         ParseResult::Invalid => match s {\n             \"inf\" => T::INFINITY,\n             \"NaN\" => T::NAN,\n-            _ => { return Err(pfe_invalid()); }\n-        }\n+            _ => {\n+                return Err(pfe_invalid());\n+            }\n+        },\n     };\n \n     match sign {"}, {"sha": "208783dd32fd5df8c271cbb0c69e308b4f3e1f2b", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -2,7 +2,7 @@\n \n // FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n \n-use crate::cmp::Ordering::{self, Less, Equal, Greater};\n+use crate::cmp::Ordering::{self, Equal, Greater, Less};\n \n pub use crate::num::bignum::Big32x40 as Big;\n \n@@ -36,7 +36,10 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n /// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n /// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n ///    more complicated than this entire function.\n-pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'a u8> {\n+pub fn from_str_unchecked<'a, T>(bytes: T) -> u64\n+where\n+    T: IntoIterator<Item = &'a u8>,\n+{\n     let mut result = 0;\n     for &c in bytes {\n         result = result * 10 + (c - b'0') as u64;\n@@ -61,14 +64,9 @@ pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n pub fn to_u64(x: &Big) -> u64 {\n     assert!(x.bit_length() < 64);\n     let d = x.digits();\n-    if d.len() < 2 {\n-        d[0] as u64\n-    } else {\n-        (d[1] as u64) << 32 | d[0] as u64\n-    }\n+    if d.len() < 2 { d[0] as u64 } else { (d[1] as u64) << 32 | d[0] as u64 }\n }\n \n-\n /// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual."}, {"sha": "93b08bce853c7e44e143229016be2572232b07af", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -10,8 +10,8 @@\n //! modules rely on to not panic (or overflow) in turn.\n //! To make matters worse, all that happens in a single pass over the input.\n //! So, be careful when modifying anything, and double-check with the other modules.\n+use self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\n use super::num;\n-use self::ParseResult::{Valid, ShortcutToInf, ShortcutToZero, Invalid};\n \n #[derive(Debug)]\n pub enum Sign {"}, {"sha": "a127c6c3fa7ceef4b886664e4ae35da7a95951b2", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -17,15 +17,15 @@\n //! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n //! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n //! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use crate::cmp::Ordering::{Less, Equal, Greater};\n+use crate::cmp::Ordering::{Equal, Greater, Less};\n use crate::convert::{TryFrom, TryInto};\n-use crate::ops::{Add, Mul, Div, Neg};\n use crate::fmt::{Debug, LowerExp};\n-use crate::num::diy_float::Fp;\n-use crate::num::FpCategory::{Infinite, Zero, Subnormal, Normal, Nan};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::num::{self, Big};\n use crate::num::dec2flt::table;\n+use crate::num::diy_float::Fp;\n+use crate::num::FpCategory;\n+use crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\n+use crate::ops::{Add, Div, Mul, Neg};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Unpacked {\n@@ -44,13 +44,8 @@ impl Unpacked {\n /// See the parent module's doc comment for why this is necessary.\n ///\n /// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n-pub trait RawFloat\n-    : Copy\n-    + Debug\n-    + LowerExp\n-    + Mul<Output=Self>\n-    + Div<Output=Self>\n-    + Neg<Output=Self>\n+pub trait RawFloat:\n+    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n {\n     const INFINITY: Self;\n     const NAN: Self;\n@@ -144,7 +139,7 @@ macro_rules! other_constants {\n         const INFINITY: Self = $crate::$type::INFINITY;\n         const NAN: Self = $crate::$type::NAN;\n         const ZERO: Self = 0.0;\n-    }\n+    };\n }\n \n impl RawFloat for f32 {\n@@ -163,11 +158,8 @@ impl RawFloat for f32 {\n         let bits = self.to_bits();\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0x7fffff) << 1\n-        } else {\n-            (bits & 0x7fffff) | 0x800000\n-        };\n+        let mantissa =\n+            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n         // Exponent bias + mantissa shift\n         exponent -= 127 + 23;\n         (mantissa as u64, exponent, sign)\n@@ -188,12 +180,17 @@ impl RawFloat for f32 {\n         table::F32_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n-\n impl RawFloat for f64 {\n     type Bits = u64;\n \n@@ -235,9 +232,15 @@ impl RawFloat for f64 {\n         table::F64_SHORT_POWERS[e]\n     }\n \n-    fn classify(self) -> FpCategory { self.classify() }\n-    fn to_bits(self) -> Self::Bits { self.to_bits() }\n-    fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+    fn to_bits(self) -> Self::Bits {\n+        self.to_bits()\n+    }\n+    fn from_bits(v: Self::Bits) -> Self {\n+        Self::from_bits(v)\n+    }\n }\n \n /// Converts an `Fp` to the closest machine float type.\n@@ -248,7 +251,7 @@ pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let e = x.e + 63;\n     if e > T::MAX_EXP {\n         panic!(\"fp_to_float: exponent {} too large\", e)\n-    }  else if e > T::MIN_EXP {\n+    } else if e > T::MIN_EXP {\n         encode_normal(round_normal::<T>(x))\n     } else {\n         panic!(\"fp_to_float: exponent {} too small\", e)\n@@ -278,14 +281,15 @@ pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n /// Inverse of `RawFloat::unpack()` for normalized numbers.\n /// Panics if the significand or exponent are not valid for normalized numbers.\n pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n-    debug_assert!(T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n-        \"encode_normal: significand not normalized\");\n+    debug_assert!(\n+        T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n+        \"encode_normal: significand not normalized\"\n+    );\n     // Remove the hidden bit\n     let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n     // Adjust the exponent for exponent bias and mantissa shift\n     let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n-    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP,\n-        \"encode_normal: exponent out of range\");\n+    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP, \"encode_normal: exponent out of range\");\n     // Leave sign bit at 0 (\"+\"), our numbers are all positive\n     let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n     T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n@@ -315,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n         Equal | Greater => match leading.checked_add(1) {\n             Some(f) => Fp { f, e }.normalize(),\n             None => Fp { f: 1 << 63, e: e + 1 },\n-        }\n+        },\n     }\n }\n \n@@ -354,8 +358,6 @@ pub fn next_float<T: RawFloat>(x: T) -> T {\n         // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n         // too is exactly what we want!\n         // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n-        Zero | Subnormal | Normal => {\n-            T::from_bits(x.to_bits() + T::Bits::from(1u8))\n-        }\n+        Zero | Subnormal | Normal => T::from_bits(x.to_bits() + T::Bits::from(1u8)),\n     }\n }"}, {"sha": "0e601d45a2124ba8bfc569641fe7e9f5eb4102b4", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -3,9 +3,11 @@\n // This module is only for dec2flt and flt2dec, and only public because of coretests.\n // It is not intended to ever be stabilized.\n #![doc(hidden)]\n-#![unstable(feature = \"core_private_diy_float\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"core_private_diy_float\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n /// A custom 64-bit floating point type, representing `f * 2^e`.\n #[derive(Copy, Clone, Debug)]\n@@ -74,9 +76,6 @@ impl Fp {\n         assert!(edelta >= 0);\n         let edelta = edelta as usize;\n         assert_eq!(self.f << edelta >> edelta, self.f);\n-        Fp {\n-            f: self.f << edelta,\n-            e,\n-        }\n+        Fp { f: self.f << edelta, e }\n     }\n }"}, {"sha": "2b74effbe2e988e5ae7645091a1e6d95cba985e9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,8 +1,8 @@\n //! Decodes a floating-point value into individual parts and error ranges.\n \n-use crate::{f32, f64};\n-use crate::num::FpCategory;\n use crate::num::dec2flt::rawfp::RawFloat;\n+use crate::num::FpCategory;\n+use crate::{f32, f64};\n \n /// Decoded unsigned finite value, such that:\n ///\n@@ -47,11 +47,15 @@ pub trait DecodableFloat: RawFloat + Copy {\n }\n \n impl DecodableFloat for f32 {\n-    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f32::MIN_POSITIVE\n+    }\n }\n \n impl DecodableFloat for f64 {\n-    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n+    fn min_pos_norm_value() -> Self {\n+        f64::MIN_POSITIVE\n+    }\n }\n \n /// Returns a sign (true when negative) and `FullDecoded` value\n@@ -67,20 +71,29 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n             // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n             // Float::integer_decode always preserves the exponent,\n             // so the mantissa is scaled for subnormals.\n-            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1,\n-                                          exp, inclusive: even })\n+            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1, exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n             let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n             if mant == minnorm.0 {\n                 // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                 // where maxmant = minnormmant * 2 - 1\n-                FullDecoded::Finite(Decoded { mant: mant << 2, minus: 1, plus: 2,\n-                                              exp: exp - 2, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 2,\n+                    minus: 1,\n+                    plus: 2,\n+                    exp: exp - 2,\n+                    inclusive: even,\n+                })\n             } else {\n                 // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n-                FullDecoded::Finite(Decoded { mant: mant << 1, minus: 1, plus: 1,\n-                                              exp: exp - 1, inclusive: even })\n+                FullDecoded::Finite(Decoded {\n+                    mant: mant << 1,\n+                    minus: 1,\n+                    plus: 1,\n+                    exp: exp - 1,\n+                    inclusive: even,\n+                })\n             }\n         }\n     };"}, {"sha": "63df5613453238988f1720f79eaf6fec1b97ca74", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 145, "deletions": 51, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -116,15 +116,17 @@ functions.\n // while this is extensively documented, this is in principle private which is\n // only made public for testing. do not expose us.\n #![doc(hidden)]\n-#![unstable(feature = \"flt2dec\",\n-            reason = \"internal routines only exposed for testing\",\n-            issue = \"0\")]\n+#![unstable(\n+    feature = \"flt2dec\",\n+    reason = \"internal routines only exposed for testing\",\n+    issue = \"0\"\n+)]\n \n+pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n use crate::i16;\n-pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-pub mod estimator;\n pub mod decoder;\n+pub mod estimator;\n \n /// Digit-generation algorithms.\n pub mod strategy {\n@@ -144,17 +146,24 @@ pub const MAX_SIG_DIGITS: usize = 17;\n #[doc(hidden)]\n pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n     match d[..n].iter().rposition(|&c| c != b'9') {\n-        Some(i) => { // d[i+1..n] is all nines\n+        Some(i) => {\n+            // d[i+1..n] is all nines\n             d[i] += 1;\n-            for j in i+1..n { d[j] = b'0'; }\n+            for j in i + 1..n {\n+                d[j] = b'0';\n+            }\n             None\n         }\n-        None if n > 0 => { // 999..999 rounds to 1000..000 with an increased exponent\n+        None if n > 0 => {\n+            // 999..999 rounds to 1000..000 with an increased exponent\n             d[0] = b'1';\n-            for j in 1..n { d[j] = b'0'; }\n+            for j in 1..n {\n+                d[j] = b'0';\n+            }\n             Some(b'0')\n         }\n-        None => { // an empty buffer rounds up (a bit strange but reasonable)\n+        None => {\n+            // an empty buffer rounds up (a bit strange but reasonable)\n             Some(b'1')\n         }\n     }\n@@ -176,8 +185,19 @@ impl<'a> Part<'a> {\n     pub fn len(&self) -> usize {\n         match *self {\n             Part::Zero(nzeroes) => nzeroes,\n-            Part::Num(v) => if v < 1_000 { if v < 10 { 1 } else if v < 100 { 2 } else { 3 } }\n-                            else { if v < 10_000 { 4 } else { 5 } },\n+            Part::Num(v) => {\n+                if v < 1_000 {\n+                    if v < 10 {\n+                        1\n+                    } else if v < 100 {\n+                        2\n+                    } else {\n+                        3\n+                    }\n+                } else {\n+                    if v < 10_000 { 4 } else { 5 }\n+                }\n+            }\n             Part::Copy(buf) => buf.len(),\n         }\n     }\n@@ -190,7 +210,9 @@ impl<'a> Part<'a> {\n         if out.len() >= len {\n             match *self {\n                 Part::Zero(nzeroes) => {\n-                    for c in &mut out[..nzeroes] { *c = b'0'; }\n+                    for c in &mut out[..nzeroes] {\n+                        *c = b'0';\n+                    }\n                 }\n                 Part::Num(mut v) => {\n                     for c in out[..len].iter_mut().rev() {\n@@ -234,7 +256,9 @@ impl<'a> Formatted<'a> {\n     /// Returns the number of written bytes, or `None` if the buffer is not enough.\n     /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n     pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n-        if out.len() < self.sign.len() { return None; }\n+        if out.len() < self.sign.len() {\n+            return None;\n+        }\n         out[..self.sign.len()].copy_from_slice(self.sign);\n \n         let mut written = self.sign.len();\n@@ -254,8 +278,12 @@ impl<'a> Formatted<'a> {\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n /// it will only print given digits and nothing else.\n-fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_dec_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    frac_digits: usize,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 4);\n@@ -322,8 +350,13 @@ fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n /// it will be ignored and full digits will be printed. It is only used to print\n /// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n /// it will only print the given digits and nothing else.\n-fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n-                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+fn digits_to_exp_str<'a>(\n+    buf: &'a [u8],\n+    exp: i16,\n+    min_ndigits: usize,\n+    upper: bool,\n+    parts: &'a mut [Part<'a>],\n+) -> &'a [Part<'a>] {\n     assert!(!buf.is_empty());\n     assert!(buf[0] > b'0');\n     assert!(parts.len() >= 6);\n@@ -359,11 +392,11 @@ fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: boo\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Sign {\n     /// Prints `-` only for the negative non-zero values.\n-    Minus,        // -inf -1  0  0  1  inf nan\n+    Minus, // -inf -1  0  0  1  inf nan\n     /// Prints `-` only for any negative values (including the negative zero).\n-    MinusRaw,     // -inf -1 -0  0  1  inf nan\n+    MinusRaw, // -inf -1 -0  0  1  inf nan\n     /// Prints `-` for the negative non-zero values, or `+` otherwise.\n-    MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n+    MinusPlus, // -inf -1 +0 +0 +1 +inf nan\n     /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n     MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n }\n@@ -374,11 +407,35 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n     match (*decoded, sign) {\n         (FullDecoded::Nan, _) => b\"\",\n         (FullDecoded::Zero, Sign::Minus) => b\"\",\n-        (FullDecoded::Zero, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (FullDecoded::Zero, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n         (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n-        (FullDecoded::Zero, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n-        (_, Sign::Minus) | (_, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n-        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+        (FullDecoded::Zero, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n+        (_, Sign::Minus) | (_, Sign::MinusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"\"\n+            }\n+        }\n+        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => {\n+            if negative {\n+                b\"-\"\n+            } else {\n+                b\"+\"\n+            }\n+        }\n     }\n }\n \n@@ -400,10 +457,19 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                 sign: Sign, frac_digits: usize, _upper: bool,\n-                                 buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n@@ -419,7 +485,8 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -430,8 +497,7 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n-            Formatted { sign,\n-                        parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n         }\n     }\n }\n@@ -455,10 +521,19 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n-                                     sign: Sign, dec_bounds: (i16, i16), upper: bool,\n-                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+pub fn to_shortest_exp_str<'a, T, F>(\n+    mut format_shortest: F,\n+    v: T,\n+    sign: Sign,\n+    dec_bounds: (i16, i16),\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n     assert!(dec_bounds.0 <= dec_bounds.1);\n@@ -534,10 +609,19 @@ fn estimate_max_buf_len(exp: i16) -> usize {\n /// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n /// There should be at least 6 parts available, due to the worst case like\n /// `[+][1][.][2345][e][-][6]`.\n-pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n-                                  sign: Sign, ndigits: usize, upper: bool,\n-                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_exp_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    ndigits: usize,\n+    upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 6);\n     assert!(ndigits > 0);\n \n@@ -553,7 +637,8 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if ndigits > 1 { // [0.][0000][e0]\n+            if ndigits > 1 {\n+                // [0.][0000][e0]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(ndigits - 1);\n                 parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n@@ -569,8 +654,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n \n             let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n             let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n-            Formatted { sign,\n-                        parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+            Formatted { sign, parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n         }\n     }\n }\n@@ -590,10 +674,19 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n /// There should be at least 4 parts available, due to the worst case like\n /// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n-pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n-                                    sign: Sign, frac_digits: usize, _upper: bool,\n-                                    buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n-        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+pub fn to_exact_fixed_str<'a, T, F>(\n+    mut format_exact: F,\n+    v: T,\n+    sign: Sign,\n+    frac_digits: usize,\n+    _upper: bool,\n+    buf: &'a mut [u8],\n+    parts: &'a mut [Part<'a>],\n+) -> Formatted<'a>\n+where\n+    T: DecodableFloat,\n+    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n+{\n     assert!(parts.len() >= 4);\n \n     let (negative, full_decoded) = decode(v);\n@@ -608,7 +701,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n             Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n-            if frac_digits > 0 { // [0.][0000]\n+            if frac_digits > 0 {\n+                // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n                 Formatted { sign, parts: &parts[..2] }\n@@ -631,7 +725,8 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                 // `exp` was. this does not include the case that the restriction has been met\n                 // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                 debug_assert_eq!(len, 0);\n-                if frac_digits > 0 { // [0.][0000]\n+                if frac_digits > 0 {\n+                    // [0.][0000]\n                     parts[0] = Part::Copy(b\"0.\");\n                     parts[1] = Part::Zero(frac_digits);\n                     Formatted { sign, parts: &parts[..2] }\n@@ -640,8 +735,7 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                     Formatted { sign, parts: &parts[..1] }\n                 }\n             } else {\n-                Formatted { sign,\n-                            parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+                Formatted { sign, parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n             }\n         }\n     }"}, {"sha": "c8de0004352efed9e9fd24d961b4bce2ec6fee75", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -6,38 +6,54 @@\n \n use crate::cmp::Ordering;\n \n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-use crate::num::flt2dec::estimator::estimate_scaling_factor;\n-use crate::num::bignum::Digit32 as Digit;\n use crate::num::bignum::Big32x40 as Big;\n+use crate::num::bignum::Digit32 as Digit;\n+use crate::num::flt2dec::estimator::estimate_scaling_factor;\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n-static POW10: [Digit; 10] = [1, 10, 100, 1000, 10000, 100000,\n-                             1000000, 10000000, 100000000, 1000000000];\n-static TWOPOW10: [Digit; 10] = [2, 20, 200, 2000, 20000, 200000,\n-                                2000000, 20000000, 200000000, 2000000000];\n+static POW10: [Digit; 10] =\n+    [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];\n+static TWOPOW10: [Digit; 10] =\n+    [2, 20, 200, 2000, 20000, 200000, 2000000, 20000000, 200000000, 2000000000];\n \n // precalculated arrays of `Digit`s for 10^(2^n)\n static POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\n static POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\n static POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\n-static POW10TO128: [Digit; 14] =\n-    [0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08,\n-     0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x24e];\n-static POW10TO256: [Digit; 27] =\n-    [0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6,\n-     0xcf4a6e70, 0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e,\n-     0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n+static POW10TO128: [Digit; 14] = [\n+    0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08, 0xbccdb0da,\n+    0xa6337f19, 0xe91f2603, 0x24e,\n+];\n+static POW10TO256: [Digit; 27] = [\n+    0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6, 0xcf4a6e70,\n+    0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e, 0xcc5573c0, 0x65f9ef17,\n+    0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7,\n+];\n \n #[doc(hidden)]\n pub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big {\n     debug_assert!(n < 512);\n-    if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n-    if n &   8 != 0 { x.mul_small(POW10[8]); }\n-    if n &  16 != 0 { x.mul_digits(&POW10TO16); }\n-    if n &  32 != 0 { x.mul_digits(&POW10TO32); }\n-    if n &  64 != 0 { x.mul_digits(&POW10TO64); }\n-    if n & 128 != 0 { x.mul_digits(&POW10TO128); }\n-    if n & 256 != 0 { x.mul_digits(&POW10TO256); }\n+    if n & 7 != 0 {\n+        x.mul_small(POW10[n & 7]);\n+    }\n+    if n & 8 != 0 {\n+        x.mul_small(POW10[8]);\n+    }\n+    if n & 16 != 0 {\n+        x.mul_digits(&POW10TO16);\n+    }\n+    if n & 32 != 0 {\n+        x.mul_digits(&POW10TO32);\n+    }\n+    if n & 64 != 0 {\n+        x.mul_digits(&POW10TO64);\n+    }\n+    if n & 128 != 0 {\n+        x.mul_digits(&POW10TO128);\n+    }\n+    if n & 256 != 0 {\n+        x.mul_digits(&POW10TO256);\n+    }\n     x\n }\n \n@@ -52,13 +68,30 @@ fn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big {\n }\n \n // only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\n-fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,\n-                       scale2: &Big, scale4: &Big, scale8: &Big) -> (u8, &'a mut Big) {\n+fn div_rem_upto_16<'a>(\n+    x: &'a mut Big,\n+    scale: &Big,\n+    scale2: &Big,\n+    scale4: &Big,\n+    scale8: &Big,\n+) -> (u8, &'a mut Big) {\n     let mut d = 0;\n-    if *x >= *scale8 { x.sub(scale8); d += 8; }\n-    if *x >= *scale4 { x.sub(scale4); d += 4; }\n-    if *x >= *scale2 { x.sub(scale2); d += 2; }\n-    if *x >= *scale  { x.sub(scale);  d += 1; }\n+    if *x >= *scale8 {\n+        x.sub(scale8);\n+        d += 8;\n+    }\n+    if *x >= *scale4 {\n+        x.sub(scale4);\n+        d += 4;\n+    }\n+    if *x >= *scale2 {\n+        x.sub(scale2);\n+        d += 2;\n+    }\n+    if *x >= *scale {\n+        x.sub(scale);\n+        d += 1;\n+    }\n     debug_assert!(*x < *scale);\n     (d, x)\n }\n@@ -85,7 +118,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     assert!(buf.len() >= MAX_SIG_DIGITS);\n \n     // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n-    let rounding = if d.inclusive {Ordering::Greater} else {Ordering::Equal};\n+    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n \n     // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n     // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n@@ -132,9 +165,12 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     }\n \n     // cache `(2, 4, 8) * scale` for digit generation.\n-    let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-    let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-    let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+    let mut scale2 = scale.clone();\n+    scale2.mul_pow2(1);\n+    let mut scale4 = scale.clone();\n+    scale4.mul_pow2(2);\n+    let mut scale8 = scale.clone();\n+    scale8.mul_pow2(3);\n \n     let mut down;\n     let mut up;\n@@ -186,7 +222,9 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // - keep generating otherwise.\n         down = mant.cmp(&minus) < rounding;\n         up = scale.cmp(mant.clone().add(&plus)) < rounding;\n-        if down || up { break; } // we have the shortest representation, proceed to the rounding\n+        if down || up {\n+            break;\n+        } // we have the shortest representation, proceed to the rounding\n \n         // restore the invariants.\n         // this makes the algorithm always terminating: `minus` and `plus` always increases,\n@@ -269,22 +307,40 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     if len > 0 {\n         // cache `(2, 4, 8) * scale` for digit generation.\n         // (this can be expensive, so do not calculate them when the buffer is empty.)\n-        let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n-        let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n-        let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+        let mut scale2 = scale.clone();\n+        scale2.mul_pow2(1);\n+        let mut scale4 = scale.clone();\n+        scale4.mul_pow2(2);\n+        let mut scale8 = scale.clone();\n+        scale8.mul_pow2(3);\n \n         for i in 0..len {\n-            if mant.is_zero() { // following digits are all zeroes, we stop here\n+            if mant.is_zero() {\n+                // following digits are all zeroes, we stop here\n                 // do *not* try to perform rounding! rather, fill remaining digits.\n-                for c in &mut buf[i..len] { *c = b'0'; }\n+                for c in &mut buf[i..len] {\n+                    *c = b'0';\n+                }\n                 return (len, k);\n             }\n \n             let mut d = 0;\n-            if mant >= scale8 { mant.sub(&scale8); d += 8; }\n-            if mant >= scale4 { mant.sub(&scale4); d += 4; }\n-            if mant >= scale2 { mant.sub(&scale2); d += 2; }\n-            if mant >= scale  { mant.sub(&scale);  d += 1; }\n+            if mant >= scale8 {\n+                mant.sub(&scale8);\n+                d += 8;\n+            }\n+            if mant >= scale4 {\n+                mant.sub(&scale4);\n+                d += 4;\n+            }\n+            if mant >= scale2 {\n+                mant.sub(&scale2);\n+                d += 2;\n+            }\n+            if mant >= scale {\n+                mant.sub(&scale);\n+                d += 1;\n+            }\n             debug_assert!(mant < scale);\n             debug_assert!(d < 10);\n             buf[i] = b'0' + d;\n@@ -296,8 +352,9 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n     // if the following digits are exactly 5000..., check the prior digit and try to\n     // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n-    if order == Ordering::Greater || (order == Ordering::Equal &&\n-                                      (len == 0 || buf[len-1] & 1 == 1)) {\n+    if order == Ordering::Greater\n+        || (order == Ordering::Equal && (len == 0 || buf[len - 1] & 1 == 1))\n+    {\n         // if rounding up changes the length, the exponent should also change.\n         // but we've been requested a fixed number of digits, so do not alter the buffer...\n         if let Some(c) = round_up(buf, len) {"}, {"sha": "1e2db212dd0de03a22acc82b504caa37d410d0da", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 169, "deletions": 123, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -6,12 +6,13 @@\n //!   accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n \n use crate::num::diy_float::Fp;\n-use crate::num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n-\n+use crate::num::flt2dec::{round_up, Decoded, MAX_SIG_DIGITS};\n \n // see the comments in `format_shortest_opt` for the rationale.\n-#[doc(hidden)] pub const ALPHA: i16 = -60;\n-#[doc(hidden)] pub const GAMMA: i16 = -32;\n+#[doc(hidden)]\n+pub const ALPHA: i16 = -60;\n+#[doc(hidden)]\n+pub const GAMMA: i16 = -32;\n \n /*\n # the following Python code generates this table:\n@@ -24,92 +25,95 @@ for i in xrange(-308, 333, 8):\n */\n \n #[doc(hidden)]\n-pub static CACHED_POW10: [(u64, i16, i16); 81] = [ // (f, e, k)\n+pub static CACHED_POW10: [(u64, i16, i16); 81] = [\n+    // (f, e, k)\n     (0xe61acf033d1a45df, -1087, -308),\n     (0xab70fe17c79ac6ca, -1060, -300),\n     (0xff77b1fcbebcdc4f, -1034, -292),\n     (0xbe5691ef416bd60c, -1007, -284),\n-    (0x8dd01fad907ffc3c,  -980, -276),\n-    (0xd3515c2831559a83,  -954, -268),\n-    (0x9d71ac8fada6c9b5,  -927, -260),\n-    (0xea9c227723ee8bcb,  -901, -252),\n-    (0xaecc49914078536d,  -874, -244),\n-    (0x823c12795db6ce57,  -847, -236),\n-    (0xc21094364dfb5637,  -821, -228),\n-    (0x9096ea6f3848984f,  -794, -220),\n-    (0xd77485cb25823ac7,  -768, -212),\n-    (0xa086cfcd97bf97f4,  -741, -204),\n-    (0xef340a98172aace5,  -715, -196),\n-    (0xb23867fb2a35b28e,  -688, -188),\n-    (0x84c8d4dfd2c63f3b,  -661, -180),\n-    (0xc5dd44271ad3cdba,  -635, -172),\n-    (0x936b9fcebb25c996,  -608, -164),\n-    (0xdbac6c247d62a584,  -582, -156),\n-    (0xa3ab66580d5fdaf6,  -555, -148),\n-    (0xf3e2f893dec3f126,  -529, -140),\n-    (0xb5b5ada8aaff80b8,  -502, -132),\n-    (0x87625f056c7c4a8b,  -475, -124),\n-    (0xc9bcff6034c13053,  -449, -116),\n-    (0x964e858c91ba2655,  -422, -108),\n-    (0xdff9772470297ebd,  -396, -100),\n-    (0xa6dfbd9fb8e5b88f,  -369,  -92),\n-    (0xf8a95fcf88747d94,  -343,  -84),\n-    (0xb94470938fa89bcf,  -316,  -76),\n-    (0x8a08f0f8bf0f156b,  -289,  -68),\n-    (0xcdb02555653131b6,  -263,  -60),\n-    (0x993fe2c6d07b7fac,  -236,  -52),\n-    (0xe45c10c42a2b3b06,  -210,  -44),\n-    (0xaa242499697392d3,  -183,  -36),\n-    (0xfd87b5f28300ca0e,  -157,  -28),\n-    (0xbce5086492111aeb,  -130,  -20),\n-    (0x8cbccc096f5088cc,  -103,  -12),\n-    (0xd1b71758e219652c,   -77,   -4),\n-    (0x9c40000000000000,   -50,    4),\n-    (0xe8d4a51000000000,   -24,   12),\n-    (0xad78ebc5ac620000,     3,   20),\n-    (0x813f3978f8940984,    30,   28),\n-    (0xc097ce7bc90715b3,    56,   36),\n-    (0x8f7e32ce7bea5c70,    83,   44),\n-    (0xd5d238a4abe98068,   109,   52),\n-    (0x9f4f2726179a2245,   136,   60),\n-    (0xed63a231d4c4fb27,   162,   68),\n-    (0xb0de65388cc8ada8,   189,   76),\n-    (0x83c7088e1aab65db,   216,   84),\n-    (0xc45d1df942711d9a,   242,   92),\n-    (0x924d692ca61be758,   269,  100),\n-    (0xda01ee641a708dea,   295,  108),\n-    (0xa26da3999aef774a,   322,  116),\n-    (0xf209787bb47d6b85,   348,  124),\n-    (0xb454e4a179dd1877,   375,  132),\n-    (0x865b86925b9bc5c2,   402,  140),\n-    (0xc83553c5c8965d3d,   428,  148),\n-    (0x952ab45cfa97a0b3,   455,  156),\n-    (0xde469fbd99a05fe3,   481,  164),\n-    (0xa59bc234db398c25,   508,  172),\n-    (0xf6c69a72a3989f5c,   534,  180),\n-    (0xb7dcbf5354e9bece,   561,  188),\n-    (0x88fcf317f22241e2,   588,  196),\n-    (0xcc20ce9bd35c78a5,   614,  204),\n-    (0x98165af37b2153df,   641,  212),\n-    (0xe2a0b5dc971f303a,   667,  220),\n-    (0xa8d9d1535ce3b396,   694,  228),\n-    (0xfb9b7cd9a4a7443c,   720,  236),\n-    (0xbb764c4ca7a44410,   747,  244),\n-    (0x8bab8eefb6409c1a,   774,  252),\n-    (0xd01fef10a657842c,   800,  260),\n-    (0x9b10a4e5e9913129,   827,  268),\n-    (0xe7109bfba19c0c9d,   853,  276),\n-    (0xac2820d9623bf429,   880,  284),\n-    (0x80444b5e7aa7cf85,   907,  292),\n-    (0xbf21e44003acdd2d,   933,  300),\n-    (0x8e679c2f5e44ff8f,   960,  308),\n-    (0xd433179d9c8cb841,   986,  316),\n-    (0x9e19db92b4e31ba9,  1013,  324),\n-    (0xeb96bf6ebadf77d9,  1039,  332),\n+    (0x8dd01fad907ffc3c, -980, -276),\n+    (0xd3515c2831559a83, -954, -268),\n+    (0x9d71ac8fada6c9b5, -927, -260),\n+    (0xea9c227723ee8bcb, -901, -252),\n+    (0xaecc49914078536d, -874, -244),\n+    (0x823c12795db6ce57, -847, -236),\n+    (0xc21094364dfb5637, -821, -228),\n+    (0x9096ea6f3848984f, -794, -220),\n+    (0xd77485cb25823ac7, -768, -212),\n+    (0xa086cfcd97bf97f4, -741, -204),\n+    (0xef340a98172aace5, -715, -196),\n+    (0xb23867fb2a35b28e, -688, -188),\n+    (0x84c8d4dfd2c63f3b, -661, -180),\n+    (0xc5dd44271ad3cdba, -635, -172),\n+    (0x936b9fcebb25c996, -608, -164),\n+    (0xdbac6c247d62a584, -582, -156),\n+    (0xa3ab66580d5fdaf6, -555, -148),\n+    (0xf3e2f893dec3f126, -529, -140),\n+    (0xb5b5ada8aaff80b8, -502, -132),\n+    (0x87625f056c7c4a8b, -475, -124),\n+    (0xc9bcff6034c13053, -449, -116),\n+    (0x964e858c91ba2655, -422, -108),\n+    (0xdff9772470297ebd, -396, -100),\n+    (0xa6dfbd9fb8e5b88f, -369, -92),\n+    (0xf8a95fcf88747d94, -343, -84),\n+    (0xb94470938fa89bcf, -316, -76),\n+    (0x8a08f0f8bf0f156b, -289, -68),\n+    (0xcdb02555653131b6, -263, -60),\n+    (0x993fe2c6d07b7fac, -236, -52),\n+    (0xe45c10c42a2b3b06, -210, -44),\n+    (0xaa242499697392d3, -183, -36),\n+    (0xfd87b5f28300ca0e, -157, -28),\n+    (0xbce5086492111aeb, -130, -20),\n+    (0x8cbccc096f5088cc, -103, -12),\n+    (0xd1b71758e219652c, -77, -4),\n+    (0x9c40000000000000, -50, 4),\n+    (0xe8d4a51000000000, -24, 12),\n+    (0xad78ebc5ac620000, 3, 20),\n+    (0x813f3978f8940984, 30, 28),\n+    (0xc097ce7bc90715b3, 56, 36),\n+    (0x8f7e32ce7bea5c70, 83, 44),\n+    (0xd5d238a4abe98068, 109, 52),\n+    (0x9f4f2726179a2245, 136, 60),\n+    (0xed63a231d4c4fb27, 162, 68),\n+    (0xb0de65388cc8ada8, 189, 76),\n+    (0x83c7088e1aab65db, 216, 84),\n+    (0xc45d1df942711d9a, 242, 92),\n+    (0x924d692ca61be758, 269, 100),\n+    (0xda01ee641a708dea, 295, 108),\n+    (0xa26da3999aef774a, 322, 116),\n+    (0xf209787bb47d6b85, 348, 124),\n+    (0xb454e4a179dd1877, 375, 132),\n+    (0x865b86925b9bc5c2, 402, 140),\n+    (0xc83553c5c8965d3d, 428, 148),\n+    (0x952ab45cfa97a0b3, 455, 156),\n+    (0xde469fbd99a05fe3, 481, 164),\n+    (0xa59bc234db398c25, 508, 172),\n+    (0xf6c69a72a3989f5c, 534, 180),\n+    (0xb7dcbf5354e9bece, 561, 188),\n+    (0x88fcf317f22241e2, 588, 196),\n+    (0xcc20ce9bd35c78a5, 614, 204),\n+    (0x98165af37b2153df, 641, 212),\n+    (0xe2a0b5dc971f303a, 667, 220),\n+    (0xa8d9d1535ce3b396, 694, 228),\n+    (0xfb9b7cd9a4a7443c, 720, 236),\n+    (0xbb764c4ca7a44410, 747, 244),\n+    (0x8bab8eefb6409c1a, 774, 252),\n+    (0xd01fef10a657842c, 800, 260),\n+    (0x9b10a4e5e9913129, 827, 268),\n+    (0xe7109bfba19c0c9d, 853, 276),\n+    (0xac2820d9623bf429, 880, 284),\n+    (0x80444b5e7aa7cf85, 907, 292),\n+    (0xbf21e44003acdd2d, 933, 300),\n+    (0x8e679c2f5e44ff8f, 960, 308),\n+    (0xd433179d9c8cb841, 986, 316),\n+    (0x9e19db92b4e31ba9, 1013, 324),\n+    (0xeb96bf6ebadf77d9, 1039, 332),\n ];\n \n-#[doc(hidden)] pub const CACHED_POW10_FIRST_E: i16 = -1087;\n-#[doc(hidden)] pub const CACHED_POW10_LAST_E: i16 = 1039;\n+#[doc(hidden)]\n+pub const CACHED_POW10_FIRST_E: i16 = -1087;\n+#[doc(hidden)]\n+pub const CACHED_POW10_LAST_E: i16 = 1039;\n \n #[doc(hidden)]\n pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n@@ -128,30 +132,39 @@ pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n     debug_assert!(x > 0);\n \n     const X9: u32 = 10_0000_0000;\n-    const X8: u32 =  1_0000_0000;\n-    const X7: u32 =    1000_0000;\n-    const X6: u32 =     100_0000;\n-    const X5: u32 =      10_0000;\n-    const X4: u32 =       1_0000;\n-    const X3: u32 =         1000;\n-    const X2: u32 =          100;\n-    const X1: u32 =           10;\n+    const X8: u32 = 1_0000_0000;\n+    const X7: u32 = 1000_0000;\n+    const X6: u32 = 100_0000;\n+    const X5: u32 = 10_0000;\n+    const X4: u32 = 1_0000;\n+    const X3: u32 = 1000;\n+    const X2: u32 = 100;\n+    const X1: u32 = 10;\n \n     if x < X4 {\n-        if x < X2 { if x < X1 {(0,  1)} else {(1, X1)} }\n-        else      { if x < X3 {(2, X2)} else {(3, X3)} }\n+        if x < X2 {\n+            if x < X1 { (0, 1) } else { (1, X1) }\n+        } else {\n+            if x < X3 { (2, X2) } else { (3, X3) }\n+        }\n     } else {\n-        if x < X6      { if x < X5 {(4, X4)} else {(5, X5)} }\n-        else if x < X8 { if x < X7 {(6, X6)} else {(7, X7)} }\n-        else           { if x < X9 {(8, X8)} else {(9, X9)} }\n+        if x < X6 {\n+            if x < X5 { (4, X4) } else { (5, X5) }\n+        } else if x < X8 {\n+            if x < X7 { (6, X6) } else { (7, X7) }\n+        } else {\n+            if x < X9 { (8, X8) } else { (9, X9) }\n+        }\n     }\n }\n \n /// The shortest mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_shortest_opt(d: &Decoded,\n-                           buf: &mut [u8]) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_shortest_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n     assert!(d.plus > 0);\n@@ -208,8 +221,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     // we start with the correct repr within the unsafe region, and try to find the closest repr\n     // to `v` which is also within the safe region. if we can't, we give up.\n     let plus1 = plus.f + 1;\n-//  let plus0 = plus.f - 1; // only for explanation\n-//  let minus0 = minus.f + 1; // only for explanation\n+    //  let plus0 = plus.f - 1; // only for explanation\n+    //  let minus0 = minus.f + 1; // only for explanation\n     let minus1 = minus.f - 1;\n     let e = -plus.e as usize; // shared exponent\n \n@@ -235,14 +248,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n     // the algorithm relies on the later verification phase to exclude `y`.\n     let delta1 = plus1 - minus1;\n-//  let delta1int = (delta1 >> e) as usize; // only for explanation\n+    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n     let delta1frac = delta1 & ((1 << e) - 1);\n \n     // render integral parts, while checking for the accuracy at each step.\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = plus1int; // digits yet to be rendered\n-    loop { // we always have at least one digit to render, as `plus1 >= 10^kappa`\n+    loop {\n+        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n         // invariants:\n         // - `delta1int <= remainder < 10^(kappa+1)`\n         // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -281,7 +295,8 @@ pub fn format_shortest_opt(d: &Decoded,\n     let mut remainder = plus1frac;\n     let mut threshold = delta1frac;\n     let mut ulp = 1;\n-    loop { // the next digit should be significant as we've tested that before breaking out\n+    loop {\n+        // the next digit should be significant as we've tested that before breaking out\n         // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n         // - `remainder < 2^e`\n         // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n@@ -300,8 +315,15 @@ pub fn format_shortest_opt(d: &Decoded,\n \n         if r < threshold {\n             let ten_kappa = 1 << e; // implicit divisor\n-            return round_and_weed(&mut buf[..i], exp, r, threshold,\n-                                  (plus1 - v.f) * ulp, ten_kappa, ulp);\n+            return round_and_weed(\n+                &mut buf[..i],\n+                exp,\n+                r,\n+                threshold,\n+                (plus1 - v.f) * ulp,\n+                ten_kappa,\n+                ulp,\n+            );\n         }\n \n         // restore invariants\n@@ -325,8 +347,15 @@ pub fn format_shortest_opt(d: &Decoded,\n     // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,\n-                      ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn round_and_weed(\n+        buf: &mut [u8],\n+        exp: i16,\n+        remainder: u64,\n+        threshold: u64,\n+        plus1v: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         assert!(!buf.is_empty());\n \n         // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n@@ -381,10 +410,11 @@ pub fn format_shortest_opt(d: &Decoded,\n             //\n             // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n             // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n-            while plus1w < plus1v_up &&\n-                  threshold - plus1w >= ten_kappa &&\n-                  (plus1w + ten_kappa < plus1v_up ||\n-                   plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up) {\n+            while plus1w < plus1v_up\n+                && threshold - plus1w >= ten_kappa\n+                && (plus1w + ten_kappa < plus1v_up\n+                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n+            {\n                 *last -= 1;\n                 debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                 plus1w += ten_kappa;\n@@ -395,10 +425,11 @@ pub fn format_shortest_opt(d: &Decoded,\n         //\n         // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n         // replaced by `plus1v_down` instead. overflow analysis equally holds.\n-        if plus1w < plus1v_down &&\n-           threshold - plus1w >= ten_kappa &&\n-           (plus1w + ten_kappa < plus1v_down ||\n-            plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down) {\n+        if plus1w < plus1v_down\n+            && threshold - plus1w >= ten_kappa\n+            && (plus1w + ten_kappa < plus1v_down\n+                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n+        {\n             return None;\n         }\n \n@@ -428,8 +459,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n /// The exact and fixed mode implementation for Grisu.\n ///\n /// It returns `None` when it would return an inexact representation otherwise.\n-pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n-                                -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+pub fn format_exact_opt(\n+    d: &Decoded,\n+    buf: &mut [u8],\n+    limit: i16,\n+) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n     assert!(d.mant > 0);\n     assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n     assert!(!buf.is_empty());\n@@ -489,7 +523,8 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     let mut kappa = max_kappa as i16;\n     let mut ten_kappa = max_ten_kappa; // 10^kappa\n     let mut remainder = vint; // digits yet to be rendered\n-    loop { // we always have at least one digit to render\n+    loop {\n+        // we always have at least one digit to render\n         // invariants:\n         // - `remainder < 10^(kappa+1)`\n         // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n@@ -575,8 +610,15 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n     // - `remainder = (v % 10^kappa) * k`\n     // - `ten_kappa = 10^kappa * k`\n     // - `ulp = 2^-e * k`\n-    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,\n-                      remainder: u64, ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+    fn possibly_round(\n+        buf: &mut [u8],\n+        mut len: usize,\n+        mut exp: i16,\n+        limit: i16,\n+        remainder: u64,\n+        ten_kappa: u64,\n+        ulp: u64,\n+    ) -> Option<(usize, i16)> {\n         debug_assert!(remainder < ten_kappa);\n \n         //           10^kappa\n@@ -593,7 +635,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         //\n         // error is too large that there are at least three possible representations\n         // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n-        if ulp >= ten_kappa { return None; }\n+        if ulp >= ten_kappa {\n+            return None;\n+        }\n \n         //    10^kappa\n         //   :<------->:\n@@ -607,7 +651,9 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n         // in fact, 1/2 ulp is enough to introduce two possible representations.\n         // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n         // this won't overflow, as `ulp < ten_kappa` from the first check.\n-        if ten_kappa - ulp <= ulp { return None; }\n+        if ten_kappa - ulp <= ulp {\n+            return None;\n+        }\n \n         //     remainder\n         //       :<->|                           :"}, {"sha": "0ddfbd02aa5b02250b453f8d5e31dc10da69130a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -4,7 +4,7 @@ use crate::ops::*;\n \n #[allow(unused_macros)]\n macro_rules! sh_impl_signed {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -19,7 +19,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -44,7 +44,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -54,11 +54,11 @@ macro_rules! sh_impl_signed {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n macro_rules! sh_impl_unsigned {\n-    ($t:ident, $f:ident) => (\n+    ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n@@ -69,7 +69,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -90,7 +90,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n-                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n+        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -100,7 +100,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n         forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n-    )\n+    };\n }\n \n // FIXME (#23545): uncomment the remaining impls"}, {"sha": "59a72799e256726e20dbf7728f4c94298269d7d9", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -66,19 +66,13 @@\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    on(\n-        all(_Self=\"{integer}\", Rhs=\"{float}\"),\n-        message=\"cannot add a float to an integer\",\n-    ),\n-    on(\n-        all(_Self=\"{float}\", Rhs=\"{integer}\"),\n-        message=\"cannot add an integer to a float\",\n-    ),\n-    message=\"cannot add `{Rhs}` to `{Self}`\",\n-    label=\"no implementation for `{Self} + {Rhs}`\",\n+    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n+    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n+    message = \"cannot add `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} + {Rhs}`\"\n )]\n #[doc(alias = \"+\")]\n-pub trait Add<Rhs=Self> {\n+pub trait Add<Rhs = Self> {\n     /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -173,10 +167,12 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} - {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} - {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n-pub trait Sub<Rhs=Self> {\n+pub trait Sub<Rhs = Self> {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -293,10 +289,12 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} * {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} * {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n-pub trait Mul<Rhs=Self> {\n+pub trait Mul<Rhs = Self> {\n     /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -417,10 +415,12 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} / {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} / {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n-pub trait Div<Rhs=Self> {\n+pub trait Div<Rhs = Self> {\n     /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -502,10 +502,12 @@ div_impl_float! { f32 f64 }\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} % {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} % {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n-pub trait Rem<Rhs=Self> {\n+pub trait Rem<Rhs = Self> {\n     /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -534,7 +536,6 @@ macro_rules! rem_impl_integer {\n \n rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n-\n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n \n@@ -616,8 +617,6 @@ pub trait Neg {\n     fn neg(self) -> Self::Output;\n }\n \n-\n-\n macro_rules! neg_impl_core {\n     ($id:ident => $body:expr, $($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -679,11 +678,13 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"add_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot add-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} += {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} += {Rhs}`\"\n+)]\n #[doc(alias = \"+\")]\n #[doc(alias = \"+=\")]\n-pub trait AddAssign<Rhs=Self> {\n+pub trait AddAssign<Rhs = Self> {\n     /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n@@ -735,11 +736,13 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot subtract-assign `{Rhs}` from `{Self}`\",\n-                         label=\"no implementation for `{Self} -= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n+    label = \"no implementation for `{Self} -= {Rhs}`\"\n+)]\n #[doc(alias = \"-\")]\n #[doc(alias = \"-=\")]\n-pub trait SubAssign<Rhs=Self> {\n+pub trait SubAssign<Rhs = Self> {\n     /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n@@ -782,11 +785,13 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot multiply-assign `{Rhs}` to `{Self}`\",\n-                         label=\"no implementation for `{Self} *= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n+    label = \"no implementation for `{Self} *= {Rhs}`\"\n+)]\n #[doc(alias = \"*\")]\n #[doc(alias = \"*=\")]\n-pub trait MulAssign<Rhs=Self> {\n+pub trait MulAssign<Rhs = Self> {\n     /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n@@ -829,11 +834,13 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot divide-assign `{Self}` by `{Rhs}`\",\n-                         label=\"no implementation for `{Self} /= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n+    label = \"no implementation for `{Self} /= {Rhs}`\"\n+)]\n #[doc(alias = \"/\")]\n #[doc(alias = \"/=\")]\n-pub trait DivAssign<Rhs=Self> {\n+pub trait DivAssign<Rhs = Self> {\n     /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n@@ -879,11 +886,13 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot mod-assign `{Self}` by `{Rhs}``\",\n-                         label=\"no implementation for `{Self} %= {Rhs}`\")]\n+#[rustc_on_unimplemented(\n+    message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n+    label = \"no implementation for `{Self} %= {Rhs}`\"\n+)]\n #[doc(alias = \"%\")]\n #[doc(alias = \"%=\")]\n-pub trait RemAssign<Rhs=Self> {\n+pub trait RemAssign<Rhs = Self> {\n     /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);"}, {"sha": "bcfff4a223bec7b63fad2b0f3d96c00dae05c9bc", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -112,9 +112,11 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitand\"]\n #[doc(alias = \"&\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} & {Rhs}`\",\n-                         label=\"no implementation for `{Self} & {Rhs}`\")]\n-pub trait BitAnd<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} & {Rhs}`\",\n+    label = \"no implementation for `{Self} & {Rhs}`\"\n+)]\n+pub trait BitAnd<Rhs = Self> {\n     /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -196,9 +198,11 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor\"]\n #[doc(alias = \"|\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} | {Rhs}`\",\n-                         label=\"no implementation for `{Self} | {Rhs}`\")]\n-pub trait BitOr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} | {Rhs}`\",\n+    label = \"no implementation for `{Self} | {Rhs}`\"\n+)]\n+pub trait BitOr<Rhs = Self> {\n     /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -283,9 +287,11 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor\"]\n #[doc(alias = \"^\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^ {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^ {Rhs}`\")]\n-pub trait BitXor<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^ {Rhs}`\",\n+    label = \"no implementation for `{Self} ^ {Rhs}`\"\n+)]\n+pub trait BitXor<Rhs = Self> {\n     /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -371,9 +377,11 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl\"]\n #[doc(alias = \"<<\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} << {Rhs}`\",\n-                         label=\"no implementation for `{Self} << {Rhs}`\")]\n-pub trait Shl<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} << {Rhs}`\",\n+    label = \"no implementation for `{Self} << {Rhs}`\"\n+)]\n+pub trait Shl<Rhs = Self> {\n     /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -385,7 +393,7 @@ pub trait Shl<Rhs=Self> {\n }\n \n macro_rules! shl_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shl<$f> for $t {\n             type Output = $t;\n@@ -398,7 +406,7 @@ macro_rules! shl_impl {\n         }\n \n         forward_ref_binop! { impl Shl, shl for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_impl_all {\n@@ -480,9 +488,11 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n #[lang = \"shr\"]\n #[doc(alias = \">>\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >> {Rhs}`\",\n-                         label=\"no implementation for `{Self} >> {Rhs}`\")]\n-pub trait Shr<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >> {Rhs}`\",\n+    label = \"no implementation for `{Self} >> {Rhs}`\"\n+)]\n+pub trait Shr<Rhs = Self> {\n     /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n@@ -494,7 +504,7 @@ pub trait Shr<Rhs=Self> {\n }\n \n macro_rules! shr_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for $t {\n             type Output = $t;\n@@ -507,7 +517,7 @@ macro_rules! shr_impl {\n         }\n \n         forward_ref_binop! { impl Shr, shr for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_impl_all {\n@@ -596,9 +606,11 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"bitand_assign\"]\n #[doc(alias = \"&=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} &= {Rhs}`\",\n-                         label=\"no implementation for `{Self} &= {Rhs}`\")]\n-pub trait BitAndAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} &= {Rhs}`\",\n+    label = \"no implementation for `{Self} &= {Rhs}`\"\n+)]\n+pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n@@ -645,9 +657,11 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitor_assign\"]\n #[doc(alias = \"|=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} |= {Rhs}`\",\n-                         label=\"no implementation for `{Self} |= {Rhs}`\")]\n-pub trait BitOrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} |= {Rhs}`\",\n+    label = \"no implementation for `{Self} |= {Rhs}`\"\n+)]\n+pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n@@ -694,9 +708,11 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"bitxor_assign\"]\n #[doc(alias = \"^=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} ^= {Rhs}`\",\n-                         label=\"no implementation for `{Self} ^= {Rhs}`\")]\n-pub trait BitXorAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} ^= {Rhs}`\",\n+    label = \"no implementation for `{Self} ^= {Rhs}`\"\n+)]\n+pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n@@ -741,16 +757,18 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n #[lang = \"shl_assign\"]\n #[doc(alias = \"<<=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} <<= {Rhs}`\",\n-                         label=\"no implementation for `{Self} <<= {Rhs}`\")]\n-pub trait ShlAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} <<= {Rhs}`\",\n+    label = \"no implementation for `{Self} <<= {Rhs}`\"\n+)]\n+pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shl_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for $t {\n             #[inline]\n@@ -761,7 +779,7 @@ macro_rules! shl_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shl_assign_impl_all {\n@@ -809,16 +827,18 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n #[lang = \"shr_assign\"]\n #[doc(alias = \">>=\")]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"no implementation for `{Self} >>= {Rhs}`\",\n-                         label=\"no implementation for `{Self} >>= {Rhs}`\")]\n-pub trait ShrAssign<Rhs=Self> {\n+#[rustc_on_unimplemented(\n+    message = \"no implementation for `{Self} >>= {Rhs}`\",\n+    label = \"no implementation for `{Self} >>= {Rhs}`\"\n+)]\n+pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }\n \n macro_rules! shr_assign_impl {\n-    ($t:ty, $f:ty) => (\n+    ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for $t {\n             #[inline]\n@@ -829,7 +849,7 @@ macro_rules! shr_assign_impl {\n         }\n \n         forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n-    )\n+    };\n }\n \n macro_rules! shr_assign_impl_all {"}, {"sha": "f521355a90722a07ae2c57d1eae8f29dab72e480", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -76,14 +76,18 @@ pub trait Deref {\n impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for &mut T {\n     type Target = T;\n \n-    fn deref(&self) -> &T { *self }\n+    fn deref(&self) -> &T {\n+        *self\n+    }\n }\n \n /// Used for mutable dereferencing operations, like in `*v = 1;`.\n@@ -165,7 +169,9 @@ pub trait DerefMut: Deref {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> DerefMut for &mut T {\n-    fn deref_mut(&mut self) -> &mut T { *self }\n+    fn deref_mut(&mut self) -> &mut T {\n+        *self\n+    }\n }\n \n /// Indicates that a struct can be used as a method receiver, without the"}, {"sha": "505a65cee3de0265f5f0047395b656805e4ee33a", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -57,13 +57,16 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait Fn<Args> : FnMut<Args> {\n+pub trait Fn<Args>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -136,13 +139,16 @@ pub trait Fn<Args> : FnMut<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-pub trait FnMut<Args> : FnOnce<Args> {\n+pub trait FnMut<Args>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -207,9 +213,12 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n-    on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n-    message=\"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n-    label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n+    ),\n+    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n@@ -225,26 +234,29 @@ pub trait FnOnce<Args> {\n \n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> Fn<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> Fn<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnMut<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &F\n-        where F : Fn<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &F\n+    where\n+        F: Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -254,17 +266,19 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnMut<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnMut<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A,F:?Sized> FnOnce<A> for &mut F\n-        where F : FnMut<A>\n+    impl<A, F: ?Sized> FnOnce<A> for &mut F\n+    where\n+        F: FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "aae0691122415ce4d3d766b294a026314da048db", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -51,8 +51,8 @@\n /// ```\n #[lang = \"index\"]\n #[rustc_on_unimplemented(\n-    message=\"the type `{Self}` cannot be indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"]\")]\n@@ -142,22 +142,22 @@ pub trait Index<Idx: ?Sized> {\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented(\n     on(\n-        _Self=\"&str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"&str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"str\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n     on(\n-        _Self=\"std::string::String\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+        _Self = \"std::string::String\",\n+        note = \"you can use `.chars().nth()` or `.bytes().nth()`\n see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n     ),\n-    message=\"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n-    label=\"`{Self}` cannot be mutably indexed by `{Idx}`\",\n+    message = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n+    label = \"`{Self}` cannot be mutably indexed by `{Idx}`\"\n )]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"[\")]"}, {"sha": "80ab906961ee79b5f344bdbb221d98831e9f5fad", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -156,12 +156,12 @@ mod r#try;\n mod unsize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+pub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+pub use self::arith::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+pub use self::bit::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n@@ -184,7 +184,7 @@ pub use self::index::{Index, IndexMut};\n pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-pub use self::range::{RangeInclusive, RangeToInclusive, RangeBounds, Bound};\n+pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::r#try::Try;"}, {"sha": "a2250337a4dcab131b63c2c3590e2d535f0490c4", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -399,11 +399,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[inline]\n     #[rustc_promotable]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self {\n-            start,\n-            end,\n-            is_empty: None,\n-        }\n+        Self { start, end, is_empty: None }\n     }\n \n     /// Returns the lower bound of the range (inclusive)."}, {"sha": "80fb5642a6a76d87228ab661fb03659858ca879a", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -39,35 +39,34 @@ pub trait CoerceUnsized<T: ?Sized> {\n \n // &mut T -> &mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n // &mut T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n // &mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n // &mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n // &T -> &U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n // &T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n // *mut T -> *mut U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n // *mut T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n-\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n /// This is used for object safety, to check that a method's receiver type can be dispatched on.\n ///\n@@ -90,13 +89,13 @@ pub trait DispatchFromDyn<T> {\n \n // &T -> &U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n // &mut T -> &mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n // *const T -> *const U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}"}, {"sha": "2066a484dac8091a3a294227c15093dca5e4d403", "filename": "src/libcore/option.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -138,8 +138,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::iter::{FromIterator, FusedIterator, TrustedLen};\n-use crate::{convert, fmt, hint, mem, ops::{self, Deref, DerefMut}};\n use crate::pin::Pin;\n+use crate::{\n+    convert, fmt, hint, mem,\n+    ops::{self, Deref, DerefMut},\n+};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -230,7 +233,10 @@ impl<T> Option<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool where U: PartialEq<T> {\n+    pub fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: PartialEq<T>,\n+    {\n         match self {\n             Some(y) => x == y,\n             None => false,\n@@ -291,16 +297,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-\n     /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n     ///\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n-        unsafe {\n-            Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n@@ -309,9 +312,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n-        unsafe {\n-            Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n-        }\n+        unsafe { Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x)) }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -690,7 +691,7 @@ impl<T> Option<T> {\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n         if let Some(x) = self {\n             if predicate(&x) {\n-                return Some(x)\n+                return Some(x);\n             }\n         }\n         None\n@@ -1228,7 +1229,9 @@ impl<T> Default for Option<T> {\n     /// assert!(opt.is_none());\n     /// ```\n     #[inline]\n-    fn default() -> Option<T> { None }\n+    fn default() -> Option<T> {\n+        None\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1302,7 +1305,7 @@ impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n \n #[derive(Clone, Debug)]\n struct Item<A> {\n-    opt: Option<A>\n+    opt: Option<A>,\n }\n \n impl<A> Iterator for Item<A> {\n@@ -1344,22 +1347,30 @@ unsafe impl<A> TrustedLen for Item<A> {}\n /// [`Option::iter`]: enum.Option.html#method.iter\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n+pub struct Iter<'a, A: 'a> {\n+    inner: Item<&'a A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for Iter<'a, A> {\n     type Item = &'a A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1390,22 +1401,30 @@ impl<A> Clone for Iter<'_, A> {\n /// [`Option::iter_mut`]: enum.Option.html#method.iter_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n-pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n+pub struct IterMut<'a, A: 'a> {\n+    inner: Item<&'a mut A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> Iterator for IterMut<'a, A> {\n     type Item = &'a mut A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a mut A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a mut A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1427,22 +1446,30 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<A> { inner: Item<A> }\n+pub struct IntoIter<A> {\n+    inner: Item<A>,\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.inner.next() }\n+    fn next(&mut self) -> Option<A> {\n+        self.inner.next()\n+    }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<A> {\n+        self.inner.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1523,14 +1550,11 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     ///\n     /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: IntoIterator<Item = Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n-        iter.into_iter()\n-            .map(|x| x.ok_or(()))\n-            .collect::<Result<_, _>>()\n-            .ok()\n+        iter.into_iter().map(|x| x.ok_or(())).collect::<Result<_, _>>().ok()\n     }\n }\n "}, {"sha": "88fa718ae9e62c37cb5ff890cf62c23c0fbb98ec", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -374,10 +374,10 @@\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n \n+use crate::cmp::{self, PartialEq, PartialOrd};\n use crate::fmt;\n use crate::marker::{Sized, Unpin};\n-use crate::cmp::{self, PartialEq, PartialOrd};\n-use crate::ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n+use crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n \n /// A pinned pointer.\n ///\n@@ -646,7 +646,8 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n+    where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -698,7 +699,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn get_mut(self) -> &'a mut T\n-        where T: Unpin,\n+    where\n+        T: Unpin,\n     {\n         self.pointer\n     }\n@@ -735,7 +737,8 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n+    where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);\n@@ -789,13 +792,7 @@ impl<P: fmt::Pointer> fmt::Pointer for Pin<P> {\n // for other reasons, though, so we just need to take care not to allow such\n // impls to land in std.\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> CoerceUnsized<Pin<U>> for Pin<P>\n-where\n-    P: CoerceUnsized<U>,\n-{}\n+impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n-where\n-    P: DispatchFromDyn<U>,\n-{}\n+impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}"}, {"sha": "66b5a90b77b919f6f6a1c894e3f185e2a64a5de2", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -25,25 +25,25 @@ pub use crate::mem::drop;\n pub use crate::clone::Clone;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n+pub use crate::cmp::{Eq, Ord, PartialEq, PartialOrd};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::convert::{AsRef, AsMut, Into, From};\n+pub use crate::convert::{AsMut, AsRef, From, Into};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use crate::default::Default;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{Iterator, Extend, IntoIterator};\n+pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n+pub use crate::iter::{Extend, IntoIterator, Iterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::option::Option::{self, Some, None};\n+pub use crate::option::Option::{self, None, Some};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n-pub use crate::result::Result::{self, Ok, Err};\n+pub use crate::result::Result::{self, Err, Ok};\n \n // Re-exported built-in macros\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n@@ -56,37 +56,14 @@ pub use crate::hash::macros::Hash;\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[doc(no_inline)]\n pub use crate::{\n-    asm,\n-    assert,\n-    cfg,\n-    column,\n-    compile_error,\n-    concat,\n-    concat_idents,\n-    env,\n-    file,\n-    format_args,\n-    format_args_nl,\n-    global_asm,\n-    include,\n-    include_bytes,\n-    include_str,\n-    line,\n-    log_syntax,\n-    module_path,\n-    option_env,\n-    stringify,\n-    trace_macros,\n+    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n+    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n+    option_env, stringify, trace_macros,\n };\n \n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow(deprecated)]\n #[doc(no_inline)]\n pub use crate::macros::builtin::{\n-    RustcDecodable,\n-    RustcEncodable,\n-    bench,\n-    global_allocator,\n-    test,\n-    test_case,\n+    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n };"}, {"sha": "a121389bef3c9e5ad0bdfc56d963601fa7cc9b44", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,11 +1,11 @@\n+use crate::cmp::Ordering;\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::hash;\n use crate::marker::Unsize;\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n-use crate::cmp::Ordering;\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -48,12 +48,12 @@ pub struct NonNull<T: ?Sized> {\n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Send for NonNull<T> { }\n+impl<T: ?Sized> !Send for NonNull<T> {}\n \n /// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n // N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> !Sync for NonNull<T> { }\n+impl<T: ?Sized> !Sync for NonNull<T> {}\n \n impl<T: Sized> NonNull<T> {\n     /// Creates a new `NonNull` that is dangling, but well-aligned.\n@@ -91,11 +91,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n-        if !ptr.is_null() {\n-            Some(unsafe { Self::new_unchecked(ptr) })\n-        } else {\n-            None\n-        }\n+        if !ptr.is_null() { Some(unsafe { Self::new_unchecked(ptr) }) } else { None }\n     }\n \n     /// Acquires the underlying `*mut` pointer.\n@@ -131,9 +127,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -146,13 +140,13 @@ impl<T: ?Sized> Clone for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-impl<T: ?Sized> Copy for NonNull<T> { }\n+impl<T: ?Sized> Copy for NonNull<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> fmt::Debug for NonNull<T> {"}, {"sha": "546b7c9d777f59c39c99cc67a10d062192656afb", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,8 +1,8 @@\n use crate::convert::From;\n-use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::fmt;\n use crate::marker::{PhantomData, Unsize};\n use crate::mem;\n+use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::NonNull;\n \n // ignore-tidy-undocumented-unsafe\n@@ -27,9 +27,12 @@ use crate::ptr::NonNull;\n ///\n /// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n /// for any type which upholds Unique's aliasing requirements.\n-#[unstable(feature = \"ptr_internals\", issue = \"0\",\n-           reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n-                     (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\")]\n+#[unstable(\n+    feature = \"ptr_internals\",\n+    issue = \"0\",\n+    reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n+              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\"\n+)]\n #[doc(hidden)]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -48,14 +51,14 @@ pub struct Unique<T: ?Sized> {\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n+unsafe impl<T: Send + ?Sized> Send for Unique<T> {}\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n+unsafe impl<T: Sync + ?Sized> Sync for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: Sized> Unique<T> {\n@@ -71,9 +74,7 @@ impl<T: Sized> Unique<T> {\n     // FIXME: rename to dangling() to match NonNull?\n     #[inline]\n     pub const fn empty() -> Self {\n-        unsafe {\n-            Unique::new_unchecked(mem::align_of::<T>() as *mut T)\n-        }\n+        unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n     }\n }\n \n@@ -128,9 +129,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Casts to a pointer of another type.\n     #[inline]\n     pub const fn cast<U>(self) -> Unique<U> {\n-        unsafe {\n-            Unique::new_unchecked(self.as_ptr() as *mut U)\n-        }\n+        unsafe { Unique::new_unchecked(self.as_ptr() as *mut U) }\n     }\n }\n \n@@ -143,13 +142,13 @@ impl<T: ?Sized> Clone for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized> Copy for Unique<T> { }\n+impl<T: ?Sized> Copy for Unique<T> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n-impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Debug for Unique<T> {"}, {"sha": "019832e16f89cd20d25f6c508c55d5bfa081e72f", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -20,13 +20,16 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+        unsafe {\n+            ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+        }\n     }\n }\n \n /// Shifts the first element to the right until it encounters a greater or equal element.\n fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -36,10 +39,7 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(1),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(1) };\n             ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n             for i in 2..len {\n@@ -58,7 +58,8 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n \n /// Shifts the last element to the left until it encounters a smaller or equal element.\n fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     unsafe {\n@@ -68,13 +69,10 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n             let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n-            let mut hole = CopyOnDrop {\n-                src: &mut *tmp,\n-                dest: v.get_unchecked_mut(len - 2),\n-            };\n+            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.get_unchecked_mut(len - 2) };\n             ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n \n-            for i in (0..len-2).rev() {\n+            for i in (0..len - 2).rev() {\n                 if !is_less(&*tmp, v.get_unchecked(i)) {\n                     break;\n                 }\n@@ -93,7 +91,8 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n /// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n #[cold]\n fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Maximum number of adjacent out-of-order pairs that will get shifted.\n     const MAX_STEPS: usize = 5;\n@@ -136,17 +135,19 @@ fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n \n /// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\n fn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     for i in 1..v.len() {\n-        shift_tail(&mut v[..i+1], is_less);\n+        shift_tail(&mut v[..i + 1], is_less);\n     }\n }\n \n /// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n #[cold]\n pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // This binary heap respects the invariant `parent >= child`.\n     let mut sift_down = |v: &mut [T], mut node| {\n@@ -156,11 +157,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n             let right = 2 * node + 2;\n \n             // Choose the greater child.\n-            let greater = if right < v.len() && is_less(&v[left], &v[right]) {\n-                right\n-            } else {\n-                left\n-            };\n+            let greater =\n+                if right < v.len() && is_less(&v[left], &v[right]) { right } else { left };\n \n             // Stop if the invariant holds at `node`.\n             if greater >= v.len() || !is_less(&v[node], &v[greater]) {\n@@ -174,12 +172,12 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n     };\n \n     // Build the heap in linear time.\n-    for i in (0 .. v.len() / 2).rev() {\n+    for i in (0..v.len() / 2).rev() {\n         sift_down(v, i);\n     }\n \n     // Pop maximal elements from the heap.\n-    for i in (1 .. v.len()).rev() {\n+    for i in (1..v.len()).rev() {\n         v.swap(0, i);\n         sift_down(&mut v[..i], 0);\n     }\n@@ -195,7 +193,8 @@ pub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\n ///\n /// [pdf]: http://drops.dagstuhl.de/opus/volltexte/2016/6389/pdf/LIPIcs-ESA-2016-38.pdf\n fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Number of elements in a typical block.\n     const BLOCK: usize = 128;\n@@ -298,8 +297,16 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n         let count = cmp::min(width(start_l, end_l), width(start_r, end_r));\n \n         if count > 0 {\n-            macro_rules! left { () => { l.offset(*start_l as isize) } }\n-            macro_rules! right { () => { r.offset(-(*start_r as isize) - 1) } }\n+            macro_rules! left {\n+                () => {\n+                    l.offset(*start_l as isize)\n+                };\n+            }\n+            macro_rules! right {\n+                () => {\n+                    r.offset(-(*start_r as isize) - 1)\n+                };\n+            }\n \n             // Instead of swapping one pair at the time, it is more efficient to perform a cyclic\n             // permutation. This is not strictly equivalent to swapping, but produces a similar\n@@ -379,7 +386,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n /// 1. Number of elements smaller than `v[pivot]`.\n /// 2. True if `v` was already partitioned.\n fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let (mid, was_partitioned) = {\n         // Place the pivot at the beginning of slice.\n@@ -390,10 +398,7 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n         // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n         // operation panics, the pivot will be automatically written back into the slice.\n         let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop {\n-            src: &mut *tmp,\n-            dest: pivot,\n-        };\n+        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -429,7 +434,8 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n /// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n /// elements smaller than the pivot.\n fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Place the pivot at the beginning of slice.\n     v.swap(0, pivot);\n@@ -439,10 +445,7 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n     let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop {\n-        src: &mut *tmp,\n-        dest: pivot,\n-    };\n+    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice.\n@@ -528,7 +531,8 @@ fn break_patterns<T>(v: &mut [T]) {\n ///\n /// Elements in `v` might be reordered in the process.\n fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Minimum length to choose the median-of-medians method.\n     // Shorter slices use the simple median-of-three method.\n@@ -596,7 +600,8 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n /// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n /// this function will immediately switch to heapsort.\n fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -650,7 +655,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n                 let mid = partition_equal(v, pivot, is_less);\n \n                 // Continue sorting elements greater than the pivot.\n-                v = &mut {v}[mid..];\n+                v = &mut { v }[mid..];\n                 continue;\n             }\n         }\n@@ -661,7 +666,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n         was_partitioned = was_p;\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -681,7 +686,8 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n \n /// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\n pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Sorting has no meaningful behavior on zero-sized types.\n     if mem::size_of::<T>() == 0 {\n@@ -694,8 +700,13 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n     recurse(v, &mut is_less, None, limit);\n }\n \n-fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_less: &mut F\n-                                    , mut pred: Option<&'a T>) where F: FnMut(&T, &T) -> bool\n+fn partition_at_index_loop<'a, T, F>(\n+    mut v: &'a mut [T],\n+    mut index: usize,\n+    is_less: &mut F,\n+    mut pred: Option<&'a T>,\n+) where\n+    F: FnMut(&T, &T) -> bool,\n {\n     loop {\n         // For slices of up to this length it's probably faster to simply sort them.\n@@ -731,7 +742,7 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n         let (mid, _) = partition(v, pivot, is_less);\n \n         // Split the slice into `left`, `pivot`, and `right`.\n-        let (left, right) = {v}.split_at_mut(mid);\n+        let (left, right) = { v }.split_at_mut(mid);\n         let (pivot, right) = right.split_at_mut(1);\n         let pivot = &pivot[0];\n \n@@ -749,11 +760,16 @@ fn partition_at_index_loop<'a, T, F>( mut v: &'a mut [T], mut index: usize, is_l\n     }\n }\n \n-pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n-                                -> (&mut [T], &mut T, &mut [T]) where F: FnMut(&T, &T) -> bool\n+pub fn partition_at_index<T, F>(\n+    v: &mut [T],\n+    index: usize,\n+    mut is_less: F,\n+) -> (&mut [T], &mut T, &mut [T])\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n-    use cmp::Ordering::Less;\n     use cmp::Ordering::Greater;\n+    use cmp::Ordering::Less;\n \n     if index >= v.len() {\n         panic!(\"partition_at_index index {} greater than length of slice {}\", index, v.len());\n@@ -764,14 +780,20 @@ pub fn partition_at_index<T, F>(v: &mut [T], index: usize, mut is_less: F)\n     } else if index == v.len() - 1 {\n         // Find max element and place it in the last position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (max_index, _) = v.iter().enumerate().max_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (max_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .max_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(max_index, index);\n     } else if index == 0 {\n         // Find min element and place it in the first position of the array. We're free to use\n         // `unwrap()` here because we know v must not be empty.\n-        let (min_index, _) = v.iter().enumerate().min_by(\n-            |&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater }).unwrap();\n+        let (min_index, _) = v\n+            .iter()\n+            .enumerate()\n+            .min_by(|&(_, x), &(_, y)| if is_less(x, y) { Less } else { Greater })\n+            .unwrap();\n         v.swap(min_index, index);\n     } else {\n         partition_at_index_loop(v, index, &mut is_less, None);"}, {"sha": "27760749c1d4b63ddca3afbf14d25da6d2c5ef3e", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -8,4 +8,4 @@ pub use self::poll::Poll;\n \n mod wake;\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub use self::wake::{Context, Waker, RawWaker, RawWakerVTable};\n+pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};"}, {"sha": "d567ae545774ef56726de81f2a55c2ac3bb3be96", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -11,10 +11,7 @@ use crate::result::Result;\n pub enum Poll<T> {\n     /// Represents that a value is immediately ready.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-    Ready(\n-        #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-        T\n-    ),\n+    Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n \n     /// Represents that a value is not ready yet.\n     ///\n@@ -29,7 +26,8 @@ impl<T> Poll<T> {\n     /// Changes the ready value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(t) => Poll::Ready(f(t)),\n@@ -59,7 +57,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(f(t))),\n@@ -71,7 +70,8 @@ impl<T, E> Poll<Result<T, E>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Ok(t)) => Poll::Ready(Ok(t)),\n@@ -85,7 +85,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the success value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n-        where F: FnOnce(T) -> U\n+    where\n+        F: FnOnce(T) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(f(t)))),\n@@ -98,7 +99,8 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n     /// Changes the error value of this `Poll` with the closure provided.\n     #[unstable(feature = \"poll_map\", issue = \"63514\")]\n     pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n-        where F: FnOnce(E) -> U\n+    where\n+        F: FnOnce(E) -> U,\n     {\n         match self {\n             Poll::Ready(Some(Ok(t))) => Poll::Ready(Some(Ok(t))),"}, {"sha": "0759ff93ea85f0da49acb9f346068da1b0622a83", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -40,10 +40,7 @@ impl RawWaker {\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n-        RawWaker {\n-            data,\n-            vtable,\n-        }\n+        RawWaker { data, vtable }\n     }\n }\n \n@@ -160,12 +157,7 @@ impl RawWakerVTable {\n         wake_by_ref: unsafe fn(*const ()),\n         drop: unsafe fn(*const ()),\n     ) -> Self {\n-        Self {\n-            clone,\n-            wake,\n-            wake_by_ref,\n-            drop,\n-        }\n+        Self { clone, wake, wake_by_ref, drop }\n     }\n }\n \n@@ -188,10 +180,7 @@ impl<'a> Context<'a> {\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[inline]\n     pub fn from_waker(waker: &'a Waker) -> Self {\n-        Context {\n-            waker,\n-            _marker: PhantomData,\n-        }\n+        Context { waker, _marker: PhantomData }\n     }\n \n     /// Returns a reference to the `Waker` for the current task.\n@@ -205,9 +194,7 @@ impl<'a> Context<'a> {\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl fmt::Debug for Context<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Context\")\n-            .field(\"waker\", &self.waker)\n-            .finish()\n+        f.debug_struct(\"Context\").field(\"waker\", &self.waker).finish()\n     }\n }\n \n@@ -291,9 +278,7 @@ impl Waker {\n     #[inline]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n-        Waker {\n-            waker,\n-        }\n+        Waker { waker }\n     }\n }\n "}, {"sha": "70ec1e42fd71b6981d27c8c02e2e0ee4fd198f07", "filename": "src/libcore/time.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -12,9 +12,9 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n-use crate::{fmt, u64};\n use crate::iter::Sum;\n-use crate::ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n+use crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+use crate::{fmt, u64};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -131,8 +131,8 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn new(secs: u64, nanos: u32) -> Duration {\n-        let secs = secs.checked_add((nanos / NANOS_PER_SEC) as u64)\n-            .expect(\"overflow in Duration::new\");\n+        let secs =\n+            secs.checked_add((nanos / NANOS_PER_SEC) as u64).expect(\"overflow in Duration::new\");\n         let nanos = nanos % NANOS_PER_SEC;\n         Duration { secs, nanos }\n     }\n@@ -252,7 +252,9 @@ impl Duration {\n     /// [`subsec_nanos`]: #method.subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn as_secs(&self) -> u64 { self.secs }\n+    pub const fn as_secs(&self) -> u64 {\n+        self.secs\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole milliseconds.\n     ///\n@@ -271,7 +273,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_millis(&self) -> u32 { self.nanos / NANOS_PER_MILLI }\n+    pub const fn subsec_millis(&self) -> u32 {\n+        self.nanos / NANOS_PER_MILLI\n+    }\n \n     /// Returns the fractional part of this `Duration`, in whole microseconds.\n     ///\n@@ -290,7 +294,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n     #[inline]\n-    pub const fn subsec_micros(&self) -> u32 { self.nanos / NANOS_PER_MICRO }\n+    pub const fn subsec_micros(&self) -> u32 {\n+        self.nanos / NANOS_PER_MICRO\n+    }\n \n     /// Returns the fractional part of this `Duration`, in nanoseconds.\n     ///\n@@ -309,7 +315,9 @@ impl Duration {\n     /// ```\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n-    pub const fn subsec_nanos(&self) -> u32 { self.nanos }\n+    pub const fn subsec_nanos(&self) -> u32 {\n+        self.nanos\n+    }\n \n     /// Returns the total number of whole milliseconds contained by this `Duration`.\n     ///\n@@ -388,10 +396,7 @@ impl Duration {\n                 }\n             }\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -455,14 +460,11 @@ impl Duration {\n         let total_nanos = self.nanos as u64 * rhs as u64;\n         let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n         let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n-        if let Some(secs) = self.secs\n-            .checked_mul(rhs as u64)\n-            .and_then(|s| s.checked_add(extra_secs)) {\n+        if let Some(secs) =\n+            self.secs.checked_mul(rhs as u64).and_then(|s| s.checked_add(extra_secs))\n+        {\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration {\n-                secs,\n-                nanos,\n-            })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -549,9 +551,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f64(secs: f64) -> Duration {\n-        const MAX_NANOS_F64: f64 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n-        let nanos =  secs * (NANOS_PER_SEC as f64);\n+        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n+        let nanos = secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -561,7 +562,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -584,9 +585,8 @@ impl Duration {\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[inline]\n     pub fn from_secs_f32(secs: f32) -> Duration {\n-        const MAX_NANOS_F32: f32 =\n-            ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f32;\n-        let nanos =  secs * (NANOS_PER_SEC as f32);\n+        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n+        let nanos = secs * (NANOS_PER_SEC as f32);\n         if !nanos.is_finite() {\n             panic!(\"got non-finite value when converting float to duration\");\n         }\n@@ -596,7 +596,7 @@ impl Duration {\n         if nanos < 0.0 {\n             panic!(\"underflow when converting float to duration\");\n         }\n-        let nanos =  nanos as u128;\n+        let nanos = nanos as u128;\n         Duration {\n             secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n             nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n@@ -799,9 +799,8 @@ macro_rules! sum_durations {\n         let mut total_nanos: u64 = 0;\n \n         for entry in $iter {\n-            total_secs = total_secs\n-                .checked_add(entry.secs)\n-                .expect(\"overflow in iter::sum over durations\");\n+            total_secs =\n+                total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n             total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n                 Some(n) => n,\n                 None => {\n@@ -816,23 +815,20 @@ macro_rules! sum_durations {\n             .checked_add(total_nanos / NANOS_PER_SEC as u64)\n             .expect(\"overflow in iter::sum over durations\");\n         total_nanos = total_nanos % NANOS_PER_SEC as u64;\n-        Duration {\n-            secs: total_secs,\n-            nanos: total_nanos as u32,\n-        }\n+        Duration { secs: total_secs, nanos: total_nanos as u32 }\n     }};\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl Sum for Duration {\n-    fn sum<I: Iterator<Item=Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n \n #[stable(feature = \"duration_sum\", since = \"1.16.0\")]\n impl<'a> Sum<&'a Duration> for Duration {\n-    fn sum<I: Iterator<Item=&'a Duration>>(iter: I) -> Duration {\n+    fn sum<I: Iterator<Item = &'a Duration>>(iter: I) -> Duration {\n         sum_durations!(iter)\n     }\n }\n@@ -922,9 +918,7 @@ impl fmt::Debug for Duration {\n             } else {\n                 // SAFETY: We are only writing ASCII digits into the buffer and it was\n                 // initialized with '0's, so it contains valid UTF8.\n-                let s = unsafe {\n-                    crate::str::from_utf8_unchecked(&buf[..end])\n-                };\n+                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n \n                 // If the user request a precision > 9, we pad '0's at the end.\n                 let w = f.precision().unwrap_or(pos);"}, {"sha": "9f8a3a1de420116d50f89d515f9930d8120ac44c", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -1,7 +1,7 @@\n // See src/libstd/primitive_docs.rs for documentation.\n \n-use crate::cmp::*;\n use crate::cmp::Ordering::*;\n+use crate::cmp::*;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {"}, {"sha": "b7fba88a540f9012dbc01efd9b5758d86e30709d", "filename": "src/libcore/unicode/bool_trie.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -19,16 +19,16 @@\n /// non-BMP range of most Unicode sets.\n pub struct BoolTrie {\n     // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    pub r1: [u64; 32],   // leaves\n+    pub r1: [u64; 32], // leaves\n \n     // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n     pub r2: [u8; 992],      // first level\n-    pub r3: &'static [u64],  // leaves\n+    pub r3: &'static [u64], // leaves\n \n     // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    pub r4: [u8; 256],       // first level\n-    pub r5: &'static [u8],   // second level\n-    pub r6: &'static [u64],  // leaves\n+    pub r4: [u8; 256],      // first level\n+    pub r5: &'static [u8],  // second level\n+    pub r6: &'static [u64], // leaves\n }\n impl BoolTrie {\n     pub fn lookup(&self, c: char) -> bool {\n@@ -48,7 +48,7 @@ impl BoolTrie {\n \n pub struct SmallBoolTrie {\n     pub(crate) r1: &'static [u8],  // first level\n-    pub(crate) r2: &'static [u64],  // leaves\n+    pub(crate) r2: &'static [u64], // leaves\n }\n \n impl SmallBoolTrie {"}, {"sha": "f41f4a5e94a76ee5b585b9575636cfa4b7e66aab", "filename": "src/libcore/unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e00bfed801e264e9c4ac817004153ca0f19eb6/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=95e00bfed801e264e9c4ac817004153ca0f19eb6", "patch": "@@ -15,7 +15,7 @@ use crate::iter::FromIterator;\n /// ```\n #[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\n impl FromIterator<()> for () {\n-    fn from_iter<I: IntoIterator<Item=()>>(iter: I) -> Self {\n+    fn from_iter<I: IntoIterator<Item = ()>>(iter: I) -> Self {\n         iter.into_iter().for_each(|()| {})\n     }\n }"}]}