{"sha": "b418cd23068b1074e78d8631aec923b865bcc583", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MThjZDIzMDY4YjEwNzRlNzhkODYzMWFlYzkyM2I4NjViY2M1ODM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-10T19:01:38Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-24T21:41:09Z"}, "message": "Cleanup\n\n+ Fix a comment and add a test based on it", "tree": {"sha": "fd2974f890f0ba840aefb3551f62a9454ba9cb67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd2974f890f0ba840aefb3551f62a9454ba9cb67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b418cd23068b1074e78d8631aec923b865bcc583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b418cd23068b1074e78d8631aec923b865bcc583", "html_url": "https://github.com/rust-lang/rust/commit/b418cd23068b1074e78d8631aec923b865bcc583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b418cd23068b1074e78d8631aec923b865bcc583/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77f033bac17d2767e9605f3f44d43500662c4ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f033bac17d2767e9605f3f44d43500662c4ec7", "html_url": "https://github.com/rust-lang/rust/commit/77f033bac17d2767e9605f3f44d43500662c4ec7"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "231bf666deafc50e701b34d49b70fefd1dfc82c5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b418cd23068b1074e78d8631aec923b865bcc583/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b418cd23068b1074e78d8631aec923b865bcc583/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b418cd23068b1074e78d8631aec923b865bcc583", "patch": "@@ -2616,27 +2616,37 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let last_ident = segments.last().unwrap().identifier;\n+        // Resolve a single identifier with fallback to primitive types\n+        let resolve_identifier_with_fallback = |this: &mut Self, record_used| {\n+            let def = this.resolve_identifier(last_ident, namespace, record_used);\n+            match def {\n+                None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n+                    this.primitive_type_table\n+                        .primitive_types\n+                        .get(&last_ident.unhygienic_name)\n+                        .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n+                _ => def\n+            }\n+        };\n+\n         if segments.len() == 1 {\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n             // So, we are still able to successfully resolve something like\n             //\n             // use std::u8; // bring module u8 in scope\n             // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n-            //     u8::MAX // OK, resolves to associated constant <u8>::MAX,\n-            //             // not to non-existent std::u8::MAX\n+            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+            //                     // not to non-existent std::u8::max_value\n             // }\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let unqualified_def = self.resolve_identifier_with_fallback(last_ident, namespace, true);\n-            return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n-                                  .map(|def| {\n-                                      PathResolution::new(def, path_depth)\n-                                  });\n+            let unqualified_def = resolve_identifier_with_fallback(self, true);\n+            return unqualified_def.and_then(|def| self.adjust_local_def(def, span)).map(mk_res);\n         }\n \n-        let unqualified_def = self.resolve_identifier_with_fallback(last_ident, namespace, false);\n+        let unqualified_def = resolve_identifier_with_fallback(self, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n             (Some(d), Some(ref ud)) if d == ud.def => {\n@@ -2652,28 +2662,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         def.map(mk_res)\n     }\n \n-    // Resolve a single identifier with fallback to primitive types\n-    fn resolve_identifier_with_fallback(&mut self,\n-                          identifier: hir::Ident,\n-                          namespace: Namespace,\n-                          check_ribs: bool,\n-                          record_used: bool)\n-                          -> Option<LocalDef> {\n-        let def = self.resolve_identifier(identifier, namespace, check_ribs, record_used);\n-        match def {\n-            None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS => {\n-                if let Some(&prim_ty) = self.primitive_type_table\n-                                            .primitive_types\n-                                            .get(&identifier.unhygienic_name) {\n-                    Some(LocalDef::from_def(Def::PrimTy(prim_ty)))\n-                } else {\n-                    def\n-                }\n-            }\n-            _ => def\n-        }\n-    }\n-\n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n                           identifier: hir::Ident,"}, {"sha": "dd3d952224c057edcb1070ba5ca5f0c96bde6867", "filename": "src/test/run-pass/issue-20427.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b418cd23068b1074e78d8631aec923b865bcc583/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b418cd23068b1074e78d8631aec923b865bcc583/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20427.rs?ref=b418cd23068b1074e78d8631aec923b865bcc583", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // aux-build:i8.rs\n+// ignore-pretty (#23623)\n+\n extern crate i8;\n use std::string as i16;\n static i32: i32 = 0;\n@@ -66,6 +68,17 @@ mod reuse {\n     }\n }\n \n+mod guard {\n+    pub fn check() {\n+        use std::u8; // bring module u8 in scope\n+        fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+                            // not to non-existent std::u8::max_value\n+        }\n+        assert_eq!(f(), u8::MAX); // OK, resolves to std::u8::MAX\n+    }\n+}\n+\n fn main() {\n     let bool = true;\n     let _ = match bool {\n@@ -74,4 +87,5 @@ fn main() {\n     };\n \n     reuse::check::<u64>();\n+    guard::check();\n }"}]}