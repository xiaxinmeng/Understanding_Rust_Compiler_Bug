{"sha": "f31767df66b9468cea81a3aceb34633fad213d67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTc2N2RmNjZiOTQ2OGNlYTgxYTNhY2ViMzQ2MzNmYWQyMTNkNjc=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-14T08:32:34Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-06-14T19:37:54Z"}, "message": "Implement terminfo param conditionals\n\nImplement the %?, %t, %e, and %; operators. Also implement the %<, %=,\n%> operators, without which conditionals aren't very useful.\n\nFix the order of parameters for the arithmetic operators.\n\nImplement the missing %^ operator.", "tree": {"sha": "23f3103fe2c6bff7d8377d1d3ee216f1f1539b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f3103fe2c6bff7d8377d1d3ee216f1f1539b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f31767df66b9468cea81a3aceb34633fad213d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f31767df66b9468cea81a3aceb34633fad213d67", "html_url": "https://github.com/rust-lang/rust/commit/f31767df66b9468cea81a3aceb34633fad213d67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f31767df66b9468cea81a3aceb34633fad213d67/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6423548818e7dd6940a95889641fbd327749ebd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6423548818e7dd6940a95889641fbd327749ebd4", "html_url": "https://github.com/rust-lang/rust/commit/6423548818e7dd6940a95889641fbd327749ebd4"}], "stats": {"total": 147, "additions": 129, "deletions": 18}, "files": [{"sha": "59d34c7317b853afeb9886fc31a4ba5a1a800fd8", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 129, "deletions": 18, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f31767df66b9468cea81a3aceb34633fad213d67/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f31767df66b9468cea81a3aceb34633fad213d67/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=f31767df66b9468cea81a3aceb34633fad213d67", "patch": "@@ -24,8 +24,10 @@ enum States {\n     CharConstant,\n     CharClose,\n     IntConstant,\n-    IfCond,\n-    IfBody\n+    SeekIfElse(int),\n+    SeekIfElsePercent(int),\n+    SeekIfEnd(int),\n+    SeekIfEndPercent(int)\n }\n \n /// Types of parameters a capability can use\n@@ -126,44 +128,68 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     } else { return Err(~\"stack is empty\") },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x + y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with +\")\n+                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                            _ => return Err(~\"non-numbers on stack with +\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x - y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with -\")\n+                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                            _ => return Err(~\"non-numbers on stack with -\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x * y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with *\")\n+                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                            _ => return Err(~\"non-numbers on stack with *\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x / y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with /\")\n+                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                            _ => return Err(~\"non-numbers on stack with /\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x % y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with %\")\n+                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                            _ => return Err(~\"non-numbers on stack with %\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x & y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with &\")\n+                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                            _ => return Err(~\"non-numbers on stack with &\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop(), stack.pop()) {\n-                            (Number(x), Number(y)) => stack.push(Number(x | y)),\n-                            (_, _) => return Err(~\"non-numbers on stack with |\")\n+                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                            _ => return Err(~\"non-numbers on stack with |\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '^' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                            _ => return Err(~\"non-numbers on stack with ^\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '=' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 } else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with =\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '>' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 } else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with >\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    '<' => if stack.len() > 1 {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 } else { 0 })),\n+                            _ => return Err(~\"non-numbers on stack with <\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'A' => if stack.len() > 1 {\n@@ -201,7 +227,19 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         },\n                         (_, _) => return Err(~\"first two params not numbers with %i\")\n                     },\n-                    '?' => state = return Err(fmt!(\"if expressions unimplemented (%?)\", cap)),\n+\n+                    // conditionals\n+                    '?' => (),\n+                    't' => if stack.len() > 0 {\n+                        match stack.pop() {\n+                            Number(0) => state = SeekIfElse(0),\n+                            Number(_) => (),\n+                            _         => return Err(~\"non-number on stack with conditional\")\n+                        }\n+                    } else { return Err(~\"stack is empty\") },\n+                    'e' => state = SeekIfEnd(0),\n+                    ';' => (),\n+\n                     _ => return Err(fmt!(\"unrecognized format option %c\", cur))\n                 }\n             },\n@@ -260,7 +298,46 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     old_state = Nothing;\n                 }\n             }\n-            _ => return Err(~\"unimplemented state\")\n+            SeekIfElse(level) => {\n+                if cur == '%' {\n+                    state = SeekIfElsePercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfElsePercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfElse(level-1);\n+                    }\n+                } else if cur == 'e' && level == 0 {\n+                    state = Nothing;\n+                } else if cur == '?' {\n+                    state = SeekIfElse(level+1);\n+                } else {\n+                    state = SeekIfElse(level);\n+                }\n+            }\n+            SeekIfEnd(level) => {\n+                if cur == '%' {\n+                    state = SeekIfEndPercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfEndPercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfEnd(level-1);\n+                    }\n+                } else if cur == '?' {\n+                    state = SeekIfEnd(level+1);\n+                } else {\n+                    state = SeekIfEnd(level);\n+                }\n+            }\n         }\n         if state == old_state {\n             state = Nothing;\n@@ -316,4 +393,38 @@ mod test {\n     fn test_push_bad_param() {\n         assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n     }\n+\n+    #[test]\n+    fn test_comparison_ops() {\n+        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+        for v.iter().advance |&(op, bs)| {\n+            let s = fmt!(\"%%{1}%%{2}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[0]]);\n+            let s = fmt!(\"%%{1}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[1]]);\n+            let s = fmt!(\"%%{2}%%{1}%%%c%%d\", op);\n+            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), ~['0' as u8 + bs[2]]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conditionals() {\n+        let mut vars = Variables::new();\n+        let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n+        let res = expand(s, [Number(1)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[31m\").to_owned());\n+        let res = expand(s, [Number(8)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[90m\").to_owned());\n+        let res = expand(s, [Number(42)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), bytes!(\"\\\\E[38;5;42m\").to_owned());\n+    }\n }"}]}