{"sha": "9df78ec4a4e41ca94b25f292aba90e266f104f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZjc4ZWM0YTRlNDFjYTk0YjI1ZjI5MmFiYTkwZTI2NmYxMDRmMDI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-29T19:23:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-30T12:03:32Z"}, "message": "Properly resolve intra doc links in hover and goto_definition", "tree": {"sha": "0b670a721b9fd5de261de18b871f20552e23f0fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b670a721b9fd5de261de18b871f20552e23f0fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9df78ec4a4e41ca94b25f292aba90e266f104f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9df78ec4a4e41ca94b25f292aba90e266f104f02", "html_url": "https://github.com/rust-lang/rust/commit/9df78ec4a4e41ca94b25f292aba90e266f104f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9df78ec4a4e41ca94b25f292aba90e266f104f02/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30", "html_url": "https://github.com/rust-lang/rust/commit/0b68e03bf56c00f63fcc65e7879cc64c6d5c4f30"}], "stats": {"total": 142, "additions": 103, "deletions": 39}, "files": [{"sha": "69442278b2ff863cd7dacc1c3ee993d2f0683ed6", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=9df78ec4a4e41ca94b25f292aba90e266f104f02", "patch": "@@ -26,12 +26,7 @@ pub(crate) type DocumentationLink = String;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n-    let mut cb = |link: BrokenLink| {\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n+    let mut cb = broken_link_clone_cb;\n     let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n \n     let doc = map_links(doc, |target, title: &str| {\n@@ -124,45 +119,49 @@ pub(crate) fn external_docs(\n pub(crate) fn extract_definitions_from_markdown(\n     markdown: &str,\n ) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n-    let mut res = vec![];\n-    let mut cb = |link: BrokenLink| {\n-        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n-        // this is fixed in the repo but not on the crates.io release yet\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n-    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n-    for (event, range) in doc.into_offset_iter() {\n-        if let Event::Start(Tag::Link(_, target, title)) = event {\n-            let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_intra_doc_link(&link);\n-            res.push((range, link.to_string(), ns));\n-        }\n-    }\n-    res\n+    extract_definitions_from_markdown_(markdown, &mut broken_link_clone_cb).collect()\n+}\n+\n+fn extract_definitions_from_markdown_<'a>(\n+    markdown: &'a str,\n+    cb: &'a mut dyn FnMut(BrokenLink<'_>) -> Option<(CowStr<'a>, CowStr<'a>)>,\n+) -> impl Iterator<Item = (Range<usize>, String, Option<hir::Namespace>)> + 'a {\n+    Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(cb))\n+        .into_offset_iter()\n+        .filter_map(|(event, range)| {\n+            if let Event::Start(Tag::Link(_, target, title)) = event {\n+                let link = if target.is_empty() { title } else { target };\n+                let (link, ns) = parse_intra_doc_link(&link);\n+                Some((range, link.to_string(), ns))\n+            } else {\n+                None\n+            }\n+        })\n }\n \n /// Extracts a link from a comment at the given position returning the spanning range, link and\n /// optionally it's namespace.\n pub(crate) fn extract_positioned_link_from_comment(\n     position: TextSize,\n     comment: &ast::Comment,\n+    docs: hir::Documentation,\n ) -> Option<(TextRange, String, Option<hir::Namespace>)> {\n-    let doc_comment = comment.doc_comment()?;\n+    let doc_comment = comment.doc_comment()?.to_string() + \"\\n\" + docs.as_str();\n     let comment_start =\n         comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n-    let def_links = extract_definitions_from_markdown(doc_comment);\n-    let (range, def_link, ns) =\n-        def_links.into_iter().find_map(|(Range { start, end }, def_link, ns)| {\n+    let len = comment.syntax().text_range().len().into();\n+    let mut cb = broken_link_clone_cb;\n+    // because pulldown_cmarks lifetimes are wrong we gotta dance around a few temporaries here\n+    let res = extract_definitions_from_markdown_(&doc_comment, &mut cb)\n+        .take_while(|&(Range { end, .. }, ..)| end < len)\n+        .find_map(|(Range { start, end }, def_link, ns)| {\n             let range = TextRange::at(\n                 comment_start + TextSize::from(start as u32),\n                 TextSize::from((end - start) as u32),\n             );\n             range.contains(position).then(|| (range, def_link, ns))\n-        })?;\n-    Some((range, def_link, ns))\n+        });\n+    res\n }\n \n /// Turns a syntax node into it's [`Definition`] if it can hold docs.\n@@ -220,6 +219,15 @@ pub(crate) fn resolve_doc_path_for_def(\n     }\n }\n \n+fn broken_link_clone_cb<'a, 'b>(link: BrokenLink<'a>) -> Option<(CowStr<'b>, CowStr<'b>)> {\n+    // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n+    // this is fixed in the repo but not on the crates.io release yet\n+    Some((\n+        /*url*/ link.reference.to_owned().into(),\n+        /*title*/ link.reference.to_owned().into(),\n+    ))\n+}\n+\n // FIXME:\n // BUG: For Option::Some\n // Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some"}, {"sha": "4e4d1b2007ca9ffacedb987a3df28c65ca368f24", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=9df78ec4a4e41ca94b25f292aba90e266f104f02", "patch": "@@ -31,7 +31,8 @@ pub(crate) fn goto_definition(\n     let token = sema.descend_into_macros(original_token.clone());\n     let parent = token.parent()?;\n     if let Some(comment) = ast::Comment::cast(token) {\n-        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment)?;\n+        let docs = doc_owner_to_def(&sema, &parent)?.docs(db)?;\n+        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment, docs)?;\n         let def = doc_owner_to_def(&sema, &parent)?;\n         let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n@@ -1158,4 +1159,25 @@ fn fn_macro() {}\n             \"#,\n         )\n     }\n+\n+    #[test]\n+    fn goto_intra_doc_links() {\n+        check(\n+            r#\"\n+\n+pub mod theitem {\n+    /// This is the item. Cool!\n+    pub struct TheItem;\n+             //^^^^^^^\n+}\n+\n+/// Gives you a [`TheItem$0`].\n+///\n+/// [`TheItem`]: theitem::TheItem\n+pub fn gimme() -> theitem::TheItem {\n+    theitem::TheItem\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "5a497e92d1a827dad2d5966ee11dbc4c4cf14aac", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=9df78ec4a4e41ca94b25f292aba90e266f104f02", "patch": "@@ -115,10 +115,11 @@ pub(crate) fn hover(\n \n             _ => ast::Comment::cast(token.clone())\n                 .and_then(|comment| {\n+                    let def = doc_owner_to_def(&sema, &node)?;\n+                    let docs = def.docs(db)?;\n                     let (idl_range, link, ns) =\n-                        extract_positioned_link_from_comment(position.offset, &comment)?;\n+                        extract_positioned_link_from_comment(position.offset, &comment, docs)?;\n                     range = Some(idl_range);\n-                    let def = doc_owner_to_def(&sema, &node)?;\n                     resolve_doc_path_for_def(db, def, &link, ns)\n                 })\n                 .map(Definition::ModuleDef),\n@@ -3812,23 +3813,33 @@ fn main() {\n     fn hover_intra_doc_links() {\n         check(\n             r#\"\n-/// This is the [`foo`](foo$0) function.\n-fn foo() {}\n+\n+pub mod theitem {\n+    /// This is the item. Cool!\n+    pub struct TheItem;\n+}\n+\n+/// Gives you a [`TheItem$0`].\n+///\n+/// [`TheItem`]: theitem::TheItem\n+pub fn gimme() -> theitem::TheItem {\n+    theitem::TheItem\n+}\n \"#,\n             expect![[r#\"\n-                *[`foo`](foo)*\n+                *[`TheItem`]*\n \n                 ```rust\n-                test\n+                test::theitem\n                 ```\n \n                 ```rust\n-                fn foo()\n+                pub struct TheItem\n                 ```\n \n                 ---\n \n-                This is the [`foo`](https://docs.rs/test/*/test/fn.foo.html) function.\n+                This is the item. Cool!\n             \"#]],\n         );\n     }"}, {"sha": "378bac7b218cf93cbb711f6eed1d4f5969b7d506", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df78ec4a4e41ca94b25f292aba90e266f104f02/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=9df78ec4a4e41ca94b25f292aba90e266f104f02", "patch": "@@ -79,6 +79,29 @@ impl Definition {\n         };\n         Some(name)\n     }\n+\n+    pub fn docs(&self, db: &RootDatabase) -> Option<hir::Documentation> {\n+        match self {\n+            Definition::Macro(it) => it.docs(db),\n+            Definition::Field(it) => it.docs(db),\n+            Definition::ModuleDef(def) => match def {\n+                hir::ModuleDef::Module(it) => it.docs(db),\n+                hir::ModuleDef::Function(it) => it.docs(db),\n+                hir::ModuleDef::Adt(def) => match def {\n+                    hir::Adt::Struct(it) => it.docs(db),\n+                    hir::Adt::Union(it) => it.docs(db),\n+                    hir::Adt::Enum(it) => it.docs(db),\n+                },\n+                hir::ModuleDef::Variant(it) => it.docs(db),\n+                hir::ModuleDef::Const(it) => it.docs(db),\n+                hir::ModuleDef::Static(it) => it.docs(db),\n+                hir::ModuleDef::Trait(it) => it.docs(db),\n+                hir::ModuleDef::TypeAlias(it) => it.docs(db),\n+                hir::ModuleDef::BuiltinType(_) => None,\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug)]"}]}