{"sha": "ddbfefef0003992017650945fad1722bacf205d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYmZlZmVmMDAwMzk5MjAxNzY1MDk0NWZhZDE3MjJiYWNmMjA1ZDM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-07-14T11:28:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-14T11:28:38Z"}, "message": "Merge pull request #2826 from nrc/complex-struct\n\nImprove formatting of lists of binops", "tree": {"sha": "a5a8597e4e77d9c88fa91c2f1f082eb5ab0e9de0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5a8597e4e77d9c88fa91c2f1f082eb5ab0e9de0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddbfefef0003992017650945fad1722bacf205d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbSd5mCRBK7hj4Ov3rIwAAdHIIAFf7Gj4QY+hXzurNCC6d5mes\nHv7Trun7duInmxKhXWqjg5RpBVA7/PeG8Xk5FeeL0r6jqQEqsoos7/j/J7gMuaEA\nTw2FO/Q+imXyudPiWp7fpLyjYNb1lJg1wqq1THm++fFdWr36O49Bb52pBiyX5dPN\nFU7OfkpOEd8vuDdvapDmx3ENvp247YsNgIPwevDwKeBcnpzamEVkGRBrLJWN/rWC\ndGHuLjkbvl8WdCv8o8OC6Lm47wpmFf2RrSKTSB3xHmbIjOGAo1dJeQYokkV0mBI4\n9LfhHS7huxgqAZo8kSBV54ahvANxYD2N+W/lgtm25jBBq94GKdP+URcQheTiq20=\n=f7zs\n-----END PGP SIGNATURE-----\n", "payload": "tree a5a8597e4e77d9c88fa91c2f1f082eb5ab0e9de0\nparent 667ad76bca00e04d05c08165a209393c6153125a\nparent 229a55248b49137d32af96bdd88c58913409106e\nauthor Seiichi Uchida <seuchida@gmail.com> 1531567718 +0900\ncommitter GitHub <noreply@github.com> 1531567718 +0900\n\nMerge pull request #2826 from nrc/complex-struct\n\nImprove formatting of lists of binops"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbfefef0003992017650945fad1722bacf205d3", "html_url": "https://github.com/rust-lang/rust/commit/ddbfefef0003992017650945fad1722bacf205d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddbfefef0003992017650945fad1722bacf205d3/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "667ad76bca00e04d05c08165a209393c6153125a", "url": "https://api.github.com/repos/rust-lang/rust/commits/667ad76bca00e04d05c08165a209393c6153125a", "html_url": "https://github.com/rust-lang/rust/commit/667ad76bca00e04d05c08165a209393c6153125a"}, {"sha": "229a55248b49137d32af96bdd88c58913409106e", "url": "https://api.github.com/repos/rust-lang/rust/commits/229a55248b49137d32af96bdd88c58913409106e", "html_url": "https://github.com/rust-lang/rust/commit/229a55248b49137d32af96bdd88c58913409106e"}], "stats": {"total": 661, "additions": 426, "deletions": 235}, "files": [{"sha": "555c0eb96e7ca9ba88fc829ee53429ac26adcc21", "filename": "src/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -194,7 +194,8 @@ fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n             .rev()\n             .take_while(|c| c.is_whitespace())\n             .filter(|&c| c == '\\n')\n-            .count() > 1\n+            .count()\n+            > 1\n     };\n     (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n }"}, {"sha": "cd5e58437e600b2b7404f04c7e0118d44924ac09", "filename": "src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -38,7 +38,8 @@ fn main() {\n \n     let exit_code = match execute(&opts) {\n         Ok((exit_mode, summary)) => {\n-            if summary.has_operational_errors() || summary.has_parsing_errors()\n+            if summary.has_operational_errors()\n+                || summary.has_parsing_errors()\n                 || ((summary.has_diff || summary.has_check_errors())\n                     && exit_mode == ExitCodeMode::Check)\n             {"}, {"sha": "42b883589db1dd42ac03197fc6e816336b5cbd5a", "filename": "src/closures.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -363,7 +363,8 @@ where\n                 })\n                 .unwrap_or(false)\n         })\n-        .count() > 1\n+        .count()\n+        > 1\n }\n \n fn is_block_closure_forced(context: &RewriteContext, expr: &ast::Expr) -> bool {"}, {"sha": "c4675cbcdf7ebd0a1659ed470a0322d2dd78cd96", "filename": "src/expr.rs", "status": "modified", "additions": 13, "deletions": 178, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -31,6 +31,7 @@ use lists::{\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n use matches::rewrite_match;\n use overflow;\n+use pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n use patterns::{can_be_overflowed_pat, is_short_pattern, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -88,11 +89,11 @@ pub fn format_expr(\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape, expr.span),\n         ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n             // FIXME: format comments between operands and operator\n-            rewrite_simple_binaries(context, expr, shape, op).or_else(|| {\n+            rewrite_all_pairs(expr, shape, context).or_else(|| {\n                 rewrite_pair(\n                     &**lhs,\n                     &**rhs,\n-                    PairParts::new(\"\", &format!(\" {} \", context.snippet(op.span)), \"\"),\n+                    PairParts::infix(&format!(\" {} \", context.snippet(op.span))),\n                     context,\n                     shape,\n                     context.config.binop_separator(),\n@@ -211,15 +212,15 @@ pub fn format_expr(\n         ast::ExprKind::Cast(ref expr, ref ty) => rewrite_pair(\n             &**expr,\n             &**ty,\n-            PairParts::new(\"\", \" as \", \"\"),\n+            PairParts::infix(\" as \"),\n             context,\n             shape,\n             SeparatorPlace::Front,\n         ),\n         ast::ExprKind::Type(ref expr, ref ty) => rewrite_pair(\n             &**expr,\n             &**ty,\n-            PairParts::new(\"\", \": \", \"\"),\n+            PairParts::infix(\": \"),\n             context,\n             shape,\n             SeparatorPlace::Back,\n@@ -288,7 +289,7 @@ pub fn format_expr(\n                     rewrite_pair(\n                         &*lhs,\n                         &*rhs,\n-                        PairParts::new(\"\", &sp_delim, \"\"),\n+                        PairParts::infix(&sp_delim),\n                         context,\n                         shape,\n                         context.config.binop_separator(),\n@@ -361,172 +362,6 @@ pub fn format_expr(\n         })\n }\n \n-/// Collect operands that appears in the given binary operator in the opposite order.\n-/// e.g. `collect_binary_items(e, ||)` for `a && b || c || d` returns `[d, c, a && b]`.\n-fn collect_binary_items<'a>(mut expr: &'a ast::Expr, binop: ast::BinOp) -> Vec<&'a ast::Expr> {\n-    let mut result = vec![];\n-    let mut prev_lhs = None;\n-    loop {\n-        match expr.node {\n-            ast::ExprKind::Binary(inner_binop, ref lhs, ref rhs)\n-                if inner_binop.node == binop.node =>\n-            {\n-                result.push(&**rhs);\n-                expr = lhs;\n-                prev_lhs = Some(lhs);\n-            }\n-            _ => {\n-                if let Some(lhs) = prev_lhs {\n-                    result.push(lhs);\n-                }\n-                break;\n-            }\n-        }\n-    }\n-    result\n-}\n-\n-/// Rewrites a binary expression whose operands fits within a single line.\n-fn rewrite_simple_binaries(\n-    context: &RewriteContext,\n-    expr: &ast::Expr,\n-    shape: Shape,\n-    op: ast::BinOp,\n-) -> Option<String> {\n-    let op_str = context.snippet(op.span);\n-\n-    // 2 = spaces around a binary operator.\n-    let sep_overhead = op_str.len() + 2;\n-    let nested_overhead = sep_overhead - 1;\n-\n-    let nested_shape = (match context.config.indent_style() {\n-        IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n-    }).with_max_width(context.config);\n-    let nested_shape = match context.config.binop_separator() {\n-        SeparatorPlace::Back => nested_shape.sub_width(nested_overhead)?,\n-        SeparatorPlace::Front => nested_shape.offset_left(nested_overhead)?,\n-    };\n-\n-    let opt_rewrites: Option<Vec<_>> = collect_binary_items(expr, op)\n-        .iter()\n-        .rev()\n-        .map(|e| e.rewrite(context, nested_shape))\n-        .collect();\n-    if let Some(rewrites) = opt_rewrites {\n-        if rewrites.iter().all(|e| ::utils::is_single_line(e)) {\n-            let total_width = rewrites.iter().map(|s| s.len()).sum::<usize>()\n-                + sep_overhead * (rewrites.len() - 1);\n-\n-            let sep_str = if total_width <= shape.width {\n-                format!(\" {} \", op_str)\n-            } else {\n-                let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n-                match context.config.binop_separator() {\n-                    SeparatorPlace::Back => format!(\" {}{}\", op_str.trim_right(), indent_str),\n-                    SeparatorPlace::Front => format!(\"{}{} \", indent_str, op_str.trim_left()),\n-                }\n-            };\n-\n-            return wrap_str(rewrites.join(&sep_str), context.config.max_width(), shape);\n-        }\n-    }\n-\n-    None\n-}\n-\n-#[derive(new, Clone, Copy)]\n-pub struct PairParts<'a> {\n-    prefix: &'a str,\n-    infix: &'a str,\n-    suffix: &'a str,\n-}\n-\n-pub fn rewrite_pair<LHS, RHS>(\n-    lhs: &LHS,\n-    rhs: &RHS,\n-    pp: PairParts,\n-    context: &RewriteContext,\n-    shape: Shape,\n-    separator_place: SeparatorPlace,\n-) -> Option<String>\n-where\n-    LHS: Rewrite,\n-    RHS: Rewrite,\n-{\n-    let lhs_overhead = match separator_place {\n-        SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n-        SeparatorPlace::Front => shape.used_width(),\n-    };\n-    let lhs_shape = Shape {\n-        width: context.budget(lhs_overhead),\n-        ..shape\n-    };\n-    let lhs_result = lhs\n-        .rewrite(context, lhs_shape)\n-        .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n-\n-    // Try to put both lhs and rhs on the same line.\n-    let rhs_orig_result = shape\n-        .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n-        .and_then(|s| s.sub_width(pp.suffix.len()))\n-        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n-    if let Some(ref rhs_result) = rhs_orig_result {\n-        // If the length of the lhs is equal to or shorter than the tab width or\n-        // the rhs looks like block expression, we put the rhs on the same\n-        // line with the lhs even if the rhs is multi-lined.\n-        let allow_same_line = lhs_result.len() <= context.config.tab_spaces()\n-            || rhs_result\n-                .lines()\n-                .next()\n-                .map(|first_line| first_line.ends_with('{'))\n-                .unwrap_or(false);\n-        if !rhs_result.contains('\\n') || allow_same_line {\n-            let one_line_width = last_line_width(&lhs_result)\n-                + pp.infix.len()\n-                + first_line_width(rhs_result)\n-                + pp.suffix.len();\n-            if one_line_width <= shape.width {\n-                return Some(format!(\n-                    \"{}{}{}{}\",\n-                    lhs_result, pp.infix, rhs_result, pp.suffix\n-                ));\n-            }\n-        }\n-    }\n-\n-    // We have to use multiple lines.\n-    // Re-evaluate the rhs because we have more space now:\n-    let mut rhs_shape = match context.config.indent_style() {\n-        IndentStyle::Visual => shape\n-            .sub_width(pp.suffix.len() + pp.prefix.len())?\n-            .visual_indent(pp.prefix.len()),\n-        IndentStyle::Block => {\n-            // Try to calculate the initial constraint on the right hand side.\n-            let rhs_overhead = shape.rhs_overhead(context.config);\n-            Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                .sub_width(rhs_overhead)?\n-        }\n-    };\n-    let infix = match separator_place {\n-        SeparatorPlace::Back => pp.infix.trim_right(),\n-        SeparatorPlace::Front => pp.infix.trim_left(),\n-    };\n-    if separator_place == SeparatorPlace::Front {\n-        rhs_shape = rhs_shape.offset_left(infix.len())?;\n-    }\n-    let rhs_result = rhs.rewrite(context, rhs_shape)?;\n-    let indent_str = rhs_shape.indent.to_string_with_newline(context.config);\n-    let infix_with_sep = match separator_place {\n-        SeparatorPlace::Back => format!(\"{}{}\", infix, indent_str),\n-        SeparatorPlace::Front => format!(\"{}{}\", indent_str, infix),\n-    };\n-    Some(format!(\n-        \"{}{}{}{}\",\n-        lhs_result, infix_with_sep, rhs_result, pp.suffix\n-    ))\n-}\n-\n pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n     name: &str,\n     exprs: &[&T],\n@@ -1028,16 +863,16 @@ impl<'a> ControlFlow<'a> {\n             && context\n                 .config\n                 .width_heuristics()\n-                .single_line_if_else_max_width > 0\n+                .single_line_if_else_max_width\n+                > 0\n         {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if let Some(cond_str) = trial {\n-                if cond_str.len()\n-                    <= context\n-                        .config\n-                        .width_heuristics()\n-                        .single_line_if_else_max_width\n+                if cond_str.len() <= context\n+                    .config\n+                    .width_heuristics()\n+                    .single_line_if_else_max_width\n                 {\n                     return Some((cond_str, 0));\n                 }\n@@ -2095,7 +1930,7 @@ fn choose_rhs<R: Rewrite>(\n                 }\n                 (None, Some(ref new_rhs)) => Some(format!(\"{}{}\", new_indent_str, new_rhs)),\n                 (None, None) => None,\n-                (Some(ref orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n+                (Some(orig_rhs), _) => Some(format!(\" {}\", orig_rhs)),\n             }\n         }\n     }"}, {"sha": "00db19f3b6ce1ebf53e0fa6e64ddafcc21d78635", "filename": "src/items.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -1382,7 +1382,8 @@ fn format_tuple_struct(\n         )?;\n     }\n \n-    if !where_clause_str.is_empty() && !where_clause_str.contains('\\n')\n+    if !where_clause_str.is_empty()\n+        && !where_clause_str.contains('\\n')\n         && (result.contains('\\n')\n             || offset.block_indent + result.len() + where_clause_str.len() + 1\n                 > context.config.max_width())\n@@ -2527,7 +2528,8 @@ fn rewrite_where_clause_rfc_style(\n         && comment_before.is_empty()\n         && comment_after.is_empty()\n         && !preds_str.contains('\\n')\n-        && 6 + preds_str.len() <= shape.width || where_single_line\n+        && 6 + preds_str.len() <= shape.width\n+        || where_single_line\n     {\n         Cow::from(\" \")\n     } else {\n@@ -2737,7 +2739,8 @@ fn format_generics(\n             false,\n         )?;\n         result.push_str(&where_clause_str);\n-        brace_pos == BracePos::ForceSameLine || brace_style == BraceStyle::PreferSameLine\n+        brace_pos == BracePos::ForceSameLine\n+            || brace_style == BraceStyle::PreferSameLine\n             || (generics.where_clause.predicates.is_empty()\n                 && trimmed_last_line_width(&result) == 1)\n     } else {"}, {"sha": "2c9a792d92d311444cfe2070d30eb32550a3096c", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -86,6 +86,7 @@ mod matches;\n mod missed_spans;\n pub(crate) mod modules;\n mod overflow;\n+mod pairs;\n mod patterns;\n mod reorder;\n mod rewrite;"}, {"sha": "c415032ad67b9c5ab06f68d0cf22d3b93b5d2753", "filename": "src/lists.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -97,11 +97,10 @@ impl ListItem {\n     }\n \n     pub fn is_different_group(&self) -> bool {\n-        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some()\n-            || self\n-                .post_comment\n-                .as_ref()\n-                .map_or(false, |s| s.contains('\\n'))\n+        self.inner_as_ref().contains('\\n') || self.pre_comment.is_some() || self\n+            .post_comment\n+            .as_ref()\n+            .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn is_multiline(&self) -> bool {\n@@ -420,7 +419,8 @@ where\n                 if first_line_width(&formatted_comment)\n                     + last_line_width(&result)\n                     + comment_alignment\n-                    + 1 > formatting.config.max_width()\n+                    + 1\n+                    > formatting.config.max_width()\n                 {\n                     item_max_width = None;\n                     formatted_comment = rewrite_post_comment(&mut item_max_width)?;"}, {"sha": "76f50b30a545281b371410721f2d60c9ea25c28b", "filename": "src/macros.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -1107,23 +1107,22 @@ fn indent_macro_snippet(\n         .min()?;\n \n     Some(\n-        first_line + \"\\n\"\n-            + &trimmed_lines\n-                .iter()\n-                .map(\n-                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n-                        _ if !trimmed => line.to_owned(),\n-                        Some(original_indent_width) => {\n-                            let new_indent_width = indent.width()\n-                                + original_indent_width.saturating_sub(min_prefix_space_width);\n-                            let new_indent = Indent::from_width(context.config, new_indent_width);\n-                            format!(\"{}{}\", new_indent.to_string(context.config), line.trim())\n-                        }\n-                        None => String::new(),\n-                    },\n-                )\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\"),\n+        first_line + \"\\n\" + &trimmed_lines\n+            .iter()\n+            .map(\n+                |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n+                    _ if !trimmed => line.to_owned(),\n+                    Some(original_indent_width) => {\n+                        let new_indent_width = indent.width() + original_indent_width\n+                            .saturating_sub(min_prefix_space_width);\n+                        let new_indent = Indent::from_width(context.config, new_indent_width);\n+                        format!(\"{}{}\", new_indent.to_string(context.config), line.trim())\n+                    }\n+                    None => String::new(),\n+                },\n+            )\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\"),\n     )\n }\n "}, {"sha": "54e594d814f8a210d4beac2f518ca3093f3b3778", "filename": "src/overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -320,15 +320,13 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                                     ListTactic::HorizontalVertical,\n                                     Separator::Comma,\n                                     self.nested_shape.width,\n-                                )\n-                                    == DefinitiveListTactic::Horizontal\n+                                ) == DefinitiveListTactic::Horizontal\n                                 && definitive_tactic(\n                                     &list_items[num_args_before + 1..],\n                                     ListTactic::HorizontalVertical,\n                                     Separator::Comma,\n                                     self.nested_shape.width,\n-                                )\n-                                    == DefinitiveListTactic::Horizontal;\n+                                ) == DefinitiveListTactic::Horizontal;\n \n                             if one_line {\n                                 tactic = DefinitiveListTactic::SpecialMacro(num_args_before);"}, {"sha": "2c4358f7278a8f5aa00caeda29fdb3e6b85b51e8", "filename": "src/pairs.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -0,0 +1,331 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+\n+use config::lists::*;\n+use config::IndentStyle;\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use utils::{first_line_width, is_single_line, last_line_width, trimmed_last_line_width, wrap_str};\n+\n+/// Sigils that decorate a binop pair.\n+#[derive(new, Clone, Copy)]\n+pub(crate) struct PairParts<'a> {\n+    prefix: &'a str,\n+    infix: &'a str,\n+    suffix: &'a str,\n+}\n+\n+impl<'a> PairParts<'a> {\n+    pub(crate) fn infix(infix: &'a str) -> PairParts<'a> {\n+        PairParts {\n+            prefix: \"\",\n+            infix,\n+            suffix: \"\",\n+        }\n+    }\n+}\n+\n+// Flattens a tree of pairs into a list and tries to rewrite them all at once.\n+// FIXME would be nice to reuse the lists API for this, but because each separator\n+// can be different, we can't.\n+pub(crate) fn rewrite_all_pairs(\n+    expr: &ast::Expr,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    // First we try formatting on one line.\n+    if let Some(list) = expr.flatten(context, false) {\n+        if let Some(r) = rewrite_pairs_one_line(&list, shape, context) {\n+            return Some(r);\n+        }\n+    }\n+\n+    // We can't format on line, so try many. When we flatten here we make sure\n+    // to only flatten pairs with the same operator, that way we don't\n+    // necessarily need one line per sub-expression, but we don't do anything\n+    // too funny wrt precedence.\n+    expr.flatten(context, true)\n+        .and_then(|list| rewrite_pairs_multiline(list, shape, context))\n+}\n+\n+// This may return a multi-line result since we allow the last expression to go\n+// multiline in a 'single line' formatting.\n+fn rewrite_pairs_one_line<T: Rewrite>(\n+    list: &PairList<T>,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    assert!(list.list.len() >= 2, \"Not a pair?\");\n+\n+    let mut result = String::new();\n+    let base_shape = shape.block();\n+\n+    for (e, s) in list.list.iter().zip(list.separators.iter()) {\n+        let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n+        let rewrite = e.rewrite(context, cur_shape)?;\n+\n+        if !is_single_line(&rewrite) || result.len() > shape.width {\n+            return None;\n+        }\n+\n+        result.push_str(&rewrite);\n+        result.push(' ');\n+        result.push_str(s);\n+        result.push(' ');\n+    }\n+\n+    let last = list.list.last().unwrap();\n+    let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n+    let rewrite = last.rewrite(context, cur_shape)?;\n+    result.push_str(&rewrite);\n+\n+    if first_line_width(&result) > shape.width {\n+        return None;\n+    }\n+\n+    // Check the last expression in the list. We let this expression go over\n+    // multiple lines, but we check that if this is necessary, then we can't\n+    // do better using multi-line formatting.\n+    if !is_single_line(&result) {\n+        let multiline_shape = shape.offset_left(list.separators.last().unwrap().len() + 1)?;\n+        let multiline_list: PairList<T> = PairList {\n+            list: vec![last],\n+            separators: vec![],\n+            separator_place: list.separator_place,\n+        };\n+        // Format as if we were multi-line.\n+        if let Some(rewrite) = rewrite_pairs_multiline(multiline_list, multiline_shape, context) {\n+            // Also, don't let expressions surrounded by parens go multi-line,\n+            // this looks really bad.\n+            if rewrite.starts_with('(') || is_single_line(&rewrite) {\n+                return None;\n+            }\n+        }\n+    }\n+\n+    wrap_str(result, context.config.max_width(), shape)\n+}\n+\n+fn rewrite_pairs_multiline<T: Rewrite>(\n+    list: PairList<T>,\n+    shape: Shape,\n+    context: &RewriteContext,\n+) -> Option<String> {\n+    let rhs_offset = shape.rhs_overhead(&context.config);\n+    let nested_shape = (match context.config.indent_style() {\n+        IndentStyle::Visual => shape.visual_indent(0),\n+        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n+    }).with_max_width(&context.config)\n+        .sub_width(rhs_offset)?;\n+\n+    let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+    let mut result = String::new();\n+\n+    let rewrite = list.list[0].rewrite(context, shape)?;\n+    result.push_str(&rewrite);\n+\n+    for (e, s) in list.list[1..].iter().zip(list.separators.iter()) {\n+        // The following test checks if we should keep two subexprs on the same\n+        // line. We do this if not doing so would create an orphan and there is\n+        // enough space to do so.\n+        let offset = if result.contains('\\n') {\n+            0\n+        } else {\n+            shape.used_width()\n+        };\n+        if last_line_width(&result) + offset <= nested_shape.used_width() {\n+            // We must snuggle the next line onto the previous line to avoid an orphan.\n+            if let Some(line_shape) =\n+                shape.offset_left(s.len() + 2 + trimmed_last_line_width(&result))\n+            {\n+                if let Some(rewrite) = e.rewrite(context, line_shape) {\n+                    result.push(' ');\n+                    result.push_str(s);\n+                    result.push(' ');\n+                    result.push_str(&rewrite);\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        let nested_overhead = s.len() + 1;\n+        let line_shape = match context.config.binop_separator() {\n+            SeparatorPlace::Back => {\n+                result.push(' ');\n+                result.push_str(s);\n+                result.push_str(&indent_str);\n+                nested_shape.sub_width(nested_overhead)?\n+            }\n+            SeparatorPlace::Front => {\n+                result.push_str(&indent_str);\n+                result.push_str(s);\n+                result.push(' ');\n+                nested_shape.offset_left(nested_overhead)?\n+            }\n+        };\n+\n+        let rewrite = e.rewrite(context, line_shape)?;\n+        result.push_str(&rewrite);\n+    }\n+    Some(result)\n+}\n+\n+// Rewrites a single pair.\n+pub(crate) fn rewrite_pair<LHS, RHS>(\n+    lhs: &LHS,\n+    rhs: &RHS,\n+    pp: PairParts,\n+    context: &RewriteContext,\n+    shape: Shape,\n+    separator_place: SeparatorPlace,\n+) -> Option<String>\n+where\n+    LHS: Rewrite,\n+    RHS: Rewrite,\n+{\n+    let tab_spaces = context.config.tab_spaces();\n+    let lhs_overhead = match separator_place {\n+        SeparatorPlace::Back => shape.used_width() + pp.prefix.len() + pp.infix.trim_right().len(),\n+        SeparatorPlace::Front => shape.used_width(),\n+    };\n+    let lhs_shape = Shape {\n+        width: context.budget(lhs_overhead),\n+        ..shape\n+    };\n+    let lhs_result = lhs\n+        .rewrite(context, lhs_shape)\n+        .map(|lhs_str| format!(\"{}{}\", pp.prefix, lhs_str))?;\n+\n+    // Try to put both lhs and rhs on the same line.\n+    let rhs_orig_result = shape\n+        .offset_left(last_line_width(&lhs_result) + pp.infix.len())\n+        .and_then(|s| s.sub_width(pp.suffix.len()))\n+        .and_then(|rhs_shape| rhs.rewrite(context, rhs_shape));\n+    if let Some(ref rhs_result) = rhs_orig_result {\n+        // If the length of the lhs is equal to or shorter than the tab width or\n+        // the rhs looks like block expression, we put the rhs on the same\n+        // line with the lhs even if the rhs is multi-lined.\n+        let allow_same_line = lhs_result.len() <= tab_spaces || rhs_result\n+            .lines()\n+            .next()\n+            .map(|first_line| first_line.ends_with('{'))\n+            .unwrap_or(false);\n+        if !rhs_result.contains('\\n') || allow_same_line {\n+            let one_line_width = last_line_width(&lhs_result)\n+                + pp.infix.len()\n+                + first_line_width(rhs_result)\n+                + pp.suffix.len();\n+            if one_line_width <= shape.width {\n+                return Some(format!(\n+                    \"{}{}{}{}\",\n+                    lhs_result, pp.infix, rhs_result, pp.suffix\n+                ));\n+            }\n+        }\n+    }\n+\n+    // We have to use multiple lines.\n+    // Re-evaluate the rhs because we have more space now:\n+    let mut rhs_shape = match context.config.indent_style() {\n+        IndentStyle::Visual => shape\n+            .sub_width(pp.suffix.len() + pp.prefix.len())?\n+            .visual_indent(pp.prefix.len()),\n+        IndentStyle::Block => {\n+            // Try to calculate the initial constraint on the right hand side.\n+            let rhs_overhead = shape.rhs_overhead(context.config);\n+            Shape::indented(shape.indent.block_indent(context.config), context.config)\n+                .sub_width(rhs_overhead)?\n+        }\n+    };\n+    let infix = match separator_place {\n+        SeparatorPlace::Back => pp.infix.trim_right(),\n+        SeparatorPlace::Front => pp.infix.trim_left(),\n+    };\n+    if separator_place == SeparatorPlace::Front {\n+        rhs_shape = rhs_shape.offset_left(infix.len())?;\n+    }\n+    let rhs_result = rhs.rewrite(context, rhs_shape)?;\n+    let indent_str = rhs_shape.indent.to_string_with_newline(context.config);\n+    let infix_with_sep = match separator_place {\n+        SeparatorPlace::Back => format!(\"{}{}\", infix, indent_str),\n+        SeparatorPlace::Front => format!(\"{}{}\", indent_str, infix),\n+    };\n+    Some(format!(\n+        \"{}{}{}{}\",\n+        lhs_result, infix_with_sep, rhs_result, pp.suffix\n+    ))\n+}\n+\n+// A pair which forms a tree and can be flattened (e.g., binops).\n+trait FlattenPair: Rewrite + Sized {\n+    // If `_same_op` is `true`, then we only combine binops with the same\n+    // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n+    // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n+    // `[a, b, c]`\n+    fn flatten(&self, _context: &RewriteContext, _same_op: bool) -> Option<PairList<Self>> {\n+        None\n+    }\n+}\n+\n+struct PairList<'a, 'b, T: Rewrite + 'b> {\n+    list: Vec<&'b T>,\n+    separators: Vec<&'a str>,\n+    separator_place: SeparatorPlace,\n+}\n+\n+impl FlattenPair for ast::Expr {\n+    fn flatten(&self, context: &RewriteContext, same_op: bool) -> Option<PairList<ast::Expr>> {\n+        let top_op = match self.node {\n+            ast::ExprKind::Binary(op, _, _) => op.node,\n+            _ => return None,\n+        };\n+\n+        // Turn a tree of binop expressions into a list using a depth-first,\n+        // in-order traversal.\n+        let mut stack = vec![];\n+        let mut list = vec![];\n+        let mut separators = vec![];\n+        let mut node = self;\n+        loop {\n+            match node.node {\n+                ast::ExprKind::Binary(op, ref lhs, _) if !same_op || op.node == top_op => {\n+                    stack.push(node);\n+                    node = lhs;\n+                }\n+                _ => {\n+                    list.push(node);\n+                    if let Some(pop) = stack.pop() {\n+                        match pop.node {\n+                            ast::ExprKind::Binary(op, _, ref rhs) => {\n+                                separators.push(op.node.to_string());\n+                                node = rhs;\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        assert_eq!(list.len() - 1, separators.len());\n+        Some(PairList {\n+            list,\n+            separators,\n+            separator_place: context.config.binop_separator(),\n+        })\n+    }\n+}\n+\n+impl FlattenPair for ast::Ty {}\n+impl FlattenPair for ast::Pat {}"}, {"sha": "dbe0c8a6f6623cb49dcd9460e11a887ddc33a419", "filename": "src/patterns.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -15,15 +15,14 @@ use syntax::ptr;\n \n use codemap::SpanUtils;\n use comment::FindUncommented;\n-use expr::{\n-    can_be_overflowed_expr, rewrite_pair, rewrite_unary_prefix, wrap_struct_field, PairParts,\n-};\n+use expr::{can_be_overflowed_expr, rewrite_unary_prefix, wrap_struct_field};\n use lists::{\n     itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape, struct_lit_tactic,\n     write_list,\n };\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n+use pairs::{rewrite_pair, PairParts};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n@@ -112,7 +111,7 @@ impl Rewrite for Pat {\n                 rewrite_pair(\n                     &**lhs,\n                     &**rhs,\n-                    PairParts::new(\"\", &infix, \"\"),\n+                    PairParts::infix(&infix),\n                     context,\n                     shape,\n                     SeparatorPlace::Front,"}, {"sha": "5947b4ae87ffd4b6835e5755df19ef5df733be9d", "filename": "src/reorder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -242,12 +242,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         let item_length = items\n             .iter()\n             .take_while(|ppi| {\n-                item_kind.is_same_item_kind(&***ppi) && (!in_group || {\n-                    let current = self.codemap.lookup_line_range(ppi.span());\n-                    let in_same_group = current.lo < last.hi + 2;\n-                    last = current;\n-                    in_same_group\n-                })\n+                item_kind.is_same_item_kind(&***ppi)\n+                    && (!in_group || {\n+                        let current = self.codemap.lookup_line_range(ppi.span());\n+                        let in_same_group = current.lo < last.hi + 2;\n+                        last = current;\n+                        in_same_group\n+                    })\n             })\n             .count();\n         let items = &items[..item_length];"}, {"sha": "39eaf57d72e9487836d0f63c5a758b1b67ad7bc0", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -72,7 +72,8 @@ pub fn rewrite_string<'a>(\n     // succeed.\n     let mut max_chars = shape\n         .width\n-        .checked_sub(fmt.opener.len() + ender_length + 1)? + 1;\n+        .checked_sub(fmt.opener.len() + ender_length + 1)?\n+        + 1;\n \n     // Snip a line at a time from `orig` until it is used up. Push the snippet\n     // onto result."}, {"sha": "633f9f8bd3f3e56489ddd5927663dc204f4fac56", "filename": "src/test/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -703,7 +703,8 @@ impl ConfigCodeBlock {\n             .unwrap()\n             .split('\\n')\n             .nth(0)\n-            .unwrap_or(\"\") == \"#![rustfmt::skip]\";\n+            .unwrap_or(\"\")\n+            == \"#![rustfmt::skip]\";\n \n         if self.config_name.is_none() && !fmt_skip {\n             write_message(&format!("}, {"sha": "0c978ea28a6792c739c1cb76fc164de9434af064", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -18,12 +18,11 @@ use syntax::symbol::keywords;\n \n use codemap::SpanUtils;\n use config::{IndentStyle, TypeDensity};\n-use expr::{\n-    rewrite_assign_rhs, rewrite_pair, rewrite_tuple, rewrite_unary_prefix, PairParts, ToExpr,\n-};\n+use expr::{rewrite_assign_rhs, rewrite_tuple, rewrite_unary_prefix, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n use macros::{rewrite_macro, MacroPosition};\n use overflow;\n+use pairs::{rewrite_pair, PairParts};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;"}, {"sha": "48b71d9a84fa0060787abd3d8e90ae7aae0fea93", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -295,11 +295,10 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n // Return true if the given span does not intersect with file lines.\n macro_rules! out_of_file_lines_range {\n     ($self:ident, $span:expr) => {\n-        !$self.config.file_lines().is_all()\n-            && !$self\n-                .config\n-                .file_lines()\n-                .intersects(&$self.codemap.lookup_line_range($span))\n+        !$self.config.file_lines().is_all() && !$self\n+            .config\n+            .file_lines()\n+            .intersects(&$self.codemap.lookup_line_range($span))\n     };\n }\n "}, {"sha": "1b7fdb9be1d1745baa9a51620d27d1d691ea0e31", "filename": "src/vertical.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -173,11 +173,14 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n         let rest_span = mk_sp(init_last_pos, span.hi());\n         let rest_str = rewrite_with_alignment(rest, context, shape, rest_span, one_line_width)?;\n         Some(\n-            result + spaces + \"\\n\"\n+            result\n+                + spaces\n+                + \"\\n\"\n                 + &shape\n                     .indent\n                     .block_indent(context.config)\n-                    .to_string(context.config) + &rest_str,\n+                    .to_string(context.config)\n+                + &rest_str,\n         )\n     }\n }"}, {"sha": "c0ab651bfd6ff1eeb1048c318a27936d8a6d2848", "filename": "tests/source/expr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -440,3 +440,10 @@ fn issue2704() {\n fn issue2782() {\n     {let f={let f={{match f{F(f,_)=>{{loop{let f={match f{F(f,_)=>{{match f{F(f,_)=>{{loop{let f={let f={match f{'-'=>F(f,()),}};};}}}}}}}};}}}}}};};}\n }\n+\n+fn issue_2802() {\n+    function_to_fill_this_line(some_arg, some_arg, some_arg)\n+        * a_very_specific_length(specific_length_arg) * very_specific_length(Foo {\n+        a: some_much_much_longer_value,\n+    }) * some_value\n+}"}, {"sha": "5684b6efd31585b9459285c23f8515ce2660877a", "filename": "tests/target/expr.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddbfefef0003992017650945fad1722bacf205d3/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddbfefef0003992017650945fad1722bacf205d3/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=ddbfefef0003992017650945fad1722bacf205d3", "patch": "@@ -14,7 +14,8 @@ fn foo() -> bool {\n         self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n \n     let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb\n-        / (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;\n+        / (bbbbbb - function_call(x, *very_long_pointer, y))\n+        + 1000;\n \n     some_ridiculously_loooooooooooooooooooooong_function(\n         10000 * 30000000000 + 40000 / 1002200000000 - 50000 * sqrt(-1),\n@@ -358,7 +359,8 @@ fn issue1749() {\n         {\n             {\n                 if self.shape[(r as f32 + self.x_offset) as usize]\n-                    [(c as f32 + self.y_offset) as usize] != 0\n+                    [(c as f32 + self.y_offset) as usize]\n+                    != 0\n                 {\n                     // hello\n                 }\n@@ -507,3 +509,12 @@ fn issue2782() {\n         };\n     }\n }\n+\n+fn issue_2802() {\n+    function_to_fill_this_line(some_arg, some_arg, some_arg)\n+        * a_very_specific_length(specific_length_arg)\n+        * very_specific_length(Foo {\n+            a: some_much_much_longer_value,\n+        })\n+        * some_value\n+}"}]}