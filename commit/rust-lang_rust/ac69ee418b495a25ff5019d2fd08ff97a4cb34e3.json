{"sha": "ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNjllZTQxOGI0OTVhMjVmZjUwMTlkMmZkMDhmZjk3YTRjYjM0ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-25T18:36:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-25T18:36:36Z"}, "message": "auto merge of #6048 : bjz/rust/numeric-traits, r=pcwalton\n\nAs part of the numeric trait reform (see issue #4819), I have added the following traits to `core::num` and implemented them for floating point types:\r\n\r\n~~~rust\r\npub trait Round {\r\n    fn floor(&self) -> Self;\r\n    fn ceil(&self) -> Self;\r\n    fn round(&self) -> Self;\r\n    fn trunc(&self) -> Self;\r\n    fn fract(&self) -> Self;\r\n}\r\n\r\npub trait Fractional: Num\r\n                    + Ord\r\n                    + Round\r\n                    + Quot<Self,Self> {\r\n    fn recip(&self) -> Self;\r\n}\r\n\r\npub trait Real: Signed\r\n              + Fractional {\r\n    // Common Constants\r\n    fn pi() -> Self;\r\n    fn two_pi() -> Self;\r\n    fn frac_pi_2() -> Self;\r\n    fn frac_pi_3() -> Self;\r\n    fn frac_pi_4() -> Self;\r\n    fn frac_pi_6() -> Self;\r\n    fn frac_pi_8() -> Self;\r\n    fn frac_1_pi() -> Self;\r\n    fn frac_2_pi() -> Self;\r\n    fn frac_2_sqrtpi() -> Self;\r\n    fn sqrt2() -> Self;\r\n    fn frac_1_sqrt2() -> Self;\r\n    fn e() -> Self;\r\n    fn log2_e() -> Self;\r\n    fn log10_e() -> Self;\r\n    fn log_2() -> Self;\r\n    fn log_10() -> Self;\r\n\r\n    // Exponential functions\r\n    fn pow(&self, n: Self) -> Self;\r\n    fn exp(&self) -> Self;\r\n    fn exp2(&self) -> Self;\r\n    fn expm1(&self) -> Self;\r\n    fn ldexp(&self, n: int) -> Self;\r\n    fn log(&self) -> Self;\r\n    fn log2(&self) -> Self;\r\n    fn log10(&self) -> Self;\r\n    fn log_radix(&self) -> Self;\r\n    fn ilog_radix(&self) -> int;\r\n    fn sqrt(&self) -> Self;\r\n    fn rsqrt(&self) -> Self;\r\n    fn cbrt(&self) -> Self;\r\n\r\n    // Angular conversions\r\n    fn to_degrees(&self) -> Self;\r\n    fn to_radians(&self) -> Self;\r\n\r\n    // Triganomic functions\r\n    fn hypot(&self, other: Self) -> Self;\r\n    fn sin(&self) -> Self;\r\n    fn cos(&self) -> Self;\r\n    fn tan(&self) -> Self;\r\n\r\n    // Inverse triganomic functions\r\n    fn asin(&self) -> Self;\r\n    fn acos(&self) -> Self;\r\n    fn atan(&self) -> Self;\r\n    fn atan2(&self, other: Self) -> Self;\r\n\r\n    // Hyperbolic triganomic functions\r\n    fn sinh(&self) -> Self;\r\n    fn cosh(&self) -> Self;\r\n    fn tanh(&self) -> Self;\r\n}\r\n\r\n/// Methods that are harder to implement and not commonly used.\r\npub trait RealExt: Real {\r\n    // Gamma functions\r\n    fn lgamma(&self) -> (int, Self);\r\n    fn tgamma(&self) -> Self;\r\n\r\n    // Bessel functions\r\n    fn j0(&self) -> Self;\r\n    fn j1(&self) -> Self;\r\n    fn jn(&self, n: int) -> Self;\r\n    fn y0(&self) -> Self;\r\n    fn y1(&self) -> Self;\r\n    fn yn(&self, n: int) -> Self;\r\n} \r\n~~~\r\n\r\nThe constants in `Real` could be [associated items](http://smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/) in the future (see issue #5527). At the moment I have left the constants in `{float|f32|f64}::consts` in case folks need to access these at compile time. There are also instances of `int` in `Real` and `RealExt`. In the future these could be replaced with an associated `INTEGER` type on `Real`.\r\n\r\n`Natural` has also been renamed to `Integer`. This is because `Natural` normally means 'positive integer' in mathematics. It is therefore strange to implement it on signed integer types. `Integer` is probably a better choice.\r\n\r\nI have also switched some of the `Integer` methods to take borrowed pointers as arguments. This brings them in line with the `Quot` and `Rem` traits, and is be better for large Integer types like `BigInt` and `BigUint` because they don't need to be copied unnecessarily.\r\n\r\nThere has also been considerable discussion on the mailing list and IRC about the renaming of the `Div` and `Modulo` traits to `Quot` and `Rem`. Depending on the outcome of these discussions they might be renamed again.", "tree": {"sha": "daafa5bc9ec9ac2211afecdf388758bca14352de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daafa5bc9ec9ac2211afecdf388758bca14352de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "html_url": "https://github.com/rust-lang/rust/commit/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d53babd2f23439975518fda94d9122b15e779c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d53babd2f23439975518fda94d9122b15e779c9", "html_url": "https://github.com/rust-lang/rust/commit/1d53babd2f23439975518fda94d9122b15e779c9"}, {"sha": "225ac216157cf530332cef1c926875e2023e48e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/225ac216157cf530332cef1c926875e2023e48e6", "html_url": "https://github.com/rust-lang/rust/commit/225ac216157cf530332cef1c926875e2023e48e6"}], "stats": {"total": 1467, "additions": 1148, "deletions": 319}, "files": [{"sha": "71bbaf557ce38691be3755e00160d52bef7e287d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -77,9 +77,7 @@ pub use kinds::{Const, Copy, Owned, Durable};\n pub use ops::{Drop};\n #[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};\n@@ -105,7 +103,9 @@ pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n-pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n+pub use num::{Num, NumCast};\n+pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Round, Fractional, Real, RealExt};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "7d5807ba5462c8525bf9e5697bb10c3158d1928a", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 289, "deletions": 41, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -10,20 +10,10 @@\n \n //! Operations and constants for `f32`\n \n-use num::strconv;\n-use num::Signed;\n-use num;\n-use option::Option;\n use from_str;\n-use to_str;\n-\n-#[cfg(notest)] use cmp::{Eq, Ord};\n-#[cfg(stage0,notest)]\n-use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use libc::c_int;\n+use num::strconv;\n+use prelude::*;\n \n pub use cmath::c_float_targ_consts::*;\n \n@@ -233,6 +223,8 @@ pub fn logarithm(n: f32, b: f32) -> f32 {\n     return log2(n) / log2(b);\n }\n \n+impl Num for f32 {}\n+\n #[cfg(notest)]\n impl Eq for f32 {\n     #[inline(always)]\n@@ -286,10 +278,7 @@ impl Div<f32,f32> for f32 {\n     #[inline(always)]\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Quot<f32,f32> for f32 {\n     #[inline(always)]\n     fn quot(&self, other: &f32) -> f32 { *self / *other }\n@@ -300,10 +289,7 @@ impl Modulo<f32,f32> for f32 {\n     #[inline(always)]\n     fn modulo(&self, other: &f32) -> f32 { *self % *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Rem<f32,f32> for f32 {\n     #[inline(always)]\n     fn rem(&self, other: &f32) -> f32 { *self % *other }\n@@ -341,31 +327,188 @@ impl Signed for f32 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n-impl num::Round for f32 {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> f32 {\n-        match mode {\n-            num::RoundDown                           => floor(*self),\n-            num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if self.is_negative() => ceil(*self),\n-            num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if self.is_negative() => floor(*self),\n-            num::RoundFromZero                       => ceil(*self)\n-        }\n-    }\n-\n+impl Round for f32 {\n+    /// Round half-way cases toward `neg_infinity`\n     #[inline(always)]\n     fn floor(&self) -> f32 { floor(*self) }\n+\n+    /// Round half-way cases toward `infinity`\n     #[inline(always)]\n     fn ceil(&self) -> f32 { ceil(*self) }\n+\n+    /// Round half-way cases away from `0.0`\n     #[inline(always)]\n-    fn fract(&self) -> f32 {\n-        if self.is_negative() {\n-            (*self) - ceil(*self)\n-        } else {\n-            (*self) - floor(*self)\n-        }\n-    }\n+    fn round(&self) -> f32 { round(*self) }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline(always)]\n+    fn trunc(&self) -> f32 { trunc(*self) }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> f32 { *self - self.trunc() }\n+}\n+\n+impl Fractional for f32 {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> f32 { 1.0 / *self }\n+}\n+\n+impl Real for f32 {\n+    /// Archimedes' constant\n+    #[inline(always)]\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n+    #[inline(always)]\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n+    #[inline(always)]\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+\n+    /// 1 .0/ pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> f32 { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> f32 { 2.30258509299404568401799145468436421 }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: f32) -> f32 { pow(*self, n) }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> f32 { exp(*self) }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> f32 { exp2(*self) }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> f32 { expm1(*self) }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> f32 { ldexp(*self, n as c_int) }\n+\n+    #[inline(always)]\n+    fn log(&self) -> f32 { ln(*self) }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> f32 { log2(*self) }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> f32 { log10(*self) }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> f32 { log_radix(*self) as f32 }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> f32 { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> f32 { cbrt(*self) }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> f32 { *self * (180.0 / Real::pi::<f32>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> f32 { *self * (Real::pi::<f32>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: f32) -> f32 { hypot(*self, other) }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> f32 { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> f32 { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> f32 { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> f32 { asin(*self) }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> f32 { acos(*self) }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> f32 { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: f32) -> f32 { atan2(*self, other) }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> f32 { sinh(*self) }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> f32 { cosh(*self) }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> f32 { tanh(*self) }\n }\n \n /**\n@@ -588,6 +731,111 @@ impl num::FromStrRadix for f32 {\n #[cfg(test)]\n mod tests {\n     use f32::*;\n+    use super::*;\n+    use prelude::*;\n+\n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+            }\n+        })\n+    )\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10f32, 2f32);\n+    }\n+\n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(1.7f32.floor(), 1.0f32);\n+        assert_fuzzy_eq!(0.0f32.floor(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).floor(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).floor(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).floor(), -2.0f32);\n+        assert_fuzzy_eq!((-1.5f32).floor(), -2.0f32);\n+        assert_fuzzy_eq!((-1.7f32).floor(), -2.0f32);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f32.ceil(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(1.5f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(1.7f32.ceil(), 2.0f32);\n+        assert_fuzzy_eq!(0.0f32.ceil(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).ceil(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).ceil(), -1.0f32);\n+        assert_fuzzy_eq!((-1.7f32).ceil(), -1.0f32);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f32.round(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.round(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.round(), 2.0f32);\n+        assert_fuzzy_eq!(1.7f32.round(), 2.0f32);\n+        assert_fuzzy_eq!(0.0f32.round(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).round(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).round(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).round(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).round(), -2.0f32);\n+        assert_fuzzy_eq!((-1.7f32).round(), -2.0f32);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.3f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.5f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(1.7f32.trunc(), 1.0f32);\n+        assert_fuzzy_eq!(0.0f32.trunc(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).trunc(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.3f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.5f32).trunc(), -1.0f32);\n+        assert_fuzzy_eq!((-1.7f32).trunc(), -1.0f32);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f32.fract(), 0.0f32);\n+        assert_fuzzy_eq!(1.3f32.fract(), 0.3f32);\n+        assert_fuzzy_eq!(1.5f32.fract(), 0.5f32);\n+        assert_fuzzy_eq!(1.7f32.fract(), 0.7f32);\n+        assert_fuzzy_eq!(0.0f32.fract(), 0.0f32);\n+        assert_fuzzy_eq!((-0.0f32).fract(), -0.0f32);\n+        assert_fuzzy_eq!((-1.0f32).fract(), -0.0f32);\n+        assert_fuzzy_eq!((-1.3f32).fract(), -0.3f32);\n+        assert_fuzzy_eq!((-1.5f32).fract(), -0.5f32);\n+        assert_fuzzy_eq!((-1.7f32).fract(), -0.7f32);\n+    }\n+\n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<f32>(), 2f32 * Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<f32>(), Real::pi::<f32>() / 2f32);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<f32>(), Real::pi::<f32>() / 3f32);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<f32>(), Real::pi::<f32>() / 4f32);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<f32>(), Real::pi::<f32>() / 6f32);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<f32>(), Real::pi::<f32>() / 8f32);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<f32>(), 1f32 / Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<f32>(), 2f32 / Real::pi::<f32>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f32>(), 2f32 / Real::pi::<f32>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<f32>(), 2f32.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f32>(), 1f32 / 2f32.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<f32>(), Real::e::<f32>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<f32>(), Real::e::<f32>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<f32>(), 2f32.log());\n+        assert_fuzzy_eq!(Real::log_10::<f32>(), 10f32.log());\n+    }\n \n     #[test]\n     pub fn test_signed() {"}, {"sha": "3b6198bfc472ecb81e18ffd7fe2613bba0744fba", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 319, "deletions": 38, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -10,20 +10,10 @@\n \n //! Operations and constants for `f64`\n \n-use num::strconv;\n-use num::Signed;\n-use num;\n-use option::Option;\n-use to_str;\n use from_str;\n-\n-#[cfg(notest)] use cmp::{Eq, Ord};\n-#[cfg(stage0,notest)]\n-use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use libc::c_int;\n+use num::strconv;\n+use prelude::*;\n \n pub use cmath::c_double_targ_consts::*;\n pub use cmp::{min, max};\n@@ -254,6 +244,8 @@ pub fn logarithm(n: f64, b: f64) -> f64 {\n     return log2(n) / log2(b);\n }\n \n+impl Num for f64 {}\n+\n #[cfg(notest)]\n impl Eq for f64 {\n     #[inline(always)]\n@@ -300,9 +292,7 @@ impl Mul<f64,f64> for f64 {\n impl Div<f64,f64> for f64 {\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Quot<f64,f64> for f64 {\n     #[inline(always)]\n     fn quot(&self, other: &f64) -> f64 { *self / *other }\n@@ -311,9 +301,7 @@ impl Quot<f64,f64> for f64 {\n impl Modulo<f64,f64> for f64 {\n     fn modulo(&self, other: &f64) -> f64 { *self % *other }\n }\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Rem<f64,f64> for f64 {\n     #[inline(always)]\n     fn rem(&self, other: &f64) -> f64 { *self % *other }\n@@ -349,31 +337,218 @@ impl Signed for f64 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n }\n \n-impl num::Round for f64 {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> f64 {\n-        match mode {\n-            num::RoundDown                           => floor(*self),\n-            num::RoundUp                             => ceil(*self),\n-            num::RoundToZero   if self.is_negative() => ceil(*self),\n-            num::RoundToZero                         => floor(*self),\n-            num::RoundFromZero if self.is_negative() => floor(*self),\n-            num::RoundFromZero                       => ceil(*self)\n-        }\n-    }\n-\n+impl Round for f64 {\n+    /// Round half-way cases toward `neg_infinity`\n     #[inline(always)]\n     fn floor(&self) -> f64 { floor(*self) }\n+\n+    /// Round half-way cases toward `infinity`\n     #[inline(always)]\n     fn ceil(&self) -> f64 { ceil(*self) }\n+\n+    /// Round half-way cases away from `0.0`\n     #[inline(always)]\n-    fn fract(&self) -> f64 {\n-        if self.is_negative() {\n-            (*self) - ceil(*self)\n-        } else {\n-            (*self) - floor(*self)\n-        }\n+    fn round(&self) -> f64 { round(*self) }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n+    #[inline(always)]\n+    fn trunc(&self) -> f64 { trunc(*self) }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> f64 { *self - self.trunc() }\n+}\n+\n+impl Fractional for f64 {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> f64 { 1.0 / *self }\n+}\n+\n+impl Real for f64 {\n+    /// Archimedes' constant\n+    #[inline(always)]\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n+    #[inline(always)]\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n+    #[inline(always)]\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+\n+    /// 1.0 / pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> f64 { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> f64 { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> f64 { 2.30258509299404568401799145468436421 }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: f64) -> f64 { pow(*self, n) }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> f64 { exp(*self) }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> f64 { exp2(*self) }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> f64 { expm1(*self) }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> f64 { ldexp(*self, n as c_int) }\n+\n+    #[inline(always)]\n+    fn log(&self) -> f64 { ln(*self) }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> f64 { log2(*self) }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> f64 { log10(*self) }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> f64 { log_radix(*self) }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> f64 { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> f64 { cbrt(*self) }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> f64 { *self * (180.0 / Real::pi::<f64>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> f64 { *self * (Real::pi::<f64>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: f64) -> f64 { hypot(*self, other) }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> f64 { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> f64 { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> f64 { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> f64 { asin(*self) }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> f64 { acos(*self) }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> f64 { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: f64) -> f64 { atan2(*self, other) }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> f64 { sinh(*self) }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> f64 { cosh(*self) }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> f64 { tanh(*self) }\n+}\n+\n+impl RealExt for f64 {\n+    #[inline(always)]\n+    fn lgamma(&self) -> (int, f64) {\n+        let mut sign = 0;\n+        let result = lgamma(*self, &mut sign);\n+        (sign as int, result)\n     }\n+\n+    #[inline(always)]\n+    fn tgamma(&self) -> f64 { tgamma(*self) }\n+\n+    #[inline(always)]\n+    fn j0(&self) -> f64 { j0(*self) }\n+\n+    #[inline(always)]\n+    fn j1(&self) -> f64 { j1(*self) }\n+\n+    #[inline(always)]\n+    fn jn(&self, n: int) -> f64 { jn(n as c_int, *self) }\n+\n+    #[inline(always)]\n+    fn y0(&self) -> f64 { y0(*self) }\n+\n+    #[inline(always)]\n+    fn y1(&self) -> f64 { y1(*self) }\n+\n+    #[inline(always)]\n+    fn yn(&self, n: int) -> f64 { yn(n as c_int, *self) }\n }\n \n /**\n@@ -596,6 +771,112 @@ impl num::FromStrRadix for f64 {\n #[cfg(test)]\n mod tests {\n     use f64::*;\n+    use super::*;\n+    use prelude::*;\n+\n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. \\\n+                            Found: %? and expected %?\", a, b));\n+            }\n+        })\n+    )\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10f64, 2f64);\n+    }\n+\n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(1.7f64.floor(), 1.0f64);\n+        assert_fuzzy_eq!(0.0f64.floor(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).floor(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).floor(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).floor(), -2.0f64);\n+        assert_fuzzy_eq!((-1.5f64).floor(), -2.0f64);\n+        assert_fuzzy_eq!((-1.7f64).floor(), -2.0f64);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f64.ceil(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(1.5f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(1.7f64.ceil(), 2.0f64);\n+        assert_fuzzy_eq!(0.0f64.ceil(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).ceil(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).ceil(), -1.0f64);\n+        assert_fuzzy_eq!((-1.7f64).ceil(), -1.0f64);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f64.round(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.round(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.round(), 2.0f64);\n+        assert_fuzzy_eq!(1.7f64.round(), 2.0f64);\n+        assert_fuzzy_eq!(0.0f64.round(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).round(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).round(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).round(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).round(), -2.0f64);\n+        assert_fuzzy_eq!((-1.7f64).round(), -2.0f64);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.3f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.5f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(1.7f64.trunc(), 1.0f64);\n+        assert_fuzzy_eq!(0.0f64.trunc(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).trunc(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.3f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.5f64).trunc(), -1.0f64);\n+        assert_fuzzy_eq!((-1.7f64).trunc(), -1.0f64);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f64.fract(), 0.0f64);\n+        assert_fuzzy_eq!(1.3f64.fract(), 0.3f64);\n+        assert_fuzzy_eq!(1.5f64.fract(), 0.5f64);\n+        assert_fuzzy_eq!(1.7f64.fract(), 0.7f64);\n+        assert_fuzzy_eq!(0.0f64.fract(), 0.0f64);\n+        assert_fuzzy_eq!((-0.0f64).fract(), -0.0f64);\n+        assert_fuzzy_eq!((-1.0f64).fract(), -0.0f64);\n+        assert_fuzzy_eq!((-1.3f64).fract(), -0.3f64);\n+        assert_fuzzy_eq!((-1.5f64).fract(), -0.5f64);\n+        assert_fuzzy_eq!((-1.7f64).fract(), -0.7f64);\n+    }\n+\n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<f64>(), 2.0 * Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<f64>(), Real::pi::<f64>() / 2f64);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<f64>(), Real::pi::<f64>() / 3f64);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<f64>(), Real::pi::<f64>() / 4f64);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<f64>(), Real::pi::<f64>() / 6f64);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<f64>(), Real::pi::<f64>() / 8f64);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<f64>(), 1f64 / Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<f64>(), 2f64 / Real::pi::<f64>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<f64>(), 2f64 / Real::pi::<f64>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<f64>(), 2f64.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<f64>(), 1f64 / 2f64.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<f64>(), Real::e::<f64>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<f64>(), Real::e::<f64>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<f64>(), 2f64.log());\n+        assert_fuzzy_eq!(Real::log_10::<f64>(), 10f64.log());\n+    }\n \n     #[test]\n     pub fn test_signed() {"}, {"sha": "9c0412b422f52bd49188d96cd7dec7b2ac23968a", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 317, "deletions": 55, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -20,21 +20,10 @@\n \n // PORT this must match in width according to architecture\n \n-use f64;\n-use num::strconv;\n-use num::Signed;\n-use num;\n-use option::Option;\n-use to_str;\n use from_str;\n-\n-#[cfg(notest)] use cmp::{Eq, Ord};\n-#[cfg(stage0,notest)]\n-use ops::{Add, Sub, Mul, Div, Modulo, Neg};\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use libc::c_int;\n+use num::strconv;\n+use prelude::*;\n \n pub use f64::{add, sub, mul, quot, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n@@ -382,6 +371,8 @@ pub fn tan(x: float) -> float {\n     f64::tan(x as f64) as float\n }\n \n+impl Num for float {}\n+\n #[cfg(notest)]\n impl Eq for float {\n     #[inline(always)]\n@@ -412,37 +403,218 @@ impl num::One for float {\n     fn one() -> float { 1.0 }\n }\n \n-impl num::Round for float {\n-    #[inline(always)]\n-    fn round(&self, mode: num::RoundMode) -> float {\n-        match mode {\n-            num::RoundDown\n-                => f64::floor(*self as f64) as float,\n-            num::RoundUp\n-                => f64::ceil(*self as f64) as float,\n-            num::RoundToZero   if self.is_negative()\n-                => f64::ceil(*self as f64) as float,\n-            num::RoundToZero\n-                => f64::floor(*self as f64) as float,\n-            num::RoundFromZero if self.is_negative()\n-                => f64::floor(*self as f64) as float,\n-            num::RoundFromZero\n-                => f64::ceil(*self as f64) as float\n-        }\n-    }\n+impl Round for float {\n+    /// Round half-way cases toward `neg_infinity`\n+    #[inline(always)]\n+    fn floor(&self) -> float { floor(*self as f64) as float }\n \n+    /// Round half-way cases toward `infinity`\n     #[inline(always)]\n-    fn floor(&self) -> float { f64::floor(*self as f64) as float}\n+    fn ceil(&self) -> float { ceil(*self as f64) as float }\n+\n+    /// Round half-way cases away from `0.0`\n     #[inline(always)]\n-    fn ceil(&self) -> float { f64::ceil(*self as f64) as float}\n+    fn round(&self) -> float { round(*self as f64) as float }\n+\n+    /// The integer part of the number (rounds towards `0.0`)\n     #[inline(always)]\n-    fn fract(&self) -> float {\n-        if self.is_negative() {\n-            (*self) - (f64::ceil(*self as f64) as float)\n-        } else {\n-            (*self) - (f64::floor(*self as f64) as float)\n-        }\n+    fn trunc(&self) -> float { trunc(*self as f64) as float }\n+\n+    ///\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ~~~\n+    /// assert!(x == trunc(x) + fract(x))\n+    /// ~~~\n+    ///\n+    #[inline(always)]\n+    fn fract(&self) -> float { *self - self.trunc() }\n+}\n+\n+impl Fractional for float {\n+    /// The reciprocal (multiplicative inverse) of the number\n+    #[inline(always)]\n+    fn recip(&self) -> float { 1.0 / *self }\n+}\n+\n+impl Real for float {\n+    /// Archimedes' constant\n+    #[inline(always)]\n+    fn pi() -> float { 3.14159265358979323846264338327950288 }\n+\n+    /// 2.0 * pi\n+    #[inline(always)]\n+    fn two_pi() -> float { 6.28318530717958647692528676655900576 }\n+\n+    /// pi / 2.0\n+    #[inline(always)]\n+    fn frac_pi_2() -> float { 1.57079632679489661923132169163975144 }\n+\n+    /// pi / 3.0\n+    #[inline(always)]\n+    fn frac_pi_3() -> float { 1.04719755119659774615421446109316763 }\n+\n+    /// pi / 4.0\n+    #[inline(always)]\n+    fn frac_pi_4() -> float { 0.785398163397448309615660845819875721 }\n+\n+    /// pi / 6.0\n+    #[inline(always)]\n+    fn frac_pi_6() -> float { 0.52359877559829887307710723054658381 }\n+\n+    /// pi / 8.0\n+    #[inline(always)]\n+    fn frac_pi_8() -> float { 0.39269908169872415480783042290993786 }\n+\n+    /// 1.0 / pi\n+    #[inline(always)]\n+    fn frac_1_pi() -> float { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline(always)]\n+    fn frac_2_pi() -> float { 0.636619772367581343075535053490057448 }\n+\n+    /// 2 .0/ sqrt(pi)\n+    #[inline(always)]\n+    fn frac_2_sqrtpi() -> float { 1.12837916709551257389615890312154517 }\n+\n+    /// sqrt(2.0)\n+    #[inline(always)]\n+    fn sqrt2() -> float { 1.41421356237309504880168872420969808 }\n+\n+    /// 1.0 / sqrt(2.0)\n+    #[inline(always)]\n+    fn frac_1_sqrt2() -> float { 0.707106781186547524400844362104849039 }\n+\n+    /// Euler's number\n+    #[inline(always)]\n+    fn e() -> float { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline(always)]\n+    fn log2_e() -> float { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline(always)]\n+    fn log10_e() -> float { 0.434294481903251827651128918916605082 }\n+\n+    /// log(2.0)\n+    #[inline(always)]\n+    fn log_2() -> float { 0.693147180559945309417232121458176568 }\n+\n+    /// log(10.0)\n+    #[inline(always)]\n+    fn log_10() -> float { 2.30258509299404568401799145468436421 }\n+\n+    #[inline(always)]\n+    fn pow(&self, n: float) -> float { pow(*self as f64, n as f64) as float }\n+\n+    #[inline(always)]\n+    fn exp(&self) -> float { exp(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn exp2(&self) -> float { exp2(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn expm1(&self) -> float { expm1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn ldexp(&self, n: int) -> float { ldexp(*self as f64, n as c_int) as float }\n+\n+    #[inline(always)]\n+    fn log(&self) -> float { ln(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log2(&self) -> float { log2(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log10(&self) -> float { log10(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn log_radix(&self) -> float { log_radix(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn ilog_radix(&self) -> int { ilog_radix(*self as f64) as int }\n+\n+    #[inline(always)]\n+    fn sqrt(&self) -> float { sqrt(*self) }\n+\n+    #[inline(always)]\n+    fn rsqrt(&self) -> float { self.sqrt().recip() }\n+\n+    #[inline(always)]\n+    fn cbrt(&self) -> float { cbrt(*self as f64) as float }\n+\n+    /// Converts to degrees, assuming the number is in radians\n+    #[inline(always)]\n+    fn to_degrees(&self) -> float { *self * (180.0 / Real::pi::<float>()) }\n+\n+    /// Converts to radians, assuming the number is in degrees\n+    #[inline(always)]\n+    fn to_radians(&self) -> float { *self * (Real::pi::<float>() / 180.0) }\n+\n+    #[inline(always)]\n+    fn hypot(&self, other: float) -> float { hypot(*self as f64, other as f64) as float }\n+\n+    #[inline(always)]\n+    fn sin(&self) -> float { sin(*self) }\n+\n+    #[inline(always)]\n+    fn cos(&self) -> float { cos(*self) }\n+\n+    #[inline(always)]\n+    fn tan(&self) -> float { tan(*self) }\n+\n+    #[inline(always)]\n+    fn asin(&self) -> float { asin(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn acos(&self) -> float { acos(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn atan(&self) -> float { atan(*self) }\n+\n+    #[inline(always)]\n+    fn atan2(&self, other: float) -> float { atan2(*self as f64, other as f64) as float }\n+\n+    #[inline(always)]\n+    fn sinh(&self) -> float { sinh(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn cosh(&self) -> float { cosh(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn tanh(&self) -> float { tanh(*self as f64) as float }\n+}\n+\n+impl RealExt for float {\n+    #[inline(always)]\n+    fn lgamma(&self) -> (int, float) {\n+        let mut sign = 0;\n+        let result = lgamma(*self as f64, &mut sign);\n+        (sign as int, result as float)\n     }\n+\n+    #[inline(always)]\n+    fn tgamma(&self) -> float { tgamma(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn j0(&self) -> float { j0(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn j1(&self) -> float { j1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn jn(&self, n: int) -> float { jn(n as c_int, *self as f64) as float }\n+\n+    #[inline(always)]\n+    fn y0(&self) -> float { y0(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn y1(&self) -> float { y1(*self as f64) as float }\n+\n+    #[inline(always)]\n+    fn yn(&self, n: int) -> float { yn(n as c_int, *self as f64) as float }\n }\n \n #[cfg(notest)]\n@@ -468,9 +640,7 @@ impl Div<float,float> for float {\n     #[inline(always)]\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Quot<float,float> for float {\n     #[inline(always)]\n     fn quot(&self, other: &float) -> float { *self / *other }\n@@ -480,9 +650,7 @@ impl Modulo<float,float> for float {\n     #[inline(always)]\n     fn modulo(&self, other: &float) -> float { *self % *other }\n }\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Rem<float,float> for float {\n     #[inline(always)]\n     fn rem(&self, other: &float) -> float { *self % *other }\n@@ -524,6 +692,109 @@ mod tests {\n     use super::*;\n     use prelude::*;\n \n+    macro_rules! assert_fuzzy_eq(\n+        ($a:expr, $b:expr) => ({\n+            let a = $a, b = $b;\n+            if !((a - b).abs() < 1.0e-6) {\n+                fail!(fmt!(\"The values were not approximately equal. Found: %? and %?\", a, b));\n+            }\n+        })\n+    )\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10f, 2f);\n+    }\n+\n+    #[test]\n+    fn test_floor() {\n+        assert_fuzzy_eq!(1.0f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.floor(), 1.0f);\n+        assert_fuzzy_eq!(1.7f.floor(), 1.0f);\n+        assert_fuzzy_eq!(0.0f.floor(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).floor(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).floor(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).floor(), -2.0f);\n+        assert_fuzzy_eq!((-1.5f).floor(), -2.0f);\n+        assert_fuzzy_eq!((-1.7f).floor(), -2.0f);\n+    }\n+\n+    #[test]\n+    fn test_ceil() {\n+        assert_fuzzy_eq!(1.0f.ceil(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(1.5f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(1.7f.ceil(), 2.0f);\n+        assert_fuzzy_eq!(0.0f.ceil(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).ceil(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).ceil(), -1.0f);\n+        assert_fuzzy_eq!((-1.7f).ceil(), -1.0f);\n+    }\n+\n+    #[test]\n+    fn test_round() {\n+        assert_fuzzy_eq!(1.0f.round(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.round(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.round(), 2.0f);\n+        assert_fuzzy_eq!(1.7f.round(), 2.0f);\n+        assert_fuzzy_eq!(0.0f.round(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).round(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).round(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).round(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).round(), -2.0f);\n+        assert_fuzzy_eq!((-1.7f).round(), -2.0f);\n+    }\n+\n+    #[test]\n+    fn test_trunc() {\n+        assert_fuzzy_eq!(1.0f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.3f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.5f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(1.7f.trunc(), 1.0f);\n+        assert_fuzzy_eq!(0.0f.trunc(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).trunc(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.3f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.5f).trunc(), -1.0f);\n+        assert_fuzzy_eq!((-1.7f).trunc(), -1.0f);\n+    }\n+\n+    #[test]\n+    fn test_fract() {\n+        assert_fuzzy_eq!(1.0f.fract(), 0.0f);\n+        assert_fuzzy_eq!(1.3f.fract(), 0.3f);\n+        assert_fuzzy_eq!(1.5f.fract(), 0.5f);\n+        assert_fuzzy_eq!(1.7f.fract(), 0.7f);\n+        assert_fuzzy_eq!(0.0f.fract(), 0.0f);\n+        assert_fuzzy_eq!((-0.0f).fract(), -0.0f);\n+        assert_fuzzy_eq!((-1.0f).fract(), -0.0f);\n+        assert_fuzzy_eq!((-1.3f).fract(), -0.3f);\n+        assert_fuzzy_eq!((-1.5f).fract(), -0.5f);\n+        assert_fuzzy_eq!((-1.7f).fract(), -0.7f);\n+    }\n+\n+    #[test]\n+    fn test_real_consts() {\n+        assert_fuzzy_eq!(Real::two_pi::<float>(), 2f * Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_pi_2::<float>(), Real::pi::<float>() / 2f);\n+        assert_fuzzy_eq!(Real::frac_pi_3::<float>(), Real::pi::<float>() / 3f);\n+        assert_fuzzy_eq!(Real::frac_pi_4::<float>(), Real::pi::<float>() / 4f);\n+        assert_fuzzy_eq!(Real::frac_pi_6::<float>(), Real::pi::<float>() / 6f);\n+        assert_fuzzy_eq!(Real::frac_pi_8::<float>(), Real::pi::<float>() / 8f);\n+        assert_fuzzy_eq!(Real::frac_1_pi::<float>(), 1f / Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_2_pi::<float>(), 2f / Real::pi::<float>());\n+        assert_fuzzy_eq!(Real::frac_2_sqrtpi::<float>(), 2f / Real::pi::<float>().sqrt());\n+        assert_fuzzy_eq!(Real::sqrt2::<float>(), 2f.sqrt());\n+        assert_fuzzy_eq!(Real::frac_1_sqrt2::<float>(), 1f / 2f.sqrt());\n+        assert_fuzzy_eq!(Real::log2_e::<float>(), Real::e::<float>().log2());\n+        assert_fuzzy_eq!(Real::log10_e::<float>(), Real::e::<float>().log10());\n+        assert_fuzzy_eq!(Real::log_2::<float>(), 2f.log());\n+        assert_fuzzy_eq!(Real::log_10::<float>(), 10f.log());\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!(infinity.abs(), infinity);\n@@ -704,15 +975,6 @@ mod tests {\n         assert_eq!(to_str_digits(infinity, 10u), ~\"inf\");\n         assert_eq!(to_str_digits(-infinity, 10u), ~\"-inf\");\n     }\n-\n-    #[test]\n-    pub fn test_round() {\n-        assert_eq!(round(5.8), 6.0);\n-        assert_eq!(round(5.2), 5.0);\n-        assert_eq!(round(3.0), 3.0);\n-        assert_eq!(round(2.5), 3.0);\n-        assert_eq!(round(-3.5), -4.0);\n-    }\n }\n \n //"}, {"sha": "f9edf1cefc873f8a99bbe017d55d42c4b8f1c151", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -10,12 +10,9 @@\n \n use T = self::inst::T;\n \n-use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n-use num::Signed;\n-use num;\n use prelude::*;\n \n pub use cmp::{min, max};\n@@ -133,6 +130,8 @@ pub fn compl(i: T) -> T {\n #[inline(always)]\n pub fn abs(i: T) -> T { i.abs() }\n \n+impl Num for T {}\n+\n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n@@ -186,10 +185,7 @@ impl Div<T,T> for T {\n     #[inline(always)]\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Quot<T,T> for T {\n     /**\n      * Returns the integer quotient, truncated towards 0. As this behaviour reflects\n@@ -218,10 +214,7 @@ impl Modulo<T,T> for T {\n     #[inline(always)]\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Rem<T,T> for T {\n     /**\n      * Returns the integer remainder after division, satisfying:\n@@ -286,7 +279,7 @@ impl Signed for T {\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n-impl Natural for T {\n+impl Integer for T {\n     /**\n      * Floored integer division\n      *\n@@ -305,13 +298,13 @@ impl Natural for T {\n      * ~~~\n      */\n     #[inline(always)]\n-    fn div(&self, other: T) -> T {\n+    fn div(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.quot_rem(other) {\n-            (q, r) if (r > 0 && other < 0)\n-                   || (r < 0 && other > 0) => q - 1,\n-            (q, _)                         => q,\n+            (q, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => q - 1,\n+            (q, _)                          => q,\n         }\n     }\n \n@@ -337,32 +330,32 @@ impl Natural for T {\n      * ~~~\n      */\n     #[inline(always)]\n-    fn modulo(&self, other: T) -> T {\n+    fn modulo(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match *self % other {\n-            r if (r > 0 && other < 0)\n-              || (r < 0 && other > 0) => r + other,\n-            r                         => r,\n+        match *self % *other {\n+            r if (r > 0 && *other < 0)\n+              || (r < 0 && *other > 0) => r + *other,\n+            r                          => r,\n         }\n     }\n \n     /// Calculates `div` and `modulo` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: T) -> (T,T) {\n+    fn div_mod(&self, other: &T) -> (T,T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.quot_rem(other) {\n-            (q, r) if (r > 0 && other < 0)\n-                   || (r < 0 && other > 0) => (q - 1, r + other),\n-            (q, r)                         => (q, r),\n+            (q, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => (q - 1, r + *other),\n+            (q, r)                          => (q, r),\n         }\n     }\n \n     /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn quot_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /**\n@@ -371,9 +364,9 @@ impl Natural for T {\n      * The result is always positive\n      */\n     #[inline(always)]\n-    fn gcd(&self, other: T) -> T {\n+    fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = other;\n+        let mut m = *self, n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;\n@@ -386,17 +379,17 @@ impl Natural for T {\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n     #[inline(always)]\n-    fn lcm(&self, other: T) -> T {\n-        ((*self * other) / self.gcd(other)).abs() // should not have to recaluculate abs\n+    fn lcm(&self, other: &T) -> T {\n+        ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(2) }\n+    fn is_even(&self) -> bool { self.divisible_by(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -522,6 +515,11 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as T, 2 as T);\n+    }\n+\n     #[test]\n     pub fn test_signed() {\n         assert_eq!((1 as T).abs(), 1 as T);\n@@ -564,7 +562,7 @@ mod tests {\n         fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n             let (n,d) = nd;\n             let separate_quot_rem = (n / d, n % d);\n-            let combined_quot_rem = n.quot_rem(d);\n+            let combined_quot_rem = n.quot_rem(&d);\n \n             assert_eq!(separate_quot_rem, qr);\n             assert_eq!(combined_quot_rem, qr);\n@@ -588,8 +586,8 @@ mod tests {\n     fn test_div_mod() {\n         fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n             let (n,d) = nd;\n-            let separate_div_mod = (n.div(d), n.modulo(d));\n-            let combined_div_mod = n.div_mod(d);\n+            let separate_div_mod = (n.div(&d), n.modulo(&d));\n+            let combined_div_mod = n.div_mod(&d);\n \n             assert_eq!(separate_div_mod, dm);\n             assert_eq!(combined_div_mod, dm);\n@@ -611,26 +609,26 @@ mod tests {\n \n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(2), 2 as T);\n-        assert_eq!((10 as T).gcd(3), 1 as T);\n-        assert_eq!((0 as T).gcd(3), 3 as T);\n-        assert_eq!((3 as T).gcd(3), 3 as T);\n-        assert_eq!((56 as T).gcd(42), 14 as T);\n-        assert_eq!((3 as T).gcd(-3), 3 as T);\n-        assert_eq!((-6 as T).gcd(3), 3 as T);\n-        assert_eq!((-4 as T).gcd(-2), 2 as T);\n+        assert_eq!((10 as T).gcd(&2), 2 as T);\n+        assert_eq!((10 as T).gcd(&3), 1 as T);\n+        assert_eq!((0 as T).gcd(&3), 3 as T);\n+        assert_eq!((3 as T).gcd(&3), 3 as T);\n+        assert_eq!((56 as T).gcd(&42), 14 as T);\n+        assert_eq!((3 as T).gcd(&-3), 3 as T);\n+        assert_eq!((-6 as T).gcd(&3), 3 as T);\n+        assert_eq!((-4 as T).gcd(&-2), 2 as T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(0), 0 as T);\n-        assert_eq!((0 as T).lcm(1), 0 as T);\n-        assert_eq!((1 as T).lcm(1), 1 as T);\n-        assert_eq!((-1 as T).lcm(1), 1 as T);\n-        assert_eq!((1 as T).lcm(-1), 1 as T);\n-        assert_eq!((-1 as T).lcm(-1), 1 as T);\n-        assert_eq!((8 as T).lcm(9), 72 as T);\n-        assert_eq!((11 as T).lcm(5), 55 as T);\n+        assert_eq!((1 as T).lcm(&0), 0 as T);\n+        assert_eq!((0 as T).lcm(&1), 0 as T);\n+        assert_eq!((1 as T).lcm(&1), 1 as T);\n+        assert_eq!((-1 as T).lcm(&1), 1 as T);\n+        assert_eq!((1 as T).lcm(&-1), 1 as T);\n+        assert_eq!((-1 as T).lcm(&-1), 1 as T);\n+        assert_eq!((8 as T).lcm(&9), 72 as T);\n+        assert_eq!((11 as T).lcm(&5), 55 as T);\n     }\n \n     #[test]"}, {"sha": "e19afdc69c32fb15097a29ed5f1f9731be420681", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 103, "deletions": 50, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -16,9 +16,7 @@ use ops::{Add, Sub, Mul, Neg};\n use Quot = ops::Div;\n #[cfg(stage0)]\n use Rem = ops::Modulo;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n use option::Option;\n use kinds::Copy;\n@@ -33,30 +31,18 @@ pub trait Num: Eq + Zero + One\n              + Quot<Self,Self>\n              + Rem<Self,Self> {}\n \n-impl Num for u8 {}\n-impl Num for u16 {}\n-impl Num for u32 {}\n-impl Num for u64 {}\n-impl Num for uint {}\n-impl Num for i8 {}\n-impl Num for i16 {}\n-impl Num for i32 {}\n-impl Num for i64 {}\n-impl Num for int {}\n-impl Num for f32 {}\n-impl Num for f64 {}\n-impl Num for float {}\n-\n pub trait IntConvertible {\n     fn to_int(&self) -> int;\n     fn from_int(n: int) -> Self;\n }\n \n pub trait Zero {\n+    // FIXME (#5527): These should be associated constants\n     fn zero() -> Self;\n }\n \n pub trait One {\n+    // FIXME (#5527): These should be associated constants\n     fn one() -> Self;\n }\n \n@@ -75,35 +61,115 @@ pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n \n-pub trait Natural: Num\n+pub trait Integer: Num\n                  + Ord\n                  + Quot<Self,Self>\n                  + Rem<Self,Self> {\n-    fn div(&self, other: Self) -> Self;\n-    fn modulo(&self, other: Self) -> Self;\n-    fn div_mod(&self, other: Self) -> (Self,Self);\n-    fn quot_rem(&self, other: Self) -> (Self,Self);\n-\n-    fn gcd(&self, other: Self) -> Self;\n-    fn lcm(&self, other: Self) -> Self;\n-    fn divisible_by(&self, other: Self) -> bool;\n+    fn div(&self, other: &Self) -> Self;\n+    fn modulo(&self, other: &Self) -> Self;\n+    fn div_mod(&self, other: &Self) -> (Self,Self);\n+    fn quot_rem(&self, other: &Self) -> (Self,Self);\n+\n+    fn gcd(&self, other: &Self) -> Self;\n+    fn lcm(&self, other: &Self) -> Self;\n+    fn divisible_by(&self, other: &Self) -> bool;\n     fn is_even(&self) -> bool;\n     fn is_odd(&self) -> bool;\n }\n \n pub trait Round {\n-    fn round(&self, mode: RoundMode) -> Self;\n-\n     fn floor(&self) -> Self;\n-    fn ceil(&self)  -> Self;\n+    fn ceil(&self) -> Self;\n+    fn round(&self) -> Self;\n+    fn trunc(&self) -> Self;\n     fn fract(&self) -> Self;\n }\n \n-pub enum RoundMode {\n-    RoundDown,\n-    RoundUp,\n-    RoundToZero,\n-    RoundFromZero\n+pub trait Fractional: Num\n+                    + Ord\n+                    + Round\n+                    + Quot<Self,Self> {\n+    fn recip(&self) -> Self;\n+}\n+\n+pub trait Real: Signed\n+              + Fractional {\n+    // FIXME (#5527): usages of `int` should be replaced with an associated\n+    // integer type once these are implemented\n+\n+    // Common Constants\n+    // FIXME (#5527): These should be associated constants\n+    fn pi() -> Self;\n+    fn two_pi() -> Self;\n+    fn frac_pi_2() -> Self;\n+    fn frac_pi_3() -> Self;\n+    fn frac_pi_4() -> Self;\n+    fn frac_pi_6() -> Self;\n+    fn frac_pi_8() -> Self;\n+    fn frac_1_pi() -> Self;\n+    fn frac_2_pi() -> Self;\n+    fn frac_2_sqrtpi() -> Self;\n+    fn sqrt2() -> Self;\n+    fn frac_1_sqrt2() -> Self;\n+    fn e() -> Self;\n+    fn log2_e() -> Self;\n+    fn log10_e() -> Self;\n+    fn log_2() -> Self;\n+    fn log_10() -> Self;\n+\n+    // Exponential functions\n+    fn pow(&self, n: Self) -> Self;\n+    fn exp(&self) -> Self;\n+    fn exp2(&self) -> Self;\n+    fn expm1(&self) -> Self;\n+    fn ldexp(&self, n: int) -> Self;\n+    fn log(&self) -> Self;\n+    fn log2(&self) -> Self;\n+    fn log10(&self) -> Self;\n+    fn log_radix(&self) -> Self;\n+    fn ilog_radix(&self) -> int;\n+    fn sqrt(&self) -> Self;\n+    fn rsqrt(&self) -> Self;\n+    fn cbrt(&self) -> Self;\n+\n+    // Angular conversions\n+    fn to_degrees(&self) -> Self;\n+    fn to_radians(&self) -> Self;\n+\n+    // Triganomic functions\n+    fn hypot(&self, other: Self) -> Self;\n+    fn sin(&self) -> Self;\n+    fn cos(&self) -> Self;\n+    fn tan(&self) -> Self;\n+\n+    // Inverse triganomic functions\n+    fn asin(&self) -> Self;\n+    fn acos(&self) -> Self;\n+    fn atan(&self) -> Self;\n+    fn atan2(&self, other: Self) -> Self;\n+\n+    // Hyperbolic triganomic functions\n+    fn sinh(&self) -> Self;\n+    fn cosh(&self) -> Self;\n+    fn tanh(&self) -> Self;\n+}\n+\n+/// Methods that are harder to implement and not commonly used.\n+pub trait RealExt: Real {\n+    // FIXME (#5527): usages of `int` should be replaced with an associated\n+    // integer type once these are implemented\n+\n+    // Gamma functions\n+    fn lgamma(&self) -> (int, Self);\n+    fn tgamma(&self) -> Self;\n+\n+    // Bessel functions\n+    fn j0(&self) -> Self;\n+    fn j1(&self) -> Self;\n+    fn jn(&self, n: int) -> Self;\n+    fn y0(&self) -> Self;\n+    fn y1(&self) -> Self;\n+    fn yn(&self, n: int) -> Self;\n }\n \n /**\n@@ -230,8 +296,9 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n     total\n }\n \n+/// Helper function for testing numeric operations\n #[cfg(stage0,test)]\n-fn test_num<T:Num + NumCast>(ten: T, two: T) {\n+pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),    cast(12));\n     assert_eq!(ten.sub(&two),    cast(8));\n     assert_eq!(ten.mul(&two),    cast(20));\n@@ -247,7 +314,7 @@ fn test_num<T:Num + NumCast>(ten: T, two: T) {\n #[cfg(stage1,test)]\n #[cfg(stage2,test)]\n #[cfg(stage3,test)]\n-fn test_num<T:Num + NumCast>(ten: T, two: T) {\n+pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),  cast(12));\n     assert_eq!(ten.sub(&two),  cast(8));\n     assert_eq!(ten.mul(&two),  cast(20));\n@@ -261,20 +328,6 @@ fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n \n-#[test] fn test_u8_num()    { test_num(10u8,  2u8)  }\n-#[test] fn test_u16_num()   { test_num(10u16, 2u16) }\n-#[test] fn test_u32_num()   { test_num(10u32, 2u32) }\n-#[test] fn test_u64_num()   { test_num(10u64, 2u64) }\n-#[test] fn test_uint_num()  { test_num(10u,   2u)   }\n-#[test] fn test_i8_num()    { test_num(10i8,  2i8)  }\n-#[test] fn test_i16_num()   { test_num(10i16, 2i16) }\n-#[test] fn test_i32_num()   { test_num(10i32, 2i32) }\n-#[test] fn test_i64_num()   { test_num(10i64, 2i64) }\n-#[test] fn test_int_num()   { test_num(10i,   2i)   }\n-#[test] fn test_f32_num()   { test_num(10f32, 2f32) }\n-#[test] fn test_f64_num()   { test_num(10f64, 2f64) }\n-#[test] fn test_float_num() { test_num(10f,   2f)   }\n-\n macro_rules! test_cast_20(\n     ($_20:expr) => ({\n         let _20 = $_20;"}, {"sha": "96019ddd564d60c2c2b9416f99b1a7fcaf0e81dc", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -11,13 +11,9 @@\n use T = self::inst::T;\n use T_SIGNED = self::inst::T_SIGNED;\n \n-use to_str::ToStr;\n use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n-use num::Unsigned;\n-use num;\n-use option::Option;\n use prelude::*;\n \n pub use cmp::{min, max};\n@@ -100,6 +96,8 @@ pub fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n+impl Num for T {}\n+\n #[cfg(notest)]\n impl Ord for T {\n     #[inline(always)]\n@@ -153,10 +151,7 @@ impl Div<T,T> for T {\n     #[inline(always)]\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Quot<T,T> for T {\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n@@ -167,10 +162,7 @@ impl Modulo<T,T> for T {\n     #[inline(always)]\n     fn modulo(&self, other: &T) -> T { *self % *other }\n }\n-\n-#[cfg(stage1,notest)]\n-#[cfg(stage2,notest)]\n-#[cfg(stage3,notest)]\n+#[cfg(not(stage0),notest)]\n impl Rem<T,T> for T {\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }\n@@ -184,32 +176,32 @@ impl Neg<T> for T {\n \n impl Unsigned for T {}\n \n-impl Natural for T {\n+impl Integer for T {\n     /// Unsigned integer division. Returns the same result as `quot` (`/`).\n     #[inline(always)]\n-    fn div(&self, other: T) -> T { *self / other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n \n     /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n     #[inline(always)]\n-    fn modulo(&self, other: T) -> T { *self / other }\n+    fn modulo(&self, other: &T) -> T { *self / *other }\n \n     /// Calculates `div` and `modulo` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn div_mod(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn quot_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n     #[inline(always)]\n-    fn gcd(&self, other: T) -> T {\n+    fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = other;\n+        let mut m = *self, n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;\n@@ -220,17 +212,17 @@ impl Natural for T {\n \n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     #[inline(always)]\n-    fn lcm(&self, other: T) -> T {\n-        (*self * other) / self.gcd(other)\n+    fn lcm(&self, other: &T) -> T {\n+        (*self * *other) / self.gcd(other)\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(2) }\n+    fn is_even(&self) -> bool { self.divisible_by(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -356,23 +348,28 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as T, 2 as T);\n+    }\n+\n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(2), 2 as T);\n-        assert_eq!((10 as T).gcd(3), 1 as T);\n-        assert_eq!((0 as T).gcd(3), 3 as T);\n-        assert_eq!((3 as T).gcd(3), 3 as T);\n-        assert_eq!((56 as T).gcd(42), 14 as T);\n+        assert_eq!((10 as T).gcd(&2), 2 as T);\n+        assert_eq!((10 as T).gcd(&3), 1 as T);\n+        assert_eq!((0 as T).gcd(&3), 3 as T);\n+        assert_eq!((3 as T).gcd(&3), 3 as T);\n+        assert_eq!((56 as T).gcd(&42), 14 as T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(0), 0 as T);\n-        assert_eq!((0 as T).lcm(1), 0 as T);\n-        assert_eq!((1 as T).lcm(1), 1 as T);\n-        assert_eq!((8 as T).lcm(9), 72 as T);\n-        assert_eq!((11 as T).lcm(5), 55 as T);\n-        assert_eq!((99 as T).lcm(17), 1683 as T);\n+        assert_eq!((1 as T).lcm(&0), 0 as T);\n+        assert_eq!((0 as T).lcm(&1), 0 as T);\n+        assert_eq!((1 as T).lcm(&1), 1 as T);\n+        assert_eq!((8 as T).lcm(&9), 72 as T);\n+        assert_eq!((11 as T).lcm(&5), 55 as T);\n+        assert_eq!((99 as T).lcm(&17), 1683 as T);\n     }\n \n     #[test]"}, {"sha": "1aa7aada05c886b481e694b5044a5a06bc036966", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -36,9 +36,7 @@ pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n #[lang=\"quot\"]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n pub trait Quot<RHS,Result> {\n     fn quot(&self, rhs: &RHS) -> Result;\n }\n@@ -49,9 +47,7 @@ pub trait Modulo<RHS,Result> {\n     fn modulo(&self, rhs: &RHS) -> Result;\n }\n #[lang=\"rem\"]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n pub trait Rem<RHS,Result> {\n     fn rem(&self, rhs: &RHS) -> Result;\n }"}, {"sha": "553bb8268102b901a1c0e7ceb91f0ae1bd59e79a", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -16,9 +16,7 @@ pub use either::{Either, Left, Right};\n pub use kinds::{Const, Copy, Owned, Durable};\n #[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};\n@@ -39,7 +37,9 @@ pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n-pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n+pub use num::{Num, NumCast};\n+pub use num::{Signed, Unsigned, Integer};\n+pub use num::{Round, Fractional, Real, RealExt};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "e90f0fb3c81d4216e9e12f4d1fa63fe8fbbdba29", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -118,7 +118,7 @@ pub trait FromBase64 {\n impl FromBase64 for ~[u8] {\n     /**\n      * Convert base64 `u8` vector into u8 byte values.\n-     * Every 4 encoded characters is converted into 3 octets, rem padding.\n+     * Every 4 encoded characters is converted into 3 octets, modulo padding.\n      *\n      * *Example*:\n      *"}, {"sha": "8af1d99fa47196cd663df43a064640e487e82a67", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -204,20 +204,6 @@ impl<T: Copy + Num + Ord>\n /* Utils */\n impl<T: Copy + Num + Ord>\n     Round for Ratio<T> {\n-    fn round(&self, mode: num::RoundMode) -> Ratio<T> {\n-        match mode {\n-            num::RoundUp => { self.ceil() }\n-            num::RoundDown => { self.floor()}\n-            num::RoundToZero => { Ratio::from_integer(self.numer / self.denom) }\n-            num::RoundFromZero => {\n-                if *self < Zero::zero() {\n-                    Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n-                } else {\n-                    Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n-                }\n-            }\n-        }\n-    }\n \n     fn floor(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n@@ -226,13 +212,29 @@ impl<T: Copy + Num + Ord>\n             Ratio::from_integer(self.numer / self.denom)\n         }\n     }\n+\n     fn ceil(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n             Ratio::from_integer(self.numer / self.denom)\n         } else {\n             Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n         }\n     }\n+\n+    #[inline(always)]\n+    fn round(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+        } else {\n+            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn trunc(&self) -> Ratio<T> {\n+        Ratio::from_integer(self.numer / self.denom)\n+    }\n+\n     fn fract(&self) -> Ratio<T> {\n         Ratio::new_raw(self.numer % self.denom, self.denom)\n     }\n@@ -421,18 +423,18 @@ mod test {\n     fn test_round() {\n         assert_eq!(_1_2.ceil(), _1);\n         assert_eq!(_1_2.floor(), _0);\n-        assert_eq!(_1_2.round(num::RoundToZero), _0);\n-        assert_eq!(_1_2.round(num::RoundFromZero), _1);\n+        assert_eq!(_1_2.round(), _1);\n+        assert_eq!(_1_2.trunc(), _0);\n \n         assert_eq!(_neg1_2.ceil(), _0);\n         assert_eq!(_neg1_2.floor(), -_1);\n-        assert_eq!(_neg1_2.round(num::RoundToZero), _0);\n-        assert_eq!(_neg1_2.round(num::RoundFromZero), -_1);\n+        assert_eq!(_neg1_2.round(), -_1);\n+        assert_eq!(_neg1_2.trunc(), _0);\n \n         assert_eq!(_1.ceil(), _1);\n         assert_eq!(_1.floor(), _1);\n-        assert_eq!(_1.round(num::RoundToZero), _1);\n-        assert_eq!(_1.round(num::RoundFromZero), _1);\n+        assert_eq!(_1.round(), _1);\n+        assert_eq!(_1.trunc(), _1);\n     }\n \n     #[test]"}, {"sha": "07c679409cf68570c2402024f51174e2657863fd", "filename": "src/libstd/std.rc", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac69ee418b495a25ff5019d2fd08ff97a4cb34e3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=ac69ee418b495a25ff5019d2fd08ff97a4cb34e3", "patch": "@@ -76,9 +76,7 @@ pub mod rope;\n pub mod smallintmap;\n pub mod sort;\n pub mod dlist;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n pub mod treemap;\n \n // And ... other stuff\n@@ -98,19 +96,13 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n #[path=\"num/bigint.rs\"]\n pub mod bigint;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n #[path=\"num/rational.rs\"]\n pub mod rational;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n+#[cfg(not(stage0))]\n #[path=\"num/complex.rs\"]\n pub mod complex;\n pub mod stats;"}]}