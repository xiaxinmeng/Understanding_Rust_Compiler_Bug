{"sha": "c8a93efdae48b88bf594480705a5c0aac39c75e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTkzZWZkYWU0OGI4OGJmNTk0NDgwNzA1YTVjMGFhYzM5Yzc1ZTE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T19:04:40Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T19:04:40Z"}, "message": "Merge remote-tracking branch 'remotes/origin/master' into cleanup-iterators", "tree": {"sha": "07b97a6ad0d382272a978018c71c5220cece8237", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b97a6ad0d382272a978018c71c5220cece8237"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a93efdae48b88bf594480705a5c0aac39c75e1", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a93efdae48b88bf594480705a5c0aac39c75e1", "html_url": "https://github.com/rust-lang/rust/commit/c8a93efdae48b88bf594480705a5c0aac39c75e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a93efdae48b88bf594480705a5c0aac39c75e1/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b2c1c543fb7e2201ff2c7c579fafef670b149e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2c1c543fb7e2201ff2c7c579fafef670b149e0", "html_url": "https://github.com/rust-lang/rust/commit/5b2c1c543fb7e2201ff2c7c579fafef670b149e0"}, {"sha": "2ba36ec62934c8b877766a6283633b6407c8d357", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba36ec62934c8b877766a6283633b6407c8d357", "html_url": "https://github.com/rust-lang/rust/commit/2ba36ec62934c8b877766a6283633b6407c8d357"}], "stats": {"total": 285, "additions": 268, "deletions": 17}, "files": [{"sha": "756a5c7da006594a0efcec42dcdaf2ffe83c21e0", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -72,6 +72,12 @@ impl WaitQueue {\n         }\n         count\n     }\n+\n+    fn wait_end(&self) -> WaitEnd {\n+        let (wait_end, signal_end) = comm::oneshot();\n+        self.tail.send_deferred(signal_end);\n+        wait_end\n+    }\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n@@ -100,12 +106,9 @@ impl<Q:Send> Sem<Q> {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n-                    // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = comm::oneshot();\n-                    // Tell outer scope we need to block.\n-                    waiter_nobe = Some(WaitEnd);\n-                    // Enqueue ourself.\n-                    state.waiters.tail.send_deferred(SignalEnd);\n+                    // Create waiter nobe, enqueue ourself, and tell\n+                    // outer scope we need to block.\n+                    waiter_nobe = Some(state.waiters.wait_end());\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -201,10 +204,7 @@ impl<'self> Condvar<'self> {\n      * wait() is equivalent to wait_on(0).\n      */\n     pub fn wait_on(&self, condvar_id: uint) {\n-        // Create waiter nobe.\n-        let (WaitEnd, SignalEnd) = comm::oneshot();\n-        let mut WaitEnd   = Some(WaitEnd);\n-        let mut SignalEnd = Some(SignalEnd);\n+        let mut WaitEnd = None;\n         let mut out_of_bounds = None;\n         do task::unkillable {\n             // Release lock, 'atomically' enqueuing ourselves in so doing.\n@@ -216,9 +216,9 @@ impl<'self> Condvar<'self> {\n                         if state.count <= 0 {\n                             state.waiters.signal();\n                         }\n-                        // Enqueue ourself to be woken up by a signaller.\n-                        let SignalEnd = SignalEnd.take_unwrap();\n-                        state.blocked[condvar_id].tail.send_deferred(SignalEnd);\n+                        // Create waiter nobe, and enqueue ourself to\n+                        // be woken up by a signaller.\n+                        WaitEnd = Some(state.blocked[condvar_id].wait_end());\n                     } else {\n                         out_of_bounds = Some(state.blocked.len());\n                     }"}, {"sha": "5801e43a54cd2ba0bfd7d02757a35909b18ee931", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -1553,6 +1553,8 @@ pub mod llvm {\n         /* Selected entries from the downcasts. */\n         #[fast_ffi]\n         pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n+        pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n \n         /** Writes a module to the specified path. Returns 0 on success. */\n         #[fast_ffi]"}, {"sha": "762f6953bb2228aede51fac529c16359ad1db826", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -59,6 +59,7 @@ use middle::trans::monomorphize;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n+use middle::trans::value::Value;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n@@ -1792,11 +1793,30 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n // Builds the return block for a function.\n pub fn build_return_block(fcx: &FunctionContext, ret_cx: @mut Block) {\n     // Return the value if this function immediate; otherwise, return void.\n-    if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n-        Ret(ret_cx, Load(ret_cx, fcx.llretptr.unwrap()))\n-    } else {\n-        RetVoid(ret_cx)\n+    if fcx.llretptr.is_none() || !fcx.has_immediate_return_value {\n+        return RetVoid(ret_cx);\n     }\n+\n+    let retptr = Value(fcx.llretptr.unwrap());\n+    let retval = match retptr.get_dominating_store(ret_cx) {\n+        // If there's only a single store to the ret slot, we can directly return\n+        // the value that was stored and omit the store and the alloca\n+        Some(s) => {\n+            let retval = *s.get_operand(0).unwrap();\n+            s.erase_from_parent();\n+\n+            if retptr.has_no_uses() {\n+                retptr.erase_from_parent();\n+            }\n+\n+            retval\n+        }\n+        // Otherwise, load the return value from the ret slot\n+        None => Load(ret_cx, fcx.llretptr.unwrap())\n+    };\n+\n+\n+    Ret(ret_cx, retval);\n }\n \n pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }"}, {"sha": "8ca18d81245e9ccfacc853dff039b8e422dbfa7c", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lib::llvm::{llvm, BasicBlockRef};\n+use middle::trans::value::{UserIterator, Value};\n+use std::iterator::{Filter, Map};\n+\n+pub struct BasicBlock(BasicBlockRef);\n+\n+pub type PredIterator<'self> = Map<'self, Value, BasicBlock, Filter<'self, Value, UserIterator>>;\n+\n+/**\n+ * Wrapper for LLVM BasicBlockRef\n+ */\n+impl BasicBlock {\n+    pub fn as_value(self) -> Value {\n+        unsafe {\n+            Value(llvm::LLVMBasicBlockAsValue(*self))\n+        }\n+    }\n+\n+    pub fn pred_iter(self) -> PredIterator {\n+        self.as_value().user_iter()\n+            .filter(|user| user.is_a_terminator_inst())\n+            .map(|user| user.get_parent().unwrap())\n+    }\n+\n+    pub fn get_single_predecessor(self) -> Option<BasicBlock> {\n+        let mut iter = self.pred_iter();\n+        match (iter.next(), iter.next()) {\n+            (Some(first), None) => Some(first),\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "387a8ecc5eec60a6d39392bc4784b5104618281d", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -42,3 +42,5 @@ pub mod machine;\n pub mod adt;\n pub mod asm;\n pub mod type_;\n+pub mod value;\n+pub mod basic_block;"}, {"sha": "08b2db6eff9bc212e129c6e7c6e495fb3093301e", "filename": "src/librustc/middle/trans/value.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use lib::llvm::{llvm, UseRef, ValueRef};\n+use middle::trans::basic_block::BasicBlock;\n+use middle::trans::common::Block;\n+use std::libc::c_uint;\n+\n+pub struct Value(ValueRef);\n+\n+macro_rules! opt_val ( ($e:expr) => (\n+    unsafe {\n+        match $e {\n+            p if p.is_not_null() => Some(Value(p)),\n+            _ => None\n+        }\n+    }\n+))\n+\n+/**\n+ * Wrapper for LLVM ValueRef\n+ */\n+impl Value {\n+    /// Returns the BasicBlock that contains this value\n+    pub fn get_parent(self) -> Option<BasicBlock> {\n+        unsafe {\n+            match llvm::LLVMGetInstructionParent(*self) {\n+                p if p.is_not_null() => Some(BasicBlock(p)),\n+                _ => None\n+            }\n+        }\n+    }\n+\n+    /// Removes this value from its containing BasicBlock\n+    pub fn erase_from_parent(self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(*self);\n+        }\n+    }\n+\n+    /// Returns the single dominating store to this value, if any\n+    /// This only performs a search for a trivially dominating store. The store\n+    /// must be the only user of this value, and there must not be any conditional\n+    /// branches between the store and the given block.\n+    pub fn get_dominating_store(self, bcx: @mut Block) -> Option<Value> {\n+        match self.get_single_user().chain(|user| user.as_store_inst()) {\n+            Some(store) => {\n+                do store.get_parent().chain |store_bb| {\n+                    let mut bb = BasicBlock(bcx.llbb);\n+                    let mut ret = Some(store);\n+                    while *bb != *store_bb {\n+                        match bb.get_single_predecessor() {\n+                            Some(pred) => bb = pred,\n+                            None => { ret = None; break }\n+                        }\n+                    }\n+                    ret\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns the first use of this value, if any\n+    pub fn get_first_use(self) -> Option<Use> {\n+        unsafe {\n+            match llvm::LLVMGetFirstUse(*self) {\n+                u if u.is_not_null() => Some(Use(u)),\n+                _ => None\n+            }\n+        }\n+    }\n+\n+    /// Tests if there are no uses of this value\n+    pub fn has_no_uses(self) -> bool {\n+        self.get_first_use().is_none()\n+    }\n+\n+    /// Returns the single user of this value\n+    /// If there are no users or multiple users, this returns None\n+    pub fn get_single_user(self) -> Option<Value> {\n+        let mut iter = self.user_iter();\n+        match (iter.next(), iter.next()) {\n+            (Some(first), None) => Some(first),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns an iterator for the users of this value\n+    pub fn user_iter(self) -> UserIterator {\n+        UserIterator {\n+            next: self.get_first_use()\n+        }\n+    }\n+\n+    /// Returns the requested operand of this instruction\n+    /// Returns None, if there's no operand at the given index\n+    pub fn get_operand(self, i: uint) -> Option<Value> {\n+        opt_val!(llvm::LLVMGetOperand(*self, i as c_uint))\n+    }\n+\n+    /// Returns the Store represent by this value, if any\n+    pub fn as_store_inst(self) -> Option<Value> {\n+        opt_val!(llvm::LLVMIsAStoreInst(*self))\n+    }\n+\n+    /// Tests if this value is a terminator instruction\n+    pub fn is_a_terminator_inst(self) -> bool {\n+        unsafe {\n+            llvm::LLVMIsATerminatorInst(*self).is_not_null()\n+        }\n+    }\n+}\n+\n+pub struct Use(UseRef);\n+\n+/**\n+ * Wrapper for LLVM UseRef\n+ */\n+impl Use {\n+    pub fn get_user(self) -> Value {\n+        unsafe {\n+            Value(llvm::LLVMGetUser(*self))\n+        }\n+    }\n+\n+    pub fn get_next_use(self) -> Option<Use> {\n+        unsafe {\n+            match llvm::LLVMGetNextUse(*self) {\n+                u if u.is_not_null() => Some(Use(u)),\n+                _ => None\n+            }\n+        }\n+    }\n+}\n+\n+/// Iterator for the users of a value\n+pub struct UserIterator {\n+    priv next: Option<Use>\n+}\n+\n+impl Iterator<Value> for UserIterator {\n+    fn next(&mut self) -> Option<Value> {\n+        let current = self.next;\n+\n+        self.next = do current.chain |u| { u.get_next_use() };\n+\n+        do current.map |u| { u.get_user() }\n+    }\n+}"}, {"sha": "97d80d3950fbb5c26dd53bab4113f1958ff2b59b", "filename": "src/test/codegen/single-return-value.cc", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Ftest%2Fcodegen%2Fsingle-return-value.cc", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Ftest%2Fcodegen%2Fsingle-return-value.cc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsingle-return-value.cc?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"C\"\n+int test() {\n+  return 5;\n+}"}, {"sha": "e6eb9a2be72cbc6a77a93923c6bb23725388941d", "filename": "src/test/codegen/single-return-value.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a93efdae48b88bf594480705a5c0aac39c75e1/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs?ref=c8a93efdae48b88bf594480705a5c0aac39c75e1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_mangle]\n+fn test() -> int {\n+    5\n+}"}]}