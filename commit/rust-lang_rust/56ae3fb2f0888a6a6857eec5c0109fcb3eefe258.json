{"sha": "56ae3fb2f0888a6a6857eec5c0109fcb3eefe258", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2YWUzZmIyZjA4ODhhNmE2ODU3ZWVjNWMwMTA5ZmNiM2VlZmUyNTg=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-02-21T06:26:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-21T06:26:40Z"}, "message": "Rollup merge of #81706 - SkiFire13:document-binaryheap-unsafe, r=Mark-Simulacrum\n\nDocument BinaryHeap unsafe functions\n\n`BinaryHeap` contains some private safe functions but that are actually unsafe to call. This PR marks them `unsafe` and documents all the `unsafe` function calls inside them.\n\nWhile doing this I might also have found a bug: some \"SAFETY\" comments in `sift_down_range` and `sift_down_to_bottom` are valid only if you assume that `child` doesn't overflow. However it may overflow if `end > isize::MAX` which can be true for ZSTs (but I think only for them). I guess the easiest fix would be to skip any sifting if `mem::size_of::<T> == 0`.\n\nProbably conflicts with #81127 but solving the eventual merge conflict should be pretty easy.", "tree": {"sha": "803e55be0e99dad3de5c5eb9e359203c2a93a8f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/803e55be0e99dad3de5c5eb9e359203c2a93a8f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMf0gCRBK7hj4Ov3rIwAAdHIIAG0FHCO1JzE2HE31zLLLsI+e\nGtTXmdfq15wAC3PJ66LyExD5oebJEkygvesFyblMSyGCqYAIsSMDjxnf+njeYkjT\n8mdC8ORvP1dEsgtr3rBvyg6p/TcVmJ8eRQRaMIo7AbKX2VAXbwBAvWVR0/C0niJ6\nWzlSS9ijnNx9r2Qs9DMv49TSQVpOspf7bC34Oosn4qWuvf8QsJ/Rog7PimN425Od\n9ZhD4aiYj0DZi611MvInz3DFVCMsAfb2wfHhK68Ym8i2TiFqhycquGw6cvvCs5aB\nZN5Fs3BsBNcGZektHA8mvpUghNj5d7vByg9D2q5sxRyDZ8VBBtll0co2GUanNuA=\n=GFEF\n-----END PGP SIGNATURE-----\n", "payload": "tree 803e55be0e99dad3de5c5eb9e359203c2a93a8f7\nparent 3219a100fab579015d56411f5a50dcb7ff10f39d\nparent 3ec1a28418472d64518efcb72e25ff976d6ff140\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1613888800 +0900\ncommitter GitHub <noreply@github.com> 1613888800 +0900\n\nRollup merge of #81706 - SkiFire13:document-binaryheap-unsafe, r=Mark-Simulacrum\n\nDocument BinaryHeap unsafe functions\n\n`BinaryHeap` contains some private safe functions but that are actually unsafe to call. This PR marks them `unsafe` and documents all the `unsafe` function calls inside them.\n\nWhile doing this I might also have found a bug: some \"SAFETY\" comments in `sift_down_range` and `sift_down_to_bottom` are valid only if you assume that `child` doesn't overflow. However it may overflow if `end > isize::MAX` which can be true for ZSTs (but I think only for them). I guess the easiest fix would be to skip any sifting if `mem::size_of::<T> == 0`.\n\nProbably conflicts with #81127 but solving the eventual merge conflict should be pretty easy.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258", "html_url": "https://github.com/rust-lang/rust/commit/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3219a100fab579015d56411f5a50dcb7ff10f39d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3219a100fab579015d56411f5a50dcb7ff10f39d", "html_url": "https://github.com/rust-lang/rust/commit/3219a100fab579015d56411f5a50dcb7ff10f39d"}, {"sha": "3ec1a28418472d64518efcb72e25ff976d6ff140", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec1a28418472d64518efcb72e25ff976d6ff140", "html_url": "https://github.com/rust-lang/rust/commit/3ec1a28418472d64518efcb72e25ff976d6ff140"}], "stats": {"total": 166, "additions": 117, "deletions": 49}, "files": [{"sha": "33bd98d467ceca291326b69526b9a766853333d0", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 117, "deletions": 49, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ae3fb2f0888a6a6857eec5c0109fcb3eefe258/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=56ae3fb2f0888a6a6857eec5c0109fcb3eefe258", "patch": "@@ -275,7 +275,8 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n         if self.sift {\n-            self.heap.sift_down(0);\n+            // SAFETY: PeekMut is only instantiated for non-empty heaps.\n+            unsafe { self.heap.sift_down(0) };\n         }\n     }\n }\n@@ -431,7 +432,8 @@ impl<T: Ord> BinaryHeap<T> {\n         self.data.pop().map(|mut item| {\n             if !self.is_empty() {\n                 swap(&mut item, &mut self.data[0]);\n-                self.sift_down_to_bottom(0);\n+                // SAFETY: !self.is_empty() means that self.len() > 0\n+                unsafe { self.sift_down_to_bottom(0) };\n             }\n             item\n         })\n@@ -473,7 +475,9 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n         self.data.push(item);\n-        self.sift_up(0, old_len);\n+        // SAFETY: Since we pushed a new item it means that\n+        //  old_len = self.len() - 1 < self.len()\n+        unsafe { self.sift_up(0, old_len) };\n     }\n \n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n@@ -506,7 +510,10 @@ impl<T: Ord> BinaryHeap<T> {\n                 let ptr = self.data.as_mut_ptr();\n                 ptr::swap(ptr, ptr.add(end));\n             }\n-            self.sift_down_range(0, end);\n+            // SAFETY: `end` goes from `self.len() - 1` to 1 (both included) so:\n+            //  0 < 1 <= end <= self.len() - 1 < self.len()\n+            //  Which means 0 < end and end < self.len().\n+            unsafe { self.sift_down_range(0, end) };\n         }\n         self.into_vec()\n     }\n@@ -519,78 +526,139 @@ impl<T: Ord> BinaryHeap<T> {\n     // the hole is filled back at the end of its scope, even on panic.\n     // Using a hole reduces the constant factor compared to using swaps,\n     // which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() > start {\n-                let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) {\n-                    break;\n-                }\n-                hole.move_to(parent);\n+\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n+        // Take out the value at `pos` and create a hole.\n+        // SAFETY: The caller guarantees that pos < self.len()\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+\n+        while hole.pos() > start {\n+            let parent = (hole.pos() - 1) / 2;\n+\n+            // SAFETY: hole.pos() > start >= 0, which means hole.pos() > 0\n+            //  and so hole.pos() - 1 can't underflow.\n+            //  This guarantees that parent < hole.pos() so\n+            //  it's a valid index and also != hole.pos().\n+            if hole.element() <= unsafe { hole.get(parent) } {\n+                break;\n             }\n-            hole.pos()\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(parent) };\n         }\n+\n+        hole.pos()\n     }\n \n     /// Take an element at `pos` and move it down the heap,\n     /// while its children are larger.\n-    fn sift_down_range(&mut self, pos: usize, end: usize) {\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                // compare with the greater of the two children\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                // if we are already in order, stop.\n-                if hole.element() >= hole.get(child) {\n-                    return;\n-                }\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 && hole.element() < hole.get(child) {\n-                hole.move_to(child);\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < end <= self.len()`.\n+    unsafe fn sift_down_range(&mut self, pos: usize, end: usize) {\n+        // SAFETY: The caller guarantees that pos < end <= self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // compare with the greater of the two children\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n+            //  if T is a ZST\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // if we are already in order, stop.\n+            // SAFETY: child is now either the old child or the old child+1\n+            //  We already proven that both are < self.len() and != hole.pos()\n+            if hole.element() >= unsafe { hole.get(child) } {\n+                return;\n             }\n+\n+            // SAFETY: same as above.\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n+        }\n+\n+        // SAFETY: && short circuit, which means that in the\n+        //  second condition it's already true that child == end - 1 < self.len().\n+        if child == end - 1 && hole.element() < unsafe { hole.get(child) } {\n+            // SAFETY: child is already proven to be a valid index and\n+            //  child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n         }\n     }\n \n-    fn sift_down(&mut self, pos: usize) {\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down(&mut self, pos: usize) {\n         let len = self.len();\n-        self.sift_down_range(pos, len);\n+        // SAFETY: pos < len is guaranteed by the caller and\n+        //  obviously len = self.len() <= self.len().\n+        unsafe { self.sift_down_range(pos, len) };\n     }\n \n     /// Take an element at `pos` and move it all the way down the heap,\n     /// then sift it up to its position.\n     ///\n     /// Note: This is faster when the element is known to be large / should\n     /// be closer to the bottom.\n-    fn sift_down_to_bottom(&mut self, mut pos: usize) {\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must guarantee that `pos < self.len()`.\n+    unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {\n         let end = self.len();\n         let start = pos;\n-        unsafe {\n-            let mut hole = Hole::new(&mut self.data, pos);\n-            let mut child = 2 * pos + 1;\n-            while child < end - 1 {\n-                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n-                hole.move_to(child);\n-                child = 2 * hole.pos() + 1;\n-            }\n-            if child == end - 1 {\n-                hole.move_to(child);\n-            }\n-            pos = hole.pos;\n+\n+        // SAFETY: The caller guarantees that pos < self.len().\n+        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n+        let mut child = 2 * hole.pos() + 1;\n+\n+        // Loop invariant: child == 2 * hole.pos() + 1.\n+        while child < end - 1 {\n+            // SAFETY: child < end - 1 < self.len() and\n+            //  child + 1 < end <= self.len(), so they're valid indexes.\n+            //  child == 2 * hole.pos() + 1 != hole.pos() and\n+            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n+            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n+            //  if T is a ZST\n+            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n+\n+            // SAFETY: Same as above\n+            unsafe { hole.move_to(child) };\n+            child = 2 * hole.pos() + 1;\n         }\n-        self.sift_up(start, pos);\n+\n+        if child == end - 1 {\n+            // SAFETY: child == end - 1 < self.len(), so it's a valid index\n+            //  and child == 2 * hole.pos() + 1 != hole.pos().\n+            unsafe { hole.move_to(child) };\n+        }\n+        pos = hole.pos();\n+        drop(hole);\n+\n+        // SAFETY: pos is the position in the hole and was already proven\n+        //  to be a valid index.\n+        unsafe { self.sift_up(start, pos) };\n     }\n \n     fn rebuild(&mut self) {\n         let mut n = self.len() / 2;\n         while n > 0 {\n             n -= 1;\n-            self.sift_down(n);\n+            // SAFETY: n starts from self.len() / 2 and goes down to 0.\n+            //  The only case when !(n < self.len()) is if\n+            //  self.len() == 0, but it's ruled out by the loop condition.\n+            unsafe { self.sift_down(n) };\n         }\n     }\n "}]}