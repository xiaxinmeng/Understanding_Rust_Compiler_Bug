{"sha": "cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTAwNTE2MmQxZDdhZWE2Y2ZmZGMyOTlmZWRmMGQyYmIyYTRiMjg=", "commit": {"author": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-05-24T02:25:49Z"}, "committer": {"name": "Geoffrey Thomas", "email": "geofft@ldpreload.com", "date": "2015-06-22T04:55:42Z"}, "message": "sys/unix/process: Reset signal behavior before exec\n\nMake sure that child processes don't get affected by libstd's desire to\nignore SIGPIPE, nor a third-party library's signal mask (which is needed\nto use either a signal-handling thread correctly or to use signalfd /\nkqueue correctly).", "tree": {"sha": "beba0171790854155ccf90befb60926f8581f70b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beba0171790854155ccf90befb60926f8581f70b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "html_url": "https://github.com/rust-lang/rust/commit/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/comments", "author": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "committer": {"login": "geofft", "id": 74644, "node_id": "MDQ6VXNlcjc0NjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/74644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geofft", "html_url": "https://github.com/geofft", "followers_url": "https://api.github.com/users/geofft/followers", "following_url": "https://api.github.com/users/geofft/following{/other_user}", "gists_url": "https://api.github.com/users/geofft/gists{/gist_id}", "starred_url": "https://api.github.com/users/geofft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geofft/subscriptions", "organizations_url": "https://api.github.com/users/geofft/orgs", "repos_url": "https://api.github.com/users/geofft/repos", "events_url": "https://api.github.com/users/geofft/events{/privacy}", "received_events_url": "https://api.github.com/users/geofft/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b", "html_url": "https://github.com/rust-lang/rust/commit/56d904c4bb4a10e6da3f03d11279e9a3f3d20d8b"}], "stats": {"total": 126, "additions": 124, "deletions": 2}, "files": [{"sha": "431312b3d8fecd8b7224560b0b4cd030ad597e63", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "patch": "@@ -25,7 +25,7 @@\n #![allow(non_camel_case_types)]\n \n pub use self::signal_os::{sigaction, siginfo, sigset_t, sigaltstack};\n-pub use self::signal_os::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIGSTKSZ};\n+pub use self::signal_os::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIGSTKSZ, SIG_SETMASK};\n \n use libc;\n \n@@ -112,6 +112,7 @@ pub struct passwd {\n pub type sighandler_t = *mut libc::c_void;\n \n pub const SIG_DFL: sighandler_t = 0 as sighandler_t;\n+pub const SIG_ERR: sighandler_t = !0 as sighandler_t;\n \n extern {\n     pub fn getsockopt(sockfd: libc::c_int,\n@@ -135,6 +136,8 @@ extern {\n                        oss: *mut sigaltstack) -> libc::c_int;\n \n     pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n+    pub fn pthread_sigmask(how: libc::c_int, set: *const sigset_t,\n+                           oldset: *mut sigset_t) -> libc::c_int;\n \n     #[cfg(not(target_os = \"ios\"))]\n     pub fn getpwuid_r(uid: libc::uid_t,\n@@ -155,7 +158,7 @@ extern {\n #[cfg(any(target_os = \"linux\",\n           target_os = \"android\"))]\n mod signal_os {\n-    pub use self::arch::{SA_ONSTACK, SA_SIGINFO, SIGBUS,\n+    pub use self::arch::{SA_ONSTACK, SA_SIGINFO, SIGBUS, SIG_SETMASK,\n                          sigaction, sigaltstack};\n     use libc;\n \n@@ -216,6 +219,8 @@ mod signal_os {\n \n         pub const SIGBUS: libc::c_int = 7;\n \n+        pub const SIG_SETMASK: libc::c_int = 2;\n+\n         #[cfg(target_os = \"linux\")]\n         #[repr(C)]\n         pub struct sigaction {\n@@ -263,6 +268,8 @@ mod signal_os {\n \n         pub const SIGBUS: libc::c_int = 10;\n \n+        pub const SIG_SETMASK: libc::c_int = 3;\n+\n         #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n         #[repr(C)]\n         pub struct sigaction {\n@@ -321,6 +328,8 @@ mod signal_os {\n     #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n     pub const SIGSTKSZ: libc::size_t = 40960;\n \n+    pub const SIG_SETMASK: libc::c_int = 3;\n+\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\"))]\n     pub type sigset_t = u32;"}, {"sha": "85ce8d798801f6434c478cb3457e1c5132429eee", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "patch": "@@ -17,6 +17,7 @@ use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n+use mem;\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n@@ -313,6 +314,23 @@ impl Process {\n         if !envp.is_null() {\n             *sys::os::environ() = envp as *const _;\n         }\n+\n+        // Reset signal handling so the child process starts in a\n+        // standardized state. libstd ignores SIGPIPE, and signal-handling\n+        // libraries often set a mask. Child processes inherit ignored\n+        // signals and the signal mask from their parent, but most\n+        // UNIX programs do not reset these things on their own, so we\n+        // need to clean things up now to avoid confusing the program\n+        // we're about to run.\n+        let mut set: c::sigset_t = mem::uninitialized();\n+        if c::sigemptyset(&mut set) != 0 ||\n+           c::pthread_sigmask(c::SIG_SETMASK, &set, ptr::null_mut()) != 0 ||\n+           libc::funcs::posix01::signal::signal(\n+               libc::SIGPIPE, mem::transmute(c::SIG_DFL)\n+           ) == mem::transmute(c::SIG_ERR) {\n+            fail(&mut output);\n+        }\n+\n         let _ = libc::execvp(*argv, argv);\n         fail(&mut output)\n     }\n@@ -418,3 +436,59 @@ fn translate_status(status: c_int) -> ExitStatus {\n         ExitStatus::Signal(imp::WTERMSIG(status))\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::v1::*;\n+\n+    use ffi::OsStr;\n+    use mem;\n+    use ptr;\n+    use libc;\n+    use sys::{self, c, cvt, pipe};\n+\n+    extern {\n+        fn sigaddset(set: *mut c::sigset_t, signum: libc::c_int) -> libc::c_int;\n+    }\n+\n+    #[test]\n+    fn test_process_mask() {\n+        unsafe {\n+            // Test to make sure that a signal mask does not get inherited.\n+            let cmd = Command::new(OsStr::new(\"cat\"));\n+            let (stdin_read, stdin_write) = sys::pipe::anon_pipe().unwrap();\n+            let (stdout_read, stdout_write) = sys::pipe::anon_pipe().unwrap();\n+\n+            let mut set: c::sigset_t = mem::uninitialized();\n+            let mut old_set: c::sigset_t = mem::uninitialized();\n+            cvt(c::sigemptyset(&mut set)).unwrap();\n+            cvt(sigaddset(&mut set, libc::SIGINT)).unwrap();\n+            cvt(c::pthread_sigmask(c::SIG_SETMASK, &set, &mut old_set)).unwrap();\n+\n+            let cat = Process::spawn(&cmd, Stdio::Raw(stdin_read.raw()),\n+                                           Stdio::Raw(stdout_write.raw()),\n+                                           Stdio::None).unwrap();\n+            drop(stdin_read);\n+            drop(stdout_write);\n+\n+            cvt(c::pthread_sigmask(c::SIG_SETMASK, &old_set, ptr::null_mut())).unwrap();\n+\n+            cvt(libc::funcs::posix88::signal::kill(cat.id() as libc::pid_t, libc::SIGINT)).unwrap();\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Either EOF or failure (EPIPE) is okay.\n+            let mut buf = [0; 5];\n+            if let Ok(ret) = stdout_read.read(&mut buf) {\n+                assert!(ret == 0);\n+            }\n+\n+            cat.wait().unwrap();\n+        }\n+    }\n+}"}, {"sha": "5bff4fa080a34d2aa4f2220807342ea06b6edf91", "filename": "src/test/run-pass/process-sigpipe.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae005162d1d7aea6cffdc299fedf0d2bb2a4b28/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-sigpipe.rs?ref=cae005162d1d7aea6cffdc299fedf0d2bb2a4b28", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android since the dynamic linker sets a SIGPIPE handler (to do\n+// a crash report) so inheritance is moot on the entire platform\n+\n+// libstd ignores SIGPIPE, and other libraries may set signal masks.\n+// Make sure that these behaviors don't get inherited to children\n+// spawned via std::process, since they're needed for traditional UNIX\n+// filter behavior. This test checks that `yes | head` terminates\n+// (instead of running forever), and that it does not print an error\n+// message about a broken pipe.\n+\n+use std::process;\n+use std::thread;\n+\n+#[cfg(unix)]\n+fn main() {\n+    // Just in case `yes` doesn't check for EPIPE...\n+    thread::spawn(|| {\n+        thread::sleep_ms(5000);\n+        process::exit(1);\n+    });\n+    let output = process::Command::new(\"sh\").arg(\"-c\").arg(\"yes | head\").output().unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.len() == 0);\n+}\n+\n+#[cfg(not(unix))]\n+fn main() {\n+    // Not worried about signal masks on other platforms\n+}"}]}