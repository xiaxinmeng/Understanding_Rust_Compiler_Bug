{"sha": "a3f74702d94b393d2f37bcda0fdfd6213fad460b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZjc0NzAyZDk0YjM5M2QyZjM3YmNkYTBmZGZkNjIxM2ZhZDQ2MGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:33:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T15:33:19Z"}, "message": "move tests", "tree": {"sha": "642e1b05bd78e0518d26fab2c8907373ef6ee6cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/642e1b05bd78e0518d26fab2c8907373ef6ee6cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3f74702d94b393d2f37bcda0fdfd6213fad460b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f74702d94b393d2f37bcda0fdfd6213fad460b", "html_url": "https://github.com/rust-lang/rust/commit/a3f74702d94b393d2f37bcda0fdfd6213fad460b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3f74702d94b393d2f37bcda0fdfd6213fad460b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "256ec6e8d4ac46b2569713d2ffe92d102595f5d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/256ec6e8d4ac46b2569713d2ffe92d102595f5d2", "html_url": "https://github.com/rust-lang/rust/commit/256ec6e8d4ac46b2569713d2ffe92d102595f5d2"}], "stats": {"total": 510, "additions": 250, "deletions": 260}, "files": [{"sha": "2fcd03c9be8d8142d926af1b46c64796402048b7", "filename": "crates/ra_analysis/src/call_info.rs", "status": "modified", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/a3f74702d94b393d2f37bcda0fdfd6213fad460b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f74702d94b393d2f37bcda0fdfd6213fad460b/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs?ref=a3f74702d94b393d2f37bcda0fdfd6213fad460b", "patch": "@@ -128,3 +128,252 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use crate::mock_analysis::single_file_with_position;\n+\n+    fn call_info(text: &str) -> CallInfo {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.call_info(position).unwrap().unwrap()\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_first() {\n+        let info = call_info(\n+            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n+        assert_eq!(info.active_parameter, Some(0));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_two_args_second() {\n+        let info = call_info(\n+            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_impl() {\n+        let info = call_info(\n+            r#\"struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, Vec::<String>::new());\n+        assert_eq!(info.active_parameter, None);\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_self() {\n+        let info = call_info(\n+            r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"&self\".to_string()]);\n+        assert_eq!(info.active_parameter, None);\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_for_method_with_arg() {\n+        let info = call_info(\n+            r#\"struct F;\n+impl F {\n+    pub fn new() -> F{\n+        F{}\n+    }\n+\n+    pub fn do_it(&self, x: i32) {}\n+}\n+\n+fn bar() {\n+    let f : F = F::new();\n+    f.do_it(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"&self\".to_string(), \"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_simple() {\n+        let info = call_info(\n+            r#\"\n+/// test\n+// non-doc-comment\n+fn foo(j: u32) -> u32 {\n+    j\n+}\n+\n+fn bar() {\n+    let _ = foo(<|>);\n+}\n+\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"j\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"fn foo(j: u32) -> u32\".to_string());\n+        assert_eq!(info.doc, Some(\"test\".into()));\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs() {\n+        let info = call_info(\n+            r#\"\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let five = 5;\n+///\n+/// assert_eq!(6, my_crate::add_one(5));\n+/// ```\n+pub fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+pub fn do() {\n+    add_one(<|>\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Adds one to the number given.\n+\n+# Examples\n+\n+```rust\n+let five = 5;\n+\n+assert_eq!(6, my_crate::add_one(5));\n+```\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_impl() {\n+        let info = call_info(\n+            r#\"\n+struct addr;\n+impl addr {\n+    /// Adds one to the number given.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let five = 5;\n+    ///\n+    /// assert_eq!(6, my_crate::add_one(5));\n+    /// ```\n+    pub fn add_one(x: i32) -> i32 {\n+        x + 1\n+    }\n+}\n+\n+pub fn do_it() {\n+    addr {};\n+    addr::add_one(<|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n+        assert_eq!(info.active_parameter, Some(0));\n+        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Adds one to the number given.\n+\n+# Examples\n+\n+```rust\n+let five = 5;\n+\n+assert_eq!(6, my_crate::add_one(5));\n+```\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fn_signature_with_docs_from_actix() {\n+        let info = call_info(\n+            r#\"\n+pub trait WriteHandler<E>\n+where\n+    Self: Actor,\n+    Self::Context: ActorContext,\n+{\n+    /// Method is called when writer emits error.\n+    ///\n+    /// If this method returns `ErrorAction::Continue` writer processing\n+    /// continues otherwise stream processing stops.\n+    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n+        Running::Stop\n+    }\n+\n+    /// Method is called when writer finishes.\n+    ///\n+    /// By default this method stops actor's `Context`.\n+    fn finished(&mut self, ctx: &mut Self::Context) {\n+        ctx.stop()\n+    }\n+}\n+\n+pub fn foo() {\n+    WriteHandler r;\n+    r.finished(<|>);\n+}\n+\n+\"#,\n+        );\n+\n+        assert_eq!(\n+            info.parameters,\n+            vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n+        );\n+        assert_eq!(info.active_parameter, Some(1));\n+        assert_eq!(\n+            info.doc,\n+            Some(\n+                r#\"Method is called when writer finishes.\n+\n+By default this method stops actor's `Context`.\"#\n+                    .into()\n+            )\n+        );\n+    }\n+\n+}"}, {"sha": "2c0735cb50cf433d6f5c980f7fb9bc1725908172", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 1, "deletions": 260, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/a3f74702d94b393d2f37bcda0fdfd6213fad460b/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3f74702d94b393d2f37bcda0fdfd6213fad460b/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=a3f74702d94b393d2f37bcda0fdfd6213fad460b", "patch": "@@ -5,14 +5,9 @@ use test_utils::{assert_eq_dbg, assert_eq_text};\n \n use ra_analysis::{\n     mock_analysis::{analysis_and_position, single_file, single_file_with_position, MockAnalysis},\n-    AnalysisChange, CrateGraph, FileId, FnSignatureInfo, Query\n+    AnalysisChange, CrateGraph, FileId, Query\n };\n \n-fn get_signature(text: &str) -> (FnSignatureInfo, Option<usize>) {\n-    let (analysis, position) = single_file_with_position(text);\n-    analysis.resolve_callable(position).unwrap().unwrap()\n-}\n-\n #[test]\n fn test_unresolved_module_diagnostic() {\n     let (analysis, file_id) = single_file(\"mod foo;\");\n@@ -99,260 +94,6 @@ fn test_resolve_crate_root() {\n     assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n }\n \n-#[test]\n-fn test_fn_signature_two_args_first() {\n-    let (desc, param) = get_signature(\n-        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n-    assert_eq!(param, Some(0));\n-}\n-\n-#[test]\n-fn test_fn_signature_two_args_second() {\n-    let (desc, param) = get_signature(\n-        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n-    assert_eq!(param, Some(1));\n-}\n-\n-#[test]\n-fn test_fn_signature_for_impl() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"new\".to_string());\n-    assert_eq!(desc.params, Vec::<String>::new());\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, None);\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_self() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"do_it\".to_string());\n-    assert_eq!(desc.params, vec![\"&self\".to_string()]);\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, None);\n-}\n-\n-#[test]\n-fn test_fn_signature_for_method_with_arg() {\n-    let (desc, param) = get_signature(\n-        r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self, x: i32) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"do_it\".to_string());\n-    assert_eq!(desc.params, vec![\"&self\".to_string(), \"x\".to_string()]);\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, Some(1));\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_simple() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo(<|>);\n-}\n-\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec![\"j\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> u32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"fn foo(j: u32) -> u32\".to_string());\n-    assert_eq!(desc.doc, Some(\"test\".into()));\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one(<|>\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"add_one\".to_string());\n-    assert_eq!(desc.params, vec![\"x\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> i32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                .into()\n-        )\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_impl() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one(<|>);\n-}\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"add_one\".to_string());\n-    assert_eq!(desc.params, vec![\"x\".to_string()]);\n-    assert_eq!(desc.ret_type, Some(\"-> i32\".to_string()));\n-    assert_eq!(param, Some(0));\n-    assert_eq!(desc.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                .into()\n-        )\n-    );\n-}\n-\n-#[test]\n-fn test_fn_signature_with_docs_from_actix() {\n-    let (desc, param) = get_signature(\n-        r#\"\n-pub trait WriteHandler<E>\n-where\n-    Self: Actor,\n-    Self::Context: ActorContext,\n-{\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo() {\n-    WriteHandler r;\n-    r.finished(<|>);\n-}\n-\n-\"#,\n-    );\n-\n-    assert_eq!(desc.name, \"finished\".to_string());\n-    assert_eq!(\n-        desc.params,\n-        vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n-    );\n-    assert_eq!(desc.ret_type, None);\n-    assert_eq!(param, Some(1));\n-    assert_eq!(\n-        desc.doc,\n-        Some(\n-            r#\"Method is called when writer finishes.\n-\n-By default this method stops actor's `Context`.\"#\n-                .into()\n-        )\n-    );\n-}\n-\n fn get_all_refs(text: &str) -> Vec<(FileId, TextRange)> {\n     let (analysis, position) = single_file_with_position(text);\n     analysis.find_all_refs(position).unwrap()"}]}