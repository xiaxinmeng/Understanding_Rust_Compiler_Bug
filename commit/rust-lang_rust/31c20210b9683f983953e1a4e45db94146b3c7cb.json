{"sha": "31c20210b9683f983953e1a4e45db94146b3c7cb", "node_id": "C_kwDOAAsO6NoAKDMxYzIwMjEwYjk2ODNmOTgzOTUzZTFhNGU0NWRiOTQxNDZiM2M3Y2I", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-12-23T20:02:23Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-01-11T22:40:02Z"}, "message": "Migrate pattern matching", "tree": {"sha": "e75765ba780b71da1998109e22abe6b64905086e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e75765ba780b71da1998109e22abe6b64905086e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31c20210b9683f983953e1a4e45db94146b3c7cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmO/OsIACgkQ+boUO5X/\nbYJrSBAAkLchGjx/EDLbP3Jq7YG/NGQ2SujVgSp0nTDMLKZ0c5g0xjdxAYNXRgW6\nSRbrTMOkC0ZveASdO4VDEJu4GyIiJtvBjN3XQIx+lk27As2opCt04NCdXpNUJX9x\nyBgMsPT4zV63ZZtuacg4tJQXOWtWA08bVKdvE6YOzqvkTOTVeX6BQZVjXU2oPEKM\nbOZ1dWiPaqSXl/kPu1cgduBeLLQaAmA0Bk4K9lAaLjYNOV6RliFu6eZ8XHBNujry\nsrHMc51S+pj/VTDDGpBVq5pLIlZmcnm8SZlLwVUGRsOebBEl/AdphbJrLC2eVXmm\nTL2gTXL/KQbcqpWpNwXkeZSC0Z9W8fxNwq7E+jKraVczF/vJ0o99pAwH4D1kzofJ\nAqx4UN2x+yx1WyBAin8ssdm8e1UyhzSVGsUfZ9q1ClBCTgea4Tw6dL+KfY9PO1h1\nDhtPWE8H0Lq2pEegBX2+vvEvtxOXy27l2RZBifPAhpAVU0lXOC6R1x2SOveyR5Y/\nN2gTHZI+33Y2dcGMWSANHoUQfAdKv21MxFA3YXmeFuFGGvDa5Dqag9Mb6+8KHeUS\nu782KxD8LObbf37DSRReiehkDBV25U3vlelMxf2OqMXfoaLxXKH9cd3iYnQAxJNP\nAv6d/b4mMArw4ETENDr+sa1UxrMNvYnatnqhr7LRBfxEcEjKAyw=\n=C0pN\n-----END PGP SIGNATURE-----", "payload": "tree e75765ba780b71da1998109e22abe6b64905086e\nparent ef3307289056ac3151a1a6eb29065932e5326bcf\nauthor mejrs <> 1671825743 +0100\ncommitter David Tolnay <dtolnay@gmail.com> 1673476802 -0800\n\nMigrate pattern matching\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31c20210b9683f983953e1a4e45db94146b3c7cb", "html_url": "https://github.com/rust-lang/rust/commit/31c20210b9683f983953e1a4e45db94146b3c7cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31c20210b9683f983953e1a4e45db94146b3c7cb/comments", "author": {}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef3307289056ac3151a1a6eb29065932e5326bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3307289056ac3151a1a6eb29065932e5326bcf", "html_url": "https://github.com/rust-lang/rust/commit/ef3307289056ac3151a1a6eb29065932e5326bcf"}], "stats": {"total": 739, "additions": 415, "deletions": 324}, "files": [{"sha": "b277942cdcca11550a06c80d7137fcd6ee89589c", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -326,11 +326,39 @@ mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpo\n mir_build_overlapping_range = this range overlaps on `{$range}`...\n \n mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n-    .label = {$count ->\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_uncovered = {$count ->\n         [1] pattern `{$witness_1}`\n         [2] patterns `{$witness_1}` and `{$witness_2}`\n         [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n-        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and more\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n     } not covered\n-    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n-    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_pattern_not_covered = refutable pattern in {$origin}\n+    .pattern_ty = the matched value is of type `{$pattern_ty}`\n+\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+\n+mir_build_res_defined_here = {$res} defined here\n+\n+mir_build_adt_defined_here = `{$ty}` defined here\n+\n+mir_build_variant_defined_here = not covered\n+\n+mir_build_interpreted_as_const = introduce a variable instead\n+\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+\n+mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched\n+\n+mir_build_suggest_let_else = alternatively, you might want to use `let else` to handle the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched"}, {"sha": "a3c58c31654fd3f1436275b7183a470be948a385", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 157, "deletions": 7, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,8 +1,11 @@\n+use crate::thir::pattern::deconstruct_pat::DeconstructedPat;\n use crate::thir::pattern::MatchCheckCtxt;\n use rustc_errors::Handler;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n+use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n@@ -677,7 +680,6 @@ pub struct OverlappingRangeEndpoints<'tcx> {\n     pub overlap: Overlap<'tcx>,\n }\n \n-#[derive(Debug)]\n #[derive(Subdiagnostic)]\n #[label(mir_build_overlapping_range)]\n pub struct Overlap<'tcx> {\n@@ -692,10 +694,158 @@ pub struct Overlap<'tcx> {\n #[note]\n pub(crate) struct NonExhaustiveOmittedPattern<'tcx> {\n     pub scrut_ty: Ty<'tcx>,\n-    #[label]\n-    pub uncovered: Span,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_uncovered)]\n+pub(crate) struct Uncovered<'tcx> {\n+    #[primary_span]\n+    span: Span,\n+    count: usize,\n+    witness_1: Pat<'tcx>,\n+    witness_2: Pat<'tcx>,\n+    witness_3: Pat<'tcx>,\n+    remainder: usize,\n+}\n+\n+impl<'tcx> Uncovered<'tcx> {\n+    pub fn new<'p>(\n+        span: Span,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        let witness_1 = witnesses.get(0).unwrap().to_pat(cx);\n+        Self {\n+            span,\n+            count: witnesses.len(),\n+            // Substitute dummy values if witnesses is smaller than 3. These will never be read.\n+            witness_2: witnesses.get(1).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_3: witnesses.get(2).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_1,\n+            remainder: witnesses.len().saturating_sub(3),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_pattern_not_covered, code = \"E0005\")]\n+pub(crate) struct PatternNotCovered<'s, 'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub origin: &'s str,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+    #[subdiagnostic]\n+    pub inform: Option<Inform>,\n+    #[subdiagnostic]\n+    pub interpreted_as_const: Option<InterpretedAsConst>,\n+    #[subdiagnostic]\n+    pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(pattern_ty)]\n+    pub _p: (),\n+    pub pattern_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub if_let_suggestion: Option<SuggestIfLet>,\n+    #[subdiagnostic]\n+    pub let_else_suggestion: Option<SuggestLetElse>,\n+    #[subdiagnostic]\n+    pub res_defined_here: Option<ResDefinedHere>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_build_inform_irrefutable)]\n+#[note(mir_build_more_information)]\n+pub struct Inform;\n+\n+pub struct AdtDefinedHere<'tcx> {\n+    pub adt_def_span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub variants: Vec<Variant>,\n+}\n+\n+pub struct Variant {\n+    pub span: Span,\n+}\n+\n+impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"ty\", self.ty);\n+        let mut spans = MultiSpan::from(self.adt_def_span);\n+\n+        for Variant { span } in self.variants {\n+            spans.push_span_label(span, rustc_errors::fluent::mir_build_variant_defined_here);\n+        }\n+\n+        diag.span_note(spans, rustc_errors::fluent::mir_build_adt_defined_here);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_res_defined_here)]\n+pub struct ResDefinedHere {\n+    #[primary_span]\n+    pub def_span: Span,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    mir_build_interpreted_as_const,\n+    code = \"{variable}_var\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+#[label(mir_build_confused)]\n+pub struct InterpretedAsConst {\n+    #[primary_span]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub variable: String,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestIfLet {\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    None {\n+        #[suggestion_part(code = \"if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ todo!() }}\")]\n+        semi_span: Span,\n+        count: usize,\n+    },\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    One {\n+        #[suggestion_part(code = \"let {binding} = if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ {binding} }} else {{ todo!() }}\")]\n+        end_span: Span,\n+        binding: Ident,\n+        count: usize,\n+    },\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    More {\n+        #[suggestion_part(code = \"let ({bindings}) = if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ ({bindings}) }} else {{ todo!() }}\")]\n+        end_span: Span,\n+        bindings: String,\n+        count: usize,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    mir_build_suggest_let_else,\n+    code = \" else {{ todo!() }}\",\n+    applicability = \"has-placeholders\"\n+)]\n+pub struct SuggestLetElse {\n+    #[primary_span]\n+    pub end_span: Span,\n     pub count: usize,\n-    pub witness_1: Pat<'tcx>,\n-    pub witness_2: Pat<'tcx>,\n-    pub witness_3: Pat<'tcx>,\n }"}, {"sha": "fb7ae6f1d242412e8e72197107f2214969a54e50", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -10,6 +10,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "422c2ff3ede0deb631b2551576386c14cc84c5e8", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 74, "deletions": 133, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,3 +1,8 @@\n+//#![allow(unused_imports, unused_variables)]\n+\n+//#![warn(rustc::untranslatable_diagnostic)]\n+//#![warn(rustc::diagnostic_outside_of_impl)]\n+\n use super::deconstruct_pat::{Constructor, DeconstructedPat};\n use super::usefulness::{\n     compute_match_usefulness, MatchArm, MatchCheckCtxt, Reachability, UsefulnessReport,\n@@ -9,8 +14,7 @@ use crate::errors::*;\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-    MultiSpan,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -378,8 +382,8 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n         let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n         let pattern_ty = pattern.ty();\n-        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n-        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,145 +394,82 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n-\n-        let mut bindings = vec![];\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            pat.span,\n-            E0005,\n-            \"refutable pattern in {}: {} not covered\",\n-            origin,\n-            joined_patterns\n-        );\n-        let suggest_if_let = match &pat.kind {\n-            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+        let (inform, interpreted_as_const, res_defined_here, if_let_suggestion, let_else_suggestion) =\n+            if let hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path {\n+                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n+                    ..\n+                },\n+            )) = &pat.kind\n             {\n-                const_not_var(&mut err, cx.tcx, pat, path);\n-                false\n-            }\n-            _ => {\n-                pat.walk(&mut |pat: &hir::Pat<'_>| {\n-                    match pat.kind {\n-                        hir::PatKind::Binding(_, _, ident, _) => {\n-                            bindings.push(ident);\n+                (\n+                    None,\n+                    Some(InterpretedAsConst {\n+                        span: pat.span,\n+                        article: res.article(),\n+                        variable: ident.to_string().to_lowercase(),\n+                        res,\n+                    }),\n+                    try {\n+                        ResDefinedHere {\n+                            def_span: cx.tcx.hir().res_span(res)?,\n+                            res,\n                         }\n-                        _ => {}\n+                    },\n+                    None, None,\n+                )\n+            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n+                let mut bindings = vec![];\n+                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                        bindings.push(ident);\n                     }\n-                    true\n                 });\n-\n-                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n-                true\n-            }\n-        };\n-\n-        if let (Some(span), true) = (sp, suggest_if_let) {\n-            err.note(\n-                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                 an `enum` with only one variant\",\n-            );\n-            if self.tcx.sess.source_map().is_span_accessible(span) {\n                 let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n                 let start_span = span.shrink_to_lo();\n                 let end_span = semi_span.shrink_to_lo();\n-                err.multipart_suggestion(\n-                    &format!(\n-                        \"you might want to use `if let` to ignore the variant{} that {} matched\",\n-                        pluralize!(witnesses.len()),\n-                        match witnesses.len() {\n-                            1 => \"isn't\",\n-                            _ => \"aren't\",\n-                        },\n-                    ),\n-                    vec![\n-                        match &bindings[..] {\n-                            [] => (start_span, \"if \".to_string()),\n-                            [binding] => (start_span, format!(\"let {} = if \", binding)),\n-                            bindings => (\n-                                start_span,\n-                                format!(\n-                                    \"let ({}) = if \",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                        match &bindings[..] {\n-                            [] => (semi_span, \" { todo!() }\".to_string()),\n-                            [binding] => {\n-                                (end_span, format!(\" {{ {} }} else {{ todo!() }}\", binding))\n-                            }\n-                            bindings => (\n-                                end_span,\n-                                format!(\n-                                    \" {{ ({}) }} else {{ todo!() }}\",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                    ],\n-                    Applicability::HasPlaceholders,\n-                );\n-                if !bindings.is_empty() {\n-                    err.span_suggestion_verbose(\n-                        semi_span.shrink_to_lo(),\n-                        &format!(\n-                            \"alternatively, you might want to use \\\n-                             let else to handle the variant{} that {} matched\",\n-                            pluralize!(witnesses.len()),\n-                            match witnesses.len() {\n-                                1 => \"isn't\",\n-                                _ => \"aren't\",\n-                            },\n-                        ),\n-                        \" else { todo!() }\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-            }\n-            err.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n-            );\n-        }\n-\n-        adt_defined_here(&cx, &mut err, pattern_ty, &witnesses);\n-        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-        err.emit();\n-    }\n-}\n+                let count = witnesses.len();\n+                let if_let = match *bindings {\n+                    [] =>  SuggestIfLet::None{start_span, semi_span, count},\n+                    [binding] => SuggestIfLet::One{start_span, end_span, count, binding },\n+                    _ => SuggestIfLet::More{start_span, end_span, count, bindings: bindings\n+                        .iter()\n+                        .map(|ident| ident.to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")},\n+                };\n+                let let_else = if bindings.is_empty() {None} else{Some( SuggestLetElse{end_span, count })};\n+                (sp.map(|_|Inform), None, None, Some(if_let), let_else)\n+            } else{\n+                (sp.map(|_|Inform), None, None,  None, None)\n+            };\n \n-/// A path pattern was interpreted as a constant, not a new variable.\n-/// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut Diagnostic, tcx: TyCtxt<'_>, pat: &Pat<'_>, path: &hir::Path<'_>) {\n-    let descr = path.res.descr();\n-    err.span_label(\n-        pat.span,\n-        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n-    );\n+        let adt_defined_here = try {\n+            let ty = pattern_ty.peel_refs();\n+            let ty::Adt(def, _) = ty.kind() else { None? };\n+            let adt_def_span = cx.tcx.hir().get_if_local(def.did())?.ident()?.span;\n+            let mut variants = vec![];\n \n-    err.span_suggestion(\n-        pat.span,\n-        \"introduce a variable instead\",\n-        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n-        // Cannot use `MachineApplicable` as it's not really *always* correct\n-        // because there may be such an identifier in scope or the user maybe\n-        // really wanted to match against the constant. This is quite unlikely however.\n-        Applicability::MaybeIncorrect,\n-    );\n+            for span in maybe_point_at_variant(&cx, *def, witnesses.iter().take(5)) {\n+                variants.push(Variant { span });\n+            }\n+            AdtDefinedHere { adt_def_span, ty, variants }\n+        };\n \n-    if let Some(span) = tcx.hir().res_span(path.res) {\n-        err.span_label(span, format!(\"{} defined here\", descr));\n+        self.tcx.sess.emit_err(PatternNotCovered {\n+            span: pat.span,\n+            origin,\n+            uncovered: Uncovered::new(pat.span, &cx, witnesses),\n+            inform,\n+            interpreted_as_const,\n+            _p: (),\n+            pattern_ty,\n+            if_let_suggestion,\n+            let_else_suggestion,\n+            res_defined_here,\n+            adt_defined_here,\n+        });\n     }\n }\n "}, {"sha": "be66d0d476513992b4009fef5d85ba354ba4b82a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -292,7 +292,7 @@\n use self::ArmType::*;\n use self::Usefulness::*;\n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n-use crate::errors::NonExhaustiveOmittedPattern;\n+use crate::errors::{NonExhaustiveOmittedPattern, Uncovered};\n \n use rustc_data_structures::captures::Captures;\n \n@@ -742,49 +742,6 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     }\n }\n \n-/// Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n-/// is not exhaustive enough.\n-///\n-/// NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n-fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    scrut_ty: Ty<'tcx>,\n-    sp: Span,\n-    hir_id: HirId,\n-    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-) {\n-    let witness_1 = witnesses.get(0).unwrap().to_pat(cx);\n-\n-    cx.tcx.emit_spanned_lint(\n-        NON_EXHAUSTIVE_OMITTED_PATTERNS,\n-        hir_id,\n-        sp,\n-        NonExhaustiveOmittedPattern {\n-            scrut_ty,\n-            uncovered: sp,\n-            count: witnesses.len(),\n-            // Substitute dummy values if witnesses is smaller than 3.\n-            witness_2: witnesses.get(1).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n-            witness_3: witnesses.get(2).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n-            witness_1,\n-        },\n-    );\n-    /*\n-    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, \"some variants are not matched explicitly\", |lint| {\n-        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n-        lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n-        lint.help(\n-            \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n-        );\n-        lint.note(&format!(\n-            \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n-            scrut_ty,\n-        ));\n-        lint\n-    });\n-    */\n-}\n-\n /// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -930,7 +887,19 @@ fn is_useful<'p, 'tcx>(\n                         .collect::<Vec<_>>()\n                 };\n \n-                lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n+                // Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n+                // is not exhaustive enough.\n+                //\n+                // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n+                cx.tcx.emit_spanned_lint(\n+                    NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+                    hir_id,\n+                    pcx.span,\n+                    NonExhaustiveOmittedPattern {\n+                        scrut_ty: pcx.ty,\n+                        uncovered: Uncovered::new(pcx.span, pcx.cx, patterns),\n+                    },\n+                );\n             }\n \n             ret.extend(usefulness);"}, {"sha": "1caf1617e213cb198ad9cbf82e80804013bbd664", "filename": "tests/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },"}, {"sha": "f038ba1c8ed859314c4aa4140e4018cce0bba1c7", "filename": "tests/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];"}, {"sha": "b1921f8a41e48db0560471f059b83b6114ab9ec5", "filename": "tests/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n@@ -12,7 +12,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                  ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n@@ -26,7 +26,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL | static Y: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                   ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n@@ -40,7 +40,7 @@ help: you might want to use `if let` to ignore the variants that aren't matched\n LL |     const X: i32 = { if let 0 = 0 { todo!() } 0 };\n    |                      ++           ~~~~~~~~~~~\n \n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `1_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };"}, {"sha": "61bdf57ffdb9445890321d9ff29c25f2f114bc59", "filename": "tests/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -9,8 +9,20 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX\n+    let a = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let c = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    let d = 4;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+    //~| missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "c156ea1610c4fca77bd67d1364f8c57981bc4306", "filename": "tests/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL | const a: u8 = 2;\n@@ -7,35 +7,38 @@ LL | const a: u8 = 2;\n LL |     let a = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:13:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:17:9\n    |\n LL |     pub const b: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let c = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `c` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `c_var`\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n-  --> $DIR/const-pattern-irrefutable.rs:14:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/const-pattern-irrefutable.rs:22:9\n    |\n LL |     pub const d: u8 = 2;\n    |     --------------- constant defined here\n ...\n LL |     let d = 4;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `0_u8..=1_u8` and `3_u8..=u8::MAX` not covered\n+   |         missing patterns are not covered because `d` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `d_var`\n    |\n    = note: the matched value is of type `u8`"}, {"sha": "d6119028f5b59dff801ad06b757fdf1d670944f8", "filename": "tests/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice(&[a, b]: &[i32]) -> i32 {"}, {"sha": "fd93346101d846778efb629f929afc4d99c25012", "filename": "tests/ui/empty/empty-never-array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fempty%2Fempty-never-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fempty%2Fempty-never-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -8,7 +8,8 @@ enum Helper<T, U> {\n \n fn transmute<T, U>(t: T) -> U {\n     let Helper::U(u) = Helper::T(t, []);\n-    //~^ ERROR refutable pattern in local binding: `Helper::T(_, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Helper::T(_, _)` not covered\n     u\n }\n "}, {"sha": "9385382f860bc94219127f5d75a79d6c6a6b4163", "filename": "tests/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Helper::T(_, _)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/empty-never-array.rs:10:9\n    |\n LL |     let Helper::U(u) = Helper::T(t, []);\n@@ -7,18 +7,18 @@ LL |     let Helper::U(u) = Helper::T(t, []);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Helper<T, U>` defined here\n-  --> $DIR/empty-never-array.rs:4:5\n+  --> $DIR/empty-never-array.rs:3:6\n    |\n LL | enum Helper<T, U> {\n-   |      ------\n+   |      ^^^^^^\n LL |     T(T, [!; 0]),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Helper<T, U>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let u = if let Helper::U(u) = Helper::T(t, []) { u } else { todo!() };\n    |     ++++++++++                                     ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Helper::U(u) = Helper::T(t, []) else { todo!() };\n    |                                         ++++++++++++++++"}, {"sha": "3c27a7d4c064e0fe4fdcae158109f48a54e90d6a", "filename": "tests/ui/error-codes/E0005.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0005.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,22 +1,17 @@\n-error[E0005]: refutable pattern in local binding: `None` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/E0005.rs:3:9\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let y = if let Some(y) = x { y } else { todo!() };\n    |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Some(y) = x else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "293028f5f68b12cd5f827b01de66b333404dd714", "filename": "tests/ui/error-codes/E0297.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0297.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,14 +1,9 @@\n-error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/E0297.rs:4:9\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n    |\n-note: `Option<i32>` defined here\n-  --> $SRC_DIR/core/src/option.rs:LL:COL\n-  ::: $SRC_DIR/core/src/option.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Option<i32>`\n \n error: aborting due to previous error"}, {"sha": "5e4df7422fcf0a4ea64b033f4ab4f7e03d057348", "filename": "tests/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,22 +1,17 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, !>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let _x = if let Ok(_x) = foo() { _x } else { todo!() };\n    |     +++++++++++                    +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(_x) = foo() else { todo!() };\n    |                        ++++++++++++++++"}, {"sha": "49a82a6769dce5f6fe2c7524223dc0d90605089a", "filename": "tests/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&i32::MIN..=0_i32` and `&2_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}"}, {"sha": "23b266bef1d91d373d4519178c27330f2a559602", "filename": "tests/ui/issues/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fissues%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fissues%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not\n+        //~^ ERROR refutable pattern in `for` loop binding\n+        //~| patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "085958411ccb963ce490835fcaf5cc08e0077887", "filename": "tests/ui/issues/issue-15381.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fissues%2Fissue-15381.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fissues%2Fissue-15381.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-15381.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+error[E0005]: refutable pattern in `for` loop binding\n   --> $DIR/issue-15381.rs:4:9\n    |\n LL |     for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {"}, {"sha": "40c7c1d1067ffad535a6dc11dc2895325357f6e7", "filename": "tests/ui/never_type/exhaustive_patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_type%2Fexhaustive_patterns.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Either::B(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/exhaustive_patterns.rs:20:9\n    |\n LL |     let Either::A(()) = foo();\n@@ -7,13 +7,13 @@ LL |     let Either::A(()) = foo();\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Either<(), !>` defined here\n-  --> $DIR/exhaustive_patterns.rs:12:5\n+  --> $DIR/exhaustive_patterns.rs:10:6\n    |\n LL | enum Either<A, B> {\n-   |      ------\n+   |      ^^^^^^\n LL |     A(A),\n LL |     B(inner::Wrapper<B>),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Either<(), !>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |"}, {"sha": "4adcf4feee90d6dfbe705a71497b30f27d5090ae", "filename": "tests/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=-1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:2:10\n    |\n LL |     let (0 | (1 | 2)) = 0;"}, {"sha": "82414f0418bb21e0dc8795f8e70fa570d024a2ce", "filename": "tests/ui/pattern/usefulness/issue-31561.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -6,5 +6,6 @@ enum Thing {\n \n fn main() {\n     let Thing::Foo(y) = Thing::Foo(1);\n-    //~^ ERROR refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Thing::Bar` and `Thing::Baz` not covered\n }"}, {"sha": "202fe9de5d3e63705b0b147b60f5aa90edd129ac", "filename": "tests/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Thing::Bar` and `Thing::Baz` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/issue-31561.rs:8:9\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1);\n@@ -7,21 +7,21 @@ LL |     let Thing::Foo(y) = Thing::Foo(1);\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Thing` defined here\n-  --> $DIR/issue-31561.rs:3:5\n+  --> $DIR/issue-31561.rs:1:6\n    |\n LL | enum Thing {\n-   |      -----\n+   |      ^^^^^\n LL |     Foo(u8),\n LL |     Bar,\n-   |     ^^^ not covered\n+   |     --- not covered\n LL |     Baz\n-   |     ^^^ not covered\n+   |     --- not covered\n    = note: the matched value is of type `Thing`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n LL |     let y = if let Thing::Foo(y) = Thing::Foo(1) { y } else { todo!() };\n    |     ++++++++++                                   ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variants that aren't matched\n+help: alternatively, you might want to use `let else` to handle the variants that aren't matched\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1) else { todo!() };\n    |                                       ++++++++++++++++"}, {"sha": "5145f769075d9b86403e3cf1f340e9888e156466", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -15,9 +15,6 @@ enum E {\n     //~^ NOTE `E` defined here\n     //~| NOTE `E` defined here\n     //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n-    //~| NOTE `E` defined here\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n     //~| NOTE  not covered\n@@ -41,37 +38,41 @@ fn by_val(e: E) {\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `E::B` and `E::C` not covered\n-    //~^ NOTE patterns `E::B` and `E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `E::B` and `E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `E`\n }\n \n fn by_ref_once(e: &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE the matched value is of type `&E`\n         E::A => {}\n     }\n \n-    let E::A = e; //~ ERROR refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-    //~^ NOTE patterns `&E::B` and `&E::C` not covered\n+    let E::A = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&E::B` and `&E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&E`\n }\n \n fn by_ref_thrice(e: & &mut &E) {\n-    match e { //~ ERROR non-exhaustive patterns: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~^ NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    match e {\n+    //~^ ERROR non-exhaustive patterns\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE the matched value is of type `&&mut &E`\n         E::A => {}\n     }\n \n     let E::A = e;\n-    //~^ ERROR refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-    //~| NOTE patterns `&&mut &E::B` and `&&mut &E::C` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `&&mut &E::B` and `&&mut &E::C` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n     //~| NOTE the matched value is of type `&&mut &E`\n@@ -83,20 +84,21 @@ enum Opt {\n     Some(u8),\n     None,\n     //~^ NOTE `Opt` defined here\n-    //~| NOTE `Opt` defined here\n     //~| NOTE not covered\n     //~| NOTE not covered\n }\n \n fn ref_pat(e: Opt) {\n-    match e {//~ ERROR non-exhaustive patterns: `Opt::None` not covered\n-        //~^ NOTE pattern `Opt::None` not covered\n+    match e {\n+        //~^ ERROR non-exhaustive patterns\n+        //~| pattern `Opt::None` not covered\n         //~| NOTE the matched value is of type `Opt`\n         Opt::Some(ref _x) => {}\n     }\n \n-    let Opt::Some(ref _x) = e; //~ ERROR refutable pattern in local binding: `Opt::None` not covered\n-    //~^ NOTE the matched value is of type `Opt`\n+    let Opt::Some(ref _x) = e;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| NOTE the matched value is of type `Opt`\n     //~| NOTE pattern `Opt::None` not covered\n     //~| NOTE `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with\n     //~| NOTE for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "3e375066f1b50e2b4876befce24faefc97621048", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:38:11\n+  --> $DIR/non-exhaustive-defined-here.rs:35:11\n    |\n LL |     match e1 {\n    |           ^^ patterns `E::B` and `E::C` not covered\n@@ -22,33 +22,33 @@ LL ~         E::A => {}\n LL +         E::B | E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `E::B` and `E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:44:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:41:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `E::B` and `E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n LL |     if let E::A = e { todo!() }\n    |     ++              ~~~~~~~~~~~\n \n error[E0004]: non-exhaustive patterns: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:52:11\n+  --> $DIR/non-exhaustive-defined-here.rs:50:11\n    |\n LL |     match e {\n    |           ^ patterns `&E::B` and `&E::C` not covered\n@@ -71,25 +71,25 @@ LL ~         E::A => {}\n LL +         &E::B | &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&E::B` and `&E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:58:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:57:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&E::B` and `&E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -120,25 +120,25 @@ LL ~         E::A => {}\n LL +         &&mut &E::B | &&mut &E::C => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `&&mut &E::B` and `&&mut &E::C` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:72:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:73:9\n    |\n LL |     let E::A = e;\n    |         ^^^^ patterns `&&mut &E::B` and `&&mut &E::C` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `E` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:14:5\n+  --> $DIR/non-exhaustive-defined-here.rs:6:6\n    |\n LL | enum E {\n-   |      -\n+   |      ^\n ...\n LL |     B,\n-   |     ^ not covered\n+   |     - not covered\n ...\n LL |     C\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `&&mut &E`\n help: you might want to use `if let` to ignore the variants that aren't matched\n    |\n@@ -152,7 +152,7 @@ LL |     match e {\n    |           ^ pattern `Opt::None` not covered\n    |\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:85:5\n    |\n LL | enum Opt {\n    |      ---\n@@ -166,28 +166,28 @@ LL ~         Opt::Some(ref _x) => {}\n LL +         Opt::None => todo!()\n    |\n \n-error[E0005]: refutable pattern in local binding: `Opt::None` not covered\n-  --> $DIR/non-exhaustive-defined-here.rs:98:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/non-exhaustive-defined-here.rs:99:9\n    |\n LL |     let Opt::Some(ref _x) = e;\n    |         ^^^^^^^^^^^^^^^^^ pattern `Opt::None` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Opt` defined here\n-  --> $DIR/non-exhaustive-defined-here.rs:84:5\n+  --> $DIR/non-exhaustive-defined-here.rs:81:6\n    |\n LL | enum Opt {\n-   |      ---\n+   |      ^^^\n ...\n LL |     None,\n-   |     ^^^^ not covered\n+   |     ---- not covered\n    = note: the matched value is of type `Opt`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let _x = if let Opt::Some(ref _x) = e { _x } else { todo!() };\n    |     +++++++++++                           +++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Opt::Some(ref _x) = e else { todo!() };\n    |                               ++++++++++++++++"}, {"sha": "7a3e991d59317d3e6fcc3f8d5e93c96cff67441f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,7 +1,9 @@\n fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n-//~^ ERROR refutable pattern in function argument: `(_, _)` not covered\n+//~^ ERROR refutable pattern in function argument\n+//~| `(_, _)` not covered\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n }"}, {"sha": "c518de47740dd89d5c9c30fdf2ce02c02fe0170f", "filename": "tests/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,13 +1,13 @@\n-error[E0005]: refutable pattern in function argument: `(_, _)` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-errors.rs:1:9\n    |\n LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |         ^^^^^^^^^^^^^^^^^^^^^ pattern `(_, _)` not covered\n    |\n    = note: the matched value is of type `(isize, (Option<isize>, isize))`\n \n-error[E0005]: refutable pattern in local binding: `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered\n-  --> $DIR/refutable-pattern-errors.rs:5:9\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/refutable-pattern-errors.rs:6:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n    |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(i32::MIN..=0_i32, _)` and `(2_i32..=i32::MAX, _)` not covered"}, {"sha": "17dc38ab25d92ff229b805d6e19e73ce074f6203", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let f = |3: isize| println!(\"hello\");\n-    //~^ ERROR refutable pattern in function argument: `_` not covered\n+    //~^ ERROR refutable pattern in function argument\n+    //~| `_` not covered\n     f(4);\n }"}, {"sha": "55f0b2319fb7fc4ce6eec9d5883efbd69de8d0b1", "filename": "tests/ui/pattern/usefulness/refutable-pattern-in-fn-arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-in-fn-arg.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in function argument: `_` not covered\n+error[E0005]: refutable pattern in function argument\n   --> $DIR/refutable-pattern-in-fn-arg.rs:2:14\n    |\n LL |     let f = |3: isize| println!(\"hello\");"}, {"sha": "b7521df88ec5a84f5bf4debb4deee9c6f7b4c33e", "filename": "tests/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,22 +1,17 @@\n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, &R<'_>>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, &R<'_>>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let x = if let Ok(x) = res { x } else { todo!() };\n    |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = res else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "15f08486f0f0ebe2c921ea9333d62d486b7807c2", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,7 +1,8 @@\n fn main() {\n     let A = 3;\n-    //~^ ERROR refutable pattern in local binding: `i32::MIN..=1_i32` and\n-    //~| interpreted as a constant pattern, not a new variable\n+    //~^ ERROR refutable pattern in local binding\n+    //~| patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+    //~| missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n     //~| SUGGESTION a_var\n "}, {"sha": "1c1cab25fbfaf83250add6707af512d0952b0a51", "filename": "tests/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,10 +1,11 @@\n-error[E0005]: refutable pattern in local binding: `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n    |\n LL |     let A = 3;\n    |         ^\n    |         |\n-   |         interpreted as a constant pattern, not a new variable\n+   |         patterns `i32::MIN..=1_i32` and `3_i32..=i32::MAX` not covered\n+   |         missing patterns are not covered because `a` is interpreted as a constant pattern, not a new variable\n    |         help: introduce a variable instead: `a_var`\n ...\n LL |     const A: i32 = 2;"}, {"sha": "4b001aca2d1c7c4c7832514f9ca8fd2524db96fb", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.rs?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -24,5 +24,7 @@ enum Foo {\n \n fn main() {\n     let x: Foo = Foo::D(123, 456);\n-    let Foo::D(_y, _z) = x; //~ ERROR refutable pattern in local binding: `Foo::A(_)` not covered\n+    let Foo::D(_y, _z) = x;\n+    //~^ ERROR refutable pattern in local binding\n+    //~| `Foo::A(_)` not covered\n }"}, {"sha": "461863e1127919f1930ed3d774fa2501669a8209", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `Foo::A(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-irrefutable.rs:27:9\n    |\n LL |     let Foo::D(_y, _z) = x;\n@@ -7,18 +7,18 @@ LL |     let Foo::D(_y, _z) = x;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n note: `Foo` defined here\n-  --> $DIR/uninhabited-irrefutable.rs:19:5\n+  --> $DIR/uninhabited-irrefutable.rs:18:6\n    |\n LL | enum Foo {\n-   |      ---\n+   |      ^^^\n LL |     A(foo::SecretlyEmpty),\n-   |     ^ not covered\n+   |     - not covered\n    = note: the matched value is of type `Foo`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let (_y, _z) = if let Foo::D(_y, _z) = x { (_y, _z) } else { todo!() };\n    |     +++++++++++++++++                        +++++++++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Foo::D(_y, _z) = x else { todo!() };\n    |                            ++++++++++++++++"}, {"sha": "2c67eac51f5218e482c92ea7b3fe4a14345bd106", "filename": "tests/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/31c20210b9683f983953e1a4e45db94146b3c7cb/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=31c20210b9683f983953e1a4e45db94146b3c7cb", "patch": "@@ -95,25 +95,20 @@ LL ~         Ok(x) => x,\n LL ~         Err(_) => todo!(),\n    |\n \n-error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n+error[E0005]: refutable pattern in local binding\n   --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n-note: `Result<u32, Void>` defined here\n-  --> $SRC_DIR/core/src/result.rs:LL:COL\n-  ::: $SRC_DIR/core/src/result.rs:LL:COL\n-   |\n-   = note: not covered\n    = note: the matched value is of type `Result<u32, Void>`\n help: you might want to use `if let` to ignore the variant that isn't matched\n    |\n LL |     let x = if let Ok(x) = x { x } else { todo!() };\n    |     ++++++++++               ++++++++++++++++++++++\n-help: alternatively, you might want to use let else to handle the variant that isn't matched\n+help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = x else { todo!() };\n    |                   ++++++++++++++++"}]}