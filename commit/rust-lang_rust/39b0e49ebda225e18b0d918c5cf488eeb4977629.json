{"sha": "39b0e49ebda225e18b0d918c5cf488eeb4977629", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YjBlNDllYmRhMjI1ZTE4YjBkOTE4YzVjZjQ4OGVlYjQ5Nzc2Mjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-14T12:33:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:51Z"}, "message": "rustfmt: borrow_check/mod.rs", "tree": {"sha": "28fe96c1613d50ca5d12a4b8cd3452739b41582b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28fe96c1613d50ca5d12a4b8cd3452739b41582b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39b0e49ebda225e18b0d918c5cf488eeb4977629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39b0e49ebda225e18b0d918c5cf488eeb4977629", "html_url": "https://github.com/rust-lang/rust/commit/39b0e49ebda225e18b0d918c5cf488eeb4977629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39b0e49ebda225e18b0d918c5cf488eeb4977629/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "url": "https://api.github.com/repos/rust-lang/rust/commits/e447b54bc3d7b2df8dd1326b09cefad31d2e4153", "html_url": "https://github.com/rust-lang/rust/commit/e447b54bc3d7b2df8dd1326b09cefad31d2e4153"}], "stats": {"total": 407, "additions": 229, "deletions": 178}, "files": [{"sha": "4dbb613f8fb6a0f9393d4d85585072f78eb3409f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 229, "deletions": 178, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/39b0e49ebda225e18b0d918c5cf488eeb4977629/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39b0e49ebda225e18b0d918c5cf488eeb4977629/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=39b0e49ebda225e18b0d918c5cf488eeb4977629", "patch": "@@ -34,9 +34,9 @@ use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n-use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n+use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n use dataflow::{ActiveBorrows, Reservations};\n-use dataflow::indexes::{BorrowIndex};\n+use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -149,9 +149,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         param_env: param_env,\n     };\n     let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor |\n-        DefPathData::EnumVariant(_) => None,\n-        _ => Some(tcx.hir.body_owned_by(id))\n+        DefPathData::StructCtor | DefPathData::EnumVariant(_) => None,\n+        _ => Some(tcx.hir.body_owned_by(id)),\n     };\n \n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n@@ -217,8 +216,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n         locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n-            hir::BodyOwnerKind::Const |\n-            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n             hir::BodyOwnerKind::Fn => true,\n         },\n         storage_dead_or_drop_error_reported_l: FxHashSet(),\n@@ -241,18 +239,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             // In practice it is easier to be looser; in particular,\n             // it is okay for the kill-sets to hold activation bits.\n             DebugFormatted::new(&(i.kind(), rs.location(i)))\n-        });\n+        },\n+    );\n     let flow_active_borrows = {\n         let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n         let reservations = flow_reservations.0.operator;\n-        let a = DataflowAnalysis::new_with_entry_sets(mir,\n-                                                      &dead_unwinds,\n-                                                      Cow::Borrowed(reservations_on_entry),\n-                                                      ActiveBorrows::new(reservations));\n-        let results = a.run(tcx,\n-                            id,\n-                            &attributes,\n-                            |ab, i| DebugFormatted::new(&(i.kind(), ab.location(i))));\n+        let a = DataflowAnalysis::new_with_entry_sets(\n+            mir,\n+            &dead_unwinds,\n+            Cow::Borrowed(reservations_on_entry),\n+            ActiveBorrows::new(reservations),\n+        );\n+        let results = a.run(tcx, id, &attributes, |ab, i| {\n+            DebugFormatted::new(&(i.kind(), ab.location(i)))\n+        });\n         FlowAtLocation::new(results)\n     };\n \n@@ -551,9 +551,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     }\n                 });\n             }\n-            TerminatorKind::Goto { target: _ } |\n-            TerminatorKind::Unreachable |\n-            TerminatorKind::FalseEdges { .. } => {\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::FalseEdges { .. } => {\n                 // no data used, thus irrelevant to borrowck\n             }\n         }\n@@ -648,13 +648,12 @@ enum LocalMutationIsAllowed {\n     /// We want use of immutable upvars to cause a \"write to immutable upvar\"\n     /// error, not an \"reassignment\" error.\n     ExceptUpvars,\n-    No\n+    No,\n }\n \n struct AccessErrorsReported {\n     mutability_error: bool,\n-    #[allow(dead_code)]\n-    conflict_error: bool\n+    #[allow(dead_code)] conflict_error: bool,\n }\n \n #[derive(Copy, Clone)]\n@@ -704,9 +703,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if let Activation(_, borrow_index) = rw {\n             if self.reservation_error_reported.contains(&place_span.0) {\n-                debug!(\"skipping access_place for activation of invalid reservation \\\n-                        place: {:?} borrow_index: {:?}\", place_span.0, borrow_index);\n-                return AccessErrorsReported { mutability_error: false, conflict_error: true };\n+                debug!(\n+                    \"skipping access_place for activation of invalid reservation \\\n+                     place: {:?} borrow_index: {:?}\",\n+                    place_span.0,\n+                    borrow_index\n+                );\n+                return AccessErrorsReported {\n+                    mutability_error: false,\n+                    conflict_error: true,\n+                };\n             }\n         }\n \n@@ -715,7 +721,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n-        AccessErrorsReported { mutability_error, conflict_error }\n+        AccessErrorsReported {\n+            mutability_error,\n+            conflict_error,\n+        }\n     }\n \n     fn check_access_for_conflict(\n@@ -738,22 +747,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 //\n                 // NOTE: *reservations* do conflict with themselves;\n                 // thus aren't injecting unsoundenss w/ this check.)\n-                (Activation(_, activating), _) if activating == index.borrow_index() =>\n-                {\n-                    debug!(\"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n-                            skipping {:?} b/c activation of same borrow_index: {:?}\",\n-                           place_span, sd, rw, (index, borrow), index.borrow_index());\n+                (Activation(_, activating), _) if activating == index.borrow_index() => {\n+                    debug!(\n+                        \"check_access_for_conflict place_span: {:?} sd: {:?} rw: {:?} \\\n+                         skipping {:?} b/c activation of same borrow_index: {:?}\",\n+                        place_span,\n+                        sd,\n+                        rw,\n+                        (index, borrow),\n+                        index.borrow_index()\n+                    );\n                     Control::Continue\n                 }\n \n-                (Read(_), BorrowKind::Shared) |\n-                (Reservation(..), BorrowKind::Shared) => Control::Continue,\n+                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    Control::Continue\n+                }\n \n-                (Read(kind), BorrowKind::Unique) |\n-                (Read(kind), BorrowKind::Mut) => {\n+                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.tcx.sess.opts.debugging_opts.two_phase_borrows &&\n-                        index.is_reservation()\n+                    if this.tcx.sess.opts.debugging_opts.two_phase_borrows && index.is_reservation()\n                     {\n                         return Control::Continue;\n                     }\n@@ -781,20 +794,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Control::Break\n                 }\n \n-                (Reservation(kind), BorrowKind::Unique) |\n-                (Reservation(kind), BorrowKind::Mut) |\n-                (Activation(kind, _), _) |\n-                (Write(kind), _) => {\n-\n+                (Reservation(kind), BorrowKind::Unique)\n+                | (Reservation(kind), BorrowKind::Mut)\n+                | (Activation(kind, _), _)\n+                | (Write(kind), _) => {\n                     match rw {\n                         Reservation(_) => {\n-                            debug!(\"recording invalid reservation of \\\n-                                    place: {:?}\", place_span.0);\n+                            debug!(\n+                                \"recording invalid reservation of \\\n+                                 place: {:?}\",\n+                                place_span.0\n+                            );\n                             this.reservation_error_reported.insert(place_span.0.clone());\n                         }\n                         Activation(_, activating) => {\n-                            debug!(\"observing check_place for activation of \\\n-                                    borrow_index: {:?}\", activating);\n+                            debug!(\n+                                \"observing check_place for activation of \\\n+                                 borrow_index: {:?}\",\n+                                activating\n+                            );\n                         }\n                         Read(..) | Write(..) => {}\n                     }\n@@ -818,8 +836,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::StorageDeadOrDrop => {\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context, borrow, place_span.1,\n-                                flow_state.borrows.operator());\n+                                context,\n+                                borrow,\n+                                place_span.1,\n+                                flow_state.borrows.operator(),\n+                            );\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -917,10 +938,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Use(ref operand) |\n-            Rvalue::Repeat(ref operand, _) |\n-            Rvalue::UnaryOp(_ /*un_op*/, ref operand) |\n-            Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n                 self.consume_operand(context, (operand, span), flow_state)\n             }\n \n@@ -945,8 +966,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n-            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n+            | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n                 self.consume_operand(context, (operand1, span), flow_state);\n                 self.consume_operand(context, (operand2, span), flow_state);\n             }\n@@ -1015,12 +1036,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn check_for_invalidation_at_exit(&mut self,\n-                                      context: Context,\n-                                      borrow: &BorrowData<'tcx>,\n-                                      span: Span,\n-                                      flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-    {\n+    fn check_for_invalidation_at_exit(\n+        &mut self,\n+        context: Context,\n+        borrow: &BorrowData<'tcx>,\n+        span: Span,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n@@ -1061,11 +1083,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // FIXME: replace this with a proper borrow_conflicts_with_place when\n         // that is merged.\n-        let sd = if might_be_alive {\n-            Deep\n-        } else {\n-            Shallow(None)\n-        };\n+        let sd = if might_be_alive { Deep } else { Shallow(None) };\n \n         if self.places_conflict(place, root_place, sd) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n@@ -1075,16 +1093,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 context,\n                 borrow,\n                 span.end_point(),\n-                flow_state.borrows.operator()\n+                flow_state.borrows.operator(),\n             )\n         }\n     }\n \n-    fn check_activations(&mut self,\n-                         location: Location,\n-                         span: Span,\n-                         flow_state: &Flows<'cx, 'gcx, 'tcx>)\n-    {\n+    fn check_activations(\n+        &mut self,\n+        location: Location,\n+        span: Span,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+    ) {\n         if !self.tcx.sess.opts.debugging_opts.two_phase_borrows {\n             return;\n         }\n@@ -1095,8 +1114,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let domain = flow_state.borrows.operator();\n         let data = domain.borrows();\n         flow_state.borrows.each_gen_bit(|gen| {\n-            if gen.is_activation()\n-            {\n+            if gen.is_activation() {\n                 let borrow_index = gen.borrow_index();\n                 let borrow = &data[borrow_index];\n                 // currently the flow analysis registers\n@@ -1105,16 +1123,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // mutable borrow before we check it.\n                 match borrow.kind {\n                     BorrowKind::Shared => return,\n-                    BorrowKind::Unique |\n-                    BorrowKind::Mut => {}\n+                    BorrowKind::Unique | BorrowKind::Mut => {}\n                 }\n \n-                self.access_place(ContextKind::Activation.new(location),\n-                                  (&borrow.borrowed_place, span),\n-                                  (Deep, Activation(WriteKind::MutableBorrow(borrow.kind),\n-                                                    borrow_index)),\n-                                  LocalMutationIsAllowed::No,\n-                                  flow_state);\n+                self.access_place(\n+                    ContextKind::Activation.new(location),\n+                    (&borrow.borrowed_place, span),\n+                    (\n+                        Deep,\n+                        Activation(WriteKind::MutableBorrow(borrow.kind), borrow_index),\n+                    ),\n+                    LocalMutationIsAllowed::No,\n+                    flow_state,\n+                );\n                 // We do not need to call `check_if_path_is_moved`\n                 // again, as we already called it when we made the\n                 // initial reservation.\n@@ -1135,7 +1156,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Ok(()) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n             return;\n         }\n-        debug!(\"check_if_reassignment_to_immutable_state({:?}) - is an imm local\", place);\n+        debug!(\n+            \"check_if_reassignment_to_immutable_state({:?}) - is an imm local\",\n+            place\n+        );\n \n         for i in flow_state.ever_inits.elems_incoming() {\n             let init = self.move_data.inits[i];\n@@ -1364,14 +1388,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         let mut error_reported = false;\n         match kind {\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique)) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n                 if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n                     span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n                 }\n             }\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut)) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n+            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut))\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Mut)) => if let Err(place_err) =\n                 self.is_mutable(place, is_local_mutation_allowed)\n             {\n                 error_reported = true;\n@@ -1393,8 +1417,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 err.emit();\n             },\n-            Reservation(WriteKind::Mutate) |\n-            Write(WriteKind::Mutate) => {\n+            Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n                 if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;\n \n@@ -1415,12 +1438,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n-            Reservation(WriteKind::Move) |\n-            Reservation(WriteKind::StorageDeadOrDrop) |\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Shared)) |\n-            Write(WriteKind::Move) |\n-            Write(WriteKind::StorageDeadOrDrop) |\n-            Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n+            Reservation(WriteKind::Move)\n+            | Reservation(WriteKind::StorageDeadOrDrop)\n+            | Reservation(WriteKind::MutableBorrow(BorrowKind::Shared))\n+            | Write(WriteKind::Move)\n+            | Write(WriteKind::StorageDeadOrDrop)\n+            | Write(WriteKind::MutableBorrow(BorrowKind::Shared)) => {\n                 if let Err(_place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     self.tcx.sess.delay_span_bug(\n                         span,\n@@ -1435,10 +1458,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Activation(..) => {} // permission checks are done at Reservation point.\n \n-            Read(ReadKind::Borrow(BorrowKind::Unique)) |\n-            Read(ReadKind::Borrow(BorrowKind::Mut)) |\n-            Read(ReadKind::Borrow(BorrowKind::Shared)) |\n-            Read(ReadKind::Copy) => {} // Access authorized\n+            Read(ReadKind::Borrow(BorrowKind::Unique))\n+            | Read(ReadKind::Borrow(BorrowKind::Mut))\n+            | Read(ReadKind::Borrow(BorrowKind::Shared))\n+            | Read(ReadKind::Copy) => {} // Access authorized\n         }\n \n         error_reported\n@@ -1455,8 +1478,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes |\n-                        LocalMutationIsAllowed::ExceptUpvars => Ok(()),\n+                        LocalMutationIsAllowed::Yes | LocalMutationIsAllowed::ExceptUpvars => {\n+                            Ok(())\n+                        }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1481,13 +1505,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match\n-                                            self.is_upvar_field_projection(&proj.base)\n+                                        let mode = match self.is_upvar_field_projection(&proj.base)\n                                         {\n-                                            Some(field) if {\n-                                                self.mir.upvar_decls[field.index()].by_ref\n-                                            } => is_local_mutation_allowed,\n-                                            _ => LocalMutationIsAllowed::Yes\n+                                            Some(field)\n+                                                if {\n+                                                    self.mir.upvar_decls[field.index()].by_ref\n+                                                } =>\n+                                            {\n+                                                is_local_mutation_allowed\n+                                            }\n+                                            _ => LocalMutationIsAllowed::Yes,\n                                         };\n \n                                         self.is_mutable(&proj.base, mode)\n@@ -1513,22 +1540,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                     // All other projections are owned by their base path, so mutable if\n                     // base path is mutable\n-                    ProjectionElem::Field(..) |\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::Field(..)\n+                    | ProjectionElem::Index(..)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::Downcast(..) => {\n                         if let Some(field) = self.is_upvar_field_projection(place) {\n                             let decl = &self.mir.upvar_decls[field.index()];\n-                            debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n-                                   decl, is_local_mutation_allowed, place);\n+                            debug!(\n+                                \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                decl,\n+                                is_local_mutation_allowed,\n+                                place\n+                            );\n                             match (decl.mutability, is_local_mutation_allowed) {\n-                                (Mutability::Not, LocalMutationIsAllowed::No) |\n-                                (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars)\n-                                    => Err(place),\n-                                (Mutability::Not, LocalMutationIsAllowed::Yes) |\n-                                (Mutability::Mut, _) =>\n+                                (Mutability::Not, LocalMutationIsAllowed::No)\n+                                | (Mutability::Not, LocalMutationIsAllowed::ExceptUpvars) => {\n+                                    Err(place)\n+                                }\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes)\n+                                | (Mutability::Mut, _) => {\n                                     self.is_mutable(&proj.base, is_local_mutation_allowed)\n+                                }\n                             }\n                         } else {\n                             self.is_mutable(&proj.base, is_local_mutation_allowed)\n@@ -1593,11 +1626,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // Given that the bases of `elem1` and `elem2` are always either equal\n     // or disjoint (and have the same type!), return the overlap situation\n     // between `elem1` and `elem2`.\n-    fn place_element_conflict(&self,\n-                               elem1: &Place<'tcx>,\n-                               elem2: &Place<'tcx>)\n-                               -> Overlap\n-    {\n+    fn place_element_conflict(&self, elem1: &Place<'tcx>, elem2: &Place<'tcx>) -> Overlap {\n         match (elem1, elem2) {\n             (Place::Local(l1), Place::Local(l2)) => {\n                 if l1 == l2 {\n@@ -1623,8 +1652,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Overlap::EqualOrDisjoint\n                 }\n             }\n-            (Place::Local(_), Place::Static(_)) |\n-            (Place::Static(_), Place::Local(_)) => {\n+            (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n                 debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n                 Overlap::Disjoint\n             }\n@@ -1689,15 +1717,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             Overlap::Disjoint\n                         }\n                     }\n-                    (ProjectionElem::Index(..), ProjectionElem::Index(..)) |\n-                    (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::Index(..), ProjectionElem::Subslice { .. }) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..)) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. }) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. }) |\n-                    (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..))\n+                    | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n+                    | (\n+                        ProjectionElem::ConstantIndex { .. },\n+                        ProjectionElem::ConstantIndex { .. },\n+                    )\n+                    | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n+                    | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n                         // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n                         // (if the indexes differ) or equal (if they are the same), so this\n                         // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n@@ -1714,41 +1745,45 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         Overlap::EqualOrDisjoint\n                     }\n \n-                    (ProjectionElem::Deref, _) |\n-                    (ProjectionElem::Field(..), _) |\n-                    (ProjectionElem::Index(..), _) |\n-                    (ProjectionElem::ConstantIndex { .. }, _) |\n-                    (ProjectionElem::Subslice { .. }, _) |\n-                    (ProjectionElem::Downcast(..), _) => {\n-                        bug!(\"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-\n-                             elem1, elem2)\n-                    }\n+                    (ProjectionElem::Deref, _)\n+                    | (ProjectionElem::Field(..), _)\n+                    | (ProjectionElem::Index(..), _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _)\n+                    | (ProjectionElem::Subslice { .. }, _)\n+                    | (ProjectionElem::Downcast(..), _) => bug!(\n+                        \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+                        elem1,\n+                        elem2\n+                    ),\n                 }\n             }\n-            (Place::Projection(_), _) |\n-            (_, Place::Projection(_)) => {\n-                bug!(\"unexpected elements in place_element_conflict: {:?} and {:?}\",\n-                     elem1, elem2)\n-            }\n+            (Place::Projection(_), _) | (_, Place::Projection(_)) => bug!(\n+                \"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                elem1,\n+                elem2\n+            ),\n         }\n     }\n \n     /// Returns whether an access of kind `access` to `access_place` conflicts with\n     /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n     /// locations, this function is symmetric between `borrow_place` & `access_place`).\n-    fn places_conflict(&mut self,\n-                       borrow_place: &Place<'tcx>,\n-                       access_place: &Place<'tcx>,\n-                       access: ShallowOrDeep)\n-                       -> bool\n-    {\n-        debug!(\"places_conflict({:?},{:?},{:?})\", borrow_place, access_place, access);\n+    fn places_conflict(\n+        &mut self,\n+        borrow_place: &Place<'tcx>,\n+        access_place: &Place<'tcx>,\n+        access: ShallowOrDeep,\n+    ) -> bool {\n+        debug!(\n+            \"places_conflict({:?},{:?},{:?})\",\n+            borrow_place,\n+            access_place,\n+            access\n+        );\n \n         // Return all the prefixes of `place` in reverse order, including\n         // downcasts.\n-        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>>\n-        {\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n             let mut result = vec![];\n             let mut place = place;\n             loop {\n@@ -1767,13 +1802,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let borrow_components = place_elements(borrow_place);\n         let access_components = place_elements(access_place);\n-        debug!(\"places_conflict: components {:?} / {:?}\",\n-               borrow_components, access_components);\n+        debug!(\n+            \"places_conflict: components {:?} / {:?}\",\n+            borrow_components,\n+            access_components\n+        );\n \n-        let borrow_components = borrow_components.into_iter()\n-             .map(Some).chain(iter::repeat(None));\n-        let access_components = access_components.into_iter()\n-             .map(Some).chain(iter::repeat(None));\n+        let borrow_components = borrow_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        let access_components = access_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n         // The borrowck rules for proving disjointness are applied from the \"root\" of the\n         // borrow forwards, iterating over \"similar\" projections in lockstep until\n         // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n@@ -1839,13 +1881,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                     let (base, elem) = match borrow_c {\n                         Place::Projection(box Projection { base, elem }) => (base, elem),\n-                        _ => bug!(\"place has no base?\")\n+                        _ => bug!(\"place has no base?\"),\n                     };\n                     let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n                     match (elem, &base_ty.sty, access) {\n-                        (_, _, Shallow(Some(ArtificialField::Discriminant))) |\n-                        (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n                             // The discriminant and array length are like\n                             // additional fields on the type; they do not\n                             // overlap any existing data there. Furthermore,\n@@ -1866,9 +1908,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             debug!(\"places_conflict: shallow access behind ptr\");\n                             return false;\n                         }\n-                        (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n-                            ty: _, mutbl: hir::MutImmutable\n-                        }), _) => {\n+                        (\n+                            ProjectionElem::Deref,\n+                            ty::TyRef(\n+                                _,\n+                                ty::TypeAndMut {\n+                                    ty: _,\n+                                    mutbl: hir::MutImmutable,\n+                                },\n+                            ),\n+                            _,\n+                        ) => {\n                             // the borrow goes through a dereference of a shared reference.\n                             //\n                             // I'm not sure why we are tracking these borrows - shared\n@@ -1878,12 +1928,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return false;\n                         }\n \n-                        (ProjectionElem::Deref, _, Deep) |\n-                        (ProjectionElem::Field { .. }, _, _) |\n-                        (ProjectionElem::Index { ..}, _, _) |\n-                        (ProjectionElem::ConstantIndex { .. }, _, _) |\n-                        (ProjectionElem::Subslice { .. }, _, _) |\n-                        (ProjectionElem::Downcast { .. }, _, _) => {\n+                        (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n                             // Recursive case. This can still be disjoint on a\n                             // further iteration if this a shallow access and\n                             // there's a deref later on, e.g. a borrow\n@@ -1920,7 +1970,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return false;\n                         }\n                     }\n-\n                 }\n             }\n         }\n@@ -1963,7 +2012,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 let ctrl = op(self, i, borrowed);\n-                if ctrl == Control::Break { return; }\n+                if ctrl == Control::Break {\n+                    return;\n+                }\n             }\n         }\n     }"}]}