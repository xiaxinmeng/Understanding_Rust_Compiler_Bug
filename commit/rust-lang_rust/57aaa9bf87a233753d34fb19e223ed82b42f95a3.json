{"sha": "57aaa9bf87a233753d34fb19e223ed82b42f95a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YWFhOWJmODdhMjMzNzUzZDM0ZmIxOWUyMjNlZDgyYjQyZjk1YTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T11:08:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T12:11:48Z"}, "message": "Make supertrait references work in object types too.", "tree": {"sha": "519f79e38a6b86b8dab043b53900a26b63085ab5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/519f79e38a6b86b8dab043b53900a26b63085ab5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57aaa9bf87a233753d34fb19e223ed82b42f95a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57aaa9bf87a233753d34fb19e223ed82b42f95a3", "html_url": "https://github.com/rust-lang/rust/commit/57aaa9bf87a233753d34fb19e223ed82b42f95a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57aaa9bf87a233753d34fb19e223ed82b42f95a3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee58632023c4941408264eeef34a68277773408", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee58632023c4941408264eeef34a68277773408", "html_url": "https://github.com/rust-lang/rust/commit/7ee58632023c4941408264eeef34a68277773408"}], "stats": {"total": 83, "additions": 71, "deletions": 12}, "files": [{"sha": "c616f4feaff02fa9946f7d4e05d539f4c56752bb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/57aaa9bf87a233753d34fb19e223ed82b42f95a3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aaa9bf87a233753d34fb19e223ed82b42f95a3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=57aaa9bf87a233753d34fb19e223ed82b42f95a3", "patch": "@@ -627,7 +627,8 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n         }\n         Some(ref mut v) => {\n             for binding in assoc_bindings.iter() {\n-                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(), binding) {\n+                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n+                                                               self_ty, binding) {\n                     Ok(pp) => { v.push(pp); }\n                     Err(ErrorReported) => { }\n                 }\n@@ -640,10 +641,13 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n \n fn ast_type_binding_to_projection_predicate<'tcx>(\n     this: &AstConv<'tcx>,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    mut trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n     -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n {\n+    let tcx = this.tcx();\n+\n     // Given something like `U : SomeTrait<T=X>`, we want to produce a\n     // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n     // subtle in the event that `T` is defined in a supertrait of\n@@ -671,39 +675,67 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n         });\n     }\n \n-    // Otherwise, we have to walk through the supertraits to find those that do.\n-    let mut candidates: Vec<_> =\n-        traits::supertraits(this.tcx(), trait_ref.to_poly_trait_ref())\n+    // Otherwise, we have to walk through the supertraits to find\n+    // those that do.  This is complicated by the fact that, for an\n+    // object type, the `Self` type is not present in the\n+    // substitutions (after all, it's being constructed right now),\n+    // but the `supertraits` iterator really wants one. To handle\n+    // this, we currently insert a dummy type and then remove it\n+    // later. Yuck.\n+\n+    let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    if self_ty.is_none() { // if converting for an object type\n+        let mut dummy_substs = trait_ref.substs.clone();\n+        assert!(dummy_substs.self_ty().is_none());\n+        dummy_substs.types.push(SelfSpace, dummy_self_ty);\n+        trait_ref = Rc::new(ty::TraitRef::new(trait_ref.def_id,\n+                                              tcx.mk_substs(dummy_substs)));\n+    }\n+\n+    let mut candidates: Vec<ty::PolyTraitRef> =\n+        traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n         .filter(|r| trait_defines_associated_type_named(this, r.def_id(), binding.item_name))\n         .collect();\n \n+    // If converting for an object type, then remove the dummy-ty from `Self` now.\n+    // Yuckety yuck.\n+    if self_ty.is_none() {\n+        for candidate in candidates.iter_mut() {\n+            let mut dummy_substs = candidate.0.substs.clone();\n+            assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n+            dummy_substs.types.pop(SelfSpace);\n+            *candidate = ty::Binder(Rc::new(ty::TraitRef::new(candidate.def_id(),\n+                                                              tcx.mk_substs(dummy_substs))));\n+        }\n+    }\n+\n     if candidates.len() > 1 {\n-        this.tcx().sess.span_err(\n+        tcx.sess.span_err(\n             binding.span,\n             format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidates.user_string(this.tcx())).as_slice());\n+                    candidates.user_string(tcx)).as_slice());\n         return Err(ErrorReported);\n     }\n \n     let candidate = match candidates.pop() {\n         Some(c) => c,\n         None => {\n-            this.tcx().sess.span_err(\n+            tcx.sess.span_err(\n                 binding.span,\n                 format!(\"no associated type `{}` defined in `{}`\",\n                         token::get_name(binding.item_name),\n-                        trait_ref.user_string(this.tcx())).as_slice());\n+                        trait_ref.user_string(tcx)).as_slice());\n             return Err(ErrorReported);\n         }\n     };\n \n-    if ty::binds_late_bound_regions(this.tcx(), &candidate) {\n-        this.tcx().sess.span_err(\n+    if ty::binds_late_bound_regions(tcx, &candidate) {\n+        tcx.sess.span_err(\n             binding.span,\n             format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidate.user_string(this.tcx())).as_slice());\n+                    candidate.user_string(tcx)).as_slice());\n         return Err(ErrorReported);\n     }\n "}, {"sha": "429027cbf304dc219ecd3b23c3ea9cb018edf3d2", "filename": "src/test/run-pass/associated-type-doubleendediterator-object.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/57aaa9bf87a233753d34fb19e223ed82b42f95a3/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aaa9bf87a233753d34fb19e223ed82b42f95a3/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-type-doubleendediterator-object.rs?ref=57aaa9bf87a233753d34fb19e223ed82b42f95a3", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn pairwise_sub(mut t: Box<DoubleEndedIterator<Item=int>>) -> int {\n+    let mut result = 0;\n+    loop {\n+        let front = t.next();\n+        let back = t.next_back();\n+        match (front, back) {\n+            (Some(f), Some(b)) => { result += b - f; }\n+            _ => { return result; }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = vec!(1, 2, 3, 4, 5, 6);\n+    let r = pairwise_sub(box v.into_iter());\n+    assert_eq!(r, 9);\n+}"}]}