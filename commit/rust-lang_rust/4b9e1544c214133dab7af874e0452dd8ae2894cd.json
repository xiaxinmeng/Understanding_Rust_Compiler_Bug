{"sha": "4b9e1544c214133dab7af874e0452dd8ae2894cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWUxNTQ0YzIxNDEzM2RhYjdhZjg3NGUwNDUyZGQ4YWUyODk0Y2Q=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-17T11:42:36Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-17T13:02:31Z"}, "message": "give up on two-phase borrows", "tree": {"sha": "e578cbb1ac4c62e3936c6df988d66c619bead979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e578cbb1ac4c62e3936c6df988d66c619bead979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9e1544c214133dab7af874e0452dd8ae2894cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9e1544c214133dab7af874e0452dd8ae2894cd", "html_url": "https://github.com/rust-lang/rust/commit/4b9e1544c214133dab7af874e0452dd8ae2894cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9e1544c214133dab7af874e0452dd8ae2894cd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3618992a39d6ef81dea38bbf9cd3d332281e55f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3618992a39d6ef81dea38bbf9cd3d332281e55f9", "html_url": "https://github.com/rust-lang/rust/commit/3618992a39d6ef81dea38bbf9cd3d332281e55f9"}], "stats": {"total": 249, "additions": 106, "deletions": 143}, "files": [{"sha": "33d9509bd3f933ebd65f47f7e2917bed014d4788", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 105, "deletions": 142, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/4b9e1544c214133dab7af874e0452dd8ae2894cd/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9e1544c214133dab7af874e0452dd8ae2894cd/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4b9e1544c214133dab7af874e0452dd8ae2894cd", "patch": "@@ -70,10 +70,9 @@ impl fmt::Display for Item {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct Stack {\n     /// Used *mostly* as a stack; never empty.\n-    /// We sometimes push into the middle but never remove from the middle.\n-    /// The same tag may occur multiple times, e.g. from a two-phase borrow.\n     /// Invariants:\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n+    /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n }\n \n@@ -118,7 +117,7 @@ impl fmt::Display for AccessKind {\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum RefKind {\n     /// `&mut` and `Box`.\n-    Unique,\n+    Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n     /// `*mut`/`*const` (raw pointers).\n@@ -128,7 +127,8 @@ pub enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            RefKind::Unique => write!(f, \"unique\"),\n+            RefKind::Unique { two_phase: false } => write!(f, \"unique\"),\n+            RefKind::Unique { two_phase: true } => write!(f, \"unique (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared\"),\n             RefKind::Raw { mutable: true } => write!(f, \"raw (mutable)\"),\n             RefKind::Raw { mutable: false } => write!(f, \"raw (constant)\"),\n@@ -194,65 +194,82 @@ impl Default for Tag {\n     }\n }\n \n-/// Core relations on `Permission` define which accesses are allowed:\n-/// On every access, we try to find a *granting* item, and then we remove all\n-/// *incompatible* items above it.\n+\n+/// Core relation on `Permission` to define which accesses are allowed\n impl Permission {\n     /// This defines for a given permission, whether it permits the given kind of access.\n     fn grants(self, access: AccessKind) -> bool {\n-        match (self, access) {\n-            // Unique and SharedReadWrite allow any kind of access.\n-            (Permission::Unique, _) |\n-            (Permission::SharedReadWrite, _) =>\n-                true,\n-            // SharedReadOnly only permits read access.\n-            (Permission::SharedReadOnly, AccessKind::Read) =>\n-                true,\n-            (Permission::SharedReadOnly, AccessKind::Write) =>\n-                false,\n-        }\n-    }\n-\n-    /// This defines for a given permission, which other permissions it can tolerate \"above\" itself\n-    /// when it is written to.\n-    /// If true, then `other` is allowed to remain on top of `self` when a write access happens.\n-    fn write_compatible_with(self, other: Permission) -> bool {\n-        // Only writes to SharedRW can tolerate any other items above them, and they only\n-        // tolerate other SharedRW.  So, basically, searching the first write-incompatible item above X treats\n-        // consecutive SharedRW as one \"group\", and skips to the first item outside X's group.\n-        return self == Permission::SharedReadWrite && other == Permission::SharedReadWrite;\n+        // All items grant read access, and except for SharedReadOnly they grant write access.\n+        access == AccessKind::Read || self != Permission::SharedReadOnly\n     }\n }\n \n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n-    /// *the first write-incompatible item above it* is on the stack.\n-    fn check_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n-        let (perm, idx) = self.borrows.iter()\n+    /// it is on the stack.\n+    fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<usize> {\n+        self.borrows.iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n             .find_map(|(idx, item)|\n-                if item.perm.grants(access) && tag == item.tag {\n-                    Some((item.perm, idx))\n+                if tag == item.tag && item.perm.grants(access) {\n+                    Some(idx)\n                 } else {\n                     None\n                 }\n-            )?;\n-\n-        let mut first_incompatible_idx = idx+1;\n-        while let Some(item) = self.borrows.get(first_incompatible_idx) {\n-            if perm.write_compatible_with(item.perm) {\n-                // Keep this, check next.\n-                first_incompatible_idx += 1;\n-            } else {\n-                // Found it!\n-                break;\n+            )\n+    }\n+\n+    /// Find the first write-incompatible item above the given one -- \n+    /// i.e, find the heigh to which the stack will be truncated when writing to `granting`.\n+    fn find_first_write_incompaible(&self, granting: usize) -> usize {\n+        let perm = self.borrows[granting].perm;\n+        match perm {\n+            Permission::SharedReadOnly =>\n+                bug!(\"Cannot use SharedReadOnly for writing\"),\n+            Permission::Unique =>\n+                // On a write, everything above us is incompatible.\n+                granting+1,\n+            Permission::SharedReadWrite => {\n+                // The SharedReadWrite *just* above us are compatible, to skip those.\n+                let mut idx = granting+1;\n+                while let Some(item) = self.borrows.get(idx) {\n+                    if item.perm == Permission::SharedReadWrite {\n+                        // Go on.\n+                        idx += 1;\n+                    } else {\n+                        // Found first incompatible!\n+                        break;\n+                    }\n+                }\n+                idx\n+            }\n+        }\n+    }\n+\n+    /// Remove the given item, enforcing barriers.\n+    /// `tag` is just used for the error message.\n+    fn remove(&mut self, idx: usize, tag: Option<Tag>, global: &GlobalState) -> EvalResult<'tcx> {\n+        let item = self.borrows.remove(idx);\n+        if let Some(call) = item.protector {\n+            if global.is_active(call) {\n+                if let Some(tag) = tag {\n+                    return err!(MachineError(format!(\n+                        \"not granting access to tag {} because incompatible item is protected: {}\",\n+                        tag, item\n+                    )));\n+                } else {\n+                    return err!(MachineError(format!(\n+                        \"deallocating while item is protected: {}\", item\n+                    )));\n+                }\n             }\n         }\n-        return Some(first_incompatible_idx);\n+        trace!(\"access: removing item {}\", item);\n+        Ok(())\n     }\n \n     /// Test if a memory `access` using pointer tagged `tag` is granted.\n@@ -266,46 +283,32 @@ impl<'tcx> Stack {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let first_incompatible_idx = self.check_granting(access, tag)\n+        let granting_idx = self.find_granting(access, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting {} access to tag {} found in borrow stack\",\n                 access, tag,\n             )))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n-        //\n-        // For writes, this is a simple stack, where everything starting with the first incompatible item\n-        // gets removed. This makes sure read-only and unique pointers become invalid on write accesses\n-        // (ensures F2a, and ensures U2 for write accesses).\n-        //\n-        // For reads, however, we just filter away the Unique items, which is sufficient to ensure U2 for read\n-        // accesses. The reason is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n-        // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n-        // `SharedReadWrite` for `raw`.\n-        // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n-        // reference and use that.\n-        {\n-            // Implemented with indices because there does not seem to be a nice iterator and range-based\n-            // API for this.\n-            let mut cur = first_incompatible_idx;\n-            while let Some(item) = self.borrows.get(cur) {\n-                // If this is a read, only remove Unique items!\n-                if access == AccessKind::Read && item.perm != Permission::Unique {\n-                    // Keep this, check next.\n-                    cur += 1;\n-                } else {\n-                    // Aha! This is a bad one, remove it, and make sure it is not protected.\n-                    let item = self.borrows.remove(cur);\n-                    if let Some(call) = item.protector {\n-                        if global.is_active(call) {\n-                            return err!(MachineError(format!(\n-                                \"not granting {} access to tag {} because incompatible item {} is protected\",\n-                                access, tag, item\n-                            )));\n-                        }\n-                    }\n-                    trace!(\"access: removing item {}\", item);\n+        if access == AccessKind::Write {\n+            // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n+            // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n+            let first_incompatible_idx = self.find_first_write_incompaible(granting_idx);\n+            for idx in (first_incompatible_idx..self.borrows.len()).rev() {\n+                self.remove(idx, Some(tag), global)?;\n+            }\n+        } else {\n+            // On a read, remove all `Unique` above the granting item.  This ensures U2 for read accesses.\n+            // The reason this is not following the stack discipline is that in\n+            // `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+            // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n+            // `SharedReadWrite` for `raw`.\n+            // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+            // reference and use that.\n+            for idx in (granting_idx+1 .. self.borrows.len()).rev() {\n+                if self.borrows[idx].perm == Permission::Unique {\n+                    self.remove(idx, Some(tag), global)?;\n                 }\n             }\n         }\n@@ -315,29 +318,22 @@ impl<'tcx> Stack {\n     }\n \n     /// Deallocate a location: Like a write access, but also there must be no\n-    /// active protectors at all.\n+    /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n         tag: Tag,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.check_granting(AccessKind::Write, tag)\n+        self.find_granting(AccessKind::Write, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item granting write access for deallocation to tag {} found in borrow stack\",\n                 tag,\n             )))?;\n \n-        // We must make sure there are no protected items remaining on the stack.\n-        // Also clear the stack, no more accesses are possible.\n-        for item in self.borrows.drain(..) {\n-            if let Some(call) = item.protector {\n-                if global.is_active(call) {\n-                    return err!(MachineError(format!(\n-                        \"deallocating with active protector ({})\", call\n-                    )))\n-                }\n-            }\n+        // Step 2: Remove all items.  Also checks for protectors.\n+        for idx in (0..self.borrows.len()).rev() {\n+            self.remove(idx, None, global)?;\n         }\n \n         Ok(())\n@@ -367,7 +363,6 @@ impl<'tcx> Stack {\n     fn grant(\n         &mut self,\n         derived_from: Tag,\n-        weak: bool,\n         new: Item,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n@@ -379,38 +374,26 @@ impl<'tcx> Stack {\n         };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n-        let first_incompatible_idx = self.check_granting(access, derived_from)\n+        let granting_idx = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n                 \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n             )))?;\n \n         // Compute where to put the new item.\n-        // Either way, we ensure that we insert the new item in a way that between\n+        // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if weak {\n-            // A weak SharedReadOnly reborrow might be added below other items, violating the\n-            // invariant that only SharedReadOnly can sit on top of SharedReadOnly.\n-            assert!(new.perm != Permission::SharedReadOnly, \"Weak SharedReadOnly reborrows don't work\");\n-            // A very liberal reborrow because the new pointer does not expect any kind of aliasing guarantee.\n-            // Just insert new permission as child of old permission, and maintain everything else.\n-            // This inserts \"as far down as possible\", which is good because it makes this pointer as\n-            // long-lived as possible *and* we want all the items that are incompatible with this\n-            // to actually get removed from the stack.  If we pushed a `SharedReadWrite` on top of\n-            // a `SharedReadOnly`, we'd violate the invariant that `SaredReadOnly` are at the top\n-            // and we'd allow write access without invalidating frozen shared references!\n-            // This ensures F2b for `SharedReadWrite` by adding the new item below any\n-            // potentially existing `SharedReadOnly`.\n-            first_incompatible_idx\n+        let new_idx = if new.perm == Permission::SharedReadWrite {\n+            assert!(access == AccessKind::Write, \"this case only makes sense for stack-like accesses\");\n+            // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n+            // access.  Instead of popping the stack, we insert the item at the place the stack would\n+            // be popped to (i.e., we insert it above all the write-compatible items).\n+            // This ensures F2b by adding the new item below any potentially existing `SharedReadOnly`.\n+            self.find_first_write_incompaible(granting_idx)\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n-            // Here, creating a reference actually counts as an access, and pops incompatible\n-            // stuff off the stack.\n+            // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n             self.access(access, derived_from, global)?;\n-            if access == AccessKind::Write {\n-                // For write accesses, the position is the same as what it would have been weakly!\n-                assert_eq!(first_incompatible_idx, self.borrows.len());\n-            }\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -541,8 +524,7 @@ impl AllocationExtra<Tag> for Stacks {\n }\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n-/// to grant for which references, when to add protectors, and how to realize two-phase\n-/// borrows in terms of the primitives above.\n+/// to grant for which references, and when to add protectors.\n impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     fn reborrow(\n@@ -551,7 +533,6 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         size: Size,\n         kind: RefKind,\n         new_tag: Tag,\n-        force_weak: bool,\n         protect: bool,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -567,7 +548,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n         let perm = match kind {\n-            RefKind::Unique => Permission::Unique,\n+            RefKind::Unique { two_phase: false } => Permission::Unique,\n+            RefKind::Unique { two_phase: true } => Permission::SharedReadWrite,\n             RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n             RefKind::Shared | RefKind::Raw { mutable: false } => {\n                 // Shared references and *const are a whole different kind of game, the\n@@ -576,19 +558,16 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n-                    let weak = perm == Permission::SharedReadWrite;\n                     let item = Item { perm, tag: new_tag, protector };\n                     alloc.extra.for_each(cur_ptr, size, |stack, global| {\n-                        stack.grant(cur_ptr.tag, force_weak || weak, item, global)\n+                        stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n-        debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n-        let weak = perm == Permission::SharedReadWrite;\n         let item = Item { perm, tag: new_tag, protector };\n         alloc.extra.for_each(ptr, size, |stack, global| {\n-            stack.grant(ptr.tag, force_weak || weak, item, global)\n+            stack.grant(ptr.tag, item, global)\n         })\n     }\n \n@@ -599,7 +578,6 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n-        two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -619,22 +597,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         };\n \n         // Reborrow.\n-        // TODO: With `two_phase == true`, this performs a weak reborrow for a `Unique`. That\n-        // can lead to some possibly surprising effects, if the parent permission is\n-        // `SharedReadWrite` then we now have a `Unique` in the middle of them, which \"splits\"\n-        // them in terms of what remains valid when the `Unique` gets used.  Is that really\n-        // what we want?\n-        this.reborrow(place, size, kind, new_tag, /*force_weak:*/ two_phase, protect)?;\n+        this.reborrow(place, size, kind, new_tag, protect)?;\n         let new_place = place.replace_tag(new_tag);\n-        // Handle two-phase borrows.\n-        if two_phase {\n-            assert!(kind == RefKind::Unique, \"two-phase shared borrows make no sense\");\n-            // Grant read access *to the parent pointer* with the old tag *derived from the new tag* (`new_place`). \n-            // This means the old pointer has multiple items in the stack now, which otherwise cannot happen\n-            // for unique references -- but in this case it precisely expresses the semantics we want.\n-            let old_tag = place.ptr.to_ptr().unwrap().tag;\n-            this.reborrow(new_place, size, RefKind::Shared, old_tag, /*force_weak:*/ false, /*protect:*/ false)?;\n-        }\n \n         // Return new pointer.\n         Ok(new_place.to_ref())\n@@ -656,15 +620,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             match ty.sty {\n                 // References are simple.\n                 ty::Ref(_, _, MutMutable) =>\n-                    Some((RefKind::Unique, kind == RetagKind::FnEntry)),\n+                    Some((RefKind::Unique { two_phase: kind == RetagKind::TwoPhase}, kind == RetagKind::FnEntry)),\n                 ty::Ref(_, _, MutImmutable) =>\n                     Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique, false)),\n+                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique { two_phase: false }, false)),\n                 _ => None,\n             }\n         }\n@@ -675,7 +639,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, protector, kind == RetagKind::TwoPhase)?;\n+            let val = this.retag_reference(val, mutbl, protector)?;\n             this.write_immediate(val, place)?;\n             return Ok(());\n         }\n@@ -711,8 +675,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                     let val = self.ecx.retag_reference(\n                         val,\n                         mutbl,\n-                        protector,\n-                        self.kind == RetagKind::TwoPhase\n+                        protector\n                     )?;\n                     self.ecx.write_immediate(val, place.into())?;\n                 }"}, {"sha": "bf18c9a058cf969685bf8c5c4ab09caa4cb2c5d3", "filename": "tests/compile-fail/stacked_borrows/deallocate_against_barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9e1544c214133dab7af874e0452dd8ae2894cd/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9e1544c214133dab7af874e0452dd8ae2894cd/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=4b9e1544c214133dab7af874e0452dd8ae2894cd", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: deallocating with active protect\n+// error-pattern: deallocating while item is protected\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}]}