{"sha": "e63da0ba000b94c932aa6e166a02cebe9bf2c719", "node_id": "C_kwDOAAsO6NoAKGU2M2RhMGJhMDAwYjk0YzkzMmFhNmUxNjZhMDJjZWJlOWJmMmM3MTk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-27T00:47:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-27T00:47:07Z"}, "message": "Rollup merge of #96370 - compiler-errors:cleanup-report_method_error, r=estebank\n\nCleanup `report_method_error` a bit\n\n1. Remove an unnecessary indentation level\n2. Split out a couple of large functions from this humongo function body", "tree": {"sha": "047b1adb05dd3848bbe31bc3eaed09e429128df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047b1adb05dd3848bbe31bc3eaed09e429128df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e63da0ba000b94c932aa6e166a02cebe9bf2c719", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiaJKLCRBK7hj4Ov3rIwAApJwIAJeU6/WSIcibyBmPI8EQSlli\nyNlP4K7HR6RtL6AcZXcXy8/04AOpYokhf2UddiAIsgG8d7toABGZFr4bdyshrIdG\n74Smd5qHYL0fmgOMfaU4AA2eI+7lUgOBkI/kx8caIVxJVDIHMvWQOoGEIfFADGcy\n+93TwyOdJcDRffcM5fYRnpNiN8cXxInozP4J8pa6M1HeDNjw+MOmjioqSUDNzf96\nqiAG1xGs1k23dIt5kyPlEHUYa8YlwQzSUq6O4iknzB2246+mG3lYzukzlbZZvcVC\nm8O9ZYqF7+kRmdnJnsYEGTQSmj43ooIWzdOJ1egAYYHy5OUUFMou4yCjkB2F0ZI=\n=U7V0\n-----END PGP SIGNATURE-----\n", "payload": "tree 047b1adb05dd3848bbe31bc3eaed09e429128df6\nparent ac46e17c02c7be374827c2f9df899cd053659dff\nparent 2da65da5a753a9c63ac4789afdfccc783a806c61\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1651020427 +0200\ncommitter GitHub <noreply@github.com> 1651020427 +0200\n\nRollup merge of #96370 - compiler-errors:cleanup-report_method_error, r=estebank\n\nCleanup `report_method_error` a bit\n\n1. Remove an unnecessary indentation level\n2. Split out a couple of large functions from this humongo function body\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e63da0ba000b94c932aa6e166a02cebe9bf2c719", "html_url": "https://github.com/rust-lang/rust/commit/e63da0ba000b94c932aa6e166a02cebe9bf2c719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e63da0ba000b94c932aa6e166a02cebe9bf2c719/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac46e17c02c7be374827c2f9df899cd053659dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac46e17c02c7be374827c2f9df899cd053659dff", "html_url": "https://github.com/rust-lang/rust/commit/ac46e17c02c7be374827c2f9df899cd053659dff"}, {"sha": "2da65da5a753a9c63ac4789afdfccc783a806c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/2da65da5a753a9c63ac4789afdfccc783a806c61", "html_url": "https://github.com/rust-lang/rust/commit/2da65da5a753a9c63ac4789afdfccc783a806c61"}], "stats": {"total": 498, "additions": 254, "deletions": 244}, "files": [{"sha": "80c31355fe71dde81b6a7d3db6e914749b1381fe", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 254, "deletions": 244, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/e63da0ba000b94c932aa6e166a02cebe9bf2c719/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63da0ba000b94c932aa6e166a02cebe9bf2c719/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e63da0ba000b94c932aa6e166a02cebe9bf2c719", "patch": "@@ -272,205 +272,82 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                // FIXME(eddyb) this indentation is probably unnecessary.\n-                let mut err = {\n-                    // Suggest clamping down the type if the method that is being attempted to\n-                    // be used exists at all, and the type is an ambiguous numeric type\n-                    // ({integer}/{float}).\n-                    let mut candidates = all_traits(self.tcx)\n-                        .into_iter()\n-                        .filter_map(|info| self.associated_value(info.def_id, item_name));\n-                    // There are methods that are defined on the primitive types and won't be\n-                    // found when exploring `all_traits`, but we also need them to be accurate on\n-                    // our suggestions (#47759).\n-                    let found_assoc = |ty: Ty<'tcx>| {\n-                        simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n-                            .and_then(|simp| {\n-                                tcx.incoherent_impls(simp)\n-                                    .iter()\n-                                    .find_map(|&id| self.associated_value(id, item_name))\n-                            })\n-                            .is_some()\n-                    };\n-                    let found_candidate = candidates.next().is_some()\n-                        || found_assoc(tcx.types.i8)\n-                        || found_assoc(tcx.types.i16)\n-                        || found_assoc(tcx.types.i32)\n-                        || found_assoc(tcx.types.i64)\n-                        || found_assoc(tcx.types.i128)\n-                        || found_assoc(tcx.types.u8)\n-                        || found_assoc(tcx.types.u16)\n-                        || found_assoc(tcx.types.u32)\n-                        || found_assoc(tcx.types.u64)\n-                        || found_assoc(tcx.types.u128)\n-                        || found_assoc(tcx.types.f32)\n-                        || found_assoc(tcx.types.f32);\n-                    if let (true, false, SelfSource::MethodCall(expr), true) = (\n-                        actual.is_numeric(),\n-                        actual.has_concrete_skeleton(),\n-                        source,\n-                        found_candidate,\n-                    ) {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0689,\n-                            \"can't call {} `{}` on ambiguous numeric type `{}`\",\n-                            item_kind,\n-                            item_name,\n-                            ty_str\n-                        );\n-                        let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n-                        match expr.kind {\n-                            ExprKind::Lit(ref lit) => {\n-                                // numeric literal\n-                                let snippet = tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n-\n-                                // If this is a floating point literal that ends with '.',\n-                                // get rid of it to stop this from becoming a member access.\n-                                let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n \n-                                err.span_suggestion(\n-                                    lit.span,\n-                                    &format!(\n-                                        \"you must specify a concrete type for this numeric value, \\\n-                                         like `{}`\",\n-                                        concrete_type\n-                                    ),\n-                                    format!(\"{snippet}_{concrete_type}\"),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                            ExprKind::Path(QPath::Resolved(_, path)) => {\n-                                // local binding\n-                                if let hir::def::Res::Local(hir_id) = path.res {\n-                                    let span = tcx.hir().span(hir_id);\n-                                    let snippet = tcx.sess.source_map().span_to_snippet(span);\n-                                    let filename = tcx.sess.source_map().span_to_filename(span);\n-\n-                                    let parent_node =\n-                                        self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n-                                    let msg = format!(\n-                                        \"you must specify a type for this binding, like `{}`\",\n-                                        concrete_type,\n-                                    );\n-\n-                                    match (filename, parent_node, snippet) {\n-                                        (\n-                                            FileName::Real(_),\n-                                            Node::Local(hir::Local {\n-                                                source: hir::LocalSource::Normal,\n-                                                ty,\n-                                                ..\n-                                            }),\n-                                            Ok(ref snippet),\n-                                        ) => {\n-                                            err.span_suggestion(\n-                                                // account for `let x: _ = 42;`\n-                                                //                  ^^^^\n-                                                span.to(ty\n-                                                    .as_ref()\n-                                                    .map(|ty| ty.span)\n-                                                    .unwrap_or(span)),\n-                                                &msg,\n-                                                format!(\"{}: {}\", snippet, concrete_type),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                        }\n-                                        _ => {\n-                                            err.span_label(span, msg);\n-                                        }\n-                                    }\n-                                }\n+                if self.suggest_constraining_numerical_ty(\n+                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                ) {\n+                    return None;\n+                }\n+\n+                span = item_name.span;\n+\n+                // Don't show generic arguments when the method can't be found in any implementation (#81576).\n+                let mut ty_str_reported = ty_str.clone();\n+                if let ty::Adt(_, generics) = actual.kind() {\n+                    if generics.len() > 0 {\n+                        let mut autoderef = self.autoderef(span, actual);\n+                        let candidate_found = autoderef.any(|(ty, _)| {\n+                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                                self.tcx\n+                                    .inherent_impls(adt_deref.did())\n+                                    .iter()\n+                                    .filter_map(|def_id| self.associated_value(*def_id, item_name))\n+                                    .count()\n+                                    >= 1\n+                            } else {\n+                                false\n                             }\n-                            _ => {}\n-                        }\n-                        err.emit();\n-                        return None;\n-                    } else {\n-                        span = item_name.span;\n-\n-                        // Don't show generic arguments when the method can't be found in any implementation (#81576).\n-                        let mut ty_str_reported = ty_str.clone();\n-                        if let ty::Adt(_, generics) = actual.kind() {\n-                            if generics.len() > 0 {\n-                                let mut autoderef = self.autoderef(span, actual);\n-                                let candidate_found = autoderef.any(|(ty, _)| {\n-                                    if let ty::Adt(adt_deref, _) = ty.kind() {\n-                                        self.tcx\n-                                            .inherent_impls(adt_deref.did())\n-                                            .iter()\n-                                            .filter_map(|def_id| {\n-                                                self.associated_value(*def_id, item_name)\n-                                            })\n-                                            .count()\n-                                            >= 1\n-                                    } else {\n-                                        false\n-                                    }\n-                                });\n-                                let has_deref = autoderef.step_count() > 0;\n-                                if !candidate_found\n-                                    && !has_deref\n-                                    && unsatisfied_predicates.is_empty()\n-                                {\n-                                    if let Some((path_string, _)) = ty_str.split_once('<') {\n-                                        ty_str_reported = path_string.to_string();\n-                                    }\n-                                }\n+                        });\n+                        let has_deref = autoderef.step_count() > 0;\n+                        if !candidate_found && !has_deref && unsatisfied_predicates.is_empty() {\n+                            if let Some((path_string, _)) = ty_str.split_once('<') {\n+                                ty_str_reported = path_string.to_string();\n                             }\n                         }\n+                    }\n+                }\n \n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0599,\n-                            \"no {} named `{}` found for {} `{}` in the current scope\",\n-                            item_kind,\n-                            item_name,\n-                            actual.prefix_string(self.tcx),\n-                            ty_str_reported,\n-                        );\n-                        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n-                            self.suggest_await_before_method(\n-                                &mut err, item_name, actual, cal, span,\n-                            );\n-                        }\n-                        if let Some(span) =\n-                            tcx.resolutions(()).confused_type_with_std_module.get(&span)\n-                        {\n-                            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n-                                err.span_suggestion(\n-                                    *span,\n-                                    \"you are looking for the module in `std`, \\\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0599,\n+                    \"no {} named `{}` found for {} `{}` in the current scope\",\n+                    item_kind,\n+                    item_name,\n+                    actual.prefix_string(self.tcx),\n+                    ty_str_reported,\n+                );\n+                if actual.references_error() {\n+                    err.downgrade_to_delayed_bug();\n+                }\n+\n+                if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+                    self.suggest_await_before_method(\n+                        &mut err, item_name, actual, cal, span,\n+                    );\n+                }\n+                if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            \"you are looking for the module in `std`, \\\n                                      not the primitive type\",\n-                                    format!(\"std::{}\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                        }\n-                        if let ty::RawPtr(_) = &actual.kind() {\n-                            err.note(\n-                                \"try using `<*const T>::as_ref()` to get a reference to the \\\n+                            format!(\"std::{}\", snippet),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                if let ty::RawPtr(_) = &actual.kind() {\n+                    err.note(\n+                        \"try using `<*const T>::as_ref()` to get a reference to the \\\n                                       type behind the pointer: https://doc.rust-lang.org/std/\\\n                                       primitive.pointer.html#method.as_ref\",\n-                            );\n-                            err.note(\n-                                \"using `<*const T>::as_ref()` on a pointer \\\n+                    );\n+                    err.note(\n+                        \"using `<*const T>::as_ref()` on a pointer \\\n                                       which is unaligned or points to invalid \\\n                                       or uninitialized memory is undefined behavior\",\n-                            );\n-                        }\n-                        err\n-                    }\n-                };\n-\n-                if actual.references_error() {\n-                    err.downgrade_to_delayed_bug();\n+                    );\n                 }\n \n                 if let Some(def) = actual.ty_adt_def() {\n@@ -999,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let mut label_span_not_found = || {\n+                let label_span_not_found = |err: &mut DiagnosticBuilder<'_, _>| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n                         let is_string_or_ref_str = match actual.kind() {\n@@ -1085,62 +962,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    let field_receiver =\n-                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n-                                let variant = &def.non_enum_variant();\n-                                self.tcx.find_field_index(item_name, variant).map(|index| {\n-                                    let field = &variant.fields[index];\n-                                    let field_ty = field.ty(tcx, substs);\n-                                    (field, field_ty)\n-                                })\n-                            }\n-                            _ => None,\n-                        });\n-\n-                    if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n-                        let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n-\n-                        if is_accessible {\n-                            if self.is_fn_ty(field_ty, span) {\n-                                let expr_span = expr.span.to(item_name.span);\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"to call the function stored in `{}`, \\\n-                                         surround the field access with parentheses\",\n-                                        item_name,\n-                                    ),\n-                                    vec![\n-                                        (expr_span.shrink_to_lo(), '('.to_string()),\n-                                        (expr_span.shrink_to_hi(), ')'.to_string()),\n-                                    ],\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                let call_expr = self\n-                                    .tcx\n-                                    .hir()\n-                                    .expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-\n-                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"remove the arguments\",\n-                                        String::new(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        }\n-\n-                        let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n-                        err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n-                    } else if lev_candidate.is_none() && !custom_span_label {\n-                        label_span_not_found();\n+                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                        && lev_candidate.is_none()\n+                        && !custom_span_label\n+                    {\n+                        label_span_not_found(&mut err);\n                     }\n                 } else if !custom_span_label {\n-                    label_span_not_found();\n+                    label_span_not_found(&mut err);\n                 }\n \n                 if let SelfSource::MethodCall(expr) = source\n@@ -1327,6 +1156,187 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn suggest_field_call(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        expr: &hir::Expr<'_>,\n+        item_name: Ident,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let field_receiver = self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n+            ty::Adt(def, substs) if !def.is_enum() => {\n+                let variant = &def.non_enum_variant();\n+                tcx.find_field_index(item_name, variant).map(|index| {\n+                    let field = &variant.fields[index];\n+                    let field_ty = field.ty(tcx, substs);\n+                    (field, field_ty)\n+                })\n+            }\n+            _ => None,\n+        });\n+        if let Some((field, field_ty)) = field_receiver {\n+            let scope = tcx.parent_module(self.body_id).to_def_id();\n+            let is_accessible = field.vis.is_accessible_from(scope, tcx);\n+\n+            if is_accessible {\n+                if self.is_fn_ty(field_ty, span) {\n+                    let expr_span = expr.span.to(item_name.span);\n+                    err.multipart_suggestion(\n+                        &format!(\n+                            \"to call the function stored in `{}`, \\\n+                                         surround the field access with parentheses\",\n+                            item_name,\n+                        ),\n+                        vec![\n+                            (expr_span.shrink_to_lo(), '('.to_string()),\n+                            (expr_span.shrink_to_hi(), ')'.to_string()),\n+                        ],\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+                    if let Some(span) = call_expr.span.trim_start(item_name.span) {\n+                        err.span_suggestion(\n+                            span,\n+                            \"remove the arguments\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+\n+            let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n+            err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn suggest_constraining_numerical_ty(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        actual: Ty<'tcx>,\n+        source: SelfSource<'_>,\n+        span: Span,\n+        item_kind: &str,\n+        item_name: Ident,\n+        ty_str: &str,\n+    ) -> bool {\n+        let found_candidate = all_traits(self.tcx)\n+            .into_iter()\n+            .any(|info| self.associated_value(info.def_id, item_name).is_some());\n+        let found_assoc = |ty: Ty<'tcx>| {\n+            simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+                .and_then(|simp| {\n+                    tcx.incoherent_impls(simp)\n+                        .iter()\n+                        .find_map(|&id| self.associated_value(id, item_name))\n+                })\n+                .is_some()\n+        };\n+        let found_candidate = found_candidate\n+            || found_assoc(tcx.types.i8)\n+            || found_assoc(tcx.types.i16)\n+            || found_assoc(tcx.types.i32)\n+            || found_assoc(tcx.types.i64)\n+            || found_assoc(tcx.types.i128)\n+            || found_assoc(tcx.types.u8)\n+            || found_assoc(tcx.types.u16)\n+            || found_assoc(tcx.types.u32)\n+            || found_assoc(tcx.types.u64)\n+            || found_assoc(tcx.types.u128)\n+            || found_assoc(tcx.types.f32)\n+            || found_assoc(tcx.types.f32);\n+        if found_candidate\n+            && actual.is_numeric()\n+            && !actual.has_concrete_skeleton()\n+            && let SelfSource::MethodCall(expr) = source\n+        {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0689,\n+                \"can't call {} `{}` on ambiguous numeric type `{}`\",\n+                item_kind,\n+                item_name,\n+                ty_str\n+            );\n+            let concrete_type = if actual.is_integral() { \"i32\" } else { \"f32\" };\n+            match expr.kind {\n+                ExprKind::Lit(ref lit) => {\n+                    // numeric literal\n+                    let snippet = tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(lit.span)\n+                        .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n+\n+                    // If this is a floating point literal that ends with '.',\n+                    // get rid of it to stop this from becoming a member access.\n+                    let snippet = snippet.strip_suffix('.').unwrap_or(&snippet);\n+\n+                    err.span_suggestion(\n+                        lit.span,\n+                        &format!(\n+                            \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n+                            concrete_type\n+                        ),\n+                        format!(\"{snippet}_{concrete_type}\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ExprKind::Path(QPath::Resolved(_, path)) => {\n+                    // local binding\n+                    if let hir::def::Res::Local(hir_id) = path.res {\n+                        let span = tcx.hir().span(hir_id);\n+                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n+                        let filename = tcx.sess.source_map().span_to_filename(span);\n+\n+                        let parent_node =\n+                            self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                        let msg = format!(\n+                            \"you must specify a type for this binding, like `{}`\",\n+                            concrete_type,\n+                        );\n+\n+                        match (filename, parent_node, snippet) {\n+                            (\n+                                FileName::Real(_),\n+                                Node::Local(hir::Local {\n+                                    source: hir::LocalSource::Normal,\n+                                    ty,\n+                                    ..\n+                                }),\n+                                Ok(ref snippet),\n+                            ) => {\n+                                err.span_suggestion(\n+                                    // account for `let x: _ = 42;`\n+                                    //                  ^^^^\n+                                    span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n+                                    &msg,\n+                                    format!(\"{}: {}\", snippet, concrete_type),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            _ => {\n+                                err.span_label(span, msg);\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            err.emit();\n+            return true;\n+        }\n+        false\n+    }\n+\n     crate fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,"}]}