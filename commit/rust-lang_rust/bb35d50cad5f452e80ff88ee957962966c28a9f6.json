{"sha": "bb35d50cad5f452e80ff88ee957962966c28a9f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMzVkNTBjYWQ1ZjQ1MmU4MGZmODhlZTk1Nzk2Mjk2NmMyOGE5ZjY=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-16T16:21:49Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-29T01:09:13Z"}, "message": "Refactor TyTrait to contain a interned ExistentialPredicate slice.\n\nRenames TyTrait to TyDynamic.", "tree": {"sha": "78d3195a09bd810ebf42bdab1d45b80bee97d28b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78d3195a09bd810ebf42bdab1d45b80bee97d28b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb35d50cad5f452e80ff88ee957962966c28a9f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb35d50cad5f452e80ff88ee957962966c28a9f6", "html_url": "https://github.com/rust-lang/rust/commit/bb35d50cad5f452e80ff88ee957962966c28a9f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb35d50cad5f452e80ff88ee957962966c28a9f6/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64e97d9b33ac7a38ec9f0ae1575771cdad4afac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/64e97d9b33ac7a38ec9f0ae1575771cdad4afac0", "html_url": "https://github.com/rust-lang/rust/commit/64e97d9b33ac7a38ec9f0ae1575771cdad4afac0"}], "stats": {"total": 1129, "additions": 614, "deletions": 515}, "files": [{"sha": "cf985a0d980b4a640e9d3018cf1740cc4ad2a447", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -140,7 +140,7 @@ DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n-                     rustc_const_eval rustc_errors\n+                     rustc_const_eval rustc_errors rustc_data_structures\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts test \\\n                 rustc_lint rustc_const_eval syntax_pos rustc_data_structures"}, {"sha": "19183892e4b0c16cb68629d14b3ad7212341e9d6", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyRef(..) |\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "58cb52e897786a5687a0fe6eb13ea2f1bfa1cd1a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -227,7 +227,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) => true,\n         ty::TyAdt(def, _) => def.is_fundamental(),\n-        ty::TyTrait(ref data) => {\n+        ty::TyDynamic(ref data, ..) => {\n             data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n         }\n         _ => false\n@@ -270,7 +270,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             krate == Some(LOCAL_CRATE)\n         }\n \n-        ty::TyTrait(ref tt) => {\n+        ty::TyDynamic(ref tt, ..) => {\n             tt.principal().map_or(false, |p| p.def_id().is_local())\n         }\n "}, {"sha": "2e8e45468ddcb2199f0cb417ee8ba45ff80db168", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n                 ty::TyArray(..) | ty::TySlice(..) => Some(6),\n                 ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n-                ty::TyTrait(..) => Some(8),\n+                ty::TyDynamic(..) => Some(8),\n                 ty::TyClosure(..) => Some(9),\n                 ty::TyTuple(..) => Some(10),\n                 ty::TyProjection(..) => Some(11),"}, {"sha": "23c28037a3c2d7b629f211c195446299032a6e0d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -231,10 +231,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_bound(&mut self,\n-                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  def_id: DefId,\n-                                  cause: ObligationCause<'tcx>)\n+                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          def_id: DefId,\n+                          cause: ObligationCause<'tcx>)\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: def_id,"}, {"sha": "5c5bf130c3ba401ee28b00499fddca56a754429d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -366,10 +366,10 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        ty: Ty<'tcx>,\n-                                                        def_id: DefId,\n-                                                        span: Span)\n-                                                        -> bool\n+                                                ty: Ty<'tcx>,\n+                                                def_id: DefId,\n+                                                span: Span)\n+-> bool\n {\n     debug!(\"type_known_to_meet_bound(ty={:?}, bound={:?})\",\n            ty,"}, {"sha": "27b7adf0ef34a3887e7dc275fbfc29849ff7bc39", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -1123,15 +1123,15 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n-        ty::TyTrait(ref data) => data,\n+        ty::TyDynamic(ref data, ..) => data,\n         _ => {\n             span_bug!(\n                 obligation.cause.span,\n                 \"confirm_object_candidate called with non-object: {:?}\",\n                 object_ty)\n         }\n     };\n-    let env_predicates = data.projection_bounds.iter().map(|p| {\n+    let env_predicates = data.projection_bounds().map(|p| {\n         p.with_self_ty(selcx.tcx(), object_ty).to_predicate()\n     }).collect();\n     let env_predicate = {"}, {"sha": "a23b021cd4f4a67b1be16d2302608fdde85e38e9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 64, "deletions": 80, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -50,7 +50,6 @@ use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n use std::rc::Rc;\n-use std::iter;\n use syntax::abi::Abi;\n use hir;\n use util::nodemap::FxHashMap;\n@@ -1094,38 +1093,30 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // and applicable impls. There is a certain set of precedence rules here.\n \n         let def_id = obligation.predicate.def_id();\n-        match obligation.predicate.def_id() {\n-            _ if self.tcx().lang_items.copy_trait() == Some(def_id) => {\n-                debug!(\"obligation self ty is {:?}\",\n-                       obligation.predicate.0.self_ty());\n-\n-                // User-defined copy impls are permitted, but only for\n-                // structs and enums.\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-\n-                // For other types, we'll use the builtin rules.\n-                let copy_conditions = self.copy_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-            }\n-            _ if self.tcx().lang_items.sized_trait() == Some(def_id) => {\n-                // Sized is never implementable by end-users, it is\n-                // always automatically computed.\n-                let sized_conditions = self.sized_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(sized_conditions,\n-                                                       &mut candidates)?;\n-            }\n-\n-            _ if self.tcx().lang_items.unsize_trait() == Some(def_id) => {\n-                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-            }\n-\n-            // For non-builtins and Send/Sync\n-            _ => {\n-                self.assemble_closure_candidates(obligation, &mut candidates)?;\n-                self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-            }\n+        if self.tcx().lang_items.copy_trait() == Some(def_id) {\n+            debug!(\"obligation self ty is {:?}\",\n+                   obligation.predicate.0.self_ty());\n+\n+            // User-defined copy impls are permitted, but only for\n+            // structs and enums.\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+\n+            // For other types, we'll use the builtin rules.\n+            let copy_conditions = self.copy_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if self.tcx().lang_items.sized_trait() == Some(def_id) {\n+            // Sized is never implementable by end-users, it is\n+            // always automatically computed.\n+            let sized_conditions = self.sized_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(sized_conditions,\n+                                                   &mut candidates)?;\n+         } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n+             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+         } else {\n+             self.assemble_closure_candidates(obligation, &mut candidates)?;\n+             self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n@@ -1446,7 +1437,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if self.tcx().trait_has_default_impl(def_id) {\n             match self_ty.sty {\n-                ty::TyTrait(..) => {\n+                ty::TyDynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. For most traits, this means we\n                     // conservatively say nothing; a candidate may be\n@@ -1516,7 +1507,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n-                ty::TyTrait(ref data) => {\n+                ty::TyDynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n                         debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                     pushing candidate\");\n@@ -1525,7 +1516,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n \n                     match data.principal() {\n-                        Some(ref p) => p.with_self_ty(this.tcx(), self_ty),\n+                        Some(p) => p.with_self_ty(this.tcx(), self_ty),\n                         None => return,\n                     }\n                 }\n@@ -1598,7 +1589,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, ..), &ty::TyDynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1611,7 +1602,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n                 match (data_a.principal(), data_b.principal()) {\n-                    (Some(ref a), Some(ref b)) => a.def_id() == b.def_id() &&\n+                    (Some(a), Some(b)) => a.def_id() == b.def_id() &&\n                         data_b.auto_traits()\n                             // All of a's auto traits need to be in b's auto traits.\n                             .all(|b| data_a.auto_traits().any(|a| a == b)),\n@@ -1620,7 +1611,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(_)) => true,\n+            (_, &ty::TyDynamic(..)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n@@ -1772,7 +1763,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n+            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) => Never,\n \n             ty::TyTuple(tys) => {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n@@ -1818,7 +1809,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) | ty::TyTrait(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyBox(_) | ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyClosure(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n@@ -1883,7 +1874,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Vec::new()\n             }\n \n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n@@ -2169,11 +2160,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, ..) => {\n                 // OK to skip the binder, it is reintroduced below\n                 let principal = data.principal().unwrap();\n                 let input_types = principal.input_types();\n-                let assoc_types = data.projection_bounds.iter()\n+                let assoc_types = data.projection_bounds()\n                                       .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.chain(assoc_types)\n                                                    .collect();\n@@ -2305,7 +2296,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, ..) => {\n                 data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n@@ -2474,14 +2465,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                let new_trait = tcx.mk_trait(ty::TraitObject::new(\n-                    data_a.principal(),\n-                    data_b.region_bound,\n-                    data_b.auto_traits().collect(),\n-                    data_a.projection_bounds.clone(),\n-                ));\n+                // Binders reintroduced below in call to mk_existential_predicates.\n+                let principal = data_a.skip_binder().principal();\n+                let iter = principal.into_iter().map(ty::ExistentialPredicate::Trait)\n+                    .chain(data_a.skip_binder().projection_bounds()\n+                           .map(|x| ty::ExistentialPredicate::Projection(x)))\n+                    .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                let new_trait = tcx.mk_dynamic(\n+                    ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n@@ -2491,17 +2484,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let outlives = ty::OutlivesPredicate(data_a.region_bound,\n-                                                     data_b.region_bound);\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(ref data)) => {\n+            (_, &ty::TyDynamic(ref data, r)) => {\n                 let mut object_dids =\n-                    data.auto_traits().chain(data.principal().map(|ref p| p.def_id()));\n+                    data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2517,35 +2509,27 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                        predicate));\n                 };\n \n-                // Create the obligation for casting from T to Trait.\n-                push(data.principal().unwrap().with_self_ty(tcx, source).to_predicate());\n-\n-                // We can only make objects from sized types.\n-                let trait_refs = data.auto_traits()\n-                    .chain(iter::once(\n-                            tcx.lang_items.require(lang_items::SizedTraitLangItem)\n-                            .unwrap_or_else(|msg| tcx.sess.fatal(&msg[..]))))\n-                    .map(|did| ty::TraitRef {\n-                        def_id: did,\n-                        substs: tcx.mk_substs_trait(source, &[]),\n-                    });\n-\n-                // Create additional obligations for all the various builtin\n-                // bounds attached to the object cast. (In other words, if the\n-                // object type is Foo+Send, this would create an obligation\n-                // for the Send check.)\n-                for tr in trait_refs {\n-                    push(tr.to_predicate());\n+                // Create obligations:\n+                //  - Casting T to Trait\n+                //  - For all the various builtin bounds attached to the object cast. (In other\n+                //  words, if the object type is Foo+Send, this would create an obligation for the\n+                //  Send check.)\n+                //  - Projection predicates\n+                for predicate in data.iter() {\n+                    push(predicate.with_self_ty(tcx, source));\n                 }\n \n-                // Create obligations for the projection predicates.\n-                for bound in &data.projection_bounds {\n-                    push(bound.with_self_ty(tcx, source).to_predicate());\n-                }\n+                // We can only make objects from sized types.\n+                let tr = ty::TraitRef {\n+                    def_id: tcx.lang_items.require(lang_items::SizedTraitLangItem)\n+                        .unwrap_or_else(|msg| tcx.sess.fatal(&msg[..])),\n+                    substs: tcx.mk_substs_trait(source, &[]),\n+                };\n+                push(tr.to_predicate());\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source, data.region_bound);\n+                let outlives = ty::OutlivesPredicate(source, r);\n                 push(ty::Binder(outlives).to_predicate());\n             }\n "}, {"sha": "8c3cb7929488064cb3982949452d352e121388bd", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     tc_ty(tcx, typ, cache).owned_pointer()\n                 }\n \n-                ty::TyTrait(_) => {\n+                ty::TyDynamic(..) => {\n                     TC::All - TC::InteriorParam\n                 }\n "}, {"sha": "c23ee489a28f41128e6d5714e25085d944ac6f5b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -29,7 +29,7 @@ use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -47,6 +47,7 @@ use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::iter;\n+use std::cmp::Ordering;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n@@ -63,6 +64,7 @@ pub struct CtxtArenas<'tcx> {\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n     layout: TypedArena<Layout>,\n+    existential_predicates: TypedArena<ExistentialPredicate<'tcx>>,\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n@@ -81,6 +83,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n             layout: TypedArena::new(),\n+            existential_predicates: TypedArena::new(),\n \n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n@@ -103,6 +106,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n     stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n     layout: RefCell<FxHashSet<&'tcx Layout>>,\n+    existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -115,7 +119,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             bare_fn: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             stability: RefCell::new(FxHashSet()),\n-            layout: RefCell::new(FxHashSet())\n+            layout: RefCell::new(FxHashSet()),\n+            existential_predicates: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -958,6 +963,27 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n+    type Lifted = &'tcx Slice<ExistentialPredicate<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+        -> Option<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(Slice::empty());\n+        }\n+        if let Some(&Interned(eps)) = tcx.interners.existential_predicates.borrow().get(&self[..]) {\n+            if *self as *const _ == eps as *const _ {\n+                return Some(eps);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n     type Lifted = &'tcx BareFnTy<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1126,7 +1152,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1200,6 +1226,13 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n+    for Interned<'tcx, Slice<ExistentialPredicate<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1297,6 +1330,7 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n     type_list: _intern_type_list(Ty),\n     substs: _intern_substs(Kind)\n );\n@@ -1437,24 +1471,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n-        obj.projection_bounds.sort_by_key(|b| b.sort_key(self));\n-        self.mk_ty(TyTrait(box obj))\n+    pub fn mk_dynamic(\n+        self,\n+        obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n+        reg: &'tcx ty::Region\n+    ) -> Ty<'tcx> {\n+        self.mk_ty(TyDynamic(obj, reg))\n     }\n \n     pub fn mk_projection(self,\n                          trait_ref: TraitRef<'tcx>,\n                          item_name: Name)\n-                         -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n-        self.mk_ty(TyProjection(inner))\n-    }\n+        -> Ty<'tcx> {\n+            // take a copy of substs so that we own the vectors inside\n+            let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+            self.mk_ty(TyProjection(inner))\n+        }\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>)\n-                      -> Ty<'tcx> {\n+        -> Ty<'tcx> {\n         self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n             substs: substs\n         })\n@@ -1501,6 +1538,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyAnon(def_id, substs))\n     }\n \n+    pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n+        -> &'tcx Slice<ExistentialPredicate<'tcx>> {\n+        assert!(!eps.is_empty());\n+        assert!(eps.windows(2).all(|w| w[0].cmp(self, &w[1]) != Ordering::Greater));\n+        self._intern_existential_predicates(eps)\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n         if ts.len() == 0 {\n             Slice::empty()\n@@ -1517,6 +1561,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n+                                     &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n+                                     -> I::Output {\n+        iter.intern_with(|xs| self.intern_existential_predicates(xs))\n+    }\n+\n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n                         &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))"}, {"sha": "125ee0a02c814a7f77c67d76ac6654e8014a0362", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -49,7 +49,8 @@ pub enum TypeError<'tcx> {\n     CyclicTy,\n     ProjectionNameMismatched(ExpectedFound<Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -164,6 +165,10 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.expected.ty,\n                        values.found.ty)\n             }\n+            ExistentialMismatch(ref values) => {\n+                report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n+                                       format!(\"trait `{}`\", values.found))\n+            }\n         }\n     }\n }\n@@ -200,7 +205,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n-            ty::TyTrait(ref inner) => {\n+            ty::TyDynamic(ref inner, ..) => {\n                 inner.principal().map_or_else(|| \"trait\".to_string(),\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }"}, {"sha": "9791ccb101380716c1dc4d68f889c9803df5b7db", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -59,7 +59,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(ArraySimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n-        ty::TyTrait(ref trait_info) => {\n+        ty::TyDynamic(ref trait_info, ..) => {\n             trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n         ty::TyRef(_, mt) => {"}, {"sha": "2bcbccb7d0505933e55f6dddfe4ed61fd60a144f", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -121,16 +121,21 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyTrait(ref obj) => {\n+            &ty::TyDynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(obj.principal().unwrap().skip_binder().substs);\n-                for projection_bound in &obj.projection_bounds {\n-                    let mut proj_computation = FlagComputation::new();\n-                    proj_computation.add_existential_projection(&projection_bound.0);\n-                    self.add_bound_computation(&proj_computation);\n+                for predicate in obj.skip_binder().iter() {\n+                    match *predicate {\n+                        ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n+                        ty::ExistentialPredicate::Projection(p) => {\n+                            let mut proj_computation = FlagComputation::new();\n+                            proj_computation.add_existential_projection(&p);\n+                            self.add_bound_computation(&proj_computation);\n+                        }\n+                        ty::ExistentialPredicate::AutoTrait(_) => {}\n+                    }\n                 }\n                 self.add_bound_computation(&computation);\n-                self.add_region(obj.region_bound);\n+                self.add_region(r);\n             }\n \n             &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {"}, {"sha": "440a3916786fa3224fb25ecf8bc6a002d6fa8c77", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -316,7 +316,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyAdt(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyTrait(ref data) => data.principal().map(|ref p| p.def_id()),\n+        ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) |"}, {"sha": "8646bccf1e9ed75d91856385a5d2b7e3865f0ffe", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -924,7 +924,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         ty::TySlice(_) | ty::TyStr => {\n                             Int(dl.ptr_sized_integer())\n                         }\n-                        ty::TyTrait(_) => Pointer,\n+                        ty::TyDynamic(..) => Pointer,\n                         _ => return Err(LayoutError::Unknown(unsized_part))\n                     };\n                     FatPointer { metadata: meta, non_zero: non_zero }\n@@ -963,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     non_zero: false\n                 }\n             }\n-            ty::TyTrait(_) => {\n+            ty::TyDynamic(..) => {\n                 let mut unit = Struct::new(dl, false);\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }"}, {"sha": "86fe14ea504b6e1682815679a9de95cce5c78856", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -54,7 +54,7 @@ use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n@@ -1712,7 +1712,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 vec![]\n             }\n \n-            TyStr | TyTrait(..) | TySlice(_) | TyError => {\n+            TyStr | TyDynamic(..) | TySlice(_) | TyError => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }"}, {"sha": "eb384eec6a6f1e3b583fcf5e0f355a023f0c6158", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyTuple(..) |       // ...\n             ty::TyFnDef(..) |       // OutlivesFunction (*)\n             ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-            ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::TyDynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n             ty::TyError => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the"}, {"sha": "8cb1483107ff119d3e0b5018fef3db5157a5a49b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -398,26 +398,15 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n \n-        (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n-        {\n-            let principal = match (a_obj.principal(), b_obj.principal()) {\n-                (Some(ref a_p), Some(ref b_p)) => Some(relation.relate(a_p, b_p)?),\n-                (None, None) => None,\n-                _ => return Err(TypeError::Sorts(expected_found(relation, &a, &b))),\n-            };\n-            let r =\n-                relation.with_cause(\n-                    Cause::ExistentialRegionBound,\n-                    |relation| relation.relate_with_variance(ty::Contravariant,\n-                                                             &a_obj.region_bound,\n-                                                             &b_obj.region_bound))?;\n-            let nb = if !a_obj.auto_traits().eq(b_obj.auto_traits()) {\n-                return Err(TypeError::Sorts(expected_found(relation, &a, &b)));\n-            } else {\n-                a_obj.auto_traits().collect()\n-            };\n-            let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n-            Ok(tcx.mk_trait(ty::TraitObject::new(principal, r, nb, pb)))\n+        (&ty::TyDynamic(ref a_obj, ref a_region), &ty::TyDynamic(ref b_obj, ref b_region)) => {\n+            let region_bound = relation.with_cause(Cause::ExistentialRegionBound,\n+                                                       |relation| {\n+                                                           relation.relate_with_variance(\n+                                                               ty::Contravariant,\n+                                                               a_region,\n+                                                               b_region)\n+                                                       })?;\n+            Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n         (&ty::TyClosure(a_id, a_substs),\n@@ -513,6 +502,31 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Self,\n+                           b: &Self)\n+        -> RelateResult<'tcx, Self>\n+            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+\n+        if a.len() != b.len() {\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+        }\n+\n+        let tcx = relation.tcx();\n+        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n+            use ty::ExistentialPredicate::*;\n+            match (*ep_a, *ep_b) {\n+                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)))\n+            }\n+        });\n+        Ok(tcx.mk_existential_predicates(v)?)\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::ClosureSubsts<'tcx>,"}, {"sha": "88de3575274cc4a8ea22ea69e49f1e275c48238a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -324,6 +324,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             TyParamDefaultMismatch(ref x) => {\n                 return tcx.lift(x).map(TyParamDefaultMismatch)\n             }\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n }\n@@ -426,20 +427,33 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitObject::new(\n-            self.principal().map(|p| p.fold_with(folder)),\n-            self.region_bound.fold_with(folder),\n-            self.auto_traits().collect(),\n-            self.projection_bounds.fold_with(folder),\n-        )\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_existential_predicates(&v)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.principal().map(|p| p.visit_with(visitor)).unwrap_or(true) ||\n-        self.region_bound.visit_with(visitor) ||\n-        self.projection_bounds.visit_with(visitor)\n+        self.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self  {\n+        use ty::ExistentialPredicate::*;\n+        match *self {\n+            Trait(ref tr) => Trait(tr.fold_with(folder)),\n+            Projection(ref p) => Projection(p.fold_with(folder)),\n+            AutoTrait(did) => AutoTrait(did),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ty::ExistentialPredicate::Trait(ref tr) => tr.visit_with(visitor),\n+            ty::ExistentialPredicate::Projection(ref p) => p.visit_with(visitor),\n+            ty::ExistentialPredicate::AutoTrait(_) => false,\n+        }\n     }\n }\n \n@@ -462,7 +476,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n-            ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n+            ty::TyDynamic(ref trait_ty, ref region) =>\n+                ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n             ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n@@ -499,7 +514,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n-            ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n+            ty::TyDynamic(ref trait_ty, ref reg) =>\n+                trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)"}, {"sha": "667db5b673054e437330923fb54077e4222af13f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 139, "deletions": 55, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -16,8 +16,11 @@ use middle::region;\n use ty::subst::Substs;\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n+use ty::subst::Kind;\n \n use std::fmt;\n+use std::iter;\n+use std::cmp::Ordering;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::symbol::{keywords, InternedString};\n@@ -144,7 +147,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyTrait(Box<TraitObject<'tcx>>),\n+    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -272,32 +275,103 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct TraitObject<'tcx> {\n-    principal: Option<PolyExistentialTraitRef<'tcx>>,\n-    pub region_bound: &'tcx ty::Region,\n-    auto_traits: Vec<DefId>,\n-    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ExistentialPredicate<'tcx> {\n+    // e.g. Iterator\n+    Trait(ExistentialTraitRef<'tcx>),\n+    // e.g. Iterator::Item = T\n+    Projection(ExistentialProjection<'tcx>),\n+    // e.g. Send\n+    AutoTrait(DefId),\n }\n \n-impl<'tcx> TraitObject<'tcx> {\n-    pub fn new(principal: Option<PolyExistentialTraitRef<'tcx>>, region_bound: &'tcx ty::Region,\n-               auto_traits: Vec<DefId>, projection_bounds: Vec<PolyExistentialProjection<'tcx>>)\n-        -> Self {\n-        TraitObject {\n-            principal: principal,\n-            region_bound: region_bound,\n-            auto_traits: auto_traits,\n-            projection_bounds: projection_bounds,\n+impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n+    pub fn cmp(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, other: &Self) -> Ordering {\n+        use self::ExistentialPredicate::*;\n+        match (*self, *other) {\n+            (Trait(_), Trait(_)) => Ordering::Equal,\n+            (Projection(ref a), Projection(ref b)) => a.sort_key(tcx).cmp(&b.sort_key(tcx)),\n+            (AutoTrait(ref a), AutoTrait(ref b)) =>\n+                tcx.lookup_trait_def(*a).def_path_hash.cmp(&tcx.lookup_trait_def(*b).def_path_hash),\n+            (Trait(_), _) => Ordering::Less,\n+            (Projection(_), Trait(_)) => Ordering::Greater,\n+            (Projection(_), _) => Ordering::Less,\n+            (AutoTrait(_), _) => Ordering::Greater,\n+        }\n+    }\n+\n+}\n+\n+impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::Predicate<'tcx> {\n+        use ty::ToPredicate;\n+        match *self.skip_binder() {\n+            ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n+            ExistentialPredicate::Projection(p) =>\n+                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty))),\n+            ExistentialPredicate::AutoTrait(did) => {\n+                let trait_ref = Binder(ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n+                trait_ref.to_predicate()\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<ExistentialPredicate<'tcx>> {}\n+\n+impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n+    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n+        match self.get(0) {\n+            Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n+            _ => None\n         }\n     }\n \n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::Projection(p) => Some(p),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::AutoTrait(d) => Some(d),\n+                _ => None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n-        self.principal\n+        self.skip_binder().principal().map(Binder)\n+    }\n+\n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=PolyExistentialProjection<'tcx>> + 'a {\n+        self.skip_binder().projection_bounds().map(Binder)\n     }\n \n+    #[inline]\n     pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n-        self.auto_traits.iter().cloned()\n+        self.skip_binder().auto_traits()\n+    }\n+\n+    pub fn iter<'a>(&'a self)\n+        -> impl DoubleEndedIterator<Item=Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n+        self.skip_binder().iter().cloned().map(Binder)\n     }\n }\n \n@@ -362,14 +436,30 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n         self.substs.types()\n     }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::TraitRef<'tcx>  {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: tcx.mk_substs(\n+                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned()))\n+        }\n+    }\n }\n \n pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n@@ -731,61 +821,53 @@ pub struct ExistentialProjection<'tcx> {\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n-impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n     pub fn item_name(&self) -> Name {\n-        self.0.item_name // safe to skip the binder to access a name\n+        self.item_name // safe to skip the binder to access a name\n     }\n \n     pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n-        let trait_def = tcx.lookup_trait_def(self.0.trait_ref.def_id);\n+        let trait_def = tcx.lookup_trait_def(self.trait_ref.def_id);\n         let def_path_hash = trait_def.def_path_hash;\n \n         // An `ast::Name` is also not stable (it's just an index into an\n         // interning table), so map to the corresponding `InternedString`.\n-        let item_name = self.0.item_name.as_str();\n+        let item_name = self.item_name.as_str();\n         (def_path_hash, item_name)\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         self_ty: Ty<'tcx>)\n-                        -> ty::PolyProjectionPredicate<'tcx>\n+                        -> ty::ProjectionPredicate<'tcx>\n     {\n         // otherwise the escaping regions would be captured by the binders\n         assert!(!self_ty.has_escaping_regions());\n \n-        let trait_ref = self.map_bound(|proj| proj.trait_ref);\n-        self.map_bound(|proj| ty::ProjectionPredicate {\n+        ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref.with_self_ty(tcx, self_ty).0,\n-                item_name: proj.item_name\n+                trait_ref: self.trait_ref.with_self_ty(tcx, self_ty),\n+                item_name: self.item_name\n             },\n-            ty: proj.ty\n-        })\n+            ty: self.ty\n+        }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn try_add_builtin_trait(self,\n-                                 id: DefId,\n-                                 auto_traits: &mut Vec<DefId>)\n-                                 -> bool\n-    {\n-        //! Checks whether `id` refers to one of the builtin\n-        //! traits, like `Send`, and adds it to `auto_traits` if so.\n-        //! Returns true if `idf` refers to a builtin trait.\n-\n-        if Some(id) == self.lang_items.send_trait() ||\n-            Some(id) == self.lang_items.sized_trait() ||\n-            Some(id) == self.lang_items.copy_trait() ||\n-            Some(id) == self.lang_items.sync_trait() {\n-            auto_traits.push(id);\n-            true\n-        } else {\n-            false\n-        }\n+impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn item_name(&self) -> Name {\n+        self.skip_binder().item_name()\n+    }\n+\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+        self.skip_binder().sort_key(tcx)\n+    }\n+\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::PolyProjectionPredicate<'tcx> {\n+        self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n }\n \n@@ -1045,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n-            TyTrait(..) => true,\n+            TyDynamic(..) => true,\n             _ => false\n         }\n     }\n@@ -1178,7 +1260,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n-            TyTrait(ref tt) => tt.principal().map(|p| p.def_id()),\n+            TyDynamic(ref tt, ..) => tt.principal().map(|p| p.def_id()),\n             TyAdt(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n@@ -1200,9 +1282,11 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyRef(region, _) => {\n                 vec![region]\n             }\n-            TyTrait(ref obj) => {\n-                let mut v = vec![obj.region_bound];\n-                v.extend(obj.principal().unwrap().skip_binder().substs.regions());\n+            TyDynamic(ref obj, region) => {\n+                let mut v = vec![region];\n+                if let Some(p) = obj.principal() {\n+                    v.extend(p.skip_binder().substs.regions());\n+                }\n                 v\n             }\n             TyAdt(_, substs) | TyAnon(_, substs) => {"}, {"sha": "ed9a327750a1604c3329a7e8863ba2f55e4e76fb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -532,8 +532,8 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.sig.variadic());\n                 self.hash(f.sig.inputs().skip_binder().len());\n             }\n-            TyTrait(ref data) => {\n-                if let Some(ref p) = data.principal() {\n+            TyDynamic(ref data, ..) => {\n+                if let Some(p) = data.principal() {\n                     self.def_id(p.def_id());\n                 }\n                 for d in data.auto_traits() {\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n-            TyArray(..) | TySlice(..) | TyTrait(..) | TyTuple(..) |\n+            TyArray(..) | TySlice(..) | TyDynamic(..) | TyTuple(..) |\n             TyClosure(..) | TyAdt(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| {\n@@ -684,7 +684,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n \n-            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n+            TyStr | TyDynamic(..) | TySlice(_) => Some(false),\n \n             TyAdt(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None"}, {"sha": "0848dcd2c8d213ec4f37bf3e930e2aee6b50cba4", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -92,14 +92,19 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyProjection(ref data) => {\n             stack.extend(data.trait_ref.substs.types().rev());\n         }\n-        ty::TyTrait(ref obj) => {\n-            match obj.principal() {\n-                Some(ref p) => stack.extend(p.input_types().rev()),\n-                None => {}\n-            }\n-            stack.extend(obj.projection_bounds.iter().map(|pred| {\n-                pred.0.ty\n-            }).rev());\n+        ty::TyDynamic(ref obj, ..) => {\n+            stack.extend(obj.iter().rev().flat_map(|predicate| {\n+                let (substs, opt_ty) = match *predicate.skip_binder() {\n+                    ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n+                    ty::ExistentialPredicate::Projection(p) =>\n+                        (p.trait_ref.substs, Some(p.ty)),\n+                    ty::ExistentialPredicate::AutoTrait(_) =>\n+                        // Empty iterator\n+                        (ty::Substs::empty(), None),\n+                };\n+\n+                substs.types().rev().chain(opt_ty)\n+            }));\n         }\n         ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n             stack.extend(substs.types().rev());"}, {"sha": "87a0339fff7d29d3fda7508aa88d1544fe8de121", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -374,12 +374,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // of whatever returned this exact `impl Trait`.\n                 }\n \n-                ty::TyTrait(ref data) => {\n+                ty::TyDynamic(data, r) => {\n                     // WfObject\n                     //\n                     // Here, we defer WF checking due to higher-ranked\n                     // regions. This is perhaps not ideal.\n-                    self.from_object_ty(ty, data);\n+                    self.from_object_ty(ty, data, r);\n \n                     // FIXME(#27579) RFC also considers adding trait\n                     // obligations that don't refer to Self and\n@@ -388,7 +388,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     let cause = self.cause(traits::MiscObligation);\n \n                     let component_traits =\n-                        data.auto_traits().chain(data.principal().map(|ref p| p.def_id()));\n+                        data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n@@ -450,7 +450,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitObject<'tcx>) {\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>,\n+                      data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+                      region: &'tcx ty::Region) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -485,11 +487,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         if !data.has_escaping_regions() {\n             let implicit_bounds =\n-                object_region_bounds(self.infcx.tcx,\n-                                     data.principal().unwrap(),\n-                                     data.auto_traits());\n+                object_region_bounds(self.infcx.tcx, data);\n \n-            let explicit_bound = data.region_bound;\n+            let explicit_bound = region;\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n@@ -506,26 +506,23 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'a, 'gcx, 'tcx, I>(\n+pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    principal: ty::PolyExistentialTraitRef<'tcx>,\n-    others: I)\n+    existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<&'tcx ty::Region>\n-    where I: Iterator<Item=DefId>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    let mut predicates = others.map(|d| {\n-        let trait_ref = ty::TraitRef {\n-            def_id: d,\n-            substs: tcx.mk_substs_trait(open_ty, &[])\n-        };\n-        trait_ref.to_predicate()\n-    }).collect::<Vec<_>>();\n-    predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n+    let predicates = existential_predicates.iter().filter_map(|predicate| {\n+        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+            None\n+        } else {\n+            Some(predicate.with_self_ty(tcx, open_ty))\n+        }\n+    }).collect();\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "d839df80a12acc25d4fd9630c64e1b187276b4f8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 27, "deletions": 98, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -16,9 +16,8 @@ use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyProjection, TyAnon};\n-use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n+use ty::{TyBox, TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -298,58 +297,23 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n     write!(f, \"{}\", new_value)\n }\n \n-/// This curious type is here to help pretty-print trait objects. In\n-/// a trait object, the projections are stored separately from the\n-/// main trait bound, but in fact we want to package them together\n-/// when printing out; they also have separate binders, but we want\n-/// them to share a binder when we print them out. (And the binder\n-/// pretty-printing logic is kind of clever and we don't want to\n-/// reproduce it.) So we just repackage up the structure somewhat.\n-///\n-/// Right now there is only one trait in an object that can have\n-/// projection bounds, so we just stuff them altogether. But in\n-/// reality we should eventually sort things out better.\n-#[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>,\n-                                 Vec<ty::ProjectionPredicate<'tcx>>);\n-\n-impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n-        parameterized(f, trait_ref.substs,\n-                      trait_ref.def_id,\n-                      projection_bounds)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n+impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n             // Use a type that can't appear in defaults of type parameters.\n             let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-            let principal = self.principal().and_then(|ref p| tcx.lift(p))\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            let projections = self.projection_bounds.iter().map(|p| {\n-                tcx.lift(p)\n-                    .expect(\"could not lift projection for printing\")\n-                    .with_self_ty(tcx, dummy_self).0\n-            }).collect();\n-\n-            let tap = ty::Binder(TraitAndProjections(principal, projections));\n-            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))?;\n+            if let Some(p) = self.principal() {\n+                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                    .with_self_ty(tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    tcx.lift(&p)\n+                        .expect(\"could not lift projection for printing\")\n+                        .with_self_ty(tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                parameterized(f, principal.substs, principal.def_id, &projections)?;\n+            }\n \n             // Builtin bounds.\n             for did in self.auto_traits() {\n@@ -359,16 +323,6 @@ impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n             Ok(())\n         })?;\n \n-        // FIXME: It'd be nice to compute from context when this bound\n-        // is implied, but that's non-trivial -- we'd perhaps have to\n-        // use thread-local data of some kind? There are also\n-        // advantages to just showing the region, since it makes\n-        // people aware that it's there.\n-        let bound = self.region_bound.to_string();\n-        if !bound.is_empty() {\n-            write!(f, \" + {}\", bound)?;\n-        }\n-\n         Ok(())\n     }\n }\n@@ -455,45 +409,6 @@ impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut empty = true;\n-        let mut maybe_continue = |f: &mut fmt::Formatter| {\n-            if empty {\n-                empty = false;\n-                Ok(())\n-            } else {\n-                write!(f, \" + \")\n-            }\n-        };\n-\n-        maybe_continue(f)?;\n-        write!(f, \"{:?}\", self.principal())?;\n-\n-        let region_str = format!(\"{:?}\", self.region_bound);\n-        if !region_str.is_empty() {\n-            maybe_continue(f)?;\n-            write!(f, \"{}\", region_str)?;\n-        }\n-\n-        ty::tls::with(|tcx| {\n-            for did in self.auto_traits() {\n-                maybe_continue(f)?;\n-                write!(f, \" + {}\", tcx.item_path_str(did))?;\n-            }\n-\n-            Ok(())\n-        })?;\n-\n-        for projection_bound in &self.projection_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", projection_bound)?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -746,6 +661,12 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n+impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n@@ -865,7 +786,15 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     }\n                 })\n             }\n-            TyTrait(ref data) => write!(f, \"{}\", data),\n+            TyDynamic(data, r) => {\n+                write!(f, \"{}\", data)?;\n+                let r = r.to_string();\n+                if !r.is_empty() {\n+                    write!(f, \" + {}\", r)\n+                } else {\n+                    Ok(())\n+                }\n+            }\n             TyProjection(ref data) => write!(f, \"{}\", data),\n             TyAnon(def_id, substs) => {\n                 ty::tls::with(|tcx| {"}, {"sha": "6e9467d63dd1f84d43158ca7f4fc1f71a234ec36", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                            consider using a raw pointer instead\")\n             }\n \n-            ty::TyTrait(..) => {\n+            ty::TyDynamic(..) => {\n                 FfiUnsafe(\"found Rust trait type in foreign module, \\\n                            consider using a raw pointer instead\")\n             }"}, {"sha": "1e3d12c50a394ae4300978cdd7bdf6fc7776392d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -416,6 +416,15 @@ impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+    for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self)\n+        -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+        Ok(self.tcx().mk_existential_predicates((0..self.read_usize()?)\n+                                                .map(|_| Decodable::decode(self)))?)\n+    }\n+}\n+\n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {\n         self.raw_bytes().starts_with(METADATA_HEADER)"}, {"sha": "f1126e6fd256c033d31f4c5256e48bc04c3b402f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -295,16 +295,14 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n-        (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n+        (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::TyTrait(ref data)) => {\n-            let trait_ref = data.principal().unwrap().with_self_ty(ccx.tcx(), source);\n-            let trait_ref = ccx.tcx().erase_regions(&trait_ref);\n-            consts::ptrcast(meth::get_vtable(ccx, trait_ref),\n+        (_, &ty::TyDynamic(ref data, ..)) => {\n+            consts::ptrcast(meth::get_vtable(ccx, source, data.principal()),\n                             Type::vtable_ptr(ccx))\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\","}, {"sha": "120e1a562ebea80be0bf135dd4bc07b9eaac2740", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -763,7 +763,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyFnDef(..) |\n         ty::TyFnPtr(_)  |\n         ty::TyNever     |\n-        ty::TyTrait(_)  => {\n+        ty::TyDynamic(..)  => {\n             /* nothing to do */\n         }\n         ty::TyAdt(adt_def, substs) => {\n@@ -1003,18 +1003,20 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                    output: &mut Vec<TransItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !impl_ty.needs_subst());\n \n-    if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n-        let poly_trait_ref = trait_ty.principal().unwrap().with_self_ty(scx.tcx(), impl_ty);\n-        let param_substs = scx.tcx().intern_substs(&[]);\n-\n-        // Walk all methods of the trait, including those of its supertraits\n-        let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n-        let methods = methods.filter_map(|method| method)\n-            .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs, param_substs))\n-            .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n-            .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n-        output.extend(methods);\n-\n+    if let ty::TyDynamic(ref trait_ty, ..) = trait_ty.sty {\n+        if let Some(principal) = trait_ty.principal() {\n+            let poly_trait_ref = principal.with_self_ty(scx.tcx(), impl_ty);\n+            let param_substs = scx.tcx().intern_substs(&[]);\n+\n+            // Walk all methods of the trait, including those of its supertraits\n+            let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+            let methods = methods.filter_map(|method| method)\n+                .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs,\n+                                                                  param_substs))\n+                .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+                .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+            output.extend(methods);\n+        }\n         // Also add the destructor\n         let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n         output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));"}, {"sha": "c0d7c64bd192c8713e422040360ea6a50387346d", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -95,7 +95,8 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FxHashMap<Instance<'tcx>, ValueRef>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n+    vtables: RefCell<FxHashMap<(ty::Ty<'tcx>,\n+                                Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FxHashMap<InternedString, ValueRef>>,\n \n@@ -800,7 +801,9 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().instances\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n+    pub fn vtables<'a>(&'a self)\n+        -> &'a RefCell<FxHashMap<(ty::Ty<'tcx>,\n+                                  Option<ty::PolyExistentialTraitRef<'tcx>>), ValueRef>> {\n         &self.local().vtables\n     }\n "}, {"sha": "8bbe50af0651c6f4f7357266fb453a74f09ff784", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -432,7 +432,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::TyTrait(ref data) => if let Some(principal) = data.principal() {\n+        ty::TyDynamic(ref data, ..) => if let Some(principal) = data.principal() {\n             let def_id = principal.def_id();\n             get_namespace_and_span_for_item(cx, def_id).0\n         } else {\n@@ -523,7 +523,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyStr => {\n             fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, None, usage_site_span)\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n@@ -538,7 +538,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ty::TyStr => {\n                     vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n                 }\n-                ty::TyTrait(..) => {\n+                ty::TyDynamic(..) => {\n                     MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n                         false)"}, {"sha": "80e6bd7aa29840528f16526205f4716a0d36cbad", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -93,7 +93,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             push_debuginfo_type_name(cx, inner_type, true, output);\n             output.push(']');\n         },\n-        ty::TyTrait(ref trait_data) => {\n+        ty::TyDynamic(ref trait_data, ..) => {\n             if let Some(principal) = trait_data.principal() {\n                 let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n                     &principal);"}, {"sha": "06d0b1e19828e4f912fdc0e4b6f780a996d5ec3e", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -394,7 +394,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n \n             (size, align)\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n             let info = bcx.pointercast(info, Type::int(bcx.ccx()).ptr_to());\n@@ -463,7 +463,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n             }\n         }\n-        ty::TyTrait(..) => {\n+        ty::TyDynamic(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any."}, {"sha": "aa9b900fa465396573edae7f1f02801a0de67667", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -110,42 +110,48 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            trait_ref: ty::PolyTraitRef<'tcx>)\n+                            ty: ty::Ty<'tcx>,\n+                            trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n+    debug!(\"get_vtable(ty={:?}, trait_ref={:?})\", ty, trait_ref);\n \n     // Check the cache.\n-    if let Some(&val) = ccx.vtables().borrow().get(&trait_ref) {\n+    if let Some(&val) = ccx.vtables().borrow().get(&(ty, trait_ref)) {\n         return val;\n     }\n \n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n-    let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n-        opt_mth.map_or(nullptr, |(def_id, substs)| {\n-            Callee::def(ccx, def_id, substs).reify(ccx)\n-        })\n-    });\n \n-    let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n+    let size_ty = sizing_type_of(ccx, ty);\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let align = align_of(ccx, trait_ref.self_ty());\n+    let align = align_of(ccx, ty);\n \n-    let components: Vec<_> = [\n+    let mut components: Vec<_> = [\n         // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, trait_ref.self_ty()),\n+        glue::get_drop_glue(ccx, ty),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n-    ].iter().cloned().chain(methods).collect();\n+    ].iter().cloned().collect();\n+\n+    if let Some(trait_ref) = trait_ref {\n+        let trait_ref = trait_ref.with_self_ty(tcx, ty);\n+        let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n+            opt_mth.map_or(nullptr, |(def_id, substs)| {\n+                Callee::def(ccx, def_id, substs).reify(ccx)\n+            })\n+        });\n+        components.extend(methods);\n+    }\n \n     let vtable_const = C_struct(ccx, &components, false);\n     let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n     let vtable = consts::addr_of(ccx, vtable_const, align, \"vtable\");\n \n-    ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n+    ccx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "979c2206fc1dea788f993c889cff2242ce1c2ca8", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -457,11 +457,11 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_type_name(inner_type, output);\n                 output.push(']');\n             },\n-            ty::TyTrait(ref trait_data) => {\n+            ty::TyDynamic(ref trait_data, ..) => {\n                 if let Some(principal) = trait_data.principal() {\n                     self.push_def_path(principal.def_id(), output);\n                     self.push_type_params(principal.skip_binder().substs,\n-                        &trait_data.projection_bounds,\n+                        &trait_data.projection_bounds().collect::<Vec<_>>()[..],\n                         output);\n                 }\n             },"}, {"sha": "22c405fe254a62c400d818d54e51de617f67c405", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -95,7 +95,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyAnon(..) | ty::TyError => {\n             bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n-        ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n+        ty::TySlice(_) | ty::TyDynamic(..) | ty::TyStr => bug!()\n     };\n \n     debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n@@ -148,7 +148,7 @@ fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type\n         ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n             Type::uint_from_ty(ccx, ast::UintTy::Us)\n         }\n-        ty::TyTrait(_) => Type::vtable_ptr(ccx),\n+        ty::TyDynamic(..) => Type::vtable_ptr(ccx),\n         _ => bug!(\"Unexpected tail in unsized_info_ty: {:?} for ty={:?}\",\n                           unsized_part, ty)\n     }\n@@ -258,7 +258,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       // fat pointers is of the right type (e.g. for array accesses), even\n       // when taking the address of an unsized field in a struct.\n       ty::TySlice(ty) => in_memory_type_of(cx, ty),\n-      ty::TyStr | ty::TyTrait(..) => Type::i8(cx),\n+      ty::TyStr | ty::TyDynamic(..) => Type::i8(cx),\n \n       ty::TyFnDef(..) => Type::nil(cx),\n       ty::TyFnPtr(f) => {"}, {"sha": "986d817a10cc3868212c273f294d3e15204947d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -49,6 +49,7 @@\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use rustc_const_eval::eval_length;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir::{self, SelfKind};\n use hir::def::Def;\n use hir::def_id::DefId;\n@@ -69,6 +70,7 @@ use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use std::cell::RefCell;\n+use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n@@ -1052,8 +1054,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let b = &trait_bounds[0];\n             let span = b.trait_ref.path.span;\n             struct_span_err!(self.tcx().sess, span, E0225,\n-                             \"only the builtin traits can be used as closure or object bounds\")\n-                .span_label(span, &format!(\"non-builtin trait used as bounds\"))\n+                \"only Send/Sync traits can be used as additional traits in a trait object\")\n+                .span_label(span, &format!(\"non-Send/Sync additional trait\"))\n                 .emit();\n         }\n \n@@ -1070,30 +1072,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     ty: b.ty\n                 }\n             })\n-        }).collect();\n-\n-        let region_bound =\n-            self.compute_object_lifetime_bound(span,\n-                                               &region_bounds,\n-                                               existential_principal,\n-                                               &auto_traits);\n-\n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                tcx.mk_region(match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n-                                  \"the lifetime bound for this object type cannot be deduced \\\n-                                   from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                })\n-            }\n-        };\n-\n-        debug!(\"region_bound: {:?}\", region_bound);\n+        });\n \n         // ensure the super predicates and stop if we encountered an error\n         if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n@@ -1135,12 +1114,37 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         .emit();\n         }\n \n-        let ty = tcx.mk_trait(ty::TraitObject::new(\n-            Some(existential_principal),\n-            region_bound,\n-            auto_traits,\n-            existential_projections\n-        ));\n+        let mut v =\n+            iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n+            .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n+            .chain(existential_projections\n+                   .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n+            .collect::<AccumulateVec<[_; 8]>>();\n+        v.sort_by(|a, b| a.cmp(tcx, b));\n+        let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n+\n+        let region_bound = self.compute_object_lifetime_bound(span,\n+                                                              &region_bounds,\n+                                                              existential_predicates);\n+\n+        let region_bound = match region_bound {\n+            Some(r) => r,\n+            None => {\n+                tcx.mk_region(match rscope.object_lifetime_default(span) {\n+                    Some(r) => r,\n+                    None => {\n+                        span_err!(self.tcx().sess, span, E0228,\n+                                  \"the lifetime bound for this object type cannot be deduced \\\n+                                   from context; please supply an explicit bound\");\n+                        ty::ReStatic\n+                    }\n+                })\n+            }\n+        };\n+\n+        debug!(\"region_bound: {:?}\", region_bound);\n+\n+        let ty = tcx.mk_dynamic(existential_predicates, region_bound);\n         debug!(\"trait_object_type: {:?}\", ty);\n         ty\n     }\n@@ -1922,38 +1926,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n         explicit_region_bounds: &[&hir::Lifetime],\n-        principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n-        auto_traits: &[DefId])\n+        existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n         debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               principal_trait_ref={:?}, auto_traits={:?})\",\n+               existential_predicates={:?})\",\n                explicit_region_bounds,\n-               principal_trait_ref,\n-               auto_traits);\n+               existential_predicates);\n \n         if explicit_region_bounds.len() > 1 {\n             span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n                 \"only a single explicit lifetime bound is permitted\");\n         }\n \n-        if !explicit_region_bounds.is_empty() {\n+        if let Some(&r) = explicit_region_bounds.get(0) {\n             // Explicitly specified region bound. Use that.\n-            let r = explicit_region_bounds[0];\n             return Some(ast_region_to_region(tcx, r));\n         }\n \n-        if let Err(ErrorReported) =\n-                self.ensure_super_predicates(span, principal_trait_ref.def_id()) {\n-            return Some(tcx.mk_region(ty::ReStatic));\n+        if let Some(principal) = existential_predicates.principal() {\n+            if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n+                return Some(tcx.mk_region(ty::ReStatic));\n+            }\n         }\n \n         // No explicit region bound specified. Therefore, examine trait\n         // bounds and see if we can derive region bounds from those.\n         let derived_region_bounds =\n-            object_region_bounds(tcx, principal_trait_ref, auto_traits.into_iter().cloned());\n+            object_region_bounds(tcx, existential_predicates);\n \n         // If there are no derived region bounds, then report back that we\n         // can find no region bound. The caller will use the default.\n@@ -2000,7 +2002,11 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n                 match b.trait_ref.path.def {\n                     Def::Trait(trait_did) => {\n-                        if tcx.try_add_builtin_trait(trait_did, &mut auto_traits) {\n+                        // Checks whether `trait_did` refers to one of the builtin\n+                        // traits, like `Send`, and adds it to `auto_traits` if so.\n+                        if Some(trait_did) == tcx.lang_items.send_trait() ||\n+                            Some(trait_did) == tcx.lang_items.sync_trait() {\n+                            auto_traits.push(trait_did);\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;\n                             if !parameters.types().is_empty() {\n@@ -2115,12 +2121,15 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n     {\n         let mut vec = Vec::new();\n \n-        for trait_did in &self.auto_traits {\n-           let trait_ref = ty::TraitRef {\n-               def_id: *trait_did,\n-               substs: tcx.mk_substs_trait(param_ty, &[]),\n-           };\n-           vec.push(trait_ref.to_predicate());\n+        // If it could be sized, and is, add the sized predicate\n+        if self.implicitly_sized {\n+            if let Some(sized) = tcx.lang_items.sized_trait() {\n+                let trait_ref = ty::TraitRef {\n+                    def_id: sized,\n+                    substs: tcx.mk_substs_trait(param_ty, &[])\n+                };\n+                vec.push(trait_ref.to_predicate());\n+            }\n         }\n \n         for &region_bound in &self.region_bounds {"}, {"sha": "6e2b42881a709622c876a403d315d7dca3d1df4b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n-                if let ty::TyTrait(..) = mt.ty.sty {\n+                if let ty::TyDynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);"}, {"sha": "5f904f507e27270dbf9572ef3dad2c5df52589f7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -65,7 +65,7 @@ pub struct CastCheck<'tcx> {\n /// fat pointers if their unsize-infos have the same kind.\n #[derive(Copy, Clone, PartialEq, Eq)]\n enum UnsizeKind<'tcx> {\n-    Vtable(DefId),\n+    Vtable(Option<DefId>),\n     Length,\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n@@ -79,7 +79,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n         match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n-            ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal().unwrap().def_id())),\n+            ty::TyDynamic(ref tty, ..) =>\n+                Some(UnsizeKind::Vtable(tty.principal().map(|p| p.def_id()))),\n             ty::TyAdt(def, substs) if def.is_struct() => {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {\n@@ -130,7 +131,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n         match cast_ty.sty {\n-            ty::TyTrait(..) | ty::TySlice(..) => {\n+            ty::TyDynamic(..) | ty::TySlice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n             }"}, {"sha": "744d99fe60d17b1faae4c9b667fbfe9c1058a72e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -111,16 +111,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_ty);\n \n         match expected_ty.sty {\n-            ty::TyTrait(ref object_type) => {\n-                let sig = object_type.projection_bounds\n-                    .iter()\n+            ty::TyDynamic(ref object_type, ..) => {\n+                let sig = object_type.projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n                         self.deduce_sig_from_projection(&pb)\n                     })\n                     .next();\n-                let kind =\n-                    self.tcx.lang_items.fn_trait_kind(object_type.principal().unwrap().def_id());\n+                let kind = object_type.principal()\n+                    .and_then(|p| self.tcx.lang_items.fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n             ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),"}, {"sha": "a5446b0fbaa89edc025b8c1c279b3dd3cada64ea", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -515,7 +515,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n+        ty::TyDynamic(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n     }\n }\n \n@@ -564,7 +564,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);\n         }\n-        ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n             return DropckKind::BorrowedDataMustStrictlyOutliveSelf;\n         },"}, {"sha": "ff9eaa012ba41e3c37f1ed4652134de01c00becb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .autoderef(self.span, self_ty)\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n-                    ty::TyTrait(ref data) => data.principal().map(|p| closure(self, ty, p)),\n+                    ty::TyDynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n                     _ => None,\n                 }\n             })"}, {"sha": "b0787d75c9cb4f903fa58a2794eddee5c6cb0db4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -295,9 +295,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n \n         match self_ty.sty {\n-            ty::TyTrait(box ref data) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, data.principal().unwrap());\n-                self.assemble_inherent_impl_candidates_for_type(data.principal().unwrap().def_id());\n+            ty::TyDynamic(ref data, ..) => {\n+                if let Some(p) = data.principal() {\n+                    self.assemble_inherent_candidates_from_object(self_ty, p);\n+                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n+                }\n             }\n             ty::TyAdt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);"}, {"sha": "9443e0a3586b016abf563a0161ae11437dd8264e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -379,8 +379,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyAdt(def, _) => def.did.is_local(),\n \n-                ty::TyTrait(ref tr) => tr.principal().map(|p|\n-                                                          p.def_id().is_local()).unwrap_or(false),\n+                ty::TyDynamic(ref tr, ..) => tr.principal()\n+                    .map_or(false, |p| p.def_id().is_local()),\n \n                 ty::TyParam(_) => true,\n "}, {"sha": "bad7b4d96cac670c38bb3c9a3e3894c78048b9a7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx.struct_tail(ty).sty {\n-            ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n+            ty::TySlice(_) | ty::TyStr | ty::TyDynamic(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n             _ => ExpectHasType(ty)"}, {"sha": "fb35cb8181cb3de6de0d3ce332e55f96e05ab9d5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -806,11 +806,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::TyTrait(ref obj)) => {\n+            /*To:  */  &ty::TyDynamic(.., r)) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n-                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span),\n-                                       from_ty, obj.region_bound);\n+                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n             /*From:*/ (&ty::TyBox(from_referent_ty),"}, {"sha": "f29965ee47c8f38c51da689b873d90e679300c8b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -118,15 +118,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 // FIXME(#27579) what amount of WF checking do we need for neg impls?\n \n                 let trait_ref = ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(item.id)).unwrap();\n-                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n-                let sync_trait = ccx.tcx.lang_items.require(lang_items::SyncTraitLangItem)\n-                    .unwrap_or_else(|msg| ccx.tcx.sess.fatal(&msg[..]));\n-                let send_trait = ccx.tcx.lang_items.require(lang_items::SendTraitLangItem)\n-                    .unwrap_or_else(|msg| ccx.tcx.sess.fatal(&msg[..]));\n-                if trait_ref.def_id != sync_trait && trait_ref.def_id != send_trait {\n-                    if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                        error_192(ccx, item.span);\n-                    }\n+                if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n+                    error_192(ccx, item.span);\n                 }\n             }\n             hir::ItemFn(.., ref body) => {"}, {"sha": "30472f85db1207a9db955aecc7289cb3f4974420", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -23,7 +23,7 @@ use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n+use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n@@ -68,7 +68,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         match ty.sty {\n             TyAdt(def, _) => Some(def.did),\n \n-            TyTrait(ref t) => t.principal().map(|p| p.def_id()),\n+            TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n             TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n "}, {"sha": "f04442de09c307547d3d30f53417da51c2fcd030", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -86,7 +86,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     ty::TyAdt(def, _) => {\n                         self.check_def_id(item, def.did);\n                     }\n-                    ty::TyTrait(ref data) if data.principal().is_some() => {\n+                    ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n                         self.check_def_id(item, data.principal().unwrap().def_id());\n                     }\n                     ty::TyBox(..) => {"}, {"sha": "815811675a54bff05321ee3fef482003bb8bf6c7", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -178,16 +178,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 }\n \n                 // check for overlap with the automatic `impl Trait for Trait`\n-                if let ty::TyTrait(ref data) = trait_ref.self_ty().sty {\n+                if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n                     // This is something like impl Trait1 for Trait2. Illegal\n                     // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                    if data.principal().is_none() ||\n-                        !self.tcx.is_object_safe(data.principal().unwrap().def_id()) {\n-                        // This is an error, but it will be\n-                        // reported by wfcheck.  Ignore it\n-                        // here. This is tested by\n-                        // `coherence-impl-trait-for-trait-object-safe.rs`.\n+                    if data.principal().map_or(true, |p| !self.tcx.is_object_safe(p.def_id())) {\n+                        // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+                        // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n                     } else {\n                         let mut supertrait_def_ids =\n                             traits::supertrait_def_ids(self.tcx,"}, {"sha": "2b69ac12a2c4d1f5f93a6e274d723e85290c37cf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -1617,12 +1617,11 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\\n                                        a default. Only `?Sized` is supported\");\n-                    tcx.try_add_builtin_trait(kind_id, bounds);\n                 }\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            tcx.try_add_builtin_trait(kind_id.unwrap(), bounds);\n+            bounds.push(kind_id.unwrap());\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}"}, {"sha": "01e99a296e886bb49fb99e6cfe8f02527c768c55", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -2778,8 +2778,8 @@ fn main() {\n }\n ```\n \n-Builtin traits are an exception to this rule: it's possible to have bounds of\n-one non-builtin type, plus any number of builtin types. For example, the\n+Send and Sync are an exception to this rule: it's possible to have bounds of\n+one non-builtin trait, plus either or both of Send and Sync. For example, the\n following compiles correctly:\n \n ```"}, {"sha": "f34753c227d71c34d1625cceadcf31687e59d9f5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -371,16 +371,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                                  variance);\n             }\n \n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, data.region_bound, contra);\n+                self.add_constraints_from_region(generics, r, contra);\n \n-                let poly_trait_ref = data.principal().unwrap().with_self_ty(self.tcx(),\n-                    self.tcx().types.err);\n-                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                if let Some(p) = data.principal() {\n+                    let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n+                    self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n+                }\n \n-                for projection in &data.projection_bounds {\n+                for projection in data.projection_bounds() {\n                     self.add_constraints_from_ty(generics, projection.0.ty, self.invariant);\n                 }\n             }"}, {"sha": "b9ba7f732a68eaa9f26ce8482c00f775b18c12e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -594,10 +594,10 @@ pub enum TyParamBound {\n \n impl TyParamBound {\n     fn maybe_sized(cx: &DocContext) -> TyParamBound {\n-        let did = cx.tcx().lang_items.require(lang_items::SizedTraitLangItem)\n-            .unwrap_or_else(|msg| cx.tcx().sess.fatal(&msg[..]));\n-        let empty = cx.tcx().intern_substs(&[]);\n-        let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n+        let did = cx.tcx.lang_items.require(lang_items::SizedTraitLangItem)\n+            .unwrap_or_else(|msg| cx.tcx.sess.fatal(&msg[..]));\n+        let empty = cx.tcx.intern_substs(&[]);\n+        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n             Some(did), false, vec![], empty);\n         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n         TraitBound(PolyTrait {\n@@ -1855,23 +1855,16 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     is_generic: false,\n                 }\n             }\n-            ty::TyTrait(ref obj) => {\n+            ty::TyDynamic(ref obj, ref reg) => {\n                 if let Some(principal) = obj.principal() {\n                     let did = principal.def_id();\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n                     let mut typarams = vec![];\n-                    obj.region_bound.clean(cx).map(|b| typarams.push(RegionBound(b)));\n+                    reg.clean(cx).map(|b| typarams.push(RegionBound(b)));\n                     for did in obj.auto_traits() {\n-                        let tcx = match cx.tcx_opt() {\n-                            Some(tcx) => tcx,\n-                            None => {\n-                                typarams.push(RegionBound(Lifetime::statik()));\n-                                continue;\n-                            }\n-                        };\n-                        let empty = tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &tcx.item_name(did).as_str(),\n+                        let empty = cx.tcx.intern_substs(&[]);\n+                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                             Some(did), false, vec![], empty);\n                         inline::record_extern_fqn(cx, did, TypeKind::Trait);\n                         let bound = TraitBound(PolyTrait {\n@@ -1887,14 +1880,14 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     }\n \n                     let mut bindings = vec![];\n-                    for &ty::Binder(ref pb) in &obj.projection_bounds {\n+                    for ty::Binder(ref pb) in obj.projection_bounds() {\n                         bindings.push(TypeBinding {\n                             name: pb.item_name.clean(cx),\n                             ty: pb.ty.clean(cx)\n                         });\n                     }\n \n-                    let path = external_path(cx, &cx.tcx().item_name(did).as_str(), Some(did),\n+                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n                         false, bindings, principal.0.substs);\n                     ResolvedPath {\n                         path: path,"}, {"sha": "8c79c15e3de5bf8c053da24e8c126aa88c38c281", "filename": "src/test/compile-fail/E0225.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2FE0225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2FE0225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0225.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     let _: Box<std::io::Read + std::io::Write>;\n-    //~^ ERROR only the builtin traits can be used as closure or object bounds [E0225]\n-    //~| NOTE non-builtin trait used as bounds\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object [E0225]\n+    //~| NOTE non-Send/Sync additional trait\n }"}, {"sha": "a2e2e5caafe6d0c408cd5a13d2ed7de8c43cb06d", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -12,8 +12,7 @@ trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n-    //~^ ERROR the trait bound `Trait + std::marker::Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR the trait `std::marker::Sized` cannot be made into an object\n-    //~| ERROR the trait bound `Trait + std::marker::Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR the trait `std::marker::Sized` cannot be made into an object\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object\n+    //~| ERROR the trait bound `Trait: std::marker::Sized` is not satisfied\n+    //~| ERROR the trait bound `Trait: std::marker::Sized` is not satisfied\n }"}, {"sha": "2ad804fc8ced7e3c92964c1825f0553697c9521f", "filename": "src/test/compile-fail/issue-22560.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -20,6 +20,6 @@ type Test = Add +\n             //~| NOTE missing associated type `Output` value\n             Sub;\n             //~^ ERROR E0225\n-            //~| NOTE non-builtin trait used as bounds\n+            //~| NOTE non-Send/Sync additional trait\n \n fn main() { }"}, {"sha": "f146cfbe68b9631f50540cd022caa2c588095100", "filename": "src/test/compile-fail/issue-32963.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32963.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -16,6 +16,6 @@ fn size_of_copy<T: Copy+?Sized>() -> usize { mem::size_of::<T>() }\n \n fn main() {\n     size_of_copy::<Misc+Copy>();\n-    //~^ ERROR the trait bound `Misc + std::marker::Copy: std::marker::Copy` is not satisfied\n-    //~| ERROR the trait `std::marker::Copy` cannot be made into an object\n+    //~^ ERROR only Send/Sync traits can be used as additional traits in a trait object\n+    //~| ERROR the trait bound `Misc: std::marker::Copy` is not satisfied\n }"}, {"sha": "9f832c7b6e500f52e87a900e82b0c47cebb5c6f3", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -24,7 +24,7 @@ fn d(x: Box<Foo>) {\n     a(x); //~ ERROR mismatched types [E0308]\n           //~| NOTE expected type `Box<Foo + std::marker::Send + 'static>`\n           //~| NOTE found type `Box<Foo + 'static>`\n-          //~| NOTE expected trait Foo, found a different trait Foo\n+          //~| NOTE expected trait `Foo + std::marker::Send`, found trait `Foo`\n }\n \n fn main() { }"}, {"sha": "ba50aed42c36f64f1f21fe4709517dc5f45759a7", "filename": "src/test/run-pass/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb35d50cad5f452e80ff88ee957962966c28a9f6/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue13507.rs?ref=bb35d50cad5f452e80ff88ee957962966c28a9f6", "patch": "@@ -70,7 +70,7 @@ pub mod testtypes {\n     // Tests TyFnPtr\n     pub type FooFnPtr = fn(u8) -> bool;\n \n-    // Tests TyTrait\n+    // Tests TyDynamic\n     pub trait FooTrait {\n         fn foo_method(&self) -> usize;\n     }"}]}