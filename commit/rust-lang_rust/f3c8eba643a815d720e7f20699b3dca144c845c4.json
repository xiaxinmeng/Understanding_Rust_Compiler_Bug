{"sha": "f3c8eba643a815d720e7f20699b3dca144c845c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzhlYmE2NDNhODE1ZDcyMGU3ZjIwNjk5YjNkY2ExNDRjODQ1YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-28T03:38:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-28T03:38:48Z"}, "message": "Auto merge of #64864 - Centril:rollup-pxz6tw3, r=Centril\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #64703 (Docs: slice elements are equidistant)\n - #64745 (Include message on tests that should panic but do not)\n - #64781 (Remove stray references to the old global tcx)\n - #64794 (Remove unused DepTrackingMap)\n - #64802 (Account for tail expressions when pointing at return type)\n - #64809 (hir: Disallow `target_feature` on constants)\n - #64815 (Fix div_duration() marked as stable by mistake)\n - #64818 (update rtpSpawn's parameters type(It's prototype has been updated in libc))\n - #64830 (Thou shallt not `.abort_if_errors()`)\n - #64836 (Stabilize map_get_key_value feature)\n - #64845 (pin.rs: fix links to primitives in documentation)\n - #64847 (Upgrade env_logger to 0.7)\n - #64851 (Add mailmap entry for Dustin Bensing by request)\n - #64859 (check_match: improve diagnostics for `let A = 2;` with `const A: i32 = 3`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ab96a1cde1bbd285fa578cdd476bc4e30fec5fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab96a1cde1bbd285fa578cdd476bc4e30fec5fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c8eba643a815d720e7f20699b3dca144c845c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c8eba643a815d720e7f20699b3dca144c845c4", "html_url": "https://github.com/rust-lang/rust/commit/f3c8eba643a815d720e7f20699b3dca144c845c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c8eba643a815d720e7f20699b3dca144c845c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6f87c2c6e3b34381e5c37567a2b11af1fdf1507", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507", "html_url": "https://github.com/rust-lang/rust/commit/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507"}, {"sha": "017944c5a7236bcc3ed553d49dd1f43e73733966", "url": "https://api.github.com/repos/rust-lang/rust/commits/017944c5a7236bcc3ed553d49dd1f43e73733966", "html_url": "https://github.com/rust-lang/rust/commit/017944c5a7236bcc3ed553d49dd1f43e73733966"}], "stats": {"total": 1169, "additions": 569, "deletions": 600}, "files": [{"sha": "a2e3c581eabba32aa116add9c703e3994c988673", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -69,6 +69,7 @@ David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n+Dustin Bensing <dustin.bensing@googlemail.com>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>"}, {"sha": "5a92011d57033377abb7e80c56bc0b2016bee662", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -534,7 +534,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.0\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -3409,7 +3409,7 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.6.2\",\n+ \"env_logger 0.7.0\",\n  \"graphviz\",\n  \"lazy_static 1.3.0\",\n  \"log\","}, {"sha": "e6512bb6f6de9c42a0c28e5fd15499c5395704fc", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -47,8 +47,6 @@ Stabilized APIs\n - [`<*mut T>::cast`]\n - [`Duration::as_secs_f32`]\n - [`Duration::as_secs_f64`]\n-- [`Duration::div_duration_f32`]\n-- [`Duration::div_duration_f64`]\n - [`Duration::div_f32`]\n - [`Duration::div_f64`]\n - [`Duration::from_secs_f32`]\n@@ -100,8 +98,6 @@ Compatibility Notes\n [`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n [`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n [`Duration::as_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64\n-[`Duration::div_duration_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32\n-[`Duration::div_duration_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64\n [`Duration::div_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32\n [`Duration::div_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64\n [`Duration::from_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32"}, {"sha": "ddf012d15029ae090e7e634fdad5245cf17dd44d", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -580,15 +580,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(map_get_key_value)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n-    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n         where K: Borrow<Q>,\n               Q: Ord"}, {"sha": "be057ed6d59a758dc7c017a7fbb006fce704cbc8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -369,6 +369,8 @@\n //! [drop-guarantee]: #drop-guarantee\n //! [`poll`]: ../../std/future/trait.Future.html#tymethod.poll\n //! [`Pin::get_unchecked_mut`]: struct.Pin.html#method.get_unchecked_mut\n+//! [`bool`]: ../../std/primitive.bool.html\n+//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"pin\", since = \"1.33.0\")]\n "}, {"sha": "ee22d0b755a097565df5b53cc4db22c2e5da4922", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=c6f87c2c6e3b34381e5c37567a2b11af1fdf1507", "patch": "@@ -1,87 +0,0 @@\n-use rustc_data_structures::fx::FxHashMap;\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::marker::PhantomData;\n-use crate::util::common::MemoizationMap;\n-\n-use super::{DepKind, DepNodeIndex, DepGraph};\n-\n-/// A DepTrackingMap offers a subset of the `Map` API and ensures that\n-/// we make calls to `read` and `write` as appropriate. We key the\n-/// maps with a unique type for brevity.\n-pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n-    phantom: PhantomData<M>,\n-    graph: DepGraph,\n-    map: FxHashMap<M::Key, (M::Value, DepNodeIndex)>,\n-}\n-\n-pub trait DepTrackingMapConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value: Clone;\n-    fn to_dep_kind() -> DepKind;\n-}\n-\n-impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n-    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n-        DepTrackingMap {\n-            phantom: PhantomData,\n-            graph,\n-            map: Default::default(),\n-        }\n-    }\n-}\n-\n-impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n-    type Key = M::Key;\n-    type Value = M::Value;\n-\n-    /// Memoizes an entry in the dep-tracking-map. If the entry is not\n-    /// already present, then `op` will be executed to compute its value.\n-    /// The resulting dependency graph looks like this:\n-    ///\n-    ///     [op] -> Map(key) -> CurrentTask\n-    ///\n-    /// Here, `[op]` represents whatever nodes `op` reads in the\n-    /// course of execution; `Map(key)` represents the node for this\n-    /// map, and `CurrentTask` represents the current task when\n-    /// `memoize` is invoked.\n-    ///\n-    /// **Important:** when `op` is invoked, the current task will be\n-    /// switched to `Map(key)`. Therefore, if `op` makes use of any\n-    /// HIR nodes or shared state accessed through its closure\n-    /// environment, it must explicitly register a read of that\n-    /// state. As an example, see `type_of_item` in `collect`,\n-    /// which looks something like this:\n-    ///\n-    /// ```\n-    /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.hir_id);\n-    ///     ccx.tcx.item_types.memoized(item_def_id, || {\n-    ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n-    ///         compute_type_of_item(ccx, item)\n-    ///     });\n-    /// }\n-    /// ```\n-    ///\n-    /// The key is the line marked `(*)`: the closure implicitly\n-    /// accesses the body of the item `item`, so we register a read\n-    /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n-        where OP: FnOnce() -> M::Value\n-    {\n-        let graph;\n-        {\n-            let this = self.borrow();\n-            if let Some(&(ref result, dep_node)) = this.map.get(&key) {\n-                this.graph.read_index(dep_node);\n-                return result.clone();\n-            }\n-            graph = this.graph.clone();\n-        }\n-\n-        let (result, dep_node) = graph.with_anon_task(M::to_dep_kind(), op);\n-        self.borrow_mut().map.insert(key, (result.clone(), dep_node));\n-        graph.read_index(dep_node);\n-        result\n-    }\n-}"}, {"sha": "acfdc91523f70fce25036ac59148d453d304e0b4", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -590,7 +590,7 @@ impl DepGraph {\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n                 self.try_mark_previous_green(\n-                    tcx.global_tcx(),\n+                    tcx,\n                     data,\n                     prev_index,\n                     &dep_node"}, {"sha": "43f3d7e89cd5c7236589ed72a8ca9ebea47ddcd0", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,14 +1,12 @@\n pub mod debug;\n mod dep_node;\n-mod dep_tracking_map;\n mod graph;\n mod prev;\n mod query;\n mod safe;\n mod serialized;\n pub mod cgu_reuse_tracker;\n \n-pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, RecoverKey, label_strs};\n pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;"}, {"sha": "d5e956555bdfb7e4a526027c246af743a10261cf", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -93,70 +93,102 @@ struct CheckAttrVisitor<'tcx> {\n impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n-        } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(sym::target_feature)) {\n-            self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n-                .span_label(item.span, \"not a function\")\n-                .emit();\n-        }\n-\n+        let mut is_valid = true;\n         for attr in &item.attrs {\n-            if attr.check_name(sym::inline) {\n+            is_valid &= if attr.check_name(sym::inline) {\n                 self.check_inline(attr, &item.span, target)\n             } else if attr.check_name(sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, item, target)\n             } else if attr.check_name(sym::marker) {\n                 self.check_marker(attr, item, target)\n-            }\n+            } else if attr.check_name(sym::target_feature) {\n+                self.check_target_feature(attr, item, target)\n+            } else {\n+                true\n+            };\n+        }\n+\n+        if !is_valid {\n+            return;\n+        }\n+\n+        if target == Target::Fn {\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.hir_id));\n         }\n \n         self.check_repr(item, target);\n         self.check_used(item, target);\n     }\n \n-    /// Checks if an `#[inline]` is applied to a function or a closure.\n-    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n+    /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n+    fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) -> bool {\n         if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n                              attr.span,\n                              E0518,\n                              \"attribute should be applied to function or closure\")\n                 .span_label(*span, \"not a function or closure\")\n                 .emit();\n+            false\n+        } else {\n+            true\n         }\n     }\n \n-    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid.\n-    fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_non_exhaustive(\n+        &self,\n+        attr: &hir::Attribute,\n+        item: &hir::Item,\n+        target: Target,\n+    ) -> bool {\n         match target {\n-            Target::Struct | Target::Enum => { /* Valid */ },\n+            Target::Struct | Target::Enum => true,\n             _ => {\n                 struct_span_err!(self.tcx.sess,\n                                  attr.span,\n                                  E0701,\n                                  \"attribute can only be applied to a struct or enum\")\n                     .span_label(item.span, \"not a struct or enum\")\n                     .emit();\n-                return;\n+                false\n             }\n         }\n     }\n \n-    /// Checks if the `#[marker]` attribute on an `item` is valid.\n-    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n+    /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) -> bool {\n         match target {\n-            Target::Trait => { /* Valid */ },\n+            Target::Trait => true,\n             _ => {\n                 self.tcx.sess\n                     .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n                     .span_label(item.span, \"not a trait\")\n                     .emit();\n-                return;\n+                false\n             }\n         }\n     }\n \n+    /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n+    fn check_target_feature(\n+        &self,\n+        attr: &hir::Attribute,\n+        item: &hir::Item,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Fn => true,\n+            _ => {\n+                self.tcx.sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                    .span_label(item.span, \"not a function\")\n+                    .emit();\n+                false\n+            },\n+        }\n+    }\n+\n     /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:"}, {"sha": "50fceacaa4486b09ee0d43c450586d2a5a452a6a", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -705,7 +705,6 @@ impl LoweringContext<'_> {\n                         E0628,\n                         \"generators cannot have explicit parameters\"\n                     );\n-                    self.sess.abort_if_errors();\n                 }\n                 Some(match movability {\n                     Movability::Movable => hir::GeneratorMovability::Movable,\n@@ -998,7 +997,7 @@ impl LoweringContext<'_> {\n                     E0727,\n                     \"`async` generators are not yet supported\",\n                 );\n-                self.sess.abort_if_errors();\n+                return hir::ExprKind::Err;\n             },\n             None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n         }"}, {"sha": "42a4a9909f8a94e0c433aa8a7c9b3b284360ee13", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 135, "deletions": 108, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -23,8 +23,6 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::result::Result::Err;\n-\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -183,6 +181,44 @@ pub struct Map<'hir> {\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n+struct ParentHirIterator<'map> {\n+    current_id: HirId,\n+    map: &'map Map<'map>,\n+}\n+\n+impl<'map> ParentHirIterator<'map> {\n+    fn new(current_id: HirId, map: &'map Map<'map>) -> ParentHirIterator<'map> {\n+        ParentHirIterator {\n+            current_id,\n+            map,\n+        }\n+    }\n+}\n+\n+impl<'map> Iterator for ParentHirIterator<'map> {\n+    type Item = (HirId, Node<'map>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.current_id == CRATE_HIR_ID {\n+            return None;\n+        }\n+        loop { // There are nodes that do not have entries, so we need to skip them.\n+            let parent_id = self.map.get_parent_node(self.current_id);\n+\n+            if parent_id == self.current_id {\n+                self.current_id = CRATE_HIR_ID;\n+                return None;\n+            }\n+\n+            self.current_id = parent_id;\n+            if let Some(entry) = self.map.find_entry(parent_id) {\n+                return Some((parent_id, entry.node));\n+            }\n+            // If this `HirId` doesn't have an `Entry`, skip it and look for its `parent_id`.\n+        }\n+    }\n+}\n+\n impl<'hir> Map<'hir> {\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n@@ -682,45 +718,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-\n-    /// If there is some error when walking the parents (e.g., a node does not\n-    /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n-    /// is not an error, since items in the crate module have the crate root as\n-    /// parent.\n-    fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: HirId,\n-                                found: F,\n-                                bail_early: F2)\n-        -> Result<HirId, HirId>\n-        where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n-    {\n-        let mut id = start_id;\n-        loop {\n-            let parent_id = self.get_parent_node(id);\n-            if parent_id == CRATE_HIR_ID {\n-                return Ok(CRATE_HIR_ID);\n-            }\n-            if parent_id == id {\n-                return Err(id);\n-            }\n-\n-            if let Some(entry) = self.find_entry(parent_id) {\n-                if let Node::Crate = entry.node {\n-                    return Err(id);\n-                }\n-                if found(&entry.node) {\n-                    return Ok(parent_id);\n-                } else if bail_early(&entry.node) {\n-                    return Err(parent_id);\n-                }\n-                id = parent_id;\n-            } else {\n-                return Err(id);\n-            }\n-        }\n-    }\n-\n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n@@ -744,46 +741,64 @@ impl<'hir> Map<'hir> {\n     /// }\n     /// ```\n     pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n-        let match_fn = |node: &Node<'_>| {\n-            match *node {\n+        let mut iter = ParentHirIterator::new(id, &self).peekable();\n+        let mut ignore_tail = false;\n+        if let Some(entry) = self.find_entry(id) {\n+            if let Node::Expr(Expr { kind: ExprKind::Ret(_), .. }) = entry.node {\n+                // When dealing with `return` statements, we don't care about climbing only tail\n+                // expressions.\n+                ignore_tail = true;\n+            }\n+        }\n+        while let Some((hir_id, node)) = iter.next() {\n+            if let (Some((_, next_node)), false) = (iter.peek(), ignore_tail) {\n+                match next_node {\n+                    Node::Block(Block { expr: None, .. }) => return None,\n+                    Node::Block(Block { expr: Some(expr), .. }) => {\n+                        if hir_id != expr.hir_id {\n+                            // The current node is not the tail expression of its parent.\n+                            return None;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            match node {\n                 Node::Item(_) |\n                 Node::ForeignItem(_) |\n                 Node::TraitItem(_) |\n                 Node::Expr(Expr { kind: ExprKind::Closure(..), ..}) |\n-                Node::ImplItem(_) => true,\n-                _ => false,\n-            }\n-        };\n-        let match_non_returning_block = |node: &Node<'_>| {\n-            match *node {\n+                Node::ImplItem(_) => return Some(hir_id),\n                 Node::Expr(ref expr) => {\n                     match expr.kind {\n-                        ExprKind::Loop(..) | ExprKind::Ret(..) => true,\n-                        _ => false,\n+                        // Ignore `return`s on the first iteration\n+                        ExprKind::Loop(..) | ExprKind::Ret(..) => return None,\n+                        _ => {}\n                     }\n                 }\n-                _ => false,\n+                Node::Local(_) => return None,\n+                _ => {}\n             }\n-        };\n-\n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        }\n+        None\n     }\n \n     /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            match node {\n+                Node::Crate |\n+                Node::Item(_) |\n+                Node::ForeignItem(_) |\n+                Node::TraitItem(_) |\n+                Node::ImplItem(_) => return hir_id,\n+                _ => {}\n+            }\n         }\n+        hir_id\n     }\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n@@ -795,60 +810,64 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        match self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(&Item { kind: ItemKind::Mod(_), .. }) => true,\n-            _ => false,\n-        }, |_| false) {\n-            Ok(id) => id,\n-            Err(id) => id,\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if let Node::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n+                return hir_id;\n+            }\n         }\n+        CRATE_HIR_ID\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n     pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(i) => {\n-                match i.kind {\n-                    ItemKind::Fn(..)\n-                    | ItemKind::Mod(..)\n-                    | ItemKind::Enum(..)\n-                    | ItemKind::Struct(..)\n-                    | ItemKind::Union(..)\n-                    | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ForeignItem(fi) => {\n-                match fi.kind {\n-                    ForeignItemKind::Fn(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::TraitItem(ti) => {\n-                match ti.kind {\n-                    TraitItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::ImplItem(ii) => {\n-                match ii.kind {\n-                    ImplItemKind::Method(..) => true,\n-                    _ => false,\n-                }\n-            },\n-            Node::Block(_) => true,\n-            _ => false,\n-        }, |_| false).ok()\n+        for (hir_id, node) in ParentHirIterator::new(hir_id, &self) {\n+            if match node {\n+                Node::Item(i) => {\n+                    match i.kind {\n+                        ItemKind::Fn(..)\n+                        | ItemKind::Mod(..)\n+                        | ItemKind::Enum(..)\n+                        | ItemKind::Struct(..)\n+                        | ItemKind::Union(..)\n+                        | ItemKind::Trait(..)\n+                        | ItemKind::Impl(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ForeignItem(fi) => {\n+                    match fi.kind {\n+                        ForeignItemKind::Fn(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::TraitItem(ti) => {\n+                    match ti.kind {\n+                        TraitItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::ImplItem(ii) => {\n+                    match ii.kind {\n+                        ImplItemKind::Method(..) => true,\n+                        _ => false,\n+                    }\n+                },\n+                Node::Block(_) => true,\n+                _ => false,\n+            } {\n+                return Some(hir_id);\n+            }\n+        }\n+        None\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n-            scope = self.get_enclosing_scope(scope)?;\n+            scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n             if scope == CRATE_HIR_ID {\n-                return Some(CRATE_HIR_ID);\n+                return CRATE_HIR_ID;\n             }\n             match self.get(scope) {\n                 Node::Item(i) => {\n@@ -861,7 +880,7 @@ impl<'hir> Map<'hir> {\n                 _ => break,\n             }\n         }\n-        Some(scope)\n+        scope\n     }\n \n     pub fn get_parent_did(&self, id: HirId) -> DefId {\n@@ -1064,6 +1083,14 @@ impl<'hir> Map<'hir> {\n         self.as_local_hir_id(id).map(|id| self.span(id))\n     }\n \n+    pub fn res_span(&self, res: Res) -> Option<Span> {\n+        match res {\n+            Res::Err => None,\n+            Res::Local(id) => Some(self.span(id)),\n+            res => self.span_if_local(res.opt_def_id()?),\n+        }\n+    }\n+\n     pub fn node_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }"}, {"sha": "6a88ae077c8da642b8672cbeb4e4191db1869340", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1552,7 +1552,7 @@ pub enum ExprKind {\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n     MethodCall(P<PathSegment>, Span, HirVec<Expr>),\n-    /// A tuple (e.g., `(a, b, c ,d)`).\n+    /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(HirVec<Expr>),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),"}, {"sha": "750ca4e32a64e7124f3950a3827da3152e63a2bc", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1462,7 +1462,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // type-checking closure types are in local tables only.\n         if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n             if !(param_env, ty).has_local_value() {\n-                return ty.is_copy_modulo_regions(self.tcx.global_tcx(), param_env, span);\n+                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n             }\n         }\n "}, {"sha": "2e19c9c24e9b5fd11e3e79169092f1351c5bc13e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -561,15 +561,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             def_id, instantiated_ty\n         );\n \n-        let gcx = self.tcx.global_tcx();\n-\n         // Use substs to build up a reverse map from regions to their\n         // identity mappings. This is necessary because of `impl\n         // Trait` lifetimes are computed by replacing existing\n         // lifetimes with 'static and remapping only those used in the\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(gcx, def_id);\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = opaque_defn\n             .substs\n             .iter()\n@@ -854,7 +852,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.tcx().global_tcx().mk_region(ty::ReStatic)\n+                self.tcx().mk_region(ty::ReStatic)\n             },\n         }\n     }\n@@ -1215,7 +1213,7 @@ pub fn may_define_opaque_type(\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir().get_defining_scope(opaque_hir_id).expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "c1435551a591854918a745eb7bad2ab337566da5", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -82,7 +82,7 @@ impl ExprVisitor<'tcx> {\n \n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(self.tcx.global_tcx(), from);\n+            let from = unpack_option_like(self.tcx, from);\n             if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.kind, sk_to) {\n                 if size_to == Pointer.size(&self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591,"}, {"sha": "3f5f54c94638eba2c0f71f820b18dc5c27429f7a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -749,7 +749,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                              .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n \n                     None =>\n-                        closure_substs.closure_kind(closure_def_id, self.tcx.global_tcx()),\n+                        closure_substs.closure_kind(closure_def_id, self.tcx),\n                 }\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),"}, {"sha": "cf82184ab032c4b5b40ffd665f9715ca5da548fe", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1504,7 +1504,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n+                let switch_ty = tcx.lift(&switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n                 values\n                     .iter()"}, {"sha": "d9e83df7ddda6028e2001c00a3158218060a0727", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -108,7 +108,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                     goal: obligation.goal.predicate,\n                 }, &mut orig_values);\n \n-                match infcx.tcx.global_tcx().evaluate_goal(canonical_goal) {\n+                match infcx.tcx.evaluate_goal(canonical_goal) {\n                     Ok(response) => {\n                         if response.is_proven() {\n                             making_progress = true;"}, {"sha": "9dff699deb8af6982f26e5e2a062783dca38b519", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -3,12 +3,10 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::dep_graph::{DepKind, DepTrackingMapConfig};\n-use std::marker::PhantomData;\n use crate::infer::InferCtxt;\n use crate::traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n              TraitEngine, Vtable};\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, TyCtxt};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::fold::TypeFoldable;\n \n@@ -100,33 +98,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>);\n-    type Value = Vtable<'tcx, ()>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n // # Global Cache\n \n-pub struct ProjectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for ProjectionCache<'tcx> {\n-    type Key = Ty<'tcx>;\n-    type Value = Ty<'tcx>;\n-    fn to_dep_kind() -> DepKind {\n-        DepKind::TraitSelect\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Finishes processes any obligations that remain in the\n     /// fulfillment context, and then returns the result with all type"}, {"sha": "c2d531793372a37c141a7b5df05e2db44ec52be8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             4\n         };\n \n-        let normalize = |candidate| self.tcx.global_tcx().infer_ctxt().enter(|ref infcx| {\n+        let normalize = |candidate| self.tcx.infer_ctxt().enter(|ref infcx| {\n             let normalized = infcx\n                 .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n                 .normalize(candidate)\n@@ -783,8 +783,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.global_tcx()\n-                            .object_safety_violations(trait_def_id);\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n                         if let Some(err) = self.tcx.report_object_safety_error(\n                             span,\n                             trait_def_id,\n@@ -920,7 +919,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.global_tcx().object_safety_violations(did);\n+                let violations = self.tcx.object_safety_violations(did);\n                 if let Some(err) = self.tcx.report_object_safety_error(span, did, violations) {\n                     err\n                 } else {"}, {"sha": "a981162fdc326130d8518a7b3f99595b6aa04629", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 } else {\n                     if !substs.has_local_value() {\n                         let instance = ty::Instance::resolve(\n-                            self.selcx.tcx().global_tcx(),\n+                            self.selcx.tcx(),\n                             obligation.param_env,\n                             def_id,\n                             substs,"}, {"sha": "aa30541610e9b8e1ef9f740a8092bf09ff8e1708", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -40,12 +40,11 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n             };\n         }\n \n-        let gcx = tcx.global_tcx();\n         let mut orig_values = OriginalQueryValues::default();\n         let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = &gcx.dropck_outlives(c_ty) {\n+        if let Ok(result) = &tcx.dropck_outlives(c_ty) {\n             if result.is_proven() {\n                 if let Ok(InferOk { value, obligations }) =\n                     self.infcx.instantiate_query_response_and_region_obligations("}, {"sha": "17684df7e9b8eb79579abf8573c07f3c0a815de0", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -50,7 +50,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // Run canonical query. If overflow occurs, rerun from scratch but this time\n         // in standard trait query mode so that overflow is handled appropriately\n         // within `SelectionContext`.\n-        self.tcx.global_tcx().evaluate_obligation(c_pred)\n+        self.tcx.evaluate_obligation(c_pred)\n     }\n \n     // Helper function that canonicalizes and runs the query. If an"}, {"sha": "ab42eab28440f91494616b347db6c6ec19ab4b64", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -141,7 +141,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let gcx = self.infcx.tcx.global_tcx();\n+                let tcx = self.infcx.tcx;\n \n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n@@ -150,7 +150,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                match gcx.normalize_projection_ty(c_data) {\n+                match tcx.normalize_projection_ty(c_data) {\n                     Ok(result) => {\n                         // We don't expect ambiguity.\n                         if result.is_ambiguous() {"}, {"sha": "f5808b6b5faaf03b9811d488ec84c50079ce11ef", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n         let mut orig_values = OriginalQueryValues::default();\n         let key = self.canonicalize_query(&param_env.and(ty), &mut orig_values);\n-        let result = match self.tcx.global_tcx().implied_outlives_bounds(key) {\n+        let result = match self.tcx.implied_outlives_bounds(key) {\n             Ok(r) => r,\n             Err(NoSolution) => {\n                 self.tcx.sess.delay_span_bug("}, {"sha": "34aa4ee78da30c780d6b00648923fc8f13689dca", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::hir::def_id::DefId;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -37,12 +37,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "3653f9268dcdea393fccc854894ce64bee772d99", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -34,12 +34,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_eq(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "12a834fbda6bd46011257b1398accaa32c9a03fa", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n@@ -38,12 +38,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n \n         tcx.implied_outlives_bounds(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "98e535234b6302b9888330976a5476f89b01a4b6", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{\n-    Canonical, Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n-    QueryRegionConstraints, QueryResponse,\n+    Canonicalized, CanonicalizedQueryResponse, OriginalQueryValues,\n+    QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n use std::fmt;\n@@ -66,22 +66,6 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>>;\n \n-    /// Casts a lifted query result (which is in the gcx lifetime)\n-    /// into the tcx lifetime. This is always just an identity cast,\n-    /// but the generic code doesn't realize it -- put another way, in\n-    /// the generic code, we have a `Lifted<'tcx, Self::QueryResponse>`\n-    /// and we want to convert that to a `Self::QueryResponse`. This is\n-    /// not a priori valid, so we can't do it -- but in practice, it\n-    /// is always a no-op (e.g., the lifted form of a type,\n-    /// `Ty<'tcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n-    /// the operation into the impls that know more specifically what\n-    /// `QueryResponse` is. This operation would (maybe) be nicer with\n-    /// something like HKTs or GATs, since then we could make\n-    /// `QueryResponse` parametric and `'tcx` and `'tcx` etc.\n-    fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>>;\n-\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -99,7 +83,6 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n         let canonical_self =\n             infcx.canonicalize_hr_query_hack(&query_key, &mut canonical_var_values);\n         let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n-        let canonical_result = Self::shrink_to_tcx_lifetime(&canonical_result);\n \n         let param_env = query_key.param_env;\n "}, {"sha": "2138f792d45bbd5ea07308030f61849b2e5695c9", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use std::fmt;\n use crate::traits::query::Fallible;\n use crate::ty::fold::TypeFoldable;\n@@ -38,25 +38,13 @@ where\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, T>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, T>> {\n-        T::shrink_to_tcx_lifetime(v)\n-    }\n }\n \n pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'tcx> + Copy {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonicalized<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>>;\n-\n-    /// Converts from the `'tcx` (lifted) form of `Self` into the `tcx`\n-    /// form of `Self`.\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>>;\n }\n \n impl Normalizable<'tcx> for Ty<'tcx> {\n@@ -66,12 +54,6 @@ impl Normalizable<'tcx> for Ty<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::Predicate<'tcx> {\n@@ -81,12 +63,6 @@ impl Normalizable<'tcx> for ty::Predicate<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n@@ -96,12 +72,6 @@ impl Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n@@ -111,12 +81,6 @@ impl Normalizable<'tcx> for ty::FnSig<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, Self>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "9b956f3e55408a9d6bd4616eab4e317833829ff7", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::dropck_outlives::trivial_dropck_outlives;\n use crate::traits::query::dropck_outlives::DropckOutlivesResult;\n use crate::traits::query::Fallible;\n@@ -53,12 +53,6 @@ impl super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n \n         tcx.dropck_outlives(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        lifted_query_result: &'a CanonicalizedQueryResponse<'tcx, Self::QueryResponse>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, Self::QueryResponse>> {\n-        lifted_query_result\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "2a908d0f66e5b6e30706af011b21940250a09b8c", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n@@ -43,12 +43,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "c89a55daa095e1763d1f43baa7aca9eeea687286", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResponse, QueryResponse};\n+use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n@@ -34,12 +34,6 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, ()>> {\n         tcx.type_op_subtype(canonicalized)\n     }\n-\n-    fn shrink_to_tcx_lifetime(\n-        v: &'a CanonicalizedQueryResponse<'tcx, ()>,\n-    ) -> &'a Canonical<'tcx, QueryResponse<'tcx, ()>> {\n-        v\n-    }\n }\n \n BraceStructTypeFoldableImpl! {"}, {"sha": "e1ca9a16d965f690eb5df33c39b0d439659c1ed2", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -2491,7 +2491,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if other.evaluation.must_apply_modulo_regions() {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n-                            let tcx = self.tcx().global_tcx();\n+                            let tcx = self.tcx();\n                             return tcx.specializes((other_def, victim_def))\n                                 || tcx.impls_are_allowed_to_overlap(\n                                     other_def, victim_def).is_some();"}, {"sha": "ce0f43021378b22073f3252b7ea398e3b05d082b", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -162,7 +162,6 @@ impl<'tcx> Children {\n                 }\n             };\n \n-            let tcx = tcx.global_tcx();\n             let (le, ge) = traits::overlapping_impls(\n                 tcx,\n                 possible_sibling,"}, {"sha": "18ec2241b2df89605db8ceca1d7a78bf9ec49d49", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -661,8 +661,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n             }\n             None => {\n-                self.global_tcx()\n-                    .impl_defaultness(node_item_def_id)\n+                self.impl_defaultness(node_item_def_id)\n                     .is_default()\n             }\n         }"}, {"sha": "efbc820365e2db5acbb1c391077d835b2bd84e7b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1067,14 +1067,6 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Gets the global `TyCtxt`.\n-    #[inline]\n-    pub fn global_tcx(self) -> TyCtxt<'tcx> {\n-        TyCtxt {\n-            gcx: self.gcx,\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn hir(self) -> &'tcx hir_map::Map<'tcx> {\n         &self.hir_map\n@@ -1156,11 +1148,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         value.lift_to_tcx(self)\n     }\n \n-    /// Like lift, but only tries in the global tcx.\n-    pub fn lift_to_global<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n-        value.lift_to_tcx(self.global_tcx())\n-    }\n-\n     /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n@@ -1432,7 +1419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                            -> Result<(), E::Error>\n         where E: ty::codec::TyEncoder\n     {\n-        self.queries.on_disk_cache.serialize(self.global_tcx(), encoder)\n+        self.queries.on_disk_cache.serialize(self, encoder)\n     }\n \n     /// If `true`, we should use the MIR-based borrowck, but also\n@@ -1600,7 +1587,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n         let tcx = TyCtxt {\n             gcx: self,\n         };\n-        ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n+        ty::tls::with_related_context(tcx, |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n                 query: icx.query.clone(),\n@@ -2425,7 +2412,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, ty::Const::from_usize(self.global_tcx(), n)))\n+        self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n     }\n \n     #[inline]\n@@ -2640,7 +2627,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.len() == 0 {\n             List::empty()\n         } else {\n-            self.global_tcx()._intern_canonical_var_infos(ts)\n+            self._intern_canonical_var_infos(ts)\n         }\n     }\n "}, {"sha": "5851a48a8d3773edc3dc816a0506f3760475d408", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -193,7 +193,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(_, n) => {\n-                let n = tcx.lift_to_global(&n).unwrap();\n+                let n = tcx.lift(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     Some(n) => {\n                         format!(\"array of {} element{}\", n, pluralise!(n)).into()"}, {"sha": "741830f205cb0a56a83c99ac0f3326de500a9854", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -210,7 +210,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn mono(tcx: TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n+        Instance::new(def_id, tcx.empty_substs_for_def_id(def_id))\n     }\n \n     #[inline]"}, {"sha": "3accbdf9bcbc6314d0aa88d264dc81413095feae", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1883,7 +1883,7 @@ impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n \n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.global_tcx()\n+        *self\n     }\n }\n \n@@ -2003,7 +2003,7 @@ impl TyCtxt<'tcx> {\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self.global_tcx(),\n+            tcx: self,\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)\n@@ -2017,7 +2017,7 @@ impl ty::query::TyCtxtAt<'tcx> {\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self.global_tcx().at(self.span),\n+            tcx: self.at(self.span),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)"}, {"sha": "0e9600449f62c7088032b8bb651eb901b08b3dc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -2378,7 +2378,7 @@ impl<'tcx> AdtDef {\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n         let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n-        let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), expr_did);\n+        let substs = InternalSubsts::identity_for_item(tcx, expr_did);\n         let instance = ty::Instance::new(expr_did, substs);\n         let cid = GlobalId {\n             instance,\n@@ -2387,7 +2387,7 @@ impl<'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.try_eval_bits(tcx.global_tcx(), param_env, val.ty) {\n+                if let Some(b) = val.try_eval_bits(tcx, param_env, val.ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,\n@@ -2423,7 +2423,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n         let repr_type = self.repr.discr_type();\n-        let initial = repr_type.initial_discriminant(tcx.global_tcx());\n+        let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n         self.variants.iter_enumerated().map(move |(i, v)| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n@@ -2457,7 +2457,7 @@ impl<'tcx> AdtDef {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n-            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx.global_tcx()));\n+            .unwrap_or_else(|| self.repr.discr_type().initial_discriminant(tcx));\n         explicit_value.checked_add(tcx, offset as u128).0\n     }\n "}, {"sha": "e004fa07f2c0fb421ea95d4e8f5586a01fe5215f", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -917,7 +917,7 @@ pub trait PrettyPrinter<'tcx>:\n                     let min = 1u128 << (bit_size - 1);\n                     let max = min - 1;\n \n-                    let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n+                    let ty = self.tcx().lift(&ct.ty).unwrap();\n                     let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                         .unwrap()\n                         .size;"}, {"sha": "d247c0f9f69f3d4eb8d12f02da6343a4be01876f", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         tls::with_related_context(self, move |current_icx| {\n             // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n-                tcx: self.global_tcx(),\n+                tcx: self,\n                 query: Some(job),\n                 diagnostics,\n                 layout_depth: current_icx.layout_depth,\n@@ -274,7 +274,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n-                compute(self.global_tcx())\n+                compute(self)\n             })\n         })\n     }\n@@ -384,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n                     tcx.dep_graph.with_anon_task(Q::dep_kind(), || {\n-                        Q::compute(tcx.global_tcx(), key)\n+                        Q::compute(tcx, key)\n                     })\n                 })\n             });\n@@ -445,10 +445,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n         // First we try to load the result from the on-disk cache.\n-        let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n+        let result = if Q::cache_on_disk(self, key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n-            let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n+            let result = Q::try_load_from_disk(self, prev_dep_node_index);\n             self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n@@ -643,7 +643,7 @@ impl<'tcx> TyCtxt<'tcx> {\n macro_rules! handle_cycle_error {\n     ([][$tcx: expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n-        Value::from_cycle_error($tcx.global_tcx())\n+        Value::from_cycle_error($tcx)\n     }};\n     ([fatal_cycle$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n@@ -652,7 +652,7 @@ macro_rules! handle_cycle_error {\n     }};\n     ([cycle_delay_bug$(, $modifiers:ident)*][$tcx:expr, $error:expr]) => {{\n         $tcx.report_cycle($error).delay_as_bug();\n-        Value::from_cycle_error($tcx.global_tcx())\n+        Value::from_cycle_error($tcx)\n     }};\n     ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n         handle_cycle_error!([$($modifiers),*][$($args)*])\n@@ -999,7 +999,7 @@ macro_rules! define_queries_inner {\n                         // would be missing appropriate entries in `providers`.\n                         .unwrap_or(&tcx.queries.fallback_extern_providers)\n                         .$name;\n-                    provider(tcx.global_tcx(), key)\n+                    provider(tcx, key)\n                 })\n             }\n "}, {"sha": "0f472126695e0720cacd8138162c6d79e3707a56", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,10 +1,9 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n+use rustc_data_structures::sync::Lock;\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::Cell;\n use std::fmt::Debug;\n-use std::hash::Hash;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n@@ -279,39 +278,3 @@ pub fn indenter() -> Indenter {\n     debug!(\">>\");\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n-\n-pub trait MemoizationMap {\n-    type Key: Clone;\n-    type Value: Clone;\n-\n-    /// If `key` is present in the map, return the value,\n-    /// otherwise invoke `op` and store the value in the map.\n-    ///\n-    /// N.B., if the receiver is a `DepTrackingMap`, special care is\n-    /// needed in the `op` to ensure that the correct edges are\n-    /// added into the dep graph. See the `DepTrackingMap` impl for\n-    /// more details!\n-    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n-        where OP: FnOnce() -> Self::Value;\n-}\n-\n-impl<K, V> MemoizationMap for RefCell<FxHashMap<K,V>>\n-    where K: Hash+Eq+Clone, V: Clone\n-{\n-    type Key = K;\n-    type Value = V;\n-\n-    fn memoize<OP>(&self, key: K, op: OP) -> V\n-        where OP: FnOnce() -> V\n-    {\n-        let result = self.borrow().get(&key).cloned();\n-        match result {\n-            Some(result) => result,\n-            None => {\n-                let result = op();\n-                self.borrow_mut().insert(key, result.clone());\n-                result\n-            }\n-        }\n-    }\n-}"}, {"sha": "aa74966d0ab4cf65cfd6b7e07310cc76c59bbd3d", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -13,7 +13,7 @@ crate-type = [\"dylib\"]\n graphviz = { path = \"../libgraphviz\" }\n lazy_static = \"1.0\"\n log = \"0.4\"\n-env_logger = { version = \"0.6\", default-features = false }\n+env_logger = { version = \"0.7\", default-features = false }\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "9a68dd0f5e3ced95e1ee9b3fd42d7b042e8fbbf5", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -442,8 +442,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                                          .map(|c| c.is_green())\n                                          .unwrap_or(false));\n \n-                        let key = RecoverKey::recover(tcx.global_tcx(), self).unwrap();\n-                        if queries::#name::cache_on_disk(tcx.global_tcx(), key, None) {\n+                        let key = RecoverKey::recover(tcx, self).unwrap();\n+                        if queries::#name::cache_on_disk(tcx, key, None) {\n                             let _ = tcx.#name(key);\n                         }\n                     }"}, {"sha": "cf80a1bc6437e040ee1eb0df5344169c57183704", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -621,18 +621,18 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 target: _,\n                 unwind: _,\n             } => {\n-                let gcx = self.infcx.tcx.global_tcx();\n+                let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n                 let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n \n-                // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n+                // \"Lift\" into the tcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n                 // that is useful later.\n-                gcx.lift_to_global(&drop_place_ty).unwrap();\n+                tcx.lift(&drop_place_ty).unwrap();\n \n                 debug!(\"visit_terminator_drop \\\n                         loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\","}, {"sha": "b981c76905c14155cca84a422091541260ab4c97", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1894,9 +1894,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Erase the regions from `ty` to get a global type.  The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n-        let gcx = tcx.global_tcx();\n         let erased_ty = tcx.erase_regions(&ty);\n-        if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "9f9450188fa94b6794ad46fdf3ecbe8e162bcaef", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -521,9 +521,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let gcx = tcx.global_tcx();\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n-        let identity_substs = InternalSubsts::identity_for_item(gcx, closure_base_def_id);\n+        let identity_substs = InternalSubsts::identity_for_item(tcx, closure_base_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, ClosureSubsts { ref substs })\n             | DefiningTy::Generator(_, GeneratorSubsts { ref substs }, _) => {\n@@ -542,7 +541,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::FnDef(_, substs) | DefiningTy::Const(_, substs) => substs,\n         };\n \n-        let global_mapping = iter::once((gcx.lifetimes.re_static, fr_static));\n+        let global_mapping = iter::once((tcx.lifetimes.re_static, fr_static));\n         let subst_mapping = identity_substs\n             .regions()\n             .zip(fr_substs.regions().map(|r| r.to_region_vid()));"}, {"sha": "0fe58c07b1b866bcd2742011e02195be6e1f8ec0", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -148,9 +148,8 @@ pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n         let ty = place.ty(body, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n-        let gcx = tcx.global_tcx();\n         let erased_ty = tcx.erase_regions(&ty);\n-        if erased_ty.needs_drop(gcx, ctxt.param_env) {\n+        if erased_ty.needs_drop(tcx, ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")"}, {"sha": "eed51cdab8c3cf2845906b06475f7778863923df", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -543,9 +543,9 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n             let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let substs = InternalSubsts::identity_for_item(cx.tcx.global_tcx(), def_id);\n+            let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n             let instance = ty::Instance::resolve(\n-                cx.tcx.global_tcx(),\n+                cx.tcx,\n                 cx.param_env,\n                 def_id,\n                 substs,"}, {"sha": "32efbd6f011730d92a381491462f66dc22c606fc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             infcx,\n             root_lint_level: src_id,\n             param_env: tcx.param_env(src_def_id),\n-            identity_substs: InternalSubsts::identity_for_item(tcx.global_tcx(), src_def_id),\n+            identity_substs: InternalSubsts::identity_for_item(tcx, src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n             tables,\n             constness,\n@@ -154,12 +154,11 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pat<'tcx> {\n-        let tcx = self.tcx.global_tcx();\n-        let p = match tcx.hir().get(p.hir_id) {\n+        let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n-        Pat::from_hir(tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n+        Pat::from_hir(self.tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n     }\n \n     pub fn trait_method(&mut self,\n@@ -187,7 +186,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx.global_tcx(), self.param_env)\n+        ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "c521b7352214bdf47841a5e7235179361206dd9d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -266,20 +266,51 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            err.span_label(pat.span, match &pat.kind {\n+            match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                    if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n-                    format!(\"interpreted as {} {} pattern, not new variable\",\n-                            path.res.article(), path.res.descr())\n+                    if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+                {\n+                    const_not_var(&mut err, cx.tcx, pat, path);\n                 }\n-                _ => pattern_not_convered_label(&witnesses, &joined_patterns),\n-            });\n+                _ => {\n+                    err.span_label(\n+                        pat.span,\n+                        pattern_not_covered_label(&witnesses, &joined_patterns),\n+                    );\n+                }\n+            }\n+\n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n             err.emit();\n         });\n     }\n }\n \n+/// A path pattern was interpreted as a constant, not a new variable.\n+/// This caused an irrefutable match failure in e.g. `let`.\n+fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n+    let descr = path.res.descr();\n+    err.span_label(pat.span, format!(\n+        \"interpreted as {} {} pattern, not a new variable\",\n+        path.res.article(),\n+        descr,\n+    ));\n+\n+    err.span_suggestion(\n+        pat.span,\n+        \"introduce a variable instead\",\n+        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n+        // Cannot use `MachineApplicable` as it's not really *always* correct\n+        // because there may be such an identifier in scope or the user maybe\n+        // really wanted to match against the constant. This is quite unlikely however.\n+        Applicability::MaybeIncorrect,\n+    );\n+\n+    if let Some(span) = tcx.hir().res_span(path.res) {\n+        err.span_label(span, format!(\"{} defined here\", descr));\n+    }\n+}\n+\n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n@@ -445,7 +476,7 @@ fn check_exhaustive<'tcx>(\n         cx.tcx.sess, sp,\n         format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n     );\n-    err.span_label(sp, pattern_not_convered_label(&witnesses, &joined_patterns));\n+    err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n@@ -471,7 +502,7 @@ fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     }\n }\n \n-fn pattern_not_convered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n+fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralise!(witnesses.len()), joined_patterns)\n }\n "}, {"sha": "4fae0976ffb5a1302c9c4a05e31f4a5b08a265c9", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -79,7 +79,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once } => {\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n-            let call_mut = tcx.global_tcx()\n+            let call_mut = tcx\n                 .associated_items(fn_mut)\n                 .find(|it| it.kind == ty::AssocKind::Method)\n                 .unwrap().def_id;"}, {"sha": "54d580ec05d71263248e2d107f55f295f5cb062b", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -474,7 +474,7 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n         &self,\n         value: DelayedLiteral<ChalkArenas<'tcx>>,\n     ) -> DelayedLiteral<ChalkArenas<'tcx>> {\n-        match self.infcx.tcx.lift_to_global(&value) {\n+        match self.infcx.tcx.lift(&value) {\n             Some(literal) => literal,\n             None => bug!(\"cannot lift {:?}\", value),\n         }"}, {"sha": "5ab2ca280d5cdf742a1974b364c4419d9e52d8ac", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1269,7 +1269,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // to avoid ICEs.\n         for item in &regular_traits {\n             let object_safety_violations =\n-                tcx.global_tcx().astconv_object_safety_violations(item.trait_ref().def_id());\n+                tcx.astconv_object_safety_violations(item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n                 tcx.report_object_safety_error(\n                     span,\n@@ -1368,11 +1368,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     span,\n                     format!(\"associated type `{}` must be specified\", assoc_item.ident),\n                 );\n-                if item_def_id.is_local() {\n-                    err.span_label(\n-                        tcx.def_span(*item_def_id),\n-                        format!(\"`{}` defined here\", assoc_item.ident),\n-                    );\n+                if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n+                    err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n                 }\n                 if suggest {\n                     if let Ok(snippet) = tcx.sess.source_map().span_to_snippet("}, {"sha": "7e0a3e781883e43ac7a2c18914dff992c75843d3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -351,16 +351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n-                    let def_span = match def {\n-                        Res::Err => None,\n-                        Res::Local(id) => {\n-                            Some(self.tcx.hir().span(id))\n-                        },\n-                        _ => def\n-                            .opt_def_id()\n-                            .and_then(|did| self.tcx.hir().span_if_local(did)),\n-                    };\n-                    if let Some(span) = def_span {\n+                    if let Some(span) = self.tcx.hir().res_span(def) {\n                         let label = match (unit_variant, inner_callee_path) {\n                             (Some(path), _) => format!(\"`{}` defined here\", path),\n                             (_, Some(hir::QPath::Resolved(_, path))) => format!("}, {"sha": "0cdf2fa2a5b9e7192a4ce13490416aa098cf814b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -620,8 +620,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n-            struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                \"return statement outside of function body\").emit();\n+            struct_span_err!(\n+                self.tcx.sess,\n+                expr.span,\n+                E0572,\n+                \"return statement outside of function body\",\n+            ).emit();\n         } else if let Some(ref e) = expr_opt {\n             if self.ret_coercion_span.borrow().is_none() {\n                 *self.ret_coercion_span.borrow_mut() = Some(e.span);\n@@ -932,9 +936,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(self.to_const(count, tcx.type_of(count_def_id)))\n         } else {\n             let param_env = ty::ParamEnv::empty();\n-            let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let substs = InternalSubsts::identity_for_item(tcx, count_def_id);\n             let instance = ty::Instance::resolve(\n-                tcx.global_tcx(),\n+                tcx,\n                 param_env,\n                 count_def_id,\n                 substs,"}, {"sha": "20c517d779b42c0c6057682b1c290d0d8ac7b132", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n                 // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n-            let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n+            let wf_tys = f(&fcx, fcx.tcx);\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n@@ -366,8 +366,8 @@ fn check_item_type(\n ) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx, gcx| {\n-        let ty = gcx.type_of(gcx.hir().local_def_id(item_id));\n+    for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n+        let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, &ty);\n \n         let mut forbid_unsized = true;"}, {"sha": "1e3939cbfcdf284d503ded7cd6e9bc0ff27c8f37", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -322,29 +322,29 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n     }\n }\n \n-pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = gcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n-        gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+    let unsize_trait = tcx.lang_items().require(UnsizeTraitLangItem).unwrap_or_else(|err| {\n+        tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = gcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = gcx.type_of(impl_did);\n-    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n+    let source = tcx.type_of(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = gcx.hir().span(impl_hir_id);\n-    let param_env = gcx.param_env(impl_did);\n+    let span = tcx.hir().span(impl_hir_id);\n+    let param_env = tcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -353,7 +353,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n            source,\n            target);\n \n-    gcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_hir_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -372,24 +372,24 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n                 let mt_b = ty::TypeAndMut { ty: ty_b, mutbl: mutbl_b };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::Ref(_, ty_a, mutbl_a), &ty::RawPtr(mt_b)) => {\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::RawPtr(mt_a), &ty::RawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                       def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = gcx.def_path_str(def_a.did);\n-                    let target_path = gcx.def_path_str(def_b.did);\n-                    span_err!(gcx.sess,\n+                    let source_path = tcx.def_path_str(def_a.did);\n+                    let target_path = tcx.def_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -443,9 +443,9 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                        if gcx.type_of(f.did).is_phantom_data() {\n+                        if tcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -472,22 +472,22 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(gcx.sess,\n+                    span_err!(tcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item(impl_hir_id);\n+                    let item = tcx.hir().expect_item(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span(impl_hir_id)\n+                        tcx.hir().span(impl_hir_id)\n                     };\n \n-                    let mut err = struct_span_err!(gcx.sess,\n+                    let mut err = struct_span_err!(tcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -514,7 +514,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             _ => {\n-                span_err!(gcx.sess,\n+                span_err!(tcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -527,7 +527,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-        let predicate = gcx.predicate_for_trait_def(param_env,\n+        let predicate = tcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}, {"sha": "db017394cd5f163fb636879097bddbe48ebf2727", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1717,9 +1717,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope = tcx.hir()\n-        .get_defining_scope(hir_id)\n-        .expect(\"could not get defining scope\");\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,"}, {"sha": "69abbde9e6eba39f77b8adfd6d3e15f4d97484b9", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -714,15 +714,14 @@ where\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(map_get_key_value)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n-    #[unstable(feature = \"map_get_key_value\", issue = \"49347\")]\n+    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     #[inline]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where"}, {"sha": "02f664760c08cee91ba55037a5b12565efe9dbc9", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -566,7 +566,9 @@ mod prim_array { }\n #[doc(alias = \"[\")]\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n-/// A dynamically-sized view into a contiguous sequence, `[T]`.\n+/// A dynamically-sized view into a contiguous sequence, `[T]`. Contiguous here\n+/// means that elements are layed out so that every element is the same\n+/// distance from its neighbors.\n ///\n /// *[See also the `std::slice` module](slice/index.html).*\n ///"}, {"sha": "7446471ae3122c2bdeb660f773c573e22d7edb69", "filename": "src/libstd/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -54,8 +54,8 @@ impl Command {\n \n             let ret = libc::rtpSpawn(\n                 self.get_argv()[0],                   // executing program\n-                self.get_argv().as_ptr() as *const _, // argv\n-                *sys::os::environ() as *const *const c_char,\n+                self.get_argv().as_ptr() as *mut *const c_char, // argv\n+                *sys::os::environ() as *mut *const c_char,\n                 100 as c_int,                         // initial priority\n                 thread::min_stack(),                  // initial stack size.\n                 0,                                    // options"}, {"sha": "bcda5384204d8de3caa0db0dc0c9d5396f5edb4f", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1546,6 +1546,7 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) ->\n                 }\n             }\n         }\n+        (&ShouldPanic::Yes, Ok(())) => TrFailedMsg(\"test did not panic as expected\".to_string()),\n         _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n     }"}, {"sha": "38ec7bd70930c44fd77f7efb7640e6f4d51a1963", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n use crate::test::{\n     filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailedMsg,\n     TrIgnored, TrOk,\n };\n use std::sync::mpsc::channel;\n@@ -167,7 +167,7 @@ fn test_should_panic_but_succeeds() {\n     let (tx, rx) = channel();\n     run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n-    assert!(res == TrFailed);\n+    assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {"}, {"sha": "ae044eb843bd95659b07f0ca3eefac9288070a20", "filename": "src/test/ui/attributes/multiple-invalid.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -0,0 +1,10 @@\n+// This test checks that all expected errors occur when there are multiple invalid attributes\n+// on an item.\n+\n+#[inline]\n+//~^ ERROR attribute should be applied to function or closure [E0518]\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+const FOO: u8 = 0;\n+\n+fn main() { }"}, {"sha": "9bd29f15dbcca9d660159e5795ee0e32deb7bcbc", "filename": "src/test/ui/attributes/multiple-invalid.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -0,0 +1,21 @@\n+error[E0518]: attribute should be applied to function or closure\n+  --> $DIR/multiple-invalid.rs:4:1\n+   |\n+LL | #[inline]\n+   | ^^^^^^^^^\n+...\n+LL | const FOO: u8 = 0;\n+   | ------------------ not a function or closure\n+\n+error: attribute should be applied to a function\n+  --> $DIR/multiple-invalid.rs:6:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | const FOO: u8 = 0;\n+   | ------------------ not a function\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0518`."}, {"sha": "4814aa9a5b2cadc4f76de28b051a10a8f022f67e", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,20 +1,38 @@\n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n+LL | const a: u8 = 2;\n+   | ---------------- constant defined here\n+...\n LL |     let a = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `a_var`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n+LL |     pub const b: u8 = 2;\n+   |     -------------------- constant defined here\n+...\n LL |     let c = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `c_var`\n \n error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n+LL |     pub const d: u8 = 2;\n+   |     -------------------- constant defined here\n+...\n LL |     let d = 4;\n-   |         ^ interpreted as a constant pattern, not new variable\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `d_var`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6b5a557933953381296326acd8fe24b83f27ef35", "filename": "src/test/ui/generator/no-parameters-on-generators.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -2,6 +2,7 @@\n \n fn main() {\n     let gen = |start| { //~ ERROR generators cannot have explicit parameters\n+        //~^ ERROR type inside generator must be known in this context\n         yield;\n     };\n }"}, {"sha": "5e8e043a391ce280810483861084730b95dc77c9", "filename": "src/test/ui/generator/no-parameters-on-generators.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -4,5 +4,18 @@ error[E0628]: generators cannot have explicit parameters\n LL |     let gen = |start| {\n    |               ^^^^^^^\n \n-error: aborting due to previous error\n+error[E0698]: type inside generator must be known in this context\n+  --> $DIR/no-parameters-on-generators.rs:4:16\n+   |\n+LL |     let gen = |start| {\n+   |                ^^^^^ cannot infer type\n+   |\n+note: the type is part of the generator because of this `yield`\n+  --> $DIR/no-parameters-on-generators.rs:6:9\n+   |\n+LL |         yield;\n+   |         ^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0698`."}, {"sha": "85cbc787bc2db5b50e5156a3d4dd075572afb02a", "filename": "src/test/ui/struct-literal-variant-in-if.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstruct-literal-variant-in-if.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -49,9 +49,6 @@ LL |     if x == E::V { field } {}\n error[E0308]: mismatched types\n   --> $DIR/struct-literal-variant-in-if.rs:10:20\n    |\n-LL | fn test_E(x: E) {\n-   |                 - help: try adding a return type: `-> bool`\n-LL |     let field = true;\n LL |     if x == E::V { field } {}\n    |                    ^^^^^ expected (), found bool\n    |"}, {"sha": "2a11871db8e679dcf69c6387a69c83108d46d092", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    let A = 3;\n+    //~^ ERROR refutable pattern in local binding: `std::i32::MIN..=1i32` and\n+    //~| interpreted as a constant pattern, not a new variable\n+    //~| HELP introduce a variable instead\n+    //~| SUGGESTION a_var\n+\n+    const A: i32 = 2;\n+    //~^ constant defined here\n+}"}, {"sha": "fc17199bf91d4ac3363ffc31410836d70a275b15", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -0,0 +1,15 @@\n+error[E0005]: refutable pattern in local binding: `std::i32::MIN..=1i32` and `3i32..=std::i32::MAX` not covered\n+  --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n+   |\n+LL |     let A = 3;\n+   |         ^\n+   |         |\n+   |         interpreted as a constant pattern, not a new variable\n+   |         help: introduce a variable instead: `a_var`\n+...\n+LL |     const A: i32 = 2;\n+   |     ----------------- constant defined here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "47ca5a5ca478c5c0a3a30604712f36a40c2c3c86", "filename": "src/test/ui/target-feature-wrong.stderr", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6f87c2c6e3b34381e5c37567a2b11af1fdf1507/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature-wrong.stderr?ref=c6f87c2c6e3b34381e5c37567a2b11af1fdf1507", "patch": "@@ -1,50 +0,0 @@\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:16:1\n-   |\n-LL | #[target_feature = \"+sse2\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[target_feature(enable = \"name\")]`\n-\n-error: the feature named `foo` is not valid for this target\n-  --> $DIR/target-feature-wrong.rs:18:18\n-   |\n-LL | #[target_feature(enable = \"foo\")]\n-   |                  ^^^^^^^^^^^^^^ `foo` is not valid for this target\n-\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:21:18\n-   |\n-LL | #[target_feature(bar)]\n-   |                  ^^^ help: must be of the form: `enable = \"..\"`\n-\n-error: malformed `target_feature` attribute input\n-  --> $DIR/target-feature-wrong.rs:23:18\n-   |\n-LL | #[target_feature(disable = \"baz\")]\n-   |                  ^^^^^^^^^^^^^^^ help: must be of the form: `enable = \"..\"`\n-\n-error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n-  --> $DIR/target-feature-wrong.rs:27:1\n-   |\n-LL | #[target_feature(enable = \"sse2\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n-...\n-LL | fn bar() {}\n-   | ----------- not an `unsafe` function\n-\n-error: attribute should be applied to a function\n-  --> $DIR/target-feature-wrong.rs:33:1\n-   |\n-LL | #[target_feature(enable = \"sse2\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |\n-LL | mod another {}\n-   | -------------- not a function\n-\n-error: cannot use `#[inline(always)]` with `#[target_feature]`\n-  --> $DIR/target-feature-wrong.rs:38:1\n-   |\n-LL | #[inline(always)]\n-   | ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-"}, {"sha": "bc7f7caa1076663e66b98ec01872da0c4e11e034", "filename": "src/test/ui/target-feature/gate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "previous_filename": "src/test/ui/target-feature-gate.rs"}, {"sha": "05dbc6e90adc8a054ed5d06133324132402632ec", "filename": "src/test/ui/target-feature/gate.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Fgate.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: the target feature `avx512bw` is currently unstable\n-  --> $DIR/target-feature-gate.rs:30:18\n+  --> $DIR/gate.rs:30:18\n    |\n LL | #[target_feature(enable = \"avx512bw\")]\n    |                  ^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/target-feature-gate.stderr"}, {"sha": "46680336632f905459f4bba3585bf55b180462a9", "filename": "src/test/ui/target-feature/invalid-attribute.rs", "status": "renamed", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.rs?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -35,6 +35,31 @@ fn bar() {}\n mod another {}\n //~^ NOTE not a function\n \n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+const FOO: usize = 7;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+struct Foo;\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+enum Bar { }\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+union Qux { f1: u16, f2: u16 }\n+//~^ NOTE not a function\n+\n+#[target_feature(enable = \"sse2\")]\n+//~^ ERROR attribute should be applied to a function\n+trait Baz { }\n+//~^ NOTE not a function\n+\n #[inline(always)]\n //~^ ERROR: cannot use `#[inline(always)]`\n #[target_feature(enable = \"sse2\")]", "previous_filename": "src/test/ui/target-feature-wrong.rs"}, {"sha": "abfe5dd219770c4ed7db515e1a2c0cfeec42a61a", "filename": "src/test/ui/target-feature/invalid-attribute.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -0,0 +1,95 @@\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:16:1\n+   |\n+LL | #[target_feature = \"+sse2\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[target_feature(enable = \"name\")]`\n+\n+error: the feature named `foo` is not valid for this target\n+  --> $DIR/invalid-attribute.rs:18:18\n+   |\n+LL | #[target_feature(enable = \"foo\")]\n+   |                  ^^^^^^^^^^^^^^ `foo` is not valid for this target\n+\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:21:18\n+   |\n+LL | #[target_feature(bar)]\n+   |                  ^^^ help: must be of the form: `enable = \"..\"`\n+\n+error: malformed `target_feature` attribute input\n+  --> $DIR/invalid-attribute.rs:23:18\n+   |\n+LL | #[target_feature(disable = \"baz\")]\n+   |                  ^^^^^^^^^^^^^^^ help: must be of the form: `enable = \"..\"`\n+\n+error: `#[target_feature(..)]` can only be applied to `unsafe` functions\n+  --> $DIR/invalid-attribute.rs:27:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can only be applied to `unsafe` functions\n+...\n+LL | fn bar() {}\n+   | ----------- not an `unsafe` function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:33:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | mod another {}\n+   | -------------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:38:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | const FOO: usize = 7;\n+   | --------------------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:43:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | struct Foo;\n+   | ----------- not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:48:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | enum Bar { }\n+   | ------------ not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:53:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | union Qux { f1: u16, f2: u16 }\n+   | ------------------------------ not a function\n+\n+error: attribute should be applied to a function\n+  --> $DIR/invalid-attribute.rs:58:1\n+   |\n+LL | #[target_feature(enable = \"sse2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL | trait Baz { }\n+   | ------------- not a function\n+\n+error: cannot use `#[inline(always)]` with `#[target_feature]`\n+  --> $DIR/invalid-attribute.rs:63:1\n+   |\n+LL | #[inline(always)]\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "80ef8dd662637637e8eaf12329e7bfde19fe7c47", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f3c8eba643a815d720e7f20699b3dca144c845c4/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=f3c8eba643a815d720e7f20699b3dca144c845c4", "patch": "@@ -6,7 +6,7 @@ edition = \"2018\"\n \n [dependencies]\n diff = \"0.1.10\"\n-env_logger = { version = \"0.6\", default-features = false }\n+env_logger = { version = \"0.7\", default-features = false }\n getopts = \"0.2\"\n log = \"0.4\"\n regex = \"1.0\""}]}