{"sha": "7f79e98c0356642db62e5113327e436c951e843d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNzllOThjMDM1NjY0MmRiNjJlNTExMzMyN2U0MzZjOTUxZTg0M2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T07:16:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T07:16:44Z"}, "message": "Auto merge of #72205 - ecstatic-morse:nrvo, r=oli-obk\n\nDumb NRVO\n\nThis is a very simple version of an NRVO pass, which scans backwards from the `return` terminator to see if there is an an assignment like `_0 = _1`. If a basic block with two or more predecessors is encountered during this scan without first seeing an assignment to the return place, we bail out. This avoids running a full \"reaching definitions\" dataflow analysis.\n\nI wanted to see how much `rustc` would benefit from even a very limited version of this optimization. We should be able to use this as a point of comparison for more advanced versions that are based on live ranges.\n\nr? @ghost", "tree": {"sha": "b140158d00b7dfe9c34315a771816496adab9280", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b140158d00b7dfe9c34315a771816496adab9280"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f79e98c0356642db62e5113327e436c951e843d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f79e98c0356642db62e5113327e436c951e843d", "html_url": "https://github.com/rust-lang/rust/commit/7f79e98c0356642db62e5113327e436c951e843d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f79e98c0356642db62e5113327e436c951e843d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "963bf528292d8f97104515e32908e30c2467b6a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/963bf528292d8f97104515e32908e30c2467b6a8", "html_url": "https://github.com/rust-lang/rust/commit/963bf528292d8f97104515e32908e30c2467b6a8"}, {"sha": "f50986205756075fb05a9371b94facd58cc048a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50986205756075fb05a9371b94facd58cc048a6", "html_url": "https://github.com/rust-lang/rust/commit/f50986205756075fb05a9371b94facd58cc048a6"}], "stats": {"total": 398, "additions": 350, "deletions": 48}, "files": [{"sha": "d166a27b5a982784e8f4c2083725e787b0916ee4", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -115,7 +115,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n \n         // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n-        if local == mir::RETURN_PLACE {\n+        if local == mir::RETURN_PLACE && !self.mir.local_decls[mir::RETURN_PLACE].is_user_variable()\n+        {\n             return;\n         }\n "}, {"sha": "0551ed5a15ddb2a103e8120c003cbb598c070649", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -28,6 +28,7 @@ pub mod generator;\n pub mod inline;\n pub mod instcombine;\n pub mod no_landing_pads;\n+pub mod nrvo;\n pub mod promote_consts;\n pub mod qualify_min_const_fn;\n pub mod remove_noop_landing_pads;\n@@ -324,6 +325,7 @@ fn run_optimization_passes<'tcx>(\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"after-remove-noop-landing-pads\"),\n         &simplify::SimplifyCfg::new(\"final\"),\n+        &nrvo::RenameReturnPlace,\n         &simplify::SimplifyLocals,\n     ];\n "}, {"sha": "941ffa94aa85722f4879d36e7513da53b963ef91", "filename": "src/librustc_mir/transform/nrvo.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnrvo.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -0,0 +1,238 @@\n+use rustc_hir::Mutability;\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::{self, BasicBlock, Local, Location};\n+use rustc_middle::ty::TyCtxt;\n+\n+use crate::transform::{MirPass, MirSource};\n+\n+/// This pass looks for MIR that always copies the same local into the return place and eliminates\n+/// the copy by renaming all uses of that local to `_0`.\n+///\n+/// This allows LLVM to perform an optimization similar to the named return value optimization\n+/// (NRVO) that is guaranteed in C++. This avoids a stack allocation and `memcpy` for the\n+/// relatively common pattern of allocating a buffer on the stack, mutating it, and returning it by\n+/// value like so:\n+///\n+/// ```rust\n+/// fn foo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n+///     let mut buf = [0; 1024];\n+///     init(&mut buf);\n+///     buf\n+/// }\n+/// ```\n+///\n+/// For now, this pass is very simple and only capable of eliminating a single copy. A more general\n+/// version of copy propagation, such as the one based on non-overlapping live ranges in [#47954] and\n+/// [#71003], could yield even more benefits.\n+///\n+/// [#47954]: https://github.com/rust-lang/rust/pull/47954\n+/// [#71003]: https://github.com/rust-lang/rust/pull/71003\n+pub struct RenameReturnPlace;\n+\n+impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut mir::Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n+            return;\n+        }\n+\n+        let returned_local = match local_eligible_for_nrvo(body) {\n+            Some(l) => l,\n+            None => {\n+                debug!(\"`{:?}` was ineligible for NRVO\", src.def_id());\n+                return;\n+            }\n+        };\n+\n+        // Sometimes, the return place is assigned a local of a different but coercable type, for\n+        // example `&T` instead of `&mut T`. Overwriting the `LocalInfo` for the return place would\n+        // result in it having an incorrect type. Although this doesn't seem to cause a problem in\n+        // codegen, bail out anyways since it happens so rarely.\n+        let ret_ty = body.local_decls[mir::RETURN_PLACE].ty;\n+        let assigned_ty = body.local_decls[returned_local].ty;\n+        if ret_ty != assigned_ty {\n+            debug!(\"`{:?}` was eligible for NRVO but for type mismatch\", src.def_id());\n+            debug!(\"typeof(_0) != typeof({:?}); {:?} != {:?}\", returned_local, ret_ty, assigned_ty);\n+            return;\n+        }\n+\n+        debug!(\n+            \"`{:?}` was eligible for NRVO, making {:?} the return place\",\n+            src.def_id(),\n+            returned_local\n+        );\n+\n+        RenameToReturnPlace { tcx, to_rename: returned_local }.visit_body(body);\n+\n+        // Clean up the `NOP`s we inserted for statements made useless by our renaming.\n+        for block_data in body.basic_blocks_mut() {\n+            block_data.statements.retain(|stmt| stmt.kind != mir::StatementKind::Nop);\n+        }\n+\n+        // Overwrite the debuginfo of `_0` with that of the renamed local.\n+        let (renamed_decl, ret_decl) =\n+            body.local_decls.pick2_mut(returned_local, mir::RETURN_PLACE);\n+        ret_decl.clone_from(renamed_decl);\n+\n+        // The return place is always mutable.\n+        ret_decl.mutability = Mutability::Mut;\n+    }\n+}\n+\n+/// MIR that is eligible for the NRVO must fulfill two conditions:\n+///   1. The return place must not be read prior to the `Return` terminator.\n+///   2. A simple assignment of a whole local to the return place (e.g., `_0 = _1`) must be the\n+///      only definition of the return place reaching the `Return` terminator.\n+///\n+/// If the MIR fulfills both these conditions, this function returns the `Local` that is assigned\n+/// to the return place along all possible paths through the control-flow graph.\n+fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n+    if IsReturnPlaceRead::run(body) {\n+        return None;\n+    }\n+\n+    let mut copied_to_return_place = None;\n+    for block in body.basic_blocks().indices() {\n+        // Look for blocks with a `Return` terminator.\n+        if !matches!(body[block].terminator().kind, mir::TerminatorKind::Return) {\n+            continue;\n+        }\n+\n+        // Look for an assignment of a single local to the return place prior to the `Return`.\n+        let returned_local = find_local_assigned_to_return_place(block, body)?;\n+        match body.local_kind(returned_local) {\n+            // FIXME: Can we do this for arguments as well?\n+            mir::LocalKind::Arg => return None,\n+\n+            mir::LocalKind::ReturnPointer => bug!(\"Return place was assigned to itself?\"),\n+            mir::LocalKind::Var | mir::LocalKind::Temp => {}\n+        }\n+\n+        // If multiple different locals are copied to the return place. We can't pick a\n+        // single one to rename.\n+        if copied_to_return_place.map_or(false, |old| old != returned_local) {\n+            return None;\n+        }\n+\n+        copied_to_return_place = Some(returned_local);\n+    }\n+\n+    return copied_to_return_place;\n+}\n+\n+fn find_local_assigned_to_return_place(\n+    start: BasicBlock,\n+    body: &mut mir::Body<'_>,\n+) -> Option<Local> {\n+    let mut block = start;\n+    let mut seen = HybridBitSet::new_empty(body.basic_blocks().len());\n+\n+    // Iterate as long as `block` has exactly one predecessor that we have not yet visited.\n+    while seen.insert(block) {\n+        trace!(\"Looking for assignments to `_0` in {:?}\", block);\n+\n+        let local = body[block].statements.iter().rev().find_map(as_local_assigned_to_return_place);\n+        if local.is_some() {\n+            return local;\n+        }\n+\n+        match body.predecessors()[block].as_slice() {\n+            &[pred] => block = pred,\n+            _ => return None,\n+        }\n+    }\n+\n+    return None;\n+}\n+\n+// If this statement is an assignment of an unprojected local to the return place,\n+// return that local.\n+fn as_local_assigned_to_return_place(stmt: &mir::Statement<'_>) -> Option<Local> {\n+    if let mir::StatementKind::Assign(box (lhs, rhs)) = &stmt.kind {\n+        if lhs.as_local() == Some(mir::RETURN_PLACE) {\n+            if let mir::Rvalue::Use(mir::Operand::Copy(rhs) | mir::Operand::Move(rhs)) = rhs {\n+                return rhs.as_local();\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+struct RenameToReturnPlace<'tcx> {\n+    to_rename: Local,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+/// Replaces all uses of `self.to_rename` with `_0`.\n+impl MutVisitor<'tcx> for RenameToReturnPlace<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_statement(&mut self, stmt: &mut mir::Statement<'tcx>, loc: Location) {\n+        // Remove assignments of the local being replaced to the return place, since it is now the\n+        // return place:\n+        //     _0 = _1\n+        if as_local_assigned_to_return_place(stmt) == Some(self.to_rename) {\n+            stmt.kind = mir::StatementKind::Nop;\n+            return;\n+        }\n+\n+        // Remove storage annotations for the local being replaced:\n+        //     StorageLive(_1)\n+        if let mir::StatementKind::StorageLive(local) | mir::StatementKind::StorageDead(local) =\n+            stmt.kind\n+        {\n+            if local == self.to_rename {\n+                stmt.kind = mir::StatementKind::Nop;\n+                return;\n+            }\n+        }\n+\n+        self.super_statement(stmt, loc)\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mut mir::Terminator<'tcx>, loc: Location) {\n+        // Ignore the implicit \"use\" of the return place in a `Return` statement.\n+        if let mir::TerminatorKind::Return = terminator.kind {\n+            return;\n+        }\n+\n+        self.super_terminator(terminator, loc);\n+    }\n+\n+    fn visit_local(&mut self, l: &mut Local, _: PlaceContext, _: Location) {\n+        assert_ne!(*l, mir::RETURN_PLACE);\n+        if *l == self.to_rename {\n+            *l = mir::RETURN_PLACE;\n+        }\n+    }\n+}\n+\n+struct IsReturnPlaceRead(bool);\n+\n+impl IsReturnPlaceRead {\n+    fn run(body: &mir::Body<'_>) -> bool {\n+        let mut vis = IsReturnPlaceRead(false);\n+        vis.visit_body(body);\n+        vis.0\n+    }\n+}\n+\n+impl Visitor<'tcx> for IsReturnPlaceRead {\n+    fn visit_local(&mut self, &l: &Local, ctxt: PlaceContext, _: Location) {\n+        if l == mir::RETURN_PLACE && ctxt.is_use() && !ctxt.is_place_assignment() {\n+            self.0 = true;\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, loc: Location) {\n+        // Ignore the implicit \"use\" of the return place in a `Return` statement.\n+        if let mir::TerminatorKind::Return = terminator.kind {\n+            return;\n+        }\n+\n+        self.super_terminator(terminator, loc);\n+    }\n+}"}, {"sha": "95ca7cfe7508073ac4112bafff6f9163c30e1e75", "filename": "src/test/codegen/align-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Falign-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Falign-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-enum.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C no-prepopulate-passes\n+// compile-flags: -C no-prepopulate-passes -Z mir-opt-level=0\n // ignore-tidy-linelength\n \n #![crate_type = \"lib\"]"}, {"sha": "cda7235a3d81df0e56be4a628ddeac14dcc2138d", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -C no-prepopulate-passes\n+// compile-flags: -C no-prepopulate-passes -Z mir-opt-level=0\n // ignore-tidy-linelength\n \n #![crate_type = \"lib\"]"}, {"sha": "fddb0d1fb3c8ce5733f7a792387af7bb26d06a61", "filename": "src/test/codegen/nrvo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fcodegen%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnrvo.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// Ensure that we do not call `memcpy` for the following function.\n+// `memset` and `init` should be called directly on the return pointer.\n+#[no_mangle]\n+pub fn nrvo(init: fn(&mut [u8; 4096])) -> [u8; 4096] {\n+    // CHECK-LABEL: nrvo\n+    // CHECK: @llvm.memset\n+    // CHECK-NOT: @llvm.memcpy\n+    // CHECK: ret\n+    // CHECK-EMPTY\n+    let mut buf = [0; 4096];\n+    init(&mut buf);\n+    buf\n+}"}, {"sha": "f5e34c3911904fb76c4bc8f31cb372917c67f449", "filename": "src/test/debuginfo/generic-function.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-function.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-linelength\n-\n // min-lldb-version: 310\n \n // compile-flags:-g\n@@ -12,31 +10,21 @@\n // gdb-check:$1 = 1\n // gdb-command:print *t1\n // gdb-check:$2 = 2.5\n-// gdb-command:print ret\n-// gdbg-check:$3 = {__0 = {__0 = 1, __1 = 2.5}, __1 = {__0 = 2.5, __1 = 1}}\n-// gdbr-check:$3 = ((1, 2.5), (2.5, 1))\n // gdb-command:continue\n \n // gdb-command:print *t0\n-// gdb-check:$4 = 3.5\n+// gdb-check:$3 = 3.5\n // gdb-command:print *t1\n-// gdb-check:$5 = 4\n-// gdb-command:print ret\n-// gdbg-check:$6 = {__0 = {__0 = 3.5, __1 = 4}, __1 = {__0 = 4, __1 = 3.5}}\n-// gdbr-check:$6 = ((3.5, 4), (4, 3.5))\n+// gdb-check:$4 = 4\n // gdb-command:continue\n \n // gdb-command:print *t0\n-// gdb-check:$7 = 5\n+// gdb-check:$5 = 5\n // gdb-command:print *t1\n-// gdbg-check:$8 = {a = 6, b = 7.5}\n-// gdbr-check:$8 = generic_function::Struct {a: 6, b: 7.5}\n-// gdb-command:print ret\n-// gdbg-check:$9 = {__0 = {__0 = 5, __1 = {a = 6, b = 7.5}}, __1 = {__0 = {a = 6, b = 7.5}, __1 = 5}}\n-// gdbr-check:$9 = ((5, generic_function::Struct {a: 6, b: 7.5}), (generic_function::Struct {a: 6, b: 7.5}, 5))\n+// gdbg-check:$6 = {a = 6, b = 7.5}\n+// gdbr-check:$6 = generic_function::Struct {a: 6, b: 7.5}\n // gdb-command:continue\n \n-\n // === LLDB TESTS ==================================================================================\n \n // lldb-command:run\n@@ -47,31 +35,22 @@\n // lldb-command:print *t1\n // lldbg-check:[...]$1 = 2.5\n // lldbr-check:(f64) *t1 = 2.5\n-// lldb-command:print ret\n-// lldbg-check:[...]$2 = ((1, 2.5), (2.5, 1))\n-// lldbr-check:(((i32, f64), (f64, i32))) ret = { = { = 1 = 2.5 } = { = 2.5 = 1 } }\n // lldb-command:continue\n \n // lldb-command:print *t0\n-// lldbg-check:[...]$3 = 3.5\n+// lldbg-check:[...]$2 = 3.5\n // lldbr-check:(f64) *t0 = 3.5\n // lldb-command:print *t1\n-// lldbg-check:[...]$4 = 4\n+// lldbg-check:[...]$3 = 4\n // lldbr-check:(u16) *t1 = 4\n-// lldb-command:print ret\n-// lldbg-check:[...]$5 = ((3.5, 4), (4, 3.5))\n-// lldbr-check:(((f64, u16), (u16, f64))) ret = { = { = 3.5 = 4 } = { = 4 = 3.5 } }\n // lldb-command:continue\n \n // lldb-command:print *t0\n-// lldbg-check:[...]$6 = 5\n+// lldbg-check:[...]$4 = 5\n // lldbr-check:(i32) *t0 = 5\n // lldb-command:print *t1\n-// lldbg-check:[...]$7 = Struct { a: 6, b: 7.5 }\n+// lldbg-check:[...]$5 = Struct { a: 6, b: 7.5 }\n // lldbr-check:(generic_function::Struct) *t1 = Struct { a: 6, b: 7.5 }\n-// lldb-command:print ret\n-// lldbg-check:[...]$8 = ((5, Struct { a: 6, b: 7.5 }), (Struct { a: 6, b: 7.5 }, 5))\n-// lldbr-check:(((i32, generic_function::Struct), (generic_function::Struct, i32))) ret = { = { = 5 = Struct { a: 6, b: 7.5 } } = { = Struct { a: 6, b: 7.5 } = 5 } }\n // lldb-command:continue\n \n #![feature(omit_gdb_pretty_printer_section)]"}, {"sha": "2eebf3f0eceb9c9af24ff324230e6e85428e869d", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.a.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.a.Inline.after.mir?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -8,18 +8,14 @@ fn a(_1: &mut [T]) -> &mut [T] {\n     let mut _4: &mut [T];                // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n     scope 1 {\n         debug self => _4;                // in scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n-        let mut _5: &mut [T];            // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n     }\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n         StorageLive(_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n         StorageLive(_4);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n         _4 = &mut (*_1);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:6\n-        StorageLive(_5);                 // scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n-        _5 = _4;                         // scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n-        _3 = _5;                         // scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n-        StorageDead(_5);                 // scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+        _3 = _4;                         // scope 1 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n         _2 = &mut (*_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15\n         StorageDead(_4);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:14: 3:15\n         _0 = &mut (*_2);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:3:5: 3:15"}, {"sha": "f9e1699c55dfadd601d3986d65991ad2b5de3337", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.b.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.b.Inline.after.mir?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -9,7 +9,6 @@ fn b(_1: &mut std::boxed::Box<T>) -> &mut T {\n     scope 1 {\n         debug self => _4;                // in scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n         let mut _5: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n-        let mut _6: &mut T;              // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n     }\n \n     bb0: {\n@@ -18,11 +17,8 @@ fn b(_1: &mut std::boxed::Box<T>) -> &mut T {\n         StorageLive(_4);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n         _4 = &mut (*_1);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:6\n         StorageLive(_5);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        StorageLive(_6);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        _6 = &mut (*(*_4));              // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        _5 = _6;                         // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _5 = &mut (*(*_4));              // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n         _3 = _5;                         // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        StorageDead(_6);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n         StorageDead(_5);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n         _2 = &mut (*_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:5: 8:15\n         StorageDead(_4);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:8:14: 8:15"}, {"sha": "08bd4784bde18236a0f3cdcaebdddb424ab850d1", "filename": "src/test/mir-opt/inline/issue-58867-inline-as-ref-as-mut/rustc.d.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Fissue-58867-inline-as-ref-as-mut%2Frustc.d.Inline.after.mir?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -7,17 +7,13 @@ fn d(_1: &std::boxed::Box<T>) -> &T {\n     let mut _3: &std::boxed::Box<T>;     // in scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n     scope 1 {\n         debug self => _3;                // in scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        let _4: &T;                      // in scope 1 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n     }\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         StorageLive(_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n         _3 = &(*_1);                     // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:6\n-        StorageLive(_4);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        _4 = &(*(*_3));                  // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        _2 = _4;                         // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n-        StorageDead(_4);                 // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n+        _2 = &(*(*_3));                  // scope 1 at $SRC_DIR/liballoc/boxed.rs:LL:COL\n         _0 = &(*_2);                     // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:5: 18:15\n         StorageDead(_3);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:18:14: 18:15\n         StorageDead(_2);                 // scope 0 at $DIR/issue-58867-inline-as-ref-as-mut.rs:19:1: 19:2"}, {"sha": "bf3a0efeada0ba0e8ee1d904bb076d2ec6a70b6b", "filename": "src/test/mir-opt/nrvo-simple.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -0,0 +1,10 @@\n+// EMIT_MIR rustc.nrvo.RenameReturnPlace.diff\n+fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n+    let mut buf = [0; 1024];\n+    init(&mut buf);\n+    buf\n+}\n+\n+fn main() {\n+    let _ = nrvo(|buf| { buf[4] = 4; });\n+}"}, {"sha": "79d92897cb57229c027f198af2552d1cf341d7fb", "filename": "src/test/mir-opt/nrvo-simple/rustc.nrvo.RenameReturnPlace.diff", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Fnrvo-simple%2Frustc.nrvo.RenameReturnPlace.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fmir-opt%2Fnrvo-simple%2Frustc.nrvo.RenameReturnPlace.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnrvo-simple%2Frustc.nrvo.RenameReturnPlace.diff?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -0,0 +1,41 @@\n+- // MIR for `nrvo` before RenameReturnPlace\n++ // MIR for `nrvo` after RenameReturnPlace\n+  \n+  fn nrvo(_1: for<'r> fn(&'r mut [u8; 1024])) -> [u8; 1024] {\n+      debug init => _1;                    // in scope 0 at $DIR/nrvo-simple.rs:2:9: 2:13\n+-     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:2:39: 2:49\n++     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n+      let mut _2: [u8; 1024];              // in scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n+      let _3: ();                          // in scope 0 at $DIR/nrvo-simple.rs:4:5: 4:19\n+      let mut _4: for<'r> fn(&'r mut [u8; 1024]); // in scope 0 at $DIR/nrvo-simple.rs:4:5: 4:9\n+      let mut _5: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:4:10: 4:18\n+      let mut _6: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:4:10: 4:18\n+      scope 1 {\n+-         debug buf => _2;                 // in scope 1 at $DIR/nrvo-simple.rs:3:9: 3:16\n++         debug buf => _0;                 // in scope 1 at $DIR/nrvo-simple.rs:3:9: 3:16\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_2);                 // scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n+-         _2 = [const 0u8; 1024];          // scope 0 at $DIR/nrvo-simple.rs:3:19: 3:28\n++         _0 = [const 0u8; 1024];          // scope 0 at $DIR/nrvo-simple.rs:3:19: 3:28\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/nrvo-simple.rs:3:20: 3:21\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          StorageLive(_3);                 // scope 1 at $DIR/nrvo-simple.rs:4:5: 4:19\n+-         _6 = &mut _2;                    // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n++         _6 = &mut _0;                    // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n+          _3 = move _1(move _6) -> bb1;    // scope 1 at $DIR/nrvo-simple.rs:4:5: 4:19\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/nrvo-simple.rs:4:19: 4:20\n+-         _0 = _2;                         // scope 1 at $DIR/nrvo-simple.rs:5:5: 5:8\n+-         StorageDead(_2);                 // scope 0 at $DIR/nrvo-simple.rs:6:1: 6:2\n+          return;                          // scope 0 at $DIR/nrvo-simple.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "1d2c6acc06cd5f1d5c94ad4abb8139827acad341", "filename": "src/test/ui/consts/const-eval/nrvo.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f79e98c0356642db62e5113327e436c951e843d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fnrvo.rs?ref=7f79e98c0356642db62e5113327e436c951e843d", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+\n+// When the NRVO is applied, the return place (`_0`) gets treated like a normal local. For example,\n+// its address may be taken and it may be written to indirectly. Ensure that MIRI can handle this.\n+\n+#![feature(const_mut_refs)]\n+\n+#[inline(never)] // Try to ensure that MIR optimizations don't optimize this away.\n+const fn init(buf: &mut [u8; 1024]) {\n+    buf[33] = 3;\n+    buf[444] = 4;\n+}\n+\n+const fn nrvo() -> [u8; 1024] {\n+    let mut buf = [0; 1024];\n+    init(&mut buf);\n+    buf\n+}\n+\n+const BUF: [u8; 1024] = nrvo();\n+\n+fn main() {\n+    assert_eq!(BUF[33], 3);\n+    assert_eq!(BUF[19], 0);\n+    assert_eq!(BUF[444], 4);\n+}"}]}