{"sha": "630e17d3e41dbe338b209effb6091471314798c1", "node_id": "C_kwDOAAsO6NoAKDYzMGUxN2QzZTQxZGJlMzM4YjIwOWVmZmI2MDkxNDcxMzE0Nzk4YzE", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-10-25T19:54:39Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:26Z"}, "message": "Limit number of tracked places, and some other perf improvements", "tree": {"sha": "1300696c08fa1eedd91facd31d9f5df738b55491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1300696c08fa1eedd91facd31d9f5df738b55491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/630e17d3e41dbe338b209effb6091471314798c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/630e17d3e41dbe338b209effb6091471314798c1", "html_url": "https://github.com/rust-lang/rust/commit/630e17d3e41dbe338b209effb6091471314798c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/630e17d3e41dbe338b209effb6091471314798c1/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da4a40f81650222d86fa070aad87b5d20f8596e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/da4a40f81650222d86fa070aad87b5d20f8596e9", "html_url": "https://github.com/rust-lang/rust/commit/da4a40f81650222d86fa070aad87b5d20f8596e9"}], "stats": {"total": 80, "additions": 66, "deletions": 14}, "files": [{"sha": "8e0fc77ec99907a5eaebb0415ae580fca1e2d133", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/630e17d3e41dbe338b209effb6091471314798c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630e17d3e41dbe338b209effb6091471314798c1/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=630e17d3e41dbe338b209effb6091471314798c1", "patch": "@@ -47,7 +47,7 @@\n \n use std::fmt::{Debug, Formatter};\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -405,12 +405,31 @@ rustc_index::newtype_index!(\n );\n \n /// See [`State`].\n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n enum StateData<V> {\n     Reachable(IndexVec<ValueIndex, V>),\n     Unreachable,\n }\n \n+impl<V: Clone> Clone for StateData<V> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            Self::Reachable(x) => Self::Reachable(x.clone()),\n+            Self::Unreachable => Self::Unreachable,\n+        }\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        match (&mut *self, source) {\n+            (Self::Reachable(x), Self::Reachable(y)) => {\n+                // We go through `raw` here, because `IndexVec` currently has a naive `clone_from`.\n+                x.raw.clone_from(&y.raw);\n+            }\n+            _ => *self = source.clone(),\n+        }\n+    }\n+}\n+\n /// The dataflow state for an instance of [`ValueAnalysis`].\n ///\n /// Every instance specifies a lattice that represents the possible values of a single tracked\n@@ -421,9 +440,19 @@ enum StateData<V> {\n /// reachable state). All operations on unreachable states are ignored.\n ///\n /// Flooding means assigning a value (by default `\u22a4`) to all tracked projections of a given place.\n-#[derive(PartialEq, Eq, Clone, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n pub struct State<V>(StateData<V>);\n \n+impl<V: Clone> Clone for State<V> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+\n+    fn clone_from(&mut self, source: &Self) {\n+        self.0.clone_from(&source.0);\n+    }\n+}\n+\n impl<V: Clone + HasTop + HasBottom> State<V> {\n     pub fn is_reachable(&self) -> bool {\n         matches!(&self.0, StateData::Reachable(_))\n@@ -590,6 +619,7 @@ impl Map {\n     ///\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n     /// chosen is an implementation detail and may not be relied upon.\n+    #[instrument(skip_all, level = \"debug\")]\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -604,11 +634,12 @@ impl Map {\n         if tcx.sess.opts.unstable_opts.unsound_mir_opts {\n             // We might want to add additional limitations. If a struct has 10 boxed fields of\n             // itself, there will currently be `10.pow(max_derefs)` tracked places.\n-            map.register_with_filter(tcx, body, 2, filter, &[]);\n+            map.register_with_filter(tcx, body, 2, filter, &FxHashSet::default());\n         } else {\n             map.register_with_filter(tcx, body, 0, filter, &escaped_places(body));\n         }\n \n+        debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n \n@@ -619,7 +650,7 @@ impl Map {\n         body: &Body<'tcx>,\n         max_derefs: u32,\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n-        exclude: &[Place<'tcx>],\n+        exclude: &FxHashSet<Place<'tcx>>,\n     ) {\n         // This is used to tell whether a type is `!Freeze`.\n         let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n@@ -648,10 +679,10 @@ impl Map {\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n         param_env: ty::ParamEnv<'tcx>,\n-        exclude: &[Place<'tcx>],\n+        exclude: &FxHashSet<Place<'tcx>>,\n     ) {\n-        // This currently does a linear scan, could be improved.\n         if exclude.contains(&Place { local, projection: tcx.intern_place_elems(projection) }) {\n+            // This will also exclude all projections of the excluded place.\n             return;\n         }\n \n@@ -764,6 +795,10 @@ impl Map {\n         Ok(())\n     }\n \n+    pub fn tracked_places(&self) -> usize {\n+        self.value_count\n+    }\n+\n     pub fn apply(&self, place: PlaceIndex, elem: TrackElem) -> Option<PlaceIndex> {\n         self.projections.get(&(place, elem)).copied()\n     }\n@@ -929,20 +964,20 @@ fn iter_fields<'tcx>(\n /// Returns all places, that have their reference or address taken.\n ///\n /// This includes shared references.\n-fn escaped_places<'tcx>(body: &Body<'tcx>) -> Vec<Place<'tcx>> {\n+fn escaped_places<'tcx>(body: &Body<'tcx>) -> FxHashSet<Place<'tcx>> {\n     struct Collector<'tcx> {\n-        result: Vec<Place<'tcx>>,\n+        result: FxHashSet<Place<'tcx>>,\n     }\n \n     impl<'tcx> Visitor<'tcx> for Collector<'tcx> {\n         fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n             if context.is_borrow() || context.is_address_of() {\n-                self.result.push(*place);\n+                self.result.insert(*place);\n             }\n         }\n     }\n \n-    let mut collector = Collector { result: Vec::new() };\n+    let mut collector = Collector { result: FxHashSet::default() };\n     collector.visit_body(body);\n     collector.result\n }"}, {"sha": "1eeebfabba7c77724244249acee4beca054845cd", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/630e17d3e41dbe338b209effb6091471314798c1/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630e17d3e41dbe338b209effb6091471314798c1/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=630e17d3e41dbe338b209effb6091471314798c1", "patch": "@@ -15,25 +15,42 @@ use rustc_span::DUMMY_SP;\n \n use crate::MirPass;\n \n+const TRACKING_LIMIT: usize = 1000;\n+\n pub struct DataflowConstProp;\n \n impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n     fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n         sess.mir_opt_level() >= 1\n     }\n \n+    #[instrument(skip_all level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // Decide which places to track during the analysis.\n         let map = Map::from_filter(tcx, body, Ty::is_scalar);\n \n+        // We want to have a somewhat linear runtime w.r.t. the number of statements/terminators.\n+        // Let's call this number `n`. Dataflow analysis has `O(h*n)` transfer function\n+        // applications, where `h` is the height of the lattice. Because the height of our lattice\n+        // is linear w.r.t. the number of tracked places, this is `O(tracked_places * n)`. However,\n+        // because every transfer function application could traverse the whole map, this becomes\n+        // `O(num_nodes * tracked_places * n)` in terms of time complexity. Since the number of\n+        // map nodes is strongly correlated to the number of tracked places, this becomes more or\n+        // less `O(n)` if we place a constant limit on the number of tracked places.\n+        if map.tracked_places() > TRACKING_LIMIT {\n+            debug!(\"aborted dataflow const prop due to too many tracked places\");\n+            return;\n+        }\n+\n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);\n-        let results = analysis.wrap().into_engine(tcx, body).iterate_to_fixpoint();\n+        let results = debug_span!(\"analyze\")\n+            .in_scope(|| analysis.wrap().into_engine(tcx, body).iterate_to_fixpoint());\n \n         // Collect results and patch the body afterwards.\n         let mut visitor = CollectAndPatch::new(tcx, &results.analysis.0.map);\n-        results.visit_reachable_with(body, &mut visitor);\n-        visitor.visit_body(body);\n+        debug_span!(\"collect\").in_scope(|| results.visit_reachable_with(body, &mut visitor));\n+        debug_span!(\"patch\").in_scope(|| visitor.visit_body(body));\n     }\n }\n "}]}