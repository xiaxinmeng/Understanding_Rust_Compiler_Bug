{"sha": "89940e541f921b5b22c12a24f6c84e32c691a9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OTQwZTU0MWY5MjFiNWIyMmMxMmEyNGY2Yzg0ZTMyYzY5MWE5YTQ=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seiichi.uchida@dena.com", "date": "2019-07-15T13:41:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-15T13:41:56Z"}, "message": "Fix bugs related to file-lines (#3684)", "tree": {"sha": "1c84e83836e4dabc5ead6cec4ed1460732eede7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c84e83836e4dabc5ead6cec4ed1460732eede7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89940e541f921b5b22c12a24f6c84e32c691a9a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdLIKkCRBK7hj4Ov3rIwAAdHIIADM3Edl6RWTTsB9s+s01uFXm\nEAm/rl1oMDIYjgxZGPbpJId4UNrPxb//OH4726KA24YAp9kjUHtm4iSIuUb4irta\nzRv/ERb7tkZ1axJ+VY8owKmjuIQIuLzynB5EF7jXy/W+uJBZfacj3g8DjeszMB2t\niGXkjnEtPmZ8s/0fGBTJC4ZK1xMWVoEzJuBBQU9Dk/1rEsoiuKO3W+NaLdNMUdOX\nBecszYvpR/6rWTvDEgPRlcCK0podQJ2hvPeLFkiWjr1C3D+yKJPwLQDvVf1N8s5i\nQ1Q+vgjkJ85Nd65Q0U3rS9ca8P/uIcuFwV5/UlY75xDAyYO78NBjT1uZFD9pdxg=\n=OV49\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c84e83836e4dabc5ead6cec4ed1460732eede7c\nparent 6487422b3e0b93645e004c66c32fad5a7ab58b80\nauthor Seiichi Uchida <seiichi.uchida@dena.com> 1563198116 +0900\ncommitter GitHub <noreply@github.com> 1563198116 +0900\n\nFix bugs related to file-lines (#3684)\n\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89940e541f921b5b22c12a24f6c84e32c691a9a4", "html_url": "https://github.com/rust-lang/rust/commit/89940e541f921b5b22c12a24f6c84e32c691a9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89940e541f921b5b22c12a24f6c84e32c691a9a4/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6487422b3e0b93645e004c66c32fad5a7ab58b80", "url": "https://api.github.com/repos/rust-lang/rust/commits/6487422b3e0b93645e004c66c32fad5a7ab58b80", "html_url": "https://github.com/rust-lang/rust/commit/6487422b3e0b93645e004c66c32fad5a7ab58b80"}], "stats": {"total": 310, "additions": 211, "deletions": 99}, "files": [{"sha": "70990aa798dd63f5212a777d066a0e7f5a4fc5f0", "filename": "src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -167,7 +167,7 @@ fn make_opts() -> Options {\n }\n \n fn is_nightly() -> bool {\n-    option_env!(\"CFG_RELEASE_CHANNEL\").map_or(false, |c| c == \"nightly\" || c == \"dev\")\n+    option_env!(\"CFG_RELEASE_CHANNEL\").map_or(true, |c| c == \"nightly\" || c == \"dev\")\n }\n \n // Returned i32 is an exit code"}, {"sha": "f58d3c16ac26594821b1d8b21e42a56dcfd8d398", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -9,7 +9,7 @@ use std::{cmp, fmt, iter, str};\n use serde::{ser, Deserialize, Deserializer, Serialize, Serializer};\n use serde_json as json;\n \n-use syntax::source_map::{self, SourceFile};\n+use syntax::source_map::{self, SourceFile, SourceMap, Span};\n \n /// A range of lines in a file, inclusive of both ends.\n pub struct LineRange {\n@@ -78,6 +78,17 @@ impl LineRange {\n     pub fn file_name(&self) -> FileName {\n         self.file.name.clone().into()\n     }\n+\n+    pub(crate) fn from_span(source_map: &SourceMap, span: Span) -> LineRange {\n+        let lo_char_pos = source_map.lookup_char_pos(span.lo());\n+        let hi_char_pos = source_map.lookup_char_pos(span.hi());\n+        debug_assert!(lo_char_pos.file.name == hi_char_pos.file.name);\n+        LineRange {\n+            file: lo_char_pos.file.clone(),\n+            lo: lo_char_pos.line,\n+            hi: hi_char_pos.line,\n+        }\n+    }\n }\n \n /// A range that is inclusive of both ends."}, {"sha": "8ac05457ec9b13919f251e330434c45684497a78", "filename": "src/missed_spans.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -7,7 +7,7 @@ use crate::config::file_lines::FileLines;\n use crate::config::{EmitMode, FileName};\n use crate::shape::{Indent, Shape};\n use crate::source_map::LineRangeUtils;\n-use crate::utils::{count_newlines, last_line_width, mk_sp};\n+use crate::utils::{count_lf_crlf, count_newlines, last_line_width, mk_sp};\n use crate::visitor::FmtVisitor;\n \n struct SnippetStatus {\n@@ -157,7 +157,7 @@ impl<'a> FmtVisitor<'a> {\n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n-        mut big_diff: usize,\n+        big_diff: usize,\n         old_snippet: &str,\n         span: Span,\n         process_last_snippet: F,\n@@ -176,36 +176,26 @@ impl<'a> FmtVisitor<'a> {\n             _ => Cow::from(old_snippet),\n         };\n \n-        // if the snippet starts with a new line, then information about the lines needs to be\n-        // adjusted since it is off by 1.\n-        let snippet = if snippet.starts_with('\\n') {\n-            // this takes into account the blank_lines_* options\n-            self.push_vertical_spaces(1);\n-            // include the newline character into the big_diff\n-            big_diff += 1;\n-            status.cur_line += 1;\n-            &snippet[1..]\n-        } else {\n-            snippet\n-        };\n-\n-        let slice_within_file_lines_range = |file_lines: FileLines, cur_line, s| -> (usize, bool) {\n-            let newline_count = count_newlines(s);\n-            let within_file_lines_range = file_lines.contains_range(\n-                file_name,\n-                cur_line,\n-                // if a newline character is at the end of the slice, then the number of newlines\n-                // needs to be decreased by 1 so that the range checked against the file_lines is\n-                // the visual range one would expect.\n-                cur_line + newline_count - if s.ends_with('\\n') { 1 } else { 0 },\n-            );\n-            (newline_count, within_file_lines_range)\n-        };\n+        let slice_within_file_lines_range =\n+            |file_lines: FileLines, cur_line, s| -> (usize, usize, bool) {\n+                let (lf_count, crlf_count) = count_lf_crlf(s);\n+                let newline_count = lf_count + crlf_count;\n+                let within_file_lines_range = file_lines.contains_range(\n+                    file_name,\n+                    cur_line,\n+                    // if a newline character is at the end of the slice, then the number of\n+                    // newlines needs to be decreased by 1 so that the range checked against\n+                    // the file_lines is the visual range one would expect.\n+                    cur_line + newline_count - if s.ends_with('\\n') { 1 } else { 0 },\n+                );\n+                (lf_count, crlf_count, within_file_lines_range)\n+            };\n         for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n             debug!(\"{:?}: {:?}\", kind, subslice);\n \n-            let (newline_count, within_file_lines_range) =\n+            let (lf_count, crlf_count, within_file_lines_range) =\n                 slice_within_file_lines_range(self.config.file_lines(), status.cur_line, subslice);\n+            let newline_count = lf_count + crlf_count;\n             if CodeCharKind::Comment == kind && within_file_lines_range {\n                 // 1: comment.\n                 self.process_comment(\n@@ -219,15 +209,15 @@ impl<'a> FmtVisitor<'a> {\n                 // 2: blank lines.\n                 self.push_vertical_spaces(newline_count);\n                 status.cur_line += newline_count;\n-                status.line_start = offset + newline_count;\n+                status.line_start = offset + lf_count + crlf_count * 2;\n             } else {\n                 // 3: code which we failed to format or which is not within file-lines range.\n                 self.process_missing_code(&mut status, snippet, subslice, offset, file_name);\n             }\n         }\n \n         let last_snippet = &snippet[status.line_start..];\n-        let (_, within_file_lines_range) =\n+        let (_, _, within_file_lines_range) =\n             slice_within_file_lines_range(self.config.file_lines(), status.cur_line, last_snippet);\n         if within_file_lines_range {\n             process_last_snippet(self, last_snippet, snippet);"}, {"sha": "b1ab83e7aba102ebc5f542ab8d697f9d9e34987c", "filename": "src/source_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -5,6 +5,7 @@ use syntax::source_map::{BytePos, SourceMap, Span};\n \n use crate::comment::FindUncommented;\n use crate::config::file_lines::LineRange;\n+use crate::utils::starts_with_newline;\n use crate::visitor::SnippetProvider;\n \n pub(crate) trait SpanUtils {\n@@ -95,7 +96,7 @@ impl LineRangeUtils for SourceMap {\n \n         // in case the span starts with a newline, the line range is off by 1 without the\n         // adjustment below\n-        let offset = 1 + if snippet.starts_with('\\n') { 1 } else { 0 };\n+        let offset = 1 + if starts_with_newline(&snippet) { 1 } else { 0 };\n         // Line numbers start at 1\n         LineRange {\n             file: lo.sf.clone(),"}, {"sha": "26ee7317df5dcf4d405163b82d936bc5abd477df", "filename": "src/utils.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -306,7 +306,22 @@ pub(crate) fn stmt_expr(stmt: &ast::Stmt) -> Option<&ast::Expr> {\n     }\n }\n \n-#[inline]\n+/// Returns the number of LF and CRLF respectively.\n+pub(crate) fn count_lf_crlf(input: &str) -> (usize, usize) {\n+    let mut lf = 0;\n+    let mut crlf = 0;\n+    let mut is_crlf = false;\n+    for c in input.as_bytes() {\n+        match c {\n+            b'\\r' => is_crlf = true,\n+            b'\\n' if is_crlf => crlf += 1,\n+            b'\\n' => lf += 1,\n+            _ => is_crlf = false,\n+        }\n+    }\n+    (lf, crlf)\n+}\n+\n pub(crate) fn count_newlines(input: &str) -> usize {\n     // Using bytes to omit UTF-8 decoding\n     bytecount::count(input.as_bytes(), b'\\n')"}, {"sha": "d145693b9aa5eab6013daaaa53368b25c7f09dc2", "filename": "src/visitor.rs", "status": "modified", "additions": 79, "deletions": 61, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -6,7 +6,7 @@ use syntax::{ast, visit};\n \n use crate::attr::*;\n use crate::comment::{CodeCharKind, CommentCodeSlices};\n-use crate::config::file_lines::FileName;\n+use crate::config::file_lines::LineRange;\n use crate::config::{BraceStyle, Config};\n use crate::items::{\n     format_impl, format_trait, format_trait_alias, is_mod_decl, is_use_item,\n@@ -89,6 +89,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         Shape::indented(self.block_indent, self.config)\n     }\n \n+    fn next_span(&self, hi: BytePos) -> Span {\n+        mk_sp(self.last_pos, hi)\n+    }\n+\n     fn visit_stmt(&mut self, stmt: &Stmt<'_>) {\n         debug!(\n             \"visit_stmt: {:?} {:?}\",\n@@ -132,31 +136,19 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub(crate) fn visit_block(\n+    /// Remove spaces between the opening brace and the first statement or the inner attribute\n+    /// of the block.\n+    fn trim_spaces_after_opening_brace(\n         &mut self,\n         b: &ast::Block,\n         inner_attrs: Option<&[ast::Attribute]>,\n-        has_braces: bool,\n     ) {\n-        debug!(\n-            \"visit_block: {:?} {:?}\",\n-            self.source_map.lookup_char_pos(b.span.lo()),\n-            self.source_map.lookup_char_pos(b.span.hi())\n-        );\n-\n-        // Check if this block has braces.\n-        let brace_compensation = BytePos(if has_braces { 1 } else { 0 });\n-\n-        self.last_pos = self.last_pos + brace_compensation;\n-        self.block_indent = self.block_indent.block_indent(self.config);\n-        self.push_str(\"{\");\n-\n         if let Some(first_stmt) = b.stmts.first() {\n             let hi = inner_attrs\n                 .and_then(|attrs| inner_attributes(attrs).first().map(|attr| attr.span.lo()))\n                 .unwrap_or_else(|| first_stmt.span().lo());\n-\n-            let snippet = self.snippet(mk_sp(self.last_pos, hi));\n+            let missing_span = self.next_span(hi);\n+            let snippet = self.snippet(missing_span);\n             let len = CommentCodeSlices::new(snippet)\n                 .nth(0)\n                 .and_then(|(kind, _, s)| {\n@@ -170,19 +162,57 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.last_pos = self.last_pos + BytePos::from_usize(len);\n             }\n         }\n+    }\n \n-        // Format inner attributes if available.\n-        let skip_rewrite = if let Some(attrs) = inner_attrs {\n-            self.visit_attrs(attrs, ast::AttrStyle::Inner)\n-        } else {\n-            false\n-        };\n+    /// Returns the total length of the spaces which should be trimmed between the last statement\n+    /// and the closing brace of the block.\n+    fn trimmed_spaces_width_before_closing_brace(\n+        &mut self,\n+        b: &ast::Block,\n+        brace_compensation: BytePos,\n+    ) -> usize {\n+        match b.stmts.last() {\n+            None => 0,\n+            Some(..) => {\n+                let span_after_last_stmt = self.next_span(b.span.hi() - brace_compensation);\n+                let missing_snippet = self.snippet(span_after_last_stmt);\n+                CommentCodeSlices::new(missing_snippet)\n+                    .last()\n+                    .and_then(|(kind, _, s)| {\n+                        if kind == CodeCharKind::Normal && s.trim().is_empty() {\n+                            Some(s.len())\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .unwrap_or(0)\n+            }\n+        }\n+    }\n \n-        if skip_rewrite {\n-            self.push_rewrite(b.span, None);\n-            self.close_block(false, b.span);\n-            self.last_pos = source!(self, b.span).hi();\n-            return;\n+    pub(crate) fn visit_block(\n+        &mut self,\n+        b: &ast::Block,\n+        inner_attrs: Option<&[ast::Attribute]>,\n+        has_braces: bool,\n+    ) {\n+        debug!(\n+            \"visit_block: {:?} {:?}\",\n+            self.source_map.lookup_char_pos(b.span.lo()),\n+            self.source_map.lookup_char_pos(b.span.hi())\n+        );\n+\n+        // Check if this block has braces.\n+        let brace_compensation = BytePos(if has_braces { 1 } else { 0 });\n+\n+        self.last_pos = self.last_pos + brace_compensation;\n+        self.block_indent = self.block_indent.block_indent(self.config);\n+        self.push_str(\"{\");\n+        self.trim_spaces_after_opening_brace(b, inner_attrs);\n+\n+        // Format inner attributes if available.\n+        if let Some(attrs) = inner_attrs {\n+            self.visit_attrs(attrs, ast::AttrStyle::Inner);\n         }\n \n         self.walk_block_stmts(b);\n@@ -195,36 +225,22 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             }\n         }\n \n-        let mut remove_len = BytePos(0);\n-        if let Some(stmt) = b.stmts.last() {\n-            let span_after_last_stmt = mk_sp(\n-                stmt.span.hi(),\n-                source!(self, b.span).hi() - brace_compensation,\n-            );\n-            // if the span is outside of a file_lines range, then do not try to remove anything\n-            if !out_of_file_lines_range!(self, span_after_last_stmt) {\n-                let snippet = self.snippet(span_after_last_stmt);\n-                let len = CommentCodeSlices::new(snippet)\n-                    .last()\n-                    .and_then(|(kind, _, s)| {\n-                        if kind == CodeCharKind::Normal && s.trim().is_empty() {\n-                            Some(s.len())\n-                        } else {\n-                            None\n-                        }\n-                    });\n-                if let Some(len) = len {\n-                    remove_len = BytePos::from_usize(len);\n-                }\n-            }\n+        let missing_span = self.next_span(b.span.hi());\n+        if out_of_file_lines_range!(self, missing_span) {\n+            self.push_str(self.snippet(missing_span));\n+            self.block_indent = self.block_indent.block_unindent(self.config);\n+            self.last_pos = source!(self, b.span).hi();\n+            return;\n         }\n \n+        let remove_len = BytePos::from_usize(\n+            self.trimmed_spaces_width_before_closing_brace(b, brace_compensation),\n+        );\n         let unindent_comment = self.is_if_else_block && !b.stmts.is_empty() && {\n             let end_pos = source!(self, b.span).hi() - brace_compensation - remove_len;\n             let snippet = self.snippet(mk_sp(self.last_pos, end_pos));\n             snippet.contains(\"//\") || snippet.contains(\"/*\")\n         };\n-        // FIXME: we should compress any newlines here to just one\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_unindent(self.config);\n         }\n@@ -234,7 +250,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_indent(self.config);\n         }\n-        self.close_block(unindent_comment, b.span);\n+        self.close_block(unindent_comment, self.next_span(b.span.hi()));\n         self.last_pos = source!(self, b.span).hi();\n     }\n \n@@ -243,12 +259,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     // The closing brace itself, however, should be indented at a shallower\n     // level.\n     fn close_block(&mut self, unindent_comment: bool, span: Span) {\n-        let file_name: FileName = self.source_map.span_to_filename(span).into();\n         let skip_this_line = !self\n             .config\n             .file_lines()\n-            .contains_line(&file_name, self.line_number);\n-        if !skip_this_line {\n+            .contains(&LineRange::from_span(self.source_map, span));\n+        if skip_this_line {\n+            self.push_str(self.snippet(span));\n+        } else {\n             let total_len = self.buffer.len();\n             let chars_too_many = if unindent_comment {\n                 0\n@@ -271,8 +288,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     self.buffer.push_str(\"\\n\");\n                 }\n             }\n+            self.push_str(\"}\");\n         }\n-        self.push_str(\"}\");\n         self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n \n@@ -800,8 +817,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 self.visit_attrs(attrs, ast::AttrStyle::Inner);\n                 self.walk_mod_items(m);\n-                self.format_missing_with_indent(source!(self, m.inner).hi() - BytePos(1));\n-                self.close_block(false, m.inner);\n+                let missing_span = mk_sp(source!(self, m.inner).hi() - BytePos(1), m.inner.hi());\n+                self.format_missing_with_indent(missing_span.lo());\n+                self.close_block(false, missing_span);\n             }\n             self.last_pos = source!(self, m.inner).hi();\n         } else {\n@@ -823,9 +841,9 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {\n         while let Some(pos) = self\n             .snippet_provider\n-            .opt_span_after(mk_sp(self.last_pos, end_pos), \"\\n\")\n+            .opt_span_after(self.next_span(end_pos), \"\\n\")\n         {\n-            if let Some(snippet) = self.opt_snippet(mk_sp(self.last_pos, pos)) {\n+            if let Some(snippet) = self.opt_snippet(self.next_span(pos)) {\n                 if snippet.trim().is_empty() {\n                     self.last_pos = pos;\n                 } else {"}, {"sha": "b227ac35dccda82b31cc23b907877d6a6ccc4a04", "filename": "tests/source/file-lines-7.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Ffile-lines-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Ffile-lines-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffile-lines-7.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,24 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/file-lines-7.rs\",\"range\":[8,15]}]\n+\n+struct A {\n+    t: i64,\n+}\n+\n+mod foo {\n+    fn bar() {\n+\n+\n+\n+        // test \n+        let i = 12;\n+        // test\n+    }\n+\n+    fn baz() {\n+\n+\n+\n+        ///\n+        let j = 15;     \n+    }\n+}"}, {"sha": "9ce457c7b068e31d3e8defc4224d59ce7810c9e0", "filename": "tests/source/issue-3494/crlf.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3494%2Fcrlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3494%2Fcrlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3494%2Fcrlf.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3494/crlf.rs\",\"range\":[4,5]}]\n+\n+pub fn main()\r\n+{\r\n+let world1 = \"world\"; println!(\"Hello, {}!\", world1);\r\n+let world2 = \"world\"; println!(\"Hello, {}!\", world2);\r\n+let world3 = \"world\"; println!(\"Hello, {}!\", world3);\r\n+}\r"}, {"sha": "bdbe69cef4a64e15ac23b98a88fcd021e915958a", "filename": "tests/source/issue-3494/lf.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3494%2Flf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3494%2Flf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3494%2Flf.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3494/lf.rs\",\"range\":[4,5]}]\n+\n+pub fn main()\n+{\n+let world1 = \"world\"; println!(\"Hello, {}!\", world1);\n+let world2 = \"world\"; println!(\"Hello, {}!\", world2);\n+let world3 = \"world\"; println!(\"Hello, {}!\", world3);\n+}"}, {"sha": "edfa03012f29c789902171df0bda302e8f85b0f2", "filename": "tests/source/issue-3636.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3636.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Fsource%2Fissue-3636.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3636.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -1,4 +1,4 @@\n-// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3636.rs\",\"range\":[4,7]}]\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3636.rs\",\"range\":[4,7]},{\"file\":\"tests/target/issue-3636.rs\",\"range\":[3,6]}]\n \n fn foo() {\n     let x =\n@@ -7,4 +7,4 @@ fn foo() {\n         42;\n     let z = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n     let z = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";   \n-}\n\\ No newline at end of file\n+}"}, {"sha": "62d913d8823ecc013c84e8ea0f34a093da3d98b0", "filename": "tests/target/file-lines-7.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Ffile-lines-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Ffile-lines-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffile-lines-7.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,21 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/file-lines-7.rs\",\"range\":[8,15]}]\n+\n+struct A {\n+    t: i64,\n+}\n+\n+mod foo {\n+    fn bar() {\n+        // test\n+        let i = 12;\n+        // test\n+    }\n+\n+    fn baz() {\n+\n+\n+\n+        ///\n+        let j = 15;     \n+    }\n+}"}, {"sha": "cae615a06664c8c03ae21d4669ea361a4973206a", "filename": "tests/target/issue-3494/crlf.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3494%2Fcrlf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3494%2Fcrlf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3494%2Fcrlf.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3494/crlf.rs\",\"range\":[4,5]}]\n+\n+pub fn main() {\r\n+    let world1 = \"world\";\n+    println!(\"Hello, {}!\", world1);\r\n+let world2 = \"world\"; println!(\"Hello, {}!\", world2);\r\n+let world3 = \"world\"; println!(\"Hello, {}!\", world3);\r\n+}\r"}, {"sha": "60aafe19a0291eb90111a20fb10c5ac681166a05", "filename": "tests/target/issue-3494/lf.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3494%2Flf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3494%2Flf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3494%2Flf.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3494/lf.rs\",\"range\":[4,5]}]\n+\n+pub fn main() {\n+    let world1 = \"world\";\n+    println!(\"Hello, {}!\", world1);\n+let world2 = \"world\"; println!(\"Hello, {}!\", world2);\n+let world3 = \"world\"; println!(\"Hello, {}!\", world3);\n+}"}, {"sha": "d467ed7389f6825cdb304a87d32e5cc25a54729b", "filename": "tests/target/issue-3636.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3636.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89940e541f921b5b22c12a24f6c84e32c691a9a4/tests%2Ftarget%2Fissue-3636.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3636.rs?ref=89940e541f921b5b22c12a24f6c84e32c691a9a4", "patch": "@@ -1,8 +1,8 @@\n-// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3636.rs\",\"range\":[4,7]}]\n+// rustfmt-file_lines: [{\"file\":\"tests/source/issue-3636.rs\",\"range\":[4,7]},{\"file\":\"tests/target/issue-3636.rs\",\"range\":[3,6]}]\n \n fn foo() {\n     let x = 42;\n     let y = 42;\n     let z = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n-    let z = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";\n+    let z = \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\";   \n }"}]}