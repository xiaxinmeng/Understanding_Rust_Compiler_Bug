{"sha": "0f949c2fcc696d0260a99196d5e5400c59a26a54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTQ5YzJmY2M2OTZkMDI2MGE5OTE5NmQ1ZTU0MDBjNTlhMjZhNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T23:30:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T23:30:16Z"}, "message": "Auto merge of #58051 - SimonSapin:str_escape, r=alexcrichton\n\nStabilize str::escape_* methods with new return types\u2026\n\n\u2026 that implement `Display` and `Iterator<Item=char>`, as proposed in FCP: https://github.com/rust-lang/rust/issues/27791#issuecomment-376864727", "tree": {"sha": "3983d71e145a23778a0f394871d959360f35d5fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3983d71e145a23778a0f394871d959360f35d5fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f949c2fcc696d0260a99196d5e5400c59a26a54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f949c2fcc696d0260a99196d5e5400c59a26a54", "html_url": "https://github.com/rust-lang/rust/commit/0f949c2fcc696d0260a99196d5e5400c59a26a54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f949c2fcc696d0260a99196d5e5400c59a26a54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b244f61b77c42d7be695afd7901ee4418559e518", "url": "https://api.github.com/repos/rust-lang/rust/commits/b244f61b77c42d7be695afd7901ee4418559e518", "html_url": "https://github.com/rust-lang/rust/commit/b244f61b77c42d7be695afd7901ee4418559e518"}, {"sha": "eb158f93505dbc265787ac671cbc728c80f8a39d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb158f93505dbc265787ac671cbc728c80f8a39d", "html_url": "https://github.com/rust-lang/rust/commit/eb158f93505dbc265787ac671cbc728c80f8a39d"}], "stats": {"total": 525, "additions": 326, "deletions": 199}, "files": [{"sha": "d4ee428a3b5c775ee4369d004d9707a2b4902932", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -68,7 +68,6 @@\n #![warn(intra_doc_link_resolution_failure)]\n #![warn(missing_debug_implementations)]\n \n-#![cfg_attr(not(test), feature(fn_traits))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n \n@@ -86,6 +85,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n+#![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(futures_api)]\n #![feature(lang_items)]\n@@ -100,6 +100,7 @@\n #![feature(receiver_trait)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]"}, {"sha": "a36804bddff32ec16b048e5ae2e2f1d3534071a6", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -29,8 +29,6 @@\n #![allow(unused_imports)]\n \n use core::borrow::Borrow;\n-use core::fmt;\n-use core::str as core_str;\n use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n@@ -443,45 +441,6 @@ impl str {\n         return s;\n     }\n \n-    /// Escapes each char in `s` with [`char::escape_debug`].\n-    ///\n-    /// Note: only extended grapheme codepoints that begin the string will be\n-    /// escaped.\n-    ///\n-    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_debug(&self) -> String {\n-        let mut string = String::with_capacity(self.len());\n-        let mut chars = self.chars();\n-        if let Some(first) = chars.next() {\n-            string.extend(first.escape_debug_ext(true))\n-        }\n-        string.extend(chars.flat_map(|c| c.escape_debug_ext(false)));\n-        string\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_default`].\n-    ///\n-    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_default(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_default()).collect()\n-    }\n-\n-    /// Escapes each char in `s` with [`char::escape_unicode`].\n-    ///\n-    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n-    #[unstable(feature = \"str_escape\",\n-               reason = \"return type may change to be an iterator\",\n-               issue = \"27791\")]\n-    pub fn escape_unicode(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_unicode()).collect()\n-    }\n-\n     /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n     /// [`String`]: string/struct.String.html\n@@ -612,3 +571,4 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     Box::from_raw(Box::into_raw(v) as *mut str)\n }\n+"}, {"sha": "2b63ac5c7d2f990707c31f476610206544396e98", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -5,7 +5,6 @@\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n #![feature(slice_sort_by_cached_key)]\n-#![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(vecdeque_rotate)]"}, {"sha": "a1dc763f6d8ffc2d928b9f8185e912a37fb4a512", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -990,15 +990,15 @@ fn test_split_at_boundscheck() {\n \n #[test]\n fn test_escape_unicode() {\n-    assert_eq!(\"abc\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n-    assert_eq!(\"a c\".escape_unicode(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_unicode(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n-    assert_eq!(\"'\\\"\\\\\".escape_unicode(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n-    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{fb00}\".escape_unicode(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n-    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode(), \"\\\\u{1d4ea}\\\\u{d}\");\n+    assert_eq!(\"abc\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{63}\");\n+    assert_eq!(\"a c\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{20}\\\\u{63}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_unicode().to_string(), \"\\\\u{d}\\\\u{a}\\\\u{9}\");\n+    assert_eq!(\"'\\\"\\\\\".escape_unicode().to_string(), \"\\\\u{27}\\\\u{22}\\\\u{5c}\");\n+    assert_eq!(\"\\x00\\x01\\u{fe}\\u{ff}\".escape_unicode().to_string(), \"\\\\u{0}\\\\u{1}\\\\u{fe}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_unicode().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_unicode().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{fb00}\".escape_unicode().to_string(), \"\\\\u{61}\\\\u{62}\\\\u{fb00}\");\n+    assert_eq!(\"\\u{1d4ea}\\r\".escape_unicode().to_string(), \"\\\\u{1d4ea}\\\\u{d}\");\n }\n \n #[test]\n@@ -1009,31 +1009,32 @@ fn test_escape_debug() {\n     // they are escaped. However, when the character is unescaped (e.g., for\n     // printable characters), only a single backslash appears (as the character\n     // itself appears in the debug string).\n-    assert_eq!(\"abc\".escape_debug(), \"abc\");\n-    assert_eq!(\"a c\".escape_debug(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug(), \"\u00e9\u00e8\u00ea\");\n-    assert_eq!(\"\\r\\n\\t\".escape_debug(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_debug(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug(), \"\\\\u{7f}\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug(), \"\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug(), \"\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_debug(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug(), \"\\\\u{10d4ea}\\\\r\");\n-    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug(), \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n+    assert_eq!(\"abc\".escape_debug().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_debug().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug().to_string(), \"\u00e9\u00e8\u00ea\");\n+    assert_eq!(\"\\r\\n\\t\".escape_debug().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_debug().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_debug().to_string(), \"\\\\u{7f}\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_debug().to_string(), \"\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug().to_string(), \"\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_debug().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_debug().to_string(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug().to_string(),\n+               \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n }\n \n #[test]\n fn test_escape_default() {\n-    assert_eq!(\"abc\".escape_default(), \"abc\");\n-    assert_eq!(\"a c\".escape_default(), \"a c\");\n-    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n-    assert_eq!(\"\\r\\n\\t\".escape_default(), \"\\\\r\\\\n\\\\t\");\n-    assert_eq!(\"'\\\"\\\\\".escape_default(), \"\\\\'\\\\\\\"\\\\\\\\\");\n-    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default(), \"\\\\u{7f}\\\\u{ff}\");\n-    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default(), \"\\\\u{100}\\\\u{ffff}\");\n-    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default(), \"\\\\u{10000}\\\\u{10ffff}\");\n-    assert_eq!(\"ab\\u{200b}\".escape_default(), \"ab\\\\u{200b}\");\n-    assert_eq!(\"\\u{10d4ea}\\r\".escape_default(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"abc\".escape_default().to_string(), \"abc\");\n+    assert_eq!(\"a c\".escape_default().to_string(), \"a c\");\n+    assert_eq!(\"\u00e9\u00e8\u00ea\".escape_default().to_string(), \"\\\\u{e9}\\\\u{e8}\\\\u{ea}\");\n+    assert_eq!(\"\\r\\n\\t\".escape_default().to_string(), \"\\\\r\\\\n\\\\t\");\n+    assert_eq!(\"'\\\"\\\\\".escape_default().to_string(), \"\\\\'\\\\\\\"\\\\\\\\\");\n+    assert_eq!(\"\\u{7f}\\u{ff}\".escape_default().to_string(), \"\\\\u{7f}\\\\u{ff}\");\n+    assert_eq!(\"\\u{100}\\u{ffff}\".escape_default().to_string(), \"\\\\u{100}\\\\u{ffff}\");\n+    assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_default().to_string(), \"\\\\u{10000}\\\\u{10ffff}\");\n+    assert_eq!(\"ab\\u{200b}\".escape_default().to_string(), \"ab\\\\u{200b}\");\n+    assert_eq!(\"\\u{10d4ea}\\r\".escape_default().to_string(), \"\\\\u{10d4ea}\\\\r\");\n }\n \n #[test]"}, {"sha": "122e5f3affdc2455cdd61db2dae60c9912ae339a", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -189,10 +189,8 @@ impl char {\n     /// An extended version of `escape_debug` that optionally permits escaping\n     /// Extended Grapheme codepoints. This allows us to format characters like\n     /// nonspacing marks better when they're at the start of a string.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"str_internals\", issue = \"0\")]\n     #[inline]\n-    pub fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n+    pub(crate) fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n         let init_state = match self {\n             '\\t' => EscapeDefaultState::Backslash('t'),\n             '\\r' => EscapeDefaultState::Backslash('r'),"}, {"sha": "9f0f6fd49fba1e930c41bfc08c4abc2b6d92d31f", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -75,3 +75,47 @@ macro_rules! forward_ref_op_assign {\n         }\n     }\n }\n+\n+/// Create a zero-size type similar to a closure type, but named.\n+#[unstable(feature = \"std_internals\", issue = \"0\")]\n+macro_rules! impl_fn_for_zst {\n+    ($(\n+        $( #[$attr: meta] )*\n+        // FIXME: when libcore is in the 2018 edition, use `?` repetition in\n+        // $( <$( $li : lifetime ),+> )?\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )* Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+            $body: block;\n+    )+) => {\n+        $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )* Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )* FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+    }\n+}"}, {"sha": "419980225c3358840380b0b4fd2e2cc5775a0862", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -95,6 +95,7 @@\n #![feature(simd_ffi)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]"}, {"sha": "363eae04f039c6d080fc6e7ef281f5a2ed41402c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 243, "deletions": 114, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -8,10 +8,13 @@ use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use fmt;\n+use fmt::{self, Write};\n use iter::{Map, Cloned, FusedIterator, TrustedLen, TrustedRandomAccess, Filter};\n+use iter::{Flatten, FlatMap, Chain};\n use slice::{self, SliceIndex, Split as SliceSplit};\n use mem;\n+use ops::Try;\n+use option;\n \n pub mod pattern;\n \n@@ -1345,33 +1348,14 @@ impl FusedIterator for Lines<'_> {}\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, cloneable fn type\n-#[derive(Clone)]\n-struct LinesAnyMap;\n-\n-impl<'a> Fn<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call(&self, (line,): (&'a str,)) -> &'a str {\n+impl_fn_for_zst! {\n+    /// A nameable, cloneable fn type\n+    #[derive(Clone)]\n+    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n         let l = line.len();\n         if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n         else { line }\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a str,)> for LinesAnyMap {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&*self, (line,))\n-    }\n-}\n-\n-impl<'a> FnOnce<(&'a str,)> for LinesAnyMap {\n-    type Output = &'a str;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(self, (line,): (&'a str,)) -> &'a str {\n-        Fn::call(&self, (line,))\n-    }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2727,7 +2711,7 @@ impl str {\n         let inner = self\n             .as_bytes()\n             .split(IsAsciiWhitespace)\n-            .filter(IsNotEmpty)\n+            .filter(BytesIsNotEmpty)\n             .map(UnsafeBytesToStr);\n         SplitAsciiWhitespace { inner }\n     }\n@@ -3964,6 +3948,146 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// Note: only extended grapheme codepoints that begin the string will be\n+    /// escaped.\n+    ///\n+    /// [`char::escape_debug`]: ../std/primitive.char.html#method.escape_debug\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_debug() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_debug());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\u2764\\\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_debug().to_string(), \"\u2764\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_debug(&self) -> EscapeDebug {\n+        let mut chars = self.chars();\n+        EscapeDebug {\n+            inner: chars.next()\n+                .map(|first| first.escape_debug_ext(true))\n+                .into_iter()\n+                .flatten()\n+                .chain(chars.flat_map(CharEscapeDebugContinue))\n+        }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: ../std/primitive.char.html#method.escape_default\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_default() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_default());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\n!\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_default(&self) -> EscapeDefault {\n+        EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n+    }\n+\n+    /// Return an iterator that escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: ../std/primitive.char.html#method.escape_unicode\n+    ///\n+    /// # Examples\n+    ///\n+    /// As an iterator:\n+    ///\n+    /// ```\n+    /// for c in \"\u2764\\n!\".escape_unicode() {\n+    ///     print!(\"{}\", c);\n+    /// }\n+    /// println!();\n+    /// ```\n+    ///\n+    /// Using `println!` directly:\n+    ///\n+    /// ```\n+    /// println!(\"{}\", \"\u2764\\n!\".escape_unicode());\n+    /// ```\n+    ///\n+    ///\n+    /// Both are equivalent to:\n+    ///\n+    /// ```\n+    /// println!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n+    /// ```\n+    ///\n+    /// Using `to_string`:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"\u2764\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n+    /// ```\n+    #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+    pub fn escape_unicode(&self) -> EscapeUnicode {\n+        EscapeUnicode { inner: self.chars().flat_map(CharEscapeUnicode) }\n+    }\n+}\n+\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct CharEscapeDebugContinue impl Fn = |c: char| -> char::EscapeDebug {\n+        c.escape_debug_ext(false)\n+    };\n+\n+    #[derive(Clone)]\n+    struct CharEscapeUnicode impl Fn = |c: char| -> char::EscapeUnicode {\n+        c.escape_unicode()\n+    };\n+    #[derive(Clone)]\n+    struct CharEscapeDefault impl Fn = |c: char| -> char::EscapeDefault {\n+        c.escape_default()\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4011,102 +4135,36 @@ pub struct SplitWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n #[derive(Clone, Debug)]\n pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, IsNotEmpty>, UnsafeBytesToStr>,\n-}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsAsciiWhitespace;\n-\n-impl<'a> FnOnce<(&'a u8, )> for IsAsciiWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&u8, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a> FnMut<(&'a u8, )> for IsAsciiWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&u8, )) -> bool {\n-        arg.0.is_ascii_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n+    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n-impl<'a, 'b> FnOnce<(&'a &'b [u8], )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u8], )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b [u8], )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a &'b [u8], )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n+impl_fn_for_zst! {\n+    #[derive(Clone)]\n+    struct IsWhitespace impl Fn = |c: char| -> bool {\n+        c.is_whitespace()\n+    };\n \n-#[derive(Clone)]\n-struct UnsafeBytesToStr;\n+    #[derive(Clone)]\n+    struct IsAsciiWhitespace impl Fn = |byte: &u8| -> bool {\n+        byte.is_ascii_whitespace()\n+    };\n \n-impl<'a> FnOnce<(&'a [u8], )> for UnsafeBytesToStr {\n-    type Output = &'a str;\n+    #[derive(Clone)]\n+    struct IsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b str| -> bool {\n+        !s.is_empty()\n+    };\n \n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&'a [u8], )) -> &'a str {\n-        self.call_mut(arg)\n-    }\n-}\n+    #[derive(Clone)]\n+    struct BytesIsNotEmpty impl<'a, 'b> Fn = |s: &'a &'b [u8]| -> bool {\n+        !s.is_empty()\n+    };\n \n-impl<'a> FnMut<(&'a [u8], )> for UnsafeBytesToStr {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&'a [u8], )) -> &'a str {\n-        unsafe { from_utf8_unchecked(arg.0) }\n-    }\n+    #[derive(Clone)]\n+    struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        unsafe { from_utf8_unchecked(bytes) }\n+    };\n }\n \n-\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n@@ -4216,3 +4274,74 @@ impl<'a> Iterator for EncodeUtf16<'a> {\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for EncodeUtf16<'_> {}\n+\n+/// The return type of [`str::escape_debug`].\n+///\n+/// [`str::escape_debug`]: ../../std/primitive.str.html#method.escape_debug\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug<'a> {\n+    inner: Chain<\n+        Flatten<option::IntoIter<char::EscapeDebug>>,\n+        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>\n+    >,\n+}\n+\n+/// The return type of [`str::escape_default`].\n+///\n+/// [`str::escape_default`]: ../../std/primitive.str.html#method.escape_default\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDefault<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n+}\n+\n+/// The return type of [`str::escape_unicode`].\n+///\n+/// [`str::escape_unicode`]: ../../std/primitive.str.html#method.escape_unicode\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeUnicode<'a> {\n+    inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n+}\n+\n+macro_rules! escape_types_impls {\n+    ($( $Name: ident ),+) => {$(\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> fmt::Display for $Name<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                self.clone().try_for_each(|c| f.write_char(c))\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> Iterator for $Name<'a> {\n+            type Item = char;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<char> { self.inner.next() }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+            #[inline]\n+            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+            {\n+                self.inner.try_fold(init, fold)\n+            }\n+\n+            #[inline]\n+            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n+            {\n+                self.inner.fold(init, fold)\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> FusedIterator for $Name<'a> {}\n+    )+}\n+}\n+\n+escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "489020d4ee778483ed03fbbc801b799ddf390284", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -277,7 +277,6 @@\n #![deny(rust_2018_idioms)]\n \n #![feature(nll)]\n-#![feature(str_escape)]\n \n use LabelText::*;\n \n@@ -538,7 +537,7 @@ impl<'a> LabelText<'a> {\n             EscStr(s) => s,\n             LabelStr(s) => {\n                 if s.contains('\\\\') {\n-                    (&*s).escape_default().into()\n+                    (&*s).escape_default().to_string().into()\n                 } else {\n                     s\n                 }"}, {"sha": "29e86e0eceee293aead988271288c144c7f2a653", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -634,7 +634,7 @@ impl LitKind {\n \n         match *self {\n             LitKind::Str(string, ast::StrStyle::Cooked) => {\n-                let escaped = string.as_str().escape_default();\n+                let escaped = string.as_str().escape_default().to_string();\n                 Token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None)\n             }\n             LitKind::Str(string, ast::StrStyle::Raw(n)) => {"}, {"sha": "a56cdf623bf43fa8eca910f33fe68c71a3267052", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -15,7 +15,6 @@\n #![feature(rustc_attrs)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n-#![feature(str_escape)]\n #![feature(step_trait)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]"}, {"sha": "cdf805176a2938f3e37db04fc62d9a8bc2780c49", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -606,7 +606,7 @@ pub trait PrintState<'a> {\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Err(st) => {\n-                let st = st.as_str().escape_debug();\n+                let st = st.as_str().escape_debug().to_string();\n                 let mut res = String::with_capacity(st.len() + 2);\n                 res.push('\\'');\n                 res.push_str(&st);"}, {"sha": "77e60c1363710ee48518bf6a5924152cc50cd4e6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -10,7 +10,6 @@\n #![feature(proc_macro_span)]\n #![feature(decl_macro)]\n #![feature(nll)]\n-#![feature(str_escape)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "44beb9dc1e534f4a9ead2a5d51807f7d7ce12ac6", "filename": "src/test/run-pass/threads-sendsync/sync-send-iterators-in-libcore.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fsync-send-iterators-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f949c2fcc696d0260a99196d5e5400c59a26a54/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fsync-send-iterators-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fsync-send-iterators-in-libcore.rs?ref=0f949c2fcc696d0260a99196d5e5400c59a26a54", "patch": "@@ -2,9 +2,6 @@\n // pretty-expanded FIXME #23616\n \n #![allow(warnings)]\n-#![feature(iter_empty)]\n-#![feature(iter_once)]\n-#![feature(str_escape)]\n \n use std::iter::{empty, once, repeat};\n "}]}