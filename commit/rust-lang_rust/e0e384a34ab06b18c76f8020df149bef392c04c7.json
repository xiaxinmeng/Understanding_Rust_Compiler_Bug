{"sha": "e0e384a34ab06b18c76f8020df149bef392c04c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZTM4NGEzNGFiMDZiMThjNzZmODAyMGRmMTQ5YmVmMzkyYzA0Yzc=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-04-22T01:15:55Z"}, "committer": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-05-10T16:05:51Z"}, "message": "Add ast docs to codegen script", "tree": {"sha": "dac26faaf5a1c46144cd27d4f0dd246d3a38c15a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dac26faaf5a1c46144cd27d4f0dd246d3a38c15a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e384a34ab06b18c76f8020df149bef392c04c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e384a34ab06b18c76f8020df149bef392c04c7", "html_url": "https://github.com/rust-lang/rust/commit/e0e384a34ab06b18c76f8020df149bef392c04c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e384a34ab06b18c76f8020df149bef392c04c7/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225f353aa26329260b8c7f69305f616a9edaad70", "url": "https://api.github.com/repos/rust-lang/rust/commits/225f353aa26329260b8c7f69305f616a9edaad70", "html_url": "https://github.com/rust-lang/rust/commit/225f353aa26329260b8c7f69305f616a9edaad70"}], "stats": {"total": 1532, "additions": 1515, "deletions": 17}, "files": [{"sha": "ed1bac091271fa9a4f845701ddaac8be6359e7cf", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1492, "deletions": 15, "changes": 1507, "blob_url": "https://github.com/rust-lang/rust/blob/e0e384a34ab06b18c76f8020df149bef392c04c7/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e384a34ab06b18c76f8020df149bef392c04c7/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=e0e384a34ab06b18c76f8020df149bef392c04c7", "patch": "@@ -230,6 +230,7 @@ pub(crate) struct AstSrc<'a> {\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n+    pub(crate) doc: &'a [&'a str],\n     pub(crate) name: &'a str,\n     pub(crate) traits: &'a [&'a str],\n     pub(crate) fields: &'a [Field<'a>],\n@@ -247,19 +248,22 @@ pub(crate) enum FieldSrc<'a> {\n }\n \n pub(crate) struct AstEnumSrc<'a> {\n+    pub(crate) doc: &'a [&'a str],\n     pub(crate) name: &'a str,\n     pub(crate) traits: &'a [&'a str],\n     pub(crate) variants: &'a [&'a str],\n }\n \n macro_rules! ast_nodes {\n     ($(\n+        $(#[doc = $doc:expr])+\n         struct $name:ident$(: $($trait:ident),*)? {\n             $($field_name:ident $(![$token:tt])? $(: $ty:tt)?),*$(,)?\n         }\n     )*) => {\n         [$(\n             AstNodeSrc {\n+                doc: &[$($doc),*],\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n                 fields: &[\n@@ -288,12 +292,14 @@ macro_rules! field {\n \n macro_rules! ast_enums {\n     ($(\n+        $(#[doc = $doc:expr])+\n         enum $name:ident $(: $($trait:ident),*)? {\n             $($variant:ident),*$(,)?\n         }\n     )*) => {\n         [$(\n             AstEnumSrc {\n+                doc: &[$($doc),*],\n                 name: stringify!($name),\n                 traits: &[$($(stringify!($trait)),*)?],\n                 variants: &[$(stringify!($variant)),*],\n@@ -305,10 +311,35 @@ macro_rules! ast_enums {\n pub(crate) const AST_SRC: AstSrc = AstSrc {\n     tokens: &[\"Whitespace\", \"Comment\", \"String\", \"RawString\"],\n     nodes: &ast_nodes! {\n+        /// The entire Rust source file. Includes all top-level inner attributes and module items.\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/crates-and-source-files.html)\n         struct SourceFile: ModuleItemOwner, AttrsOwner, DocCommentsOwner {\n             modules: [Module],\n         }\n \n+        /// Function definition either with body or not.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub extern \"C\" fn foo<T>(#[attr] Patern {p}: Pattern) -> u32\n+        ///     where\n+        ///         T: Debug\n+        ///     {\n+        ///         42\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// extern \"C\" {\n+        ///     \u2770 fn fn_decl(also_variadic_ffi: u32, ...) -> u32; \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// - [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n+        /// - [Nomicon](https://doc.rust-lang.org/nomicon/ffi.html#variadic-functions)\n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n             Abi,\n             T![const],\n@@ -318,65 +349,279 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![fn],\n             ParamList,\n             RetType,\n-            body: BlockExpr,\n-            T![;]\n-        }\n+            body: BlockExpr, // TODO: maybe it makes sense to make it `Block` instead,\n+            T![;]            // Or what if there may be a posibility of tryblocks as function body?\n+        }                    // But try blocks are not `BlockExpr`\n \n+        /// Return type annotation.\n+        ///\n+        /// ```\n+        /// fn foo(a: u32) \u2770 -> Option<u32> \u2771 { Some(a) }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct RetType { T![->], TypeRef }\n \n+        /// Struct definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     struct Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         pub a: u32,\n+        ///         b: T,\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// \u2770 struct Foo; \u2771\n+        /// \u2770 struct Foo<T>(#[attr] T) where T: Debug; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![struct],\n             FieldDefList,\n             T![;]\n         }\n \n+        /// Union definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub union Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         a: T,\n+        ///         b: u32,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/unions.html)\n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![union],\n             RecordFieldDefList,\n         }\n \n+        /// Record field definition list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// struct Foo // same for union\n+        /// \u2770\n+        ///     {\n+        ///         a: u32,\n+        ///         b: bool,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct RecordFieldDefList { T!['{'], fields: [RecordFieldDef], T!['}'] }\n+\n+        /// Record field definition including its attributes and doc comments.\n+        ///\n+        /// ` ``\n+        /// same for union\n+        /// struct Foo {\n+        ///      \u2770\n+        ///          /// Docs\n+        ///          #[attr]\n+        ///          pub a: u32\n+        ///      \u2771\n+        ///\n+        ///      \u2770 b: bool \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n+        /// Tuple field definition list including enclosing parens.\n+        ///\n+        /// ```\n+        /// struct Foo \u2770 (u32, String, Vec<u32>) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct TupleFieldDefList { T!['('], fields: [TupleFieldDef], T![')'] }\n+\n+        /// Tuple field definition including its attributes.\n+        ///\n+        /// ```\n+        /// struct Foo(\u2770 #[attr] u32 \u2771);\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/structs.html)\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n \n+        /// Enum definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub enum Foo<T> where T: Debug {\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         Bar,\n+        ///         Baz(#[attr] u32),\n+        ///         Bruh {\n+        ///             a: u32,\n+        ///             /// Docs\n+        ///             #[attr]\n+        ///             b: T,\n+        ///         }\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![enum],\n             variant_list: EnumVariantList,\n         }\n+\n+        /// Enum variant definition list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// enum Foo\n+        /// \u2770\n+        ///     {\n+        ///         Bar,\n+        ///         Baz(u32),\n+        ///         Bruh {\n+        ///             a: u32\n+        ///         }\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumVariantList {\n             T!['{'],\n             variants: [EnumVariant],\n             T!['}']\n         }\n+\n+        /// Enum variant definition including its attributes and discriminant value definition.\n+        ///\n+        /// ```\n+        /// enum Foo {\n+        ///     \u2770\n+        ///         /// Docs\n+        ///         #[attr]\n+        ///         Bar\n+        ///     \u2771\n+        ///\n+        ///     // same for tuple and record variants\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/enumerations.html)\n         struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n             FieldDefList,\n             T![=],\n             Expr\n         }\n \n+        /// Trait definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub unsafe trait Foo<T>: Debug where T: Debug {\n+        ///         // ...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/traits.html)\n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n             T![unsafe],\n             T![auto],\n             T![trait],\n             ItemList,\n         }\n \n+        /// Module definition either with body or not.\n+        /// Includes all of its inner and outer attributes, module items, doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub mod foo;\n+        /// \u2771\n+        ///\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub mod bar {\n+        ///        //! Inner docs\n+        ///        #![inner_attr]\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/modules.html)\n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n             T![mod],\n             ItemList,\n             T![;]\n         }\n \n+        /// Item defintion list.\n+        /// This is used for both top-level items and impl block items.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     fn foo {}\n+        ///     struct Bar;\n+        ///     enum Baz;\n+        ///     trait Bruh;\n+        ///     const BRUUH: u32 = 42;\n+        /// \u2771\n+        ///\n+        /// impl Foo\n+        /// \u2770\n+        ///     {\n+        ///         fn bar() {}\n+        ///         const BAZ: u32 = 42;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items.html)\n         struct ItemList: ModuleItemOwner {\n             T!['{'],\n             assoc_items: [AssocItem],\n             T!['}']\n         }\n \n+        /// Constant variable definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub const FOO: u32 = 42;\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/constant-items.html)\n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n             T![default],\n             T![const],\n@@ -385,6 +630,19 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+\n+        /// Static variable definition.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub static mut FOO: u32 = 42;\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/static-items.html)\n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n             T![static],\n             T![mut],\n@@ -393,6 +651,25 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+        // TODO: clarify whether this does include assoc type with bounds\n+        /// Type alias definition.\n+        /// Includes associated type clauses with type bounds.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     pub type Foo<T> where T: Debug = T;\n+        /// \u2771\n+        ///\n+        /// trait Bar {\n+        ///     \u2770 type Baz: Debug; \u2771\n+        ///     \u2770 type Bruh = String; \u2771\n+        ///     \u2770 type Bruuh: Debug = u32; \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/type-aliases.html)\n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n             T![default],\n             T![type],\n@@ -401,109 +678,798 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![;]\n         }\n \n+        /// Inherent and trait impl definition.\n+        /// Includes all of its inner and outer attributes.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     #[attr]\n+        ///     unsafe impl<T> !Foo for Bar where T: Debug {\n+        ///         #![inner_attr]\n+        ///         // ...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/implementations.html)\n         struct ImplDef: TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n             T![default],\n-            T![const],\n+            T![const], // TODO: wat?\n             T![unsafe],\n             T![impl],\n             T![!],\n             T![for],\n             ItemList,\n         }\n \n+\n+        /// Parenthesized type reference.\n+        /// Note: parens are only used for grouping, this is not a tuple type.\n+        ///\n+        /// ```\n+        /// // This is effectively just `u32`.\n+        /// // Single-item tuple must be defined with a trailing comma: `(u32,)`\n+        /// type Foo = \u2770 (u32) \u2771;\n+        ///\n+        /// let bar: &'static \u2770 (dyn Debug) \u2771 = \"bruh\";\n+        /// ```\n         struct ParenType { T!['('], TypeRef, T![')'] }\n+\n+        /// Unnamed tuple type.\n+        ///\n+        /// ```\n+        /// let foo: \u2770 (u32, bool) \u2771 = (42, true);\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/tuple.html)\n         struct TupleType { T!['('], fields: [TypeRef], T![')'] }\n+\n+        /// The never type (i.e. the exclamation point).\n+        ///\n+        /// ```\n+        /// type T = \u2770 ! \u2771;\n+        ///\n+        /// fn no_return() -> \u2770 ! \u2771 {\n+        ///     loop {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/never.html)\n         struct NeverType { T![!] }\n+\n+        /// Path to a type.\n+        /// Includes single identifier type names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 String \u2771;\n+        /// type Bar = \u2770 std::vec::Vec<T> \u2771;\n+        /// type Baz = \u2770 ::bruh::<Bruuh as Iterator>::Item \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct PathType { Path }\n+\n+        /// Raw pointer type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 *const u32 \u2771;\n+        /// type Bar = \u2770 *mut u32 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html#raw-pointers-const-and-mut)\n         struct PointerType { T![*], T![const], T![mut], TypeRef }\n+\n+        /// Array type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 [u32; 24 - 3] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/array.html)\n         struct ArrayType { T!['['], TypeRef, T![;], Expr, T![']'] }\n+\n+        /// Slice type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 [u8] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/slice.html)\n         struct SliceType { T!['['], TypeRef, T![']'] }\n+\n+        /// Reference type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 &'static str \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/pointer.html)\n         struct ReferenceType { T![&], T![lifetime], T![mut], TypeRef }\n+\n+        /// Placeholder type (i.e. the underscore).\n+        ///\n+        /// ```\n+        /// let foo: \u2770 _ \u2771 = 42_u32;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/inferred.html)\n         struct PlaceholderType { T![_] }\n+\n+        /// Function pointer type (not to be confused with `Fn*` family of traits).\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 async fn(#[attr] u32, named: bool) -> u32 \u2771;\n+        ///\n+        /// type Bar = \u2770 extern \"C\" fn(variadic: u32, #[attr] ...) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/function-pointer.html)\n         struct FnPointerType { Abi, T![unsafe], T![fn], ParamList, RetType }\n+\n+        /// Higher order type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 for<'a> fn(&'a str) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/nomicon/hrtb.html)\n         struct ForType { T![for], TypeParamList, TypeRef }\n+\n+        /// Opaque `impl Trait` type.\n+        ///\n+        /// ```\n+        /// fn foo(bar: \u2770 impl Debug + Eq \u2771) {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/impl-trait.html)\n         struct ImplTraitType: TypeBoundsOwner { T![impl] }\n+\n+        /// Trait object type.\n+        ///\n+        /// ```\n+        /// type Foo = \u2770 dyn Debug \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/types/trait-object.html)\n         struct DynTraitType: TypeBoundsOwner { T![dyn] }\n \n+        /// Tuple literal.\n+        ///\n+        /// ```\n+        /// \u2770 (42, true) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/tuple-expr.html)\n         struct TupleExpr: AttrsOwner { T!['('], exprs: [Expr], T![')'] }\n+\n+        /// Array literal.\n+        ///\n+        /// ```\n+        /// \u2770 [#![inner_attr] true, false, true] \u2771;\n+        ///\n+        /// \u2770 [\"baz\"; 24] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n         struct ArrayExpr: AttrsOwner { T!['['], exprs: [Expr], T![;], T![']'] }\n+\n+        /// Parenthesized expression.\n+        /// Note: parens are only used for grouping, this is not a tuple literal.\n+        ///\n+        /// ```\n+        /// \u2770 (#![inner_attr] 2 + 2) \u2771 * 2;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/grouped-expr.html)\n         struct ParenExpr: AttrsOwner { T!['('], Expr, T![')'] }\n-        struct PathExpr  { Path }\n+\n+        /// Path to a symbol in expression context.\n+        /// Includes single identifier variable names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// \u2770 Some::<i32> \u2771;\n+        /// \u2770 foo \u2771 + 42;\n+        /// \u2770 Vec::<i32>::push \u2771;\n+        /// \u2770 <[i32]>::reverse \u2771;\n+        /// \u2770 <String as std::borrow::Borrow<str>>::borrow \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/path-expr.html)\n+        struct PathExpr { Path }\n+\n+        /// Anonymous callable object literal a.k.a. closure, lambda or functor.\n+        ///\n+        /// ```\n+        /// \u2770 || 42 \u2771;\n+        /// \u2770 |a: u32| val + 1 \u2771;\n+        /// \u2770 async |#[attr] Pattern(_): Pattern| { bar } \u2771;\n+        /// \u2770 move || baz \u2771;\n+        /// \u2770 || -> u32 { closure_with_ret_type_annotation_requires_block_expr } \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/closure-expr.html)\n         struct LambdaExpr: AttrsOwner {\n-            T![static],\n+            // T![static], // TODO: what's this?\n             T![async],\n             T![move],\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n+\n+        /// If expression. Includes both regular `if` and `if let` forms.\n+        /// Beware that `else if` is a special case syntax sugar, because in general\n+        /// there has to be block expression after `else`.\n+        ///\n+        /// ```\n+        /// \u2770 if bool_cond { 42 } \u2771\n+        /// \u2770 if bool_cond { 42 } else { 24 } \u2771\n+        /// \u2770 if bool_cond { 42 } else if bool_cond2 { 42 } \u2771\n+        ///\n+        /// \u2770\n+        ///     if let Pattern(foo) = bar {\n+        ///         foo\n+        ///     } else {\n+        ///         panic!();\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n         struct IfExpr: AttrsOwner { T![if], Condition }\n+\n+        /// Unconditional loop expression.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     loop {\n+        ///         // yeah, it's that simple...\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html)\n         struct LoopExpr: AttrsOwner, LoopBodyOwner { T![loop] }\n+\n+        /// Block expression with an optional prefix (label, try ketword,\n+        /// unsafe keyword, async keyword...).\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     'label: try {\n+        ///         None?\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// - [try block](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)\n+        /// - [unsafe block](https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks)\n+        /// - [async block](https://doc.rust-lang.org/reference/expressions/block-expr.html#async-blocks)\n         struct EffectExpr: AttrsOwner { Label, T![try], T![unsafe], T![async], BlockExpr }\n+\n+\n+        /// For loop expression.\n+        /// Note: record struct literals are not valid as iterable expression\n+        /// due to ambiguity.\n+        ///\n+        /// ```\n+        /// \u2770\n+        /// for i in (0..4) {\n+        ///     dbg!(i);\n+        /// }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#iterator-loops)\n         struct ForExpr: AttrsOwner, LoopBodyOwner {\n             T![for],\n             Pat,\n             T![in],\n             iterable: Expr,\n         }\n+\n+        /// While loop expression. Includes both regular `while` and `while let` forms.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     while bool_cond {\n+        ///         42;\n+        ///     }\n+        /// \u2771\n+        /// \u2770\n+        ///     while let Pattern(foo) = bar {\n+        ///         bar += 1;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n         struct WhileExpr: AttrsOwner, LoopBodyOwner { T![while], Condition }\n+\n+        /// Continue expression.\n+        ///\n+        /// ```\n+        /// while bool_cond {\n+        ///     \u2770 continue \u2771;\n+        /// }\n+        ///\n+        /// 'outer: loop {\n+        ///     loop {\n+        ///         \u2770 continue 'outer \u2771;\n+        ///     }\n+        /// }\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#continue-expressions)\n         struct ContinueExpr: AttrsOwner { T![continue], T![lifetime] }\n+\n+        /// Break expression.\n+        ///\n+        /// ```\n+        /// while bool_cond {\n+        ///     \u2770 break \u2771;\n+        /// }\n+        /// 'outer: loop {\n+        ///     for foo in bar {\n+        ///         \u2770 break 'outer \u2771;\n+        ///     }\n+        /// }\n+        /// 'outer: loop {\n+        ///     loop {\n+        ///         \u2770 break 'outer 42 \u2771;\n+        ///     }\n+        /// }\n+        /// ```\n+        ///\n+        /// [Refernce](https://doc.rust-lang.org/reference/expressions/loop-expr.html#break-expressions)\n         struct BreakExpr: AttrsOwner { T![break], T![lifetime], Expr }\n+\n+        /// Label.\n+        ///\n+        /// ```\n+        /// \u2770 'outer: \u2771 loop {}\n+        ///\n+        /// let foo = \u2770 'bar: \u2771 loop {}\n+        ///\n+        /// \u2770 'baz: \u2771 {\n+        ///     break 'baz;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html?highlight=label#loop-labels)\n+        /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct Label { T![lifetime] }\n+\n+        /// Block expression. Includes unsafe blocks and block labels.\n+        ///\n+        /// ```\n+        ///     let foo = \u2770\n+        ///         {\n+        ///             #![inner_attr]\n+        ///             \u2770 { } \u2771\n+        ///\n+        ///             \u2770 'label: { break 'label } \u2771\n+        ///         }\n+        ///     \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/block-expr.html)\n+        /// [Labels for blocks RFC](https://github.com/rust-lang/rfcs/blob/master/text/2046-label-break-value.md)\n         struct BlockExpr: AttrsOwner, ModuleItemOwner {\n             T!['{'], statements: [Stmt], Expr, T!['}'],\n         }\n+\n+        /// Return expression.\n+        ///\n+        /// ```\n+        /// || \u2770 return 42 \u2771;\n+        ///\n+        /// fn bar() {\n+        ///     \u2770 return \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/return-expr.html)\n         struct ReturnExpr: AttrsOwner { Expr }\n+\n+        /// Call expression (not to be confused with method call expression, it is\n+        /// a separate ast node).\n+        ///\n+        /// ```\n+        /// \u2770 foo() \u2771;\n+        /// \u2770 &str::len(\"bar\") \u2771;\n+        /// \u2770 <&str as PartialEq<&str>>::eq(&\"\", &\"\") \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n         struct CallExpr: ArgListOwner { Expr }\n+\n+        /// Method call expression.\n+        ///\n+        /// ```\n+        /// \u2770 receiver_expr.method() \u2771;\n+        /// \u2770 receiver_expr.method::<T>(42, true) \u2771;\n+        ///\n+        /// \u2770 \u2770 \u2770 foo.bar() \u2771 .baz() \u2771 .bruh() \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/method-call-expr.html)\n         struct MethodCallExpr: AttrsOwner, ArgListOwner {\n             Expr, T![.], NameRef, TypeArgList,\n         }\n+\n+        /// Index expression a.k.a. subscript operator call.\n+        ///\n+        /// ```\n+        /// \u2770 foo[42] \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/array-expr.html)\n         struct IndexExpr: AttrsOwner { T!['['], T![']'] }\n+\n+        /// Field access expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr.bar \u2771;\n+        ///\n+        /// \u2770 \u2770 \u2770 foo.bar \u2771 .baz \u2771 .bruh \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/field-expr.html)\n         struct FieldExpr: AttrsOwner { Expr, T![.], NameRef }\n+\n+        /// Await operator call expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr.await \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/await-expr.html)\n         struct AwaitExpr: AttrsOwner { Expr, T![.], T![await] }\n+\n+        /// The question mark operator call.\n+        ///\n+        /// ```\n+        /// \u2770 expr? \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator)\n         struct TryExpr: AttrsOwner { Expr, T![?] }\n+\n+        /// Type cast expression.\n+        ///\n+        /// ```\n+        /// \u2770 expr as T \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions)\n         struct CastExpr: AttrsOwner { Expr, T![as], TypeRef }\n+\n+\n+        /// Borrow operator call.\n+        ///\n+        /// ```\n+        /// \u2770 &foo \u2771;\n+        /// \u2770 &mut bar \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#borrow-operators)\n         struct RefExpr: AttrsOwner { T![&], T![raw], T![mut], Expr }\n+\n+        /// Prefix operator call. This is either `!` or `*` or `-`.\n+        ///\n+        /// ```\n+        /// \u2770 !foo \u2771;\n+        /// \u2770 *bar \u2771;\n+        /// \u2770 -42 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html)\n         struct PrefixExpr: AttrsOwner { /*PrefixOp,*/ Expr }\n+\n+        /// Box operator call.\n+        ///\n+        /// ```\n+        /// \u2770 box 42 \u2771;\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/0806be4f282144cfcd55b1d20284b43f87cbe1c6/text/0809-box-and-in-for-stdlib.md)\n         struct BoxExpr: AttrsOwner { T![box], Expr }\n+\n+        /// Range operator call.\n+        ///\n+        /// ```\n+        /// \u2770 0..42 \u2771;\n+        /// \u2770 ..42 \u2771;\n+        /// \u2770 0.. \u2771;\n+        /// \u2770 .. \u2771;\n+        /// \u2770 0..=42 \u2771;\n+        /// \u2770 ..=42 \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/range-expr.html)\n         struct RangeExpr: AttrsOwner { /*RangeOp*/ }\n+\n+\n+        /// Binary operator call.\n+        /// Includes all arithmetic, logic, bitwise and assignment operators.\n+        ///\n+        /// ```\n+        /// \u2770 2 + \u2770 2 * 2 \u2771 \u2771;\n+        /// \u2770 \u2770 true && false \u2771 || true \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators)\n         struct BinExpr: AttrsOwner { /*BinOp*/ }\n+\n+\n+        /// [Raw] string, [raw] byte string, char, byte, integer, float or bool literal.\n+        ///\n+        /// ```\n+        /// \u2770 \"str\" \u2771;\n+        /// \u2770 br##\"raw byte str\"## \u2771;\n+        /// \u2770 'c' \u2771;\n+        /// \u2770 b'c' \u2771;\n+        /// \u2770 42 \u2771;\n+        /// \u2770 1e9 \u2771;\n+        /// \u2770 true \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/literal-expr.html)\n         struct Literal { /*LiteralToken*/ }\n \n+        /// Match expression.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     match expr {\n+        ///         Pat1 => {}\n+        ///         Pat2(_) => 42,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchExpr: AttrsOwner { T![match], Expr, MatchArmList }\n+\n+        /// Match arm list part of match expression. Includes its inner attributes.\n+        ///\n+        /// ```\n+        /// match expr\n+        /// \u2770\n+        ///     {\n+        ///         #![inner_attr]\n+        ///         Pat1 => {}\n+        ///         Pat2(_) => 42,\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchArmList: AttrsOwner { T!['{'], arms: [MatchArm], T!['}'] }\n+\n+\n+        /// Match arm.\n+        /// Note: record struct literals are not valid as target match expression\n+        /// due to ambiguity.\n+        /// ```\n+        /// match expr {\n+        ///     \u2770 #[attr] Pattern(it) if bool_cond => it \u2771,\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html)\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n             T![=>],\n             Expr,\n         }\n+\n+        /// Match guard.\n+        ///\n+        /// ```\n+        /// match expr {\n+        ///     Pattern(it) \u2770 if bool_cond \u2771 => it,\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards)\n         struct MatchGuard { T![if], Expr }\n \n+        /// Record literal expression. The same syntax is used for structs,\n+        /// unions and record enum variants.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     foo::Bar {\n+        ///         #![inner_attr]\n+        ///         baz: 42,\n+        ///         bruh: true,\n+        ///         ..spread\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordLit { Path, RecordFieldList}\n+\n+        /// Record field list including enclosing curly braces.\n+        ///\n+        /// foo::Bar \u2770\n+        ///     {\n+        ///         baz: 42,\n+        ///         ..spread\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordFieldList {\n             T!['{'],\n             fields: [RecordField],\n             T![..],\n             spread: Expr,\n             T!['}']\n         }\n+\n+        /// Record field.\n+        ///\n+        /// ```\n+        /// foo::Bar {\n+        ///     \u2770 #[attr] baz: 42 \u2771\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/struct-expr.html)\n         struct RecordField: AttrsOwner { NameRef, T![:], Expr }\n \n+        /// Disjunction of patterns.\n+        ///\n+        /// ```\n+        /// let \u2770 Foo(it) | Bar(it) | Baz(it) \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html)\n         struct OrPat { pats: [Pat] }\n+\n+        /// Parenthesized pattern.\n+        /// Note: parens are only used for grouping, this is not a tuple pattern.\n+        ///\n+        /// ```\n+        /// if let \u2770 &(0..=42) \u2771 = foo {}\n+        /// ```\n+        ///\n+        /// https://doc.rust-lang.org/reference/patterns.html#grouped-patterns\n         struct ParenPat { T!['('], Pat, T![')'] }\n+\n+        /// Reference pattern.\n+        /// Note: this has nothing to do with `ref` keyword, the latter is used in bind patterns.\n+        ///\n+        /// ```\n+        /// let \u2770 &mut foo \u2771 = bar;\n+        /// ```\n+        /// // TODO: clarify on the special case of double reference pattern\n+        /// // described in the link bellow\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#reference-patterns)\n         struct RefPat { T![&], T![mut], Pat }\n+\n+        /// Box pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 box foo \u2771 = box 42;\n+        /// ```\n+        ///\n+        /// [Unstable book](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)\n         struct BoxPat { T![box], Pat }\n+\n+        /// Bind pattern.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     Some(\u2770 ref mut bar \u2771) => {}\n+        ///     \u2770 baz @ None \u2771 => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#identifier-patterns)\n         struct BindPat: AttrsOwner, NameOwner { T![ref], T![mut], T![@], Pat }\n+\n+        /// Placeholder pattern a.k.a. the wildcard pattern or the underscore.\n+        ///\n+        /// ```\n+        /// let \u2770 _ \u2771 = foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#wildcard-pattern)\n         struct PlaceholderPat { T![_] }\n+\n+        /// Rest-of-the record/tuple pattern.\n+        /// Note: this is not the unbonded range pattern (even more: it doesn't exist).\n+        ///\n+        /// ```\n+        /// let Foo { bar, \u2770 .. \u2771 } = baz;\n+        /// let (\u2770 .. \u2771, bruh) = (42, 24, 42);\n+        /// let Bruuh(\u2770 .. \u2771) = bruuuh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct DotDotPat { T![..] }\n+\n+        /// Path pattern.\n+        /// Doesn't include the underscore pattern (it is a special case, namely `PlaceholderPat`).\n+        ///\n+        /// ```\n+        /// let \u2770 foo::bar::Baz \u2771 { .. } = bruh;\n+        /// if let \u2770 CONST \u2771 = 42 {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#path-patterns)\n         struct PathPat { Path }\n+\n+        /// Slice pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 [foo, bar, baz] \u2771 = [1, 2, 3];\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#slice-patterns)\n         struct SlicePat { T!['['], args: [Pat], T![']'] }\n-        struct RangePat { /*RangeSeparator*/ }\n+\n+        /// Range pattern.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     \u2770 0..42 \u2771 => {}\n+        ///     \u2770 0..=42 \u2771 => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#range-patterns)\n+        struct RangePat { /*RangeSeparator*/ } // TODO: where is RangeSeparator?\n+\n+        /// Literal pattern.\n+        /// Includes only bool, number, char, and string literals.\n+        ///\n+        /// ```\n+        /// match foo {\n+        ///     Number(\u2770 42 \u2771) => {}\n+        ///     String(\u2770 \"42\" \u2771) => {}\n+        ///     Bool(\u2770 true \u2771) => {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#literal-patterns)\n         struct LiteralPat { Literal }\n+\n+        /// Macro invocation in pattern position.\n+        ///\n+        /// ```\n+        /// let \u2770 foo!(my custom syntax) \u2771 = baz;\n+        ///\n+        /// ```\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html#macro-invocation)\n         struct MacroPat { MacroCall }\n \n+        /// Record literal pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 foo::Bar { baz, .. } \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordPat { RecordFieldPatList, Path }\n+\n+        /// Record literal's field patterns list including enclosing curly braces.\n+        ///\n+        /// ```\n+        /// let foo::Bar \u2770 { baz, bind @ bruh, .. } \u2771 = bruuh;\n+        /// ``\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordFieldPatList {\n             T!['{'],\n             pats: [RecordInnerPat],\n@@ -512,20 +1478,131 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             T![..],\n             T!['}']\n         }\n+\n+        /// Record literal's field pattern.\n+        /// Note: record literal can also match tuple structs.\n+        ///\n+        /// ```\n+        /// let Foo { \u2770 bar: _ \u2771 } = baz;\n+        /// let TupleStruct { \u2770 0: _ \u2771 } = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#struct-patterns)\n         struct RecordFieldPat: AttrsOwner { NameRef, T![:], Pat }\n \n+        /// Tuple struct literal pattern.\n+        ///\n+        /// ```\n+        /// let \u2770 foo::Bar(baz, bruh) \u2771 = bruuh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-struct-patterns)\n         struct TupleStructPat { Path, T!['('], args: [Pat], T![')'] }\n+\n+        /// Tuple pattern.\n+        /// Note: this doesn't include tuple structs (see `TupleStructPat`)\n+        ///\n+        /// ```\n+        /// let \u2770 (foo, bar, .., baz) \u2771 = bruh;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/patterns.html#tuple-patterns)\n         struct TuplePat { T!['('], args: [Pat], T![')'] }\n \n+        /// Visibility.\n+        ///\n+        /// ```\n+        /// \u2770 pub mod \u2771 foo;\n+        /// \u2770 pub(crate) \u2771 struct Bar;\n+        /// \u2770 pub(self) \u2771 enum Baz {}\n+        /// \u2770 pub(super) \u2771 fn bruh() {}\n+        /// \u2770 pub(in bruuh::bruuuh) \u2771 type T = u64;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html)\n         struct Visibility { T![pub], T![super], T![self], T![crate] }\n+\n+        /// Single identifier.\n+        /// // TODO: clarify the difference between Name and NameRef\n+        ///\n+        /// ```\n+        /// let \u2770 foo \u2771 = bar;\n+        /// struct \u2770 Baz \u2771;\n+        /// fn \u2770 bruh \u2771() {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n         struct Name { T![ident] }\n-        struct NameRef { /*NameRefToken*/ }\n \n-        struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n-            Path, T![!], TokenTree, T![;]\n+        /// Reference to a name.\n+        ///\n+        /// ```\n+        /// let foo = \u2770 bar \u2771(\u2770 Baz(\u2770 bruh \u2771) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/identifiers.html)\n+        struct NameRef { /*NameRefToken*/ } // TODO: where is NameRefToken?\n+\n+        /// Macro call.\n+        /// Includes all of its attributes and doc comments.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     /// Docs\n+        ///     #[attr]\n+        ///     macro_rules! foo {   // macro rules is also a macro call\n+        ///         ($bar: tt) => {}\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// \u2770 foo!() \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n+        struct MacroCall: NameOwner, AttrsOwner, DocCommentsOwner {\n+            Path, T![!], TokenTree, T![;] // TODO: what is the meaning of the semicolon here?\n         }\n+\n+        /// Attribute.\n+        ///\n+        /// ```\n+        /// \u2770 #![inner_attr] \u2771\n+        ///\n+        /// \u2770 #[attr] \u2771\n+        /// \u2770 #[foo = \"bar\"] \u2771\n+        /// \u2770 #[baz(bruh::bruuh = \"42\")] \u2771\n+        /// struct Foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/attributes.html)\n         struct Attr { T![#], T![!], T!['['], Path, T![=], input: AttrInput, T![']'] }\n+\n+        /// // TODO: clarify on this AST type @edwin0cheng\n+        ///\n+        /// ```\n+        /// macro_call! \u2770 { my syntax here } \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n         struct TokenTree {}\n+\n+        // TODO: clarify this param vs arg i.e. delcaration vs instantiation\n+        // TODO: arg vs param doesn't really make a difference, the naming here is very confusing\n+        // This one is not so obvious as pattern vs template (@matklad)\n+        //\n+        /// Generic lifetime, type and constants parameters list **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo\u2770 <'a, 'b, T, U, const BAR: u64> \u2771() {}\n+        ///\n+        /// struct Baz\u2770 <T> \u2771(T);\n+        ///\n+        /// impl\u2770 <T> \u2771 Bruh<T> {}\n+        ///\n+        /// type Bruuh = for\u2770 <'a> \u2771 fn(&'a str) -> &'a str;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct TypeParamList {\n             T![<],\n             generic_params: [GenericParam],\n@@ -534,64 +1611,337 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             const_params: [ConstParam],\n             T![>]\n         }\n+\n+        /// Single type parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo<\u2770 K \u2771, \u2770 I \u2771, \u2770 E: Debug \u2771, \u2770 V = DefaultType \u2771>() {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n             T![=],\n             default_type: TypeRef,\n         }\n+\n+        /// Const generic parameter **declaration**.\n+        /// ```\n+        /// fn foo<T, U, \u2770 const BAR: usize \u2771, \u2770 const BAZ: bool \u2771>() {}\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n         struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n             T![=],\n             default_val: Expr,\n         }\n+\n+        /// Lifetime parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo<\u2770 'a \u2771, \u2770 'b \u2771, V, G, D>(bar: &'a str, baz: &'b mut str) {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html)\n         struct LifetimeParam: AttrsOwner { T![lifetime] }\n-        struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question,  */ TypeRef}\n+\n+        // TODO: better clarify where is the colon token and what `const` pertains to.\n+        // TODO: add example with `const`\n+        /// Type bound declaration clause.\n+        ///\n+        /// ```\n+        /// fn foo<T: \u2770 ?Sized \u2771 + \u2770 Debug \u2771>() {}\n+        ///\n+        /// trait Bar<T>\n+        /// where\n+        ///     T: \u2770 Send \u2771 + \u2770 Sync \u2771\n+        /// {\n+        ///     type Baz: \u2770 !Sync \u2771 + \u2770 Debug \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n+        struct TypeBound { T![lifetime], /* Question,  */ T![const], /* Question,  */ TypeRef }\n+\n+        /// Type bounds list.\n+        ///\n+        /// ```\n+        ///\n+        /// fn foo<T: \u2770 ?Sized + Debug \u2771>() {}\n+        ///\n+        /// trait Bar<T>\n+        /// where\n+        ///     T: \u2770 Send + Sync \u2771\n+        /// {\n+        ///     type Baz: \u2770 !Sync + Debug \u2771;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/trait-bounds.html)\n         struct TypeBoundList { bounds: [TypeBound] }\n+\n+        /// Single where predicate.\n+        ///\n+        /// ```\n+        /// trait Foo<'a, 'b, T>\n+        /// where\n+        ///     \u2770 'a: 'b \u2771,\n+        ///     \u2770 T: IntoIterator \u2771,\n+        ///     \u2770 for<'c> <T as IntoIterator>::Item: Bar<'c> \u2771\n+        /// {}\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n         struct WherePred: TypeBoundsOwner { T![lifetime], TypeRef }\n+\n+        /// Where clause.\n+        ///\n+        /// ```\n+        /// trait Foo<'a, T> \u2770 where 'a: 'static, T: Debug \u2771 {}\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n         struct WhereClause { T![where], predicates: [WherePred] }\n+\n+        /// Abi declaration.\n+        /// Note: the abi string is optional.\n+        ///\n+        /// ```\n+        /// \u2770 extern \"C\" \u2771 {\n+        ///     fn foo() {}\n+        /// }\n+        ///\n+        /// type Bar = \u2770 extern \u2771 fn() -> u32;\n+        ///\n+        /// type Baz = \u2770 extern r#\"stdcall\"# \u2771 fn() -> bool;\n+        /// ```\n+        ///\n+        /// - [Extern blocks reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n+        /// - [FFI function pointers reference](https://doc.rust-lang.org/reference/items/functions.html#functions)\n         struct Abi { /*String*/ }\n+\n+        // TODO: clarify how empty statements are handled\n+        /// Expression statement.\n+        /// Note: may be empty (i.e. only semicolon).\n+        ///\n+        /// ```\n+        /// \u2770 42; \u2771\n+        /// \u2770 foo(); \u2771\n+        /// \u2770 (); \u2771\n+        /// \u2770 {}; \u2771\n+        /// \u2770 /* empty */; \u2771\n+        ///\n+        /// // constructions with trailing curly brace can omit the semicolon // TODO: clarify\n+        /// \u2770 if bool_cond { } \u2771\n+        /// \u2770 loop {} \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/statements.html)\n         struct ExprStmt: AttrsOwner { Expr, T![;] }\n+\n+        /// Let statement.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] let foo; \u2771\n+        /// \u2770 let bar: u64; \u2771\n+        /// \u2770 let baz = 42; \u2771\n+        /// \u2770 let bruh: bool = true; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/statements.html#let-statements)\n         struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n             T![let],\n             Pat,\n             T![=],\n             initializer: Expr,\n             T![;],\n         }\n+\n+        /// Condition of `if` or `while` expression.\n+        ///\n+        /// ```\n+        /// if \u2770 true \u2771 {}\n+        /// if \u2770 let Pat(foo) = bar \u2771 {}\n+        ///\n+        /// while \u2770 true \u2771 {}\n+        /// while \u2770 let Pat(baz) = bruh \u2771 {}\n+        /// ```\n+        ///\n+        /// [If expression reference](https://doc.rust-lang.org/reference/expressions/if-expr.html)\n+        /// [While expression reference](https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-loops)\n         struct Condition { T![let], Pat, T![=], Expr }\n+\n+        // TODO: this one is used by closure expressions too, but hey use pipes instead of parens\n+        /// Parameter list **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo\u2770 (a: u32, b: bool) \u2771 -> u32 {}\n+        /// let bar = \u2770 |a, b| \u2771 {};\n+        ///\n+        /// impl Baz {\n+        ///     fn bruh\u2770 (&self, a: u32) \u2771 {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)ocs to codegen script\n         struct ParamList {\n             T!['('],\n             SelfParam,\n             params: [Param],\n             T![')']\n         }\n+\n+        /// Self parameter **declaration**.\n+        ///\n+        /// ```\n+        /// impl Bruh {\n+        ///     fn foo(\u2770 self \u2771) {}\n+        ///     fn bar(\u2770 &self \u2771) {}\n+        ///     fn baz(\u2770 &mut self \u2771) {}\n+        ///     fn blah<'a>(\u2770 &'a self \u2771) {}\n+        ///     fn blin(\u2770 self: Box<Self> \u2771) {}\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct SelfParam: TypeAscriptionOwner, AttrsOwner { T![&], T![mut], T![lifetime], T![self] }\n+\n+        /// Parameter **declaration**.\n+        ///\n+        /// ```\n+        /// fn foo(\u2770 #[attr] Pat(bar): Pat(u32) \u2771, \u2770 #[attr] _: bool \u2771) {}\n+        ///\n+        /// extern \"C\" {\n+        ///     fn bar(\u2770 baz: u32 \u2771, \u2770 ... \u2771) -> u32;\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/functions.html)\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n             T![...]\n         }\n+\n+        /// Use declaration.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] pub use foo; \u2771\n+        /// \u2770 use bar as baz; \u2771\n+        /// \u2770 use bruh::{self, bruuh}; \u2771\n+        /// \u2770 use { blin::blen, blah::* };\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseItem: AttrsOwner, VisibilityOwner {\n             T![use],\n             UseTree,\n         }\n+\n+        // TODO: verify example correctness\n+        /// Use tree.\n+        ///\n+        /// ```\n+        /// pub use \u2770 foo::\u2770 * \u2771 \u2771;\n+        /// use \u2770 bar as baz \u2771;\n+        /// use \u2770 bruh::bruuh::{ \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+        /// use \u2770 { \u2770 blin::blen \u2771 } \u2771 // TODO: clarify if top-level curlies are `UseTree`\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseTree {\n             Path, T![*], UseTreeList, Alias\n         }\n+\n+        /// Item alias.\n+        /// Note: this is not the type alias.\n+        ///\n+        /// ```\n+        /// use foo \u2770 as bar \u2771;\n+        /// use baz::{bruh \u2770 as _ \u2771};\n+        /// extern crate bruuh \u2770 as blin \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct Alias: NameOwner { T![as] }\n+\n+        /// Sublist of use trees.\n+        ///\n+        /// ```\n+        /// use bruh::bruuh::\u2770 { \u2770 self \u2771, \u2770 blin \u2771 } \u2771;\n+        /// use \u2770 { blin::blen::\u2770 {} \u2771 } \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/use-declarations.html)\n         struct UseTreeList { T!['{'], use_trees: [UseTree], T!['}'] }\n+\n+        /// Extern crate item.\n+        ///\n+        /// ```\n+        /// \u2770 #[attr] pub extern crate foo; \u2771\n+        /// \u2770 extern crate self as bar; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/extern-crates.html)\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n             T![extern], T![crate], NameRef, Alias,\n         }\n+\n+        /// Call site arguments list.\n+        ///\n+        /// ```\n+        /// foo::<T, U>\u2770 (42, true) \u2771;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/expressions/call-expr.html)\n         struct ArgList {\n             T!['('],\n             args: [Expr],\n             T![')']\n         }\n+\n+        // TODO: correct the example\n+        /// Path to a symbol. Includes single identifier names and elaborate paths with\n+        /// generic parameters.\n+        ///\n+        /// ```\n+        /// (0..10).\u2770 collect \u2770 ::<Vec<_>> \u2771 \u2771();\n+        /// \u2770 Vec \u2770 ::<u8> \u2770 ::with_capacity \u2771 \u2771 \u2771(1024);\n+        /// \u2770 <Foo as Bar> \u2770 ::baz \u2771 \u2771();\n+        /// \u2770 <bruh> \u2770 ::bruuh \u2771 \u2771();\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct Path {\n             segment: PathSegment,\n             qualifier: Path,\n         }\n+\n+        // TODO: verify the example\n+        // TODO: what RetType is doing here? is this for Fn() -> T syntax?\n+        /// Segment of the path to a symbol.\n+        ///\n+        /// ```\n+        /// (0..10).\u2770 collect \u2771 \u2770 ::<Vec<_>> \u2771();\n+        /// \u2770 Vec >| \u2770 ::<u8> \u2771 \u2770 ::with_capacity \u2771(1024);\n+        /// \u2770 <Foo as Bar> \u2771 \u2770 ::baz \u2771();\n+        /// \u2770 <bruh> \u2771 \u2770 ::bruuh \u2771();\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html)\n         struct PathSegment {\n             T![::], T![crate], T![self], T![super], T![<], NameRef, TypeArgList, ParamList, RetType, PathType, T![>]\n         }\n+\n+        // TODO: verify the example\n+        /// List of type arguments that are passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// use foo \u2770 ::<'a, u64, Item = Bar, 42, true> \u2771::bar;\n+        ///\n+        /// Vec\u2770 ::<bool> \u2771::();\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct TypeArgList {\n             T![::],\n             T![<],\n@@ -602,55 +1952,165 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             const_args: [ConstArg],\n             T![>]\n         }\n+\n+        /// Type argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// use foo::<'a, \u2770 u64 \u2771, \u2770 bool \u2771, Item = Bar, 42>::baz;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct TypeArg { TypeRef }\n+\n+        // TODO: verify inline type bounds example\n+        /// Associated type argument that is passed at generic instantiation site.\n+        /// ```\n+        /// use foo::<'a, u64, bool, \u2770 Item = Bar \u2771, 42>::baz;\n+        ///\n+        /// trait Bruh<T>: Iterator<\u2770 Item: Debug \u2771> {}\n+        /// ```\n+        ///\n         struct AssocTypeArg : TypeBoundsOwner { NameRef, T![=], TypeRef }\n+\n+        // TODO: verify?\n+        /// Lifetime argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// fn foo<'a>(s: &'a str) {\n+        ///     bar::<\u2770 'a \u2771>(s);\n+        /// }\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/paths.html#paths-in-expressions)\n         struct LifetimeArg { T![lifetime] }\n+\n+        // TODO: does this peratain to const generics?\n+        // What does equal sign do here?\n+        /// Constant value argument that is passed at generic instantiation site.\n+        ///\n+        /// ```\n+        /// foo::<\u2770 u32 \u2771, \u2770 true \u2771 >();\n+        ///\n+        /// bar::<\u2770 { 2 + 2} \u2771>();\n+        /// ```\n+        ///\n+        /// [RFC](https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md#declaring-a-const-parameter)\n         struct ConstArg { Literal, T![=], BlockExpr }\n \n-        struct MacroItems: ModuleItemOwner{ }\n+        // TODO: Idk what I am writing here, please don't believe these words.\n+        // TODO: clarify @matklad @edwin0cheng\n+        /// Macro items is a node that holds all the items created by expanding a macro.\n+        ///\n+        /// ```\n+        /// foo!(); // expands into some items -v\n+        ///         // \u2770 struct Foo; impl Bar for Foo; \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n+        struct MacroItems: ModuleItemOwner { }\n \n+        // TODO: Idk what I am writing here, please don't believe these words.\n+        // TODO: clarify @matklad @edwin0cheng\n+        /// Macro statements is a node that holds an statements created by expanding a macro.\n+        ///\n+        /// ```\n+        /// foo!(); // expands into some statements -v\n+        ///         // \u2770 foo_crate::bar(); \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros.html)\n         struct MacroStmts {\n             statements: [Stmt],\n             Expr,\n         }\n \n+        /// List of items in an extern block.\n+        ///\n+        /// ```\n+        /// extern \"C\" \u2770\n+        ///     {\n+        ///         fn foo();\n+        ///         static var: u32;\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n         struct ExternItemList: ModuleItemOwner {\n             T!['{'],\n             extern_items: [ExternItem],\n             T!['}']\n         }\n \n+        /// Extern block.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     extern \"C\" {\n+        ///         fn foo();\n+        ///     }\n+        /// \u2771\n+        ///\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/items/external-blocks.html)\n         struct ExternBlock {\n             Abi,\n             ExternItemList\n         }\n \n+        /// Meta item in an attribute.\n+        ///\n+        /// ```\n+        /// #[\u2770 bar::baz = \"42\" \u2771]\n+        /// #[\u2770 bruh(bruuh(\"true\")) \u2771]\n+        /// struct Foo;\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/attributes.html?highlight=meta,item#meta-item-attribute-syntax)\n         struct MetaItem {\n             Path, T![=], AttrInput, nested_meta_items: [MetaItem]\n         }\n \n+        // TODO: is this a special case of `MacroCall` where `Name` = `macro_rules`?\n+        // It doesn't seem this ast node is used anywhere\n+        /// Macro definition.\n+        ///\n+        /// ```\n+        /// \u2770\n+        ///     macro_rules! foo {\n+        ///         ($bar:tt) => {$bar}\n+        ///     }\n+        /// \u2771\n+        /// ```\n+        ///\n+        /// [Reference](https://doc.rust-lang.org/reference/macros-by-example.html)\n         struct MacroDef {\n             Name, TokenTree\n         }\n     },\n     enums: &ast_enums! {\n+        /// Any kind of nominal type definition.\n         enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n             StructDef, EnumDef, UnionDef,\n         }\n \n+        /// Any kind of **declared** generic parameter\n         enum GenericParam {\n             LifetimeParam,\n             TypeParam,\n             ConstParam\n         }\n \n+        /// Any kind of generic argument passed at instantiation site\n         enum GenericArg {\n             LifetimeArg,\n             TypeArg,\n             ConstArg,\n             AssocTypeArg\n         }\n \n+        /// Any kind of construct valid in type context\n         enum TypeRef {\n             ParenType,\n             TupleType,\n@@ -667,6 +2127,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             DynTraitType,\n         }\n \n+        /// Any kind of top-level item that may appear in a module\n         enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n             StructDef,\n             UnionDef,\n@@ -684,16 +2145,25 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             ExternBlock\n         }\n \n-        /* impl blocks can also contain MacroCall */\n+\n+\n+        /// Any kind of item that may appear in an impl block\n+        ///\n+        /// // TODO: is the following a fixme?\n+        /// impl blocks can also contain MacroCall\n         enum AssocItem: NameOwner, AttrsOwner {\n             FnDef, TypeAliasDef, ConstDef\n         }\n \n-        /* extern blocks can also contain MacroCall */\n+        /// Any kind of item that may appear in an extern block\n+        ///\n+        /// // TODO: is the following a fixme?\n+        /// extern blocks can also contain MacroCall\n         enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n             FnDef, StaticDef\n         }\n \n+        /// Any kind of expression\n         enum Expr: AttrsOwner {\n             TupleExpr,\n             ArrayExpr,\n@@ -728,6 +2198,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             BoxExpr,\n         }\n \n+        /// Any kind of pattern\n         enum Pat {\n             OrPat,\n             ParenPat,\n@@ -746,18 +2217,24 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             MacroPat,\n         }\n \n+        /// Any kind of pattern that appears directly inside of the curly\n+        /// braces of a record pattern\n         enum RecordInnerPat {\n             RecordFieldPat,\n             BindPat\n         }\n \n+        /// Any kind of input to an attribute\n         enum AttrInput { Literal, TokenTree }\n+\n+        /// Any kind of statement\n         enum Stmt {\n             LetStmt,\n             ExprStmt,\n-            // macro calls are parsed as expression statements */\n+            // macro calls are parsed as expression statements\n         }\n \n+        /// Any kind of fields list (record or tuple field lists)\n         enum FieldDefList {\n             RecordFieldDefList,\n             TupleFieldDefList,"}, {"sha": "19d5594f5b06f6af89e0235f82a003e164f16f93", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0e384a34ab06b18c76f8020df149bef392c04c7/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e384a34ab06b18c76f8020df149bef392c04c7/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=e0e384a34ab06b18c76f8020df149bef392c04c7", "patch": "@@ -3,7 +3,7 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n-use std::collections::HashSet;\n+use std::{collections::HashSet, fmt::Write};\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n@@ -102,6 +102,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             });\n             (\n                 quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n                     #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n                     pub struct #name {\n                         pub(crate) syntax: SyntaxNode,\n@@ -145,6 +146,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n \n             (\n                 quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n                     #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n                     pub enum #name {\n                         #(#variants(#variants),)*\n@@ -230,10 +232,29 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     };\n \n     let ast = ast.to_string().replace(\"T ! [ \", \"T![\").replace(\" ] )\", \"])\");\n-    let pretty = crate::reformat(ast)?.replace(\"#[derive\", \"\\n#[derive\");\n+\n+    let mut res = String::with_capacity(ast.len() * 2);\n+\n+    let mut docs =\n+        grammar.nodes.iter().map(|it| it.doc).chain(grammar.enums.iter().map(|it| it.doc));\n+\n+    for chunk in ast.split(\"# [ pretty_doc_comment_placeholder_workaround ]\") {\n+        res.push_str(chunk);\n+        if let Some(doc) = docs.next() {\n+            write_doc_comment(doc, &mut res);\n+        }\n+    }\n+\n+    let pretty = crate::reformat(res)?;\n     Ok(pretty)\n }\n \n+fn write_doc_comment(contents: &[&str], dest: &mut String) {\n+    for line in contents {\n+        writeln!(dest, \"///{}\", line).unwrap();\n+    }\n+}\n+\n fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n     let (single_byte_tokens_values, single_byte_tokens): (Vec<_>, Vec<_>) = grammar\n         .punct"}]}