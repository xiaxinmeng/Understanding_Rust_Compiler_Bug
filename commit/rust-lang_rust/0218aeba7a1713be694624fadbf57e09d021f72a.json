{"sha": "0218aeba7a1713be694624fadbf57e09d021f72a", "node_id": "C_kwDOAAsO6NoAKDAyMThhZWJhN2ExNzEzYmU2OTQ2MjRmYWRiZjU3ZTA5ZDAyMWY3MmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T04:54:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-05T04:54:12Z"}, "message": "Auto merge of #12150 - rainy-me:feat/fix-doc-url-links, r=rainy-me\n\nfix: doc url link type\n\nfix: #12033\n\nI did some debugging and found the cause looks like to be some doc links' `LinkType` are kept as `Shortcut` which don't make sense for url links.\nThis PR should resolve both problems in the origin issue, but aside this PR, more work are needed for doc_links.\n\nabout `LinkType`: https://github.com/raphlinus/pulldown-cmark/blob/f29bd1e228913690e5092c9594e4e607423ff0aa/src/lib.rs#L191-L210", "tree": {"sha": "eab4f8016a462e3b61450be827560d1d66b31ff5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eab4f8016a462e3b61450be827560d1d66b31ff5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0218aeba7a1713be694624fadbf57e09d021f72a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0218aeba7a1713be694624fadbf57e09d021f72a", "html_url": "https://github.com/rust-lang/rust/commit/0218aeba7a1713be694624fadbf57e09d021f72a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0218aeba7a1713be694624fadbf57e09d021f72a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f709d54463972b189a3120be4073c507f2fbc00", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f709d54463972b189a3120be4073c507f2fbc00", "html_url": "https://github.com/rust-lang/rust/commit/1f709d54463972b189a3120be4073c507f2fbc00"}, {"sha": "ddff1b22f957e98aa98acff87ce86c04c72db308", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddff1b22f957e98aa98acff87ce86c04c72db308", "html_url": "https://github.com/rust-lang/rust/commit/ddff1b22f957e98aa98acff87ce86c04c72db308"}], "stats": {"total": 117, "additions": 84, "deletions": 33}, "files": [{"sha": "fd4449307608c10387e309abeb44a7927607d8f6", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=0218aeba7a1713be694624fadbf57e09d021f72a", "patch": "@@ -853,6 +853,25 @@ impl<'attr> AttrQuery<'attr> {\n             .iter()\n             .filter(move |attr| attr.path.as_ident().map_or(false, |s| s.to_smol_str() == key))\n     }\n+\n+    /// Find string value for a specific key inside token tree\n+    ///\n+    /// ```ignore\n+    /// #[doc(html_root_url = \"url\")]\n+    ///       ^^^^^^^^^^^^^ key\n+    /// ```\n+    pub fn find_string_value_in_tt(self, key: &'attr str) -> Option<&SmolStr> {\n+        self.tt_values().find_map(|tt| {\n+            let name = tt.token_trees.iter()\n+                .skip_while(|tt| !matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident { text, ..} )) if text == key))\n+                .nth(2);\n+\n+            match name {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal{ref text, ..}))) => Some(text),\n+                _ => None\n+            }\n+        })\n+    }\n }\n \n fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {"}, {"sha": "c91fbce5eacf069a3c8e80ba7e10a63cd18420c9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0218aeba7a1713be694624fadbf57e09d021f72a", "patch": "@@ -75,7 +75,6 @@ use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, T,\n };\n-use tt::{Ident, Leaf, Literal, TokenTree};\n \n use crate::db::{DefDatabase, HirDatabase};\n \n@@ -230,23 +229,7 @@ impl Crate {\n     pub fn get_html_root_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {\n         // Look for #![doc(html_root_url = \"...\")]\n         let attrs = db.attrs(AttrDefId::ModuleId(self.root_module(db).into()));\n-        let doc_attr_q = attrs.by_key(\"doc\");\n-\n-        if !doc_attr_q.exists() {\n-            return None;\n-        }\n-\n-        let doc_url = doc_attr_q.tt_values().filter_map(|tt| {\n-            let name = tt.token_trees.iter()\n-                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident { text, ..} )) if text == \"html_root_url\"))\n-                .nth(2);\n-\n-            match name {\n-                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n-                _ => None\n-            }\n-        }).next();\n-\n+        let doc_url = attrs.by_key(\"doc\").find_string_value_in_tt(\"html_root_url\");\n         doc_url.map(|s| s.trim_matches('\"').trim_end_matches('/').to_owned() + \"/\")\n     }\n "}, {"sha": "9ad11b7a6537360a166095d0df011328cc260032", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=0218aeba7a1713be694624fadbf57e09d021f72a", "patch": "@@ -45,19 +45,19 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Defin\n         // and valid URLs so we choose to be too eager to try to resolve what might be\n         // a URL.\n         if target.contains(\"://\") {\n-            (target.to_string(), title.to_string())\n+            (Some(LinkType::Inline), target.to_string(), title.to_string())\n         } else {\n             // Two possibilities:\n             // * path-based links: `../../module/struct.MyStruct.html`\n             // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            if let Some(rewritten) = rewrite_intra_doc_link(db, definition, target, title) {\n-                return rewritten;\n+            if let Some((target, title)) = rewrite_intra_doc_link(db, definition, target, title) {\n+                return (None, target, title);\n             }\n             if let Some(target) = rewrite_url_link(db, definition, target) {\n-                return (target, title.to_string());\n+                return (Some(LinkType::Inline), target, title.to_string());\n             }\n \n-            (target.to_string(), title.to_string())\n+            (None, target.to_string(), title.to_string())\n         }\n     });\n     let mut out = String::new();\n@@ -368,33 +368,42 @@ fn mod_path_of_def(db: &RootDatabase, def: Definition) -> Option<String> {\n /// Rewrites a markdown document, applying 'callback' to each link.\n fn map_links<'e>(\n     events: impl Iterator<Item = Event<'e>>,\n-    callback: impl Fn(&str, &str) -> (String, String),\n+    callback: impl Fn(&str, &str) -> (Option<LinkType>, String, String),\n ) -> impl Iterator<Item = Event<'e>> {\n     let mut in_link = false;\n-    let mut link_target: Option<CowStr> = None;\n+    // holds the origin link target on start event and the rewritten one on end event\n+    let mut end_link_target: Option<CowStr> = None;\n+    // normally link's type is determined by the type of link tag in the end event,\n+    // however in same cases we want to change the link type, for example,\n+    // `Shortcut` type doesn't make sense for url links\n+    let mut end_link_type: Option<LinkType> = None;\n \n     events.map(move |evt| match evt {\n         Event::Start(Tag::Link(_, ref target, _)) => {\n             in_link = true;\n-            link_target = Some(target.clone());\n+            end_link_target = Some(target.clone());\n             evt\n         }\n         Event::End(Tag::Link(link_type, target, _)) => {\n             in_link = false;\n             Event::End(Tag::Link(\n-                link_type,\n-                link_target.take().unwrap_or(target),\n+                end_link_type.unwrap_or(link_type),\n+                end_link_target.take().unwrap_or(target),\n                 CowStr::Borrowed(\"\"),\n             ))\n         }\n         Event::Text(s) if in_link => {\n-            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n-            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            let (link_type, link_target_s, link_name) =\n+                callback(&end_link_target.take().unwrap(), &s);\n+            end_link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            end_link_type = link_type;\n             Event::Text(CowStr::Boxed(link_name.into()))\n         }\n         Event::Code(s) if in_link => {\n-            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n-            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            let (link_type, link_target_s, link_name) =\n+                callback(&end_link_target.take().unwrap(), &s);\n+            end_link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            end_link_type = link_type;\n             Event::Code(CowStr::Boxed(link_name.into()))\n         }\n         _ => evt,\n@@ -468,7 +477,13 @@ fn filename_and_frag_for_def(\n             Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n         },\n         Definition::Module(m) => match m.name(db) {\n-            Some(name) => format!(\"{}/index.html\", name),\n+            // `#[doc(keyword = \"...\")]` is internal used only by rust compiler\n+            Some(name) => match m.attrs(db).by_key(\"doc\").find_string_value_in_tt(\"keyword\") {\n+                Some(kw) => {\n+                    format!(\"keyword.{}.html\", kw.trim_matches('\"'))\n+                }\n+                None => format!(\"{}/index.html\", name),\n+            },\n             None => String::from(\"index.html\"),\n         },\n         Definition::Trait(t) => format!(\"trait.{}.html\", t.name(db)),"}, {"sha": "95420f2ffe1f7a7dc095e82bd03e81dbee9573be", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0218aeba7a1713be694624fadbf57e09d021f72a/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=0218aeba7a1713be694624fadbf57e09d021f72a", "patch": "@@ -3641,6 +3641,40 @@ mod return_keyword {}\n     );\n }\n \n+#[test]\n+fn hover_keyword_doc() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn foo() {\n+    let bar = mov$0e || {};\n+}\n+//- /libstd.rs crate:std\n+#[doc(keyword = \"move\")]\n+/// [closure]\n+/// [closures][closure]\n+/// [threads]\n+///\n+/// [closure]: ../book/ch13-01-closures.html\n+/// [threads]: ../book/ch16-01-threads.html#using-move-closures-with-threads\n+mod move_keyword {}\n+\"#,\n+        expect![[r##\"\n+            *move*\n+\n+            ```rust\n+            move\n+            ```\n+\n+            ---\n+\n+            [closure](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n+            [closures](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n+            [threads](https://doc.rust-lang.org/nightly/book/ch16-01-threads.html#using-move-closures-with-threads)\n+        \"##]],\n+    );\n+}\n+\n #[test]\n fn hover_keyword_as_primitive() {\n     check("}]}