{"sha": "5d540de76993eb6dac9893138e45d0324c23e631", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTQwZGU3Njk5M2ViNmRhYzk4OTMxMzhlNDVkMDMyNGMyM2U2MzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T17:38:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-12T20:29:31Z"}, "message": "fixup mutability of vec::each, make iter_bytes pure\n\nalso, change DVec() to work with imm vectors rather than mut ones", "tree": {"sha": "067007dea6fa0428c80b913a10730ab3323a40f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/067007dea6fa0428c80b913a10730ab3323a40f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d540de76993eb6dac9893138e45d0324c23e631", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d540de76993eb6dac9893138e45d0324c23e631", "html_url": "https://github.com/rust-lang/rust/commit/5d540de76993eb6dac9893138e45d0324c23e631", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d540de76993eb6dac9893138e45d0324c23e631/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fbe4b58412b2818d4ef3d92259bdf5f88f61606", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fbe4b58412b2818d4ef3d92259bdf5f88f61606", "html_url": "https://github.com/rust-lang/rust/commit/8fbe4b58412b2818d4ef3d92259bdf5f88f61606"}], "stats": {"total": 535, "additions": 353, "deletions": 182}, "files": [{"sha": "d59d3828206197090daac28d48ab8a1844a53556", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -50,7 +50,7 @@ export unwrap;\n  * type could only produce 47 million pushes/second.\n  */\n type DVec_<A> = {\n-    mut data: ~[mut A]\n+    mut data: ~[A]\n };\n \n enum DVec<A> {\n@@ -59,21 +59,21 @@ enum DVec<A> {\n \n /// Creates a new, empty dvec\n fn DVec<A>() -> DVec<A> {\n-    DVec_({mut data: ~[mut]})\n+    DVec_({mut data: ~[]})\n }\n \n /// Creates a new dvec with a single element\n fn from_elem<A>(+e: A) -> DVec<A> {\n-    DVec_({mut data: ~[mut move e]})\n+    DVec_({mut data: ~[move e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n-fn from_vec<A>(+v: ~[mut A]) -> DVec<A> {\n+fn from_vec<A>(+v: ~[A]) -> DVec<A> {\n     DVec_({mut data: move v})\n }\n \n /// Consumes the vector and returns its contents\n-fn unwrap<A>(+d: DVec<A>) -> ~[mut A] {\n+fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n     let DVec_({data: v}) <- d;\n     move v\n }\n@@ -89,7 +89,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn check_out<B>(f: fn(-~[mut A]) -> B) -> B {\n+    fn check_out<B>(f: fn(-~[A]) -> B) -> B {\n         unsafe {\n             let mut data = unsafe::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n@@ -100,9 +100,9 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn give_back(-data: ~[mut A]) {\n+    fn give_back(+data: ~[A]) {\n         unsafe {\n-            self.data <- data;\n+            self.data = move data;\n         }\n     }\n }\n@@ -122,10 +122,22 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n+    fn swap(f: fn(-~[A]) -> ~[A]) {\n         self.check_out(|v| self.give_back(f(move v)))\n     }\n \n+    /**\n+     * Swaps out the current vector and hands it off to a user-provided\n+     * function `f`.  The function should transform it however is desired\n+     * and return a new vector to replace it with.\n+     */\n+    #[inline(always)]\n+    fn swap_mut(f: fn(-~[mut A]) -> ~[mut A]) {\n+        do self.swap |v| {\n+            vec::from_mut(f(vec::to_mut(move v)))\n+        }\n+    }\n+\n     /// Returns the number of elements currently in the dvec\n     pure fn len() -> uint {\n         unchecked {\n@@ -138,7 +150,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Overwrite the current contents\n-    fn set(+w: ~[mut A]) {\n+    fn set(+w: ~[A]) {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n@@ -161,7 +173,7 @@ impl<A> DVec<A> {\n             let data_ptr: *() = unsafe::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n-            self.data <- ~[mut move t];\n+            self.data <- ~[move t];\n             vec::push_all_move(self.data, move data);\n             log(error, ~\"b\");\n         }\n@@ -176,16 +188,17 @@ impl<A> DVec<A> {\n     /// Remove and return the first element\n     fn shift() -> A {\n         do self.check_out |v| {\n-            let mut v = vec::from_mut(move v);\n+            let mut v = move v;\n             let result = vec::shift(v);\n-            self.give_back(vec::to_mut(move v));\n+            self.give_back(move v);\n             move result\n         }\n     }\n \n     /// Reverse the elements in the list, in place\n     fn reverse() {\n         do self.check_out |v| {\n+            let mut v = move v;\n             vec::reverse(v);\n             self.give_back(move v);\n         }\n@@ -203,6 +216,7 @@ impl<A> DVec<A> {\n     /// Gives access to the vector as a slice with mutable contents\n     fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n         do self.check_out |v| {\n+            let mut v = move v;\n             let result = op(v);\n             self.give_back(move v);\n             move result\n@@ -268,7 +282,7 @@ impl<A: Copy> DVec<A> {\n     pure fn get() -> ~[A] {\n         unchecked {\n             do self.check_out |v| {\n-                let w = vec::from_mut(copy v);\n+                let w = copy v;\n                 self.give_back(move v);\n                 move w\n             }\n@@ -295,9 +309,9 @@ impl<A: Copy> DVec<A> {\n      */\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n         do self.swap |v| {\n-            let mut v <- v;\n+            let mut v = vec::to_mut(move v);\n             vec::grow_set(v, idx, initval, val);\n-            move v\n+            move vec::from_mut(v)\n         }\n     }\n "}, {"sha": "13fef207fac8f90f876d82bfc181980601d0b1fe", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -130,7 +130,7 @@ pure fn hash_keyed_5<A: IterBytes,\n     }\n }\n \n-pure fn hash_bytes_keyed(val: &[const u8], k0: u64, k1: u64) -> u64 {\n+pure fn hash_bytes_keyed(val: &[u8], k0: u64, k1: u64) -> u64 {\n     val.hash_keyed(k0, k1)\n }\n pure fn hash_str_keyed(val: &str, k0: u64, k1: u64) -> u64 {\n@@ -152,7 +152,7 @@ pure fn hash_uint_keyed(val: uint, k0: u64, k1: u64) -> u64 {\n     val.hash_keyed(k0, k1)\n }\n \n-pure fn hash_bytes(val: &[const u8]) -> u64 { hash_bytes_keyed(val, 0, 0) }\n+pure fn hash_bytes(val: &[u8]) -> u64 { hash_bytes_keyed(val, 0, 0) }\n pure fn hash_str(val: &str) -> u64 { hash_str_keyed(val, 0, 0) }\n pure fn hash_u64(val: u64) -> u64 { hash_u64_keyed(val, 0, 0) }\n pure fn hash_u32(val: u32) -> u64 { hash_u32_keyed(val, 0, 0) }"}, {"sha": "9d4176ea40b83bce7e4f322287064dfa8ac871b8", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -214,7 +214,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n \n impl *libc::FILE: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n-        do vec::as_buf(buf) |buf_p, buf_len| {\n+        do vec::as_mut_buf(buf) |buf_p, buf_len| {\n             assert buf_len <= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,"}, {"sha": "79ec6fea6680015cd01a650e0f38c7b4e346c2ba", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -2,6 +2,7 @@\n \n export addr_of;\n export to_unsafe_ptr;\n+export to_const_unsafe_ptr;\n export to_mut_unsafe_ptr;\n export mut_addr_of;\n export offset;\n@@ -26,11 +27,16 @@ use libc::{c_void, size_t};\n #[abi = \"cdecl\"]\n extern mod libc_ {\n     #[rust_stack]\n-    fn memcpy(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n+    fn memcpy(dest: *mut c_void, src: *const c_void,\n+              n: libc::size_t) -> *c_void;\n+\n     #[rust_stack]\n-    fn memmove(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n+    fn memmove(dest: *mut c_void, src: *const c_void,\n+               n: libc::size_t) -> *c_void;\n+\n     #[rust_stack]\n-    fn memset(dest: *c_void, c: libc::c_int, len: libc::size_t) -> *c_void;\n+    fn memset(dest: *mut c_void, c: libc::c_int,\n+              len: libc::size_t) -> *c_void;\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -105,9 +111,9 @@ pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may not overlap.\n  */\n #[inline(always)]\n-unsafe fn memcpy<T>(dst: *T, src: *T, count: uint) {\n+unsafe fn memcpy<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n-    libc_::memcpy(dst as *c_void, src as *c_void, n as size_t);\n+    libc_::memcpy(dst as *mut c_void, src as *c_void, n as size_t);\n }\n \n /**\n@@ -117,15 +123,15 @@ unsafe fn memcpy<T>(dst: *T, src: *T, count: uint) {\n  * and destination may overlap.\n  */\n #[inline(always)]\n-unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n+unsafe fn memmove<T>(dst: *mut T, src: *const T, count: uint)  {\n     let n = count * sys::size_of::<T>();\n-    libc_::memmove(dst as *c_void, src as *c_void, n as size_t);\n+    libc_::memmove(dst as *mut c_void, src as *c_void, n as size_t);\n }\n \n #[inline(always)]\n unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n     let n = count * sys::size_of::<T>();\n-    libc_::memset(dst as *c_void, c as libc::c_int, n as size_t);\n+    libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n \n \n@@ -135,8 +141,18 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_unsafe_ptr<T>(thing: &T) -> *T unsafe {\n-    unsafe::reinterpret_cast(&thing)\n+fn to_unsafe_ptr<T>(thing: &T) -> *T {\n+    unsafe { unsafe::reinterpret_cast(&thing) }\n+}\n+\n+/**\n+  Transform a const region pointer - &const T - to a const unsafe pointer -\n+  *const T. This is safe, but is implemented with an unsafe block due to\n+  reinterpret_cast.\n+*/\n+#[inline(always)]\n+fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n+    unsafe { unsafe::reinterpret_cast(&thing) }\n }\n \n /**\n@@ -145,8 +161,8 @@ fn to_unsafe_ptr<T>(thing: &T) -> *T unsafe {\n   reinterpret_cast.\n */\n #[inline(always)]\n-fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T unsafe {\n-    unsafe::reinterpret_cast(&thing)\n+fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n+    unsafe { unsafe::reinterpret_cast(&thing) }\n }\n \n /**\n@@ -246,16 +262,16 @@ fn test() {\n         assert (p.fst == 50);\n         assert (p.snd == 60);\n \n-        let v0 = ~[32000u16, 32001u16, 32002u16];\n-        let v1 = ~[0u16, 0u16, 0u16];\n+        let mut v0 = ~[32000u16, 32001u16, 32002u16];\n+        let mut v1 = ~[0u16, 0u16, 0u16];\n \n-        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 1u),\n+        ptr::memcpy(ptr::mut_offset(vec::unsafe::to_mut_ptr(v1), 1u),\n                     ptr::offset(vec::unsafe::to_ptr(v0), 1u), 1u);\n         assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(vec::unsafe::to_ptr(v1),\n+        ptr::memcpy(vec::unsafe::to_mut_ptr(v1),\n                     ptr::offset(vec::unsafe::to_ptr(v0), 2u), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n-        ptr::memcpy(ptr::offset(vec::unsafe::to_ptr(v1), 2u),\n+        ptr::memcpy(ptr::mut_offset(vec::unsafe::to_mut_ptr(v1), 2u),\n                     vec::unsafe::to_ptr(v0), 1u);\n         assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n     }"}, {"sha": "88858e2b1abc4f9c4adc405307ee1ebf9f08b77a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -250,6 +250,7 @@ fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n         do as_buf(lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n+                let dst = ::unsafe::transmute_mut_unsafe(dst);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n@@ -266,6 +267,7 @@ fn push_str(&lhs: ~str, rhs: &str) {\n         do as_buf(lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n+                let dst = ::unsafe::transmute_mut_unsafe(dst);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n@@ -1990,7 +1992,10 @@ mod unsafe {\n     unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n         let mut v: ~[mut u8] = ~[mut];\n         vec::reserve(v, len + 1u);\n-        vec::as_buf(v, |b, _len| ptr::memcpy(b, buf as *u8, len));\n+        vec::as_buf(v, |vbuf, _len| {\n+            let vbuf = ::unsafe::transmute_mut_unsafe(vbuf);\n+            ptr::memcpy(vbuf, buf as *u8, len)\n+        });\n         vec::unsafe::set_len(v, len);\n         vec::push(v, 0u8);\n \n@@ -2045,6 +2050,7 @@ mod unsafe {\n             vec::reserve(v, end - begin + 1u);\n             unsafe {\n                 do vec::as_buf(v) |vbuf, _vlen| {\n+                    let vbuf = ::unsafe::transmute_mut_unsafe(vbuf);\n                     let src = ptr::offset(sbuf, begin);\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }"}, {"sha": "337aa5980d7e02e1d85e6e57aa7cc6eef6b37130", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -7,12 +7,12 @@ use io::Writer;\n type Cb = fn(buf: &[const u8]) -> bool;\n \n trait IterBytes {\n-    fn iter_bytes(lsb0: bool, f: Cb);\n+    pure fn iter_bytes(lsb0: bool, f: Cb);\n }\n \n impl u8: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(_lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n         f([\n             self\n         ]);\n@@ -21,7 +21,7 @@ impl u8: IterBytes {\n \n impl u16: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 self as u8,\n@@ -38,7 +38,7 @@ impl u16: IterBytes {\n \n impl u32: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 self as u8,\n@@ -59,7 +59,7 @@ impl u32: IterBytes {\n \n impl u64: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         if lsb0 {\n             f([\n                 self as u8,\n@@ -88,58 +88,65 @@ impl u64: IterBytes {\n \n impl i8: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n impl i16: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u16).iter_bytes(lsb0, f)\n     }\n }\n \n impl i32: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n impl i64: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n+impl char: IterBytes {\n+    #[inline(always)]\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n+        (self as u32).iter_bytes(lsb0, f)\n+    }\n+}\n+\n #[cfg(target_word_size = \"32\")]\n impl uint: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u32).iter_bytes(lsb0, f)\n     }\n }\n \n #[cfg(target_word_size = \"64\")]\n impl uint: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as u64).iter_bytes(lsb0, f)\n     }\n }\n \n impl int: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n-impl<A: IterBytes> &[const A]: IterBytes {\n+impl<A: IterBytes> &[A]: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         for self.each |elt| {\n             do elt.iter_bytes(lsb0) |bytes| {\n                 f(bytes)\n@@ -149,34 +156,34 @@ impl<A: IterBytes> &[const A]: IterBytes {\n }\n \n // Move this to vec, probably.\n-fn borrow<A>(a: &x/[const A]) -> &x/[const A] {\n+pure fn borrow<A>(a: &x/[A]) -> &x/[A] {\n     a\n }\n \n-impl<A: IterBytes> ~[const A]: IterBytes {\n+impl<A: IterBytes> ~[A]: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         borrow(self).iter_bytes(lsb0, f)\n     }\n }\n \n \n-impl<A: IterBytes> @[const A]: IterBytes {\n+impl<A: IterBytes> @[A]: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         borrow(self).iter_bytes(lsb0, f)\n     }\n }\n \n-fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n+pure fn iter_bytes_2<A: IterBytes, B: IterBytes>(a: &A, b: &B,\n                                             lsb0: bool, z: Cb) {\n     let mut flag = true;\n     a.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n     if !flag { return; }\n     b.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_bytes_3<A: IterBytes,\n+pure fn iter_bytes_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C,\n                               lsb0: bool, z: Cb) {\n@@ -188,7 +195,7 @@ fn iter_bytes_3<A: IterBytes,\n     c.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_bytes_4<A: IterBytes,\n+pure fn iter_bytes_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C,\n@@ -204,7 +211,7 @@ fn iter_bytes_4<A: IterBytes,\n     d.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_bytes_5<A: IterBytes,\n+pure fn iter_bytes_5<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -223,7 +230,7 @@ fn iter_bytes_5<A: IterBytes,\n     e.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_bytes_6<A: IterBytes,\n+pure fn iter_bytes_6<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -245,7 +252,7 @@ fn iter_bytes_6<A: IterBytes,\n     f.iter_bytes(lsb0, |bytes| {flag = z(bytes); flag});\n }\n \n-fn iter_bytes_7<A: IterBytes,\n+pure fn iter_bytes_7<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes,\n@@ -273,7 +280,7 @@ fn iter_bytes_7<A: IterBytes,\n \n impl &str: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(_lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n@@ -282,7 +289,7 @@ impl &str: IterBytes {\n \n impl ~str: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(_lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n@@ -291,7 +298,7 @@ impl ~str: IterBytes {\n \n impl @str: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(_lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(_lsb0: bool, f: Cb) {\n         do str::byte_slice(self) |bytes| {\n             f(bytes);\n         }\n@@ -300,7 +307,7 @@ impl @str: IterBytes {\n \n impl<A: IterBytes> Option<A>: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         match self {\n           Some(a) => iter_bytes_2(&0u8, &a, lsb0, f),\n           None => 1u8.iter_bytes(lsb0, f)\n@@ -310,30 +317,30 @@ impl<A: IterBytes> Option<A>: IterBytes {\n \n impl<A: IterBytes> &A: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A: IterBytes> @A: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n impl<A: IterBytes> ~A: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (*self).iter_bytes(lsb0, f);\n     }\n }\n \n // NB: raw-pointer IterBytes does _not_ dereference\n // to the target; it just gives you the pointer-bytes.\n-impl<A> *A: IterBytes {\n+impl<A> *const A: IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: Cb) {\n         (self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "8875fc1d0ea94e85ef827a55ccfc8bbb226c9cd0", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -2,6 +2,7 @@\n \n export reinterpret_cast, forget, bump_box_refcount, transmute;\n export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n+export transmute_mut_unsafe, transmute_immut_unsafe;\n \n export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n export get_shared_mutable_state, get_shared_immutable_state;\n@@ -68,6 +69,12 @@ unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T { transmute(move ptr) }\n /// Coerce a borrowed pointer to have an arbitrary associated region.\n unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(move ptr) }\n \n+/// Coerce an immutable reference to be mutable.\n+unsafe fn transmute_mut_unsafe<T>(+ptr: *const T) -> *mut T { transmute(ptr) }\n+\n+/// Coerce an immutable reference to be mutable.\n+unsafe fn transmute_immut_unsafe<T>(+ptr: *const T) -> *T { transmute(ptr) }\n+\n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n     transmute(move ptr)\n@@ -78,6 +85,11 @@ unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n     transmute_region(ptr)\n }\n \n+/// Transforms lifetime of the second pointer to match the first.\n+unsafe fn copy_lifetime_to_unsafe<S,T>(_ptr: &a/S, +ptr: *T) -> &a/T {\n+    transmute(ptr)\n+}\n+\n \n /****************************************************************************\n  * Shared state & exclusive ARC"}, {"sha": "62cc5ce6f609032e4f94c99191ef18961b0e9d04", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 98, "deletions": 43, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -77,7 +77,7 @@ export swap;\n export reverse;\n export reversed;\n export iter, iter_between, each, eachi, reach, reachi;\n-export each_mut, each_const;\n+export each_ref, each_mut_ref, each_const_ref;\n export iter2;\n export iteri;\n export riter;\n@@ -336,7 +336,8 @@ pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n     do as_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n-                &(ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n+                &(ptr::offset(p, start),\n+                  (end - start) * sys::size_of::<T>()))\n         }\n     }\n }\n@@ -345,10 +346,11 @@ pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do as_buf(v) |p, _len| {\n+    do as_mut_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n-                &(ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n+                &(ptr::mut_offset(p, start),\n+                  (end - start) * sys::size_of::<T>()))\n         }\n     }\n }\n@@ -357,10 +359,11 @@ pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do as_buf(v) |p, _len| {\n+    do as_const_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n-                &(ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n+                &(ptr::const_offset(p, start),\n+                  (end - start) * sys::size_of::<T>()))\n         }\n     }\n }\n@@ -1141,7 +1144,7 @@ fn swap<T>(v: &[mut T], a: uint, b: uint) {\n }\n \n /// Reverse the order of elements in a vector, in place\n-fn reverse<T>(v: ~[mut T]) {\n+fn reverse<T>(v: &[mut T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n@@ -1203,7 +1206,12 @@ pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n+pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n+    //             ^^^^\n+    // NB---this CANNOT be &[const T]!  The reason\n+    // is that you are passing it to `f()` using\n+    // an immutable.\n+\n     do vec::as_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n@@ -1217,21 +1225,52 @@ pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n     }\n }\n \n+/**\n+ * Iterates over a vector, with option to break\n+ *\n+ * Return true to continue, false to break.\n+ */\n+#[inline(always)]\n+pure fn each_ref<T>(v: &r/[T], f: fn(v: &r/T) -> bool) {\n+    // this is not the most efficient impl, as it repeats the bound checks,\n+    // but it's good enough\n+    let mut i = 0;\n+    let n = v.len();\n+    while i < n {\n+        if !f(&v[i]) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n /// Like `each()`, but for the case where you have\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pure fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n-    do vec::as_mut_buf(v) |p, n| {\n-        let mut n = n;\n-        let mut p = p;\n-        while n > 0u {\n-            unsafe {\n-                if !f(&mut *p) { break; }\n-                p = ptr::mut_offset(p, 1u);\n-            }\n-            n -= 1u;\n+fn each_mut_ref<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+    let mut i = 0;\n+    let n = v.len();\n+    while i < n {\n+        if !f(&mut v[i]) {\n+            return;\n+        }\n+        i += 1;\n+    }\n+}\n+\n+/// Like `each()`, but for the case where you have\n+/// a vector with mutable contents and you would like\n+/// to mutate the contents as you iterate.\n+#[inline(always)]\n+pure fn each_const_ref<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+    let mut i = 0;\n+    let n = v.len();\n+    while i < n {\n+        if !f(&const v[i]) {\n+            return;\n         }\n+        i += 1;\n     }\n }\n \n@@ -1241,7 +1280,7 @@ pure fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n+pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n     do vec::as_buf(v) |p, n| {\n         let mut i = 0u;\n         let mut p = p;\n@@ -1392,10 +1431,18 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * foreign interop.\n  */\n #[inline(always)]\n-pure fn as_buf<T,U>(s: &[const T],\n+pure fn as_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n                     f: fn(*T, uint) -> U) -> U {\n+\n+    // NB---People keep changing the type of s to `&[const T]`.  This is\n+    // unsound.  The reason is that we are going to create immutable pointers\n+    // into `s` and pass them to `f()`, but in fact they are potentially\n+    // pointing at *mutable memory*.  Use `as_const_buf` or `as_mut_buf`\n+    // instead!\n+\n     unsafe {\n-        let v : *(*T,uint) = ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let v : *(*T,uint) =\n+            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n@@ -1405,23 +1452,25 @@ pure fn as_buf<T,U>(s: &[const T],\n #[inline(always)]\n pure fn as_const_buf<T,U>(s: &[const T],\n                           f: fn(*const T, uint) -> U) -> U {\n-    do as_buf(s) |p, len| {\n-        unsafe {\n-            let pp : *const T = ::unsafe::reinterpret_cast(&p);\n-            f(pp, len)\n-        }\n+\n+    unsafe {\n+        let v : *(*const T,uint) =\n+            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n     }\n }\n \n /// Similar to `as_buf` but passing a `*mut T`\n #[inline(always)]\n pure fn as_mut_buf<T,U>(s: &[mut T],\n                         f: fn(*mut T, uint) -> U) -> U {\n-    do as_buf(s) |p, len| {\n-        unsafe {\n-            let pp : *mut T = ::unsafe::reinterpret_cast(&p);\n-            f(pp, len)\n-        }\n+\n+    unsafe {\n+        let v : *(*mut T,uint) =\n+            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let (buf,len) = *v;\n+        f(buf, len / sys::size_of::<T>())\n     }\n }\n \n@@ -1765,7 +1814,7 @@ mod unsafe {\n         let mut dst = ~[];\n         reserve(dst, elts);\n         set_len(dst, elts);\n-        as_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n+        as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n         move dst\n     }\n \n@@ -1792,18 +1841,24 @@ mod unsafe {\n      * would also make any pointers to it invalid.\n      */\n     #[inline(always)]\n-    unsafe fn to_ptr<T>(v: ~[const T]) -> *T {\n-        let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+    unsafe fn to_ptr<T>(v: &[T]) -> *T {\n+        let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n-\n+    /** see `to_ptr()` */\n     #[inline(always)]\n-    unsafe fn to_ptr_slice<T>(v: &[const T]) -> *T {\n+    unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n         let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n+    /** see `to_ptr()` */\n+    #[inline(always)]\n+    unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n+        let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n+    }\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n@@ -1822,7 +1877,7 @@ mod unsafe {\n      */\n     #[inline(always)]\n     unsafe fn get<T: Copy>(v: &[const T], i: uint) -> T {\n-        as_buf(v, |p, _len| *ptr::offset(p, i))\n+        as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n     }\n \n     /**\n@@ -1846,8 +1901,8 @@ mod unsafe {\n       * may overlap.\n       */\n     unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n-        do as_buf(dst) |p_dst, _len_dst| {\n-            do as_buf(src) |p_src, _len_src| {\n+        do as_mut_buf(dst) |p_dst, _len_dst| {\n+            do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memcpy(p_dst, p_src, count)\n             }\n         }\n@@ -1860,8 +1915,8 @@ mod unsafe {\n       * may overlap.\n       */\n     unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n-        do as_buf(dst) |p_dst, _len_dst| {\n-            do as_buf(src) |p_src, _len_src| {\n+        do as_mut_buf(dst) |p_dst, _len_dst| {\n+            do as_const_buf(src) |p_src, _len_src| {\n                 ptr::memmove(p_dst, p_src, count)\n             }\n         }\n@@ -1952,12 +2007,12 @@ mod u8 {\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n \n-impl<A> &[const A]: iter::BaseIter<A> {\n+impl<A> &[A]: iter::BaseIter<A> {\n     pure fn each(blk: fn(A) -> bool) { each(self, blk) }\n     pure fn size_hint() -> Option<uint> { Some(len(self)) }\n }\n \n-impl<A> &[const A]: iter::ExtendedIter<A> {\n+impl<A> &[A]: iter::ExtendedIter<A> {\n     pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }"}, {"sha": "173348d8dcabf9ca6dfada2cd97be61c1170eff7", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -89,7 +89,7 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: Chunk) {\n     let mut idx = 0;\n-    let buf = vec::unsafe::to_ptr_slice(chunk.data);\n+    let buf = vec::unsafe::to_ptr(chunk.data);\n     let fill = chunk.fill;\n \n     while idx < fill {\n@@ -156,7 +156,7 @@ impl &Arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            ptr::offset(vec::unsafe::to_ptr_slice(head.data), start)\n+            ptr::offset(vec::unsafe::to_ptr(head.data), start)\n         }\n     }\n \n@@ -200,7 +200,7 @@ impl &Arena {\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n-            let buf = vec::unsafe::to_ptr_slice(head.data);\n+            let buf = vec::unsafe::to_ptr(head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }"}, {"sha": "920b969eea9cff3381aaea1785fd485f40c92329", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -57,7 +57,7 @@ fn create<T: Copy>() -> Deque<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, move v));\n+                self.elts.swap_mut(|v| grow(self.nelts, oldlo, move v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -66,7 +66,7 @@ fn create<T: Copy>() -> Deque<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n+                self.elts.swap_mut(|v| grow(self.nelts, self.lo, move v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }\n@@ -108,8 +108,7 @@ fn create<T: Copy>() -> Deque<T> {\n         mut hi: 0u,\n         elts:\n             dvec::from_vec(\n-                vec::to_mut(\n-                    vec::from_elem(initial_capacity, None)))\n+                vec::from_elem(initial_capacity, None))\n     };\n     (move repr) as Deque::<T>\n }"}, {"sha": "182c1d61bc050a05485e242961beeaccbf34453d", "filename": "src/libstd/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -646,12 +646,12 @@ pure fn lt(value0: Json, value1: Json) -> bool {\n                         let (d0_flat, d1_flat) = {\n                             let d0_flat = dvec::DVec();\n                             for d0.each |k, v| { d0_flat.push((k, v)); }\n-                            let d0_flat = dvec::unwrap(move d0_flat);\n+                            let mut d0_flat = dvec::unwrap(move d0_flat);\n                             d0_flat.qsort();\n \n                             let mut d1_flat = dvec::DVec();\n                             for d1.each |k, v| { d1_flat.push((k, v)); }\n-                            let d1_flat = dvec::unwrap(move d1_flat);\n+                            let mut d1_flat = dvec::unwrap(move d1_flat);\n                             d1_flat.qsort();\n \n                             (move d0_flat, move d1_flat)"}, {"sha": "0e422aa1eeb990efd09177e53e99463557bdf2f2", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -736,8 +736,8 @@ impl Url: Eq {\n }\n \n impl Url: IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n-        self.to_str().iter_bytes(lsb0, f)\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+        unchecked { self.to_str() }.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -1077,11 +1077,11 @@ mod tests {\n         assert encode_form_urlencoded(m) == ~\"\";\n \n         let m = str_hash();\n-        m.insert(~\"foo\", @dvec::from_vec(~[mut @~\"bar\", @~\"123\"]));\n+        m.insert(~\"foo\", @dvec::from_vec(~[@~\"bar\", @~\"123\"]));\n         assert encode_form_urlencoded(m) == ~\"foo=bar&foo=123\";\n \n         let m = str_hash();\n-        m.insert(~\"foo bar\", @dvec::from_vec(~[mut @~\"abc\", @~\"12 = 34\"]));\n+        m.insert(~\"foo bar\", @dvec::from_vec(~[@~\"abc\", @~\"12 = 34\"]));\n         assert encode_form_urlencoded(m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n     }\n "}, {"sha": "15c1c160ed13631c41884b35a0e08bd5779ac929", "filename": "src/libstd/set.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fset.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -0,0 +1,62 @@\n+import dvec::dvec;\n+import map::{hashfn, eqfn, hashmap};\n+\n+struct set<K: copy> {\n+    mut implementation: option<set_implementation<K>>\n+}\n+\n+struct list_set<K> {\n+    hasher: hashfn<K>;\n+    eqer: eqfn<K>;\n+    elements: ~[K];\n+}\n+\n+enum set_implementation<K: copy> {\n+    impl_with_list(list_set<K>),\n+    impl_with_map(hashmap<K, ()>)\n+}\n+\n+const threshold: uint = 25; // completely arbitrary.\n+\n+impl<K> &list_set {\n+    pure fn contains(element: &K) {\n+        for self.elements.each |existing_element| {\n+            if self.eqer(element, existing_element) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    pure fn convert_to_map() -> hashmap<K, ()> {\n+        ...\n+    }\n+}\n+\n+impl<K: copy> set<K> {\n+    fn add(+element: K) -> bool {\n+        let mut set_impl = option::swap_unwrap(&mut self.implementation);\n+        let contained_before = match set_impl {\n+          impl_with_list(ref mut list_set) => {\n+            if list_set.elements.len() >= threshold {\n+                // convert to a map\n+                self.implementation = some(list_set.convert_to_map());\n+                return self.add(move element);\n+            }\n+\n+            if list_set.contains(&element) {\n+                false\n+            } else {\n+                vec::push(list_set.elements, element);\n+                true\n+            }\n+          }\n+\n+          impl_with_map(ref map) => {\n+            let contained_before = map.insert(element, ());\n+          }\n+        }\n+        self.implementation = some(move set_impl);\n+        return true;\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9808b15dc66f2d6afec8fc586661f1d626c357bc", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -161,7 +161,7 @@ fn sha1() -> Sha1 {\n     fn mk_result(st: &Sha1State) -> ~[u8] {\n         if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each_mut((*st).h) |ptr_hpart| {\n+        for vec::each_mut_ref((*st).h) |ptr_hpart| {\n             let hpart = *ptr_hpart;\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;"}, {"sha": "1cb4adac45cba53ab92cb3bc04b9d8d668879627", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -92,7 +92,7 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n         old.is_some()\n     }\n     fn clear() {\n-        self.v.set(~[mut]);\n+        self.v.set(~[]);\n     }\n     fn contains_key(+key: uint) -> bool {\n         contains_key(self, key)"}, {"sha": "38eccd3593f5153c9192db1ef77202da5cef6266", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -311,7 +311,7 @@ enum binding_mode {\n }\n \n impl binding_mode : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           bind_by_value => 0u8.iter_bytes(lsb0, f),\n \n@@ -385,7 +385,7 @@ enum pat_ {\n enum mutability { m_mutbl, m_imm, m_const, }\n \n impl mutability : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -524,7 +524,7 @@ enum inferable<T> {\n }\n \n impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           expl(ref t) =>\n           to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n@@ -560,7 +560,7 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n enum rmode { by_ref, by_val, by_mutbl_ref, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -922,7 +922,7 @@ enum trait_method {\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl int_ty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -951,7 +951,7 @@ impl int_ty: cmp::Eq {\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl uint_ty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -978,7 +978,7 @@ impl uint_ty: cmp::Eq {\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl float_ty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1082,7 +1082,7 @@ impl ty : cmp::Eq {\n }\n \n impl ty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n@@ -1106,7 +1106,7 @@ enum purity {\n }\n \n impl purity : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1126,7 +1126,7 @@ enum ret_style {\n }\n \n impl ret_style : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1423,7 +1423,7 @@ enum item_ {\n enum class_mutability { class_mutable, class_immutable }\n \n impl class_mutability : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "6140014d848adba91b6fdd82911b6153a5d197f7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -254,7 +254,7 @@ pure fn is_call_expr(e: @expr) -> bool {\n // This makes def_id hashable\n impl def_id : core::to_bytes::IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: core::to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: core::to_bytes::Cb) {\n         core::to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }"}, {"sha": "d97124d5f44123800b682e1acd74d39111ec9863", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -127,7 +127,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n         pure fn by_lo(a: &gather_item, b: &gather_item) -> bool {\n             a.lo < b.lo\n         }\n-        vec::to_mut(std::sort::merge_sort(by_lo, v))\n+        std::sort::merge_sort(by_lo, v)\n     };\n     return cx;\n }"}, {"sha": "5b0fd67ae5032de904d1b13724fde37620625f24", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -35,7 +35,7 @@ impl ObsoleteSyntax : cmp::Eq {\n \n impl ObsoleteSyntax: to_bytes::IterBytes {\n     #[inline(always)]\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "1089431d810f3747c75e811fedeeb5a138eba96e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -3556,8 +3556,8 @@ impl parser {\n         }\n \n         {attrs_remaining: attrs,\n-         view_items: vec::from_mut(dvec::unwrap(move view_items)),\n-         items: vec::from_mut(dvec::unwrap(move items))}\n+         view_items: dvec::unwrap(move view_items),\n+         items: dvec::unwrap(move items)}\n     }\n \n     // Parses a source module as a crate"}, {"sha": "e7b9cdb5d3576c4d55e849f37d36f4d3c9be8a8b", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -951,7 +951,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let ids = val_dsr.read_to_vec(|| {\n                     xcx.tr_id(val_dsr.read_int())\n                 });\n-                let dvec = @dvec::from_vec(vec::to_mut(ids));\n+                let dvec = @dvec::from_vec(move ids);\n                 dcx.maps.last_use_map.insert(id, dvec);\n             } else if tag == (c::tag_table_method_map as uint) {\n                 dcx.maps.method_map.insert("}, {"sha": "f43c4dbba677e21aa1e6165cea4d57313050d9fa", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -415,7 +415,7 @@ impl root_map_key : cmp::Eq {\n }\n \n impl root_map_key : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }"}, {"sha": "f5552515142e2666908f1c9616d6426a42fd3849", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -408,7 +408,7 @@ impl gather_loan_ctxt {\n             }\n             None => {\n                 self.req_maps.req_loan_map.insert(\n-                    scope_id, @dvec::from_vec(~[mut loans]));\n+                    scope_id, @dvec::from_vec(~[loans]));\n             }\n         }\n     }"}, {"sha": "98da65324e861d8c1f01c506f3ced485eed1638b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -285,7 +285,7 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n             }\n         }\n     }\n-    return vec::from_mut(dvec::unwrap(move found));\n+    return dvec::unwrap(move found);\n }\n \n fn extract_variant_args(bcx: block, pat_id: ast::node_id,"}, {"sha": "ab108f5ef55963b5ec2af0471b427a72d839e342", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -446,7 +446,7 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n     unsafe {\n         count_insn(cx, \"inboundsgep\");\n     return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n-                                       vec::unsafe::to_ptr_slice(Indices),\n+                                       vec::unsafe::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n                                        noname());\n     }"}, {"sha": "9d0579fa88fad723801453688189a8a929f018ac", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -1133,7 +1133,7 @@ impl mono_id_: cmp::Eq {\n }\n \n impl mono_param_id : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           mono_precise(t, mids) =>\n           to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), &mids, lsb0, f),\n@@ -1147,7 +1147,7 @@ impl mono_param_id : to_bytes::IterBytes {\n }\n \n impl mono_id_ : core::to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }"}, {"sha": "b40afb6dd443b42c24b4ea0b45862d9ff1c75df7", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -43,7 +43,7 @@ impl nominal_id_ : core::cmp::Eq {\n }\n \n impl nominal_id_ : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.did, &self.parent_id, lsb0, f);\n         for self.tps.each |t| {\n             ty::type_id(t).iter_bytes(lsb0, f);"}, {"sha": "0975c8f4d8ae31c01b0474d5578498175eb1de76", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -118,7 +118,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each_mut(cx.uses) |u| {\n+    for vec::each_mut_ref(cx.uses) |u| {\n         if *u & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;"}, {"sha": "a1307d70972c6af19ed8dddda6f6d257ac0a6e36", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -247,7 +247,7 @@ impl creader_cache_key : cmp::Eq {\n }\n \n impl creader_cache_key : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n@@ -262,7 +262,7 @@ impl intern_key: cmp::Eq {\n }\n \n impl intern_key : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.sty, &self.o_def_id, lsb0, f);\n     }\n }\n@@ -404,7 +404,7 @@ enum closure_kind {\n }\n \n impl closure_kind : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -422,7 +422,7 @@ enum fn_proto {\n }\n \n impl fn_proto : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           proto_bare =>\n           0u8.iter_bytes(lsb0, f),\n@@ -500,7 +500,7 @@ impl param_ty: cmp::Eq {\n }\n \n impl param_ty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n     }\n }\n@@ -674,7 +674,7 @@ enum InferTy {\n }\n \n impl InferTy : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f)\n@@ -683,7 +683,7 @@ impl InferTy : to_bytes::IterBytes {\n }\n \n impl param_bound : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           bound_copy => 0u8.iter_bytes(lsb0, f),\n           bound_owned => 1u8.iter_bytes(lsb0, f),\n@@ -747,25 +747,25 @@ impl purity: purity_to_str {\n }\n \n impl RegionVid : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl TyVid : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl IntVid : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n \n impl FnVid : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n     }\n }\n@@ -2432,7 +2432,7 @@ fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n }\n \n impl bound_region : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           ty::br_self => 0u8.iter_bytes(lsb0, f),\n \n@@ -2449,7 +2449,7 @@ impl bound_region : to_bytes::IterBytes {\n }\n \n impl region : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           re_bound(ref br) =>\n           to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n@@ -2469,7 +2469,7 @@ impl region : to_bytes::IterBytes {\n }\n \n impl vstore : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           vstore_fixed(ref u) =>\n           to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n@@ -2484,36 +2484,36 @@ impl vstore : to_bytes::IterBytes {\n }\n \n impl substs : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n \n impl mt : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n impl field : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n impl arg : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.mode,\n                                  &self.ty, lsb0, f)\n     }\n }\n \n impl sty : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           ty_nil => 0u8.iter_bytes(lsb0, f),\n           ty_bool => 1u8.iter_bytes(lsb0, f),"}, {"sha": "eba683750fc7c39e3c0236f7846ac047bf9ab56a", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -350,7 +350,7 @@ impl Constraint: cmp::Eq {\n }\n \n impl Constraint : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+   pure  fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -377,7 +377,7 @@ impl TwoRegions: cmp::Eq {\n }\n \n impl TwoRegions : to_bytes::IterBytes {\n-    fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }"}, {"sha": "087a37ecae2635c25791d6f03b2fb34667884896", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -12,7 +12,7 @@ fn collect_raw(num: uint) -> ~[uint] {\n     return result;\n }\n \n-fn collect_dvec(num: uint) -> ~[mut uint] {\n+fn collect_dvec(num: uint) -> ~[uint] {\n     let result = DVec();\n     for uint::range(0u, num) |i| {\n         result.push(i);\n@@ -43,7 +43,7 @@ fn main(args: ~[~str]) {\n \n     let raw = mid - start;\n     let dvec = end - mid;\n-    \n+\n     let maxf = max as float;\n     let rawf = raw as float;\n     let dvecf = dvec as float;"}, {"sha": "f4ccd901fb3aacf902e882eda82d4548eea3db44", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -5,11 +5,11 @@ type parser = {\n };\n \n trait parse {\n-    fn parse() -> ~[mut int];\n+    fn parse() -> ~[int];\n }\n \n impl parser: parse {\n-    fn parse() -> ~[mut int] {\n+    fn parse() -> ~[int] {\n         dvec::unwrap(move self.tokens) //~ ERROR illegal move from self\n     }\n }"}, {"sha": "6d9c525481be4606a72dcbfaf650122d39d6da22", "filename": "src/test/run-pass/dvec-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -5,7 +5,7 @@ fn main() {\n     d.push(3);\n     d.push(4);\n     assert d.get() == ~[3, 4];\n-    d.set(~[mut 5]);\n+    d.set(~[5]);\n     d.push(6);\n     d.push(7);\n     d.push(8);\n@@ -23,6 +23,6 @@ fn main() {\n         assert e == exp[i];\n     }\n \n-    let v = vec::from_mut(dvec::unwrap(move d));\n+    let v = dvec::unwrap(move d);\n     assert v == exp;\n }"}, {"sha": "d6a0c1d34c6c030aa61e2365dd84575c22f3b5fa", "filename": "src/test/run-pass/issue-2631-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d540de76993eb6dac9893138e45d0324c23e631/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2631-b.rs?ref=5d540de76993eb6dac9893138e45d0324c23e631", "patch": "@@ -9,7 +9,7 @@ use std::map::*;\n use std::map::str_hash;\n \n fn main() {\n-  let v = ~[mut @~\"hi\"];\n+  let v = ~[@~\"hi\"];\n   let m: req::header_map = str_hash();\n   m.insert(~\"METHOD\", @dvec::from_vec(v));\n   request::<int>(m);"}]}