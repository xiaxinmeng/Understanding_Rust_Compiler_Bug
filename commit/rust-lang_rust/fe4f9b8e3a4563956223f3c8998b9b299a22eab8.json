{"sha": "fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNGY5YjhlM2E0NTYzOTU2MjIzZjNjODk5OGI5YjI5OWEyMmVhYjg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-11T07:33:49Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:01Z"}, "message": "Use partial path resolutions in expressions for UFCS desugaring.", "tree": {"sha": "d12aa9009b6a2725e7d3241999431adbff2c376e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d12aa9009b6a2725e7d3241999431adbff2c376e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "html_url": "https://github.com/rust-lang/rust/commit/fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a3054f55c48682d1458176863e0ccb08d505aa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3054f55c48682d1458176863e0ccb08d505aa8", "html_url": "https://github.com/rust-lang/rust/commit/7a3054f55c48682d1458176863e0ccb08d505aa8"}], "stats": {"total": 600, "additions": 387, "deletions": 213}, "files": [{"sha": "1cd5a19d6788a2435558b918d17f2de5e44d26d0", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -17,37 +17,36 @@\n use middle::def;\n use middle::ty::{self, Ty};\n use syntax::ast;\n-use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub const NO_REGIONS: uint = 1;\n pub const NO_TPS: uint = 2;\n \n-pub fn check_path_args(tcx: &ty::ctxt,\n-                       span: Span,\n-                       segments: &[ast::PathSegment],\n-                       flags: uint) {\n-    if (flags & NO_TPS) != 0 {\n-        if segments.iter().any(|s| s.parameters.has_types()) {\n-            span_err!(tcx.sess, span, E0109,\n-                \"type parameters are not allowed on this type\");\n+pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: uint) {\n+    for segment in segments {\n+        if (flags & NO_TPS) != 0 {\n+            for typ in segment.parameters.types() {\n+                span_err!(tcx.sess, typ.span, E0109,\n+                          \"type parameters are not allowed on this type\");\n+                break;\n+            }\n         }\n-    }\n \n-    if (flags & NO_REGIONS) != 0 {\n-        if segments.iter().any(|s| s.parameters.has_lifetimes()) {\n-            span_err!(tcx.sess, span, E0110,\n-                \"lifetime parameters are not allowed on this type\");\n+        if (flags & NO_REGIONS) != 0 {\n+            for lifetime in segment.parameters.lifetimes() {\n+                span_err!(tcx.sess, lifetime.span, E0110,\n+                          \"lifetime parameters are not allowed on this type\");\n+                break;\n+            }\n         }\n     }\n }\n \n pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                           span: Span,\n                            segments: &[ast::PathSegment],\n                            nty: ast::PrimTy)\n                            -> Ty<'tcx> {\n-    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n+    check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n     match nty {\n         ast::TyBool => tcx.types.bool,\n         ast::TyChar => tcx.types.char,\n@@ -69,7 +68,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             Some(&d) => d\n         };\n         if let def::DefPrimTy(nty) = def {\n-            Some(prim_ty_to_ty(tcx, path.span, &path.segments[], nty))\n+            Some(prim_ty_to_ty(tcx, &path.segments[], nty))\n         } else {\n             None\n         }"}, {"sha": "0c5236101cfb862e4ae915ae0550e1a2be9d97b7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -3018,7 +3018,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n-        for type_parameter in &generics.ty_params {\n+        for type_parameter in &*generics.ty_params {\n             self.check_if_primitive_type_name(type_parameter.ident.name, type_parameter.span);\n         }\n         for predicate in &generics.where_clause.predicates {\n@@ -4083,16 +4083,35 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // multiple elements in it or not.\n \n             ExprPath(ref path) | ExprQPath(ast::QPath { ref path, .. }) => {\n-                if let ExprQPath(_) = expr.node {\n+                let max_assoc_types = if let ExprQPath(_) = expr.node {\n                     // Make sure the trait is valid.\n                     let _ = self.resolve_trait_reference(expr.id, path, 1);\n+                    1\n+                } else {\n+                    path.segments.len()\n+                };\n+\n+                let mut result = self.with_no_errors(|this| {\n+                    this.resolve_path(expr.id, path, 0, ValueNS, true)\n+                });\n+                for depth in 1..max_assoc_types {\n+                    if result.is_some() {\n+                        break;\n+                    }\n+                    self.with_no_errors(|this| {\n+                        result = this.resolve_path(expr.id, path, depth, TypeNS, true);\n+                    });\n+                }\n+                if let Some((DefMod(_), _, _)) = result {\n+                    // A module is not a valid type or value.\n+                    result = None;\n                 }\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-                match self.resolve_path(expr.id, path, 0, ValueNS, true) {\n+                match result {\n                     // Check if struct variant\n-                    Some((DefVariant(_, _, true), _, _)) => {\n+                    Some((DefVariant(_, _, true), _, 0)) => {\n                         let path_name = self.path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n@@ -4110,6 +4129,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         debug!(\"(resolving expr) resolved `{}`\",\n                                self.path_names_to_string(path, 0));\n \n+                        // Partial resolutions will need the set of traits in scope,\n+                        // so they can be completed during typeck.\n+                        if def.2 != 0 {\n+                            let method_name = path.segments.last().unwrap().identifier.name;\n+                            let traits = self.search_for_traits_containing_method(method_name);\n+                            self.trait_map.insert(expr.id, traits);\n+                        }\n+\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n@@ -4135,6 +4162,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             }\n                             _ => {\n+                                // Keep reporting some errors even if they're ignored above.\n+                                self.resolve_path(expr.id, path, 0, ValueNS, true);\n+\n                                 let mut method_scope = false;\n                                 self.value_ribs.iter().rev().all(|rib| {\n                                     method_scope = match rib.kind {"}, {"sha": "adbc4d546f1903ba30ee201462f6ecf866de6b06", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 135, "deletions": 88, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -246,6 +246,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n+    param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n     item_segment: &ast::PathSegment)\n     -> Substs<'tcx>\n@@ -265,25 +266,34 @@ pub fn ast_path_substs_for_ty<'tcx>(\n \n     let (regions, types, assoc_bindings) = match item_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            convert_angle_bracketed_parameters(this, rscope, path.span, decl_generics, data)\n+            convert_angle_bracketed_parameters(this, rscope, span, decl_generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n-            convert_parenthesized_parameters(this, rscope, path.span, decl_generics, data)\n+            convert_parenthesized_parameters(this, rscope, span, decl_generics, data)\n         }\n     };\n \n     prohibit_projections(this.tcx(), &assoc_bindings);\n \n     create_substs_for_ast_path(this,\n                                span,\n+                               param_mode,\n                                decl_generics,\n                                None,\n                                types,\n                                regions)\n }\n \n+#[derive(PartialEq, Eq)]\n+pub enum PathParamMode {\n+    // Any path in a type context.\n+    Explicit,\n+    // The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n fn create_region_substs<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n@@ -331,6 +341,7 @@ fn create_region_substs<'tcx>(\n fn create_substs_for_ast_path<'tcx>(\n     this: &AstConv<'tcx>,\n     span: Span,\n+    param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types_provided: Vec<Ty<'tcx>>,\n@@ -349,13 +360,21 @@ fn create_substs_for_ast_path<'tcx>(\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = types_provided.len();\n     let formal_ty_param_count = ty_param_defs.len();\n     let required_ty_param_count = ty_param_defs.iter()\n                                                .take_while(|x| x.default.is_none())\n                                                .count();\n \n-    let mut type_substs = types_provided;\n+    // Fill with `ty_infer` if no params were specified, as long as\n+    // they were optional (e.g. paths inside expressions).\n+    let mut type_substs = if param_mode == PathParamMode::Optional &&\n+                             types_provided.is_empty() {\n+        (0..formal_ty_param_count).map(|_| this.ty_infer(span)).collect()\n+    } else {\n+        types_provided\n+    };\n+\n+    let supplied_ty_param_count = type_substs.len();\n     check_type_argument_count(this.tcx(), span, supplied_ty_param_count,\n                               required_ty_param_count, formal_ty_param_count);\n \n@@ -415,7 +434,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    return substs;\n+    substs\n }\n \n struct ConvertedBinding<'tcx> {\n@@ -607,6 +626,7 @@ pub fn instantiate_trait_ref<'tcx>(\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n                                                   path.span,\n+                                                  PathParamMode::Explicit,\n                                                   trait_def_id,\n                                                   self_ty,\n                                                   path.segments.last().unwrap(),\n@@ -627,6 +647,7 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n+    param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     trait_segment: &ast::PathSegment,\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -640,6 +661,7 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n                                                      &shifted_rscope,\n                                                      span,\n+                                                     param_mode,\n                                                      trait_def_id,\n                                                      None,\n                                                      trait_segment,\n@@ -652,6 +674,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n+    param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     trait_segment: &ast::PathSegment,\n@@ -674,7 +697,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            convert_angle_bracketed_parameters(this, rscope, path.span, &trait_def.generics, data)\n+            convert_angle_bracketed_parameters(this, rscope, span, &trait_def.generics, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n@@ -688,12 +711,13 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            convert_parenthesized_parameters(this, rscope, path.span, &trait_def.generics, data)\n+            convert_parenthesized_parameters(this, rscope, span, &trait_def.generics, data)\n         }\n     };\n \n     let substs = create_substs_for_ast_path(this,\n                                             span,\n+                                            param_mode,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n@@ -830,6 +854,7 @@ fn ast_path_to_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n+    param_mode: PathParamMode,\n     did: ast::DefId,\n     item_segment: &ast::PathSegment)\n     -> Ty<'tcx>\n@@ -839,7 +864,9 @@ fn ast_path_to_ty<'tcx>(\n         ty: decl_ty\n     } = this.get_item_type_scheme(did);\n \n-    let substs = ast_path_substs_for_ty(this, rscope, span, &generics, item_segment);\n+    let substs = ast_path_substs_for_ty(this, rscope,\n+                                        span, param_mode,\n+                                        &generics, item_segment);\n \n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n@@ -878,6 +905,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                     let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                   rscope,\n                                                                   path.span,\n+                                                                  PathParamMode::Explicit,\n                                                                   trait_def_id,\n                                                                   path.segments.last().unwrap(),\n                                                                   &mut projection_bounds);\n@@ -950,8 +978,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    -> (Ty<'tcx>, def::Def)\n {\n     let tcx = this.tcx();\n-    check_path_args(tcx, span, slice::ref_slice(item_segment),\n-                    NO_TPS | NO_REGIONS);\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n     let assoc_name = item_segment.identifier.name;\n \n     let ty_param_node_id = if let ty::ty_param(_) = ty.sty {\n@@ -1043,19 +1070,19 @@ fn trait_defines_associated_type_named(this: &AstConv,\n fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                      rscope: &RegionScope,\n                      span: Span,\n-                     opt_self_ty: Option<&ast::Ty>,\n+                     param_mode: PathParamMode,\n+                     opt_self_ty: Option<Ty<'tcx>>,\n                      trait_def_id: ast::DefId,\n                      trait_segment: &ast::PathSegment,\n                      item_segment: &ast::PathSegment)\n                      -> Ty<'tcx>\n {\n     let tcx = this.tcx();\n \n-    check_path_args(tcx, span, slice::ref_slice(item_segment),\n-                    NO_TPS | NO_REGIONS);\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n \n     let self_ty = if let Some(ty) = opt_self_ty {\n-        ast_ty_to_ty(this, rscope, ty)\n+        ty\n     } else {\n         let path_str = ty::item_path_str(tcx, trait_def_id);\n         span_err!(tcx.sess, span, E0223,\n@@ -1070,6 +1097,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let trait_ref = ast_path_to_trait_ref(this,\n                                           rscope,\n                                           span,\n+                                          param_mode,\n                                           trait_def_id,\n                                           Some(self_ty),\n                                           trait_segment,\n@@ -1113,6 +1141,88 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n+pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                                        rscope: &RegionScope,\n+                                        span: Span,\n+                                        param_mode: PathParamMode,\n+                                        def: &mut def::Def,\n+                                        opt_self_ty: Option<Ty<'tcx>>,\n+                                        segments: &[ast::PathSegment],\n+                                        assoc_segments: &[ast::PathSegment])\n+                                        -> Ty<'tcx> {\n+    let tcx = this.tcx();\n+\n+    let base_ty = match *def {\n+        def::DefTrait(trait_def_id) => {\n+            // N.B. this case overlaps somewhat with\n+            // TyObjectSum, see that fn for details\n+            let mut projection_bounds = Vec::new();\n+\n+            let trait_ref = object_path_to_poly_trait_ref(this,\n+                                                          rscope,\n+                                                          span,\n+                                                          param_mode,\n+                                                          trait_def_id,\n+                                                          segments.last().unwrap(),\n+                                                          &mut projection_bounds);\n+\n+            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            trait_ref_to_object_type(this, rscope, span, trait_ref,\n+                                     projection_bounds, &[])\n+        }\n+        def::DefTy(did, _) | def::DefStruct(did) => {\n+            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            ast_path_to_ty(this, rscope, span,\n+                           param_mode, did,\n+                           segments.last().unwrap())\n+        }\n+        def::DefTyParam(space, index, _, name) => {\n+            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            ty::mk_param(tcx, space, index, name)\n+        }\n+        def::DefSelfTy(_) => {\n+            // n.b.: resolve guarantees that the this type only appears in a\n+            // trait, which we rely upon in various places when creating\n+            // substs\n+            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            ty::mk_self_type(tcx)\n+        }\n+        def::DefAssociatedTy(trait_did, _) => {\n+            check_path_args(tcx, &segments[..segments.len()-2], NO_TPS | NO_REGIONS);\n+            qpath_to_ty(this, rscope, span, param_mode,\n+                        opt_self_ty, trait_did,\n+                        &segments[segments.len()-2],\n+                        segments.last().unwrap())\n+        }\n+        def::DefMod(id) => {\n+            tcx.sess.span_bug(span,\n+                              &format!(\"found module name used as a type: {}\",\n+                                       tcx.map.node_to_string(id.node)));\n+        }\n+        def::DefPrimTy(prim_ty) => {\n+            prim_ty_to_ty(tcx, segments, prim_ty)\n+        }\n+        _ => {\n+            span_fatal!(tcx.sess, span, E0248,\n+                        \"found value name used as a type: {:?}\", *def);\n+        }\n+    };\n+\n+    // If any associated type segments remain, attempt to resolve them.\n+    let mut ty = base_ty;\n+    for segment in assoc_segments {\n+        if ty.sty == ty::ty_err {\n+            break;\n+        }\n+        // This is pretty bad (it will fail except for T::A and Self::A).\n+        let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n+                                                      ty, *def, segment);\n+        ty = a_ty;\n+        *def = a_def;\n+    }\n+    ty\n+}\n+\n /// Parses the programmer's textual representation of a type into our\n /// internal notion of a type.\n pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n@@ -1201,81 +1311,18 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n             };\n-            let (base_def, max_depth) = result;\n-            let span = ast_ty.span; // Could be more granular.\n-            let segments = &path.segments[..path.segments.len()-max_depth];\n-            let base_ty = match base_def {\n-                def::DefTrait(trait_def_id) => {\n-                    // N.B. this case overlaps somewhat with\n-                    // TyObjectSum, see that fn for details\n-                    let mut projection_bounds = Vec::new();\n-\n-                    let trait_ref = object_path_to_poly_trait_ref(this,\n-                                                                  rscope,\n-                                                                  span,\n-                                                                  trait_def_id,\n-                                                                  segments.last().unwrap(),\n-                                                                  &mut projection_bounds);\n-\n-                    check_path_args(tcx, span, segments.init(), NO_TPS | NO_REGIONS);\n-                    trait_ref_to_object_type(this, rscope, span, trait_ref,\n-                                             projection_bounds, &[])\n-                }\n-                def::DefTy(did, _) | def::DefStruct(did) => {\n-                    check_path_args(tcx, span, segments.init(), NO_TPS | NO_REGIONS);\n-                    ast_path_to_ty(this, rscope, span, did, segments.last().unwrap())\n-                }\n-                def::DefTyParam(space, index, _, name) => {\n-                    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n-                    ty::mk_param(tcx, space, index, name)\n-                }\n-                def::DefSelfTy(_) => {\n-                    // n.b.: resolve guarantees that the this type only appears in a\n-                    // trait, which we rely upon in various places when creating\n-                    // substs\n-                    check_path_args(tcx, span, segments, NO_TPS | NO_REGIONS);\n-                    ty::mk_self_type(tcx)\n-                }\n-                def::DefAssociatedTy(trait_did, _) => {\n-                    let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n-                        Some(&*qpath.self_type)\n-                    } else {\n-                        None\n-                    };\n-                    check_path_args(tcx, span, &segments[..segments.len()-2],\n-                                    NO_TPS | NO_REGIONS);\n-                    qpath_to_ty(this, rscope, span, opt_self_ty, trait_did,\n-                                &segments[segments.len()-2],\n-                                segments.last().unwrap())\n-                }\n-                def::DefMod(id) => {\n-                    tcx.sess.span_bug(span,\n-                                      &format!(\"found module name used as a type: {}\",\n-                                               tcx.map.node_to_string(id.node)));\n-                }\n-                def::DefPrimTy(prim_ty) => {\n-                    prim_ty_to_ty(tcx, span, segments, prim_ty)\n-                }\n-                _ => {\n-                    span_fatal!(tcx.sess, span, E0248,\n-                                \"found value name used as a type: {:?}\", base_def);\n-                }\n+            let (mut def, max_depth) = result;\n+            let base_ty_end = path.segments.len() - max_depth;\n+            let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n+                Some(ast_ty_to_ty(this, rscope, &*qpath.self_type))\n+            } else {\n+                None\n             };\n-\n-            // If any associated type segments remain, attempt to resolve them.\n-            let mut ty = base_ty;\n-            let mut def = base_def;\n-            for depth in (0..max_depth).rev() {\n-                if ty.sty == ty::ty_err {\n-                    break;\n-                }\n-                // This is pretty bad (it will fail except for T::A and Self::A).\n-                let segment = &path.segments[path.segments.len()-depth-1];\n-                let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n-                                                              ty, def, segment);\n-                ty = a_ty;\n-                def = a_def;\n-            }\n+            let ty = finish_resolving_def_to_ty(this, rscope, ast_ty.span,\n+                                                PathParamMode::Explicit, &mut def,\n+                                                opt_self_ty,\n+                                                &path.segments[..base_ty_end],\n+                                                &path.segments[base_ty_end..]);\n \n             if max_depth != 0 && ty.sty != ty::ty_err {\n                 // Write back the new resolution."}, {"sha": "edbda795bde3c075e131b22ce282d56f4af1d201", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -470,7 +470,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     };\n \n     instantiate_path(pcx.fcx,\n-                     path,\n+                     &path.segments,\n                      ty::lookup_item_type(tcx, enum_def_id),\n                      &ty::lookup_predicates(tcx, enum_def_id),\n                      None,\n@@ -517,7 +517,9 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_scheme, &ctor_predicates, None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, &path.segments,\n+                     path_scheme, &ctor_predicates,\n+                     None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "488d9d53dbe39978298d8e004f74d4d694d490d1", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -14,6 +14,7 @@ use astconv::AstConv;\n use check::{FnCtxt};\n use check::vtable;\n use check::vtable::select_new_fcx_obligations;\n+use middle::def;\n use middle::subst;\n use middle::traits;\n use middle::ty::*;\n@@ -66,7 +67,8 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         call_expr_id: ast::NodeId)\n                         -> bool\n {\n-    match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n+    let mode = probe::Mode::MethodCall;\n+    match probe::probe(fcx, span, mode, method_name, self_ty, call_expr_id) {\n         Ok(..) => true,\n         Err(NoMatch(..)) => false,\n         Err(Ambiguity(..)) => true,\n@@ -103,8 +105,9 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n+    let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n-    let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n+    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n@@ -301,6 +304,23 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n+pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              method_name: ast::Name,\n+                              self_ty: Ty<'tcx>,\n+                              expr_id: ast::NodeId)\n+                              -> Result<def::Def, MethodError>\n+{\n+    let mode = probe::Mode::Path;\n+    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n+    let def_id = pick.method_ty.def_id;\n+    let provenance = match pick.kind {\n+        probe::InherentImplPick(impl_def_id) => def::FromImpl(impl_def_id),\n+        _ => def::FromTrait(pick.method_ty.container.id())\n+    };\n+    Ok(def::DefMethod(def_id, provenance))\n+}\n+\n \n /// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n /// index (or `None`, if no such method)."}, {"sha": "938b7edeef2ff2b96d3b5074cd1a945317febd04", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -37,6 +37,7 @@ pub use self::PickKind::*;\n struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n+    mode: Mode,\n     method_name: ast::Name,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n@@ -108,17 +109,30 @@ pub enum PickAdjustment {\n     AutoRef(ast::Mutability, Box<PickAdjustment>),\n }\n \n+#[derive(PartialEq, Eq, Copy)]\n+pub enum Mode {\n+    // An expression of the form `receiver.method_name(...)`.\n+    // Autoderefs are performed on `receiver`, lookup is done based on the\n+    // `self` argument  of the method, and static methods aren't considered.\n+    MethodCall,\n+    // An expression of the form `Type::method` or `<T>::method`.\n+    // No autoderefs are performed, lookup is done based on the type each\n+    // implementation is for, and static methods are included.\n+    Path\n+}\n+\n pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                        span: Span,\n+                       mode: Mode,\n                        method_name: ast::Name,\n                        self_ty: Ty<'tcx>,\n-                       call_expr_id: ast::NodeId)\n+                       scope_expr_id: ast::NodeId)\n                        -> PickResult<'tcx>\n {\n-    debug!(\"probe(self_ty={}, method_name={}, call_expr_id={})\",\n+    debug!(\"probe(self_ty={}, method_name={}, scope_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n            method_name,\n-           call_expr_id);\n+           scope_expr_id);\n \n     // FIXME(#18741) -- right now, creating the steps involves evaluating the\n     // `*` operator, which registers obligations that then escape into\n@@ -127,9 +141,16 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // it ride, although it's really not great, and in fact could I\n     // think cause spurious errors. Really though this part should\n     // take place in the `fcx.infcx().probe` below.\n-    let steps = match create_steps(fcx, span, self_ty) {\n-        Some(steps) => steps,\n-        None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+    let steps = if mode == Mode::MethodCall {\n+        match create_steps(fcx, span, self_ty) {\n+            Some(steps) => steps,\n+            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+        }\n+    } else {\n+        vec![CandidateStep {\n+            self_ty: self_ty,\n+            adjustment: AutoDeref(0)\n+        }]\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -153,12 +174,15 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n-    let mut dummy = Some((steps, opt_simplified_steps)); // FIXME(#18101) need once closures\n     fcx.infcx().probe(|_| {\n-        let (steps, opt_simplified_steps) = dummy.take().unwrap();\n-        let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n+        let mut probe_cx = ProbeContext::new(fcx,\n+                                             span,\n+                                             mode,\n+                                             method_name,\n+                                             steps,\n+                                             opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n-        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id));\n+        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id));\n         probe_cx.pick()\n     })\n }\n@@ -198,6 +222,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n+           mode: Mode,\n            method_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n@@ -206,6 +231,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         ProbeContext {\n             fcx: fcx,\n             span: span,\n+            mode: mode,\n             method_name: method_name,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n@@ -292,11 +318,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        let impl_substs = self.impl_substs(impl_def_id);\n+        let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n+        let impl_ty = self.fcx.instantiate_type_scheme(self.span, &impl_substs, &impl_ty);\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n-            self.xform_self_ty(&method, &impl_substs);\n+            self.xform_self_ty(&method, impl_ty, &impl_substs);\n \n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n@@ -330,7 +357,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                           new_trait_ref.def_id,\n                                                           method_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs);\n+            let xform_self_ty = this.xform_self_ty(&m,\n+                                                   new_trait_ref.self_ty(),\n+                                                   new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -373,7 +402,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 this.erase_late_bound_regions(&poly_trait_ref);\n \n             let xform_self_ty =\n-                this.xform_self_ty(&m, trait_ref.substs);\n+                this.xform_self_ty(&m,\n+                                   trait_ref.self_ty(),\n+                                   trait_ref.substs);\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n@@ -540,7 +571,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let impl_substs = self.impl_substs(impl_def_id);\n+            let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n \n             debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n \n@@ -553,7 +584,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n             // Determine the receiver type that the method itself expects.\n             let xform_self_ty =\n-                self.xform_self_ty(&method, impl_trait_ref.substs);\n+                self.xform_self_ty(&method,\n+                                   impl_trait_ref.self_ty(),\n+                                   impl_trait_ref.substs);\n \n             debug!(\"xform_self_ty={}\", xform_self_ty.repr(self.tcx()));\n \n@@ -630,7 +663,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                              &trait_def.generics,\n                                                              step.self_ty);\n \n-            let xform_self_ty = self.xform_self_ty(&method_ty, &substs);\n+            let xform_self_ty = self.xform_self_ty(&method_ty,\n+                                                   step.self_ty,\n+                                                   &substs);\n             self.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n@@ -684,7 +719,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        bound.repr(self.tcx()));\n \n                 if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&method, bound.substs);\n+                    let xform_self_ty = self.xform_self_ty(&method,\n+                                                           bound.self_ty(),\n+                                                           bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n                            bound.repr(self.tcx()),\n@@ -714,7 +751,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n             let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs);\n+            let xform_self_ty = self.xform_self_ty(&method_ty,\n+                                                   bound.self_ty(),\n+                                                   bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n                    bound.repr(self.tcx()),\n@@ -1023,7 +1062,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // \"fast track\" -- check for usage of sugar\n         match method.explicit_self {\n             ty::StaticExplicitSelfCategory => {\n-                // fallthrough\n+                if self.mode == Mode::Path {\n+                    return true;\n+                }\n             }\n             ty::ByValueExplicitSelfCategory |\n             ty::ByReferenceExplicitSelfCategory(..) |\n@@ -1047,11 +1088,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn xform_self_ty(&self,\n                      method: &Rc<ty::Method<'tcx>>,\n+                     impl_ty: Ty<'tcx>,\n                      substs: &subst::Substs<'tcx>)\n                      -> Ty<'tcx>\n     {\n-        debug!(\"xform_self_ty(self_ty={}, substs={})\",\n-               method.fty.sig.0.inputs[0].repr(self.tcx()),\n+        debug!(\"xform_self_ty(impl_ty={}, self_ty={}, substs={})\",\n+               impl_ty.repr(self.tcx()),\n+               method.fty.sig.0.inputs.get(0).repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n         assert!(!substs.has_escaping_regions());\n@@ -1063,6 +1106,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // if there are any.\n         assert_eq!(substs.types.len(subst::FnSpace), 0);\n         assert_eq!(substs.regions().len(subst::FnSpace), 0);\n+\n+        if self.mode == Mode::Path {\n+            return impl_ty;\n+        }\n+\n         let placeholder;\n         let mut substs = substs;\n         if\n@@ -1094,9 +1142,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         xform_self_ty\n     }\n \n-    fn impl_substs(&self,\n-                   impl_def_id: ast::DefId)\n-                   -> subst::Substs<'tcx>\n+    /// Get the type of an impl and generate substitutions with placeholders.\n+    fn impl_ty_and_substs(&self,\n+                          impl_def_id: ast::DefId)\n+                          -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n         let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n \n@@ -1108,7 +1157,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             impl_pty.generics.regions.map(\n                 |_| ty::ReStatic); // see erase_late_bound_regions() for an expl of why 'static\n \n-        subst::Substs::new(type_vars, region_placeholders)\n+        let substs = subst::Substs::new(type_vars, region_placeholders);\n+        (impl_pty.ty, substs)\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using"}, {"sha": "7a4fab5e56cf0253621490a0e77239a70243b46b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 84, "deletions": 70, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -82,9 +82,10 @@ pub use self::compare_method::compare_impl_method;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv};\n+use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n+use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::{const_eval, def};\n use middle::infer;\n use middle::mem_categorization as mc;\n@@ -1598,26 +1599,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty::TypeScheme { generics, ty: decl_ty } =\n             ty::lookup_item_type(tcx, did);\n \n-        let wants_params =\n-            generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n-\n-        let needs_defaults =\n-            wants_params &&\n-            path.segments.iter().all(|s| s.parameters.is_empty());\n-\n-        let substs = if needs_defaults {\n-            let tps =\n-                self.infcx().next_ty_vars(generics.types.len(TypeSpace));\n-            let rps =\n-                self.infcx().region_vars_for_defs(path.span,\n-                                                  generics.regions.get_slice(TypeSpace));\n-            Substs::new_type(tps, rps)\n-        } else {\n-            astconv::ast_path_substs_for_ty(self, self,\n-                                            path.span,\n-                                            &generics,\n-                                            path.segments.last().unwrap())\n-        };\n+        let substs = astconv::ast_path_substs_for_ty(self, self,\n+                                                     path.span,\n+                                                     PathParamMode::Optional,\n+                                                     &generics,\n+                                                     path.segments.last().unwrap());\n \n         let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n \n@@ -3604,21 +3590,57 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::ExprPath(ref path) => {\n-          let defn = lookup_def(fcx, path.span, id);\n-          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, path, scheme, &predicates, None, defn, expr.span, expr.id);\n+      ast::ExprPath(ref path) | ast::ExprQPath(ast::QPath { ref path, .. }) => {\n+          let opt_self_ty = if let ast::ExprQPath(ref qpath) = expr.node {\n+              Some(fcx.to_ty(&*qpath.self_type))\n+          } else {\n+              None\n+          };\n \n-          // We always require that the type provided as the value for\n-          // a type parameter outlives the moment of instantiation.\n-          constrain_path_type_parameters(fcx, expr);\n-      }\n-      ast::ExprQPath(ref qpath) => {\n-          let self_ty = fcx.to_ty(&*qpath.self_type);\n-          let defn = lookup_def(fcx, expr.span, id);\n-          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, &qpath.path, scheme, &predicates, Some(self_ty),\n-                           defn, expr.span, expr.id);\n+          // Helpers to avoid keeping the RefCell borrow for too long.\n+          let get_def = |&:| tcx.def_map.borrow().get(&id).cloned();\n+          let get_partial_def = |&:| tcx.partial_def_map.borrow().get(&id).cloned();\n+\n+          if let Some(def) = get_def() {\n+              let (scheme, predicates) =\n+                  type_scheme_and_predicates_for_def(fcx, expr.span, def);\n+              instantiate_path(fcx, &path.segments,\n+                               scheme, &predicates,\n+                               None, def, expr.span, id);\n+          } else if let Some(partial) = get_partial_def() {\n+              let mut def = partial.base_type;\n+              let ty_segments = path.segments.init();\n+              let ty_assoc_num = partial.extra_associated_types as usize;\n+              let base_ty_end = ty_segments.len() - ty_assoc_num;\n+              let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, expr.span,\n+                                                           PathParamMode::Optional,\n+                                                           &mut def,\n+                                                           opt_self_ty,\n+                                                           &ty_segments[..base_ty_end],\n+                                                           &ty_segments[base_ty_end..]);\n+              let method_segment = path.segments.last().unwrap();\n+              let method_name = method_segment.identifier.name;\n+              match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n+                  Ok(def) => {\n+                      // Write back the new resolution.\n+                      tcx.def_map.borrow_mut().insert(id, def);\n+\n+                      let (scheme, predicates) =\n+                          type_scheme_and_predicates_for_def(fcx, expr.span, def);\n+                      instantiate_path(fcx, slice::ref_slice(method_segment),\n+                                       scheme, &predicates,\n+                                       Some(ty), def, expr.span, id);\n+                  }\n+                  Err(error) => {\n+                      method::report_error(fcx, expr.span, ty,\n+                                           method_name, expr, error);\n+                      fcx.write_error(id);\n+                  }\n+              }\n+          } else {\n+              tcx.sess.span_bug(expr.span,\n+                                &format!(\"unbound path {}\", expr.repr(tcx))[])\n+          }\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -4641,7 +4663,6 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefForeignMod(..) |\n         def::DefUse(..) |\n         def::DefRegion(..) |\n-        def::DefTyParamBinder(..) |\n         def::DefLabel(..) |\n         def::DefSelfTy(..) => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n@@ -4652,15 +4673,15 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  path: &ast::Path,\n+                                  segments: &[ast::PathSegment],\n                                   type_scheme: TypeScheme<'tcx>,\n                                   type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: def::Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n-    debug!(\"instantiate_path(path={}, def={}, node_id={}, type_scheme={})\",\n-           path.repr(fcx.tcx()),\n+    debug!(\"instantiate_path(path={:?}, def={}, node_id={}, type_scheme={})\",\n+           segments,\n            def.repr(fcx.tcx()),\n            node_id,\n            type_scheme.repr(fcx.tcx()));\n@@ -4724,7 +4745,11 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // The first step then is to categorize the segments appropriately.\n \n-    assert!(path.segments.len() >= 1);\n+    assert!(segments.len() >= 1);\n+\n+    // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory.\n+    let mut require_type_space = opt_self_ty.is_some();\n+\n     let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n@@ -4738,32 +4763,37 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n-            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n+            segment_spaces = repeat(None).take(segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n         def::DefConst(..) |\n         def::DefStatic(..) => {\n-            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n+            segment_spaces = repeat(None).take(segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n         // Case 3. Reference to a method.\n         def::DefMethod(_, providence) => {\n-            assert!(path.segments.len() >= 2);\n-\n             match providence {\n                 def::FromTrait(trait_did) => {\n                     callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n                 }\n                 def::FromImpl(_) => {}\n             }\n \n-            segment_spaces = repeat(None).take(path.segments.len() - 2).collect();\n-            segment_spaces.push(Some(subst::TypeSpace));\n-            segment_spaces.push(Some(subst::FnSpace));\n+            if segments.len() >= 2 {\n+                segment_spaces = repeat(None).take(segments.len() - 2).collect();\n+                segment_spaces.push(Some(subst::TypeSpace));\n+                segment_spaces.push(Some(subst::FnSpace));\n+            } else {\n+                // `<T>::method` will end up here, and so can `T::method`.\n+                assert!(opt_self_ty.is_some());\n+                require_type_space = false;\n+                segment_spaces = vec![Some(subst::FnSpace)];\n+            }\n         }\n \n         // Other cases. Various nonsense that really shouldn't show up\n@@ -4776,10 +4806,10 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n-            segment_spaces = repeat(None).take(path.segments.len()).collect();\n+            segment_spaces = repeat(None).take(segments.len()).collect();\n         }\n     }\n-    assert_eq!(segment_spaces.len(), path.segments.len());\n+    assert_eq!(segment_spaces.len(), segments.len());\n \n     debug!(\"segment_spaces={:?}\", segment_spaces);\n \n@@ -4793,16 +4823,17 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // provided (if any) into their appropriate spaces. We'll also report\n     // errors if type parameters are provided in an inappropriate place.\n     let mut substs = Substs::empty();\n-    for (opt_space, segment) in segment_spaces.iter().zip(path.segments.iter()) {\n+    for (opt_space, segment) in segment_spaces.iter().zip(segments.iter()) {\n         match *opt_space {\n             None => {\n-                report_error_if_segment_contains_type_parameters(fcx, segment);\n+                check_path_args(fcx.tcx(), slice::ref_slice(segment),\n+                                NO_TPS | NO_REGIONS);\n             }\n \n             Some(space) => {\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n-                                                                path.span,\n+                                                                span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n@@ -4824,7 +4855,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // a problem.\n     for &space in &ParamSpace::all() {\n         adjust_type_parameters(fcx, span, space, type_defs,\n-                               opt_self_ty.is_some(), &mut substs);\n+                               require_type_space, &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n         adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n@@ -4851,23 +4882,6 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n     return;\n \n-    fn report_error_if_segment_contains_type_parameters(\n-        fcx: &FnCtxt,\n-        segment: &ast::PathSegment)\n-    {\n-        for typ in &segment.parameters.types() {\n-            span_err!(fcx.tcx().sess, typ.span, E0085,\n-                \"type parameters may not appear here\");\n-            break;\n-        }\n-\n-        for lifetime in &segment.parameters.lifetimes() {\n-            span_err!(fcx.tcx().sess, lifetime.span, E0086,\n-                \"lifetime parameters may not appear here\");\n-            break;\n-        }\n-    }\n-\n     /// Finds the parameters that the user provided and adds them to `substs`. If too many\n     /// parameters are provided, then reports an error and clears the output vector.\n     ///"}, {"sha": "976c794735fbb177244f03ceb783ae59fcc7d605", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -1684,8 +1684,8 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 -> bool\n     {\n         match ast_ty.node {\n-            ast::TyPath(_, id) => {\n-                match ccx.tcx.def_map.borrow()[id] {\n+            ast::TyPath(_) => {\n+                match ccx.tcx.def_map.borrow()[ast_ty.id] {\n                     def::DefTyParam(s, i, _, _) => {\n                         space == s && index == i\n                     }"}, {"sha": "2652fb5dfc2fd6dc453f73f1d3d9094847ccbe86", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -30,7 +30,5 @@ impl ToString_ for Point {\n \n fn main() {\n     let p = Point::new(0.0, 0.0);\n-    //~^ ERROR unresolved name `Point::new`\n-    //~^^ ERROR failed to resolve. Use of undeclared type or module `Point`\n     println!(\"{}\", p.to_string());\n }"}, {"sha": "23d90c5ee292bf288f0c6b8c64ada2ff4f117264", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4f9b8e3a4563956223f3c8998b9b299a22eab8/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=fe4f9b8e3a4563956223f3c8998b9b299a22eab8", "patch": "@@ -77,18 +77,27 @@ tests! {\n     //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n \n     // Trait static methods.\n+    bool::size, fn() -> uint, ();\n     <bool as Size>::size, fn() -> uint, ();\n+\n     Default::default, fn() -> int, ();\n+    int::default, fn() -> int, ();\n     <int as Default>::default, fn() -> int, ();\n+\n     Rand::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    int::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n     <int as Rand>::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n     Rand::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    int::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n     <int as Rand>::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n \n     // Trait non-static methods.\n     Clone::clone, fn(&int) -> int, (&5);\n+    int::clone, fn(&int) -> int, (&5);\n     <int as Clone>::clone, fn(&int) -> int, (&5);\n+\n     FromIterator::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n+    Vec::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n     <Vec<_> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n         (Some(5).into_iter());\n     <Vec<int> as FromIterator<_>>::from_iter, fn(OptionIter<int>) -> Vec<int>,\n@@ -97,9 +106,14 @@ tests! {\n         (Some(5).into_iter());\n     <Vec<int> as FromIterator<_>>::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>,\n         (Some(5).into_iter());\n+\n     Add::add, fn(i32, i32) -> i32, (5, 6);\n+    i32::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<_>>::add, fn(i32, i32) -> i32, (5, 6);\n     <i32 as Add<i32>>::add, fn(i32, i32) -> i32, (5, 6);\n+\n+    String::into_cow, fn(String) -> Cow<'static, str>,\n+        (\"foo\".to_string());\n     <String as IntoCow<_>>::into_cow, fn(String) -> Cow<'static, str>,\n         (\"foo\".to_string());\n     <String as IntoCow<'static, _>>::into_cow, fn(String) -> Cow<'static, str>,"}]}