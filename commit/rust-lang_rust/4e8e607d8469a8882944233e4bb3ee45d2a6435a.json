{"sha": "4e8e607d8469a8882944233e4bb3ee45d2a6435a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlOGU2MDdkODQ2OWE4ODgyOTQ0MjMzZTRiYjNlZTQ1ZDJhNjQzNWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-22T18:24:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-22T18:24:32Z"}, "message": "Fix #[derive] for empty structs with braces", "tree": {"sha": "1383d1f4a4e8982ea73c7165a169ba0fa53912a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1383d1f4a4e8982ea73c7165a169ba0fa53912a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e8e607d8469a8882944233e4bb3ee45d2a6435a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8e607d8469a8882944233e4bb3ee45d2a6435a", "html_url": "https://github.com/rust-lang/rust/commit/4e8e607d8469a8882944233e4bb3ee45d2a6435a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e8e607d8469a8882944233e4bb3ee45d2a6435a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98a59cf57e02b6e6a5a3bd74eb47b1422eaacc53", "url": "https://api.github.com/repos/rust-lang/rust/commits/98a59cf57e02b6e6a5a3bd74eb47b1422eaacc53", "html_url": "https://github.com/rust-lang/rust/commit/98a59cf57e02b6e6a5a3bd74eb47b1422eaacc53"}], "stats": {"total": 133, "additions": 95, "deletions": 38}, "files": [{"sha": "0085182d1ac2af018d5bff4821b4b8265d177eb3", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr};\n+use syntax::ast::{MetaItem, Expr, VariantData};\n use syntax::codemap::Span;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n@@ -66,14 +66,17 @@ fn cs_clone(\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n+    let vdata;\n     match *substr.fields {\n-        Struct(ref af) => {\n+        Struct(vdata_, ref af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident]);\n             all_fields = af;\n+            vdata = vdata_;\n         }\n         EnumMatching(_, variant, ref af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.name]);\n             all_fields = af;\n+            vdata = &variant.node.data;\n         },\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n@@ -86,30 +89,29 @@ fn cs_clone(\n         }\n     }\n \n-    if !all_fields.is_empty() && all_fields[0].name.is_none() {\n-        // enum-like\n-        let subcalls = all_fields.iter().map(subcall).collect();\n-        let path = cx.expr_path(ctor_path);\n-        cx.expr_call(trait_span, path, subcalls)\n-    } else {\n-        // struct-like\n-        let fields = all_fields.iter().map(|field| {\n-            let ident = match field.name {\n-                Some(i) => i,\n-                None => {\n-                    cx.span_bug(trait_span,\n-                                &format!(\"unnamed field in normal struct in \\\n-                                         `derive({})`\", name))\n-                }\n-            };\n-            cx.field_imm(field.span, ident, subcall(field))\n-        }).collect::<Vec<_>>();\n+    match *vdata {\n+        VariantData::Struct(..) => {\n+            let fields = all_fields.iter().map(|field| {\n+                let ident = match field.name {\n+                    Some(i) => i,\n+                    None => {\n+                        cx.span_bug(trait_span,\n+                                    &format!(\"unnamed field in normal struct in \\\n+                                             `derive({})`\", name))\n+                    }\n+                };\n+                cx.field_imm(field.span, ident, subcall(field))\n+            }).collect::<Vec<_>>();\n \n-        if fields.is_empty() {\n-            // no fields, so construct like `None`\n-            cx.expr_path(ctor_path)\n-        } else {\n             cx.expr_struct(trait_span, ctor_path, fields)\n         }\n+        VariantData::Tuple(..) => {\n+            let subcalls = all_fields.iter().map(subcall).collect();\n+            let path = cx.expr_path(ctor_path);\n+            cx.expr_call(trait_span, path, subcalls)\n+        }\n+        VariantData::Unit(..) => {\n+            cx.expr_path(ctor_path)\n+        }\n     }\n }"}, {"sha": "109f2ad4025308b6397e851011e4a0c010b7f5b0", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -62,7 +62,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n     let ident = match *substr.fields {\n-        Struct(_) => substr.type_ident,\n+        Struct(..) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n         EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n@@ -76,11 +76,16 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n+    let is_struct = match *substr.fields {\n+        Struct(vdata, _) => vdata,\n+        EnumMatching(_, v, _) => &v.node.data,\n+        _ => unreachable!()\n+    }.is_struct();\n \n     let stmts = match *substr.fields {\n-        Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n+        Struct(_, ref fields) | EnumMatching(_, _, ref fields) => {\n             let mut stmts = vec![];\n-            if fields.is_empty() || fields[0].name.is_none() {\n+            if !is_struct {\n                 // tuple struct/\"normal\" variant\n                 let expr = cx.expr_method_call(span,\n                                                fmt,"}, {"sha": "8262a04e9ce179350db8cd8437d201383382d2ac", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -179,7 +179,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     let encode = cx.ident_of(\"encode\");\n \n     return match *substr.fields {\n-        Struct(ref fields) => {\n+        Struct(_, ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo {"}, {"sha": "c0237a5d29a4103dbf8e535ba9800cc474929fca", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -300,7 +300,7 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    Struct(Vec<FieldInfo<'a>>),\n+    Struct(&'a ast::VariantData, Vec<FieldInfo<'a>>),\n     /// Matching variants of the enum: variant index, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n@@ -981,7 +981,7 @@ impl<'a> MethodDef<'a> {\n             type_ident,\n             self_args,\n             nonself_args,\n-            &Struct(fields));\n+            &Struct(struct_def, fields));\n \n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n@@ -1460,8 +1460,9 @@ impl<'a> TraitDef<'a> {\n                                           fields in generic `derive`\"),\n             // named fields\n             (_, false) => Named(named_idents),\n-            // tuple structs (includes empty structs)\n-            (_, _)     => Unnamed(just_spans)\n+            // empty structs\n+            _ if struct_def.is_struct() => Named(named_idents),\n+            _ => Unnamed(just_spans),\n         }\n     }\n \n@@ -1486,7 +1487,11 @@ impl<'a> TraitDef<'a> {\n                                                    P<Expr>,\n                                                    &'a [ast::Attribute])>) {\n         if struct_def.fields().is_empty() {\n-            return (cx.pat_enum(self.span, struct_path, vec![]), vec![]);\n+            if struct_def.is_struct() {\n+                return (cx.pat_struct(self.span, struct_path, vec![]), vec![]);\n+            } else {\n+                return (cx.pat_enum(self.span, struct_path, vec![]), vec![]);\n+            }\n         }\n \n         let mut paths = Vec::new();\n@@ -1521,7 +1526,7 @@ impl<'a> TraitDef<'a> {\n \n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n-        let pattern = if struct_type == Record {\n+        let pattern = if struct_def.is_struct() {\n             let field_pats = subpats.into_iter().zip(&ident_expr)\n                                     .map(|(pat, &(_, id, _, _))| {\n                 // id is guaranteed to be Some\n@@ -1566,7 +1571,7 @@ pub fn cs_fold<F>(use_foldl: bool,\n     F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n {\n     match *substructure.fields {\n-        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(_, ref all_fields) => {\n             if use_foldl {\n                 all_fields.iter().fold(base, |old, field| {\n                     f(cx,\n@@ -1612,7 +1617,7 @@ pub fn cs_same_method<F>(f: F,\n     F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>,\n {\n     match *substructure.fields {\n-        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(_, ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = all_fields.iter().map(|field| {\n                 cx.expr_method_call(field.span,"}, {"sha": "bf8aa8fb23debd071fceabb07f5a016e98771797", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -76,7 +76,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n     let mut stmts = Vec::new();\n \n     let fields = match *substr.fields {\n-        Struct(ref fs) => fs,\n+        Struct(_, ref fs) => fs,\n         EnumMatching(index, variant, ref fs) => {\n             // Determine the discriminant. We will feed this value to the byte\n             // iteration function."}, {"sha": "2878674f0ea61fbb0e80140be2dd3025bad995a8", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -73,7 +73,7 @@ fn expand(cx: &mut ExtCtxt,\n fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                          substr: &Substructure) -> P<ast::Expr> {\n     let fields = match *substr.fields {\n-        Struct(ref fs) | EnumMatching(_, _, ref fs) => fs,\n+        Struct(_, ref fs) | EnumMatching(_, _, ref fs) => fs,\n         _ => cx.span_bug(trait_span, \"impossible substructure\")\n     };\n "}, {"sha": "e54a8245d0bd3eb846d3cd1eda0f0dae08ff0ece", "filename": "src/test/run-pass/empty-struct-braces-derive.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Ftest%2Frun-pass%2Fempty-struct-braces-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8e607d8469a8882944233e4bb3ee45d2a6435a/src%2Ftest%2Frun-pass%2Fempty-struct-braces-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-braces-derive.rs?ref=4e8e607d8469a8882944233e4bb3ee45d2a6435a", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// `#[derive(Trait)]` works for empty structs/variants with braces\n+\n+#![feature(braced_empty_structs)]\n+#![feature(rustc_private)]\n+\n+extern crate serialize as rustc_serialize;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Default, Debug, RustcEncodable, RustcDecodable)]\n+struct S {}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Debug, RustcEncodable, RustcDecodable)]\n+enum E {\n+    V {},\n+    U,\n+}\n+\n+fn main() {\n+    let s = S {};\n+    let s1 = s;\n+    let s2 = s.clone();\n+    assert_eq!(s, s1);\n+    assert_eq!(s, s2);\n+    assert!(!(s < s1));\n+    assert_eq!(format!(\"{:?}\", s), \"S\");\n+\n+    let e = E::V {};\n+    let e1 = e;\n+    let e2 = e.clone();\n+    assert_eq!(e, e1);\n+    assert_eq!(e, e2);\n+    assert!(!(e < e1));\n+    assert_eq!(format!(\"{:?}\", e), \"V\");\n+}"}]}