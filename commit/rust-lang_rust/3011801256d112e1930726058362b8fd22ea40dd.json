{"sha": "3011801256d112e1930726058362b8fd22ea40dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMTE4MDEyNTZkMTEyZTE5MzA3MjYwNTgzNjJiOGZkMjJlYTQwZGQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-18T08:38:46Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-10-18T08:43:41Z"}, "message": "Made `std::task::TaskBuilder::future_result()` easier to use", "tree": {"sha": "a2b7c4fe80d64bf520a76cba762cab423e2a26b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2b7c4fe80d64bf520a76cba762cab423e2a26b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3011801256d112e1930726058362b8fd22ea40dd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3011801256d112e1930726058362b8fd22ea40dd", "html_url": "https://github.com/rust-lang/rust/commit/3011801256d112e1930726058362b8fd22ea40dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3011801256d112e1930726058362b8fd22ea40dd/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a32386f3b61a4997de54ed00c0a80fd07ecc75", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a32386f3b61a4997de54ed00c0a80fd07ecc75", "html_url": "https://github.com/rust-lang/rust/commit/d4a32386f3b61a4997de54ed00c0a80fd07ecc75"}], "stats": {"total": 135, "additions": 47, "deletions": 88}, "files": [{"sha": "d1e7534795b0d538d36cf6197638b594d2fbba09", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -823,7 +823,7 @@ mod tests {\n         do 5.times {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n-            builder.future_result(|r| children.push(r));\n+            children.push(builder.future_result());\n             do builder.spawn {\n                 do arc3.read |num| {\n                     assert!(*num >= 0);"}, {"sha": "59eea6b4a134cef0801d141382fb80608f296808", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -870,14 +870,12 @@ pub fn run_test(force_ignore: bool,\n                       testfn: ~fn()) {\n         let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n-            let mut result_future = None; // task::future_result(builder);\n-\n             let mut task = task::task();\n             task.unlinked();\n-            task.future_result(|r| { result_future = Some(r) });\n+            let result_future = task.future_result();\n             task.spawn(testfn_cell.take());\n \n-            let task_result = result_future.unwrap().recv();\n+            let task_result = result_future.recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n             monitor_ch.send((desc.clone(), test_result));"}, {"sha": "92315b5d47a26d7f4f82f1268a346d082be97e41", "filename": "src/libstd/result.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -463,7 +463,6 @@ mod tests {\n     use str::OwnedStr;\n     use vec::ImmutableVector;\n     use to_str::ToStr;\n-    use fmt::Default;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n     pub fn op2() -> Result<int, ~str> { Err(~\"sadface\") }"}, {"sha": "889d9bb31566e28467c168ce811cedb66a4a9555", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -621,29 +621,4 @@ mod test {\n             a.next = Some(b);\n         }\n     }\n-\n-    // XXX: This is a copy of test_future_result in std::task.\n-    // It can be removed once the scheduler is turned on by default.\n-    #[test]\n-    fn future_result() {\n-        do run_in_newsched_task {\n-            use option::{Some, None};\n-            use task::*;\n-\n-            let mut result = None;\n-            let mut builder = task();\n-            builder.future_result(|r| result = Some(r));\n-            do builder.spawn {}\n-            assert_eq!(result.unwrap().recv(), Success);\n-\n-            result = None;\n-            let mut builder = task();\n-            builder.future_result(|r| result = Some(r));\n-            builder.unlinked();\n-            do builder.spawn {\n-                fail2!();\n-            }\n-            assert_eq!(result.unwrap().recv(), Failure);\n-        }\n-    }\n }"}, {"sha": "51b1ab603ed55343751856aa8d24d4fa39f7043d", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -258,24 +258,22 @@ impl TaskBuilder {\n         self.opts.indestructible = true;\n     }\n \n-    /**\n-     * Get a future representing the exit status of the task.\n-     *\n-     * Taking the value of the future will block until the child task\n-     * terminates. The future-receiving callback specified will be called\n-     * *before* the task is spawned; as such, do not invoke .get() within the\n-     * closure; rather, store it in an outer variable/list for later use.\n-     *\n-     * Note that the future returning by this function is only useful for\n-     * obtaining the value of the next task to be spawning with the\n-     * builder. If additional tasks are spawned with the same builder\n-     * then a new result future must be obtained prior to spawning each\n-     * task.\n-     *\n-     * # Failure\n-     * Fails if a future_result was already set for this task.\n-     */\n-    pub fn future_result(&mut self, blk: &fn(v: Port<TaskResult>)) {\n+    /// Get a future representing the exit status of the task.\n+    ///\n+    /// Taking the value of the future will block until the child task\n+    /// terminates. The future result return value will be created *before* the task is\n+    /// spawned; as such, do not invoke .get() on it directly;\n+    /// rather, store it in an outer variable/list for later use.\n+    ///\n+    /// Note that the future returned by this function is only useful for\n+    /// obtaining the value of the next task to be spawning with the\n+    /// builder. If additional tasks are spawned with the same builder\n+    /// then a new result future must be obtained prior to spawning each\n+    /// task.\n+    ///\n+    /// # Failure\n+    /// Fails if a future_result was already set for this task.\n+    pub fn future_result(&mut self) -> Port<TaskResult> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -288,10 +286,10 @@ impl TaskBuilder {\n         // Construct the future and give it to the caller.\n         let (notify_pipe_po, notify_pipe_ch) = stream::<TaskResult>();\n \n-        blk(notify_pipe_po);\n-\n         // Reconfigure self to use a notify channel.\n         self.opts.notify_chan = Some(notify_pipe_ch);\n+\n+        notify_pipe_po\n     }\n \n     /// Name the task-to-be. Currently the name is used for identification\n@@ -398,15 +396,14 @@ impl TaskBuilder {\n      */\n     pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n-        let mut result = None;\n \n-        self.future_result(|r| { result = Some(r); });\n+        let result = self.future_result();\n \n         do self.spawn {\n             ch.send(f());\n         }\n \n-        match result.unwrap().recv() {\n+        match result.recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n@@ -1024,27 +1021,25 @@ fn test_add_wrapper() {\n \n #[test]\n fn test_future_result() {\n-    let mut result = None;\n     let mut builder = task();\n-    builder.future_result(|r| result = Some(r));\n+    let result = builder.future_result();\n     do builder.spawn {}\n-    assert_eq!(result.unwrap().recv(), Success);\n+    assert_eq!(result.recv(), Success);\n \n-    result = None;\n     let mut builder = task();\n-    builder.future_result(|r| result = Some(r));\n+    let result = builder.future_result();\n     builder.unlinked();\n     do builder.spawn {\n         fail2!();\n     }\n-    assert_eq!(result.unwrap().recv(), Failure);\n+    assert_eq!(result.recv(), Failure);\n }\n \n #[test] #[should_fail]\n fn test_back_to_the_future_result() {\n     let mut builder = task();\n-    builder.future_result(util::ignore);\n-    builder.future_result(util::ignore);\n+    builder.future_result();\n+    builder.future_result();\n }\n \n #[test]"}, {"sha": "459df572b78051ca90d57f7f0a8a51e56c51f917", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -580,32 +580,29 @@ mod tests {\n         // Now try the same thing, but with the child task blocking.\n         let x = Exclusive::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n-        let mut res = None;\n         let mut builder = task::task();\n-        builder.future_result(|r| res = Some(r));\n+        let res = builder.future_result();\n         do builder.spawn {\n             let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         // Have to get rid of our reference before blocking.\n         util::ignore(x);\n-        res.unwrap().recv();\n+        res.recv();\n     }\n \n     #[test] #[should_fail]\n     fn exclusive_new_unwrap_conflict() {\n         let x = Exclusive::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n-        let mut res = None;\n         let mut builder = task::task();\n-        builder.future_result(|r| res = Some(r));\n+        let res = builder.future_result();\n         do builder.spawn {\n             let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         assert!(x.unwrap() == ~~\"hello\");\n-        // See #4689 for why this can't be just \"res.recv()\".\n-        assert!(res.unwrap().recv() == task::Success);\n+        assert!(res.recv() == task::Success);\n     }\n \n     #[test]"}, {"sha": "ff2eb575ec5c846cf035e200f02f3a16d7cd42aa", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -67,7 +67,7 @@ fn run(args: &[~str]) {\n     for _ in range(0u, workers) {\n         let to_child = to_child.clone();\n         let mut builder = task::task();\n-        builder.future_result(|r| worker_results.push(r));\n+        worker_results.push(builder.future_result());\n         do builder.spawn {\n             for _ in range(0u, size / workers) {\n                 //error2!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);"}, {"sha": "4ce9fb493eb767b7262949376f5d788605bf6d9b", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -61,7 +61,7 @@ fn run(args: &[~str]) {\n     for _ in range(0u, workers) {\n         let to_child = to_child.clone();\n         let mut builder = task::task();\n-        builder.future_result(|r| worker_results.push(r));\n+        worker_results.push(builder.future_result());\n         do builder.spawn {\n             for _ in range(0u, size / workers) {\n                 //error2!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);"}, {"sha": "b4f6e7e4b710b296cb75a272f4b0d34860d1dbe6", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -84,7 +84,7 @@ fn stress(num_tasks: int) {\n     let mut results = ~[];\n     for i in range(0, num_tasks) {\n         let mut builder = task::task();\n-        builder.future_result(|r| results.push(r));\n+        results.push(builder.future_result());\n         do builder.spawn {\n             stress_task(i);\n         }"}, {"sha": "3b64cb38c7e27920196ba6c9aba605a5ffa6ea78", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -54,13 +54,12 @@ fn grandchild_group(num_tasks: uint) {\n }\n \n fn spawn_supervised_blocking(myname: &str, f: ~fn()) {\n-    let mut res = None;\n     let mut builder = task::task();\n-    builder.future_result(|r| res = Some(r));\n+    let res = builder.future_result();\n     builder.supervised();\n     builder.spawn(f);\n     error2!(\"{} group waiting\", myname);\n-    let x = res.unwrap().recv();\n+    let x = res.recv();\n     assert_eq!(x, task::Success);\n }\n "}, {"sha": "9d5f8937590435fb5e37640ddf1ff6e648c23d6d", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -18,9 +18,8 @@ fn start(_task_number: int) { info2!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let mut result = None;\n     let mut builder = task::task();\n-    builder.future_result(|r| result = Some(r));\n+    let result = builder.future_result();\n     do builder.spawn {\n         start(i)\n     }\n@@ -33,7 +32,7 @@ fn test00() {\n     }\n \n     // Try joining tasks that have already finished.\n-    result.unwrap().recv();\n+    result.recv();\n \n     info2!(\"Joined task.\");\n }"}, {"sha": "b4a1a38faa20b9056bcaee835d6a6e7edd9d05a4", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -45,7 +45,7 @@ fn test00() {\n     while i < number_of_tasks {\n         let ch = ch.clone();\n         let mut builder = task::task();\n-        builder.future_result(|r| results.push(r));\n+        results.push(builder.future_result());\n         builder.spawn({\n             let i = i;\n             || test00_start(&ch, i, number_of_messages)"}, {"sha": "20d22204bedeb6b8160f12dce2e7ed0910672cfa", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -28,9 +28,8 @@ fn test00() {\n     let (p, ch) = comm::stream();\n     let number_of_messages: int = 10;\n \n-    let mut result = None;\n     let mut builder = task::task();\n-    builder.future_result(|r| result = Some(r));\n+    let result = builder.future_result();\n     do builder.spawn {\n         test00_start(&ch, number_of_messages);\n     }\n@@ -42,7 +41,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    result.unwrap().recv();\n+    result.recv();\n \n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "6f6f59d80a5dea978397088600a39dbcb5ef355e", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -12,16 +12,15 @@\n use std::task;\n \n pub fn main() {\n-    let mut result = None;\n     let mut builder = task::task();\n-    builder.future_result(|r| { result = Some(r); });\n+    let result = builder.future_result();\n     builder.spawn(child);\n     error2!(\"1\");\n     task::deschedule();\n     error2!(\"2\");\n     task::deschedule();\n     error2!(\"3\");\n-    result.unwrap().recv();\n+    result.recv();\n }\n \n fn child() {"}, {"sha": "6b189e515ff6c5761bd342f53ff2156abbaf81bc", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3011801256d112e1930726058362b8fd22ea40dd/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=3011801256d112e1930726058362b8fd22ea40dd", "patch": "@@ -12,13 +12,12 @@\n use std::task;\n \n pub fn main() {\n-    let mut result = None;\n     let mut builder = task::task();\n-    builder.future_result(|r| { result = Some(r); });\n+    let result = builder.future_result();\n     builder.spawn(child);\n     error2!(\"1\");\n     task::deschedule();\n-    result.unwrap().recv();\n+    result.recv();\n }\n \n fn child() { error2!(\"2\"); }"}]}