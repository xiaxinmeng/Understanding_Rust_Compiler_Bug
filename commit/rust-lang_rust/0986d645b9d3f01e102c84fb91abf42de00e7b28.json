{"sha": "0986d645b9d3f01e102c84fb91abf42de00e7b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ODZkNjQ1YjlkM2YwMWUxMDJjODRmYjkxYWJmNDJkZTAwZTdiMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-16T02:41:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-16T02:41:01Z"}, "message": "Auto merge of #32236 - alexcrichton:better-compile-intrinsics, r=arielb1\n\nrustc: Improve compile time of platform intrinsics\n\nThis commit improves the compile time of `rustc_platform_intrinsics` from 23s to\n3.6s if compiling with `-O` and from 77s to 17s if compiling with `-O -g`. The\ncompiled rlib size also drops from 3.1M to 1.2M.\n\nThe wins here were gained by removing the destructors associated with `Type` by\nremoving the internal `Box` and `Vec` indirections. These destructors meant that\na lot of landing pads and extra code were generated to manage the runtime\nrepresentations. Instead everything can basically be statically computed and\nshoved into rodata, so all we need is a giant string compare to lookup what's\nwhat.\n\nCloses #28273", "tree": {"sha": "21ec6b77b757de5db7af56084b04a6523059f9db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21ec6b77b757de5db7af56084b04a6523059f9db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0986d645b9d3f01e102c84fb91abf42de00e7b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0986d645b9d3f01e102c84fb91abf42de00e7b28", "html_url": "https://github.com/rust-lang/rust/commit/0986d645b9d3f01e102c84fb91abf42de00e7b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0986d645b9d3f01e102c84fb91abf42de00e7b28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66d2380a810c9a2b3dbb4f93a830b101ee49cc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66d2380a810c9a2b3dbb4f93a830b101ee49cc2", "html_url": "https://github.com/rust-lang/rust/commit/c66d2380a810c9a2b3dbb4f93a830b101ee49cc2"}, {"sha": "87ede2da549632de443859c8e08f0c977849d8b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ede2da549632de443859c8e08f0c977849d8b7", "html_url": "https://github.com/rust-lang/rust/commit/87ede2da549632de443859c8e08f0c977849d8b7"}], "stats": {"total": 5543, "additions": 2802, "deletions": 2741}, "files": [{"sha": "786cb20ed75d5de00cc199ce6585983a453ce2c7", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28", "patch": "@@ -117,7 +117,10 @@ def __init__(self):\n         Type.__init__(self, 0)\n \n     def compiler_ctor(self):\n-        return 'void()'\n+        return '::VOID'\n+\n+    def compiler_ctor_ref(self):\n+        return '&' + self.compiler_ctor()\n \n     def rust_name(self):\n         return '()'\n@@ -163,10 +166,12 @@ def __init__(self, bitwidth, llvm_bitwidth = None):\n \n     def compiler_ctor(self):\n         if self._llvm_bitwidth is None:\n-            return 'i({})'.format(self.bitwidth())\n+            return '::I{}'.format(self.bitwidth())\n         else:\n-            return 'i_({}, {})'.format(self.bitwidth(),\n-                                       self._llvm_bitwidth)\n+            return '::I{}_{}'.format(self.bitwidth(), self._llvm_bitwidth)\n+\n+    def compiler_ctor_ref(self):\n+        return '&' + self.compiler_ctor()\n \n     def llvm_name(self):\n         bw = self._llvm_bitwidth or self.bitwidth()\n@@ -182,10 +187,12 @@ def __init__(self, bitwidth, llvm_bitwidth = None):\n \n     def compiler_ctor(self):\n         if self._llvm_bitwidth is None:\n-            return 'u({})'.format(self.bitwidth())\n+            return '::U{}'.format(self.bitwidth())\n         else:\n-            return 'u_({}, {})'.format(self.bitwidth(),\n-                                       self._llvm_bitwidth)\n+            return '::U{}_{}'.format(self.bitwidth(), self._llvm_bitwidth)\n+\n+    def compiler_ctor_ref(self):\n+        return '&' + self.compiler_ctor()\n \n     def llvm_name(self):\n         bw = self._llvm_bitwidth or self.bitwidth()\n@@ -200,7 +207,10 @@ def __init__(self, bitwidth):\n         Number.__init__(self, bitwidth)\n \n     def compiler_ctor(self):\n-        return 'f({})'.format(self.bitwidth())\n+        return '::F{}'.format(self.bitwidth())\n+\n+    def compiler_ctor_ref(self):\n+        return '&' + self.compiler_ctor()\n \n     def llvm_name(self):\n         return 'f{}'.format(self.bitwidth())\n@@ -244,12 +254,16 @@ def modify(self, spec, width, previous):\n \n     def compiler_ctor(self):\n         if self._bitcast is None:\n-            return 'v({}, {})'.format(self._elem.compiler_ctor(),\n-                                      self._length)\n+            return '{}x{}'.format(self._elem.compiler_ctor(),\n+                                     self._length)\n         else:\n-            return 'v_({}, {}, {})'.format(self._elem.compiler_ctor(),\n-                                           self._bitcast.compiler_ctor(),\n-                                           self._length)\n+            return '{}x{}_{}'.format(self._elem.compiler_ctor(),\n+                                     self._length,\n+                                     self._bitcast.compiler_ctor()\n+                                         .replace('::', ''))\n+\n+    def compiler_ctor_ref(self):\n+        return '&' + self.compiler_ctor()\n \n     def rust_name(self):\n         return '{}x{}'.format(self._elem.rust_name(), self._length)\n@@ -284,10 +298,14 @@ def compiler_ctor(self):\n         if self._llvm_elem is None:\n             llvm_elem = 'None'\n         else:\n-            llvm_elem = 'Some({})'.format(self._llvm_elem.compiler_ctor())\n-        return 'p({}, {}, {})'.format('true' if self._const else 'false',\n-                                      self._elem.compiler_ctor(),\n-                                      llvm_elem)\n+            llvm_elem = 'Some({})'.format(self._llvm_elem.compiler_ctor_ref())\n+        return 'Type::Pointer({}, {}, {})'.format(self._elem.compiler_ctor_ref(),\n+                                                  llvm_elem,\n+                                                  'true' if self._const else 'false')\n+\n+    def compiler_ctor_ref(self):\n+        return \"{{ static PTR: Type = {}; &PTR }}\".format(self.compiler_ctor())\n+\n \n     def rust_name(self):\n         return '*{} {}'.format('const' if self._const else 'mut',\n@@ -322,8 +340,14 @@ def modify(self, spec, width, previous):\n             raise NotImplementedError()\n \n     def compiler_ctor(self):\n-        return 'agg({}, vec![{}])'.format('true' if self._flatten else 'false',\n-                                          ', '.join(elem.compiler_ctor() for elem in self._elems))\n+        parts = \"{{ static PARTS: [&'static Type; {}] = [{}]; &PARTS }}\"\n+        elems = ', '.join(elem.compiler_ctor_ref() for elem in self._elems)\n+        parts = parts.format(len(self._elems), elems)\n+        return 'Type::Aggregate({}, {})'.format('true' if self._flatten else 'false',\n+                                                parts)\n+\n+    def compiler_ctor_ref(self):\n+        return \"{{ static AGG: Type = {}; &AGG }}\".format(self.compiler_ctor())\n \n     def rust_name(self):\n         return '({})'.format(', '.join(elem.rust_name() for elem in self._elems))\n@@ -518,10 +542,10 @@ def intrinsic_name(self):\n         return self._platform.platform().intrinsic_prefix() + self.intrinsic_suffix()\n \n     def compiler_args(self):\n-        return ', '.join(arg.compiler_ctor() for arg in self._args_raw)\n+        return ', '.join(arg.compiler_ctor_ref() for arg in self._args_raw)\n \n     def compiler_ret(self):\n-        return self._ret_raw.compiler_ctor()\n+        return self._ret_raw.compiler_ctor_ref()\n \n     def compiler_signature(self):\n         return '({}) -> {}'.format(self.compiler_args(), self.compiler_ret())\n@@ -733,7 +757,7 @@ def open(self, platform):\n \n #![allow(unused_imports)]\n \n-use {{Intrinsic, i, i_, u, u_, f, v, v_, agg, p, void}};\n+use {{Intrinsic, Type}};\n use IntrinsicDef::Named;\n use rustc::middle::ty::TyCtxt;\n \n@@ -747,10 +771,11 @@ def open(self, platform):\n     def render(self, mono):\n         return '''\\\n         \"{}\" => Intrinsic {{\n-            inputs: vec![{}],\n+            inputs: {{ static INPUTS: [&'static Type; {}] = [{}]; &INPUTS }},\n             output: {},\n             definition: Named(\"{}\")\n         }},'''.format(mono.intrinsic_suffix(),\n+                      len(mono._args_raw),\n                       mono.compiler_args(),\n                       mono.compiler_ret(),\n                       mono.llvm_name())"}, {"sha": "59986a905a2ecfc8eae21e08bd41d5df56cb3429", "filename": "src/librustc_platform_intrinsics/aarch64.rs", "status": "modified", "additions": 1357, "deletions": 1357, "changes": 2714, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Faarch64.rs?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28"}, {"sha": "d71f59e8e68cda2fc3077fb96293adabb6092b0a", "filename": "src/librustc_platform_intrinsics/arm.rs", "status": "modified", "additions": 825, "deletions": 825, "changes": 1650, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Farm.rs?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28"}, {"sha": "53976308bdc1933adef14b71372b2058752be4bb", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28", "patch": "@@ -14,15 +14,16 @@\n #![crate_type = \"rlib\"]\n #![feature(staged_api, rustc_private)]\n #![cfg_attr(not(stage0), deny(warnings))]\n+#![allow(bad_style)]\n \n extern crate rustc_llvm as llvm;\n extern crate rustc;\n \n use rustc::middle::ty::TyCtxt;\n \n pub struct Intrinsic {\n-    pub inputs: Vec<Type>,\n-    pub output: Type,\n+    pub inputs: &'static [&'static Type],\n+    pub output: &'static Type,\n \n     pub definition: IntrinsicDef,\n }\n@@ -32,34 +33,69 @@ pub enum Type {\n     Void,\n     Integer(/* signed */ bool, u8, /* llvm width */ u8),\n     Float(u8),\n-    Pointer(Box<Type>, Option<Box<Type>>, /* const */ bool),\n-    Vector(Box<Type>, Option<Box<Type>>, u8),\n-    Aggregate(bool, Vec<Type>),\n+    Pointer(&'static Type, Option<&'static Type>, /* const */ bool),\n+    Vector(&'static Type, Option<&'static Type>, u8),\n+    Aggregate(bool, &'static [&'static Type]),\n }\n \n pub enum IntrinsicDef {\n     Named(&'static str),\n }\n \n-fn i(width: u8) -> Type { Type::Integer(true, width, width) }\n-fn i_(width: u8, llvm_width: u8) -> Type { Type::Integer(true, width, llvm_width) }\n-fn u(width: u8) -> Type { Type::Integer(false, width, width) }\n-#[allow(dead_code)]\n-fn u_(width: u8, llvm_width: u8) -> Type { Type::Integer(false, width, llvm_width) }\n-fn f(width: u8) -> Type { Type::Float(width) }\n-fn v(x: Type, length: u8) -> Type { Type::Vector(Box::new(x), None, length) }\n-fn v_(x: Type, bitcast: Type, length: u8) -> Type {\n-    Type::Vector(Box::new(x), Some(Box::new(bitcast)), length)\n-}\n-fn agg(flatten: bool, types: Vec<Type>) -> Type {\n-    Type::Aggregate(flatten, types)\n-}\n-fn p(const_: bool, elem: Type, llvm_elem: Option<Type>) -> Type {\n-    Type::Pointer(Box::new(elem), llvm_elem.map(Box::new), const_)\n-}\n-fn void() -> Type {\n-    Type::Void\n-}\n+static I8: Type = Type::Integer(true, 8, 8);\n+static I16: Type = Type::Integer(true, 16, 16);\n+static I32: Type = Type::Integer(true, 32, 32);\n+static I64: Type = Type::Integer(true, 64, 64);\n+static U8: Type = Type::Integer(false, 8, 8);\n+static U16: Type = Type::Integer(false, 16, 16);\n+static U32: Type = Type::Integer(false, 32, 32);\n+static U64: Type = Type::Integer(false, 64, 64);\n+static F32: Type = Type::Float(32);\n+static F64: Type = Type::Float(64);\n+\n+static I32_8: Type = Type::Integer(true, 32, 8);\n+\n+static I8x8: Type = Type::Vector(&I8, None, 8);\n+static U8x8: Type = Type::Vector(&U8, None, 8);\n+static I8x16: Type = Type::Vector(&I8, None, 16);\n+static U8x16: Type = Type::Vector(&U8, None, 16);\n+static I8x32: Type = Type::Vector(&I8, None, 32);\n+static U8x32: Type = Type::Vector(&U8, None, 32);\n+\n+static I16x4: Type = Type::Vector(&I16, None, 4);\n+static U16x4: Type = Type::Vector(&U16, None, 4);\n+static I16x8: Type = Type::Vector(&I16, None, 8);\n+static U16x8: Type = Type::Vector(&U16, None, 8);\n+static I16x16: Type = Type::Vector(&I16, None, 16);\n+static U16x16: Type = Type::Vector(&U16, None, 16);\n+\n+static I32x2: Type = Type::Vector(&I32, None, 2);\n+static U32x2: Type = Type::Vector(&U32, None, 2);\n+static I32x4: Type = Type::Vector(&I32, None, 4);\n+static U32x4: Type = Type::Vector(&U32, None, 4);\n+static I32x8: Type = Type::Vector(&I32, None, 8);\n+static U32x8: Type = Type::Vector(&U32, None, 8);\n+\n+static I64x1: Type = Type::Vector(&I64, None, 1);\n+static U64x1: Type = Type::Vector(&U64, None, 1);\n+static I64x2: Type = Type::Vector(&I64, None, 2);\n+static U64x2: Type = Type::Vector(&U64, None, 2);\n+static I64x4: Type = Type::Vector(&I64, None, 4);\n+static U64x4: Type = Type::Vector(&U64, None, 4);\n+\n+static F32x2: Type = Type::Vector(&F32, None, 2);\n+static F32x4: Type = Type::Vector(&F32, None, 4);\n+static F32x8: Type = Type::Vector(&F32, None, 8);\n+static F64x1: Type = Type::Vector(&F64, None, 1);\n+static F64x2: Type = Type::Vector(&F64, None, 2);\n+static F64x4: Type = Type::Vector(&F64, None, 4);\n+\n+static I32x4_F32: Type = Type::Vector(&I32, Some(&F32), 4);\n+static I32x8_F32: Type = Type::Vector(&I32, Some(&F32), 8);\n+static I64x2_F64: Type = Type::Vector(&I64, Some(&F64), 2);\n+static I64x4_F64: Type = Type::Vector(&I64, Some(&F64), 4);\n+\n+static VOID: Type = Type::Void;\n \n mod x86;\n mod arm;"}, {"sha": "eccdc77f33c9d84a8534ae6a9d50c4a48573acf6", "filename": "src/librustc_platform_intrinsics/x86.rs", "status": "modified", "additions": 511, "deletions": 511, "changes": 1022, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_platform_intrinsics%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fx86.rs?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28", "patch": "@@ -13,7 +13,7 @@\n \n #![allow(unused_imports)]\n \n-use {Intrinsic, i, i_, u, u_, f, v, v_, agg, p, void};\n+use {Intrinsic, Type};\n use IntrinsicDef::Named;\n use rustc::middle::ty::TyCtxt;\n \n@@ -24,1278 +24,1278 @@ pub fn find<'tcx>(_tcx: &TyCtxt<'tcx>, name: &str) -> Option<Intrinsic> {\n     if !name.starts_with(\"x86_mm\") { return None }\n     Some(match &name[\"x86_mm\".len()..] {\n         \"_movemask_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse.movmsk.ps\")\n         },\n         \"_max_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse.max.ps\")\n         },\n         \"_min_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse.min.ps\")\n         },\n         \"_rsqrt_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse.rsqrt.ps\")\n         },\n         \"_rcp_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse.rcp.ps\")\n         },\n         \"_sqrt_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.sqrt.v4f32\")\n         },\n         \"_storeu_ps\" => Intrinsic {\n-            inputs: vec![p(false, f(32), Some(i(8))), v(f(32), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F32, Some(&::I8), false); &PTR }, &::F32x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse.storeu.ps\")\n         },\n         \"_adds_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse2.padds.b\")\n         },\n         \"_adds_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.paddus.b\")\n         },\n         \"_adds_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.padds.w\")\n         },\n         \"_adds_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse2.paddus.w\")\n         },\n         \"_avg_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.pavg.b\")\n         },\n         \"_avg_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse2.pavg.w\")\n         },\n         \"_lfence\" => Intrinsic {\n-            inputs: vec![],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.lfence\")\n         },\n         \"_madd_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.sse2.pmadd.wd\")\n         },\n         \"_maskmoveu_si128\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16), p(false, u(8), None)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U8x16, &::U8x16, { static PTR: Type = Type::Pointer(&::U8, None, false); &PTR }]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.maskmov.dqu\")\n         },\n         \"_max_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.pmaxs.w\")\n         },\n         \"_max_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.pmaxu.b\")\n         },\n         \"_max_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse2.max.pd\")\n         },\n         \"_mfence\" => Intrinsic {\n-            inputs: vec![],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.fence\")\n         },\n         \"_min_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.pmins.w\")\n         },\n         \"_min_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.pminu.b\")\n         },\n         \"_min_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse2.min.pd\")\n         },\n         \"_movemask_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse2.movmsk.pd\")\n         },\n         \"_movemask_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x16]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse2.pmovmskb.128\")\n         },\n         \"_mul_epu32\" => Intrinsic {\n-            inputs: vec![v(u(32), 4), v(u(32), 4)],\n-            output: v(u(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U64x2,\n             definition: Named(\"llvm.x86.sse2.pmulu.dq\")\n         },\n         \"_mulhi_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.pmulh.w\")\n         },\n         \"_mulhi_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse2.pmulhu.w\")\n         },\n         \"_packs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse2.packsswb.128\")\n         },\n         \"_packs_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.packssdw.128\")\n         },\n         \"_packus_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.packuswb.128\")\n         },\n         \"_sad_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U64x2,\n             definition: Named(\"llvm.x86.sse2.psad.bw\")\n         },\n         \"_sfence\" => Intrinsic {\n-            inputs: vec![],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.sfence\")\n         },\n         \"_sqrt_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.sqrt.v2f64\")\n         },\n         \"_storeu_pd\" => Intrinsic {\n-            inputs: vec![p(false, f(64), Some(u(8))), v(f(64), 2)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F64, Some(&::U8), false); &PTR }, &::F64x2]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.storeu.pd\")\n         },\n         \"_storeu_si128\" => Intrinsic {\n-            inputs: vec![p(false, v(u(8), 16), Some(u(8))), v(u(8), 16)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::U8x16, Some(&::U8), false); &PTR }, &::U8x16]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.sse2.storeu.dq\")\n         },\n         \"_subs_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse2.psubs.b\")\n         },\n         \"_subs_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16)],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse2.psubus.b\")\n         },\n         \"_subs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.sse2.psubs.w\")\n         },\n         \"_subs_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse2.psubus.w\")\n         },\n         \"_addsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse3.addsub.ps\")\n         },\n         \"_addsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse3.addsub.pd\")\n         },\n         \"_hadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse3.hadd.ps\")\n         },\n         \"_hadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse3.hadd.pd\")\n         },\n         \"_hsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse3.hsub.ps\")\n         },\n         \"_hsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse3.hsub.pd\")\n         },\n         \"_lddqu_si128\" => Intrinsic {\n-            inputs: vec![p(true, v(u(8), 16), Some(i(8)))],\n-            output: v(u(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 1] = [{ static PTR: Type = Type::Pointer(&::U8x16, Some(&::I8), true); &PTR }]; &INPUTS },\n+            output: &::U8x16,\n             definition: Named(\"llvm.x86.sse3.ldu.dq\")\n         },\n         \"_abs_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.ssse3.pabs.b.128\")\n         },\n         \"_abs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.pabs.w.128\")\n         },\n         \"_abs_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.ssse3.pabs.d.128\")\n         },\n         \"_hadd_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.phadd.w.128\")\n         },\n         \"_hadd_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.ssse3.phadd.d.128\")\n         },\n         \"_hadds_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.phadd.sw.128\")\n         },\n         \"_hsub_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.phsub.w.128\")\n         },\n         \"_hsub_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.ssse3.phsub.d.128\")\n         },\n         \"_hsubs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.phsub.sw.128\")\n         },\n         \"_maddubs_epi16\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(i(8), 16)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::I8x16]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.pmadd.ub.sw.128\")\n         },\n         \"_mulhrs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.pmul.hr.sw.128\")\n         },\n         \"_shuffle_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.ssse3.pshuf.b.128\")\n         },\n         \"_sign_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.ssse3.psign.b.128\")\n         },\n         \"_sign_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 8), v(i(16), 8)],\n-            output: v(i(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n             definition: Named(\"llvm.x86.ssse3.psign.w.128\")\n         },\n         \"_sign_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.ssse3.psign.d.128\")\n         },\n         \"_dp_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), i_(32, 8)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::I32_8]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.sse41.dpps\")\n         },\n         \"_dp_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), i_(32, 8)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::I32_8]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.sse41.dppd\")\n         },\n         \"_max_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse41.pmaxsb\")\n         },\n         \"_max_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse41.pmaxuw\")\n         },\n         \"_max_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.sse41.pmaxsd\")\n         },\n         \"_max_epu32\" => Intrinsic {\n-            inputs: vec![v(u(32), 4), v(u(32), 4)],\n-            output: v(u(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n             definition: Named(\"llvm.x86.sse41.pmaxud\")\n         },\n         \"_min_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse41.pminsb\")\n         },\n         \"_min_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8), v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse41.pminuw\")\n         },\n         \"_min_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.sse41.pminsd\")\n         },\n         \"_min_epu32\" => Intrinsic {\n-            inputs: vec![v(u(32), 4), v(u(32), 4)],\n-            output: v(u(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n             definition: Named(\"llvm.x86.sse41.pminud\")\n         },\n         \"_minpos_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::U16x8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse41.phminposuw\")\n         },\n         \"_mpsadbw_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 16), v(u(8), 16), i_(32, 8)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U8x16, &::U8x16, &::I32_8]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse41.mpsadbw\")\n         },\n         \"_mul_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(i(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I64x2,\n             definition: Named(\"llvm.x86.sse41.pmuldq\")\n         },\n         \"_packus_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), v(i(32), 4)],\n-            output: v(u(16), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::U16x8,\n             definition: Named(\"llvm.x86.sse41.packusdw\")\n         },\n         \"_testc_si128\" => Intrinsic {\n-            inputs: vec![v(u(64), 2), v(u(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x2, &::U64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse41.ptestc\")\n         },\n         \"_testnzc_si128\" => Intrinsic {\n-            inputs: vec![v(u(64), 2), v(u(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x2, &::U64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse41.ptestnzc\")\n         },\n         \"_testz_si128\" => Intrinsic {\n-            inputs: vec![v(u(64), 2), v(u(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x2, &::U64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse41.ptestz\")\n         },\n         \"_cmpestra\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestria128\")\n         },\n         \"_cmpestrc\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestric128\")\n         },\n         \"_cmpestri\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestri128\")\n         },\n         \"_cmpestrm\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse42.pcmpestrm128\")\n         },\n         \"_cmpestro\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestrio128\")\n         },\n         \"_cmpestrs\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestris128\")\n         },\n         \"_cmpestrz\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), i(32), v(i(8), 16), i(32), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I8x16, &::I32, &::I8x16, &::I32, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpestriz128\")\n         },\n         \"_cmpistra\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistria128\")\n         },\n         \"_cmpistrc\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistric128\")\n         },\n         \"_cmpistri\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistri128\")\n         },\n         \"_cmpistrm\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: v(i(8), 16),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I8x16,\n             definition: Named(\"llvm.x86.sse42.pcmpistrm128\")\n         },\n         \"_cmpistro\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistrio128\")\n         },\n         \"_cmpistrs\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistris128\")\n         },\n         \"_cmpistrz\" => Intrinsic {\n-            inputs: vec![v(i(8), 16), v(i(8), 16), i_(32, 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I8x16, &::I8x16, &::I32_8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.sse42.pcmpistriz128\")\n         },\n         \"256_addsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.addsub.ps.256\")\n         },\n         \"256_addsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.addsub.pd.256\")\n         },\n         \"256_blendv_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.blendv.ps.256\")\n         },\n         \"256_blendv_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.blendv.pd.256\")\n         },\n         \"256_broadcast_ps\" => Intrinsic {\n-            inputs: vec![p(true, i(8), None)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [{ static PTR: Type = Type::Pointer(&::I8, None, true); &PTR }]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.vbroadcastf128.ps.256\")\n         },\n         \"256_broadcast_pd\" => Intrinsic {\n-            inputs: vec![p(true, i(8), None)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [{ static PTR: Type = Type::Pointer(&::I8, None, true); &PTR }]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.vbroadcastf128.pd.256\")\n         },\n         \"256_cmp_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), i(8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::I8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.cmp.ps.256\")\n         },\n         \"256_cmp_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), i(8)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::I8]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.cmp.pd.256\")\n         },\n         \"256_cvtepi32_pd\" => Intrinsic {\n-            inputs: vec![v(i(32), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I32x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.cvtdq2.pd.256\")\n         },\n         \"256_cvtepi32_ps\" => Intrinsic {\n-            inputs: vec![v(i(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.cvtdq2.ps.256\")\n         },\n         \"256_cvtpd_epi32\" => Intrinsic {\n-            inputs: vec![v(f(64), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx.cvt.pd2dq.256\")\n         },\n         \"256_cvtpd_ps\" => Intrinsic {\n-            inputs: vec![v(f(64), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx.cvt.pd2.ps.256\")\n         },\n         \"256_cvtps_epi32\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx.cvt.ps2dq.256\")\n         },\n         \"256_cvtps_pd\" => Intrinsic {\n-            inputs: vec![v(f(32), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.cvt.ps2.pd.256\")\n         },\n         \"256_cvttpd_epi32\" => Intrinsic {\n-            inputs: vec![v(f(64), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx.cvtt.pd2dq.256\")\n         },\n         \"256_cvttps_epi32\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx.cvtt.ps2dq.256\")\n         },\n         \"256_dp_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), i_(32, 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::I32_8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.dp.ps.256\")\n         },\n         \"256_hadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.hadd.ps.256\")\n         },\n         \"256_hadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.hadd.pd.256\")\n         },\n         \"256_hsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.hsub.ps.256\")\n         },\n         \"256_hsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.hsub.pd.256\")\n         },\n         \"256_max_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.max.ps.256\")\n         },\n         \"256_max_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.max.pd.256\")\n         },\n         \"_maskload_ps\" => Intrinsic {\n-            inputs: vec![p(true, f(32), Some(i(8))), v_(i(32), f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I32x4_F32]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx.maskload.ps\")\n         },\n         \"_maskload_pd\" => Intrinsic {\n-            inputs: vec![p(true, f(64), Some(i(8))), v_(i(64), f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I64x2_F64]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.avx.maskload.pd\")\n         },\n         \"256_maskload_ps\" => Intrinsic {\n-            inputs: vec![p(true, f(32), Some(i(8))), v_(i(32), f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I32x8_F32]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.maskload.ps.256\")\n         },\n         \"256_maskload_pd\" => Intrinsic {\n-            inputs: vec![p(true, f(64), Some(i(8))), v_(i(64), f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I64x4_F64]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.maskload.pd.256\")\n         },\n         \"_maskstore_ps\" => Intrinsic {\n-            inputs: vec![p(false, f(32), Some(i(8))), v_(i(32), f(32), 4), v(f(32), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::F32, Some(&::I8), false); &PTR }, &::I32x4_F32, &::F32x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.maskstore.ps\")\n         },\n         \"_maskstore_pd\" => Intrinsic {\n-            inputs: vec![p(false, f(64), Some(i(8))), v_(i(64), f(64), 2), v(f(64), 2)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::F64, Some(&::I8), false); &PTR }, &::I64x2_F64, &::F64x2]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.maskstore.pd\")\n         },\n         \"256_maskstore_ps\" => Intrinsic {\n-            inputs: vec![p(false, f(32), Some(i(8))), v_(i(32), f(32), 8), v(f(32), 8)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::F32, Some(&::I8), false); &PTR }, &::I32x8_F32, &::F32x8]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.maskstore.ps.256\")\n         },\n         \"256_maskstore_pd\" => Intrinsic {\n-            inputs: vec![p(false, f(64), Some(i(8))), v_(i(64), f(64), 4), v(f(64), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::F64, Some(&::I8), false); &PTR }, &::I64x4_F64, &::F64x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.maskstore.pd.256\")\n         },\n         \"256_min_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.min.ps.256\")\n         },\n         \"256_min_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.min.pd.256\")\n         },\n         \"256_movemask_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.movmsk.ps.256\")\n         },\n         \"256_movemask_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.movmsk.pd.256\")\n         },\n         \"_permutevar_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(i(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::I32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx.vpermilvar.ps\")\n         },\n         \"_permutevar_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(i(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::I64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.avx.vpermilvar.pd\")\n         },\n         \"256_permutevar_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(i(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::I32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.vpermilvar.ps.256\")\n         },\n         \"256_permutevar_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(i(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::I64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx.vpermilvar.pd.256\")\n         },\n         \"256_rcp_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.rcp.ps.256\")\n         },\n         \"256_rsqrt_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx.rsqrt.ps.256\")\n         },\n         \"256_storeu_ps\" => Intrinsic {\n-            inputs: vec![p(false, v(f(32), 8), Some(u(8))), v(f(32), 8)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F32x8, Some(&::U8), false); &PTR }, &::F32x8]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.storeu.ps.256\")\n         },\n         \"256_storeu_pd\" => Intrinsic {\n-            inputs: vec![p(false, v(f(64), 4), Some(u(8))), v(f(64), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::F64x4, Some(&::U8), false); &PTR }, &::F64x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.storeu.ps.256\")\n         },\n         \"256_storeu_si256\" => Intrinsic {\n-            inputs: vec![p(false, v(u(8), 32), Some(u(8))), v(u(8), 32)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::U8x32, Some(&::U8), false); &PTR }, &::U8x32]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.storeu.dq.256\")\n         },\n         \"256_sqrt_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.sqrt.v8f32\")\n         },\n         \"256_sqrt_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.sqrt.v4f64\")\n         },\n         \"_testc_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestc.ps\")\n         },\n         \"256_testc_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestc.ps.256\")\n         },\n         \"_testc_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestc.pd\")\n         },\n         \"256_testc_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestc.pd.256\")\n         },\n         \"256_testc_si256\" => Intrinsic {\n-            inputs: vec![v(u(64), 4), v(u(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x4, &::U64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.ptestc.256\")\n         },\n         \"_testnzc_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestnzc.ps\")\n         },\n         \"256_testnzc_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestnzc.ps.256\")\n         },\n         \"_testnzc_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestnzc.pd\")\n         },\n         \"256_testnzc_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestnzc.pd.256\")\n         },\n         \"256_testnzc_si256\" => Intrinsic {\n-            inputs: vec![v(u(64), 4), v(u(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x4, &::U64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.ptestnzc.256\")\n         },\n         \"_testz_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestz.ps\")\n         },\n         \"256_testz_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::F32x8]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestz.ps.256\")\n         },\n         \"_testz_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x2, &::F64x2]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestz.pd\")\n         },\n         \"256_testz_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F64x4, &::F64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.vtestz.pd.256\")\n         },\n         \"256_testz_si256\" => Intrinsic {\n-            inputs: vec![v(u(64), 4), v(u(64), 4)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U64x4, &::U64x4]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx.ptestz.256\")\n         },\n         \"256_zeroall\" => Intrinsic {\n-            inputs: vec![],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.vzeroall\")\n         },\n         \"256_zeroupper\" => Intrinsic {\n-            inputs: vec![],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx.vzeroupper\")\n         },\n         \"256_abs_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.pabs.b\")\n         },\n         \"256_abs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pabs.w\")\n         },\n         \"256_abs_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.pabs.d\")\n         },\n         \"256_adds_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.padds.b\")\n         },\n         \"256_adds_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.paddus.b\")\n         },\n         \"256_adds_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.padds.w\")\n         },\n         \"256_adds_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.paddus.w\")\n         },\n         \"256_avg_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.pavg.b\")\n         },\n         \"256_avg_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.pavg.w\")\n         },\n         \"256_hadd_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.phadd.w\")\n         },\n         \"256_hadd_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.phadd.d\")\n         },\n         \"256_hadds_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.phadd.sw\")\n         },\n         \"256_hsub_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.phsub.w\")\n         },\n         \"256_hsub_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.phsub.d\")\n         },\n         \"256_hsubs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.phsub.sw\")\n         },\n         \"256_madd_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.pmadd.wd\")\n         },\n         \"256_maddubs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pmadd.ub.sw\")\n         },\n         \"_mask_i32gather_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), p(true, i(32), Some(i(8))), v(i(32), 4), v(i(32), 4), i_(32, 8)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I32x4, { static PTR: Type = Type::Pointer(&::I32, Some(&::I8), true); &PTR }, &::I32x4, &::I32x4, &::I32_8]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx2.gather.d.d\")\n         },\n         \"_mask_i32gather_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), p(true, f(32), Some(i(8))), v(i(32), 4), v_(i(32), f(32), 4), i_(32, 8)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F32x4, { static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I32x4, &::I32x4_F32, &::I32_8]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx2.gather.d.ps\")\n         },\n         \"256_mask_i32gather_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), p(true, i(32), Some(i(8))), v(i(32), 8), v(i(32), 8), i_(32, 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I32x8, { static PTR: Type = Type::Pointer(&::I32, Some(&::I8), true); &PTR }, &::I32x8, &::I32x8, &::I32_8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.gather.d.d.256\")\n         },\n         \"256_mask_i32gather_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), p(true, f(32), Some(i(8))), v(i(32), 8), v_(i(32), f(32), 8), i_(32, 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F32x8, { static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I32x8, &::I32x8_F32, &::I32_8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx2.gather.d.ps.256\")\n         },\n         \"_mask_i32gather_epi64\" => Intrinsic {\n-            inputs: vec![v(i(64), 2), p(true, i(64), Some(i(8))), v(i(32), 4), v(i(64), 2), i_(32, 8)],\n-            output: v(i(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I64x2, { static PTR: Type = Type::Pointer(&::I64, Some(&::I8), true); &PTR }, &::I32x4, &::I64x2, &::I32_8]; &INPUTS },\n+            output: &::I64x2,\n             definition: Named(\"llvm.x86.avx2.gather.d.q\")\n         },\n         \"_mask_i32gather_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), p(true, f(64), Some(i(8))), v(i(32), 4), v_(i(64), f(64), 2), i_(32, 8)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F64x2, { static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I32x4, &::I64x2_F64, &::I32_8]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.avx2.gather.d.pd\")\n         },\n         \"256_mask_i32gather_epi64\" => Intrinsic {\n-            inputs: vec![v(i(64), 4), p(true, i(64), Some(i(8))), v(i(32), 4), v(i(64), 4), i_(32, 8)],\n-            output: v(i(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I64x4, { static PTR: Type = Type::Pointer(&::I64, Some(&::I8), true); &PTR }, &::I32x4, &::I64x4, &::I32_8]; &INPUTS },\n+            output: &::I64x4,\n             definition: Named(\"llvm.x86.avx2.gather.d.q.256\")\n         },\n         \"256_mask_i32gather_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), p(true, f(64), Some(i(8))), v(i(32), 4), v_(i(64), f(64), 4), i_(32, 8)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F64x4, { static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I32x4, &::I64x4_F64, &::I32_8]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx2.gather.d.pd.256\")\n         },\n         \"_mask_i64gather_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), p(true, i(32), Some(i(8))), v(i(64), 2), v(i(32), 4), i_(32, 8)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I32x4, { static PTR: Type = Type::Pointer(&::I32, Some(&::I8), true); &PTR }, &::I64x2, &::I32x4, &::I32_8]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.d\")\n         },\n         \"_mask_i64gather_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), p(true, f(32), Some(i(8))), v(i(64), 2), v_(i(32), f(32), 4), i_(32, 8)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F32x4, { static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I64x2, &::I32x4_F32, &::I32_8]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.ps\")\n         },\n         \"256_mask_i64gather_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 4), p(true, i(32), Some(i(8))), v(i(64), 4), v(i(32), 4), i_(32, 8)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I32x4, { static PTR: Type = Type::Pointer(&::I32, Some(&::I8), true); &PTR }, &::I64x4, &::I32x4, &::I32_8]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.d\")\n         },\n         \"256_mask_i64gather_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), p(true, f(32), Some(i(8))), v(i(64), 4), v_(i(32), f(32), 4), i_(32, 8)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F32x4, { static PTR: Type = Type::Pointer(&::F32, Some(&::I8), true); &PTR }, &::I64x4, &::I32x4_F32, &::I32_8]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.ps\")\n         },\n         \"_mask_i64gather_epi64\" => Intrinsic {\n-            inputs: vec![v(i(64), 2), p(true, i(64), Some(i(8))), v(i(64), 2), v(i(64), 2), i_(32, 8)],\n-            output: v(i(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I64x2, { static PTR: Type = Type::Pointer(&::I64, Some(&::I8), true); &PTR }, &::I64x2, &::I64x2, &::I32_8]; &INPUTS },\n+            output: &::I64x2,\n             definition: Named(\"llvm.x86.avx2.gather.q.q\")\n         },\n         \"_mask_i64gather_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), p(true, f(64), Some(i(8))), v(i(64), 2), v_(i(64), f(64), 2), i_(32, 8)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F64x2, { static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I64x2, &::I64x2_F64, &::I32_8]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.avx2.gather.q.pd\")\n         },\n         \"256_mask_i64gather_epi64\" => Intrinsic {\n-            inputs: vec![v(i(64), 4), p(true, i(64), Some(i(8))), v(i(64), 4), v(i(64), 4), i_(32, 8)],\n-            output: v(i(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::I64x4, { static PTR: Type = Type::Pointer(&::I64, Some(&::I8), true); &PTR }, &::I64x4, &::I64x4, &::I32_8]; &INPUTS },\n+            output: &::I64x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.q.256\")\n         },\n         \"256_mask_i64gather_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), p(true, f(64), Some(i(8))), v(i(64), 4), v_(i(64), f(64), 4), i_(32, 8)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 5] = [&::F64x4, { static PTR: Type = Type::Pointer(&::F64, Some(&::I8), true); &PTR }, &::I64x4, &::I64x4_F64, &::I32_8]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.avx2.gather.q.pd.256\")\n         },\n         \"_maskload_epi32\" => Intrinsic {\n-            inputs: vec![p(true, v(i(32), 4), Some(i(8))), v(i(32), 4)],\n-            output: v(i(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::I32x4, Some(&::I8), true); &PTR }, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n             definition: Named(\"llvm.x86.avx2.maskload.d\")\n         },\n         \"_maskload_epi64\" => Intrinsic {\n-            inputs: vec![p(true, v(i(64), 2), Some(i(8))), v(i(64), 2)],\n-            output: v(i(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::I64x2, Some(&::I8), true); &PTR }, &::I64x2]; &INPUTS },\n+            output: &::I64x2,\n             definition: Named(\"llvm.x86.avx2.maskload.q\")\n         },\n         \"256_maskload_epi32\" => Intrinsic {\n-            inputs: vec![p(true, v(i(32), 8), Some(i(8))), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::I32x8, Some(&::I8), true); &PTR }, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.maskload.d.256\")\n         },\n         \"256_maskload_epi64\" => Intrinsic {\n-            inputs: vec![p(true, v(i(64), 4), Some(i(8))), v(i(64), 4)],\n-            output: v(i(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [{ static PTR: Type = Type::Pointer(&::I64x4, Some(&::I8), true); &PTR }, &::I64x4]; &INPUTS },\n+            output: &::I64x4,\n             definition: Named(\"llvm.x86.avx2.maskload.q.256\")\n         },\n         \"_maskstore_epi32\" => Intrinsic {\n-            inputs: vec![p(false, i(32), Some(i(8))), v(i(32), 4), v(i(32), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::I32, Some(&::I8), false); &PTR }, &::I32x4, &::I32x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx2.maskstore.d\")\n         },\n         \"_maskstore_epi64\" => Intrinsic {\n-            inputs: vec![p(false, i(64), Some(i(8))), v(i(64), 2), v(i(64), 2)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::I64, Some(&::I8), false); &PTR }, &::I64x2, &::I64x2]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx2.maskstore.q\")\n         },\n         \"256_maskstore_epi32\" => Intrinsic {\n-            inputs: vec![p(false, i(32), Some(i(8))), v(i(32), 8), v(i(32), 8)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::I32, Some(&::I8), false); &PTR }, &::I32x8, &::I32x8]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx2.maskstore.d.256\")\n         },\n         \"256_maskstore_epi64\" => Intrinsic {\n-            inputs: vec![p(false, i(64), Some(i(8))), v(i(64), 4), v(i(64), 4)],\n-            output: void(),\n+            inputs: { static INPUTS: [&'static Type; 3] = [{ static PTR: Type = Type::Pointer(&::I64, Some(&::I8), false); &PTR }, &::I64x4, &::I64x4]; &INPUTS },\n+            output: &::VOID,\n             definition: Named(\"llvm.x86.avx2.maskstore.q.256\")\n         },\n         \"256_max_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.pmaxs.b\")\n         },\n         \"256_max_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.pmaxu.b\")\n         },\n         \"256_max_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pmaxs.w\")\n         },\n         \"256_max_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.pmaxu.w\")\n         },\n         \"256_max_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.pmaxs.d\")\n         },\n         \"256_max_epu32\" => Intrinsic {\n-            inputs: vec![v(u(32), 8), v(u(32), 8)],\n-            output: v(u(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x8, &::U32x8]; &INPUTS },\n+            output: &::U32x8,\n             definition: Named(\"llvm.x86.avx2.pmaxu.d\")\n         },\n         \"256_min_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.pmins.b\")\n         },\n         \"256_min_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.pminu.b\")\n         },\n         \"256_min_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pmins.w\")\n         },\n         \"256_min_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.pminu.w\")\n         },\n         \"256_min_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.pmins.d\")\n         },\n         \"256_min_epu32\" => Intrinsic {\n-            inputs: vec![v(u(32), 8), v(u(32), 8)],\n-            output: v(u(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x8, &::U32x8]; &INPUTS },\n+            output: &::U32x8,\n             definition: Named(\"llvm.x86.avx2.pminu.d\")\n         },\n         \"256_movemask_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32)],\n-            output: i(32),\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x32]; &INPUTS },\n+            output: &::I32,\n             definition: Named(\"llvm.x86.avx2.pmovmskb\")\n         },\n         \"256_mpsadbw_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32), i_(32, 8)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::U8x32, &::U8x32, &::I32_8]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.mpsadbw\")\n         },\n         \"256_mul_epi64\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I64x4,\n             definition: Named(\"llvm.x86.avx2.pmulq.dq\")\n         },\n         \"256_mul_epu64\" => Intrinsic {\n-            inputs: vec![v(u(32), 8), v(u(32), 8)],\n-            output: v(u(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x8, &::U32x8]; &INPUTS },\n+            output: &::U64x4,\n             definition: Named(\"llvm.x86.avx2.pmulq.dq\")\n         },\n         \"256_mulhi_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pmulhw.w\")\n         },\n         \"256_mulhi_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.pmulhw.w\")\n         },\n         \"256_mulhrs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.pmul.hr.sw\")\n         },\n         \"256_packs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.packsswb\")\n         },\n         \"256_packus_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.packuswb\")\n         },\n         \"256_packs_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.packssdw\")\n         },\n         \"256_packus_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.packusdw\")\n         },\n         \"256_permutevar8x32_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.permd\")\n         },\n         \"256_permutevar8x32_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(i(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x8, &::I32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.avx2.permps\")\n         },\n         \"256_sad_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.psad.bw\")\n         },\n         \"256_shuffle_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.pshuf.b\")\n         },\n         \"256_sign_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.psign.b\")\n         },\n         \"256_sign_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.psign.w\")\n         },\n         \"256_sign_epi32\" => Intrinsic {\n-            inputs: vec![v(i(32), 8), v(i(32), 8)],\n-            output: v(i(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x8, &::I32x8]; &INPUTS },\n+            output: &::I32x8,\n             definition: Named(\"llvm.x86.avx2.psign.d\")\n         },\n         \"256_subs_epi8\" => Intrinsic {\n-            inputs: vec![v(i(8), 32), v(i(8), 32)],\n-            output: v(i(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x32, &::I8x32]; &INPUTS },\n+            output: &::I8x32,\n             definition: Named(\"llvm.x86.avx2.psubs.b\")\n         },\n         \"256_subs_epu8\" => Intrinsic {\n-            inputs: vec![v(u(8), 32), v(u(8), 32)],\n-            output: v(u(8), 32),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x32, &::U8x32]; &INPUTS },\n+            output: &::U8x32,\n             definition: Named(\"llvm.x86.avx2.psubus.b\")\n         },\n         \"256_subs_epi16\" => Intrinsic {\n-            inputs: vec![v(i(16), 16), v(i(16), 16)],\n-            output: v(i(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x16, &::I16x16]; &INPUTS },\n+            output: &::I16x16,\n             definition: Named(\"llvm.x86.avx2.psubs.w\")\n         },\n         \"256_subs_epu16\" => Intrinsic {\n-            inputs: vec![v(u(16), 16), v(u(16), 16)],\n-            output: v(u(16), 16),\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x16, &::U16x16]; &INPUTS },\n+            output: &::U16x16,\n             definition: Named(\"llvm.x86.avx2.psubus.w\")\n         },\n         \"_fmadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfmadd.ps\")\n         },\n         \"_fmadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfmadd.pd\")\n         },\n         \"256_fmadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfmadd.ps.256\")\n         },\n         \"256_fmadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfmadd.pd.256\")\n         },\n         \"_fmaddsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfmaddsub.ps\")\n         },\n         \"_fmaddsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfmaddsub.pd\")\n         },\n         \"256_fmaddsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfmaddsub.ps.256\")\n         },\n         \"256_fmaddsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfmaddsub.pd.256\")\n         },\n         \"_fmsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfmsub.ps\")\n         },\n         \"_fmsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfmsub.pd\")\n         },\n         \"256_fmsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfmsub.ps.256\")\n         },\n         \"256_fmsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfmsub.pd.256\")\n         },\n         \"_fmsubadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfmsubadd.ps\")\n         },\n         \"_fmsubadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfmsubadd.pd\")\n         },\n         \"256_fmsubadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfmsubadd.ps.256\")\n         },\n         \"256_fmsubadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfmsubadd.pd.256\")\n         },\n         \"_fnmadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfnmadd.ps\")\n         },\n         \"_fnmadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfnmadd.pd\")\n         },\n         \"256_fnmadd_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfnmadd.ps.256\")\n         },\n         \"256_fnmadd_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfnmadd.pd.256\")\n         },\n         \"_fnmsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 4), v(f(32), 4), v(f(32), 4)],\n-            output: v(f(32), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x4, &::F32x4, &::F32x4]; &INPUTS },\n+            output: &::F32x4,\n             definition: Named(\"llvm.x86.fma.vfnmsub.ps\")\n         },\n         \"_fnmsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 2), v(f(64), 2), v(f(64), 2)],\n-            output: v(f(64), 2),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x2, &::F64x2, &::F64x2]; &INPUTS },\n+            output: &::F64x2,\n             definition: Named(\"llvm.x86.fma.vfnmsub.pd\")\n         },\n         \"256_fnmsub_ps\" => Intrinsic {\n-            inputs: vec![v(f(32), 8), v(f(32), 8), v(f(32), 8)],\n-            output: v(f(32), 8),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F32x8, &::F32x8, &::F32x8]; &INPUTS },\n+            output: &::F32x8,\n             definition: Named(\"llvm.x86.fma.vfnmsub.ps.256\")\n         },\n         \"256_fnmsub_pd\" => Intrinsic {\n-            inputs: vec![v(f(64), 4), v(f(64), 4), v(f(64), 4)],\n-            output: v(f(64), 4),\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::F64x4, &::F64x4, &::F64x4]; &INPUTS },\n+            output: &::F64x4,\n             definition: Named(\"llvm.x86.fma.vfnmsub.pd.256\")\n         },\n         _ => return None,"}, {"sha": "ca9833f6f9d69cf72c1a5211e70ef565e20f14c9", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0986d645b9d3f01e102c84fb91abf42de00e7b28/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=0986d645b9d3f01e102c84fb91abf42de00e7b28", "patch": "@@ -955,7 +955,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            match intr.output {\n+            match *intr.output {\n                 intrinsics::Type::Aggregate(flatten, ref elems) => {\n                     // the output is a tuple so we need to munge it properly\n                     assert!(!flatten);"}]}