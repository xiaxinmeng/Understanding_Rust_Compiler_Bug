{"sha": "ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMjNiZWI1MmY2MzdiOGM4NjQwNzA2ZWU4YzZkMmQ0YTU3OTZiYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T16:54:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T16:54:59Z"}, "message": "auto merge of #7167 : nikomatsakis/rust/ref-bindings-explicit-copy-in-generics, r=brson\n\nTwo changes:\r\n\r\n1. Make type parameters move by default, even if they have a Copy bound. After all, they could be bound to `~T` or `~[]`. Also, this is a necessary step towards removing `copy` keyword and replacing with clone.\r\n\r\n2. Make it illegal to move from `*T`. This is dangerous in a \"moves-by-default\" scenario, because it's very easy to move when working with a `*T` pointer. Also, it requires zeroing memory, which we hope to do away with someday.", "tree": {"sha": "86c72c3bb92054b0ba9aff59cbe9c0391eb88c99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c72c3bb92054b0ba9aff59cbe9c0391eb88c99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "html_url": "https://github.com/rust-lang/rust/commit/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900de0ffaded223c0ed75188226e499e332416be", "url": "https://api.github.com/repos/rust-lang/rust/commits/900de0ffaded223c0ed75188226e499e332416be", "html_url": "https://github.com/rust-lang/rust/commit/900de0ffaded223c0ed75188226e499e332416be"}, {"sha": "bada191309d43d481d265bb1ff9c3a14e827babf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bada191309d43d481d265bb1ff9c3a14e827babf", "html_url": "https://github.com/rust-lang/rust/commit/bada191309d43d481d265bb1ff9c3a14e827babf"}], "stats": {"total": 834, "additions": 405, "deletions": 429}, "files": [{"sha": "baae56c4f4093a816827438ad033eb8fb1ab2384", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -111,7 +111,7 @@ ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += --save-temps\n endif\n ifdef ASM_COMMENTS\n-  CFG_RUSTC_FLAGS += -z asm-comments\n+  CFG_RUSTC_FLAGS += -Z asm-comments\n endif\n ifdef TIME_PASSES\n   CFG_RUSTC_FLAGS += -Z time-passes"}, {"sha": "9edbc44d6c21df1e530190c6cffd42bb86d7ddaa", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -2826,7 +2826,7 @@ Within the body of an item that has type parameter declarations, the names of it\n ~~~~~~~\n fn map<A: Copy, B: Copy>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n-   let first: B = f(xs[0]);\n+   let first: B = f(copy xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n    return ~[first] + rest;\n }"}, {"sha": "f69f569faee43cc14869ddd6b21039b44b0c48ab", "filename": "doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -1941,12 +1941,14 @@ fn head_bad<T>(v: &[T]) -> T {\n ~~~~\n \n However, we can tell the compiler that the `head` function is only for\n-copyable types: that is, those that have the `Copy` trait.\n+copyable types: that is, those that have the `Copy` trait. In that\n+case, we can explicitly create a second copy of the value we are\n+returning using the `copy` keyword:\n \n ~~~~\n // This does\n fn head<T: Copy>(v: &[T]) -> T {\n-    v[0]\n+    copy v[0]\n }\n ~~~~\n \n@@ -2137,7 +2139,7 @@ as in this version of `print_all` that copies elements.\n fn print_all<T: Printable + Copy>(printable_things: ~[T]) {\n     let mut i = 0;\n     while i < printable_things.len() {\n-        let copy_of_thing = printable_things[i];\n+        let copy_of_thing = copy printable_things[i];\n         copy_of_thing.print();\n         i += 1;\n     }"}, {"sha": "fd48e7d5958d4a1b30719619656c46fa93d3746a", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -122,7 +122,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  */\n pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert!(ofs < len(t));\n-    return unsafe { *ptr::mut_offset(t.base, ofs) };\n+    return unsafe { copy *ptr::mut_offset(t.base, ofs) };\n }\n \n /**"}, {"sha": "c8bb984736a11f3c3575b4724edb121c717786b6", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -264,31 +264,31 @@ mod tests {\n     fn test_parameterized<T:Copy + Eq>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n         assert_eq!(deq.len(), 0);\n-        deq.add_front(a);\n-        deq.add_front(b);\n-        deq.add_back(c);\n+        deq.add_front(copy a);\n+        deq.add_front(copy b);\n+        deq.add_back(copy c);\n         assert_eq!(deq.len(), 3);\n-        deq.add_back(d);\n+        deq.add_back(copy d);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.peek_front(), b);\n-        assert_eq!(*deq.peek_back(), d);\n-        assert_eq!(deq.pop_front(), b);\n-        assert_eq!(deq.pop_back(), d);\n-        assert_eq!(deq.pop_back(), c);\n-        assert_eq!(deq.pop_back(), a);\n+        assert_eq!(copy *deq.peek_front(), copy b);\n+        assert_eq!(copy *deq.peek_back(), copy d);\n+        assert_eq!(deq.pop_front(), copy b);\n+        assert_eq!(deq.pop_back(), copy d);\n+        assert_eq!(deq.pop_back(), copy c);\n+        assert_eq!(deq.pop_back(), copy a);\n         assert_eq!(deq.len(), 0);\n-        deq.add_back(c);\n+        deq.add_back(copy c);\n         assert_eq!(deq.len(), 1);\n-        deq.add_front(b);\n+        deq.add_front(copy b);\n         assert_eq!(deq.len(), 2);\n-        deq.add_back(d);\n+        deq.add_back(copy d);\n         assert_eq!(deq.len(), 3);\n-        deq.add_front(a);\n+        deq.add_front(copy a);\n         assert_eq!(deq.len(), 4);\n-        assert_eq!(*deq.get(0), a);\n-        assert_eq!(*deq.get(1), b);\n-        assert_eq!(*deq.get(2), c);\n-        assert_eq!(*deq.get(3), d);\n+        assert_eq!(copy *deq.get(0), copy a);\n+        assert_eq!(copy *deq.get(1), copy b);\n+        assert_eq!(copy *deq.get(2), copy c);\n+        assert_eq!(copy *deq.get(3), copy d);\n     }\n \n     #[deriving(Eq)]"}, {"sha": "a67b17388198758d6b5d7ed5654e19989d718ba3", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -111,7 +111,8 @@ pub fn from_elem<T>(data: T) -> @mut DList<T> {\n /// Creates a new dlist from a vector of elements, maintaining the same order\n pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n     do vec.iter().fold(DList()) |list,data| {\n-        list.push(*data); // Iterating left-to-right -- add newly to the tail.\n+        // Iterating left-to-right -- add newly to the tail.\n+        list.push(copy *data);\n         list\n     }\n }\n@@ -460,35 +461,35 @@ impl<T> DList<T> {\n impl<T:Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n     pub fn pop(@mut self) -> Option<T> {\n-        self.pop_n().map(|nobe| nobe.data)\n+        self.pop_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Remove data from the tail of the list. O(1).\n     pub fn pop_tail(@mut self) -> Option<T> {\n-        self.pop_tail_n().map(|nobe| nobe.data)\n+        self.pop_tail_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's head. O(1).\n     pub fn peek(@mut self) -> Option<T> {\n-        self.peek_n().map(|nobe| nobe.data)\n+        self.peek_n().map(|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n     pub fn peek_tail(@mut self) -> Option<T> {\n-        self.peek_tail_n().map (|nobe| nobe.data)\n+        self.peek_tail_n().map (|nobe| copy nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    pub fn head(@mut self) -> T { self.head_n().data }\n+    pub fn head(@mut self) -> T { copy self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    pub fn tail(@mut self) -> T { self.tail_n().data }\n+    pub fn tail(@mut self) -> T { copy self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n     pub fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         for old_iter::eachi(&self) |index,data| {\n-            v[index] = *data;\n+            v[index] = copy *data;\n         }\n         v\n     }"}, {"sha": "4652e1d6477015d53dc57317f9b5234587dfe9ec", "filename": "src/libextra/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -57,7 +57,7 @@ priv enum FutureState<A> {\n impl<A:Copy> Future<A> {\n     pub fn get(&mut self) -> A {\n         //! Get the value of the future.\n-        *(self.get_ref())\n+        copy *(self.get_ref())\n     }\n }\n "}, {"sha": "34c35e0d7fde2524bfc6e899ffee06bd55d463bd", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -27,7 +27,7 @@ pub enum MutList<T> {\n \n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(*h, t))\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(copy *h, t))\n }\n \n /**\n@@ -61,7 +61,7 @@ pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     loop {\n         ls = match *ls {\n           Cons(ref hd, tl) => {\n-            if f(hd) { return Some(*hd); }\n+            if f(hd) { return Some(copy *hd); }\n             tl\n           }\n           Nil => return None"}, {"sha": "aee087d3764db0121565030e37a10a65f7b54171", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -179,7 +179,7 @@ impl<V:Copy> SmallIntMap<V> {\n                            ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n-            Some(orig) => ff(key, *orig, val)\n+            Some(orig) => ff(key, copy *orig, val)\n         };\n         self.insert(key, new_val)\n     }"}, {"sha": "b5645d9c5017eb63b74d50c99ba54aa18a31077b", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -37,7 +37,7 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n \n         let v_len = end - begin;\n         if v_len == 0 { return ~[]; }\n-        if v_len == 1 { return ~[v[begin]]; }\n+        if v_len == 1 { return ~[copy v[begin]]; }\n \n         let mid = v_len / 2 + begin;\n         let a = (begin, mid);\n@@ -53,9 +53,9 @@ pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n         let mut b_ix = 0;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n-                rs.push(a[a_ix]);\n+                rs.push(copy a[a_ix]);\n                 a_ix += 1;\n-            } else { rs.push(b[b_ix]); b_ix += 1; }\n+            } else { rs.push(copy b[b_ix]); b_ix += 1; }\n         }\n         rs.push_all(vec::slice(a, a_ix, a_len));\n         rs.push_all(vec::slice(b, b_ix, b_len));\n@@ -106,7 +106,7 @@ pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n \n fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n-    let v: T = arr[right];\n+    let v: T = copy arr[right];\n     let mut i: int = left - 1;\n     let mut j: int = right;\n     let mut p: int = i;\n@@ -233,7 +233,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n     if start == 0 { start += 1; }\n \n     while start < size {\n-        let pivot = array[start];\n+        let pivot = copy array[start];\n         let mut left = 0;\n         let mut right = start;\n         assert!(left <= right);\n@@ -470,7 +470,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base1, base1+len1) |i| {\n-            tmp.push(array[i]);\n+            tmp.push(copy array[i]);\n         }\n \n         let mut c1 = 0;\n@@ -580,7 +580,7 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         let mut tmp = ~[];\n         for uint::range(base2, base2+len2) |i| {\n-            tmp.push(array[i]);\n+            tmp.push(copy array[i]);\n         }\n \n         let mut c1 = base1 + len1 - 1;\n@@ -732,7 +732,7 @@ fn copy_vec<T:Copy>(dest: &mut [T],\n     assert!(s1+from.len() <= dest.len());\n \n     for from.eachi |i, v| {\n-        dest[s1+i] = *v;\n+        dest[s1+i] = copy *v;\n     }\n }\n \n@@ -1045,7 +1045,7 @@ mod big_tests {\n     fn multiplyVec<T:Copy>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n-            arr[i % size]\n+            copy arr[i % size]\n         };\n         res\n     }"}, {"sha": "5d5d7582b5f31fc22d2c9b49f7407e86abf7c4ee", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -1184,7 +1184,7 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n     for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n     for index.each |elt| {\n         let h = elt.val.hash() as uint;\n-        buckets[h % 256].push(*elt);\n+        buckets[h % 256].push(copy *elt);\n     }\n \n     let mut buckets_frozen = ~[];"}, {"sha": "5431a0a299807f713d4e85c838af8ed86c3e1aa5", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -105,7 +105,8 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n         mc::cat_implicit_self(*) |\n         mc::cat_copied_upvar(*) |\n         mc::cat_deref(_, _, mc::region_ptr(*)) |\n-        mc::cat_deref(_, _, mc::gc_ptr(*)) => {\n+        mc::cat_deref(_, _, mc::gc_ptr(*)) |\n+        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n             bccx.span_err(\n                 cmt0.span,\n                 fmt!(\"cannot move out of %s\",\n@@ -129,8 +130,7 @@ fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n         mc::cat_rvalue(*) |\n         mc::cat_local(*) |\n         mc::cat_arg(*) |\n-        mc::cat_self(*) |\n-        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+        mc::cat_self(*) => {\n             true\n         }\n "}, {"sha": "87c33ce64f54b23e5b693e31f162c99b8dfdcba9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -200,8 +200,8 @@ fn cached_metadata<T:Copy>(cache: metadata_cache,\n         let items = cache.get(&mdtag);\n         for items.each |item| {\n             let md: T = md_from_metadata::<T>(*item);\n-            if eq_fn(md) {\n-                return option::Some(md);\n+            if eq_fn(copy md) {\n+                return option::Some(copy md);\n             }\n         }\n     }"}, {"sha": "77bf790131c427e89450b5b50a22f04b398befd4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -2273,7 +2273,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         for type_param_def.bounds.builtin_bounds.each |bound| {\n             debug!(\"tc = %s, bound = %?\", tc.to_str(), bound);\n             tc = tc - match bound {\n-                BoundCopy => TypeContents::nonimplicitly_copyable(cx),\n+                BoundCopy => TypeContents::noncopyable(cx),\n                 BoundStatic => TypeContents::nonstatic(cx),\n                 BoundOwned => TypeContents::nonowned(cx),\n                 BoundConst => TypeContents::nonconst(cx),\n@@ -3694,16 +3694,16 @@ fn lookup_locally_or_in_crate_store<V:Copy>(\n      */\n \n     match map.find(&def_id) {\n-        Some(&v) => { return v; }\n+        Some(&ref v) => { return copy *v; }\n         None => { }\n     }\n \n     if def_id.crate == ast::local_crate {\n         fail!(\"No def'n found for %? in tcx.%s\", def_id, descr);\n     }\n     let v = load_external();\n-    map.insert(def_id, v);\n-    return v;\n+    map.insert(def_id, copy v);\n+    return copy v;\n }\n \n pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {"}, {"sha": "7a3230079ee396837c75a265f94fca0fa1c5b36b", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -89,10 +89,10 @@ impl CombineFields {\n         // Need to make sub_id a subtype of sup_id.\n         let node_a = self.infcx.get(a_id);\n         let node_b = self.infcx.get(b_id);\n-        let a_id = node_a.root;\n-        let b_id = node_b.root;\n-        let a_bounds = node_a.possible_types;\n-        let b_bounds = node_b.possible_types;\n+        let a_id = copy node_a.root;\n+        let b_id = copy node_b.root;\n+        let a_bounds = copy node_a.possible_types;\n+        let b_bounds = copy node_b.possible_types;\n \n         debug!(\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.inf_str(self.infcx),\n@@ -102,8 +102,8 @@ impl CombineFields {\n \n         // If both A's UB and B's LB have already been bound to types,\n         // see if we can make those types subtypes.\n-        match (a_bounds.ub, b_bounds.lb) {\n-            (Some(ref a_ub), Some(ref b_lb)) => {\n+        match (&a_bounds.ub, &b_bounds.lb) {\n+            (&Some(ref a_ub), &Some(ref b_lb)) => {\n                 let r = self.infcx.try(\n                     || LatticeValue::sub(self, a_ub, b_lb));\n                 match r {\n@@ -138,9 +138,9 @@ impl CombineFields {\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n \n         let node_a = self.infcx.get(a_id);\n-        let a_id = node_a.root;\n+        let a_id = copy node_a.root;\n         let a_bounds = &node_a.possible_types;\n-        let b_bounds = &Bounds { lb: None, ub: Some(b) };\n+        let b_bounds = &Bounds { lb: None, ub: Some(copy b) };\n \n         debug!(\"var_sub_t(%s=%s <: %s)\",\n                a_id.to_str(),\n@@ -161,9 +161,9 @@ impl CombineFields {\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n \n-        let a_bounds = &Bounds { lb: Some(a), ub: None };\n+        let a_bounds = &Bounds { lb: Some(copy a), ub: None };\n         let node_b = self.infcx.get(b_id);\n-        let b_id = node_b.root;\n+        let b_id = copy node_b.root;\n         let b_bounds = &node_b.possible_types;\n \n         debug!(\"t_sub_var(%s <: %s=%s)\",\n@@ -190,11 +190,11 @@ impl CombineFields {\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n-        match (*a, *b) {\n-            (None,          None) => Ok(None),\n-            (Some(_),       None) => Ok(*a),\n-            (None,          Some(_)) => Ok(*b),\n-            (Some(ref v_a), Some(ref v_b)) => {\n+        match (a, b) {\n+            (&None,          &None) => Ok(None),\n+            (&Some(_),       &None) => Ok(copy *a),\n+            (&None,          &Some(_)) => Ok(copy *b),\n+            (&Some(ref v_a), &Some(ref v_b)) => {\n                 do lattice_op(self, v_a, v_b).chain |v| {\n                     Ok(Some(v))\n                 }\n@@ -272,13 +272,13 @@ impl CombineFields {\n                b.inf_str(self.infcx));\n         let _r = indenter();\n \n-        match (*a, *b) {\n-            (None, None) |\n-            (Some(_), None) |\n-            (None, Some(_)) => {\n+        match (a, b) {\n+            (&None, &None) |\n+            (&Some(_), &None) |\n+            (&None, &Some(_)) => {\n                 uok()\n             }\n-            (Some(ref t_a), Some(ref t_b)) => {\n+            (&Some(ref t_a), &Some(ref t_b)) => {\n                 LatticeValue::sub(self, t_a, t_b)\n             }\n         }\n@@ -303,9 +303,9 @@ pub trait TyLatticeDir {\n \n impl LatticeDir for Lub {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.ub }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { ub: Some(t), ..*b }\n+        Bounds { ub: Some(t), ..copy *b }\n     }\n }\n \n@@ -317,9 +317,9 @@ impl TyLatticeDir for Lub {\n \n impl LatticeDir for Glb {\n     fn combine_fields(&self) -> CombineFields { **self }\n-    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { copy b.lb }\n     fn with_bnd<T:Copy>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { lb: Some(t), ..*b }\n+        Bounds { lb: Some(t), ..copy *b }\n     }\n }\n \n@@ -405,8 +405,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     -> cres<LatticeVarResult<V,T>> {\n     let nde_a = this.infcx().get(a_vid);\n     let nde_b = this.infcx().get(b_vid);\n-    let a_vid = nde_a.root;\n-    let b_vid = nde_b.root;\n+    let a_vid = copy nde_a.root;\n+    let b_vid = copy nde_b.root;\n     let a_bounds = &nde_a.possible_types;\n     let b_bounds = &nde_b.possible_types;\n \n@@ -436,8 +436,8 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    do cf.var_sub_var(a_vid, b_vid).then {\n-        Ok(VarResult(a_vid))\n+    do cf.var_sub_var(copy a_vid, copy b_vid).then {\n+        Ok(VarResult(copy a_vid))\n     }\n }\n \n@@ -450,7 +450,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n     lattice_dir_op: LatticeDirOp<T>)\n     -> cres<T> {\n     let nde_a = this.infcx().get(a_id);\n-    let a_id = nde_a.root;\n+    let a_id = copy nde_a.root;\n     let a_bounds = &nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n@@ -472,10 +472,11 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             // If a does not have an upper bound, make b the upper bound of a\n             // and then return b.\n             debug!(\"bnd=None\");\n-            let a_bounds = this.with_bnd(a_bounds, *b);\n+            let a_bounds = this.with_bnd(a_bounds, copy *b);\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                this.infcx().set(a_id, Root(a_bounds, nde_a.rank));\n-                Ok(*b)\n+                this.infcx().set(copy a_id,\n+                                 Root(copy a_bounds, copy nde_a.rank));\n+                Ok(copy *b)\n             }\n         }\n     }"}, {"sha": "410e2fe23c10b67694d9dca5fe43456b3f5074b5", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -504,9 +504,9 @@ trait CresCompare<T> {\n \n impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n-        do self.chain |s| {\n+        do (copy *self).chain |s| {\n             if s == t {\n-                *self\n+                copy *self\n             } else {\n                 Err(f())\n             }"}, {"sha": "371d389f712c7f3c03a5de90b3c8884c96225bcc", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -61,19 +61,19 @@ impl InferCtxt {\n         {\n             let vid_u = vid.to_uint();\n             let var_val = match vb.vals.find(&vid_u) {\n-                Some(&var_val) => var_val,\n+                Some(&ref var_val) => copy *var_val,\n                 None => {\n                     tcx.sess.bug(fmt!(\n                         \"failed lookup of vid `%u`\", vid_u));\n                 }\n             };\n             match var_val {\n                 Redirect(vid) => {\n-                    let node: Node<V,T> = helper(tcx, vb, vid);\n+                    let node: Node<V,T> = helper(tcx, vb, copy vid);\n                     if node.root != vid {\n                         // Path compression\n                         vb.vals.insert(vid.to_uint(),\n-                                       Redirect(node.root));\n+                                       Redirect(copy node.root));\n                     }\n                     node\n                 }\n@@ -96,12 +96,10 @@ impl InferCtxt {\n         debug!(\"Updating variable %s to %s\",\n                vid.to_str(), new_v.inf_str(self));\n \n-        { // FIXME(#4903)---borrow checker is not flow sensitive\n-            let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-            let old_v = { *vb.vals.get(&vid.to_uint()) }; // FIXME(#4903)\n-            vb.bindings.push((vid, old_v));\n-            vb.vals.insert(vid.to_uint(), new_v);\n-        }\n+        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n+        let old_v = copy *vb.vals.get(&vid.to_uint());\n+        vb.bindings.push((copy vid, old_v));\n+        vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n     pub fn unify<T:Copy + InferStr,\n@@ -120,18 +118,18 @@ impl InferCtxt {\n         if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(node_b.root, Redirect(node_a.root));\n-            (node_a.root, node_a.rank)\n+            self.set(copy node_b.root, Redirect(copy node_a.root));\n+            (copy node_a.root, node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(node_a.root, Redirect(node_b.root));\n-            (node_b.root, node_b.rank)\n+            self.set(copy node_a.root, Redirect(copy node_b.root));\n+            (copy node_b.root, node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(node_b.root, Redirect(node_a.root));\n-            (node_a.root, node_a.rank + 1)\n+            self.set(copy node_b.root, Redirect(copy node_a.root));\n+            (copy node_a.root, node_a.rank + 1)\n         }\n     }\n \n@@ -174,20 +172,20 @@ impl InferCtxt {\n \n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n-        let a_id = node_a.root;\n-        let b_id = node_b.root;\n+        let a_id = copy node_a.root;\n+        let b_id = copy node_b.root;\n \n         if a_id == b_id { return uok(); }\n \n         let combined = match (&node_a.possible_types, &node_b.possible_types)\n         {\n             (&None, &None) => None,\n-            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(*v),\n+            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(copy *v),\n             (&Some(ref v1), &Some(ref v2)) => {\n                 if *v1 != *v2 {\n-                    return mk_err(a_is_expected, *v1, *v2);\n+                    return mk_err(a_is_expected, copy *v1, copy *v2);\n                 }\n-                Some(*v1)\n+                Some(copy *v1)\n             }\n         };\n \n@@ -211,7 +209,7 @@ impl InferCtxt {\n          * `b`. */\n \n         let node_a = self.get(a_id);\n-        let a_id = node_a.root;\n+        let a_id = copy node_a.root;\n \n         match node_a.possible_types {\n             None => {\n@@ -223,7 +221,7 @@ impl InferCtxt {\n                 if *a_t == b {\n                     return uok();\n                 } else {\n-                    return mk_err(a_is_expected, *a_t, b);\n+                    return mk_err(a_is_expected, copy *a_t, b);\n                 }\n             }\n         }"}, {"sha": "56646eb4bfbd21ec7c4a690c0f735de4a79459fc", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -107,8 +107,8 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n #[inline(always)]\n pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for lhs.each |x| { push(*x); }\n-        for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n+        for lhs.each |x| { push(copy *x); }\n+        for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n     }\n }\n \n@@ -168,7 +168,7 @@ pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n  * elements of a slice.\n  */\n pub fn to_managed<T:Copy>(v: &[T]) -> @[T] {\n-    from_fn(v.len(), |i| v[i])\n+    from_fn(v.len(), |i| copy v[i])\n }\n \n #[cfg(not(test))]"}, {"sha": "e0451b2c65d4979bccd30658e6f3f36fcfefc63e", "filename": "src/libstd/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -47,7 +47,7 @@ pub fn lefts<T:Copy,U>(eithers: &[Either<T, U>]) -> ~[T] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n-                Left(ref l) => { push(*l); }\n+                Left(ref l) => { push(copy *l); }\n                 _ => { /* fallthrough */ }\n             }\n         }\n@@ -59,7 +59,7 @@ pub fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     do vec::build_sized(eithers.len()) |push| {\n         for eithers.each |elt| {\n             match *elt {\n-                Right(ref r) => { push(*r); }\n+                Right(ref r) => { push(copy *r); }\n                 _ => { /* fallthrough */ }\n             }\n         }"}, {"sha": "3e771c4dddebb1a63c7354b54199204c30068fa6", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -1779,7 +1779,7 @@ pub mod fsync {\n                 None => (),\n                 Some(level) => {\n                   // fail hard if not succesful\n-                  assert!(((self.arg.fsync_fn)(self.arg.val, level)\n+                  assert!(((self.arg.fsync_fn)(copy self.arg.val, level)\n                     != -1));\n                 }\n             }"}, {"sha": "e7315624368986e9d96ce790dd87c50ebafaf8be", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -410,10 +410,10 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(radix: uint, pow\n     let mut multiplier = cast(radix);\n     while (my_pow > 0u) {\n         if my_pow % 2u == 1u {\n-            total *= multiplier;\n+            total = total * multiplier;\n         }\n-        my_pow     /= 2u;\n-        multiplier *= multiplier;\n+        my_pow     = my_pow / 2u;\n+        multiplier = multiplier * multiplier;\n     }\n     total\n }"}, {"sha": "75c4fa98a2b5a63c153e33f78346dbfa37dd5aec", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -229,7 +229,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n         };\n \n         // Decrease the deccumulator one digit at a time\n-        deccum /= radix_gen;\n+        deccum = deccum / radix_gen;\n         deccum = deccum.round_to_zero();\n \n         buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n@@ -282,7 +282,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n               )\n         ) {\n             // Shift first fractional digit into the integer part\n-            deccum *= radix_gen;\n+            deccum = deccum * radix_gen;\n \n             // Calculate the absolute value of each digit.\n             // See note in first loop.\n@@ -499,8 +499,8 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n \n     // Initialize accumulator with signed zero for floating point parsing to\n     // work\n-    let mut accum      = if accum_positive { _0 } else { -_1 * _0};\n-    let mut last_accum = accum; // Necessary to detect overflow\n+    let mut accum      = if accum_positive { copy _0 } else { -_1 * _0};\n+    let mut last_accum = copy accum; // Necessary to detect overflow\n     let mut i          = start;\n     let mut exp_found  = false;\n \n@@ -511,13 +511,13 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         match char::to_digit(c, radix) {\n             Some(digit) => {\n                 // shift accum one digit left\n-                accum *= radix_gen;\n+                accum = accum * copy radix_gen;\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n-                    accum += cast(digit as int);\n+                    accum = accum + cast(digit as int);\n                 } else {\n-                    accum -= cast(digit as int);\n+                    accum = accum - cast(digit as int);\n                 }\n \n                 // Detect overflow by comparing to last value, except\n@@ -526,7 +526,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                     if accum_positive && accum <= last_accum { return None; }\n                     if !accum_positive && accum >= last_accum { return None; }\n                 }\n-                last_accum = accum;\n+                last_accum = copy accum;\n             }\n             None => match c {\n                 '_' if ignore_underscores => {}\n@@ -548,29 +548,29 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n     // Parse fractional part of number\n     // Skip if already reached start of exponent\n     if !exp_found {\n-        let mut power = _1;\n+        let mut power = copy _1;\n \n         while i < len {\n             let c = buf[i] as char;\n \n             match char::to_digit(c, radix) {\n                 Some(digit) => {\n                     // Decrease power one order of magnitude\n-                    power /= radix_gen;\n+                    power = power / radix_gen;\n \n                     let digit_t: T = cast(digit);\n \n                     // add/subtract current digit depending on sign\n                     if accum_positive {\n-                        accum += digit_t * power;\n+                        accum = accum + digit_t * power;\n                     } else {\n-                        accum -= digit_t * power;\n+                        accum = accum - digit_t * power;\n                     }\n \n                     // Detect overflow by comparing to last value\n                     if accum_positive && accum < last_accum { return None; }\n                     if !accum_positive && accum > last_accum { return None; }\n-                    last_accum = accum;\n+                    last_accum = copy accum;\n                 }\n                 None => match c {\n                     '_' if ignore_underscores => {}\n@@ -596,7 +596,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n         }\n     }\n \n-    let mut multiplier = _1;\n+    let mut multiplier = copy _1;\n \n     if exp_found {\n         let c = buf[i] as char;"}, {"sha": "96bcf4e910741cd57c6a5c4055b4932ff8214b61", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -115,7 +115,7 @@ pub fn filter_to_vec<A:Copy,IA:BaseIter<A>>(this: &IA,\n                                          -> ~[A] {\n     do vec::build_sized_opt(this.size_hint()) |push| {\n         for this.each |a| {\n-            if prd(a) { push(*a); }\n+            if prd(a) { push(copy *a); }\n         }\n     }\n }\n@@ -191,7 +191,7 @@ pub fn position<A,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n pub fn find<A:Copy,IA:BaseIter<A>>(this: &IA, f: &fn(&A) -> bool)\n                                 -> Option<A> {\n     for this.each |i| {\n-        if f(i) { return Some(*i) }\n+        if f(i) { return Some(copy *i) }\n     }\n     return None;\n }\n@@ -270,7 +270,7 @@ pub fn from_fn<T,BT: Buildable<T>>(n_elts: uint, op: InitOp<T>) -> BT {\n pub fn from_elem<T:Copy,BT:Buildable<T>>(n_elts: uint, t: T) -> BT {\n     do Buildable::build_sized(n_elts) |push| {\n         let mut i: uint = 0;\n-        while i < n_elts { push(t); i += 1; }\n+        while i < n_elts { push(copy t); i += 1; }\n     }\n }\n \n@@ -281,8 +281,8 @@ pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n     let size_opt = lhs.size_hint().chain_ref(\n         |sz1| rhs.size_hint().map(|sz2| *sz1+*sz2));\n     do build_sized_opt(size_opt) |push| {\n-        for lhs.each |x| { push(*x); }\n-        for rhs.each |x| { push(*x); }\n+        for lhs.each |x| { push(copy *x); }\n+        for rhs.each |x| { push(copy *x); }\n     }\n }\n \n@@ -291,6 +291,6 @@ pub fn append<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(lhs: &IT, rhs: &IT)\n #[inline(always)]\n pub fn copy_seq<T:Copy,IT:BaseIter<T>,BT:Buildable<T>>(v: &IT) -> BT {\n     do build_sized_opt(v.size_hint()) |push| {\n-        for v.each |x| { push(*x); }\n+        for v.each |x| { push(copy *x); }\n     }\n }"}, {"sha": "30394cb21afdf8bc1a352ece134b4fa6faaa9c8e", "filename": "src/libstd/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -88,14 +88,14 @@ impl<T:Ord> Ord for Option<T> {\n     }\n }\n \n-impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n+impl<T: Copy+Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     #[inline(always)]\n     fn add(&self, other: &Option<T>) -> Option<T> {\n-        match (*self, *other) {\n-            (None, None) => None,\n-            (_, None) => *self,\n-            (None, _) => *other,\n-            (Some(ref lhs), Some(ref rhs)) => Some(*lhs + *rhs)\n+        match (&*self, &*other) {\n+            (&None, &None) => None,\n+            (_, &None) => copy *self,\n+            (&None, _) => copy *other,\n+            (&Some(ref lhs), &Some(ref rhs)) => Some(*lhs + *rhs)\n         }\n     }\n }"}, {"sha": "3448401e0b1804df042c0bbb887f5364733b087d", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -85,7 +85,8 @@ bounded and unbounded protocols allows for less code duplication.\n #[allow(missing_doc)];\n \n use container::Container;\n-use cast::{forget, transmute, transmute_copy};\n+use cast::{forget, transmute, transmute_copy, transmute_mut};\n+use cast;\n use either::{Either, Left, Right};\n use iterator::IteratorUtil;\n use kinds::Owned;\n@@ -102,10 +103,6 @@ use util::replace;\n \n static SPIN_COUNT: uint = 0;\n \n-macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n-)\n-\n #[deriving(Eq)]\n enum State {\n     Empty,\n@@ -316,9 +313,11 @@ impl<T> Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n             // FIXME(#4330) Need self by value to get mutability.\n-            let this: &mut BufferResource<T> = transmute(self);\n+            let this: &mut BufferResource<T> = transmute_mut(self);\n+\n+            let null_buffer: ~Buffer<T> = transmute(ptr::null::<Buffer<T>>());\n+            let mut b = replace(&mut this.buffer, null_buffer);\n \n-            let mut b = move_it!(this.buffer);\n             //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n             let old_count = intrinsics::atomic_xsub_rel("}, {"sha": "2d73ed0c6a1c778eab481752080930f38b50b654", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -526,7 +526,7 @@ impl<R: Rng> RngUtil for R {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(values[self.gen_uint_range(0u, values.len())])\n+            Some(copy values[self.gen_uint_range(0u, values.len())])\n         }\n     }\n     /**\n@@ -555,7 +555,7 @@ impl<R: Rng> RngUtil for R {\n         for v.each |item| {\n             so_far += item.weight;\n             if so_far > chosen {\n-                return Some(item.item);\n+                return Some(copy item.item);\n             }\n         }\n         util::unreachable();\n@@ -569,7 +569,7 @@ impl<R: Rng> RngUtil for R {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n-                r.push(item.item);\n+                r.push(copy item.item);\n             }\n         }\n         r"}, {"sha": "fa1790d79cb7de5e1175eb7dff054dbaef73c4c0", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -98,10 +98,6 @@ use iterator::{IteratorUtil};\n #[cfg(test)] use comm;\n #[cfg(test)] use task;\n \n-macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n-)\n-\n type TaskSet = HashSet<*rust_task>;\n \n fn new_taskset() -> TaskSet {\n@@ -638,23 +634,16 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: ~fn())\n                        -> ~fn() {\n-        let child_data = Cell::new((child_arc, ancestors));\n+        let child_data = Cell::new((notify_chan, child_arc, ancestors));\n         let result: ~fn() = || {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut (child_arc, ancestors) = child_data.take();\n+            let mut (notify_chan, child_arc, ancestors) = child_data.take();\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must\n             // send Something on the notify channel.\n \n-            //let mut notifier = None;//notify_chan.map(|c| AutoNotify(c));\n-            let notifier = match notify_chan {\n-                Some(ref notify_chan_value) => {\n-                    let moved_ncv = move_it!(*notify_chan_value);\n-                    Some(AutoNotify(moved_ncv))\n-                }\n-                _ => None\n-            };\n+            let notifier = notify_chan.map_consume(|c| AutoNotify(c));\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n                 let group = @@mut TCB(child,"}, {"sha": "c120883be5a07875503c1f4ecec2bf25a3126235", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -32,22 +32,22 @@ impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n     #[inline(always)]\n     fn first(&self) -> T {\n         match *self {\n-            (t, _) => t,\n+            (ref t, _) => copy *t,\n         }\n     }\n \n     /// Return the second element of self\n     #[inline(always)]\n     fn second(&self) -> U {\n         match *self {\n-            (_, u) => u,\n+            (_, ref u) => copy *u,\n         }\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline(always)]\n     fn swap(&self) -> (U, T) {\n-        match *self {\n+        match copy *self {\n             (t, u) => (u, t),\n         }\n     }"}, {"sha": "3f7bf897be2e2fd5dabb1ea648f2c16fa0af9ba1", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -167,7 +167,7 @@ pub fn from_elem<T:Copy>(n_elts: uint, t: T) -> ~[T] {\n \n /// Creates a new unique vector with the same contents as the slice\n pub fn to_owned<T:Copy>(t: &[T]) -> ~[T] {\n-    from_fn(t.len(), |i| t[i])\n+    from_fn(t.len(), |i| copy t[i])\n }\n \n /// Creates a new vector with a capacity of `capacity`\n@@ -441,9 +441,9 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n \n     for each(v) |elt| {\n         if f(elt) {\n-            lefts.push(*elt);\n+            lefts.push(copy *elt);\n         } else {\n-            rights.push(*elt);\n+            rights.push(copy *elt);\n         }\n     }\n \n@@ -798,7 +798,7 @@ pub fn grow<T:Copy>(v: &mut ~[T], n: uint, initval: &T) {\n     let mut i: uint = 0u;\n \n     while i < n {\n-        v.push(*initval);\n+        v.push(copy *initval);\n         i += 1u;\n     }\n }\n@@ -970,7 +970,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(elem) { result.push(*elem); }\n+        if f(elem) { result.push(copy *elem); }\n     }\n     result\n }\n@@ -1026,7 +1026,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.each |&inner| {\n-            if first { first = false; } else { r.push(*sep); }\n+            if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n         r\n@@ -1044,7 +1044,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n         let mut r = ~[];\n         let mut first = true;\n         for self.each |&inner| {\n-            if first { first = false; } else { r.push(*sep); }\n+            if first { first = false; } else { r.push(copy *sep); }\n             r.push_all(inner);\n         }\n         r\n@@ -1077,7 +1077,7 @@ pub fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n  */\n pub fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n                       f: &fn(t: &T) -> bool) -> Option<T> {\n-    position_between(v, start, end, f).map(|i| v[*i])\n+    position_between(v, start, end, f).map(|i| copy v[*i])\n }\n \n /**\n@@ -1103,7 +1103,7 @@ pub fn rfind_between<T:Copy>(v: &[T],\n                              end: uint,\n                              f: &fn(t: &T) -> bool)\n                           -> Option<T> {\n-    rposition_between(v, start, end, f).map(|i| v[*i])\n+    rposition_between(v, start, end, f).map(|i| copy v[*i])\n }\n \n /// Find the first index containing a matching value\n@@ -1227,7 +1227,7 @@ pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut (ts, us) = (~[], ~[]);\n     for each(v) |p| {\n-        let (t, u) = *p;\n+        let (t, u) = copy *p;\n         ts.push(t);\n         us.push(u);\n     }\n@@ -1262,7 +1262,7 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut i = 0u;\n     assert_eq!(sz, u.len());\n     while i < sz {\n-        zipped.push((v[i], u[i]));\n+        zipped.push((copy v[i], copy u[i]));\n         i += 1u;\n     }\n     zipped\n@@ -1359,8 +1359,8 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = v.len();\n     if i == 0 { return (rs); } else { i -= 1; }\n-    while i != 0 { rs.push(v[i]); i -= 1; }\n-    rs.push(v[0]);\n+    while i != 0 { rs.push(copy v[i]); i -= 1; }\n+    rs.push(copy v[0]);\n     rs\n }\n \n@@ -1479,7 +1479,7 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n  */\n pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n     let length = values.len();\n-    let mut permutation = vec::from_fn(length, |i| values[i]);\n+    let mut permutation = vec::from_fn(length, |i| copy values[i]);\n     if length <= 1 {\n         fun(permutation);\n         return true;\n@@ -1506,7 +1506,7 @@ pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n         reverse_part(indices, k+1, length);\n         // fixup permutation based on indices\n         for uint::range(k, length) |i| {\n-            permutation[i] = values[indices[i]];\n+            permutation[i] = copy values[indices[i]];\n         }\n     }\n }\n@@ -2031,7 +2031,7 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n     /// Returns the element at the given index, without doing bounds checking.\n     #[inline(always)]\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n-        *self.unsafe_ref(index)\n+        copy *self.unsafe_ref(index)\n     }\n }\n \n@@ -2350,7 +2350,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n-        as_const_buf(v, |p, _len| *ptr::const_offset(p, i))\n+        as_const_buf(v, |p, _len| copy *ptr::const_offset(p, i))\n     }\n \n     /**"}, {"sha": "07913946578ff0c67fabcbf8eed5e9fce8cb8edc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -395,30 +395,30 @@ impl id_range {\n pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n         for generics.ty_params.each |p| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n         }\n         for generics.lifetimes.each |p| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n         }\n     };\n     visit::mk_vt(@visit::Visitor {\n         visit_mod: |m, sp, id, (t, vt)| {\n-            vfn(id, t);\n+            vfn(id, copy t);\n             visit::visit_mod(m, sp, id, (t, vt));\n         },\n \n         visit_view_item: |vi, (t, vt)| {\n             match vi.node {\n-              view_item_extern_mod(_, _, id) => vfn(id, t),\n+              view_item_extern_mod(_, _, id) => vfn(id, copy t),\n               view_item_use(ref vps) => {\n                   for vps.each |vp| {\n                       match vp.node {\n-                          view_path_simple(_, _, id) => vfn(id, t),\n-                          view_path_glob(_, id) => vfn(id, t),\n+                          view_path_simple(_, _, id) => vfn(id, copy t),\n+                          view_path_glob(_, id) => vfn(id, copy t),\n                           view_path_list(_, ref paths, id) => {\n-                              vfn(id, t);\n+                              vfn(id, copy t);\n                               for paths.each |p| {\n-                                  vfn(p.node.id, t);\n+                                  vfn(p.node.id, copy t);\n                               }\n                           }\n                       }\n@@ -429,85 +429,85 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_foreign_item: |ni, (t, vt)| {\n-            vfn(ni.id, t);\n+            vfn(ni.id, copy t);\n             visit::visit_foreign_item(ni, (t, vt));\n         },\n \n         visit_item: |i, (t, vt)| {\n-            vfn(i.id, t);\n+            vfn(i.id, copy t);\n             match i.node {\n               item_enum(ref enum_definition, _) =>\n-                for (*enum_definition).variants.each |v| { vfn(v.node.id, t); },\n+                for (*enum_definition).variants.each |v| { vfn(v.node.id, copy t); },\n               _ => ()\n             }\n             visit::visit_item(i, (t, vt));\n         },\n \n         visit_local: |l, (t, vt)| {\n-            vfn(l.node.id, t);\n+            vfn(l.node.id, copy t);\n             visit::visit_local(l, (t, vt));\n         },\n         visit_block: |b, (t, vt)| {\n-            vfn(b.node.id, t);\n+            vfn(b.node.id, copy t);\n             visit::visit_block(b, (t, vt));\n         },\n         visit_stmt: |s, (t, vt)| {\n-            vfn(ast_util::stmt_id(s), t);\n+            vfn(ast_util::stmt_id(s), copy t);\n             visit::visit_stmt(s, (t, vt));\n         },\n         visit_pat: |p, (t, vt)| {\n-            vfn(p.id, t);\n+            vfn(p.id, copy t);\n             visit::visit_pat(p, (t, vt));\n         },\n \n         visit_expr: |e, (t, vt)| {\n             {\n                 let r = e.get_callee_id();\n                 for r.iter().advance |callee_id| {\n-                    vfn(*callee_id, t);\n+                    vfn(*callee_id, copy t);\n                 }\n             }\n-            vfn(e.id, t);\n+            vfn(e.id, copy t);\n             visit::visit_expr(e, (t, vt));\n         },\n \n         visit_ty: |ty, (t, vt)| {\n             match ty.node {\n-              ty_path(_, id) => vfn(id, t),\n+              ty_path(_, id) => vfn(id, copy t),\n               _ => { /* fall through */ }\n             }\n             visit::visit_ty(ty, (t, vt));\n         },\n \n         visit_generics: |generics, (t, vt)| {\n-            visit_generics(generics, t);\n+            visit_generics(generics, copy t);\n             visit::visit_generics(generics, (t, vt));\n         },\n \n         visit_fn: |fk, d, a, b, id, (t, vt)| {\n-            vfn(id, t);\n+            vfn(id, copy t);\n \n             match *fk {\n                 visit::fk_item_fn(_, generics, _, _) => {\n-                    visit_generics(generics, t);\n+                    visit_generics(generics, copy t);\n                 }\n                 visit::fk_method(_, generics, m) => {\n-                    vfn(m.self_id, t);\n-                    visit_generics(generics, t);\n+                    vfn(m.self_id, copy t);\n+                    visit_generics(generics, copy t);\n                 }\n                 visit::fk_anon(_) |\n                 visit::fk_fn_block => {\n                 }\n             }\n \n             for d.inputs.each |arg| {\n-                vfn(arg.id, t)\n+                vfn(arg.id, copy t)\n             }\n-            visit::visit_fn(fk, d, a, b, id, (t, vt));\n+            visit::visit_fn(fk, d, a, b, id, (copy t, vt));\n         },\n \n         visit_struct_field: |f, (t, vt)| {\n-            vfn(f.node.id, t);\n+            vfn(f.node.id, copy t);\n             visit::visit_struct_field(f, (t, vt));\n         },\n "}, {"sha": "e67ca5260b8f0d3eff3ffbb08d8b07a94eb17a19", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -318,7 +318,7 @@ pub fn expect<T:Copy>(diag: @span_handler,\n                        opt: Option<T>,\n                        msg: &fn() -> ~str) -> T {\n     match opt {\n-       Some(ref t) => (*t),\n+       Some(ref t) => copy *t,\n        None => diag.handler().bug(msg())\n     }\n }"}, {"sha": "e72d9b502dcd8b06567ef9f8d61305a8162f3c6b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -322,7 +322,7 @@ pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     let mut first = true;\n     for elts.each |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        op(s, *elt);\n+        op(s, copy *elt);\n     }\n     end(s);\n }\n@@ -334,13 +334,13 @@ pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n     let len = elts.len();\n     let mut i = 0u;\n     for elts.each |elt| {\n-        maybe_print_comment(s, get_span(*elt).hi);\n-        op(s, *elt);\n+        maybe_print_comment(s, get_span(copy *elt).hi);\n+        op(s, copy *elt);\n         i += 1u;\n         if i < len {\n             word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(*elt),\n-                                         Some(get_span(elts[i]).hi));\n+            maybe_print_trailing_comment(s, get_span(copy *elt),\n+                                         Some(get_span(copy elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n@@ -2118,7 +2118,7 @@ pub fn print_string(s: @ps, st: &str) {\n pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        f(s, t);\n+        f(s, copy t);\n         eof(s.s);\n     }\n }"}, {"sha": "bd5c178e7fe7d3e664449eb2368caf41f6155b41", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -36,7 +36,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n \n     pub fn prefill(init: &[T]) -> Interner<T> {\n         let rv = Interner::new();\n-        for init.each() |v| { rv.intern(*v); }\n+        for init.each() |v| { rv.intern(copy *v); }\n         rv\n     }\n \n@@ -48,7 +48,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n \n         let vect = &mut *self.vect;\n         let new_idx = vect.len();\n-        self.map.insert(val, new_idx);\n+        self.map.insert(copy val, new_idx);\n         vect.push(val);\n         new_idx\n     }\n@@ -63,7 +63,7 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n         new_idx\n     }\n \n-    pub fn get(&self, idx: uint) -> T { self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> T { copy self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n "}, {"sha": "f24c393d7b482f7b5011db0eea03fde27b1208c0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 113, "deletions": 99, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -127,15 +127,15 @@ pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n-    for m.items.each |i| { (v.visit_item)(*i, (e, v)); }\n+    for m.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+    for m.items.each |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n pub fn visit_view_item<E>(_vi: @view_item, (_e, _v): (E, vt<E>)) { }\n \n pub fn visit_local<E: Copy>(loc: @local, (e, v): (E, vt<E>)) {\n-    (v.visit_pat)(loc.node.pat, (e, v));\n-    (v.visit_ty)(loc.node.ty, (e, v));\n+    (v.visit_pat)(loc.node.pat, (copy e, v));\n+    (v.visit_ty)(loc.node.ty, (copy e, v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n@@ -149,8 +149,8 @@ fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, (e, v): (E, vt<E>)) {\n pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n     match i.node {\n         item_const(t, ex) => {\n-            (v.visit_ty)(t, (e, v));\n-            (v.visit_expr)(ex, (e, v));\n+            (v.visit_ty)(t, (copy e, v));\n+            (v.visit_expr)(ex, (copy e, v));\n         }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             (v.visit_fn)(\n@@ -170,40 +170,40 @@ pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (e, v)); }\n-            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (e, v)); }\n+            for nm.view_items.each |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+            for nm.items.each |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n         item_ty(t, ref tps) => {\n-            (v.visit_ty)(t, (e, v));\n+            (v.visit_ty)(t, (copy e, v));\n             (v.visit_generics)(tps, (e, v));\n         }\n         item_enum(ref enum_definition, ref tps) => {\n-            (v.visit_generics)(tps, (e, v));\n+            (v.visit_generics)(tps, (copy e, v));\n             visit_enum_def(\n                 enum_definition,\n                 tps,\n                 (e, v)\n             );\n         }\n         item_impl(ref tps, ref traits, ty, ref methods) => {\n-            (v.visit_generics)(tps, (e, v));\n+            (v.visit_generics)(tps, (copy e, v));\n             for traits.iter().advance |&p| {\n-                visit_trait_ref(p, (e, v));\n+                visit_trait_ref(p, (copy e, v));\n             }\n-            (v.visit_ty)(ty, (e, v));\n+            (v.visit_ty)(ty, (copy e, v));\n             for methods.each |m| {\n-                visit_method_helper(*m, (e, v))\n+                visit_method_helper(*m, (copy e, v))\n             }\n         }\n         item_struct(struct_def, ref generics) => {\n-            (v.visit_generics)(generics, (e, v));\n+            (v.visit_generics)(generics, (copy e, v));\n             (v.visit_struct_def)(struct_def, i.ident, generics, i.id, (e, v));\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n-            (v.visit_generics)(generics, (e, v));\n-            for traits.each |p| { visit_path(p.path, (e, v)); }\n+            (v.visit_generics)(generics, (copy e, v));\n+            for traits.each |p| { visit_path(p.path, (copy e, v)); }\n             for methods.each |m| {\n-                (v.visit_trait_method)(m, (e, v));\n+                (v.visit_trait_method)(m, (copy e, v));\n             }\n         }\n         item_mac(ref m) => visit_mac(m, (e, v))\n@@ -216,15 +216,19 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n     for enum_definition.variants.each |vr| {\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n-                for variant_args.each |va| { (v.visit_ty)(va.ty, (e, v)); }\n+                for variant_args.each |va| {\n+                    (v.visit_ty)(va.ty, (copy e, v));\n+                }\n             }\n             struct_variant_kind(struct_def) => {\n                 (v.visit_struct_def)(struct_def, vr.node.name, tps,\n-                                   vr.node.id, (e, v));\n+                                     vr.node.id, (copy e, v));\n             }\n         }\n         // Visit the disr expr if it exists\n-        for vr.node.disr_expr.iter().advance |ex| { (v.visit_expr)(*ex, (e, v)) }\n+        for vr.node.disr_expr.iter().advance |ex| {\n+            (v.visit_expr)(*ex, (copy e, v))\n+        }\n     }\n }\n \n@@ -238,71 +242,75 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n         },\n         ty_tup(ref ts) => {\n             for ts.each |tt| {\n-                (v.visit_ty)(*tt, (e, v));\n+                (v.visit_ty)(*tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n+            for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n         ty_path(p, _) => visit_path(p, (e, v)),\n         ty_fixed_length_vec(ref mt, ex) => {\n-            (v.visit_ty)(mt.ty, (e, v));\n-            (v.visit_expr)(ex, (e, v));\n+            (v.visit_ty)(mt.ty, (copy e, v));\n+            (v.visit_expr)(ex, (copy e, v));\n         },\n         ty_nil | ty_bot | ty_mac(_) | ty_infer => ()\n     }\n }\n \n pub fn visit_path<E: Copy>(p: @Path, (e, v): (E, vt<E>)) {\n-    for p.types.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n+    for p.types.each |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n     match p.node {\n         pat_enum(path, ref children) => {\n-            visit_path(path, (e, v));\n+            visit_path(path, (copy e, v));\n             for children.iter().advance |children| {\n-                for children.iter().advance |child| { (v.visit_pat)(*child, (e, v)); }\n+                for children.iter().advance |child| {\n+                    (v.visit_pat)(*child, (copy e, v));\n+                }\n             }\n         }\n         pat_struct(path, ref fields, _) => {\n-            visit_path(path, (e, v));\n+            visit_path(path, (copy e, v));\n             for fields.each |f| {\n-                (v.visit_pat)(f.pat, (e, v));\n+                (v.visit_pat)(f.pat, (copy e, v));\n             }\n         }\n         pat_tup(ref elts) => {\n             for elts.each |elt| {\n-                (v.visit_pat)(*elt, (e, v))\n+                (v.visit_pat)(*elt, (copy e, v))\n             }\n         },\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n         pat_ident(_, path, ref inner) => {\n-            visit_path(path, (e, v));\n-            for inner.iter().advance |subpat| { (v.visit_pat)(*subpat, (e, v)) }\n+            visit_path(path, (copy e, v));\n+            for inner.iter().advance |subpat| {\n+                (v.visit_pat)(*subpat, (copy e, v))\n+            }\n         }\n         pat_lit(ex) => (v.visit_expr)(ex, (e, v)),\n         pat_range(e1, e2) => {\n-            (v.visit_expr)(e1, (e, v));\n+            (v.visit_expr)(e1, (copy e, v));\n             (v.visit_expr)(e2, (e, v));\n         }\n         pat_wild => (),\n         pat_vec(ref before, ref slice, ref after) => {\n             for before.each |elt| {\n-                (v.visit_pat)(*elt, (e, v));\n+                (v.visit_pat)(*elt, (copy e, v));\n             }\n             for slice.iter().advance |elt| {\n-                (v.visit_pat)(*elt, (e, v));\n+                (v.visit_pat)(*elt, (copy e, v));\n             }\n             for after.each |tail| {\n-                (v.visit_pat)(*tail, (e, v));\n+                (v.visit_pat)(*tail, (copy e, v));\n             }\n         }\n     }\n@@ -311,7 +319,7 @@ pub fn visit_pat<E: Copy>(p: @pat, (e, v): (E, vt<E>)) {\n pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n     match ni.node {\n         foreign_item_fn(ref fd, _, ref generics) => {\n-            visit_fn_decl(fd, (e, v));\n+            visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n         foreign_item_const(t) => {\n@@ -324,22 +332,22 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.each |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, (e, v)),\n+            TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.each |tp| {\n-        visit_ty_param_bounds(tp.bounds, (e, v));\n+        visit_ty_param_bounds(tp.bounds, (copy e, v));\n     }\n }\n \n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.each |a| {\n-        (v.visit_pat)(a.pat, (e, v));\n-        (v.visit_ty)(a.ty, (e, v));\n+        (v.visit_pat)(a.pat, (copy e, v));\n+        (v.visit_ty)(a.ty, (copy e, v));\n     }\n     (v.visit_ty)(fd.output, (e, v));\n }\n@@ -365,15 +373,15 @@ pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n \n pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n                          _id: node_id, (e, v): (E, vt<E>)) {\n-    visit_fn_decl(decl, (e, v));\n+    visit_fn_decl(decl, (copy e, v));\n     let generics = generics_of_fn(fk);\n-    (v.visit_generics)(&generics, (e, v));\n+    (v.visit_generics)(&generics, (copy e, v));\n     (v.visit_block)(body, (e, v));\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (e, v)); }\n-    (v.visit_generics)(&m.generics, (e, v));\n+    for m.decl.inputs.each |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    (v.visit_generics)(&m.generics, (copy e, v));\n     (v.visit_ty)(m.decl.output, (e, v));\n }\n \n@@ -392,7 +400,7 @@ pub fn visit_struct_def<E: Copy>(\n     (e, v): (E, vt<E>)\n ) {\n     for sd.fields.each |f| {\n-        (v.visit_struct_field)(*f, (e, v));\n+        (v.visit_struct_field)(*f, (copy e, v));\n     }\n }\n \n@@ -406,10 +414,10 @@ pub fn visit_struct_method<E: Copy>(m: @method, (e, v): (E, vt<E>)) {\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.node.view_items.each |vi| {\n-        (v.visit_view_item)(*vi, (e, v));\n+        (v.visit_view_item)(*vi, (copy e, v));\n     }\n     for b.node.stmts.each |s| {\n-        (v.visit_stmt)(*s, (e, v));\n+        (v.visit_stmt)(*s, (copy e, v));\n     }\n     visit_expr_opt(b.node.expr, (e, v));\n }\n@@ -435,7 +443,7 @@ pub fn visit_expr_opt<E>(eo: Option<@expr>, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_exprs<E: Copy>(exprs: &[@expr], (e, v): (E, vt<E>)) {\n-    for exprs.each |ex| { (v.visit_expr)(*ex, (e, v)); }\n+    for exprs.each |ex| { (v.visit_expr)(*ex, (copy e, v)); }\n }\n \n pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n@@ -444,53 +452,57 @@ pub fn visit_mac<E>(_m: &mac, (_e, _v): (E, vt<E>)) {\n \n pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n     match ex.node {\n-        expr_vstore(x, _) => (v.visit_expr)(x, (e, v)),\n-        expr_vec(ref es, _) => visit_exprs(*es, (e, v)),\n+        expr_vstore(x, _) => (v.visit_expr)(x, (copy e, v)),\n+        expr_vec(ref es, _) => visit_exprs(*es, (copy e, v)),\n         expr_repeat(element, count, _) => {\n-            (v.visit_expr)(element, (e, v));\n-            (v.visit_expr)(count, (e, v));\n+            (v.visit_expr)(element, (copy e, v));\n+            (v.visit_expr)(count, (copy e, v));\n         }\n         expr_struct(p, ref flds, base) => {\n-            visit_path(p, (e, v));\n-            for flds.each |f| { (v.visit_expr)(f.node.expr, (e, v)); }\n-            visit_expr_opt(base, (e, v));\n+            visit_path(p, (copy e, v));\n+            for flds.each |f| {\n+                (v.visit_expr)(f.node.expr, (copy e, v));\n+            }\n+            visit_expr_opt(base, (copy e, v));\n         }\n         expr_tup(ref elts) => {\n-            for elts.each |el| { (v.visit_expr)(*el, (e, v)) }\n+            for elts.each |el| { (v.visit_expr)(*el, (copy e, v)) }\n         }\n         expr_call(callee, ref args, _) => {\n-            visit_exprs(*args, (e, v));\n-            (v.visit_expr)(callee, (e, v));\n+            visit_exprs(*args, (copy e, v));\n+            (v.visit_expr)(callee, (copy e, v));\n         }\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n-            visit_exprs(*args, (e, v));\n-            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n-            (v.visit_expr)(callee, (e, v));\n+            visit_exprs(*args, (copy e, v));\n+            for tys.each |tp| {\n+                (v.visit_ty)(*tp, (copy e, v));\n+            }\n+            (v.visit_expr)(callee, (copy e, v));\n         }\n         expr_binary(_, _, a, b) => {\n-            (v.visit_expr)(a, (e, v));\n-            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (copy e, v));\n         }\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n-        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (e, v)),\n+        expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_lit(_) => (),\n         expr_cast(x, t) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_ty)(t, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_ty)(t, (copy e, v));\n         }\n         expr_if(x, ref b, eo) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_block)(b, (e, v));\n-            visit_expr_opt(eo, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_block)(b, (copy e, v));\n+            visit_expr_opt(eo, (copy e, v));\n         }\n         expr_while(x, ref b) => {\n-            (v.visit_expr)(x, (e, v));\n-            (v.visit_block)(b, (e, v));\n+            (v.visit_expr)(x, (copy e, v));\n+            (v.visit_block)(b, (copy e, v));\n         }\n-        expr_loop(ref b, _) => (v.visit_block)(b, (e, v)),\n+        expr_loop(ref b, _) => (v.visit_block)(b, (copy e, v)),\n         expr_match(x, ref arms) => {\n-            (v.visit_expr)(x, (e, v));\n-            for arms.each |a| { (v.visit_arm)(a, (e, v)); }\n+            (v.visit_expr)(x, (copy e, v));\n+            for arms.each |a| { (v.visit_arm)(a, (copy e, v)); }\n         }\n         expr_fn_block(ref decl, ref body) => {\n             (v.visit_fn)(\n@@ -499,54 +511,56 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n                 body,\n                 ex.span,\n                 ex.id,\n-                (e, v)\n+                (copy e, v)\n             );\n         }\n-        expr_block(ref b) => (v.visit_block)(b, (e, v)),\n+        expr_block(ref b) => (v.visit_block)(b, (copy e, v)),\n         expr_assign(a, b) => {\n-            (v.visit_expr)(b, (e, v));\n-            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (copy e, v));\n         }\n-        expr_copy(a) => (v.visit_expr)(a, (e, v)),\n+        expr_copy(a) => (v.visit_expr)(a, (copy e, v)),\n         expr_assign_op(_, _, a, b) => {\n-            (v.visit_expr)(b, (e, v));\n-            (v.visit_expr)(a, (e, v));\n+            (v.visit_expr)(b, (copy e, v));\n+            (v.visit_expr)(a, (copy e, v));\n         }\n         expr_field(x, _, ref tys) => {\n-            (v.visit_expr)(x, (e, v));\n-            for tys.each |tp| { (v.visit_ty)(*tp, (e, v)); }\n+            (v.visit_expr)(x, (copy e, v));\n+            for tys.each |tp| {\n+                (v.visit_ty)(*tp, (copy e, v));\n+            }\n         }\n         expr_index(_, a, b) => {\n-            (v.visit_expr)(a, (e, v));\n-            (v.visit_expr)(b, (e, v));\n+            (v.visit_expr)(a, (copy e, v));\n+            (v.visit_expr)(b, (copy e, v));\n         }\n-        expr_path(p) => visit_path(p, (e, v)),\n+        expr_path(p) => visit_path(p, (copy e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n-        expr_ret(eo) => visit_expr_opt(eo, (e, v)),\n+        expr_ret(eo) => visit_expr_opt(eo, (copy e, v)),\n         expr_log(lv, x) => {\n-            (v.visit_expr)(lv, (e, v));\n-            (v.visit_expr)(x, (e, v));\n+            (v.visit_expr)(lv, (copy e, v));\n+            (v.visit_expr)(x, (copy e, v));\n         }\n-        expr_mac(ref mac) => visit_mac(mac, (e, v)),\n-        expr_paren(x) => (v.visit_expr)(x, (e, v)),\n+        expr_mac(ref mac) => visit_mac(mac, (copy e, v)),\n+        expr_paren(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_inline_asm(ref a) => {\n             for a.inputs.each |&(_, in)| {\n-                (v.visit_expr)(in, (e, v));\n+                (v.visit_expr)(in, (copy e, v));\n             }\n             for a.outputs.each |&(_, out)| {\n-                (v.visit_expr)(out, (e, v));\n+                (v.visit_expr)(out, (copy e, v));\n             }\n         }\n     }\n     (v.visit_expr_post)(ex, (e, v));\n }\n \n pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n-    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (e, v)); }\n-    visit_expr_opt(a.guard, (e, v));\n-    (v.visit_block)(&a.body, (e, v));\n+    for a.pats.iter().advance |p| { (v.visit_pat)(*p, (copy e, v)); }\n+    visit_expr_opt(a.guard, (copy e, v));\n+    (v.visit_block)(&a.body, (copy e, v));\n }\n \n // Simpler, non-context passing interface. Always walks the whole tree, simply"}, {"sha": "a95e183a1d12d2acb917c7a8b0b41f17d6589b1e", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -207,12 +207,14 @@ MORESTACK:\n \tsubl $12, %esp\n \n \t// Save the return value of the function we allocated space for\n+\tmovl %edx, 4(%esp)\n \tmovl %eax, (%esp)\n \n \tcall UPCALL_DEL_STACK\n \n \t// And restore it\n \tmovl (%esp), %eax\n+\tmovl 4(%esp), %edx\n \n \taddl $12,%esp\n "}, {"sha": "e45bfc8ea5dc38a9f1c6c772ea59781f8fc4c42f", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@ use std::task;\n pub fn foo<T:Owned + Copy>(x: T) -> Port<T> {\n     let (p, c) = stream();\n     do task::spawn() {\n-        c.send(x);\n+        c.send(copy x);\n     }\n     p\n }"}, {"sha": "c0b98f2af07ce0e009af806b4ffd91719f097781", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -25,7 +25,7 @@ pub fn alist_add<A:Copy,B:Copy>(lst: &alist<A,B>, k: A, v: B) {\n pub fn alist_get<A:Copy,B:Copy>(lst: &alist<A,B>, k: A) -> B {\n     let eq_fn = lst.eq_fn;\n     for lst.data.each |entry| {\n-        if eq_fn(entry.key, k) { return entry.value; }\n+        if eq_fn(copy entry.key, copy k) { return copy entry.value; }\n     }\n     fail!();\n }"}, {"sha": "7a9be75488494b90ad627bca8aef533835975a84", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -30,9 +30,7 @@ use std::ptr;\n use std::uint;\n use std::vec;\n \n-macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n-)\n+fn move_out<T>(x: T) {}\n \n enum request {\n     get_count,\n@@ -91,7 +89,7 @@ fn run(args: &[~str]) {\n \n     //error!(\"sending stop message\");\n     to_child.send(stop);\n-    move_out!(to_child);\n+    move_out(to_child);\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;"}, {"sha": "796072c848587ea8f38af86618a241dd3be73af0", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -25,9 +25,7 @@ use std::task;\n use std::uint;\n use std::vec;\n \n-macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n-)\n+fn move_out<T>(x: T) {}\n \n enum request {\n     get_count,\n@@ -87,7 +85,7 @@ fn run(args: &[~str]) {\n \n     //error!(\"sending stop message\");\n     to_child.send(stop);\n-    move_out!(to_child);\n+    move_out(to_child);\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;"}, {"sha": "0f6ca37a3fbba83668c57d0112c4827392cbee70", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -34,10 +34,6 @@ proto! ring (\n     }\n )\n \n-macro_rules! move_out (\n-    ($x:expr) => { unsafe { let y = *ptr::to_unsafe_ptr(&$x); y } }\n-)\n-\n fn thread_ring(i: uint,\n                count: uint,\n                num_chan: ring::client::num,\n@@ -54,7 +50,7 @@ fn thread_ring(i: uint,\n         match recv(port) {\n           ring::num(_n, p) => {\n             //log(error, _n);\n-            num_port = Some(move_out!(p));\n+            num_port = Some(p);\n           }\n         }\n     };"}, {"sha": "e12df5811eeea4d179ebcb4b76f57fdb5c900bb2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -36,15 +36,15 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    fn le_by_val<TT:Copy,UU:Copy + Ord>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n-      let (_, v0) = *kv0;\n-      let (_, v1) = *kv1;\n+      let (_, v0) = copy *kv0;\n+      let (_, v1) = copy *kv1;\n       return v0 >= v1;\n    }\n \n    fn le_by_key<TT:Copy + Ord,UU:Copy>(kv0: &(TT,UU),\n                                          kv1: &(TT,UU)) -> bool {\n-      let (k0, _) = *kv0;\n-      let (k1, _) = *kv1;\n+      let (k0, _) = copy *kv0;\n+      let (k1, _) = copy *kv1;\n       return k0 <= k1;\n    }\n "}, {"sha": "377b2016bcbe91adaf35d3c0726e037b7e2ecc18", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -23,7 +23,7 @@ impl to_opt for uint {\n \n impl<T:Copy> to_opt for Option<T> {\n     fn to_option(&self) -> Option<Option<T>> {\n-        Some(*self)\n+        Some(copy *self)\n     }\n }\n "}, {"sha": "ec84551f7b0a58a858029e1fc9c8e11e8057357a", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n fn copy1<T:Copy>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || t; //~ ERROR value may contain borrowed pointers\n+    let result: @fn() -> T = || copy t;\n+    //~^ ERROR value may contain borrowed pointers\n     result\n }\n \n fn copy2<T:Copy + 'static>(t: T) -> @fn() -> T {\n-    let result: @fn() -> T = || t;\n+    let result: @fn() -> T = || copy t;\n     result\n }\n "}, {"sha": "6f1b4b815213b3bc8b4c080bbab2ba1293574b05", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -13,7 +13,7 @@ struct pair<A,B> {\n }\n \n fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (a, b);\n+    let result: @fn() -> (A, u16) = || (copy a, b);\n     result\n }\n "}, {"sha": "753e5339de9da1a2e08347d17cf01e2ddb6ef301", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -24,7 +24,7 @@ fn make_cycle<A:Copy>(a: A) {\n }\n \n fn f<A:Owned + Copy,B:Owned + Copy>(a: A, b: B) -> @fn() -> (A, B) {\n-    let result: @fn() -> (A, B) = || (a, b);\n+    let result: @fn() -> (A, B) = || (copy a, copy b);\n     result\n }\n "}, {"sha": "6e5b837e0aafbf6953f3c7b4606ae6b72841fb24", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -41,6 +41,10 @@ fn test_ebml<A:\n     let d = EBReader::Doc(@bytes);\n     let mut decoder = EBReader::Decoder(d);\n     let a2: A = Decodable::decode(&mut decoder);\n+    if !(*a1 == a2) {\n+        ::std::sys::FailWithCause::fail_with(~\"explicit failure\" + \"foo\",\n+                                             \"auto-encode.rs\", 43u);\n+    }\n     assert!(*a1 == a2);\n }\n \n@@ -137,42 +141,47 @@ pub fn main() {\n     let a = &Plus(@Minus(@Val(3u), @Val(10u)), @Plus(@Val(22u), @Val(5u)));\n     test_ebml(a);\n \n-    let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n-    test_ebml(a);\n-\n-    let a = &Point {x: 3u, y: 5u};\n-    test_ebml(a);\n-\n-    let a = &@[1u, 2u, 3u];\n-    test_ebml(a);\n-\n-    let a = &Top(22u);\n-    test_ebml(a);\n-\n-    let a = &Bottom(222u);\n-    test_ebml(a);\n-\n-    let a = &A;\n-    test_ebml(a);\n+//    let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n+//    test_ebml(a);\n \n-    let a = &B;\n-    test_ebml(a);\n+//    let a = &Point {x: 3u, y: 5u};\n+//    test_ebml(a);\n+//\n+//    let a = &@[1u, 2u, 3u];\n+//    test_ebml(a);\n+//\n+//    let a = &Top(22u);\n+//    test_ebml(a);\n+//\n+//    let a = &Bottom(222u);\n+//    test_ebml(a);\n+//\n+//    let a = &A;\n+//    test_ebml(a);\n+//\n+//    let a = &B;\n+//    test_ebml(a);\n \n+    println(\"Hi1\");\n     let a = &time::now();\n     test_ebml(a);\n \n-    test_ebml(&1.0f32);\n-    test_ebml(&1.0f64);\n+    println(\"Hi2\");\n+//    test_ebml(&1.0f32);\n+//    test_ebml(&1.0f64);\n     test_ebml(&1.0f);\n-    test_ebml(&'a');\n+//    println(\"Hi3\");\n+//    test_ebml(&'a');\n \n+    println(\"Hi4\");\n     let mut a = HashMap::new();\n     test_ebml(&a);\n     a.insert(1, 2);\n+    println(\"Hi4\");\n     test_ebml(&a);\n \n-    let mut a = HashSet::new();\n-    test_ebml(&a);\n-    a.insert(1);\n-    test_ebml(&a);\n+//    let mut a = HashSet::new();\n+//    test_ebml(&a);\n+//    a.insert(1);\n+//    test_ebml(&a);\n }"}, {"sha": "2d83e9746b580951f258bc2625405315e8a3ced8", "filename": "src/test/run-pass/borrowck-move-from-unsafe-ptr-ok.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/900de0ffaded223c0ed75188226e499e332416be/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900de0ffaded223c0ed75188226e499e332416be/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-move-from-unsafe-ptr-ok.rs?ref=900de0ffaded223c0ed75188226e499e332416be", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// just make sure this compiles:\n-\n-fn bar(x: *~int) -> ~int {\n-    unsafe {\n-        let y = *x;\n-        return y;\n-    }\n-}\n-\n-pub fn main() {\n-}"}, {"sha": "86e8f600cd53eb85bedf51de4025069222f14df1", "filename": "src/test/run-pass/borrowed-ptr-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowed-ptr-pattern.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -10,7 +10,7 @@\n \n fn foo<T:Copy>(x: &T) -> T{\n     match x {\n-        &a => a\n+        &ref a => copy *a\n     }\n }\n "}, {"sha": "f4fb10fea7248fe73d838c264ca56b992a9ede49", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -12,7 +12,7 @@\n \n struct Box<T> {c: @T}\n \n-fn unbox<T:Copy>(b: Box<T>) -> T { return *b.c; }\n+fn unbox<T:Copy>(b: Box<T>) -> T { return copy *b.c; }\n \n pub fn main() {\n     let foo: int = 17;"}, {"sha": "69da3c8d9862b68cec4096c622fd6e7811d8c7cd", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -17,7 +17,7 @@ struct Pair<A,B> {\n }\n \n fn f<A:Copy + 'static>(a: A, b: u16) -> @fn() -> (A, u16) {\n-    let result: @fn() -> (A, u16) = || (a, b);\n+    let result: @fn() -> (A, u16) = || (copy a, b);\n     result\n }\n "}, {"sha": "9cf047d425c3362189f33c42e3b1bd6d551fb4a0", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { expected };\n+    let actual: T = { copy expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "25bf553ff35c38a42d810f35a394a574ae8fa785", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { expected };\n+    let actual: T = { copy expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "afb1a4c76bbb20191e15156c948fe9a6ef831966", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -16,7 +16,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = { expected };\n+    let actual: T = { copy expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "186d15c3490ae67945eb062b9d01360ae1061251", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n-    let actual: T = if true { expected } else { not_expected };\n+    let actual: T = if true { copy expected } else { not_expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "2e6db3bba07f3a0cd50be87e24c197e15c475698", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -15,7 +15,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, not_expected: T, eq: compare<T>) {\n-    let actual: T = if true { expected } else { not_expected };\n+    let actual: T = if true { copy expected } else { not_expected };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "64aa4ce3609ab81c041b886097c00ab74f1b2920", "filename": "src/test/run-pass/expr-match-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-box2.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-    let actual: T = match true { true => { expected }, _ => fail!(\"wat\") };\n+    let actual: T = match true { true => { copy expected }, _ => fail!(\"wat\") };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "bd87e7207d1491109bc92c24c1f6ff7de20c5fcc", "filename": "src/test/run-pass/expr-match-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -14,7 +14,7 @@\n type compare<T> = @fn(T, T) -> bool;\n \n fn test_generic<T:Copy>(expected: T, eq: compare<T>) {\n-  let actual: T = match true { true => { expected }, _ => fail!(\"wat\") };\n+  let actual: T = match true { true => { copy expected }, _ => fail!(\"wat\") };\n     assert!((eq(expected, actual)));\n }\n "}, {"sha": "649fe3433b46c2eba0e7ead3c9e187686a180249", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -15,8 +15,7 @@ fn g<X:Copy>(x: X) -> X { return x; }\n struct Pair<T> {a: T, b: T}\n \n fn f<T:Copy>(t: T) -> Pair<T> {\n-\n-    let x: Pair<T> = Pair {a: t, b: t};\n+    let x: Pair<T> = Pair {a: copy t, b: t};\n     return g::<Pair<T>>(x);\n }\n "}, {"sha": "014aebeff9dac7b5294e705d0fa385e283c7a9ce", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -233,9 +233,7 @@ pub mod pingpong {\n             let addr : *::pipes::send_packet<pong> = match &p {\n               &ping(ref x) => { cast::transmute(x) }\n             };\n-            let liberated_value = *addr;\n-            cast::forget(p);\n-            liberated_value\n+            fail!()\n         }\n     }\n \n@@ -244,9 +242,7 @@ pub mod pingpong {\n             let addr : *::pipes::send_packet<ping> = match &p {\n               &pong(ref x) => { cast::transmute(x) }\n             };\n-            let liberated_value = *addr;\n-            cast::forget(p);\n-            liberated_value\n+            fail!()\n         }\n     }\n "}, {"sha": "7cee6b4e8de661beb8f9f939f5112b08322ee770", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn double<T:Copy>(a: T) -> ~[T] { return ~[a] + ~[a]; }\n+fn double<T:Copy>(a: T) -> ~[T] { return ~[copy a] + ~[a]; }\n \n-fn double_int(a: int) -> ~[int] { return ~[a] + ~[a]; }\n+fn double_int(a: int) -> ~[int] { return ~[copy a] + ~[a]; }\n \n pub fn main() {\n     let mut d = double(1);"}, {"sha": "c51094d26c88febea99babd915cc58d095e40dee", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -11,7 +11,7 @@\n trait repeat<A> { fn get(&self) -> A; }\n \n impl<A:Copy> repeat<A> for @A {\n-    fn get(&self) -> A { **self }\n+    fn get(&self) -> A { copy **self }\n }\n \n fn repeater<A:Copy>(v: @A) -> @repeat<A> {"}, {"sha": "7ac38966faa3eee58c2f2b728f1c2c91f9ed7712", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -45,24 +45,18 @@ proto! bank (\n     }\n )\n \n-macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n-)\n-\n fn switch<T:Owned,U>(endp: pipes::RecvPacket<T>,\n                      f: &fn(v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }\n \n-fn move_it<T>(x: T) -> T { x }\n-\n macro_rules! follow (\n     {\n         $($message:path$(($($x: ident),+))||* -> $next:ident $e:expr)+\n     } => (\n         |m| match m {\n           $(Some($message($($($x,)+)* next)) => {\n-            let $next = move_it!(next);\n+            let $next = next;\n             $e })+\n           _ => { fail!() }\n         }\n@@ -96,7 +90,7 @@ fn bank_client(bank: bank::client::login) {\n     let bank = client::login(bank, ~\"theincredibleholk\", ~\"1234\");\n     let bank = match try_recv(bank) {\n       Some(ok(connected)) => {\n-        move_it!(connected)\n+        connected\n       }\n       Some(invalid(_)) => { fail!(\"login unsuccessful\") }\n       None => { fail!(\"bank closed the connection\") }"}, {"sha": "e091554a357281527140554b55d36f024dd99d82", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -486,9 +486,9 @@ struct Stuff {\n }\n \n impl my_visitor {\n-    pub fn get<T>(&self, f: &fn(T)) {\n+    pub fn get<T:Copy>(&self, f: &fn(T)) {\n         unsafe {\n-            f(*(self.ptr1 as *T));\n+            f(copy *(self.ptr1 as *T));\n         }\n     }\n "}, {"sha": "7a18cd02c2de7202175f2f687caa7effcb86c337", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -20,7 +20,7 @@ struct finish<T> {\n impl<T:Copy> Drop for finish<T> {\n     fn finalize(&self) {\n         unsafe {\n-            (self.arg.fin)(self.arg.val);\n+            (self.arg.fin)(copy self.arg.val);\n         }\n     }\n }"}, {"sha": "2d6b2141c5c73cdc7b9a42cbaad01f679813207d", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae23beb52f637b8c8640706ee8c6d2d4a5796bc8/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=ae23beb52f637b8c8640706ee8c6d2d4a5796bc8", "patch": "@@ -21,7 +21,7 @@ trait bool_like {\n }\n \n fn andand<T:bool_like + Copy>(x1: T, x2: T) -> T {\n-    bool_like::select(x1, x2, x1)\n+    bool_like::select(copy x1, x2, x1)\n }\n \n impl bool_like for bool {"}]}