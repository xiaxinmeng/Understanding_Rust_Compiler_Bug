{"sha": "b69a0c137c344ae722abc176f9d7ea27f7bddd3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OWEwYzEzN2MzNDRhZTcyMmFiYzE3NmY5ZDdlYTI3ZjdiZGRkM2U=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T22:22:48Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-24T22:22:48Z"}, "message": "Modify the task type to not contain any opaques; apparently these make LLVM cross.", "tree": {"sha": "6597c25a27a48a0404bded78657b3872432b9880", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6597c25a27a48a0404bded78657b3872432b9880"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b69a0c137c344ae722abc176f9d7ea27f7bddd3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b69a0c137c344ae722abc176f9d7ea27f7bddd3e", "html_url": "https://github.com/rust-lang/rust/commit/b69a0c137c344ae722abc176f9d7ea27f7bddd3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b69a0c137c344ae722abc176f9d7ea27f7bddd3e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfc4250bf721d5946b4f91c7b561dd57a00cc96", "html_url": "https://github.com/rust-lang/rust/commit/4cfc4250bf721d5946b4f91c7b561dd57a00cc96"}], "stats": {"total": 31, "additions": 25, "deletions": 6}, "files": [{"sha": "c67e45cca579b9a4f5e0d96836e403e129c5b576", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b69a0c137c344ae722abc176f9d7ea27f7bddd3e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b69a0c137c344ae722abc176f9d7ea27f7bddd3e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b69a0c137c344ae722abc176f9d7ea27f7bddd3e", "patch": "@@ -79,7 +79,22 @@ fn T_opaque() -> TypeRef {\n \n fn T_task() -> TypeRef {\n     ret T_struct(vec(T_int(),      // Refcount\n-                     T_opaque())); // Rest is opaque for now\n+                     T_int(),      // Delegate pointer\n+                     T_int(),      // Stack segment pointer\n+                     T_int(),      // Runtime SP\n+                     T_int(),      // Rust SP\n+                     T_int(),      // GC chain\n+                     T_int(),      // Domain pointer\n+                     T_int()       // Crate cache pointer\n+                     ));\n+}\n+\n+fn T_double() -> TypeRef {\n+    ret llvm.LLVMDoubleType();\n+}\n+\n+fn T_taskptr() -> TypeRef {\n+    ret T_ptr(T_task());\n }\n \n \n@@ -121,15 +136,19 @@ fn decl_cdecl_fn(ModuleRef llmod, str name,\n }\n \n fn decl_glue(ModuleRef llmod, str s) -> ValueRef {\n-    ret decl_cdecl_fn(llmod, s, vec(T_ptr(T_task())), T_nil());\n+    ret decl_cdecl_fn(llmod, s, vec(T_taskptr()), T_nil());\n }\n \n fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n+    // It doesn't actually matter what type we come up with here, at the\n+    // moment, as we cast the upcall function pointers to int before passing\n+    // them to the indirect upcall-invocation glue.  But eventually we'd like\n+    // to call them directly, once we have a calling convention worked out.\n     let int n = _n as int;\n     let str s = abi.upcall_glue_name(n);\n     let vec[TypeRef] args =\n-        vec(T_ptr(T_task()), // taskptr\n-            T_int())         // callee\n+        vec(T_taskptr(), // taskptr\n+            T_int())     // callee\n         + _vec.init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_cdecl_fn(llmod, s, args, T_int());\n@@ -139,7 +158,7 @@ fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n     if (cx.upcalls.contains_key(name)) {\n         ret cx.upcalls.get(name);\n     }\n-    auto inputs = vec(T_ptr(T_task()));\n+    auto inputs = vec(T_taskptr());\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_nil();\n     auto f = decl_cdecl_fn(cx.llmod, name, inputs, output);\n@@ -213,7 +232,7 @@ fn trans_block(@fn_ctxt cx, &ast.block b, terminator term) {\n \n fn trans_fn(@trans_ctxt cx, &ast._fn f) {\n     let vec[TypeRef] args = vec(T_ptr(T_int()), // outptr.\n-                                T_ptr(T_task()) // taskptr\n+                                T_taskptr()     // taskptr\n                                 );\n     let ValueRef llfn = decl_cdecl_fn(cx.llmod, cx.path, args, T_nil());\n     let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);"}]}