{"sha": "f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZThlOWZhY2M1YjY0YTQyNmNhN2I5NWQ2OTQ1OWM1NjAzNWQ3YjQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-31T03:32:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-31T03:32:04Z"}, "message": "Merge pull request #1613 from khadiwala/master\n\nExpose methods to locate and load config", "tree": {"sha": "4f374129289a420f7c16326fc87e4954a69bd217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f374129289a420f7c16326fc87e4954a69bd217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "html_url": "https://github.com/rust-lang/rust/commit/f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e8e9facc5b64a426ca7b95d69459c56035d7b4/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d0ee80e61250a589908ed478e4e8b65f17bf418", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d0ee80e61250a589908ed478e4e8b65f17bf418", "html_url": "https://github.com/rust-lang/rust/commit/4d0ee80e61250a589908ed478e4e8b65f17bf418"}, {"sha": "3d0ea5a099b411537098e36eb0ee06ec60d6f272", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0ea5a099b411537098e36eb0ee06ec60d6f272", "html_url": "https://github.com/rust-lang/rust/commit/3d0ea5a099b411537098e36eb0ee06ec60d6f272"}], "stats": {"total": 185, "additions": 102, "deletions": 83}, "files": [{"sha": "3a0a83f5fb11ea33009d5fcd94011b7b7b425526", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 13, "deletions": 83, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f6e8e9facc5b64a426ca7b95d69459c56035d7b4/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e8e9facc5b64a426ca7b95d69459c56035d7b4/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "patch": "@@ -19,11 +19,11 @@ extern crate getopts;\n \n use rustfmt::{run, Input, Summary};\n use rustfmt::file_lines::FileLines;\n-use rustfmt::config::{Config, WriteMode};\n+use rustfmt::config::{Config, WriteMode, get_toml_path};\n \n use std::{env, error};\n-use std::fs::{self, File};\n-use std::io::{self, ErrorKind, Read, Write};\n+use std::fs::File;\n+use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n@@ -95,78 +95,16 @@ impl CliOptions {\n     }\n }\n \n-const CONFIG_FILE_NAMES: [&'static str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n-\n-/// Try to find a project file in the given directory and its parents. Returns the path of a the\n-/// nearest project file if one exists, or `None` if no project file was found.\n-fn lookup_project_file(dir: &Path) -> FmtResult<Option<PathBuf>> {\n-    let mut current = if dir.is_relative() {\n-        env::current_dir()?.join(dir)\n-    } else {\n-        dir.to_path_buf()\n-    };\n-\n-    current = fs::canonicalize(current)?;\n-\n-    loop {\n-        for config_file_name in &CONFIG_FILE_NAMES {\n-            let config_file = current.join(config_file_name);\n-            match fs::metadata(&config_file) {\n-                // Only return if it's a file to handle the unlikely situation of a directory named\n-                // `rustfmt.toml`.\n-                Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n-                // Return the error if it's something other than `NotFound`; otherwise we didn't\n-                // find the project file yet, and continue searching.\n-                Err(e) => {\n-                    if e.kind() != ErrorKind::NotFound {\n-                        return Err(FmtError::from(e));\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // If the current directory has no parent, we're done searching.\n-        if !current.pop() {\n-            return Ok(None);\n-        }\n-    }\n-}\n-\n-fn open_config_file(file_path: &Path) -> FmtResult<(Config, Option<PathBuf>)> {\n-    let mut file = File::open(&file_path)?;\n-    let mut toml = String::new();\n-    file.read_to_string(&mut toml)?;\n-    match Config::from_toml(&toml) {\n-        Ok(cfg) => Ok((cfg, Some(file_path.to_path_buf()))),\n-        Err(err) => Err(FmtError::from(err)),\n-    }\n-}\n-\n-/// Resolve the config for input in `dir`.\n-///\n-/// Returns the `Config` to use, and the path of the project file if there was\n-/// one.\n-fn resolve_config(dir: &Path) -> FmtResult<(Config, Option<PathBuf>)> {\n-    let path = lookup_project_file(dir)?;\n-    if path.is_none() {\n-        return Ok((Config::default(), None));\n-    }\n-    open_config_file(&path.unwrap())\n-}\n-\n /// read the given config file path recursively if present else read the project file path\n fn match_cli_path_or_file(config_path: Option<PathBuf>,\n                           input_file: &Path)\n                           -> FmtResult<(Config, Option<PathBuf>)> {\n \n     if let Some(config_file) = config_path {\n-        let (toml, path) = open_config_file(config_file.as_ref())?;\n-        if path.is_some() {\n-            return Ok((toml, path));\n-        }\n+        let toml = Config::from_toml_path(config_file.as_ref())?;\n+        return Ok((toml, Some(config_file)));\n     }\n-    resolve_config(input_file)\n+    Config::from_resolved_toml_path(input_file).map_err(|e| FmtError::from(e))\n }\n \n fn make_opts() -> Options {\n@@ -261,16 +199,13 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             }\n \n             let mut config = Config::default();\n-            let mut path = None;\n             // Load the config path file if provided\n-            if let Some(config_file) = config_path {\n-                let (cfg_tmp, path_tmp) = open_config_file(config_file.as_ref())?;\n-                config = cfg_tmp;\n-                path = path_tmp;\n+            if let Some(config_file) = config_path.as_ref() {\n+                config = Config::from_toml_path(config_file.as_ref())?;\n             };\n \n             if options.verbose {\n-                if let Some(path) = path.as_ref() {\n+                if let Some(path) = config_path.as_ref() {\n                     println!(\"Using rustfmt config file {}\", path.display());\n                 }\n             }\n@@ -285,8 +220,9 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                     error_summary.add_operational_error();\n                 } else {\n                     // Check the file directory if the config-path could not be read or not provided\n-                    if path.is_none() {\n-                        let (config_tmp, path_tmp) = resolve_config(file.parent().unwrap())?;\n+                    if config_path.is_none() {\n+                        let (config_tmp, path_tmp) =\n+                            Config::from_resolved_toml_path(file.parent().unwrap())?;\n                         if options.verbose {\n                             if let Some(path) = path_tmp.as_ref() {\n                                 println!(\"Using rustfmt config file {} for {}\",\n@@ -391,13 +327,7 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     let config_path: Option<PathBuf> = match matches.opt_str(\"config-path\").map(PathBuf::from) {\n         Some(ref path) if !path.exists() => return config_path_not_found(path.to_str().unwrap()),\n         Some(ref path) if path.is_dir() => {\n-            let mut config_file_path = None;\n-            for config_file_name in &CONFIG_FILE_NAMES {\n-                let temp_path = path.join(config_file_name);\n-                if temp_path.is_file() {\n-                    config_file_path = Some(temp_path);\n-                }\n-            }\n+            let config_file_path = get_toml_path(path)?;\n             if config_file_path.is_some() {\n                 config_file_path\n             } else {"}, {"sha": "c4f078c55360e9d8362db0bb343b0c6673e7a309", "filename": "src/config.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f6e8e9facc5b64a426ca7b95d69459c56035d7b4/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e8e9facc5b64a426ca7b95d69459c56035d7b4/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "patch": "@@ -11,6 +11,11 @@\n extern crate toml;\n \n use std::cell::Cell;\n+use std::fs;\n+use std::fs::File;\n+use std::env;\n+use std::io::{Error, ErrorKind, Read};\n+use std::path::{Path, PathBuf};\n \n use file_lines::FileLines;\n use lists::{SeparatorTactic, ListTactic};\n@@ -347,6 +352,64 @@ macro_rules! create_config {\n                 }\n             }\n \n+            /// Construct a `Config` from the toml file specified at `file_path`.\n+            ///\n+            /// This method only looks at the provided path, for a method that\n+            /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n+            ///\n+            /// Return a `Config` if the config could be read and parsed from\n+            /// the file, Error otherwise.\n+            pub fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+                let mut file = File::open(&file_path)?;\n+                let mut toml = String::new();\n+                file.read_to_string(&mut toml)?;\n+                Config::from_toml(&toml).map_err(|err| Error::new(ErrorKind::InvalidData, err))\n+            }\n+\n+            /// Resolve the config for input in `dir`.\n+            ///\n+            /// Searches for `rustfmt.toml` beginning with `dir`, and\n+            /// recursively checking parents of `dir` if no config file is found.\n+            /// If no config file exists in `dir` or in any parent, a\n+            /// default `Config` will be returned (and the returned path will be empty).\n+            ///\n+            /// Returns the `Config` to use, and the path of the project file if there was\n+            /// one.\n+            pub fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n+\n+                /// Try to find a project file in the given directory and its parents.\n+                /// Returns the path of a the nearest project file if one exists,\n+                /// or `None` if no project file was found.\n+                fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+                    let mut current = if dir.is_relative() {\n+                        env::current_dir()?.join(dir)\n+                    } else {\n+                        dir.to_path_buf()\n+                    };\n+\n+                    current = fs::canonicalize(current)?;\n+\n+                    loop {\n+                        match get_toml_path(&current) {\n+                            Ok(Some(path)) => return Ok(Some(path)),\n+                            Err(e) => return Err(e),\n+                            _ => ()\n+                        }\n+\n+                        // If the current directory has no parent, we're done searching.\n+                        if !current.pop() {\n+                            return Ok(None);\n+                        }\n+                    }\n+                }\n+\n+                match resolve_project_file(dir)? {\n+                    None => Ok((Config::default(), None)),\n+                    Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n+                }\n+            }\n+\n+\n             pub fn print_docs() {\n                 use std::cmp;\n                 let max = 0;\n@@ -389,6 +452,32 @@ macro_rules! create_config {\n     )\n }\n \n+/// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n+///\n+/// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n+pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+    const CONFIG_FILE_NAMES: [&'static str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n+    for config_file_name in &CONFIG_FILE_NAMES {\n+        let config_file = dir.join(config_file_name);\n+        match fs::metadata(&config_file) {\n+            // Only return if it's a file to handle the unlikely situation of a directory named\n+            // `rustfmt.toml`.\n+            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+            // Return the error if it's something other than `NotFound`; otherwise we didn't\n+            // find the project file yet, and continue searching.\n+            Err(e) => {\n+                if e.kind() != ErrorKind::NotFound {\n+                    return Err(e);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(None)\n+}\n+\n+\n+\n create_config! {\n     verbose: bool, false, \"Use verbose output\";\n     disable_all_formatting: bool, false, \"Don't reformat anything\";"}]}