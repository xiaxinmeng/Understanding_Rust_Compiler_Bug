{"sha": "ea8d9aefdaa92526018c0de76090fb35c545faa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhOGQ5YWVmZGFhOTI1MjYwMThjMGRlNzYwOTBmYjM1YzU0NWZhYTk=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-05-31T01:04:07Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2021-07-08T21:55:57Z"}, "message": "Implement the raw_eq intrinsic in codegen_cranelift", "tree": {"sha": "4552cb2f954b4365c23430de977af30f370c08e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4552cb2f954b4365c23430de977af30f370c08e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea8d9aefdaa92526018c0de76090fb35c545faa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8d9aefdaa92526018c0de76090fb35c545faa9", "html_url": "https://github.com/rust-lang/rust/commit/ea8d9aefdaa92526018c0de76090fb35c545faa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea8d9aefdaa92526018c0de76090fb35c545faa9/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb92375755a00a39a900da50f581917519b5af6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb92375755a00a39a900da50f581917519b5af6b", "html_url": "https://github.com/rust-lang/rust/commit/fb92375755a00a39a900da50f581917519b5af6b"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "3e658cb121138aa4941e2eab57b5ec3a1fee03dc", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ea8d9aefdaa92526018c0de76090fb35c545faa9/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8d9aefdaa92526018c0de76090fb35c545faa9/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=ea8d9aefdaa92526018c0de76090fb35c545faa9", "patch": "@@ -1115,6 +1115,45 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, CValue::by_val(res, ret.layout()));\n         };\n+\n+        raw_eq, <T>(v lhs_ref, v rhs_ref) {\n+            fn type_by_size(size: Size) -> Option<Type> {\n+                Some(match size.bits() {\n+                    8 => types::I8,\n+                    16 => types::I16,\n+                    32 => types::I32,\n+                    64 => types::I64,\n+                    128 => types::I128,\n+                    _ => return None,\n+                })\n+            }\n+\n+            let size = fx.layout_of(T).layout.size;\n+            let is_eq_value =\n+                if size == Size::ZERO {\n+                    // No bytes means they're trivially equal\n+                    fx.bcx.ins().bconst(types::B1, true)\n+                } else if let Some(clty) = type_by_size(size) {\n+                    // Can't use `trusted` for these loads; they could be unaligned.\n+                    let mut flags = MemFlags::new();\n+                    flags.set_notrap();\n+                    let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n+                    let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n+                    fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val)\n+                } else {\n+                    // Just call `memcmp` (like slices do in core) when the\n+                    // size is too large or it's not a power-of-two.\n+                    let ptr_ty = pointer_ty(fx.tcx);\n+                    let signed_bytes = i64::try_from(size.bytes()).unwrap();\n+                    let bytes_val = fx.bcx.ins().iconst(ptr_ty, signed_bytes);\n+                    let params = vec![AbiParam::new(ptr_ty); 3];\n+                    let returns = vec![AbiParam::new(types::I32)];\n+                    let args = &[lhs_ref, rhs_ref, bytes_val];\n+                    let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n+                    fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0)\n+                };\n+            ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}, {"sha": "b6f5f5707fbc5d8de5a6e8453beed2a127d5e092", "filename": "src/value_and_place.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea8d9aefdaa92526018c0de76090fb35c545faa9/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea8d9aefdaa92526018c0de76090fb35c545faa9/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=ea8d9aefdaa92526018c0de76090fb35c545faa9", "patch": "@@ -437,6 +437,12 @@ impl<'tcx> CPlace<'tcx> {\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n                 | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n+\n+                // Widen an abstract SSA boolean to something that can be stored in memory\n+                (types::B1, types::I8 | types::I16 | types::I32 | types::I64 | types::I128) => {\n+                    fx.bcx.ins().bint(dst_ty, data)\n+                }\n+\n                 _ if src_ty.is_vector() && dst_ty.is_vector() => {\n                     fx.bcx.ins().raw_bitcast(dst_ty, data)\n                 }"}]}