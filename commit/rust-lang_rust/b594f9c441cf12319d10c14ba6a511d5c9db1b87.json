{"sha": "b594f9c441cf12319d10c14ba6a511d5c9db1b87", "node_id": "C_kwDOAAsO6NoAKGI1OTRmOWM0NDFjZjEyMzE5ZDEwYzE0YmE2YTUxMWQ1YzlkYjFiODc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-20T21:15:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-20T21:15:49Z"}, "message": "Merge #11690\n\n11690: feat: Add an assist for inlining type aliases r=Veykril a=steven-joruk\n\nI'm working towards implementing #10881, but I'd like to get this in first with earlier feedback.\r\n\r\nIs `inline_type_alias` a good enough name? I guess the follow up assist would be called `inline_type_alias_into_all_users` based on that.\r\n\r\n![valid_inlines](https://user-images.githubusercontent.com/1277939/158020510-fed78b5c-4c7e-46d1-9151-3044a29b9990.gif)\r\n\r\n![invalid_inlines](https://user-images.githubusercontent.com/1277939/158020516-8a2deb6d-c6ec-4adf-a15b-c514fc97dc43.gif)\r\n\r\n\n\nCo-authored-by: Steven Joruk <steven@joruk.com>", "tree": {"sha": "dad1a60d9be59b5902a2553984dbf27022cf237a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dad1a60d9be59b5902a2553984dbf27022cf237a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b594f9c441cf12319d10c14ba6a511d5c9db1b87", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiN5mFCRBK7hj4Ov3rIwAAStkIADuw2DMfZulhB9UCtK2dZU6h\nuHlSWJrfcIpgJ/ayg6vrVelybacSzZ7FcEjyAZPViBfq0y10tq50zwslYVZ0pp2w\ncoy3vpP9ay+dmYDiYbx73RMqmYL4vTl3Xua8Vi7Rt8czdVQEDkBFizqzcK63DxdC\nubPSOfGldkm5QGPv5+AVdc3wsXtAIUOCCsDEdCDLiGy0CyLFhdaVagNE8CFID704\nGkrprAmuBt3EvF77DOfMH4bZkrSHGKZcJGu0pq/P9JKL8lvgY+nOzU+MFcZ0hhig\nTmXNHmdALm4ZxFvuYDoBXmZhi9hQQms26QsuyCbMEUK3Yx7o0kw1iEx49+TMOos=\n=IvdU\n-----END PGP SIGNATURE-----\n", "payload": "tree dad1a60d9be59b5902a2553984dbf27022cf237a\nparent 6f2b1186052761c8e07c334ec786800748c42f92\nparent 1381a2de230e19944a71e8176936ac90764fbd6e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647810949 +0000\ncommitter GitHub <noreply@github.com> 1647810949 +0000\n\nMerge #11690\n\n11690: feat: Add an assist for inlining type aliases r=Veykril a=steven-joruk\n\nI'm working towards implementing #10881, but I'd like to get this in first with earlier feedback.\r\n\r\nIs `inline_type_alias` a good enough name? I guess the follow up assist would be called `inline_type_alias_into_all_users` based on that.\r\n\r\n![valid_inlines](https://user-images.githubusercontent.com/1277939/158020510-fed78b5c-4c7e-46d1-9151-3044a29b9990.gif)\r\n\r\n![invalid_inlines](https://user-images.githubusercontent.com/1277939/158020516-8a2deb6d-c6ec-4adf-a15b-c514fc97dc43.gif)\r\n\r\n\n\nCo-authored-by: Steven Joruk <steven@joruk.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b594f9c441cf12319d10c14ba6a511d5c9db1b87", "html_url": "https://github.com/rust-lang/rust/commit/b594f9c441cf12319d10c14ba6a511d5c9db1b87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b594f9c441cf12319d10c14ba6a511d5c9db1b87/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2b1186052761c8e07c334ec786800748c42f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2b1186052761c8e07c334ec786800748c42f92", "html_url": "https://github.com/rust-lang/rust/commit/6f2b1186052761c8e07c334ec786800748c42f92"}, {"sha": "1381a2de230e19944a71e8176936ac90764fbd6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1381a2de230e19944a71e8176936ac90764fbd6e", "html_url": "https://github.com/rust-lang/rust/commit/1381a2de230e19944a71e8176936ac90764fbd6e"}], "stats": {"total": 792, "additions": 791, "deletions": 1}, "files": [{"sha": "eeb2e2e66796144c45426e5e9dd5f7ca521b6f80", "filename": "crates/ide_assists/src/handlers/inline_type_alias.rs", "status": "added", "additions": 758, "deletions": 0, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=b594f9c441cf12319d10c14ba6a511d5c9db1b87", "patch": "@@ -0,0 +1,758 @@\n+// Some ideas for future improvements:\n+// - Support replacing aliases which are used in expressions, e.g. `A::new()`.\n+// - \"inline_alias_to_users\" assist #10881.\n+// - Remove unused aliases if there are no longer any users, see inline_call.rs.\n+\n+use hir::PathResolution;\n+use itertools::Itertools;\n+use std::collections::HashMap;\n+use syntax::{\n+    ast::{\n+        self,\n+        make::{self},\n+        HasGenericParams, HasName,\n+    },\n+    ted::{self},\n+    AstNode, NodeOrToken, SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: inline_type_alias\n+//\n+// Replace a type alias with its concrete type.\n+//\n+// ```\n+// type A<T = u32> = Vec<T>;\n+//\n+// fn main() {\n+//     let a: $0A;\n+// }\n+// ```\n+// ->\n+// ```\n+// type A<T = u32> = Vec<T>;\n+//\n+// fn main() {\n+//     let a: Vec<u32>;\n+// }\n+// ```\n+pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let alias_instance = ctx.find_node_at_offset::<ast::PathType>()?;\n+    let alias = get_type_alias(&ctx, &alias_instance)?;\n+    let concrete_type = alias.ty()?;\n+\n+    enum Replacement {\n+        Generic { lifetime_map: LifetimeMap, const_and_type_map: ConstAndTypeMap },\n+        Plain,\n+    }\n+\n+    let replacement = if let Some(alias_generics) = alias.generic_param_list() {\n+        if alias_generics.generic_params().next().is_none() {\n+            cov_mark::hit!(no_generics_params);\n+            return None;\n+        }\n+\n+        let instance_args =\n+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);\n+\n+        Replacement::Generic {\n+            lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,\n+            const_and_type_map: ConstAndTypeMap::new(&instance_args, &alias_generics)?,\n+        }\n+    } else {\n+        Replacement::Plain\n+    };\n+\n+    let target = alias_instance.syntax().text_range();\n+\n+    acc.add(\n+        AssistId(\"inline_type_alias\", AssistKind::RefactorInline),\n+        \"Inline type alias\",\n+        target,\n+        |builder| {\n+            let replacement_text = match replacement {\n+                Replacement::Generic { lifetime_map, const_and_type_map } => {\n+                    create_replacement(&lifetime_map, &const_and_type_map, &concrete_type)\n+                }\n+                Replacement::Plain => concrete_type.to_string(),\n+            };\n+\n+            builder.replace(target, replacement_text);\n+        },\n+    )\n+}\n+\n+struct LifetimeMap(HashMap<String, ast::Lifetime>);\n+\n+impl LifetimeMap {\n+    fn new(\n+        instance_args: &Option<ast::GenericArgList>,\n+        alias_generics: &ast::GenericParamList,\n+    ) -> Option<Self> {\n+        let mut inner = HashMap::new();\n+\n+        let wildcard_lifetime = make::lifetime(\"'_\");\n+        let lifetimes = alias_generics\n+            .lifetime_params()\n+            .filter_map(|lp| lp.lifetime())\n+            .map(|l| l.to_string())\n+            .collect_vec();\n+\n+        for lifetime in &lifetimes {\n+            inner.insert(lifetime.to_string(), wildcard_lifetime.clone());\n+        }\n+\n+        if let Some(instance_generic_args_list) = &instance_args {\n+            for (index, lifetime) in instance_generic_args_list\n+                .lifetime_args()\n+                .filter_map(|arg| arg.lifetime())\n+                .enumerate()\n+            {\n+                let key = match lifetimes.get(index) {\n+                    Some(key) => key,\n+                    None => {\n+                        cov_mark::hit!(too_many_lifetimes);\n+                        return None;\n+                    }\n+                };\n+\n+                inner.insert(key.clone(), lifetime);\n+            }\n+        }\n+\n+        Some(Self(inner))\n+    }\n+}\n+\n+struct ConstAndTypeMap(HashMap<String, SyntaxNode>);\n+\n+impl ConstAndTypeMap {\n+    fn new(\n+        instance_args: &Option<ast::GenericArgList>,\n+        alias_generics: &ast::GenericParamList,\n+    ) -> Option<Self> {\n+        let mut inner = HashMap::new();\n+        let instance_generics = generic_args_to_const_and_type_generics(instance_args);\n+        let alias_generics = generic_param_list_to_const_and_type_generics(&alias_generics);\n+\n+        if instance_generics.len() > alias_generics.len() {\n+            cov_mark::hit!(too_many_generic_args);\n+            return None;\n+        }\n+\n+        // Any declaration generics that don't have a default value must have one\n+        // provided by the instance.\n+        for (i, declaration_generic) in alias_generics.iter().enumerate() {\n+            let key = declaration_generic.replacement_key()?;\n+\n+            if let Some(instance_generic) = instance_generics.get(i) {\n+                inner.insert(key, instance_generic.replacement_value()?);\n+            } else if let Some(value) = declaration_generic.replacement_value() {\n+                inner.insert(key, value);\n+            } else {\n+                cov_mark::hit!(missing_replacement_param);\n+                return None;\n+            }\n+        }\n+\n+        Some(Self(inner))\n+    }\n+}\n+\n+/// This doesn't attempt to ensure specified generics are compatible with those\n+/// required by the type alias, other than lifetimes which must either all be\n+/// specified or all omitted. It will replace TypeArgs with ConstArgs and vice\n+/// versa if they're in the wrong position. It supports partially specified\n+/// generics.\n+///\n+/// 1. Map the provided instance's generic args to the type alias's generic\n+///    params:\n+///\n+///    ```\n+///    type A<'a, const N: usize, T = u64> = &'a [T; N];\n+///          ^ alias generic params\n+///    let a: A<100>;\n+///            ^ instance generic args\n+///    ```\n+///\n+///    generic['a] = '_ due to omission\n+///    generic[N] = 100 due to the instance arg\n+///    generic[T] = u64 due to the default param\n+///\n+/// 2. Copy the concrete type and substitute in each found mapping:\n+///\n+///    &'_ [u64; 100]\n+///\n+/// 3. Remove wildcard lifetimes entirely:\n+///\n+///    &[u64; 100]\n+fn create_replacement(\n+    lifetime_map: &LifetimeMap,\n+    const_and_type_map: &ConstAndTypeMap,\n+    concrete_type: &ast::Type,\n+) -> String {\n+    let updated_concrete_type = concrete_type.clone_for_update();\n+    let mut replacements = Vec::new();\n+    let mut removals = Vec::new();\n+\n+    for syntax in updated_concrete_type.syntax().descendants() {\n+        let syntax_string = syntax.to_string();\n+        let syntax_str = syntax_string.as_str();\n+\n+        if let Some(old_lifetime) = ast::Lifetime::cast(syntax.clone()) {\n+            if let Some(new_lifetime) = lifetime_map.0.get(&old_lifetime.to_string()) {\n+                if new_lifetime.text() == \"'_\" {\n+                    removals.push(NodeOrToken::Node(syntax.clone()));\n+\n+                    if let Some(ws) = syntax.next_sibling_or_token() {\n+                        removals.push(ws.clone());\n+                    }\n+\n+                    continue;\n+                }\n+\n+                replacements.push((syntax.clone(), new_lifetime.syntax().clone_for_update()));\n+            }\n+        } else if let Some(replacement_syntax) = const_and_type_map.0.get(syntax_str) {\n+            let new_string = replacement_syntax.to_string();\n+            let new = if new_string == \"_\" {\n+                make::wildcard_pat().syntax().clone_for_update()\n+            } else {\n+                replacement_syntax.clone_for_update()\n+            };\n+\n+            replacements.push((syntax.clone(), new));\n+        }\n+    }\n+\n+    for (old, new) in replacements {\n+        ted::replace(old, new);\n+    }\n+\n+    for syntax in removals {\n+        ted::remove(syntax);\n+    }\n+\n+    updated_concrete_type.to_string()\n+}\n+\n+fn get_type_alias(ctx: &AssistContext, path: &ast::PathType) -> Option<ast::TypeAlias> {\n+    let resolved_path = ctx.sema.resolve_path(&path.path()?)?;\n+\n+    // We need the generics in the correct order to be able to map any provided\n+    // instance generics to declaration generics. The `hir::TypeAlias` doesn't\n+    // keep the order, so we must get the `ast::TypeAlias` from the hir\n+    // definition.\n+    if let PathResolution::Def(hir::ModuleDef::TypeAlias(ta)) = resolved_path {\n+        Some(ctx.sema.source(ta)?.value)\n+    } else {\n+        None\n+    }\n+}\n+\n+enum ConstOrTypeGeneric {\n+    ConstArg(ast::ConstArg),\n+    TypeArg(ast::TypeArg),\n+    ConstParam(ast::ConstParam),\n+    TypeParam(ast::TypeParam),\n+}\n+\n+impl ConstOrTypeGeneric {\n+    fn replacement_key(&self) -> Option<String> {\n+        // Only params are used as replacement keys.\n+        match self {\n+            ConstOrTypeGeneric::ConstParam(cp) => Some(cp.name()?.to_string()),\n+            ConstOrTypeGeneric::TypeParam(tp) => Some(tp.name()?.to_string()),\n+            _ => None,\n+        }\n+    }\n+\n+    fn replacement_value(&self) -> Option<SyntaxNode> {\n+        Some(match self {\n+            ConstOrTypeGeneric::ConstArg(ca) => ca.expr()?.syntax().clone(),\n+            ConstOrTypeGeneric::TypeArg(ta) => ta.syntax().clone(),\n+            ConstOrTypeGeneric::ConstParam(cp) => cp.default_val()?.syntax().clone(),\n+            ConstOrTypeGeneric::TypeParam(tp) => tp.default_type()?.syntax().clone(),\n+        })\n+    }\n+}\n+\n+fn generic_param_list_to_const_and_type_generics(\n+    generics: &ast::GenericParamList,\n+) -> Vec<ConstOrTypeGeneric> {\n+    let mut others = Vec::new();\n+\n+    for param in generics.generic_params() {\n+        match param {\n+            ast::GenericParam::LifetimeParam(_) => {}\n+            ast::GenericParam::ConstParam(cp) => {\n+                others.push(ConstOrTypeGeneric::ConstParam(cp));\n+            }\n+            ast::GenericParam::TypeParam(tp) => others.push(ConstOrTypeGeneric::TypeParam(tp)),\n+        }\n+    }\n+\n+    others\n+}\n+\n+fn generic_args_to_const_and_type_generics(\n+    generics: &Option<ast::GenericArgList>,\n+) -> Vec<ConstOrTypeGeneric> {\n+    let mut others = Vec::new();\n+\n+    // It's fine for there to be no instance generics because the declaration\n+    // might have default values or they might be inferred.\n+    if let Some(generics) = generics {\n+        for arg in generics.generic_args() {\n+            match arg {\n+                ast::GenericArg::TypeArg(ta) => {\n+                    others.push(ConstOrTypeGeneric::TypeArg(ta));\n+                }\n+                ast::GenericArg::ConstArg(ca) => {\n+                    others.push(ConstOrTypeGeneric::ConstArg(ca));\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    others\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn empty_generic_params() {\n+        cov_mark::check!(no_generics_params);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<> = T;\n+fn main() {\n+    let a: $0A<u32>;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_generic_args() {\n+        cov_mark::check!(too_many_generic_args);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: $0A<u32, u64>;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_lifetimes() {\n+        cov_mark::check!(too_many_lifetimes);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<'a> = &'a &'b u32;\n+fn f<'a>() {\n+    let a: $0A<'a, 'b> = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    // This must be supported in order to support \"inline_alias_to_users\" or\n+    // whatever it will be called.\n+    #[test]\n+    fn alias_as_expression_ignored() {\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: A = $0A::new();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_arg() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: $0A<u32> = 0;\n+}\n+\"#,\n+            r#\"\n+type A<T> = T;\n+fn main() {\n+    let a: u32 = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_generic_replacements() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A = Vec<u32>;\n+fn main() {\n+    let a: Vec<u32>;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_expression() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize = { 1 }> = [u32; N];\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize = { 1 }> = [u32; N];\n+fn main() {\n+    let a: [u32; { 1 }];\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_default_value() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize = 1> = [u32; N];\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize = 1> = [u32; N];\n+fn main() {\n+    let a: [u32; 1];\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn all_param_types() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+struct Struct<const C: usize>;\n+type A<'inner1, 'outer1, Outer1, const INNER1: usize, Inner1: Clone, const OUTER1: usize> = (Struct<INNER1>, Struct<OUTER1>, Outer1, &'inner1 (), Inner1, &'outer1 ());\n+fn foo<'inner2, 'outer2, Outer2, const INNER2: usize, Inner2, const OUTER2: usize>() {\n+    let a: $0A<'inner2, 'outer2, Outer2, INNER2, Inner2, OUTER2>;\n+}\n+\"#,\n+            r#\"\n+struct Struct<const C: usize>;\n+type A<'inner1, 'outer1, Outer1, const INNER1: usize, Inner1: Clone, const OUTER1: usize> = (Struct<INNER1>, Struct<OUTER1>, Outer1, &'inner1 (), Inner1, &'outer1 ());\n+fn foo<'inner2, 'outer2, Outer2, const INNER2: usize, Inner2, const OUTER2: usize>() {\n+    let a: (Struct<INNER2>, Struct<OUTER2>, Outer2, &'inner2 (), Inner2, &'outer2 ());\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_lifetimes() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'l, 'r> = &'l &'r u32;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+            r#\"\n+type A<'l, 'r> = &'l &'r u32;\n+fn main() {\n+    let a: &&u32;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let a: $0A<'_, '_>;\n+}\n+\"#,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let a: &std::collections::HashMap<&str, u32>;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn omitted_everything() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let v = std::collections::HashMap<&str, u32>;\n+    let a: $0A = &v;\n+}\n+\"#,\n+            r#\"\n+type A<'r, 'l, T = u32> = &'l std::collections::HashMap<&'r str, T>;\n+fn main() {\n+    let v = std::collections::HashMap<&str, u32>;\n+    let a: &std::collections::HashMap<&str, u32> = &v;\n+}\n+\"#,\n+        );\n+    }\n+\n+    // This doesn't actually cause the GenericArgsList to contain a AssocTypeArg.\n+    #[test]\n+    fn arg_associated_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+trait Tra { type Assoc; fn a(); }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T> = Vec<T>;\n+        let a: $0A<Self::Assoc>;\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Tra { type Assoc; fn a(); }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T> = Vec<T>;\n+        let a: Vec<Self::Assoc>;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn param_default_associated_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+trait Tra { type Assoc; fn a() }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T = Self::Assoc> = Vec<T>;\n+        let a: $0A;\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Tra { type Assoc; fn a() }\n+struct Str {}\n+impl Tra for Str {\n+    type Assoc = u32;\n+    fn a() {\n+        type A<T = Self::Assoc> = Vec<T>;\n+        let a: Vec<Self::Assoc>;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_pointer() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = fn(u32);\n+fn foo(a: u32) {}\n+fn main() {\n+    let a: $0A = foo;\n+}\n+\"#,\n+            r#\"\n+type A = fn(u32);\n+fn foo(a: u32) {}\n+fn main() {\n+    let a: fn(u32) = foo;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closure() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = Box<dyn FnOnce(u32) -> u32>;\n+fn main() {\n+    let a: $0A = Box::new(|_| 0);\n+}\n+\"#,\n+            r#\"\n+type A = Box<dyn FnOnce(u32) -> u32>;\n+fn main() {\n+    let a: Box<dyn FnOnce(u32) -> u32> = Box::new(|_| 0);\n+}\n+\"#,\n+        );\n+    }\n+\n+    // Type aliases can't be used in traits, but someone might use the assist to\n+    // fix the error.\n+    #[test]\n+    fn bounds() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"type A = std::io::Write; fn f<T>() where T: $0A {}\"#,\n+            r#\"type A = std::io::Write; fn f<T>() where T: std::io::Write {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_parameter() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = std::io::Write;\n+fn f(a: impl $0A) {}\n+\"#,\n+            r#\"\n+type A = std::io::Write;\n+fn f(a: impl std::io::Write) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn arg_expression() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: $0A<{ 1 + 1 }>;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: [u32; { 1 + 1 }];\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn alias_instance_generic_path() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: $0A<u32::MAX>;\n+}\n+\"#,\n+            r#\"\n+type A<const N: usize> = [u32; N];\n+fn main() {\n+    let a: [u32; u32::MAX];\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn generic_type() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+type A = String;\n+fn f(a: Vec<$0A>) {}\n+\"#,\n+            r#\"\n+type A = String;\n+fn f(a: Vec<String>) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_replacement_param() {\n+        cov_mark::check!(missing_replacement_param);\n+        check_assist_not_applicable(\n+            inline_type_alias,\n+            r#\"\n+type A<U> = Vec<T>;\n+fn main() {\n+    let a: $0A;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn full_path_type_is_replaced() {\n+        check_assist(\n+            inline_type_alias,\n+            r#\"\n+mod foo {\n+    pub type A = String;\n+}\n+fn main() {\n+    let a: foo::$0A;\n+}\n+\"#,\n+            r#\"\n+mod foo {\n+    pub type A = String;\n+}\n+fn main() {\n+    let a: String;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "6eff8871e8ae6827d8975afa55fec96c5c62a001", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=b594f9c441cf12319d10c14ba6a511d5c9db1b87", "patch": "@@ -42,7 +42,7 @@\n //!   useful and (worse) less predictable. The user should have a clear\n //!   intuition when each particular assist is available.\n //! * Make small assists, which compose. Example: rather than auto-importing\n-//!   enums in `fill_match_arms`, we use fully-qualified names. There's a\n+//!   enums in `add_missing_match_arms`, we use fully-qualified names. There's a\n //!   separate assist to shorten a fully-qualified name.\n //! * Distinguish between assists and fixits for diagnostics. Internally, fixits\n //!   and assists are equivalent. They have the same \"show a list + invoke a\n@@ -150,6 +150,7 @@ mod handlers {\n     mod add_return_type;\n     mod inline_call;\n     mod inline_local_variable;\n+    mod inline_type_alias;\n     mod introduce_named_lifetime;\n     mod invert_if;\n     mod merge_imports;\n@@ -231,6 +232,7 @@ mod handlers {\n             inline_call::inline_call,\n             inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n+            inline_type_alias::inline_type_alias,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "3d0e134a9bbd89fd9264ceda6b31407b207fb93a", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=b594f9c441cf12319d10c14ba6a511d5c9db1b87", "patch": "@@ -1246,6 +1246,27 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_inline_type_alias() {\n+    check_doc_test(\n+        \"inline_type_alias\",\n+        r#####\"\n+type A<T = u32> = Vec<T>;\n+\n+fn main() {\n+    let a: $0A;\n+}\n+\"#####,\n+        r#####\"\n+type A<T = u32> = Vec<T>;\n+\n+fn main() {\n+    let a: Vec<u32>;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_introduce_named_generic() {\n     check_doc_test("}, {"sha": "e1d4addb52f68aefaf74f139b5da70413386b666", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b594f9c441cf12319d10c14ba6a511d5c9db1b87/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b594f9c441cf12319d10c14ba6a511d5c9db1b87", "patch": "@@ -764,6 +764,15 @@ impl ast::Meta {\n     }\n }\n \n+impl ast::GenericArgList {\n+    pub fn lifetime_args(&self) -> impl Iterator<Item = ast::LifetimeArg> {\n+        self.generic_args().filter_map(|arg| match arg {\n+            ast::GenericArg::LifetimeArg(it) => Some(it),\n+            _ => None,\n+        })\n+    }\n+}\n+\n impl ast::GenericParamList {\n     pub fn lifetime_params(&self) -> impl Iterator<Item = ast::LifetimeParam> {\n         self.generic_params().filter_map(|param| match param {"}]}