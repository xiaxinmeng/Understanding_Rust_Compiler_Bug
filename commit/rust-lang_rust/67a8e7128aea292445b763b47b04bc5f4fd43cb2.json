{"sha": "67a8e7128aea292445b763b47b04bc5f4fd43cb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YThlNzEyOGFlYTI5MjQ0NWI3NjNiNDdiMDRiYzVmNGZkNDNjYjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-27T00:33:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-27T01:02:07Z"}, "message": "Demode vec::push (and convert to method)", "tree": {"sha": "9ddde322dbc8fd5af39e903419cae508d9df05f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ddde322dbc8fd5af39e903419cae508d9df05f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67a8e7128aea292445b763b47b04bc5f4fd43cb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67a8e7128aea292445b763b47b04bc5f4fd43cb2", "html_url": "https://github.com/rust-lang/rust/commit/67a8e7128aea292445b763b47b04bc5f4fd43cb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67a8e7128aea292445b763b47b04bc5f4fd43cb2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "html_url": "https://github.com/rust-lang/rust/commit/cd79e1d1b20a2c289dd15bc2766f97c789d975aa"}], "stats": {"total": 1354, "additions": 684, "deletions": 670}, "files": [{"sha": "6f6a7bb86b6a90aeb463e903103e331e5cfc6009", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -1016,7 +1016,7 @@ fn iter<T>(seq: ~[T], f: fn(T)) {\n }\n fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n-    for seq.each |elt| { vec::push(acc, f(elt)); }\n+    for seq.each |elt| { acc.push(f(elt)); }\n     acc\n }\n ~~~~"}, {"sha": "4b76152cdb0c067b6eeed43e412784f62d5db2c7", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -1651,7 +1651,7 @@ may be invoked on multiple types.\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vec::each(vector) |element| {\n-        vec::push(accumulator, function(element));\n+        accumulator.push(function(element));\n     }\n     return accumulator;\n }"}, {"sha": "853060ea57196435011719d6e27773149a2336ff", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -345,7 +345,7 @@ fn load_crate(filename: &Path) -> Option<Crate> {\n \n                 match *ps.interner.get(attr_name) {\n                     ~\"std\" | ~\"core\" => (),\n-                    _ => vec::push(e.deps, query)\n+                    _ => e.deps.push(query)\n                 }\n             }\n             _ => ()\n@@ -801,7 +801,7 @@ fn install_source(c: &Cargo, path: &Path) {\n     let mut cratefiles = ~[];\n     for os::walk_dir(&Path(\".\")) |p| {\n         if p.filetype() == Some(~\".rc\") {\n-            vec::push(cratefiles, *p);\n+            cratefiles.push(*p);\n         }\n     }\n "}, {"sha": "8d48669ab17332ec0fc0d3a9bf87092be910f2e8", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -141,7 +141,7 @@ fn make_tests(config: config) -> ~[test::TestDesc] {\n         let file = copy *file;\n         debug!(\"inspecting file %s\", file.to_str());\n         if is_test(config, file) {\n-            vec::push(tests, make_test(config, file))\n+            tests.push(make_test(config, file))\n         }\n     }\n     return tests;"}, {"sha": "19a3c621d2795ca956f50a17b1acc9dda3c2b6ed", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -28,7 +28,7 @@ fn load_props(testfile: &Path) -> test_props {\n     let mut pp_exact = option::None;\n     for iter_header(testfile) |ln| {\n         match parse_error_pattern(ln) {\n-          option::Some(ep) => vec::push(error_patterns, ep),\n+          option::Some(ep) => error_patterns.push(ep),\n           option::None => ()\n         };\n \n@@ -41,11 +41,11 @@ fn load_props(testfile: &Path) -> test_props {\n         }\n \n         do parse_aux_build(ln).iter |ab| {\n-            vec::push(aux_builds, ab);\n+            aux_builds.push(ab);\n         }\n \n         do parse_exec_env(ln).iter |ee| {\n-            vec::push(exec_env, ee);\n+            exec_env.push(ee);\n         }\n     };\n     return {"}, {"sha": "641425f2b8e91eb89edbb50b35467de94d52fafe", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -19,7 +19,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n         else { (k,v) }\n     };\n     if str::ends_with(prog, ~\"rustc.exe\") {\n-        vec::push(env, (~\"RUST_THREADS\", ~\"1\"));\n+        env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;\n }"}, {"sha": "dae5105ce7128b816c1649ac1d6207bb2e278076", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -121,7 +121,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n                           procres);\n         }\n \n-        vec::push(srcs, procres.stdout);\n+        srcs.push(procres.stdout);\n         round += 1;\n     }\n "}, {"sha": "ec263ead954f57cee3adf6bb711d05f1aabd2fd7", "filename": "src/fuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fcycles.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -62,7 +62,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|\n-        vec::push(v, empty_pointy());\n+        v.push(empty_pointy());\n     }\n \n     // Fill in the graph with random edges, with density k/n\n@@ -77,7 +77,7 @@ fn test_cycles(r : rand::rng, k: uint, n: uint)\n           // https://github.com/mozilla/rust/issues/1899\n \n         if (likelihood(r, k, n)) { v[i].m = [p(choice(r, v))]; }\n-        if (likelihood(r, k, n)) { vec::push(v[i].n, mut p(choice(r, v))); }\n+        if (likelihood(r, k, n)) { v[i].n.push(mut p(choice(r, v))); }\n         if (likelihood(r, k, n)) { v[i].o = {x: 0, y: p(choice(r, v))}; }\n     }\n "}, {"sha": "5329d3c14dc6bbed2b2ddced3766ce628c624593", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -30,7 +30,7 @@ fn contains(haystack: ~str, needle: ~str) -> bool {\n fn find_rust_files(files: &mut ~[Path], path: &Path) {\n     if path.filetype() == Some(~\".rs\") && !contains(path.to_str(), ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n-        vec::push(*files, *path);\n+        files.push(*path);\n     } else if os::path_is_dir(path)\n         && !contains(path.to_str(), ~\"compile-fail\")\n         && !contains(path.to_str(), ~\"build\") {\n@@ -124,7 +124,7 @@ fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n                e: @ast::ty,\n                tm: test_mode) {\n     if c(e, tm) {\n-        vec::push(*es,*e);\n+        es.push(e);\n     } else {/* now my indices are wrong :( */ }\n }\n "}, {"sha": "49d34e7699253eeeacdf925b6174c224e7d98e31", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -55,11 +55,11 @@ fn vec_edits<T: copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n \n     if Lv != 1u {\n         // When Lv == 1u, this is redundant with omit.\n-        vec::push(edits, ~[]);\n+        edits.push(~[]);\n     }\n     if Lv >= 3u {\n         // When Lv == 2u, this is redundant with swap.\n-        vec::push(edits, vec::reversed(v));\n+        edits.push(vec::reversed(v));\n     }\n     ix(0u, 1u, Lv) {|i| edits += ~[vec_omit(v, i)]; }\n     ix(0u, 1u, Lv) {|i| edits += ~[vec_dup(v, i)]; }\n@@ -69,10 +69,10 @@ fn vec_edits<T: copy>(v: ~[T], xs: ~[T]) -> ~[~[T]] {\n \n     ix(0u, 1u, len(xs)) {|j|\n         ix(0u, 1u, Lv) {|i|\n-            vec::push(edits, vec_poke(v, i, xs[j]));\n+            edits.push(vec_poke(v, i, xs[j]));\n         }\n         ix(0u, 0u, Lv) {|i|\n-            vec::push(edits, vec_insert(v, i, xs[j]));\n+            edits.push(vec_insert(v, i, xs[j]));\n         }\n     }\n "}, {"sha": "6745805e2d8879e6911ff06df9c35ea18826b92d", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -61,7 +61,7 @@ fn weighted_vec<T: copy>(v : ~[weighted<T>]) -> ~[T] {\n     for {weight: weight, item: item} in v {\n         let i = 0u;\n         while i < weight {\n-            vec::push(r, item);\n+            r.push(item);\n             i += 1u;\n         }\n     }"}, {"sha": "dae77d66f253726040b5e7b2d8332d70b1a79fa9", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -17,6 +17,7 @@ use tuple::{TupleOps, ExtendedTupleOps};\n use str::{StrSlice, UniqueStr};\n use vec::{ConstVector, CopyableVector, ImmutableVector};\n use vec::{ImmutableEqVector, ImmutableCopyableVector};\n+use vec::{MutableVector, MutableCopyableVector};\n use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n use iter::{CopyableOrderedIter, Times, TimesIx};\n use num::Num;\n@@ -33,6 +34,7 @@ export Num, Times, TimesIx;\n export StrSlice, UniqueStr;\n export ConstVector, CopyableVector, ImmutableVector;\n export ImmutableEqVector, ImmutableCopyableVector, IterTraitExtensions;\n+export MutableVector, MutableCopyableVector;\n export BaseIter, CopyableIter, CopyableOrderedIter, ExtendedIter, EqIter;\n export TupleOps, ExtendedTupleOps;\n export Ptr;"}, {"sha": "eb221926fc19f3977764d2b54c955ad0414f5c1a", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -172,15 +172,15 @@ impl<A> DVec<A> {\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n             self.data <- ~[move t];\n-            vec::push_all_move(self.data, move data);\n+            self.data.push_all_move(move data);\n             log(error, ~\"b\");\n         }\n     }\n \n     /// Append a single item to the end of the list\n     fn push(+t: A) {\n         self.check_not_borrowed();\n-        vec::push(self.data, move t);\n+        self.data.push(move t);\n     }\n \n     /// Remove and return the first element\n@@ -240,7 +240,7 @@ impl<A: Copy> DVec<A> {\n             vec::reserve(&mut v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n-                vec::push(v, ts[i]);\n+                v.push(ts[i]);\n                 i += 1u;\n             }\n             move v\n@@ -266,7 +266,7 @@ impl<A: Copy> DVec<A> {\n             }\n            };\n \n-        for ts.each |t| { vec::push(v, *t) };\n+        for ts.each |t| { v.push(*t) };\n            v\n         }\n     }"}, {"sha": "d93074e4a40174c14ec1eb3dddbe71ea1d1580b5", "filename": "src/libcore/either.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -32,27 +32,27 @@ fn either<T, U, V>(f_left: fn((&T)) -> V,\n fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n     //! Extracts from a vector of either all the left values\n \n-    let mut result: ~[T] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match *elt {\n-          Left(l) => vec::push(result, l),\n-          _ => { /* fallthrough */ }\n+    do vec::build_sized(eithers.len()) |push| {\n+        for vec::each(eithers) |elt| {\n+            match *elt {\n+                Left(ref l) => { push(*l); }\n+                _ => { /* fallthrough */ }\n+            }\n         }\n     }\n-    move result\n }\n \n fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n     //! Extracts from a vector of either all the right values\n \n-    let mut result: ~[U] = ~[];\n-    for vec::each(eithers) |elt| {\n-        match *elt {\n-          Right(r) => vec::push(result, r),\n-          _ => { /* fallthrough */ }\n+    do vec::build_sized(eithers.len()) |push| {\n+        for vec::each(eithers) |elt| {\n+            match *elt {\n+                Right(ref r) => { push(*r); }\n+                _ => { /* fallthrough */ }\n+            }\n         }\n     }\n-    move result\n }\n \n fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n@@ -68,8 +68,8 @@ fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n         match *elt {\n-          Left(l) => vec::push(lefts, l),\n-          Right(r) => vec::push(rights, r)\n+          Left(l) => lefts.push(l),\n+          Right(r) => rights.push(r)\n         }\n     }\n     return {lefts: move lefts, rights: move rights};"}, {"sha": "fda3f50ca2920926c3d57c48145475ea98e54364", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -90,7 +90,7 @@ mod ct {\n         fn flush_buf(+buf: ~str, &pieces: ~[Piece]) -> ~str {\n             if str::len(buf) > 0 {\n                 let piece = PieceString(move buf);\n-                vec::push(pieces, move piece);\n+                pieces.push(move piece);\n             }\n             return ~\"\";\n         }\n@@ -110,7 +110,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(move buf, pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    vec::push(pieces, copy rs.piece);\n+                    pieces.push(copy rs.piece);\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }"}, {"sha": "6b4c93949e592993e1720f420e65178ceb8e203c", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -71,12 +71,12 @@ fn test_flate_round_trip() {\n     let r = rand::Rng();\n     let mut words = ~[];\n     for 20.times {\n-        vec::push(words, r.gen_bytes(r.gen_uint_range(1, 10)));\n+        words.push(r.gen_bytes(r.gen_uint_range(1, 10)));\n     }\n     for 20.times {\n         let mut in = ~[];\n         for 2000.times {\n-            vec::push_all(in, r.choose(words));\n+            in.push_all(r.choose(words));\n         }\n         debug!(\"de/inflate of %u bytes of random word-sequences\",\n                in.len());"}, {"sha": "cf8a10b9c7b8b259ca021d70c60ec38914742dba", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -143,7 +143,7 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n         // store the next digit\n         frac *= 10.0;\n         let digit = frac as uint;\n-        vec::push(fractionalParts, digit);\n+        fractionalParts.push(digit);\n \n         // calculate the next frac\n         frac -= digit as float;"}, {"sha": "385df30e824fdd510cdf8c1abcb9a481880467cf", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -76,7 +76,7 @@ impl<T: Reader> T : ReaderUtil {\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            vec::push(buf, ch as u8);\n+            buf.push(ch as u8);\n         }\n         str::from_bytes(buf)\n     }\n@@ -94,7 +94,7 @@ impl<T: Reader> T : ReaderUtil {\n                 i += 1;\n                 assert (w > 0);\n                 if w == 1 {\n-                    vec::push(*chars, b0 as char);\n+                    chars.push(b0 as char);\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n@@ -113,7 +113,7 @@ impl<T: Reader> T : ReaderUtil {\n                 // See str::char_at\n                 val += ((b0 << ((w + 1) as u8)) as uint)\n                     << (w - 1) * 6 - w - 1u;\n-                vec::push(*chars, val as char);\n+                chars.push(val as char);\n             }\n             return (i, 0);\n         }\n@@ -128,7 +128,7 @@ impl<T: Reader> T : ReaderUtil {\n                 // we're split in a unicode char?\n                 break;\n             }\n-            vec::push_all(buf, data);\n+            buf.push_all(data);\n             let (offset, nbreq) = chars_from_bytes::<T>(&buf, &mut chars);\n             let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n@@ -155,7 +155,7 @@ impl<T: Reader> T : ReaderUtil {\n         let mut buf: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { vec::push(buf, ch as u8); }\n+            if ch < 1 { break; } else { buf.push(ch as u8); }\n         }\n         str::from_bytes(buf)\n     }\n@@ -190,7 +190,7 @@ impl<T: Reader> T : ReaderUtil {\n \n     fn read_whole_stream() -> ~[u8] {\n         let mut buf: ~[u8] = ~[];\n-        while !self.eof() { vec::push_all(buf, self.read_bytes(2048u)); }\n+        while !self.eof() { buf.push_all(self.read_bytes(2048u)); }\n         move buf\n     }\n \n@@ -503,7 +503,7 @@ fn u64_to_le_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n \n         let mut bytes: ~[u8] = ~[], i = size, n = n;\n         while i > 0u {\n-            vec::push(bytes, (n & 255_u64) as u8);\n+            bytes.push((n & 255_u64) as u8);\n             n >>= 8_u64;\n             i -= 1u;\n         }\n@@ -535,7 +535,7 @@ fn u64_to_be_bytes<T>(n: u64, size: uint, f: fn(v: &[u8]) -> T) -> T {\n         let mut i = size;\n         while i > 0u {\n             let shift = ((i - 1u) * 8u) as u64;\n-            vec::push(bytes, (n >> shift) as u8);\n+            bytes.push((n >> shift) as u8);\n             i -= 1u;\n         }\n         f(bytes)\n@@ -737,7 +737,7 @@ fn with_str_writer(f: fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // Make sure the vector has a trailing null and is proper utf8.\n-    vec::push(v, 0);\n+    v.push(0);\n     assert str::is_utf8(v);\n \n     unsafe { move ::cast::transmute(v) }"}, {"sha": "0a2f00e3f2b23c1bb5dacf6a55ecbd5540e35b99", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -219,7 +219,7 @@ mod global_env {\n             for vec::each(rustrt::rust_env_pairs()) |p| {\n                 let vs = str::splitn_char(*p, '=', 1u);\n                 assert vec::len(vs) == 2u;\n-                vec::push(pairs, (copy vs[0], copy vs[1]));\n+                pairs.push((copy vs[0], copy vs[1]));\n             }\n             move pairs\n         }"}, {"sha": "505ecff2bcff0e9062e4dc6ea6590c8f2bdb11b2", "filename": "src/libcore/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -206,15 +206,15 @@ impl PosixPath : GenericPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { vec::push_all_move(v, move ss); }\n+            unsafe { v.push_all_move(move ss); }\n         }\n         PosixPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { vec::push_all_move(v, move ss); }\n+        unsafe { v.push_all_move(move ss); }\n         PosixPath { components: move v, ..self }\n     }\n \n@@ -400,15 +400,15 @@ impl WindowsPath : GenericPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { vec::push_all_move(v, move ss); }\n+            unsafe { v.push_all_move(move ss); }\n         }\n         return WindowsPath { components: move v, ..self }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { vec::push_all_move(v, move ss); }\n+        unsafe { v.push_all_move(move ss); }\n         return WindowsPath { components: move v, ..self }\n     }\n \n@@ -440,7 +440,7 @@ pure fn normalize(components: &[~str]) -> ~[~str] {\n                     vec::pop(cs);\n                     loop;\n                 }\n-                vec::push(cs, copy *c);\n+                cs.push(copy *c);\n             }\n         }\n     }"}, {"sha": "c4a7fa1437ab80d4749ff9425ce39a093e94ed8b", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -1059,7 +1059,7 @@ pub fn PortSet<T: Send>() -> PortSet<T>{\n impl<T: Send> PortSet<T> : Recv<T> {\n \n     fn add(+port: pipes::Port<T>) {\n-        vec::push(self.ports, move port)\n+        self.ports.push(move port)\n     }\n \n     fn chan() -> Chan<T> {"}, {"sha": "7eba81803b3302e164358abca97a2a21c822af0f", "filename": "src/libcore/private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -564,7 +564,7 @@ pub mod tests {\n \n         for uint::range(0u, num_tasks) |_i| {\n             let total = total.clone();\n-            vec::push(futures, future::spawn(|| {\n+            futures.push(future::spawn(|| {\n                 for uint::range(0u, count) |_i| {\n                     do total.with |count| {\n                         **count += 1u;"}, {"sha": "d68bd97ae5dc57f5d95ed3345130951bad37c8e3", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -215,7 +215,7 @@ impl Rng {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n-                vec::push(r, item.item);\n+                r.push(item.item);\n             }\n         }\n         move r"}, {"sha": "3968b0264d93ce84329d68644e77eb8501ac644e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -280,7 +280,7 @@ fn map_vec<T,U:Copy,V:Copy>(\n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n         match op(t) {\n-          Ok(v) => vec::push(vs, v),\n+          Ok(v) => vs.push(v),\n           Err(u) => return Err(u)\n         }\n     }\n@@ -317,7 +317,7 @@ fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n     let mut i = 0u;\n     while i < n {\n         match op(&ss[i],&ts[i]) {\n-          Ok(v) => vec::push(vs, v),\n+          Ok(v) => vs.push(v),\n           Err(u) => return Err(u)\n         }\n         i += 1u;"}, {"sha": "abeff1bd1d6e8b2548a455f3044ca47009ff1e00", "filename": "src/libcore/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -82,10 +82,10 @@ fn with_argv<T>(prog: &str, args: &[~str],\n     let mut tmps = ~[];\n     for vec::each(args) |arg| {\n         let t = @copy *arg;\n-        vec::push(tmps, t);\n-        vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n+        tmps.push(t);\n+        argptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n     }\n-    vec::push(argptrs, ptr::null());\n+    argptrs.push(ptr::null());\n     vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n }\n \n@@ -102,10 +102,10 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n         for vec::each(es) |e| {\n             let (k,v) = copy *e;\n             let t = @(fmt!(\"%s=%s\", k, v));\n-            vec::push(tmps, t);\n-            vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n+            tmps.push(t);\n+            ptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n         }\n-        vec::push(ptrs, ptr::null());\n+        ptrs.push(ptr::null());\n         vec::as_imm_buf(ptrs, |p, _len|\n             unsafe { cb(::cast::reinterpret_cast(&p)) }\n         )"}, {"sha": "7ed962b4a901bb2ccd450024206b8f4d1a2fe624", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -283,18 +283,9 @@ pub mod linear {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n-                            let ptr = unsafe {\n-                                // FIXME(#3148)--region inference\n-                                // fails to capture needed deps.\n-                                // Here, the bucket value is known to\n-                                // live as long as self, because self\n-                                // is immutable.  But the region\n-                                // inference stupidly infers a\n-                                // lifetime for `ref bkt` that is\n-                                // shorter than it needs to be.\n-                                cast::copy_lifetime(self, &bkt.value)\n-                            };\n-                            Some(ptr)\n+                            // FIXME(#3148)---should be inferred\n+                            let bkt: &self/Bucket<K,V> = bkt;\n+                            Some(&bkt.value)\n                         }\n                         None => {\n                             fail ~\"LinearMap::find: internal logic error\""}, {"sha": "0993d1df63f330ec716a6aeef68b6c02efc1afa1", "filename": "src/libcore/str.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -468,7 +468,7 @@ pure fn chars(s: &str) -> ~[char] {\n     let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n-        unsafe { vec::push(buf, ch); }\n+        unsafe { buf.push(ch); }\n         i = next;\n     }\n     move buf\n@@ -537,16 +537,15 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i unsafe {\n-                    vec::push(result,\n-                              unsafe { raw::slice_bytes(s, start, i) });\n+                    result.push(unsafe { raw::slice_bytes(s, start, i) });\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { vec::push(result, raw::slice_bytes(s, start, l) ) };\n+            unsafe { result.push(raw::slice_bytes(s, start, l) ) };\n         }\n         move result\n     } else {\n@@ -581,15 +580,15 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i unsafe {\n-                vec::push(result, unsafe { raw::slice_bytes(s, start, i)});\n+                result.push(unsafe { raw::slice_bytes(s, start, i)});\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_empty || start < l unsafe {\n-        vec::push(result, unsafe { raw::slice_bytes(s, start, l) });\n+        result.push(unsafe { raw::slice_bytes(s, start, l) });\n     }\n     move result\n }\n@@ -643,7 +642,7 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n+        unsafe { result.push(raw::slice_bytes(s, from, to)); }\n     }\n     move result\n }\n@@ -652,7 +651,7 @@ pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { vec::push(result, raw::slice_bytes(s, from, to)); }\n+            unsafe { result.push(raw::slice_bytes(s, from, to)); }\n         }\n     }\n     move result\n@@ -1535,14 +1534,14 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n         if (ch & 0xFFFF_u32) == ch unsafe {\n             // The BMP falls through (assuming non-surrogate, as it should)\n             assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n-            vec::push(u, ch as u16)\n+            u.push(ch as u16)\n         } else unsafe {\n             // Supplementary planes break into surrogates.\n             assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n             ch -= 0x1_0000_u32;\n             let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n             let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            vec::push_all(u, ~[w1, w2])\n+            u.push_all(~[w1, w2])\n         }\n     }\n     move u\n@@ -2010,7 +2009,7 @@ mod raw {\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(v, len);\n-        vec::push(v, 0u8);\n+        v.push(0u8);\n \n         assert is_utf8(v);\n         return ::cast::transmute(move v);\n@@ -2067,7 +2066,7 @@ mod raw {\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }\n                 vec::raw::set_len(v, end - begin);\n-                vec::push(v, 0u8);\n+                v.push(0u8);\n                 ::cast::transmute(move v)\n             }\n         }"}, {"sha": "50011dbacecbf0f2106d7b2d24f43942fab8857a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 113, "deletions": 76, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -92,6 +92,8 @@ export CopyableVector;\n export ImmutableVector;\n export ImmutableEqVector;\n export ImmutableCopyableVector;\n+export MutableVector;\n+export MutableCopyableVector;\n export IterTraitExtensions;\n export vec_concat;\n export traits;\n@@ -238,7 +240,7 @@ pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n pure fn build_sized<A>(size: uint,\n                        builder: fn(push: pure fn(+v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|+x| unsafe { push(vec, move x) });\n+    builder(|+x| unsafe { vec.push(move x) });\n     move vec\n }\n \n@@ -330,7 +332,7 @@ pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (end <= len(v));\n     let mut result = ~[];\n     unsafe {\n-        for uint::range(start, end) |i| { vec::push(result, v[i]) }\n+        for uint::range(start, end) |i| { result.push(v[i]) }\n     }\n     move result\n }\n@@ -383,14 +385,14 @@ fn split<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln {\n         match position_between(v, start, ln, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, start, i));\n-            start = i + 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, start, i));\n+                start = i + 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, start, ln));\n+    result.push(slice(v, start, ln));\n     move result\n }\n \n@@ -407,16 +409,16 @@ fn splitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while start < ln && count > 0u {\n         match position_between(v, start, ln, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, start, i));\n-            // Make sure to skip the separator.\n-            start = i + 1u;\n-            count -= 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, start, i));\n+                // Make sure to skip the separator.\n+                start = i + 1u;\n+                count -= 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, start, ln));\n+    result.push(slice(v, start, ln));\n     move result\n }\n \n@@ -432,14 +434,14 @@ fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, i + 1u, end));\n-            end = i;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, i + 1u, end));\n+                end = i;\n+            }\n         }\n     }\n-    push(result, slice(v, 0u, end));\n+    result.push(slice(v, 0u, end));\n     reverse(result);\n     return move result;\n }\n@@ -457,16 +459,16 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let mut result = ~[];\n     while end > 0u && count > 0u {\n         match rposition_between(v, 0u, end, f) {\n-          None => break,\n-          Some(i) => {\n-            push(result, slice(v, i + 1u, end));\n-            // Make sure to skip the separator.\n-            end = i;\n-            count -= 1u;\n-          }\n+            None => break,\n+            Some(i) => {\n+                result.push(slice(v, i + 1u, end));\n+                // Make sure to skip the separator.\n+                end = i;\n+                count -= 1u;\n+            }\n         }\n     }\n-    push(result, slice(v, 0u, end));\n+    result.push(slice(v, 0u, end));\n     reverse(result);\n     move result\n }\n@@ -489,7 +491,7 @@ fn shift<T>(&v: ~[T]) -> T {\n \n             for uint::range(1, ln) |i| {\n                 let r <- *ptr::offset(vv, i);\n-                push(v, move r);\n+                v.push(move r);\n             }\n         }\n         raw::set_len(vv, 0);\n@@ -503,7 +505,7 @@ fn unshift<T>(&v: ~[T], +x: T) {\n     let mut vv = ~[move x];\n     v <-> vv;\n     while len(vv) > 0 {\n-        push(v, shift(vv));\n+        v.push(shift(vv));\n     }\n }\n \n@@ -568,9 +570,9 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n \n /// Append an element to a vector\n #[inline(always)]\n-fn push<T>(&v: ~[T], +initval: T) {\n+fn push<T>(v: &mut ~[T], +initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::transmute(copy v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n@@ -583,8 +585,8 @@ fn push<T>(&v: ~[T], +initval: T) {\n \n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n-unsafe fn push_fast<T>(&v: ~[T], +initval: T) {\n-    let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n+unsafe fn push_fast<T>(+v: &mut ~[T], +initval: T) {\n+    let repr: **raw::VecRepr = ::cast::transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::size_of::<T>();\n     let p = ptr::addr_of((**repr).unboxed.data);\n@@ -593,23 +595,23 @@ unsafe fn push_fast<T>(&v: ~[T], +initval: T) {\n }\n \n #[inline(never)]\n-fn push_slow<T>(&v: ~[T], +initval: T) {\n-    reserve_at_least(&mut v, v.len() + 1u);\n+fn push_slow<T>(+v: &mut ~[T], +initval: T) {\n+    reserve_at_least(v, v.len() + 1u);\n     unsafe { push_fast(v, move initval) }\n }\n \n #[inline(always)]\n-fn push_all<T: Copy>(&v: ~[T], rhs: &[const T]) {\n-    reserve(&mut v, v.len() + rhs.len());\n+fn push_all<T: Copy>(+v: &mut ~[T], rhs: &[const T]) {\n+    reserve(v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n         push(v, unsafe { raw::get(rhs, i) })\n     }\n }\n \n #[inline(always)]\n-fn push_all_move<T>(&v: ~[T], -rhs: ~[const T]) {\n-    reserve(&mut v, v.len() + rhs.len());\n+fn push_all_move<T>(v: &mut ~[T], -rhs: ~[const T]) {\n+    reserve(v, v.len() + rhs.len());\n     unsafe {\n         do as_imm_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n@@ -675,15 +677,15 @@ fn dedup<T: Eq>(&v: ~[const T]) unsafe {\n pure fn append<T: Copy>(+lhs: ~[T], rhs: &[const T]) -> ~[T] {\n     let mut v <- lhs;\n     unsafe {\n-        push_all(v, rhs);\n+        v.push_all(rhs);\n     }\n     move v\n }\n \n #[inline(always)]\n pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n     let mut v <- lhs;\n-    unsafe { push(v, move x); }\n+    unsafe { v.push(move x); }\n     move v\n }\n \n@@ -705,7 +707,10 @@ fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n     reserve_at_least(&mut v, len(v) + n);\n     let mut i: uint = 0u;\n \n-    while i < n { push(v, initval); i += 1u; }\n+    while i < n {\n+        v.push(initval);\n+        i += 1u;\n+    }\n }\n \n /**\n@@ -724,7 +729,10 @@ fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n     reserve_at_least(&mut v, len(v) + n);\n     let mut i: uint = 0u;\n-    while i < n { push(v, op(i)); i += 1u; }\n+    while i < n {\n+        v.push(op(i));\n+        i += 1u;\n+    }\n }\n \n /**\n@@ -745,14 +753,18 @@ fn grow_set<T: Copy>(&v: ~[T], index: uint, initval: T, val: T) {\n /// Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: &[T], f: fn(v: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n-    for each(v) |elem| { unsafe { push(result, f(elem)); } }\n+    for each(v) |elem| {\n+        unsafe {\n+            result.push(f(elem));\n+        }\n+    }\n     move result\n }\n \n fn map_consume<T, U>(+v: ~[T], f: fn(+v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(move v) |_i, x| {\n-        vec::push(result, f(move x));\n+        result.push(f(move x));\n     }\n     move result\n }\n@@ -772,7 +784,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n  */\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ push_all_move(result, f(*elem)); } }\n+    for each(v) |elem| { unsafe{ result.push_all_move(f(*elem)); } }\n     move result\n }\n \n@@ -784,7 +796,7 @@ pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n-        unsafe { push(u, f(copy v0[i], copy v1[i])) };\n+        unsafe { u.push(f(copy v0[i], copy v1[i])) };\n         i += 1u;\n     }\n     move u\n@@ -802,7 +814,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n     for each(v) |elem| {\n         match f(*elem) {\n           None => {/* no-op */ }\n-          Some(result_elem) => unsafe { push(result, result_elem); }\n+          Some(result_elem) => unsafe { result.push(result_elem); }\n         }\n     }\n     move result\n@@ -818,7 +830,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(*elem) { unsafe { push(result, *elem); } }\n+        if f(*elem) { unsafe { result.push(*elem); } }\n     }\n     move result\n }\n@@ -830,7 +842,7 @@ pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n  */\n pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) |inner| { unsafe { push_all(r, *inner); } }\n+    for each(v) |inner| { unsafe { r.push_all(*inner); } }\n     move r\n }\n \n@@ -839,8 +851,8 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n-        if first { first = false; } else { unsafe { push(r, sep); } }\n-        unsafe { push_all(r, *inner) };\n+        if first { first = false; } else { unsafe { r.push(sep); } }\n+        unsafe { r.push_all(*inner) };\n     }\n     move r\n }\n@@ -1059,15 +1071,15 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n-    let mut as_ = ~[], bs = ~[];\n+    let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n-        let (a, b) = *p;\n+        let (t, u) = *p;\n         unsafe {\n-            vec::push(as_, a);\n-            vec::push(bs, b);\n+            ts.push(t);\n+            us.push(u);\n         }\n     }\n-    return (move as_, move bs);\n+    return (move ts, move us);\n }\n \n /**\n@@ -1082,9 +1094,9 @@ pure fn unzip<T,U>(+v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     unsafe {\n         do consume(move v) |_i, p| {\n-            let (a,b) = move p;\n-            push(ts, move a);\n-            push(us, move b);\n+            let (t, u) = move p;\n+            ts.push(move t);\n+            us.push(move u);\n         }\n     }\n     (move ts, move us)\n@@ -1099,7 +1111,7 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz unsafe { vec::push(zipped, (v[i], u[i])); i += 1u; }\n+    while i < sz unsafe { zipped.push((v[i], u[i])); i += 1u; }\n     move zipped\n }\n \n@@ -1114,7 +1126,7 @@ pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n     assert i == len(u);\n     let mut w = with_capacity(i);\n     while i > 0 {\n-        unsafe { push(w, (pop(v),pop(u))); }\n+        unsafe { w.push((pop(v),pop(u))); }\n         i -= 1;\n     }\n     unsafe { reverse(w); }\n@@ -1147,8 +1159,8 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut i = len::<T>(v);\n     if i == 0 { return (move rs); } else { i -= 1; }\n     unsafe {\n-        while i != 0 { vec::push(rs, v[i]); i -= 1; }\n-        vec::push(rs, v[0]);\n+        while i != 0 { rs.push(v[i]); i -= 1; }\n+        rs.push(v[0]);\n     }\n     move rs\n }\n@@ -1283,7 +1295,7 @@ pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i);\n             unsafe {\n-                push_all(rest, const_view(v, i+1u, ln));\n+                rest.push_all(const_view(v, i+1u, ln));\n                 permute(rest, |permutation| {\n                     put(append(~[elt], permutation))\n                 })\n@@ -1299,7 +1311,7 @@ pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len unsafe {\n-            vec::push(ww, vec::slice(xx, ii, ii+nn));\n+            ww.push(vec::slice(xx, ii, ii+nn));\n         }\n     }\n     move ww\n@@ -1551,7 +1563,7 @@ impl<T> &[T]: ImmutableVector<T> {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n-            push(r, f(&self[i]));\n+            r.push(f(&self[i]));\n             i += 1;\n         }\n         move r\n@@ -1637,6 +1649,31 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n     pure fn rfind(f: fn(T) -> bool) -> Option<T> { rfind(self, f) }\n }\n \n+trait MutableVector<T> {\n+    fn push(&mut self, +t: T);\n+    fn push_all_move(&mut self, -rhs: ~[const T]);\n+}\n+\n+trait MutableCopyableVector<T: Copy> {\n+    fn push_all(&mut self, rhs: &[const T]);\n+}\n+\n+impl<T> ~[T]: MutableVector<T> {\n+    fn push(&mut self, +t: T) {\n+        push(self, move t);\n+    }\n+\n+    fn push_all_move(&mut self, -rhs: ~[const T]) {\n+        push_all_move(self, move rhs);\n+    }\n+}\n+\n+impl<T: Copy> ~[T]: MutableCopyableVector<T> {\n+    fn push_all(&mut self, rhs: &[const T]) {\n+        push_all(self, rhs);\n+    }\n+}\n+\n /// Unsafe operations\n mod raw {\n     #[legacy_exports];\n@@ -2109,12 +2146,12 @@ mod tests {\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n-        push(v, 1);\n+        v.push(1);\n         assert (len(v) == 1u);\n         assert (v[0] == 1);\n \n         // Test on-heap push().\n-        push(v, 2);\n+        v.push(2);\n         assert (len(v) == 2u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);\n@@ -2380,19 +2417,19 @@ mod tests {\n         let mut results: ~[~[int]];\n \n         results = ~[];\n-        permute(~[], |v| vec::push(results, copy v));\n+        permute(~[], |v| results.push(copy v));\n         assert results == ~[~[]];\n \n         results = ~[];\n-        permute(~[7], |v| push(results, copy v));\n+        permute(~[7], |v| results.push(copy v));\n         assert results == ~[~[7]];\n \n         results = ~[];\n-        permute(~[1,1], |v| push(results, copy v));\n+        permute(~[1,1], |v| results.push(copy v));\n         assert results == ~[~[1,1],~[1,1]];\n \n         results = ~[];\n-        permute(~[5,2,0], |v| push(results, copy v));\n+        permute(~[5,2,0], |v| results.push(copy v));\n         assert results ==\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n     }"}, {"sha": "1f26822ed9fdbabb73eaf1c4d592be1c0cdea00c", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -648,7 +648,7 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = ~arc.clone();\n-            do task::task().future_result(|+r| vec::push(children, r)).spawn {\n+            do task::task().future_result(|+r| children.push(r)).spawn {\n                 do arc3.read |num| {\n                     assert *num >= 0;\n                 }\n@@ -676,7 +676,7 @@ mod tests {\n         let mut reader_convos = ~[];\n         for 10.times {\n             let ((rc1,rp1),(rc2,rp2)) = (pipes::stream(),pipes::stream());\n-            vec::push(reader_convos, (rc1,rp2));\n+            reader_convos.push((rc1,rp2));\n             let arcn = ~arc.clone();\n             do task::spawn {\n                 rp1.recv(); // wait for downgrader to give go-ahead"}, {"sha": "e5eacd5c440bba6a2f323e9ab0a40399a0060bde", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -102,12 +102,12 @@ impl ~[u8]: FromBase64 {\n                 } else if ch == '=' {\n                     match len - i {\n                       1u => {\n-                        vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n-                        vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n+                        r.push(((n >> 16u) & 0xFFu) as u8);\n+                        r.push(((n >> 8u ) & 0xFFu) as u8);\n                         return copy r;\n                       }\n                       2u => {\n-                        vec::push(r, ((n >> 10u) & 0xFFu) as u8);\n+                        r.push(((n >> 10u) & 0xFFu) as u8);\n                         return copy r;\n                       }\n                       _ => fail ~\"invalid base64 padding\"\n@@ -119,9 +119,9 @@ impl ~[u8]: FromBase64 {\n                 i += 1u;\n             };\n \n-            vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n-            vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n-            vec::push(r, ((n       ) & 0xFFu) as u8);\n+            r.push(((n >> 16u) & 0xFFu) as u8);\n+            r.push(((n >> 8u ) & 0xFFu) as u8);\n+            r.push(((n       ) & 0xFFu) as u8);\n         }\n \n         r"}, {"sha": "8506bd5f6fc2874397cedbf4a28c432b74687f14", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -38,8 +38,8 @@ fn create<T: Copy>() -> Deque<T> {\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {\n-                vec::push(rv, elts[(lo + i) % nelts]);\n-            } else { vec::push(rv, None); }\n+                rv.push(elts[(lo + i) % nelts]);\n+            } else { rv.push(None); }\n             i += 1u;\n         }\n "}, {"sha": "3f6bcd31a73193e1ee534560b1b09aeb71b9c227", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -211,7 +211,7 @@ impl Writer {\n         write_vuint(self.writer, tag_id);\n \n         // Write a placeholder four-byte size.\n-        vec::push(self.size_positions, self.writer.tell());\n+        self.size_positions.push(self.writer.tell());\n         let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n         self.writer.write(zeroes);\n     }"}, {"sha": "496010d579e37116baa387a651e96caced1b1fa2", "filename": "src/libstd/ebml2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -220,7 +220,7 @@ impl Serializer {\n         write_vuint(self.writer, tag_id);\n \n         // Write a placeholder four-byte size.\n-        vec::push(self.size_positions, self.writer.tell());\n+        self.size_positions.push(self.writer.tell());\n         let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n         self.writer.write(zeroes);\n     }"}, {"sha": "7a47db8a7f0730607d4eadcc980fe59653a2296d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -234,10 +234,10 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n         let cur = args[i];\n         let curlen = str::len(cur);\n         if !is_arg(cur) {\n-            vec::push(free, cur);\n+            free.push(cur);\n         } else if cur == ~\"--\" {\n             let mut j = i + 1u;\n-            while j < l { vec::push(free, args[j]); j += 1u; }\n+            while j < l { free.push(args[j]); j += 1u; }\n             break;\n         } else {\n             let mut names;\n@@ -287,7 +287,7 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                         }\n                       }\n                     }\n-                    vec::push(names, opt);\n+                    names.push(opt);\n                     j = range.next;\n                 }\n             }\n@@ -303,23 +303,22 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                     if !i_arg.is_none() {\n                         return Err(UnexpectedArgument(name_str(nm)));\n                     }\n-                    vec::push(vals[optid], Given);\n+                    vals[optid].push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vec::push(vals[optid], Val(i_arg.get()));\n+                        vals[optid].push(Val(i_arg.get()));\n                     } else if name_pos < vec::len::<Name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n-                        vec::push(vals[optid], Given);\n-                    } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n+                        vals[optid].push(Given);\n+                    } else { i += 1u; vals[optid].push(Val(args[i])); }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vec::push(vals[optid],\n-                                  Val(i_arg.get()));\n+                        vals[optid].push(Val(i_arg.get()));\n                     } else if i + 1u == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n-                    } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n+                    } else { i += 1u; vals[optid].push(Val(args[i])); }\n                   }\n                 }\n             }\n@@ -412,7 +411,7 @@ fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match *v { Val(s) => vec::push(acc, s), _ => () }\n+        match *v { Val(s) => acc.push(s), _ => () }\n     }\n     return acc;\n }"}, {"sha": "29535c62b5eb8d1a94018fffc515a627a572bb1a", "filename": "src/libstd/json.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -594,7 +594,7 @@ priv impl Parser {\n \n         loop {\n             match move self.parse_value() {\n-              Ok(move v) => vec::push(values, v),\n+              Ok(move v) => values.push(v),\n               Err(move e) => return Err(e)\n             }\n \n@@ -690,13 +690,13 @@ pub fn Deserializer(rdr: io::Reader) -> Result<Deserializer, Error> {\n }\n \n priv impl Deserializer {\n-    fn peek() -> &self/Json {\n-        if self.stack.len() == 0 { vec::push(self.stack, &self.json); }\n+    fn peek(&self) -> &self/Json {\n+        if self.stack.len() == 0 { self.stack.push(&self.json); }\n         vec::last(self.stack)\n     }\n \n-    fn pop() -> &self/Json {\n-        if self.stack.len() == 0 { vec::push(self.stack, &self.json); }\n+    fn pop(&self) -> &self/Json {\n+        if self.stack.len() == 0 { self.stack.push(&self.json); }\n         vec::pop(self.stack)\n     }\n }\n@@ -772,7 +772,7 @@ pub impl Deserializer: serialization2::Deserializer {\n     fn read_vec<T>(&self, f: fn(uint) -> T) -> T {\n         debug!(\"read_vec()\");\n         let len = match *self.peek() {\n-            List(list) => list.len(),\n+            List(ref list) => list.len(),\n             _ => fail ~\"not a list\",\n         };\n         let res = f(len);\n@@ -784,7 +784,10 @@ pub impl Deserializer: serialization2::Deserializer {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                vec::push(self.stack, &list[idx]);\n+                // FIXME(#3148)---should be inferred\n+                let list: &self/~[Json] = list;\n+\n+                self.stack.push(&list[idx]);\n                 f()\n             }\n             _ => fail ~\"not a list\",\n@@ -820,7 +823,7 @@ pub impl Deserializer: serialization2::Deserializer {\n                 match obj.find_ref(&f_name) {\n                     None => fail fmt!(\"no such field: %s\", f_name),\n                     Some(json) => {\n-                        vec::push(self.stack, json);\n+                        self.stack.push(json);\n                         f()\n                     }\n                 }\n@@ -845,8 +848,10 @@ pub impl Deserializer: serialization2::Deserializer {\n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n-            List(list) => {\n-                vec::push(self.stack, &list[idx]);\n+            List(ref list) => {\n+                // FIXME(#3148)---should be inferred\n+                let list: &self/~[Json] = list;\n+                self.stack.push(&list[idx]);\n                 f()\n             }\n             _ => fail ~\"not a list\"\n@@ -939,12 +944,12 @@ impl Json : Ord {\n \n                             // XXX: this is horribly inefficient...\n                             for d0.each |k, v| {\n-                                 vec::push(d0_flat, (@copy *k, @copy *v));\n+                                 d0_flat.push((@copy *k, @copy *v));\n                             }\n                             d0_flat.qsort();\n \n                             for d1.each |k, v| {\n-                                vec::push(d1_flat, (@copy *k, @copy *v));\n+                                d1_flat.push((@copy *k, @copy *v));\n                             }\n                             d1_flat.qsort();\n "}, {"sha": "0bf4f6f86108c439a98da2e20322f9b605674168", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -11,14 +11,14 @@ fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     let mut msg = vec::append(vec::from_slice(msg), ~[0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n-        vec::push(msg, 0u8);\n+        msg.push(0u8);\n         bitlen += 8u64;\n     }\n \n     // append length\n     let mut i = 0u64;\n     while i < 8u64 {\n-        vec::push(msg, (orig_len >> (i * 8u64)) as u8);\n+        msg.push((orig_len >> (i * 8u64)) as u8);\n         i += 1u64;\n     }\n "}, {"sha": "347f2b271a1d9aa616b575ba01d3b1b37dbd11b8", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -277,7 +277,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                         result::Err(GetAddrUnknownError));\n                     break;\n                 };\n-                vec::push(out_vec, move new_ip_addr);\n+                out_vec.push(move new_ip_addr);\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {"}, {"sha": "a0ba8aae3f11d27485d2d1f3b798b9cd16e11d3c", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -779,7 +779,7 @@ impl TcpSocketBuf: io::Reader {\n                 }\n             }\n             else {\n-                vec::push_all(self.data.buf, result::unwrap(read_result));\n+                self.data.buf.push_all(result::unwrap(read_result));\n             }\n         }\n \n@@ -790,7 +790,7 @@ impl TcpSocketBuf: io::Reader {\n \n         vec::bytes::memcpy(buf, vec::view(data, 0, data.len()), count);\n \n-        vec::push_all(self.data.buf, vec::view(data, count, data.len()));\n+        self.data.buf.push_all(vec::view(data, count, data.len()));\n \n         count\n     }"}, {"sha": "33e657c390b9834f6b713987dddf5dadd0dbe032", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -329,7 +329,7 @@ fn query_from_str(rawquery: &str) -> Query {\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n             let (k, v) = split_char_first(*p, '=');\n-            vec::push(query, (decode_component(k), decode_component(v)));\n+            query.push((decode_component(k), decode_component(v)));\n         };\n     }\n     return query;"}, {"sha": "2f98c4bad3494895c4d4217d2c561f8854cdc10b", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -55,7 +55,7 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n                         f(base, slice)\n                     }\n                 };\n-                vec::push(futures, move f);\n+                futures.push(move f);\n             };\n             base += items_per_task;\n         }"}, {"sha": "4680448e2758022ee68b08197ef888e4363f2b7b", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -869,7 +869,7 @@ mod node {\n         loop {\n             match (leaf_iterator::next(&it)) {\n               option::None    => break,\n-              option::Some(x) => vec::push(forest, @Leaf(x))\n+              option::Some(x) => forest.push(@Leaf(x))\n             }\n         }\n         //2. Rebuild tree from forest"}, {"sha": "f1abe5be5a51e44bfa16224eacfcd539e96b3542", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -47,9 +47,9 @@ fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n         let mut b_ix = 0u;\n         while a_ix < a_len && b_ix < b_len {\n             if le(&a[a_ix], &b[b_ix]) {\n-                vec::push(rs, a[a_ix]);\n+                rs.push(a[a_ix]);\n                 a_ix += 1u;\n-            } else { vec::push(rs, b[b_ix]); b_ix += 1u; }\n+            } else { rs.push(b[b_ix]); b_ix += 1u; }\n         }\n         rs = vec::append(rs, vec::slice(a, a_ix, a_len));\n         rs = vec::append(rs, vec::slice(b, b_ix, b_len));"}, {"sha": "7638b43ad86aeeb76cfe95ebc517cb8fc221c8da", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -82,7 +82,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n         -> Sem<~[mut Waitqueue]> {\n     let mut queues = ~[];\n     for num_condvars.times {\n-        vec::push(queues, new_waitqueue());\n+        queues.push(new_waitqueue());\n     }\n     new_sem(count, vec::to_mut(move queues))\n }\n@@ -840,7 +840,7 @@ mod tests {\n         for num_waiters.times {\n             let mi = ~m.clone();\n             let (chan, port) = pipes::stream();\n-            vec::push(ports, port);\n+            ports.push(port);\n             do task::spawn {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n@@ -930,7 +930,7 @@ mod tests {\n             for 2.times {\n                 let (c,p) = pipes::stream();\n                 let c = ~mut Some(c);\n-                vec::push(sibling_convos, p);\n+                sibling_convos.push(p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n@@ -1194,7 +1194,7 @@ mod tests {\n         for num_waiters.times {\n             let xi = ~x.clone();\n             let (chan, port) = pipes::stream();\n-            vec::push(ports, port);\n+            ports.push(port);\n             do task::spawn {\n                 do lock_cond(xi, dg1) |cond| {\n                     chan.send(());"}, {"sha": "facc43f62734bb5c58e7889417d33ffd082c569a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -141,7 +141,7 @@ fn run_tests_console(opts: &TestOpts,\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n-                vec::push(st.failures, copy test);\n+                st.failures.push(copy test);\n               }\n               TrIgnored => {\n                 st.ignored += 1u;\n@@ -545,7 +545,7 @@ mod tests {\n             for vec::each(names) |name| {\n                 let test = {name: *name, testfn: copy testfn, ignore: false,\n                             should_fail: false};\n-                vec::push(tests, test);\n+                tests.push(test);\n             }\n             tests\n         };"}, {"sha": "b6d4c2d0fe3497ec83f6621f4b4c677b2ec3fd9e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -273,9 +273,9 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     }\n     match i.node {\n       item_mod(_) | item_foreign_mod(_) => {\n-        vec::push(cx.path, path_mod(i.ident));\n+        cx.path.push(path_mod(i.ident));\n       }\n-      _ => vec::push(cx.path, path_name(i.ident))\n+      _ => cx.path.push(path_name(i.ident))\n     }\n     visit::visit_item(i, cx, v);\n     vec::pop(cx.path);"}, {"sha": "329c9f362a4654a7b6db13cec34e20e964048e8e", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -313,8 +313,8 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n         match *trt_method {\n-          required(tm) => vec::push(reqd, tm),\n-          provided(m) => vec::push(provd, m)\n+          required(tm) => reqd.push(tm),\n+          provided(m) => provd.push(m)\n         }\n     };\n     (reqd, provd)"}, {"sha": "7ef34d8eb0b3d85f095f5d00043c71d034733167", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -91,7 +91,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     let mut mitems = ~[];\n-    for attrs.each |a| { vec::push(mitems, attr_meta(*a)); }\n+    for attrs.each |a| { mitems.push(attr_meta(*a)); }\n     return mitems;\n }\n "}, {"sha": "e07985119ec49630c7b2f2c47f702da202fd5fb6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -84,7 +84,7 @@ fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n-    vec::push(file.lines, {ch: chpos, byte: byte_pos + file.start_pos.byte});\n+    file.lines.push({ch: chpos, byte: byte_pos + file.start_pos.byte});\n }\n \n type lookup_fn = pure fn(file_pos) -> uint;\n@@ -204,7 +204,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let hi = lookup_char_pos(cm, sp.hi);\n     let mut lines = ~[];\n     for uint::range(lo.line - 1u, hi.line as uint) |i| {\n-        vec::push(lines, i);\n+        lines.push(i);\n     };\n     return @{file: lo.file, lines: lines};\n }"}, {"sha": "b51184eefd80e49ab9ead29c706f1f85000fd49d", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -750,7 +750,7 @@ fn mk_enum_deser_body(\n         body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n     };\n \n-    vec::push(arms, impossible_case);\n+    arms.push(impossible_case);\n \n     // ast for `|i| { match i { $(arms) } }`\n     let expr_lambda = cx.expr("}, {"sha": "566cdc4fa21dbaf6a900ec33cb45b84963da6858", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -160,7 +160,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn cfg() -> ast::crate_cfg { self.cfg }\n         fn print_backtrace() { }\n         fn backtrace() -> expn_info { self.backtrace }\n-        fn mod_push(i: ast::ident) { vec::push(self.mod_path, i); }\n+        fn mod_push(i: ast::ident) { self.mod_path.push(i); }\n         fn mod_pop() { vec::pop(self.mod_path); }\n         fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n         fn bt_push(ei: codemap::expn_info_) {"}, {"sha": "8ce426f03575ad6ae443a6e2953fe751f4f3641a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -96,7 +96,7 @@ fn mk_rec_e(cx: ext_ctxt, sp: span,\n         let val = field.ex;\n         let astfield =\n             {node: {mutbl: ast::m_imm, ident: ident, expr: val}, span: sp};\n-        vec::push(astfields, astfield);\n+        astfields.push(astfield);\n     }\n     let recexpr = ast::expr_rec(astfields, option::None::<@ast::expr>);\n     mk_expr(cx, sp, recexpr)"}, {"sha": "e4f197801c2a02d5e0f64a3f7aedb600a788bb2e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -245,7 +245,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     for pieces.each |pc| {\n         match *pc {\n           PieceString(s) => {\n-            vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s))\n+            piece_exprs.push(mk_uniq_str(cx, fmt_sp, s))\n           }\n           PieceConv(conv) => {\n             n += 1u;\n@@ -258,7 +258,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n-            vec::push(piece_exprs, c_expr);\n+            piece_exprs.push(c_expr);\n           }\n         }\n     }"}, {"sha": "a9bfd87ab0eb3506e747cd6c3655b7aeb40b470a", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -65,7 +65,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     let mut self_live = ~[];\n     for colive.eachi |i, bv| {\n         if bv.get(i) {\n-            vec::push(self_live, proto.get_state_by_id(i))\n+            self_live.push(proto.get_state_by_id(i))\n         }\n     }\n "}, {"sha": "f93fa830f926daf08319a27e77cf04f8b4f3d306", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -226,7 +226,7 @@ impl state: to_type_decls {\n \n             let v = cx.variant(cx.ident_of(name), span, tys);\n \n-            vec::push(items_msg, v);\n+            items_msg.push(v);\n         }\n \n         ~[cx.item_enum_poly(name,\n@@ -245,44 +245,44 @@ impl state: to_type_decls {\n         let mut items = ~[];\n         for self.messages.each |m| {\n             if dir == send {\n-                vec::push(items, m.gen_send(cx, true));\n-                vec::push(items, m.gen_send(cx, false));\n+                items.push(m.gen_send(cx, true));\n+                items.push(m.gen_send(cx, false));\n             }\n         }\n \n         if !self.proto.is_bounded() {\n-            vec::push(items,\n-                      cx.item_ty_poly(\n-                          self.data_name(),\n-                          self.span,\n-                          cx.ty_path_ast_builder(\n-                              path(~[cx.ident_of(~\"pipes\"),\n-                                     cx.ident_of(dir.to_str() + ~\"Packet\")],\n-                                   empty_span())\n-                              .add_ty(cx.ty_path_ast_builder(\n-                                  path(~[cx.ident_of(self.proto.name),\n-                                         self.data_name()],\n-                                       empty_span())\n-                                  .add_tys(cx.ty_vars(self.ty_params))))),\n-                          self.ty_params));\n+            items.push(\n+                cx.item_ty_poly(\n+                    self.data_name(),\n+                    self.span,\n+                    cx.ty_path_ast_builder(\n+                        path(~[cx.ident_of(~\"pipes\"),\n+                               cx.ident_of(dir.to_str() + ~\"Packet\")],\n+                             empty_span())\n+                        .add_ty(cx.ty_path_ast_builder(\n+                            path(~[cx.ident_of(self.proto.name),\n+                                   self.data_name()],\n+                                 empty_span())\n+                            .add_tys(cx.ty_vars(self.ty_params))))),\n+                    self.ty_params));\n         }\n         else {\n-            vec::push(items,\n-                      cx.item_ty_poly(\n-                          self.data_name(),\n-                          self.span,\n-                          cx.ty_path_ast_builder(\n-                              path(~[cx.ident_of(~\"pipes\"),\n-                                     cx.ident_of(dir.to_str()\n-                                                 + ~\"PacketBuffered\")],\n-                                  empty_span())\n-                              .add_tys(~[cx.ty_path_ast_builder(\n-                                  path(~[cx.ident_of(self.proto.name),\n-                                         self.data_name()],\n-                                       empty_span())\n-                                  .add_tys(cx.ty_vars(self.ty_params))),\n-                                         self.proto.buffer_ty_path(cx)])),\n-                          self.ty_params));\n+            items.push(\n+                cx.item_ty_poly(\n+                    self.data_name(),\n+                    self.span,\n+                    cx.ty_path_ast_builder(\n+                        path(~[cx.ident_of(~\"pipes\"),\n+                               cx.ident_of(dir.to_str()\n+                                           + ~\"PacketBuffered\")],\n+                             empty_span())\n+                        .add_tys(~[cx.ty_path_ast_builder(\n+                            path(~[cx.ident_of(self.proto.name),\n+                                   self.data_name()],\n+                                 empty_span())\n+                            .add_tys(cx.ty_vars(self.ty_params))),\n+                                   self.proto.buffer_ty_path(cx)])),\n+                    self.ty_params));\n         };\n         items\n     }\n@@ -367,7 +367,7 @@ impl protocol: gen_init {\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  None => vec::push(params, *tp),\n+                  None => params.push(*tp),\n                   _ => ()\n                 }\n             }\n@@ -383,7 +383,7 @@ impl protocol: gen_init {\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n-                  None => vec::push(params, *tp),\n+                  None => params.push(*tp),\n                   _ => ()\n                 }\n             }\n@@ -415,17 +415,15 @@ impl protocol: gen_init {\n         }\n \n         if self.is_bounded() {\n-            vec::push(items, self.gen_buffer_type(cx))\n+            items.push(self.gen_buffer_type(cx))\n         }\n \n-        vec::push(items,\n-                  cx.item_mod(cx.ident_of(~\"client\"),\n-                              self.span,\n-                              client_states));\n-        vec::push(items,\n-                  cx.item_mod(cx.ident_of(~\"server\"),\n-                              self.span,\n-                              server_states));\n+        items.push(cx.item_mod(cx.ident_of(~\"client\"),\n+                               self.span,\n+                               client_states));\n+        items.push(cx.item_mod(cx.ident_of(~\"server\"),\n+                               self.span,\n+                               server_states));\n \n         cx.item_mod(cx.ident_of(self.name), self.span, items)\n     }"}, {"sha": "51239754635c0f29395c26233961b9fb5a408e69", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -94,7 +94,7 @@ fn option_flatten_map<T: Copy, U: Copy>(f: fn@(T) -> Option<U>, v: ~[T]) ->\n     for v.each |elem| {\n         match f(*elem) {\n           None => return None,\n-          Some(fv) => vec::push(res, fv)\n+          Some(fv) => res.push(fv)\n         }\n     }\n     return Some(res);\n@@ -305,8 +305,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                 /* Whew, we now know how how many times to repeat */\n                 let mut idx: uint = 0u;\n                 while idx < rc {\n-                    vec::push(*idx_path, idx);\n-                    vec::push(res, recur(repeat_me)); // whew!\n+                    idx_path.push(idx);\n+                    res.push(recur(repeat_me)); // whew!\n                     vec::pop(*idx_path);\n                     idx += 1u;\n                 }\n@@ -567,7 +567,7 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n                     let mut elts = ~[];\n                     let mut idx = offset;\n                     while idx < vec::len(arg_elts) {\n-                        vec::push(elts, leaf(match_expr(arg_elts[idx])));\n+                        elts.push(leaf(match_expr(arg_elts[idx])));\n                         idx += 1u;\n                     }\n \n@@ -672,9 +672,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                       None => cx.span_fatal(mac.span,\n                                            ~\"macro must have arguments\")\n                     };\n-                    vec::push(clauses,\n-                              @{params: pattern_to_selectors(cx, arg),\n-                                body: elts[1u]});\n+                    clauses.push(@{params: pattern_to_selectors(cx, arg),\n+                                   body: elts[1u]});\n \n                     // FIXME (#2251): check duplicates (or just simplify\n                     // the macro arg situation)"}, {"sha": "737694337e3bfb4dcbd718a843a6e891a7bcd010", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -208,7 +208,7 @@ fn parse_or_else(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader,\n fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n     -> parse_result {\n     let mut cur_eis = ~[];\n-    vec::push(cur_eis, initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n+    cur_eis.push(initial_matcher_pos(ms, None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -256,7 +256,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                         }\n \n                         new_pos.idx += 1;\n-                        vec::push(cur_eis, move new_pos);\n+                        cur_eis.push(move new_pos);\n                     }\n \n                     // can we go around again?\n@@ -267,17 +267,17 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                         if tok == t { //pass the separator\n                             let ei_t <- ei;\n                             ei_t.idx += 1;\n-                            vec::push(next_eis, move ei_t);\n+                            next_eis.push(move ei_t);\n                         }\n                       }\n                       _ => { // we don't need a separator\n                         let ei_t <- ei;\n                         ei_t.idx = 0;\n-                        vec::push(cur_eis, move ei_t);\n+                        cur_eis.push(move ei_t);\n                       }\n                     }\n                 } else {\n-                    vec::push(eof_eis, move ei);\n+                    eof_eis.push(move ei);\n                 }\n             } else {\n                 match copy ei.elts[idx].node {\n@@ -292,26 +292,26 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                             new_ei.matches[idx].push(@matched_seq(~[], sp));\n                         }\n \n-                        vec::push(cur_eis, move new_ei);\n+                        cur_eis.push(move new_ei);\n                     }\n \n                     let matches = vec::map(ei.matches, // fresh, same size:\n                                            |_m| DVec::<@named_match>());\n                     let ei_t <- ei;\n-                    vec::push(cur_eis, ~{\n+                    cur_eis.push(~{\n                         elts: matchers, sep: sep, mut idx: 0u,\n                         mut up: matcher_pos_up(Some(move ei_t)),\n                         matches: move matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n-                  match_nonterminal(_,_,_) => { vec::push(bb_eis, move ei) }\n+                  match_nonterminal(_,_,_) => { bb_eis.push(move ei) }\n                   match_tok(t) => {\n                     let ei_t <- ei;\n                     if t == tok {\n                         ei_t.idx += 1;\n-                        vec::push(next_eis, move ei_t);\n+                        next_eis.push(move ei_t);\n                     }\n                   }\n                 }\n@@ -323,7 +323,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n             if eof_eis.len() == 1u {\n                 return success(\n                     nameize(sess, ms,\n-                            vec::map(eof_eis[0u].matches, |dv| dv.pop())));\n+                            eof_eis[0u].matches.map(|dv| dv.pop())));\n             } else if eof_eis.len() > 1u {\n                 return error(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {\n@@ -350,7 +350,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n                 while(next_eis.len() > 0u) {\n-                    vec::push(cur_eis, vec::pop(next_eis));\n+                    cur_eis.push(vec::pop(next_eis));\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n@@ -365,7 +365,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                   }\n                   _ => fail\n                 }\n-                vec::push(cur_eis, move ei);\n+                cur_eis.push(move ei);\n \n                 /* this would fail if zero-length tokens existed */\n                 while rdr.peek().sp.lo < rust_parser.span.lo {"}, {"sha": "558593579bfae22b3fdf88d58a80bf5c982b4167", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -205,8 +205,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n                     r.cur.idx += 1u;\n                     return tt_next_token(r);\n                 } else {\n-                    vec::push(r.repeat_len, len);\n-                    vec::push(r.repeat_idx, 0u);\n+                    r.repeat_len.push(len);\n+                    r.repeat_idx.push(0u);\n                     r.cur = @{readme: tts, mut idx: 0u, dotdotdoted: true,\n                               sep: sep, up: tt_frame_up(option::Some(r.cur))};\n                 }"}, {"sha": "12c8dc2f7bb044af9d735acb0a18fd2ef12277fc", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -367,19 +367,17 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_rec(fields, etc) => {\n             let mut fs = ~[];\n             for fields.each |f| {\n-                vec::push(fs,\n-                          {ident: /* FIXME (#2543) */ copy f.ident,\n-                           pat: fld.fold_pat(f.pat)});\n+                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n+                         pat: fld.fold_pat(f.pat)});\n             }\n             pat_rec(fs, etc)\n           }\n           pat_struct(pth, fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let mut fs = ~[];\n             for fields.each |f| {\n-                vec::push(fs,\n-                          {ident: /* FIXME (#2543) */ copy f.ident,\n-                           pat: fld.fold_pat(f.pat)});\n+                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n+                         pat: fld.fold_pat(f.pat)});\n             }\n             pat_struct(pth_, fs, etc)\n           }"}, {"sha": "cb8416501b37f170084e7243a2149a0383ef3024", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -130,7 +130,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n fn push_blank_line_comment(rdr: string_reader, &comments: ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    vec::push(comments, {style: blank_line, lines: v, pos: rdr.chpos});\n+    comments.push({style: blank_line, lines: v, pos: rdr.chpos});\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n@@ -149,7 +149,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n     debug!(\">>> shebang comment\");\n     let p = rdr.chpos;\n     debug!(\"<<< shebang comment\");\n-    vec::push(comments, {\n+    comments.push({\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n         pos: p\n@@ -167,12 +167,12 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n         if is_doc_comment(line) { // doc-comments are not put in comments\n             break;\n         }\n-        vec::push(lines, line);\n+        lines.push(line);\n         consume_non_eol_whitespace(rdr);\n     }\n     debug!(\"<<< line comments\");\n     if !lines.is_empty() {\n-        vec::push(comments, {\n+        comments.push({\n             style: if code_to_the_left { trailing } else { isolated },\n             lines: lines,\n             pos: p\n@@ -198,7 +198,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n         } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n     log(debug, ~\"pushing line: \" + s1);\n-    vec::push(lines, s1);\n+    lines.push(s1);\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n@@ -257,7 +257,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n         style = mixed;\n     }\n     debug!(\"<<< block comment\");\n-    vec::push(comments, {style: style, lines: lines, pos: p});\n+    comments.push({style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: string_reader) -> bool {\n@@ -315,7 +315,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         let {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n-            vec::push(literals, {lit: s, pos: sp.lo});\n+            literals.push({lit: s, pos: sp.lo});\n             log(debug, ~\"tok lit: \" + s);\n         } else {\n             log(debug, ~\"tok: \" + token::to_str(rdr.interner, tok));"}, {"sha": "c8c30ee7fa9cbaf179b7f895da0233ab533f26b6", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -229,7 +229,7 @@ impl parser: parser_common {\n               }\n               _ => ()\n             }\n-            vec::push(v, f(self));\n+            v.push(f(self));\n         }\n \n         return v;\n@@ -274,7 +274,7 @@ impl parser: parser_common {\n               _ => ()\n             }\n             if sep.trailing_sep_allowed && self.token == ket { break; }\n-            vec::push(v, f(self));\n+            v.push(f(self));\n         }\n         return v;\n     }"}, {"sha": "14dc490346eb94df5805ed59acc7b2b1ef6469e7", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -107,7 +107,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = r0.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + r0.pos;\n-        vec::push(items, i);\n+        items.push(i);\n       }\n       ast::cdir_dir_mod(vis, id, cdirs, attrs) => {\n         let path = Path(cdir_path_opt(*cx.sess.interner.get(id), attrs));\n@@ -126,9 +126,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n               vis: vis,\n               span: cdir.span};\n         cx.sess.next_id += 1;\n-        vec::push(items, i);\n+        items.push(i);\n       }\n-      ast::cdir_view_item(vi) => vec::push(view_items, vi),\n+      ast::cdir_view_item(vi) => view_items.push(vi),\n       ast::cdir_syntax(*) => ()\n     }\n }"}, {"sha": "10981c5c708debc106b280c9c8d228078aef4620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -496,7 +496,7 @@ impl parser {\n                 let mut ts = ~[self.parse_ty(false)];\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    vec::push(ts, self.parse_ty(false));\n+                    ts.push(self.parse_ty(false));\n                 }\n                 let t = if vec::len(ts) == 1u { ts[0].node }\n                 else { ty_tup(ts) };\n@@ -771,10 +771,10 @@ impl parser {\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                vec::push(ids, parse_ident(self));\n+                ids.push(parse_ident(self));\n                 self.expect(token::MOD_SEP);\n             } else {\n-                vec::push(ids, parse_last_ident(self));\n+                ids.push(parse_last_ident(self));\n                 break;\n             }\n         }\n@@ -903,7 +903,7 @@ impl parser {\n             }\n             let mut es = ~[self.parse_expr()];\n             while self.token == token::COMMA {\n-                self.bump(); vec::push(es, self.parse_expr());\n+                self.bump(); es.push(self.parse_expr());\n             }\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n@@ -1049,7 +1049,7 @@ impl parser {\n                     self.bump();\n                     let mut fields = ~[];\n                     let mut base = None;\n-                    vec::push(fields, self.parse_field(token::COLON));\n+                    fields.push(self.parse_field(token::COLON));\n                     while self.token != token::RBRACE {\n \n                         if self.try_parse_obsolete_with() {\n@@ -1067,7 +1067,7 @@ impl parser {\n                             // Accept an optional trailing comma.\n                             break;\n                         }\n-                        vec::push(fields, self.parse_field(token::COLON));\n+                        fields.push(self.parse_field(token::COLON));\n                     }\n \n                     hi = pth.span.hi;\n@@ -1316,7 +1316,7 @@ impl parser {\n         while self.token != ket || lparens > 0u {\n             if self.token == token::LPAREN { lparens += 1u; }\n             if self.token == token::RPAREN { lparens -= 1u; }\n-            vec::push(ret_val, self.parse_matcher(name_idx));\n+            ret_val.push(self.parse_matcher(name_idx));\n         }\n \n         self.bump();\n@@ -1722,7 +1722,7 @@ impl parser {\n                 // record ends by an optional trailing comma\n                 break;\n             }\n-            vec::push(fields, self.parse_field(token::COLON));\n+            fields.push(self.parse_field(token::COLON));\n         }\n         self.expect(token::RBRACE);\n         return expr_rec(fields, base);\n@@ -1757,7 +1757,7 @@ impl parser {\n                               rules: default_blk},\n                        span: expr.span};\n \n-            vec::push(arms, {pats: pats, guard: guard, body: blk});\n+            arms.push({pats: pats, guard: guard, body: blk});\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n@@ -1802,7 +1802,7 @@ impl parser {\n     fn parse_pats() -> ~[@pat] {\n         let mut pats = ~[];\n         loop {\n-            vec::push(pats, self.parse_pat(true));\n+            pats.push(self.parse_pat(true));\n             if self.token == token::BINOP(token::OR) { self.bump(); }\n             else { return pats; }\n         };\n@@ -1849,7 +1849,7 @@ impl parser {\n                     span: self.last_span\n                 };\n             }\n-            vec::push(fields, {ident: fieldname, pat: subpat});\n+            fields.push({ident: fieldname, pat: subpat});\n         }\n         return (fields, etc);\n     }\n@@ -1937,7 +1937,7 @@ impl parser {\n                 let mut fields = ~[self.parse_pat(refutable)];\n                 while self.token == token::COMMA {\n                     self.bump();\n-                    vec::push(fields, self.parse_pat(refutable));\n+                    fields.push(self.parse_pat(refutable));\n                 }\n                 if vec::len(fields) == 1u { self.expect(token::COMMA); }\n                 hi = self.span.hi;\n@@ -2126,7 +2126,7 @@ impl parser {\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl, true)];\n         while self.eat(token::COMMA) {\n-            vec::push(locals, self.parse_local(is_mutbl, true));\n+            locals.push(self.parse_local(is_mutbl, true));\n         }\n         return @spanned(lo, self.last_span.hi, decl_local(locals));\n     }\n@@ -2266,8 +2266,8 @@ impl parser {\n \n         for items.each |item| {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n-            push(stmts, @spanned(item.span.lo, item.span.hi,\n-                                 stmt_decl(decl, self.get_id())));\n+            stmts.push(@spanned(item.span.lo, item.span.hi,\n+                                stmt_decl(decl, self.get_id())));\n         }\n \n         let mut initial_attrs = attrs_remaining;\n@@ -2278,43 +2278,43 @@ impl parser {\n \n         while self.token != token::RBRACE {\n             match self.token {\n-              token::SEMI => {\n-                self.bump(); // empty\n-              }\n-              _ => {\n-                let stmt = self.parse_stmt(initial_attrs);\n-                initial_attrs = ~[];\n-                match stmt.node {\n-                  stmt_expr(e, stmt_id) => { // Expression without semicolon:\n-                    match self.token {\n-                      token::SEMI => {\n-                        self.bump();\n-                        push(stmts,\n-                             @{node: stmt_semi(e, stmt_id),.. *stmt});\n-                      }\n-                      token::RBRACE => {\n-                        expr = Some(e);\n-                      }\n-                      t => {\n-                        if classify::stmt_ends_with_semi(*stmt) {\n-                            self.fatal(~\"expected `;` or `}` after \\\n-                                         expression but found `\"\n-                                       + token_to_str(self.reader, t) + ~\"`\");\n+                token::SEMI => {\n+                    self.bump(); // empty\n+                }\n+                _ => {\n+                    let stmt = self.parse_stmt(initial_attrs);\n+                    initial_attrs = ~[];\n+                    match stmt.node {\n+                        stmt_expr(e, stmt_id) => { // Expression without semicolon:\n+                            match self.token {\n+                                token::SEMI => {\n+                                    self.bump();\n+                                    stmts.push(@{node: stmt_semi(e, stmt_id),\n+                                                 ..*stmt});\n+                                }\n+                                token::RBRACE => {\n+                                    expr = Some(e);\n+                                }\n+                                t => {\n+                                    if classify::stmt_ends_with_semi(*stmt) {\n+                                        self.fatal(~\"expected `;` or `}` after \\\n+                                                     expression but found `\"\n+                                                   + token_to_str(self.reader, t) + ~\"`\");\n+                                    }\n+                                    stmts.push(stmt);\n+                                }\n+                            }\n                         }\n-                        vec::push(stmts, stmt);\n-                      }\n-                    }\n-                  }\n \n-                  _ => { // All other kinds of statements:\n-                    vec::push(stmts, stmt);\n+                        _ => { // All other kinds of statements:\n+                            stmts.push(stmt);\n \n-                    if classify::stmt_ends_with_semi(*stmt) {\n-                        self.expect(token::SEMI);\n+                            if classify::stmt_ends_with_semi(*stmt) {\n+                                self.expect(token::SEMI);\n+                            }\n+                        }\n                     }\n-                  }\n                 }\n-              }\n             }\n         }\n         let mut hi = self.span.hi;\n@@ -2356,16 +2356,16 @@ impl parser {\n                     };\n \n                     match maybe_bound {\n-                      Some(bound) => {\n-                        self.bump();\n-                        push(bounds, bound);\n-                      }\n-                      None => {\n-                        push(bounds, bound_trait(self.parse_ty(false)));\n-                      }\n+                        Some(bound) => {\n+                            self.bump();\n+                            bounds.push(bound);\n+                        }\n+                        None => {\n+                            bounds.push(bound_trait(self.parse_ty(false)));\n+                        }\n                     }\n                 } else {\n-                    push(bounds, bound_trait(self.parse_ty(false)));\n+                    bounds.push(bound_trait(self.parse_ty(false)));\n                 }\n             }\n         }\n@@ -2636,7 +2636,7 @@ impl parser {\n         self.expect(token::LBRACE);\n         while !self.eat(token::RBRACE) {\n             let vis = self.parse_visibility();\n-            vec::push(meths, self.parse_method(vis));\n+            meths.push(self.parse_method(vis));\n         }\n         (ident, item_impl(tps, opt_trait, ty, meths), None)\n     }\n@@ -2722,9 +2722,9 @@ impl parser {\n                     for mms.each |mm| {\n                         match *mm {\n                             @field_member(struct_field) =>\n-                                vec::push(fields, struct_field),\n+                                fields.push(struct_field),\n                             @method_member(the_method_member) =>\n-                                vec::push(methods, the_method_member)\n+                                methods.push(the_method_member)\n                         }\n                     }\n                   }\n@@ -2896,7 +2896,7 @@ impl parser {\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n                    attrs);\n             match self.parse_item_or_view_item(attrs, true) {\n-              iovi_item(item) => vec::push(items, item),\n+              iovi_item(item) => items.push(item),\n               iovi_view_item(view_item) => {\n                 self.span_fatal(view_item.span, ~\"view items must be \\\n                                                   declared at the top of the \\\n@@ -3000,7 +3000,7 @@ impl parser {\n             let attrs = vec::append(initial_attrs,\n                                     self.parse_outer_attributes());\n             initial_attrs = ~[];\n-            vec::push(items, self.parse_foreign_item(attrs));\n+            items.push(self.parse_foreign_item(attrs));\n         }\n         return {sort: sort, view_items: view_items,\n              items: items};\n@@ -3113,9 +3113,9 @@ impl parser {\n                     for mms.each |mm| {\n                         match *mm {\n                             @field_member(struct_field) =>\n-                                vec::push(fields, struct_field),\n+                                fields.push(struct_field),\n                             @method_member(the_method_member) =>\n-                                vec::push(methods, the_method_member)\n+                                methods.push(the_method_member)\n                         }\n                     }\n                 }\n@@ -3184,7 +3184,7 @@ impl parser {\n                         seq_sep_trailing_disallowed(token::COMMA),\n                         |p| p.parse_ty(false));\n                     for arg_tys.each |ty| {\n-                        vec::push(args, {ty: *ty, id: self.get_id()});\n+                        args.push({ty: *ty, id: self.get_id()});\n                     }\n                     kind = tuple_variant_kind(args);\n                 } else if self.eat(token::EQ) {\n@@ -3200,7 +3200,7 @@ impl parser {\n             let vr = {name: ident, attrs: variant_attrs,\n                       kind: kind, id: self.get_id(),\n                       disr_expr: disr_expr, vis: vis};\n-            vec::push(variants, spanned(vlo, self.last_span.hi, vr));\n+            variants.push(spanned(vlo, self.last_span.hi, vr));\n \n             if needs_comma && !self.eat(token::COMMA) { break; }\n         }\n@@ -3427,7 +3427,7 @@ impl parser {\n             while self.token == token::MOD_SEP {\n                 self.bump();\n                 let id = self.parse_ident();\n-                vec::push(path, id);\n+                path.push(id);\n             }\n             let path = @{span: mk_sp(lo, self.span.hi), global: false,\n                          idents: path, rp: None, types: ~[]};\n@@ -3445,7 +3445,7 @@ impl parser {\n \n                   token::IDENT(i, _) => {\n                     self.bump();\n-                    vec::push(path, i);\n+                    path.push(i);\n                   }\n \n                   // foo::bar::{a,b,c}\n@@ -3488,7 +3488,7 @@ impl parser {\n         let mut vp = ~[self.parse_view_path()];\n         while self.token == token::COMMA {\n             self.bump();\n-            vec::push(vp, self.parse_view_path());\n+            vp.push(self.parse_view_path());\n         }\n         return vp;\n     }\n@@ -3662,7 +3662,7 @@ impl parser {\n         let mut first_outer_attr = first_outer_attr;\n         while self.token != term {\n             let cdir = @self.parse_crate_directive(first_outer_attr);\n-            vec::push(cdirs, cdir);\n+            cdirs.push(cdir);\n             first_outer_attr = ~[];\n         }\n         return cdirs;"}, {"sha": "4bbd51524c42868f397fb575cfbe846bd6c7cdce", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -392,14 +392,14 @@ fn build_link_meta(sess: session, c: ast::crate, output: &Path,\n             if attr::get_meta_item_name(*meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { name = Some(v); }\n-                  None => vec::push(cmh_items, *meta)\n+                  None => cmh_items.push(*meta)\n                 }\n             } else if attr::get_meta_item_name(*meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(*meta) {\n                   Some(v) => { vers = Some(v); }\n-                  None => vec::push(cmh_items, *meta)\n+                  None => cmh_items.push(*meta)\n                 }\n-            } else { vec::push(cmh_items, *meta); }\n+            } else { cmh_items.push(*meta); }\n         }\n         return {name: name, vers: vers, cmh_items: cmh_items};\n     }\n@@ -657,9 +657,9 @@ fn link_binary(sess: session,\n \n     let mut cc_args =\n         vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n-    vec::push(cc_args, ~\"-o\");\n-    vec::push(cc_args, output.to_str());\n-    vec::push(cc_args, obj_filename.to_str());\n+    cc_args.push(~\"-o\");\n+    cc_args.push(output.to_str());\n+    cc_args.push(obj_filename.to_str());\n \n     let mut lib_cmd;\n     let os = sess.targ_cfg.os;\n@@ -674,17 +674,17 @@ fn link_binary(sess: session,\n     let cstore = sess.cstore;\n     for cstore::get_used_crate_files(cstore).each |cratepath| {\n         if cratepath.filetype() == Some(~\".rlib\") {\n-            vec::push(cc_args, cratepath.to_str());\n+            cc_args.push(cratepath.to_str());\n             loop;\n         }\n         let dir = cratepath.dirname();\n-        if dir != ~\"\" { vec::push(cc_args, ~\"-L\" + dir); }\n+        if dir != ~\"\" { cc_args.push(~\"-L\" + dir); }\n         let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n-        vec::push(cc_args, ~\"-l\" + libarg);\n+        cc_args.push(~\"-l\" + libarg);\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { vec::push(cc_args, *arg); }\n+    for ula.each |arg| { cc_args.push(*arg); }\n \n     // # Extern library linking\n \n@@ -695,41 +695,41 @@ fn link_binary(sess: session,\n     // forces to make sure that library can be found at runtime.\n \n     let addl_paths = sess.opts.addl_lib_search_paths;\n-    for addl_paths.each |path| { vec::push(cc_args, ~\"-L\" + path.to_str()); }\n+    for addl_paths.each |path| { cc_args.push(~\"-L\" + path.to_str()); }\n \n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n-    for used_libs.each |l| { vec::push(cc_args, ~\"-l\" + *l); }\n+    for used_libs.each |l| { cc_args.push(~\"-l\" + *l); }\n \n     if sess.building_library {\n-        vec::push(cc_args, lib_cmd);\n+        cc_args.push(lib_cmd);\n \n         // On mac we need to tell the linker to let this library\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n-            vec::push(cc_args, ~\"-Wl,-install_name,@rpath/\"\n+            cc_args.push(~\"-Wl,-install_name,@rpath/\"\n                       + output.filename().get());\n         }\n     }\n \n     if !sess.debugging_opt(session::no_rt) {\n         // Always want the runtime linked in\n-        vec::push(cc_args, ~\"-lrustrt\");\n+        cc_args.push(~\"-lrustrt\");\n     }\n \n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        vec::push_all(cc_args, ~[~\"-lrt\", ~\"-ldl\"]);\n+        cc_args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n-        vec::push(cc_args, ~\"-lm\");\n+        cc_args.push(~\"-lm\");\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n-        vec::push_all(cc_args, ~[~\"-pthread\", ~\"-lrt\",\n+        cc_args.push_all(~[~\"-pthread\", ~\"-lrt\",\n                                 ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n                                 ~\"-L/usr/local/lib/gcc46\",\n                                 ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n@@ -743,15 +743,15 @@ fn link_binary(sess: session,\n     // understand how to unwind our __morestack frame, so we have to turn it\n     // off. This has impacted some other projects like GHC.\n     if sess.targ_cfg.os == session::os_macos {\n-        vec::push(cc_args, ~\"-Wl,-no_compact_unwind\");\n+        cc_args.push(~\"-Wl,-no_compact_unwind\");\n     }\n \n     // Stack growth requires statically linking a __morestack function\n-    vec::push(cc_args, ~\"-lmorestack\");\n+    cc_args.push(~\"-lmorestack\");\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to where\n     // extern libraries might live, based on the addl_lib_search_paths\n-    vec::push_all(cc_args, rpath::get_rpath_flags(sess, &output));\n+    cc_args.push_all(rpath::get_rpath_flags(sess, &output));\n \n     debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n     // We run 'cc' here"}, {"sha": "8aa7caefc7a5e624fbe3bdc4d2686045b001ed8c", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -81,8 +81,8 @@ fn get_rpaths(os: session::os,\n     log_rpaths(~\"fallback\", fallback_rpaths);\n \n     let mut rpaths = rel_rpaths;\n-    vec::push_all(rpaths, abs_rpaths);\n-    vec::push_all(rpaths, fallback_rpaths);\n+    rpaths.push_all(abs_rpaths);\n+    rpaths.push_all(fallback_rpaths);\n \n     // Remove duplicates\n     let rpaths = minimize_rpaths(rpaths);\n@@ -136,9 +136,9 @@ fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     }\n \n     let mut path = ~[];\n-    for uint::range(start_idx, len1 - 1) |_i| { vec::push(path, ~\"..\"); };\n+    for uint::range(start_idx, len1 - 1) |_i| { path.push(~\"..\"); };\n \n-    vec::push_all(path, vec::view(split2, start_idx, len2 - 1));\n+    path.push_all(vec::view(split2, start_idx, len2 - 1));\n \n     if vec::is_not_empty(path) {\n         return Path(\"\").push_many(path);\n@@ -172,7 +172,7 @@ fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     for rpaths.each |rpath| {\n         let s = rpath.to_str();\n         if !set.contains_key(s) {\n-            vec::push(minimized, *rpath);\n+            minimized.push(*rpath);\n             set.insert(s, ());\n         }\n     }"}, {"sha": "a2c864f6f465fc6d4f79575a9036531852b6d284", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -28,7 +28,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n             tys: ~[TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let mut arg_tys: ~[TypeRef] = ~[];\n-        for tys.each |t| { vec::push(arg_tys, *t); }\n+        for tys.each |t| { arg_tys.push(*t); }\n         let fn_ty = T_fn(arg_tys, rv);\n         return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n     }"}, {"sha": "3acacd3c0a5a119586edc690598308d4ee8a3034", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -94,7 +94,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // meta_word variant.\n     let mut words = ~[];\n     for cfgspecs.each |s| {\n-        vec::push(words, attr::mk_word_item(*s));\n+        words.push(attr::mk_word_item(*s));\n     }\n     return words;\n }\n@@ -466,7 +466,7 @@ fn build_session_options(binary: ~str,\n                                            level_name, lint_name));\n               }\n               Some(lint) => {\n-                vec::push(lint_opts, (lint.lint, *level));\n+                lint_opts.push((lint.lint, *level));\n               }\n             }\n         }"}, {"sha": "55d71ab6950441a4c458f1e702db3cd6738275e8", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -99,7 +99,7 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    Option<@ast::item> {\n \n-    vec::push(cx.path, i.ident);\n+    cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n            ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner));\n \n@@ -286,7 +286,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        vec::push(descs, mk_test_desc_rec(cx, *test));\n+        descs.push(mk_test_desc_rec(cx, *test));\n     }\n \n     let inner_expr = @{id: cx.sess.next_node_id(),"}, {"sha": "edf6a9612c794c478fd05559e79641a341f14f65", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -115,7 +115,7 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n \n fn add_used_crate_file(cstore: cstore, lib: &Path) {\n     if !vec::contains(p(cstore).used_crate_files, copy *lib) {\n-        vec::push(p(cstore).used_crate_files, copy *lib);\n+        p(cstore).used_crate_files.push(copy *lib);\n     }\n }\n \n@@ -127,7 +127,7 @@ fn add_used_library(cstore: cstore, lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n     if vec::contains(p(cstore).used_libraries, lib) { return false; }\n-    vec::push(p(cstore).used_libraries, lib);\n+    p(cstore).used_libraries.push(lib);\n     return true;\n }\n \n@@ -136,7 +136,7 @@ fn get_used_libraries(cstore: cstore) -> ~[~str] {\n }\n \n fn add_used_link_args(cstore: cstore, args: ~str) {\n-    vec::push_all(p(cstore).used_link_args, str::split_char(args, ' '));\n+    p(cstore).used_link_args.push_all(str::split_char(args, ' '));\n }\n \n fn get_used_link_args(cstore: cstore) -> ~[~str] {\n@@ -163,7 +163,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n-        vec::push(result, {name: cdata.name, hash: hash});\n+        result.push({name: cdata.name, hash: hash});\n     };\n     pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n     let sorted = std::sort::merge_sort(lteq, result);"}, {"sha": "a6bb681bc16b9579449f682efe244ecfbca0531b", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -227,7 +227,7 @@ fn item_type(item_id: ast::def_id, item: ebml::Doc,\n fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n     for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n-        vec::push(results, doc_type(ity, tcx, cdata));\n+        results.push(doc_type(ity, tcx, cdata));\n     };\n     results\n }\n@@ -239,7 +239,7 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n-        vec::push(bounds, bd);\n+        bounds.push(bd);\n     }\n     @bounds\n }\n@@ -263,7 +263,7 @@ fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let v = tag_items_data_item_variant;\n     for ebml::tagged_docs(item, v) |p| {\n         let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n-        vec::push(ids, {crate: cdata.cnum, node: ext.node});\n+        ids.push({crate: cdata.cnum, node: ext.node});\n     };\n     return ids;\n }\n@@ -278,10 +278,10 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     for ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n-            vec::push(result, ast_map::path_mod(intr.intern(@str)));\n+            result.push(ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n             let str = ebml::doc_as_str(elt_doc);\n-            vec::push(result, ast_map::path_name(intr.intern(@str)));\n+            result.push(ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -584,15 +584,15 @@ fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let mut arg_tys: ~[ty::t] = ~[];\n         match ty::get(ctor_ty).sty {\n           ty::ty_fn(f) => {\n-            for f.sig.inputs.each |a| { vec::push(arg_tys, a.ty); }\n+            for f.sig.inputs.each |a| { arg_tys.push(a.ty); }\n           }\n           _ => { /* Nullary enum variant. */ }\n         }\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n           _         => { /* empty */ }\n         }\n-        vec::push(infos, @{args: arg_tys, ctor_ty: ctor_ty, name: name,\n+        infos.push(@{args: arg_tys, ctor_ty: ctor_ty, name: name,\n                            id: *did, disr_val: disr_val});\n         disr_val += 1;\n     }\n@@ -645,7 +645,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n         let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n-        vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n+        rslt.push(@{did: translate_def_id(cdata, m_did),\n                     /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n                    ident: item_name(intr, mth_item),\n@@ -675,7 +675,7 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n         let nm = item_name(intr, item);\n         if match name { Some(n) => { n == nm } None => { true } } {\n            let base_tps = item_ty_param_count(item);\n-           vec::push(result, @{\n+           result.push(@{\n                 did: local_did, ident: nm,\n                 methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n             });\n@@ -701,7 +701,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                 ~\"get_trait_methods: id has non-function type\");\n         } };\n         let self_ty = get_self_ty(mth);\n-        vec::push(result, {ident: name, tps: bounds, fty: fty,\n+        result.push({ident: name, tps: bounds, fty: fty,\n                            self_ty: self_ty,\n                            vis: ast::public});\n     }\n@@ -753,7 +753,7 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n           let name = item_name(intr, an_item);\n           let did = item_def_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n-          vec::push(result, {ident: name, id: did, vis:\n+          result.push({ident: name, id: did, vis:\n                   family_to_visibility(f), mutability: mt});\n        }\n     }\n@@ -835,7 +835,7 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n-        vec::push(items, attr::mk_word_item(n));\n+        items.push(attr::mk_word_item(n));\n     };\n     for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -844,13 +844,13 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n         let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        vec::push(items, attr::mk_name_value_item_str(n, v));\n+        items.push(attr::mk_name_value_item_str(n, v));\n     };\n     for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        vec::push(items, attr::mk_list_item(n, subitems));\n+        items.push(attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n@@ -865,10 +865,10 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             // an attribute\n             assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items[0];\n-            vec::push(attrs,\n-                      {node: {style: ast::attr_outer, value: *meta_item,\n-                              is_sugared_doc: false},\n-                       span: ast_util::dummy_sp()});\n+            attrs.push(\n+                {node: {style: ast::attr_outer, value: *meta_item,\n+                        is_sugared_doc: false},\n+                 span: ast_util::dummy_sp()});\n         };\n       }\n       option::None => ()\n@@ -910,7 +910,7 @@ fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n     for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n-        vec::push(deps, {cnum: crate_num,\n+        deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n                   hash: docstr(depdoc, tag_crate_dep_hash)});\n@@ -977,7 +977,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd)\n         // Collect everything by now. There might be multiple\n         // paths pointing to the same did. Those will be\n         // unified later by using the mods map\n-        vec::push(res, (did, path));\n+        res.push((did, path));\n     }\n     return do vec::filter(res) |x| {\n         let (_, xp) = x;"}, {"sha": "81ad9dfc3a5fccc19551829e762f8716066fe177", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -118,12 +118,12 @@ type entry<T> = {val: T, pos: uint};\n fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: &[ident],\n                 &index: ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n-    vec::push_all(full_path, path);\n-    vec::push(full_path, name);\n-    vec::push(index,\n-              {val: ast_util::path_name_i(full_path,\n-                                          ecx.tcx.sess.parse_sess.interner),\n-               pos: ebml_w.writer.tell()});\n+    full_path.push_all(path);\n+    full_path.push(name);\n+    index.push(\n+        {val: ast_util::path_name_i(full_path,\n+                                    ecx.tcx.sess.parse_sess.interner),\n+         pos: ebml_w.writer.tell()});\n }\n \n fn encode_trait_ref(ebml_w: ebml::Writer, ecx: @encode_ctxt, t: @trait_ref) {\n@@ -225,7 +225,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx, {crate: local_crate, node: id});\n     for variants.each |variant| {\n-        vec::push(*index, {val: variant.node.id, pos: ebml_w.writer.tell()});\n+        index.push({val: variant.node.id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n@@ -390,9 +390,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n         match field.node.kind {\n             named_field(nm, mt, vis) => {\n                 let id = field.node.id;\n-                vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n-                vec::push(*global_index, {val: id,\n-                                          pos: ebml_w.writer.tell()});\n+                index.push({val: id, pos: ebml_w.writer.tell()});\n+                global_index.push({val: id,\n+                                    pos: ebml_w.writer.tell()});\n                 ebml_w.start_tag(tag_items_data_item);\n                 debug!(\"encode_info_for_class: doing %s %d\",\n                        tcx.sess.str_of(nm), id);\n@@ -411,9 +411,9 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     for methods.each |m| {\n         match m.vis {\n             public | inherited => {\n-                vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n-                vec::push(*global_index,\n-                          {val: m.id, pos: ebml_w.writer.tell()});\n+                index.push({val: m.id, pos: ebml_w.writer.tell()});\n+                global_index.push(\n+                    {val: m.id, pos: ebml_w.writer.tell()});\n                 let impl_path = vec::append_one(path,\n                                                 ast_map::path_name(m.ident));\n                 debug!(\"encode_info_for_class: doing %s %d\",\n@@ -519,7 +519,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n \n     fn add_to_index_(item: @item, ebml_w: ebml::Writer,\n                      index: @mut ~[entry<int>]) {\n-        vec::push(*index, {val: item.id, pos: ebml_w.writer.tell()});\n+        index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n     let add_to_index = |copy ebml_w| add_to_index_(item, ebml_w, index);\n \n@@ -603,7 +603,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n                                         index);\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n-            vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n+            index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n                                    ecx.tcx.sess.str_of(item.ident) +\n@@ -688,7 +688,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         for struct_def.ctor.each |ctor| {\n             debug!(\"encoding info for ctor %s %d\",\n                    ecx.tcx.sess.str_of(item.ident), ctor.node.id);\n-            vec::push(*index, {\n+            index.push({\n                 val: ctor.node.id,\n                 pos: ebml_w.writer.tell()\n             });\n@@ -723,7 +723,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         let impl_path = vec::append_one(path,\n                                         ast_map::path_name(item.ident));\n         for methods.each |m| {\n-            vec::push(*index, {val: m.id, pos: ebml_w.writer.tell()});\n+            index.push({val: m.id, pos: ebml_w.writer.tell()});\n             encode_info_for_method(ecx, ebml_w, impl_path,\n                                    should_inline(m.attrs), item.id, *m,\n                                    vec::append(tps, m.tps));\n@@ -774,7 +774,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n             let ty_m = ast_util::trait_method_to_ty_method(*m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n-            vec::push(*index, {val: ty_m.id, pos: ebml_w.writer.tell()});\n+            index.push({val: ty_m.id, pos: ebml_w.writer.tell()});\n \n             ebml_w.start_tag(tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ty_m.id));\n@@ -799,7 +799,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n     if !reachable(ecx, nitem.id) { return; }\n-    vec::push(*index, {val: nitem.id, pos: ebml_w.writer.tell()});\n+    index.push({val: nitem.id, pos: ebml_w.writer.tell()});\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n@@ -831,7 +831,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n-    vec::push(*index, {val: crate_node_id, pos: ebml_w.writer.tell()});\n+    index.push({val: crate_node_id, pos: ebml_w.writer.tell()});\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n@@ -869,15 +869,15 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n    ~[@~[entry<T>]] {\n     let mut buckets: ~[@mut ~[entry<T>]] = ~[];\n-    for uint::range(0u, 256u) |_i| { vec::push(buckets, @mut ~[]); };\n+    for uint::range(0u, 256u) |_i| { buckets.push(@mut ~[]); };\n     for index.each |elt| {\n         let h = elt.val.hash() as uint;\n-        vec::push(*buckets[h % 256], *elt);\n+        buckets[h % 256].push(*elt);\n     }\n \n     let mut buckets_frozen = ~[];\n     for buckets.each |bucket| {\n-        vec::push(buckets_frozen, @**bucket);\n+        buckets_frozen.push(@**bucket);\n     }\n     return buckets_frozen;\n }\n@@ -889,7 +889,7 @@ fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n     let mut bucket_locs: ~[uint] = ~[];\n     ebml_w.start_tag(tag_index_buckets);\n     for buckets.each |bucket| {\n-        vec::push(bucket_locs, ebml_w.writer.tell());\n+        bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(**bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n@@ -996,8 +996,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     let mut attrs: ~[attribute] = ~[];\n     let mut found_link_attr = false;\n     for crate.node.attrs.each |attr| {\n-        vec::push(\n-            attrs,\n+        attrs.push(\n             if attr::get_attr_name(*attr) != ~\"link\" {\n                 *attr\n             } else {\n@@ -1011,7 +1010,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n             });\n     }\n \n-    if !found_link_attr { vec::push(attrs, synthesize_link_attr(ecx, ~[])); }\n+    if !found_link_attr { attrs.push(synthesize_link_attr(ecx, ~[])); }\n \n     return attrs;\n }\n@@ -1031,7 +1030,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n             let dep = {cnum: key, name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n-            vec::push(deps, dep);\n+            deps.push(dep);\n         };\n \n         // Sort by cnum"}, {"sha": "63370b09321040bdecd6ce86209cf04da0a715d7", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -39,15 +39,15 @@ fn mk_filesearch(maybe_sysroot: Option<Path>,\n         fn lib_search_paths() -> ~[Path] {\n             let mut paths = self.addl_lib_search_paths;\n \n-            vec::push(paths,\n-                      make_target_lib_path(&self.sysroot,\n-                                           self.target_triple));\n+            paths.push(\n+                make_target_lib_path(&self.sysroot,\n+                                     self.target_triple));\n             match get_cargo_lib_path_nearest() {\n-              result::Ok(p) => vec::push(paths, p),\n+              result::Ok(p) => paths.push(p),\n               result::Err(_) => ()\n             }\n             match get_cargo_lib_path() {\n-              result::Ok(p) => vec::push(paths, p),\n+              result::Ok(p) => paths.push(p),\n               result::Err(_) => ()\n             }\n             paths"}, {"sha": "2ccaccf17a59ea900dcf1280f6354c80b006c619", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -90,7 +90,7 @@ fn find_library_crate_aux(cx: ctxt,\n                     option::None::<()>\n                 } else {\n                     debug!(\"found %s with matching metadata\", path.to_str());\n-                    vec::push(matches, {ident: path.to_str(), data: cvec});\n+                    matches.push({ident: path.to_str(), data: cvec});\n                     option::None::<()>\n                 }\n               }"}, {"sha": "f3fa0e3f3507ff02818edfbba9fa7e60d2b2181d", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -84,7 +84,7 @@ fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n fn parse_path(st: @pstate) -> @ast::path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n-    vec::push(idents, parse_ident_(st, is_last));\n+    idents.push(parse_ident_(st, is_last));\n     loop {\n         match peek(st) {\n           ':' => { next(st); next(st); }\n@@ -93,7 +93,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n                 return @{span: ast_util::dummy_sp(),\n                       global: false, idents: idents,\n                       rp: None, types: ~[]};\n-            } else { vec::push(idents, parse_ident_(st, is_last)); }\n+            } else { idents.push(parse_ident_(st, is_last)); }\n           }\n         }\n     };\n@@ -136,7 +136,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n \n     assert next(st) == '[';\n     let mut params: ~[ty::t] = ~[];\n-    while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n+    while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n     return {self_r: self_r,\n@@ -273,15 +273,15 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let mut fields: ~[ty::field] = ~[];\n         while peek(st) != ']' {\n             let name = st.tcx.sess.ident_of(parse_str(st, '='));\n-            vec::push(fields, {ident: name, mt: parse_mt(st, conv)});\n+            fields.push({ident: name, mt: parse_mt(st, conv)});\n         }\n         st.pos = st.pos + 1u;\n         return ty::mk_rec(st.tcx, fields);\n       }\n       'T' => {\n         assert (next(st) == '[');\n         let mut params = ~[];\n-        while peek(st) != ']' { vec::push(params, parse_ty(st, conv)); }\n+        while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n         return ty::mk_tup(st.tcx, params);\n       }\n@@ -348,7 +348,7 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n     let mut def = ~[];\n-    while peek(st) != '|' { vec::push(def, next_byte(st)); }\n+    while peek(st) != '|' { def.push(next_byte(st)); }\n     st.pos = st.pos + 1u;\n     return conv(parse_def_id(def));\n }\n@@ -412,7 +412,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = parse_mode(st);\n-        vec::push(inputs, {mode: mode, ty: parse_ty(st, conv)});\n+        inputs.push({mode: mode, ty: parse_ty(st, conv)});\n     }\n     st.pos += 1u; // eat the ']'\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n@@ -464,7 +464,7 @@ fn parse_bounds_data(data: @~[u8], start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n-        vec::push(bounds, match next(st) {\n+        bounds.push(match next(st) {\n           'S' => ty::bound_send,\n           'C' => ty::bound_copy,\n           'K' => ty::bound_const,"}, {"sha": "618d43e121a307f6241dd8d6d3c2cae759a8baa5", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -122,6 +122,6 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     }\n \n     let mut result = ~[];\n-    for cap_map.each_value |cap_var| { vec::push(result, cap_var); }\n+    for cap_map.each_value |cap_var| { result.push(cap_var); }\n     return result;\n }"}, {"sha": "54f415857ba3bce572f95a26d516c7465ae65ea5", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -67,7 +67,7 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n               }\n               _ => ()\n             }\n-            if arm.guard.is_none() { vec::push(seen, v); }\n+            if arm.guard.is_none() { seen.push(v); }\n         }\n     }\n }\n@@ -269,7 +269,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n         let mut found = ~[];\n         for m.each |r| {\n             do option::iter(&pat_ctor_id(tcx, r[0])) |id| {\n-                if !vec::contains(found, id) { vec::push(found, id); }\n+                if !vec::contains(found, id) { found.push(id); }\n             }\n         }\n         let variants = ty::enum_variants(tcx, eid);"}, {"sha": "7e925d7d8d84213e6a124cdd2b2f495272f05c6a", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -63,7 +63,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n                         if !seen.contains_key(dnum) {\n-                            vec::push(*refs, @{def:def, span:expr.span});\n+                            refs.push(@{def:def, span:expr.span});\n                             seen.insert(dnum, ());\n                         }\n                       }"}, {"sha": "7d911f7d05a17fc1b89bb737e4aa39efff33beac", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -42,17 +42,17 @@ fn kind_to_str(k: kind) -> ~str {\n     let mut kinds = ~[];\n \n     if ty::kind_lteq(kind_const(), k) {\n-        vec::push(kinds, ~\"const\");\n+        kinds.push(~\"const\");\n     }\n \n     if ty::kind_can_be_copied(k) {\n-        vec::push(kinds, ~\"copy\");\n+        kinds.push(~\"copy\");\n     }\n \n     if ty::kind_can_be_sent(k) {\n-        vec::push(kinds, ~\"send\");\n+        kinds.push(~\"send\");\n     } else if ty::kind_is_owned(k) {\n-        vec::push(kinds, ~\"owned\");\n+        kinds.push(~\"owned\");\n     }\n \n     str::connect(kinds, ~\" \")"}, {"sha": "b92f8e8441f1c7cae576aac361ab9700447fe028", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -288,7 +288,7 @@ impl ctxt {\n                     for metas.each |meta| {\n                         match meta.node {\n                           ast::meta_word(lintname) => {\n-                            vec::push(triples, (*meta, *level, lintname));\n+                            triples.push((*meta, *level, lintname));\n                           }\n                           _ => {\n                             self.sess.span_err("}, {"sha": "b39b7914905d12f241506dc0472a80d186c772cf", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -302,7 +302,7 @@ fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n impl IrMaps {\n     fn add_live_node(lnk: LiveNodeKind) -> LiveNode {\n         let ln = LiveNode(self.num_live_nodes);\n-        vec::push(self.lnks, lnk);\n+        self.lnks.push(lnk);\n         self.num_live_nodes += 1u;\n \n         debug!(\"%s is of kind %?\", ln.to_str(), lnk);\n@@ -319,7 +319,7 @@ impl IrMaps {\n \n     fn add_variable(vk: VarKind) -> Variable {\n         let v = Variable(self.num_vars);\n-        vec::push(self.var_kinds, vk);\n+        self.var_kinds.push(vk);\n         self.num_vars += 1u;\n \n         match vk {\n@@ -540,7 +540,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n                   cap_move | cap_drop => true, // var must be dead afterwards\n                   cap_copy | cap_ref => false // var can still be used\n                 };\n-                vec::push(call_caps, {ln: cv_ln, is_move: is_move, rv: rv});\n+                call_caps.push({ln: cv_ln, is_move: is_move, rv: rv});\n               }\n               None => {}\n             }"}, {"sha": "006065988b92ceecd2bcefb2ab694459fdf17980", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -54,6 +54,6 @@ fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n \n fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n     let mut found = ~[];\n-    pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| vec::push(found, b_id) );\n+    pat_bindings(dm, pat, |_bm, b_id, _sp, _pt| found.push(b_id) );\n     return found;\n }"}, {"sha": "ff708b7f4efa12b0e433317ed870088c32555b0a", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -141,7 +141,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n             match region_map.find(scope) {\n                 None => return result,\n                 Some(superscope) => {\n-                    vec::push(result, superscope);\n+                    result.push(superscope);\n                     scope = superscope;\n                 }\n             }"}, {"sha": "99d98c52f959d6d9fe2f6d4b6a394e55cb221927", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -2897,7 +2897,7 @@ impl Resolver {\n                            if reexport { ~\"reexport\" } else { ~\"export\"},\n                            self.session.str_of(ident),\n                            def_id_of_def(d.def));\n-                    vec::push(*exports2,  Export2 {\n+                    exports2.push(Export2 {\n                         reexport: reexport,\n                         name: self.session.str_of(ident),\n                         def_id: def_id_of_def(d.def)\n@@ -2949,7 +2949,7 @@ impl Resolver {\n                                 for %?\",\n                                self.session.str_of(name),\n                                module_.def_id);\n-                        vec::push(*exports2, Export2 {\n+                        exports2.push(Export2 {\n                             reexport: false,\n                             name: self.session.str_of(name),\n                             def_id: def_id_of_def(target_def)\n@@ -2960,7 +2960,7 @@ impl Resolver {\n                                 %?\",\n                                self.session.str_of(name),\n                                module_.def_id);\n-                        vec::push(*exports2, Export2 {\n+                        exports2.push(Export2 {\n                             reexport: true,\n                             name: self.session.str_of(name),\n                             def_id: def_id_of_def(target_def)"}, {"sha": "165ca8e2fc43a7e271def1c5f921e735cbb448f4", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -305,7 +305,7 @@ fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n                     _ => {}\n                 }\n \n-                vec::push(result, @Match {pats: pats, data: br.data});\n+                result.push(@Match {pats: pats, data: br.data});\n             }\n             None => ()\n         }\n@@ -398,8 +398,8 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n                 let mut pats = ~[];\n                 for vec::each(fields) |fname| {\n                     match fpats.find(|p| p.ident == *fname) {\n-                        None => vec::push(pats, dummy),\n-                        Some(pat) => vec::push(pats, pat.pat)\n+                        None => pats.push(dummy),\n+                        Some(pat) => pats.push(pat.pat)\n                     }\n                 }\n                 Some(pats)\n@@ -582,7 +582,7 @@ fn collect_record_or_struct_fields(m: &[@Match], col: uint) -> ~[ast::ident] {\n         for field_pats.each |field_pat| {\n             let field_ident = field_pat.ident;\n             if !vec::any(*idents, |x| x == field_ident) {\n-                vec::push(*idents, field_ident);\n+                idents.push(field_ident);\n             }\n         }\n     }\n@@ -1162,9 +1162,9 @@ fn trans_alt_inner(scope_cx: block,\n         let arm_data = @ArmData {bodycx: body,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n-        vec::push(arm_datas, arm_data);\n+        arm_datas.push(arm_data);\n         for vec::each(arm.pats) |p| {\n-            vec::push(matches, @Match {pats: ~[*p], data: arm_data});\n+            matches.push(@Match {pats: ~[*p], data: arm_data});\n         }\n     }\n "}, {"sha": "94b09a30e4be8daff9575e08b55e5e55b5f02d38", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -76,7 +76,7 @@ impl @crate_ctxt: get_insn_ctxt {\n     fn insn_ctxt(s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n-            vec::push(*self.stats.llvm_insn_ctxt, str::from_slice(s));\n+            self.stats.llvm_insn_ctxt.push(str::from_slice(s));\n         }\n         icx_popper(self)\n     }\n@@ -98,7 +98,7 @@ fn log_fn_time(ccx: @crate_ctxt, name: ~str, start: time::Timespec,\n                end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n         ((end.nsec as int) - (start.nsec as int)) / 1000000;\n-    vec::push(*ccx.stats.fn_times, {ident: name, time: elapsed});\n+    ccx.stats.fn_times.push({ident: name, time: elapsed});\n }\n \n fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n@@ -1153,7 +1153,7 @@ fn cleanup_and_leave(bcx: block, upto: Option<BasicBlockRef>,\n             }\n             let sub_cx = sub_block(bcx, ~\"cleanup\");\n             Br(bcx, sub_cx.llbb);\n-            vec::push(inf.cleanup_paths, {target: leave, dest: sub_cx.llbb});\n+            inf.cleanup_paths.push({target: leave, dest: sub_cx.llbb});\n             bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n           }\n           _ => ()\n@@ -2001,7 +2001,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n         let mut args = ~[lloutputarg, llenvarg];\n         if takes_argv {\n-            vec::push(args, llvm::LLVMGetParam(llfdecl, 2 as c_uint));\n+            args.push(llvm::LLVMGetParam(llfdecl, 2 as c_uint));\n         }\n         Call(bcx, main_llfn, args);\n \n@@ -2451,10 +2451,10 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     for ccx.module_data.each |key, val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]);\n-        vec::push(elts, elt);\n+        elts.push(elt);\n     }\n     let term = C_struct(~[C_int(ccx, 0), C_int(ccx, 0)]);\n-    vec::push(elts, term);\n+    elts.push(term);\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     return map;\n }\n@@ -2492,10 +2492,10 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n         let cr = str::as_c_str(nm, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n-        vec::push(subcrates, p2i(ccx, cr));\n+        subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n-    vec::push(subcrates, C_int(ccx, 0));\n+    subcrates.push(C_int(ccx, 0));\n \n     let llannihilatefn;\n     let annihilate_def_id = ccx.tcx.lang_items.annihilate_fn.get();"}, {"sha": "070132b4b18407e8b3466415bf0eaf5d512c7856", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -435,7 +435,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n // XXX: Use a small-vector optimization to avoid allocations here.\n fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n-    for vec::each(ixs) |i| { vec::push(v, C_i32(*i as i32)); }\n+    for vec::each(ixs) |i| { v.push(C_i32(*i as i32)); }\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }"}, {"sha": "470d4dbb4ab8f08e0b335ec6d2edc701b3eb0741", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -478,10 +478,10 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n             }\n         }\n     };\n-    vec::push(llargs, llretslot);\n+    llargs.push(llretslot);\n \n     // Arg 1: Env (closure-bindings / self value)\n-    vec::push(llargs, llenv);\n+    llargs.push(llenv);\n \n     // ... then explicit args.\n \n@@ -497,11 +497,11 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n                                if i == last { ret_flag } else { None },\n                                autoref_arg)\n             });\n-            vec::push(llargs, arg_val);\n+            llargs.push(arg_val);\n         }\n       }\n       ArgVals(vs) => {\n-        vec::push_all(llargs, vs);\n+        llargs.push_all(vs);\n       }\n     }\n \n@@ -622,7 +622,7 @@ fn trans_arg_expr(bcx: block,\n                         // However, we must cleanup should we fail before the\n                         // callee is actually invoked.\n                         scratch.add_clean(bcx);\n-                        vec::push(*temp_cleanups, scratch.val);\n+                        temp_cleanups.push(scratch.val);\n \n                         match arg_datum.appropriate_mode() {\n                             ByValue => {"}, {"sha": "7b071866136ed5d8edfb0619efb05ef5c762edb6", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -259,16 +259,16 @@ fn build_closure(bcx0: block,\n         match cap_var.mode {\n             capture::cap_ref => {\n                 assert ck == ty::ck_block;\n-                vec::push(env_vals, EnvValue {action: EnvRef,\n-                                              datum: datum});\n+                env_vals.push(EnvValue {action: EnvRef,\n+                                        datum: datum});\n             }\n             capture::cap_copy => {\n-                vec::push(env_vals, EnvValue {action: EnvStore,\n-                                              datum: datum});\n+                env_vals.push(EnvValue {action: EnvStore,\n+                                        datum: datum});\n             }\n             capture::cap_move => {\n-                vec::push(env_vals, EnvValue {action: EnvMove,\n-                                              datum: datum});\n+                env_vals.push(EnvValue {action: EnvMove,\n+                                        datum: datum});\n             }\n             capture::cap_drop => {\n                 bcx = datum.drop_val(bcx);\n@@ -283,8 +283,8 @@ fn build_closure(bcx0: block,\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: flagptr, ty: ty::mk_bool(tcx),\n                                 mode: ByRef, source: FromLvalue};\n-        vec::push(env_vals, EnvValue {action: EnvRef,\n-                                      datum: flag_datum});\n+        env_vals.push(EnvValue {action: EnvRef,\n+                                datum: flag_datum});\n \n         // Return value (we just pass a by-ref () and cast it later to\n         // the right thing):\n@@ -295,8 +295,8 @@ fn build_closure(bcx0: block,\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n                                mode: ByRef, source: FromLvalue};\n-        vec::push(env_vals, EnvValue {action: EnvRef,\n-                                      datum: ret_datum});\n+        env_vals.push(EnvValue {action: EnvRef,\n+                                datum: ret_datum});\n     }\n \n     return store_environment(bcx, env_vals, ck);"}, {"sha": "0df63e40acf2ea9a389a7da9bf1ff1e66f8b43b2", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -348,9 +348,9 @@ fn add_clean(bcx: block, val: ValueRef, t: ty::t) {\n     let {root, rooted} = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |info| {\n-        vec::push(info.cleanups,\n-                  clean(|a| glue::drop_ty_root(a, root, rooted, t),\n-                        cleanup_type));\n+        info.cleanups.push(\n+            clean(|a| glue::drop_ty_root(a, root, rooted, t),\n+                  cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n@@ -362,9 +362,9 @@ fn add_clean_temp_immediate(cx: block, val: ValueRef, ty: ty::t) {\n            ty_to_str(cx.ccx().tcx, ty));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n-        vec::push(info.cleanups,\n-                  clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n-                             cleanup_type));\n+        info.cleanups.push(\n+            clean_temp(val, |a| glue::drop_ty_immediate(a, val, ty),\n+                       cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n@@ -376,9 +376,9 @@ fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     let {root, rooted} = root_for_cleanup(bcx, val, t);\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     do in_scope_cx(bcx) |info| {\n-        vec::push(info.cleanups,\n-                  clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n-                             cleanup_type));\n+        info.cleanups.push(\n+            clean_temp(val, |a| glue::drop_ty_root(a, root, rooted, t),\n+                       cleanup_type));\n         scope_clean_changed(info);\n     }\n }\n@@ -388,8 +388,8 @@ fn add_clean_free(cx: block, ptr: ValueRef, heap: heap) {\n       heap_exchange => |a| glue::trans_unique_free(a, ptr)\n     };\n     do in_scope_cx(cx) |info| {\n-        vec::push(info.cleanups, clean_temp(ptr, free_fn,\n-                                     normal_exit_and_unwind));\n+        info.cleanups.push(clean_temp(ptr, free_fn,\n+                                      normal_exit_and_unwind));\n         scope_clean_changed(info);\n     }\n }\n@@ -1050,7 +1050,7 @@ fn C_postr(s: ~str) -> ValueRef {\n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n     let mut i = 0u;\n     let mut elts: ~[ValueRef] = ~[];\n-    while i < size { vec::push(elts, C_u8(0u)); i += 1u; }\n+    while i < size { elts.push(C_u8(0u)); i += 1u; }\n     return llvm::LLVMConstArray(T_i8(), vec::raw::to_ptr(elts),\n                              elts.len() as c_uint);\n }"}, {"sha": "6cd4b49fa3b36fa006b148e4a7686ec1c37eed7c", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -383,7 +383,7 @@ fn create_derived_type(type_tag: int, file: ValueRef, name: ~str, line: int,\n \n fn add_member(cx: @struct_ctxt, name: ~str, line: int, size: int, align: int,\n               ty: ValueRef) {\n-    vec::push(cx.members, create_derived_type(MemberTag, cx.file, name, line,\n+    cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n                                        size * 8, align * 8, cx.total_size,\n                                        ty));\n     cx.total_size += size * 8;\n@@ -529,7 +529,7 @@ fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n           ty::ty_rec(fields) {\n             let fs = ~[];\n             for field in fields {\n-                vec::push(fs, {node: {ident: field.ident,\n+                fs.push({node: {ident: field.ident,\n                                mt: {ty: t_to_ty(cx, field.mt.ty, span),\n                                     mutbl: field.mt.mutbl}},\n                         span: span});"}, {"sha": "dafaebef9e01f3fd37f6adc5e681fbb3eb0a7b13", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -993,7 +993,7 @@ fn trans_rec_or_struct(bcx: block,\n             let dest = GEPi(bcx, addr, struct_field(ix));\n             bcx = trans_into(bcx, field.node.expr, SaveIn(dest));\n             add_clean_temp_mem(bcx, dest, field_tys[ix].mt.ty);\n-            vec::push(temp_cleanups, dest);\n+            temp_cleanups.push(dest);\n         }\n \n         // copy over any remaining fields from the base (for\n@@ -1046,7 +1046,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n         let e_ty = expr_ty(bcx, *e);\n         bcx = trans_into(bcx, *e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n-        vec::push(temp_cleanups, dest);\n+        temp_cleanups.push(dest);\n     }\n     for vec::each(temp_cleanups) |cleanup| {\n         revoke_clean(bcx, *cleanup);"}, {"sha": "f1077912fec6e471cdee2b5b55e0f8074ecf184c", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -297,21 +297,21 @@ fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n     while i < e {\n         match cls[i] {\n             integer_class => {\n-                vec::push(tys, T_i64());\n+                tys.push(T_i64());\n             }\n             sse_fv_class => {\n                 let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n                 let vec_ty = llvm::LLVMVectorType(T_f32(),\n                                                   vec_len as c_uint);\n-                vec::push(tys, vec_ty);\n+                tys.push(vec_ty);\n                 i += vec_len;\n                 loop;\n             }\n             sse_fs_class => {\n-                vec::push(tys, T_f32());\n+                tys.push(T_f32());\n             }\n             sse_ds_class => {\n-                vec::push(tys, T_f64());\n+                tys.push(T_f64());\n             }\n             _ => fail ~\"llregtype: unhandled class\"\n         }\n@@ -378,8 +378,8 @@ fn x86_64_tys(atys: ~[TypeRef],\n     let mut attrs = ~[];\n     for vec::each(atys) |t| {\n         let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n-        vec::push(arg_tys, ty);\n-        vec::push(attrs, attr);\n+        arg_tys.push(ty);\n+        attrs.push(attr);\n     }\n     let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n                                        StructRetAttribute);\n@@ -619,15 +619,15 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                         } else {\n                             load_inbounds(bcx, llargbundle, [0u, i])\n                         };\n-                        vec::push(llargvals, llargval);\n+                        llargvals.push(llargval);\n                         i += 1u;\n                     }\n                 }\n                 _ => {\n                     while i < n {\n                         let llargval = load_inbounds(bcx, llargbundle,\n                                                           [0u, i]);\n-                        vec::push(llargvals, llargval);\n+                        llargvals.push(llargval);\n                         i += 1u;\n                     }\n                 }\n@@ -1041,12 +1041,12 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n-            vec::push(llargvals, llretptr);\n+            llargvals.push(llretptr);\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n-            vec::push(llargvals, llenvptr);\n+            llargvals.push(llenvptr);\n             while i < n {\n                 let llargval = load_inbounds(bcx, llargbundle, ~[0u, i]);\n-                vec::push(llargvals, llargval);\n+                llargvals.push(llargval);\n                 i += 1u;\n             }\n             return llargvals;"}, {"sha": "40558e72c804c5da4e1d1bd082e07f84e3c4cc1c", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -246,7 +246,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n             for vec::each(*bounds) |bound| {\n                 match *bound {\n                   ty::bound_trait(_) => {\n-                    vec::push(v, meth::vtable_id(ccx, vts[i]));\n+                    v.push(meth::vtable_id(ccx, vts[i]));\n                     i += 1u;\n                   }\n                   _ => ()"}, {"sha": "e1eae11569453b5577ca3409dc98711c8db972dd", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -332,7 +332,7 @@ fn write_content(bcx: block,\n                         bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n-                        vec::push(temp_cleanups, lleltptr);\n+                        temp_cleanups.push(lleltptr);\n                     }\n                     for vec::each(temp_cleanups) |cleanup| {\n                         revoke_clean(bcx, *cleanup);\n@@ -369,7 +369,7 @@ fn write_content(bcx: block,\n                             bcx = tmpdatum.move_to(bcx, INIT, lleltptr);\n                         }\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n-                        vec::push(temp_cleanups, lleltptr);\n+                        temp_cleanups.push(lleltptr);\n                     }\n \n                     for vec::each(temp_cleanups) |cleanup| {"}, {"sha": "99555d5b29486bb452663bb1754a8a5c834252b6", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -39,13 +39,13 @@ fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n     let mut atys: ~[TypeRef] = ~[];\n \n     // Arg 0: Output pointer.\n-    vec::push(atys, T_ptr(type_of(cx, output)));\n+    atys.push(T_ptr(type_of(cx, output)));\n \n     // Arg 1: Environment\n-    vec::push(atys, T_opaque_box_ptr(cx));\n+    atys.push(T_opaque_box_ptr(cx));\n \n     // ... then explicit args.\n-    vec::push_all(atys, type_of_explicit_args(cx, inputs));\n+    atys.push_all(type_of_explicit_args(cx, inputs));\n     return T_fn(atys, llvm::LLVMVoidType());\n }\n \n@@ -151,7 +151,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         let mut tys: ~[TypeRef] = ~[];\n         for vec::each(fields) |f| {\n             let mt_ty = f.mt.ty;\n-            vec::push(tys, type_of(cx, mt_ty));\n+            tys.push(type_of(cx, mt_ty));\n         }\n \n         // n.b.: introduce an extra layer of indirection to match\n@@ -164,7 +164,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_tup(elts) => {\n         let mut tys = ~[];\n         for vec::each(elts) |elt| {\n-            vec::push(tys, type_of(cx, *elt));\n+            tys.push(type_of(cx, *elt));\n         }\n         T_struct(tys)\n       }"}, {"sha": "ed71d27451c009d7c6b5531405a145dd76608f2c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -2243,10 +2243,10 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           }\n \n           ty_class(did, ref substs) => {\n-            vec::push(*seen, did);\n-            let r = vec::any(class_items_as_fields(cx, did, substs),\n-                             |f| type_requires(cx, seen, r_ty, f.mt.ty));\n-            vec::pop(*seen);\n+              seen.push(did);\n+              let r = vec::any(class_items_as_fields(cx, did, substs),\n+                               |f| type_requires(cx, seen, r_ty, f.mt.ty));\n+              vec::pop(*seen);\n             r\n           }\n \n@@ -2258,18 +2258,18 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_enum(did, ref substs) => {\n-            vec::push(*seen, did);\n-            let vs = enum_variants(cx, did);\n-            let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n-                vec::any(variant.args, |aty| {\n-                    let sty = subst(cx, substs, aty);\n-                    type_requires(cx, seen, r_ty, sty)\n-                })\n-            });\n-            vec::pop(*seen);\n-            r\n-          }\n+            ty_enum(did, ref substs) => {\n+                seen.push(did);\n+                let vs = enum_variants(cx, did);\n+                let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n+                    vec::any(variant.args, |aty| {\n+                        let sty = subst(cx, substs, aty);\n+                        type_requires(cx, seen, r_ty, sty)\n+                    })\n+                });\n+                vec::pop(*seen);\n+                r\n+            }\n         };\n \n         debug!(\"subtypes_require(%s, %s)? %b\",\n@@ -3036,7 +3036,7 @@ fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     do walk_ty(ty) |ty| {\n         match get(ty).sty {\n           ty_param(p) => {\n-            vec::push(rslt, p);\n+            rslt.push(p);\n           }\n           _ => ()\n         }\n@@ -3052,7 +3052,7 @@ fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n         let mut rslt = ~[];\n         do walk_ty(ty) |ty| {\n             match get(ty).sty {\n-              ty_infer(TyVar(v)) => vec::push(rslt, v),\n+              ty_infer(TyVar(v)) => rslt.push(v),\n               _ => ()\n             }\n         }\n@@ -3704,10 +3704,10 @@ fn class_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n     for fields.each |field| {\n         match field.node.kind {\n             named_field(ident, mutability, visibility) => {\n-                vec::push(rslt, {ident: ident,\n-                                 id: ast_util::local_def(field.node.id),\n-                                 vis: visibility,\n-                                 mutability: mutability});\n+                rslt.push({ident: ident,\n+                           id: ast_util::local_def(field.node.id),\n+                           vis: visibility,\n+                           mutability: mutability});\n             }\n             unnamed_field => {}\n        }\n@@ -3747,7 +3747,7 @@ fn class_item_fields(cx:ctxt,\n     for lookup_class_fields(cx, did).each |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-       vec::push(rslt, {ident: f.ident, mt:\n+       rslt.push({ident: f.ident, mt:\n                {ty: lookup_field_type(cx, did, f.id, substs),\n                     mutbl: frob_mutability(f.mutability)}});\n     }"}, {"sha": "bc7711c059b6db26514a2ac66b46036cd72545cf", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -818,7 +818,7 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n                 if vec::contains(enum_dids, did) {\n                     return (t1, autoderefs);\n                 }\n-                vec::push(enum_dids, did);\n+                enum_dids.push(did);\n             }\n             _ => { /*ok*/ }\n         }\n@@ -2029,8 +2029,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         let name = class_field.ident;\n                         let (_, seen) = class_field_map.get(name);\n                         if !seen {\n-                            vec::push(missing_fields,\n-                                      ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n+                            missing_fields.push(\n+                                ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n                         }\n                     }\n \n@@ -2298,7 +2298,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                 ccx.tcx.sess.span_err(v.span,\n                                       ~\"discriminator value already exists\");\n             }\n-            vec::push(*disr_vals, *disr_val);\n+            disr_vals.push(*disr_val);\n             let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n             let arg_tys;\n \n@@ -2321,7 +2321,8 @@ fn check_enum_variants(ccx: @crate_ctxt,\n             match arg_tys {\n                 None => {}\n                 Some(arg_tys) => {\n-                    vec::push(*variants, @{args: arg_tys, ctor_ty: ctor_ty,\n+                    variants.push(\n+                        @{args: arg_tys, ctor_ty: ctor_ty,\n                           name: v.node.name, id: local_def(v.node.id),\n                           disr_val: this_disr_val});\n                 }"}, {"sha": "aec42f770486b39c95ef060a3633323e4f0d42f2", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -27,13 +27,13 @@ fn replace_bound_regions_in_fn_ty(\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n                              { ty: ty::mk_self(tcx), mutbl: m });\n-        vec::push(all_tys, ty);\n+        all_tys.push(ty);\n       }\n       _ => {}\n     }\n \n \n-    for self_ty.each |t| { vec::push(all_tys, *t) }\n+    for self_ty.each |t| { all_tys.push(*t) }\n \n     debug!(\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n                 all_tys=%?)\","}, {"sha": "453559e5e42492ad3d1a794470482149897857fb", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -51,8 +51,8 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                vec::push(result, lookup_vtable(fcx, expr, *ty, i_ty,\n-                                                allow_unsafe, is_early));\n+                result.push(lookup_vtable(fcx, expr, *ty, i_ty,\n+                                          allow_unsafe, is_early));\n               }\n               _ => ()\n             }\n@@ -331,9 +331,9 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             // the impl as well as the resolved list\n                             // of type substitutions for the target\n                             // trait.\n-                            vec::push(found,\n-                                      vtable_static(im.did, substs_f.tps,\n-                                                    subres));\n+                            found.push(\n+                                vtable_static(im.did, substs_f.tps,\n+                                              subres));\n                         }\n                     }\n                 }"}, {"sha": "33a26c8daf4972c26c4c99efde6b54fbac7074c4", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -94,7 +94,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n             let mut new_tps = ~[];\n             for substs.tps.each |subst| {\n                 match resolve_type_vars_in_type(fcx, sp, *subst) {\n-                  Some(t) => vec::push(new_tps, t),\n+                  Some(t) => new_tps.push(t),\n                   None => { wbcx.success = false; return None; }\n                 }\n             }"}, {"sha": "907cdb4f5ecc0d91a851cf0e39bf172892216062", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -198,7 +198,7 @@ impl CoherenceChecker {\n                                               existing trait\",\n                                               sess.str_of(mi.ident));\n                                       let mut method_infos = mis;\n-                                      push(method_infos, mi);\n+                                      method_infos.push(mi);\n                                       pmm.insert(item.id, method_infos);\n                                     }\n                                     None => {\n@@ -547,7 +547,7 @@ impl CoherenceChecker {\n                     debug!(\n                         \"(creating impl) adding provided method `%s` to impl\",\n                         sess.str_of(provided_method.ident));\n-                    push(methods, *provided_method);\n+                    methods.push(*provided_method);\n                 }\n             }\n \n@@ -559,8 +559,7 @@ impl CoherenceChecker {\n                 let mut methods = ~[];\n \n                 for ast_methods.each |ast_method| {\n-                    push(methods,\n-                         method_to_MethodInfo(*ast_method));\n+                    methods.push(method_to_MethodInfo(*ast_method));\n                 }\n \n                 // For each trait that the impl implements, see what\n@@ -619,7 +618,7 @@ impl CoherenceChecker {\n                             -> @Impl {\n         let mut methods = ~[];\n         for struct_def.methods.each |ast_method| {\n-            push(methods, @{\n+            methods.push(@{\n                 did: local_def(ast_method.id),\n                 n_tps: ast_method.tps.len(),\n                 ident: ast_method.ident,"}, {"sha": "8eabb2c078793d259200bad3da3391437ecb6d60", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -830,7 +830,7 @@ impl RegionVarBindings {\n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n         for self.constraints.each_ref |constraint, span| {\n-            vec::push(edges, GraphEdge {\n+            edges.push(GraphEdge {\n                 next_edge: [mut uint::max_value, uint::max_value],\n                 constraint: *constraint,\n                 span: *span\n@@ -1201,21 +1201,21 @@ impl RegionVarBindings {\n                       Outgoing => to_vid\n                     };\n                     if set.insert(*vid, ()) {\n-                        vec::push(stack, vid);\n+                        stack.push(vid);\n                     }\n                   }\n \n                   ConstrainRegSubVar(region, _) => {\n                     assert dir == Incoming;\n-                    vec::push(result, SpannedRegion {\n+                    result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span\n                     });\n                   }\n \n                   ConstrainVarSubReg(_, region) => {\n                     assert dir == Outgoing;\n-                    vec::push(result, SpannedRegion {\n+                    result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span\n                     });"}, {"sha": "a366a2ef1c7103264c51c8bd30b8ed3644d995d4", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -174,7 +174,7 @@ impl resolve_state {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n         } else {\n-            vec::push(self.v_seen, vid);\n+            self.v_seen.push(vid);\n             let tcx = self.infcx.tcx;\n \n             // Nonobvious: prefer the most specific type"}, {"sha": "7ccbaa40ada199960d3cb876a7bc7adfe9fffa3a", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -51,7 +51,7 @@ impl infer_ctxt {\n         +new_v: var_value<V, T>) {\n \n         let old_v = vb.vals.get(vid.to_uint());\n-        vec::push(vb.bindings, (vid, old_v));\n+        vb.bindings.push((vid, old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n \n         debug!(\"Updating variable %s from %s to %s\","}, {"sha": "37cc016e8ea08dea0b9afade952c2d1cfe900b77", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -36,7 +36,7 @@ fn field_expr(f: ast::field) -> @ast::expr { return f.node.expr; }\n \n fn field_exprs(fields: ~[ast::field]) -> ~[@ast::expr] {\n     let mut es = ~[];\n-    for fields.each |f| { vec::push(es, f.node.expr); }\n+    for fields.each |f| { es.push(f.node.expr); }\n     return es;\n }\n "}, {"sha": "0df5827ed3d8f794230e285bf80afcb24e2083b8", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -286,7 +286,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         }\n         s += ~\"(\";\n         let mut strs = ~[];\n-        for inputs.each |a| { vec::push(strs, fn_input_to_str(cx, *a)); }\n+        for inputs.each |a| { strs.push(fn_input_to_str(cx, *a)); }\n         s += str::connect(strs, ~\", \");\n         s += ~\")\";\n         if ty::get(output).sty != ty_nil {\n@@ -342,12 +342,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_type => ~\"type\",\n       ty_rec(elems) => {\n         let mut strs: ~[~str] = ~[];\n-        for elems.each |fld| { vec::push(strs, field_to_str(cx, *fld)); }\n+        for elems.each |fld| { strs.push(field_to_str(cx, *fld)); }\n         ~\"{\" + str::connect(strs, ~\",\") + ~\"}\"\n       }\n       ty_tup(elems) => {\n         let mut strs = ~[];\n-        for elems.each |elem| { vec::push(strs, ty_to_str(cx, *elem)); }\n+        for elems.each |elem| { strs.push(ty_to_str(cx, *elem)); }\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n       ty_fn(ref f) => {"}, {"sha": "7b34a327bee248f29d74ba9bfcb27d8f062d989c", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -140,7 +140,7 @@ fn nmoddoc_from_mod(\n         let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n         match item.node {\n           ast::foreign_item_fn(*) => {\n-            vec::push(fns, fndoc_from_fn(ItemDoc));\n+            fns.push(fndoc_from_fn(ItemDoc));\n           }\n           ast::foreign_item_const(*) => {} // XXX: Not implemented.\n         }"}, {"sha": "96ed269a7e97941ce8dcb4bf06553025d27cfb74", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -43,7 +43,7 @@ fn fold_item(fold: fold::Fold<Ctxt>, doc: doc::ItemDoc) -> doc::ItemDoc {\n fn fold_mod(fold: fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n     let is_topmod = doc.id() == ast::crate_node_id;\n \n-    if !is_topmod { vec::push(fold.ctxt.path, doc.name()); }\n+    if !is_topmod { fold.ctxt.path.push(doc.name()); }\n     let doc = fold::default_any_fold_mod(fold, doc);\n     if !is_topmod { vec::pop(fold.ctxt.path); }\n \n@@ -54,7 +54,7 @@ fn fold_mod(fold: fold::Fold<Ctxt>, doc: doc::ModDoc) -> doc::ModDoc {\n }\n \n fn fold_nmod(fold: fold::Fold<Ctxt>, doc: doc::NmodDoc) -> doc::NmodDoc {\n-    vec::push(fold.ctxt.path, doc.name());\n+    fold.ctxt.path.push(doc.name());\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     vec::pop(fold.ctxt.path);\n "}, {"sha": "9454ef7aec7402c5385cb1dabb78e8e28bf34700", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -47,7 +47,7 @@ fn shift_push() {\n     let mut v2 = ~[];\n \n     while v1.len() > 0 {\n-        vec::push(v2, vec::shift(v1));\n+        v2.push(vec::shift(v1));\n     }\n }\n \n@@ -122,11 +122,11 @@ fn vec_push_all() {\n     for uint::range(0, 1500) |i| {\n         let mut rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n         if r.gen_bool() {\n-            vec::push_all(v, rv);\n+            v.push_all(rv);\n         }\n         else {\n             v <-> rv;\n-            vec::push_all(v, rv);\n+            v.push_all(rv);\n         }\n     }\n }"}, {"sha": "2b9216876b42fd8ec946f28ec0e8d8531a28f967", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -7,7 +7,7 @@ use io::WriterUtil;\n fn collect_raw(num: uint) -> ~[uint] {\n     let mut result = ~[];\n     for uint::range(0u, num) |i| {\n-        vec::push(result, i);\n+        result.push(i);\n     }\n     return result;\n }"}, {"sha": "ef2fa8dfa9e1ae1569fbc5febaa9808b3f4d01a6", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -318,7 +318,7 @@ fn validate(edges: ~[(node_id, node_id)],\n                     status = false;\n                 }\n \n-                vec::push(path, parent);\n+                path.push(parent);\n                 parent = tree[parent];\n             }\n "}, {"sha": "392f67d671498c3e3c86a9a7a98c4bdf2586c076", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -60,7 +60,7 @@ fn run(args: &[~str]) {\n     for uint::range(0u, workers) |i| {\n         let to_child = to_child.clone();\n         do task::task().future_result(|+r| {\n-            vec::push(worker_results, r);\n+            worker_results.push(r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);"}, {"sha": "6ba8b71d8c43460f2c688dd92f2d26b5d2156daa", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -57,7 +57,7 @@ fn run(args: &[~str]) {\n         let (to_child, from_parent_) = pipes::stream();\n         from_parent.add(from_parent_);\n         do task::task().future_result(|+r| {\n-            vec::push(worker_results, r);\n+            worker_results.push(r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n                 //error!(\"worker %?: sending %? bytes\", i, num_bytes);"}, {"sha": "2931cab248fa22ffa58e2b08f42b869f0dc8099e", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -18,7 +18,7 @@ type pipe = arc::MutexARC<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n     do p.access_cond |state, cond| {\n-        vec::push(*state, msg);\n+        state.push(msg);\n         cond.signal();\n     }\n }\n@@ -91,7 +91,7 @@ fn main(++args: ~[~str]) {\n                         option::unwrap(num_chan),\n                         option::unwrap(num_port1))\n         });\n-        vec::push(futures, new_future);\n+        futures.push(new_future);\n         num_chan = Some(new_chan);\n     };\n "}, {"sha": "3c888fd0c8d4505afd426d79d57ff1e1e905e1ab", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -88,7 +88,7 @@ fn main(++args: ~[~str]) {\n                         option::unwrap(num_chan),\n                         option::unwrap(num_port1))\n         };\n-        vec::push(futures, new_future);\n+        futures.push(new_future);\n         num_chan = Some(new_chan);\n     };\n "}, {"sha": "525cf8f1c50379ce2c67aa4d578b410ee904dae9", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -18,7 +18,7 @@ type pipe = arc::RWARC<~[uint]>;\n \n fn send(p: &pipe, msg: uint) {\n     do p.write_cond |state, cond| {\n-        vec::push(*state, msg);\n+        state.push(msg);\n         cond.signal();\n     }\n }\n@@ -92,7 +92,7 @@ fn main(++args: ~[~str]) {\n                         option::unwrap(num_chan),\n                         option::unwrap(num_port1))\n         };\n-        vec::push(futures, new_future);\n+        futures.push(new_future);\n         num_chan = Some(new_chan);\n     };\n "}, {"sha": "5533aeeeb41b788b07b3620b29d1881906d61dd6", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -51,7 +51,7 @@ fn main(++args: ~[~str]) {\n             get_chan_chan.send(Chan(p));\n             thread_ring(i, msg_per_task, num_chan,  p)\n         };\n-        vec::push(futures, new_future);\n+        futures.push(new_future);\n         \n         num_chan = get_chan.recv();\n     };"}, {"sha": "fb1e3ae92262817f4a25ea743ed6ea38955d70c3", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -37,7 +37,7 @@ fn run(args: ~[~str]) {\n     let mut worker_results = ~[];\n     for uint::range(0u, workers) |_i| {\n         do task::task().future_result(|+r| {\n-            vec::push(worker_results, r);\n+            worker_results.push(r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n                 comm::send(to_child, bytes(100u));"}, {"sha": "5c7827f5106d114c4ec8f09e777141e10b19d350", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -163,7 +163,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     // save each creature's meeting stats\n     let mut report = ~[];\n     for vec::each(to_creature) |_to_one| {\n-        vec::push(report, comm::recv(from_creatures_log));\n+        report.push(comm::recv(from_creatures_log));\n     }\n \n     // print each color in the set"}, {"sha": "4f821a534ab480a17fe7887aab6427ba0411cc05", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -41,7 +41,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    // map -> [(k,%)]\n    mm.each(fn&(key: ~[u8], val: uint) -> bool {\n-      vec::push(pairs, (key, pct(val, total)));\n+      pairs.push((key, pct(val, total)));\n       return true;\n    });\n \n@@ -152,7 +152,7 @@ fn main(++args: ~[~str]) {\n         stream <-> streams[ii];\n         let (to_parent_, from_child_) = option::unwrap(stream);\n \n-        vec::push(from_child, from_child_);\n+        from_child.push(from_child_);\n \n         let (to_child, from_parent) = pipes::stream();\n "}, {"sha": "3b00fd99a5534326ec0eb5df651dfa6611dbafdd", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -38,7 +38,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n    // map -> [(k,%)]\n    mm.each(fn&(key: ~[u8], val: uint) -> bool {\n-      vec::push(pairs, (key, pct(val, total)));\n+      pairs.push((key, pct(val, total)));\n       return true;\n    });\n "}, {"sha": "d9859d54648ea886dc763dec30b9ac8b700e1bd5", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -85,7 +85,7 @@ fn chanmb(i: uint, size: uint, ch: comm::Chan<line>) -> ()\n     let xincr = 8f64*incr;\n     for uint::range(0_u, size/8_u) |j| {\n         let x = cmplx {re: xincr*(j as f64) - 1.5f64, im: y};\n-        vec::push(crv, fillbyte(x, incr));\n+        crv.push(fillbyte(x, incr));\n     };\n     comm::send(ch, {i:i, b:crv});\n }"}, {"sha": "90224645f84c32c718b174d01d8df548b0e0f5d8", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -73,7 +73,7 @@ fn stress(num_tasks: int) {\n     let mut results = ~[];\n     for range(0, num_tasks) |i| {\n         do task::task().future_result(|+r| {\n-            vec::push(results, r);\n+            results.push(r);\n         }).spawn {\n             stress_task(i);\n         }"}, {"sha": "c9d4fb6b4d871f4bb84a7307121eb6519f12b0f5", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -21,7 +21,7 @@ fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n     for iter::repeat (children) {\n         match comm::recv(port) {\n           ready(child_ch) => {\n-            vec::push(child_chs, child_ch);\n+            child_chs.push(child_ch);\n           }\n           _ => fail ~\"task-perf-one-million failed (port not ready)\"\n         }"}, {"sha": "efb795a76afe8c0e7cd2712cb87f3f48adeef3b8", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -155,8 +155,8 @@ mod map_reduce {\n             let (ctrl, ctrl_server) = ctrl_proto::init();\n             let ctrl = box(ctrl);\n             let i = copy *i;\n-            vec::push(tasks, spawn_joinable(|move i| map_task(map, ctrl, i)));\n-            vec::push(ctrls, ctrl_server);\n+            tasks.push(spawn_joinable(|move i| map_task(map, ctrl, i)));\n+            ctrls.push(ctrl_server);\n         }\n         return tasks;\n     }\n@@ -270,8 +270,7 @@ mod map_reduce {\n                     let p = Port();\n                     let ch = Chan(p);\n                     let r = reduce, kk = k;\n-                    vec::push(tasks,\n-                              spawn_joinable(|| reduce_task(r, kk, ch) ));\n+                    tasks.push(spawn_joinable(|| reduce_task(r, kk, ch) ));\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }"}, {"sha": "b7666fa865094eabd7eb7e4809fbd0491201629c", "filename": "src/test/compile-fail/purity-infer-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -2,5 +2,5 @@ fn something(f: pure fn()) { f(); }\n \n fn main() {\n     let mut x = ~[];\n-    something(|| vec::push(x, 0) ); //~ ERROR access to impure function prohibited in pure context\n+    something(|| x.push(0) ); //~ ERROR access to impure function prohibited in pure context\n }"}, {"sha": "c6239c1f657c92b32ee32a78be17edaaaeb2dda2", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -8,15 +8,15 @@ fn enum_chars(start: u8, end: u8) -> ~[char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n+    while i <= end { r.push(i as char); i += 1u as u8; }\n     return r;\n }\n \n fn enum_uints(start: uint, end: uint) -> ~[uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { vec::push(r, i); i += 1u; }\n+    while i <= end { r.push(i); i += 1u; }\n     return r;\n }\n "}, {"sha": "48d83da74adbc81507882247d37f51f3ef335c3e", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -4,7 +4,7 @@ trait Pushable<T> {\n \n impl<T> ~[T]: Pushable<T> {\n     fn push_val(&mut self, +t: T) {\n-        vec::push(*self, t);\n+        self.push(t);\n     }\n }\n "}, {"sha": "cb70a1810b7c499dd361739d2417c3aa8b7e5f97", "filename": "src/test/run-pass/autoref-vec-push.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Ftest%2Frun-pass%2Fautoref-vec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd79e1d1b20a2c289dd15bc2766f97c789d975aa/src%2Ftest%2Frun-pass%2Fautoref-vec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-vec-push.rs?ref=cd79e1d1b20a2c289dd15bc2766f97c789d975aa", "patch": "@@ -1,17 +0,0 @@\n-trait VecPush<T> {\n-    fn push(&mut self, +t: T);\n-}\n-\n-impl<T> ~[T]: VecPush<T> {\n-    fn push(&mut self, +t: T) {\n-        vec::push(*self, t);\n-    }\n-}\n-\n-fn main() {\n-    let mut x = ~[];\n-    x.push(1);\n-    x.push(2);\n-    x.push(3);\n-    assert x == ~[1, 2, 3];\n-}\n\\ No newline at end of file"}, {"sha": "2d1833c0736731e14df974a3dc0ef4d01743b685", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -4,7 +4,7 @@ fn add_int(x: &mut ints, v: int) {\n     *x.sum += v;\n     let mut values = ~[];\n     x.values <-> values;\n-    vec::push(values, v);\n+    values.push(v);\n     x.values <- values;\n }\n "}, {"sha": "fc637429cd0c75f8bdeb9cf3f299b75b8f946fc2", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -52,10 +52,15 @@ fn read_board_grid<rdr: Owned io::Reader>(+in: rdr) -> ~[~[square]] {\n     let mut grid = ~[];\n     for in.each_line |line| {\n         let mut row = ~[];\n+<<<<<<< HEAD\n         for str::each_char(line) |c| {\n             vec::push(row, square_from_char(c))\n+=======\n+        for line.each_char |c| {\n+            row.push(square_from_char(c))\n+>>>>>>> Demode vec::push (and convert to method)\n         }\n-        vec::push(grid, row)\n+        grid.push(row)\n     }\n     let width = grid[0].len();\n     for grid.each |row| { assert row.len() == width }"}, {"sha": "4faac4fdac19a593b69c46ed569e068be20cb3b0", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -34,7 +34,7 @@ fn test00() {\n     while i < number_of_tasks {\n         let ch = po.chan();\n         do task::task().future_result(|+r| {\n-            vec::push(results, r);\n+            results.push(r);\n         }).spawn |copy i| {\n             test00_start(ch, i, number_of_messages)\n         }"}, {"sha": "8d144b1a3995dd20c52e97cbd07eea63d1cc2fad", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -40,7 +40,7 @@ fn test00() {\n     while i < number_of_tasks {\n         i = i + 1;\n         do task::task().future_result(|+r| {\n-            vec::push(results, r);\n+            results.push(r);\n         }).spawn |copy i| {\n             test00_start(ch, i, number_of_messages);\n         }\n@@ -127,7 +127,7 @@ fn test06() {\n     while i < number_of_tasks {\n         i = i + 1;\n         do task::task().future_result(|+r| {\n-            vec::push(results, r);\n+            results.push(r);\n         }).spawn |copy i| {\n             test06_start(i);\n         };"}, {"sha": "d4190d4138613fabbf779f9936158ef1ac275ed1", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -1 +1 @@\n-fn main() { let mut v = ~[1, 2, 3]; vec::push(v, 1); }\n+fn main() { let mut v = ~[1, 2, 3]; v.push(1); }"}, {"sha": "9b8304792fa3bcc1726844a95729fc0c40289287", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67a8e7128aea292445b763b47b04bc5f4fd43cb2/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=67a8e7128aea292445b763b47b04bc5f4fd43cb2", "patch": "@@ -7,15 +7,15 @@ fn enum_chars(start: u8, end: u8) -> ~[char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n+    while i <= end { r.push(i as char); i += 1u as u8; }\n     return r;\n }\n \n fn enum_uints(start: uint, end: uint) -> ~[uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = ~[];\n-    while i <= end { vec::push(r, i); i += 1u; }\n+    while i <= end { r.push(i); i += 1u; }\n     return r;\n }\n "}]}