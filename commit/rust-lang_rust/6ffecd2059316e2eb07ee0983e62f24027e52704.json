{"sha": "6ffecd2059316e2eb07ee0983e62f24027e52704", "node_id": "C_kwDOAAsO6NoAKDZmZmVjZDIwNTkzMTZlMmViMDdlZTA5ODNlNjJmMjQwMjdlNTI3MDQ", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-10-23T01:50:44Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T22:07:25Z"}, "message": "migrate(wip): `builtin.rs`", "tree": {"sha": "3a1deed76d5903908c929b3667f65d507c00135d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1deed76d5903908c929b3667f65d507c00135d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ffecd2059316e2eb07ee0983e62f24027e52704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ffecd2059316e2eb07ee0983e62f24027e52704", "html_url": "https://github.com/rust-lang/rust/commit/6ffecd2059316e2eb07ee0983e62f24027e52704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ffecd2059316e2eb07ee0983e62f24027e52704/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b19227524622d953fbaefa272b36b0ef2fa263e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b19227524622d953fbaefa272b36b0ef2fa263e", "html_url": "https://github.com/rust-lang/rust/commit/0b19227524622d953fbaefa272b36b0ef2fa263e"}], "stats": {"total": 612, "additions": 383, "deletions": 229}, "files": [{"sha": "1080ba2d2b565dabd9200f59ca872707e3e3640a", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=6ffecd2059316e2eb07ee0983e62f24027e52704", "patch": "@@ -433,6 +433,13 @@ lint_builtin_deref_nullptr = dereferencing a null pointer\n \n lint_builtin_asm_labels = avoid using named labels in inline assembly\n \n+lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n+    .note = lib.rs is the root of this crate's library target\n+    .help = to refer to it from other targets, use the library's name as the path\n+\n+lint_builtin_special_module_name_used_main = found module declaration for main.rs\n+    .note = a binary crate cannot be used as library\n+\n lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n     .label = overruled by previous forbid\n "}, {"sha": "8a34afb1ff5242541a5ecb1b1445c8bca4fbffb8", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 120, "deletions": 228, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6ffecd2059316e2eb07ee0983e62f24027e52704", "patch": "@@ -22,6 +22,17 @@\n \n use crate::{\n     errors::BuiltinEllpisisInclusiveRangePatterns,\n+    lints::{\n+        BuiltinAnonymousParams, BuiltinBoxPointers, BuiltinConstNoMangle,\n+        BuiltinDeprecatedAttrUsed, BuiltinDerefNullptr, BuiltinEllipsisInclusiveRangePatternsLint,\n+        BuiltinExplicitOutlives, BuiltinExplicitOutlivesSuggestion, BuiltinIncompleteFeatures,\n+        BuiltinKeywordIdents, BuiltinMissingCopyImpl, BuiltinMissingDebugImpl, BuiltinMissingDoc,\n+        BuiltinMutablesTransmutes, BuiltinNoMangleGeneric, BuiltinNonShorthandFieldPatterns,\n+        BuiltinSpecialModuleNameUsed, BuiltinTrivialBounds, BuiltinUnexpectedCliConfigName,\n+        BuiltinUnexpectedCliConfigValue, BuiltinUnnameableTestItems, BuiltinUnreachablePub,\n+        BuiltinUnstableFeatures, BuiltinUnusedDocComment, BuiltinUnusedDocCommentSub,\n+        BuiltinWhileTrue,\n+    },\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n@@ -110,25 +121,17 @@ impl EarlyLintPass for WhileTrue {\n             && !cond.span.from_expansion()\n         {\n             let condition_span = e.span.with_hi(cond.span.hi());\n-            cx.struct_span_lint(\n-                            WHILE_TRUE,\n-                            condition_span,\n-                fluent::lint_builtin_while_true,\n-                            |lint| {\n-                    lint.span_suggestion_short(\n-                        condition_span,\n-                        fluent::suggestion,\n-                        format!(\n+            let replace = format!(\n                             \"{}loop\",\n                             label.map_or_else(String::new, |label| format!(\n                                 \"{}: \",\n                                 label.ident,\n                             ))\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    )\n-                },\n-            )\n+                        );\n+            cx.emit_spanned_lint(WHILE_TRUE, condition_span, BuiltinWhileTrue {\n+                suggestion: condition_span,\n+                replace,\n+            });\n         }\n     }\n }\n@@ -164,12 +167,7 @@ impl BoxPointers {\n         for leaf in ty.walk() {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n-                    cx.struct_span_lint(\n-                        BOX_POINTERS,\n-                        span,\n-                        fluent::lint_builtin_box_pointers,\n-                        |lint| lint.set_arg(\"ty\", ty),\n-                    );\n+                    cx.emit_spanned_lint(BOX_POINTERS, span, BuiltinBoxPointers { ty });\n                 }\n             }\n         }\n@@ -267,19 +265,13 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.typeck_results().field_index(fieldpat.hir_id))\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            fluent::lint_builtin_non_shorthand_field_patterns,\n-                            |lint| {\n-                                let suggested_ident =\n-                                    format!(\"{}{}\", binding_annot.prefix_str(), ident);\n-                                lint.set_arg(\"ident\", ident).span_suggestion(\n-                                    fieldpat.span,\n-                                    fluent::suggestion,\n-                                    suggested_ident,\n-                                    Applicability::MachineApplicable,\n-                                )\n+                            BuiltinNonShorthandFieldPatterns {\n+                                ident,\n+                                suggestion: fieldpat.span,\n+                                prefix: binding_annot.prefix_str(),\n                             },\n                         );\n                     }\n@@ -578,11 +570,10 @@ impl MissingDoc {\n         let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DOCS,\n                 cx.tcx.def_span(def_id),\n-                fluent::lint_builtin_missing_doc,\n-                |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n+                BuiltinMissingDoc { article, desc },\n             );\n         }\n     }\n@@ -799,12 +790,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         )\n         .is_ok()\n         {\n-            cx.struct_span_lint(\n-                MISSING_COPY_IMPLEMENTATIONS,\n-                item.span,\n-                fluent::lint_builtin_missing_copy_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, BuiltinMissingCopyImpl);\n         }\n     }\n }\n@@ -878,11 +864,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.owner_id.def_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint_builtin_missing_debug_impl,\n-                |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n+                BuiltinMissingDebugImpl { tcx: cx.tcx, def_id: debug },\n             );\n         }\n     }\n@@ -958,19 +943,11 @@ impl EarlyLintPass for AnonymousParameters {\n                         } else {\n                             (\"<type>\", Applicability::HasPlaceholders)\n                         };\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             ANONYMOUS_PARAMETERS,\n                             arg.pat.span,\n-                            fluent::lint_builtin_anonymous_params,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    arg.pat.span,\n-                                    fluent::suggestion,\n-                                    format!(\"_: {}\", ty_snip),\n-                                    appl,\n-                                )\n-                            },\n-                        )\n+                            BuiltinAnonymousParams { suggestion: (arg.pat.span, appl), ty_snip },\n+                        );\n                     }\n                 }\n             }\n@@ -1029,18 +1006,12 @@ impl EarlyLintPass for DeprecatedAttr {\n             }\n         }\n         if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 DEPRECATED,\n                 attr.span,\n-                fluent::lint_builtin_deprecated_attr_used,\n-                |lint| {\n-                    lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n-                        .span_suggestion_short(\n-                            attr.span,\n-                            fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        )\n+                BuiltinDeprecatedAttrUsed {\n+                    name: pprust::path_to_string(&attr.get_normal_item().path),\n+                    suggestion: attr.span,\n                 },\n             );\n         }\n@@ -1069,20 +1040,18 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n         let span = sugared_span.take().unwrap_or(attr.span);\n \n         if is_doc_comment || attr.has_name(sym::doc) {\n-            cx.struct_span_lint(\n+            let sub = match attr.kind {\n+                AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n+                    BuiltinUnusedDocCommentSub::PlainHelp\n+                }\n+                AttrKind::DocComment(CommentKind::Block, _) => {\n+                    BuiltinUnusedDocCommentSub::BlockHelp\n+                }\n+            };\n+            cx.emit_spanned_lint(\n                 UNUSED_DOC_COMMENTS,\n                 span,\n-                fluent::lint_builtin_unused_doc_comment,\n-                |lint| {\n-                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::label).help(\n-                        match attr.kind {\n-                            AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                                fluent::plain_help\n-                            }\n-                            AttrKind::DocComment(CommentKind::Block, _) => fluent::block_help,\n-                        },\n-                    )\n-                },\n+                BuiltinUnusedDocComment { kind: node_kind, label: node_span, sub },\n             );\n         }\n     }\n@@ -1197,20 +1166,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NO_MANGLE_GENERIC_ITEMS,\n                             span,\n-                            fluent::lint_builtin_no_mangle_generic,\n-                            |lint| {\n-                                lint.span_suggestion_short(\n-                                    no_mangle_attr.span,\n-                                    fluent::suggestion,\n-                                    \"\",\n-                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                    // fix may be to monomorphize source by hand\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                            },\n+                            BuiltinNoMangleGeneric { suggestion: no_mangle_attr.span },\n                         );\n                         break;\n                     }\n@@ -1225,30 +1184,23 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             }\n             hir::ItemKind::Const(..) => {\n                 if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                    // account for \"pub const\" (#45562)\n+                    let start = cx\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(it.span)\n+                        .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                        .unwrap_or(0) as u32;\n+                    // `const` is 5 chars\n+                    let suggestion = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         NO_MANGLE_CONST_ITEMS,\n                         it.span,\n-                        fluent::lint_builtin_const_no_mangle,\n-                        |lint| {\n-                            // account for \"pub const\" (#45562)\n-                            let start = cx\n-                                .tcx\n-                                .sess\n-                                .source_map()\n-                                .span_to_snippet(it.span)\n-                                .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                                .unwrap_or(0) as u32;\n-                            // `const` is 5 chars\n-                            let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                            lint.span_suggestion(\n-                                const_span,\n-                                fluent::suggestion,\n-                                \"pub static\",\n-                                Applicability::MachineApplicable,\n-                            )\n-                        },\n+                        BuiltinConstNoMangle { suggestion },\n                     );\n                 }\n             }\n@@ -1309,12 +1261,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if from_mutbl < to_mutbl {\n-                cx.struct_span_lint(\n-                    MUTABLE_TRANSMUTES,\n-                    expr.span,\n-                    fluent::lint_builtin_mutable_transmutes,\n-                    |lint| lint,\n-                );\n+                cx.emit_spanned_lint(MUTABLE_TRANSMUTES, expr.span, BuiltinMutablesTransmutes);\n             }\n         }\n \n@@ -1362,12 +1309,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n         if attr.has_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    cx.struct_span_lint(\n-                        UNSTABLE_FEATURES,\n-                        item.span(),\n-                        fluent::lint_builtin_unstable_features,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNSTABLE_FEATURES, item.span(), BuiltinUnstableFeatures);\n                 }\n             }\n         }\n@@ -1493,18 +1435,13 @@ impl UnreachablePub {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n             let def_span = cx.tcx.def_span(def_id);\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNREACHABLE_PUB,\n                 def_span,\n-                fluent::lint_builtin_unreachable_pub,\n-                |lint| {\n-                    lint.set_arg(\"what\", what);\n-\n-                    lint.span_suggestion(vis_span, fluent::suggestion, \"pub(crate)\", applicability);\n-                    if exportable {\n-                        lint.help(fluent::help);\n-                    }\n-                    lint\n+                BuiltinUnreachablePub {\n+                    what,\n+                    suggestion: (vis_span, applicability),\n+                    help: exportable.then_some(()),\n                 },\n             );\n         }\n@@ -1767,14 +1704,10 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        fluent::lint_builtin_trivial_bounds,\n-                        |lint| {\n-                            lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n-                                .set_arg(\"predicate\", predicate)\n-                        },\n+                        BuiltinTrivialBounds { predicate_kind_name, predicate },\n                     );\n                 }\n             }\n@@ -1875,8 +1808,6 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = fluent::lint_builtin_ellipsis_inclusive_range_patterns;\n-            let suggestion = fluent::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1891,14 +1822,14 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace,\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg, |lint| {\n-                        lint.span_suggestion(\n-                            pat.span,\n-                            suggestion,\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        pat.span,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::Parenthesise {\n+                            suggestion: pat.span,\n                             replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                        },\n+                    );\n                 }\n             } else {\n                 let replace = \"..=\";\n@@ -1909,14 +1840,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace: replace.to_string(),\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg, |lint| {\n-                        lint.span_suggestion_short(\n-                            join,\n-                            suggestion,\n-                            replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        join,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::NonParenthesise {\n+                            suggestion: join,\n+                        },\n+                    );\n                 }\n             };\n         }\n@@ -1996,12 +1926,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(\n-                UNNAMEABLE_TEST_ITEMS,\n-                attr.span,\n-                fluent::lint_builtin_unnameable_test_items,\n-                |lint| lint,\n-            );\n+            cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }\n \n@@ -2117,18 +2042,10 @@ impl KeywordIdents {\n             return;\n         }\n \n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            fluent::lint_builtin_keyword_idents,\n-            |lint| {\n-                lint.set_arg(\"kw\", ident).set_arg(\"next\", next_edition).span_suggestion(\n-                    ident.span,\n-                    fluent::suggestion,\n-                    format!(\"r#{}\", ident),\n-                    Applicability::MachineApplicable,\n-                )\n-            },\n+            BuiltinKeywordIdents { kw: ident, next: next_edition, suggestion: ident.span },\n         );\n     }\n }\n@@ -2405,16 +2322,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     Applicability::MaybeIncorrect\n                 };\n \n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    fluent::lint_builtin_explicit_outlives,\n-                    |lint| {\n-                        lint.set_arg(\"count\", bound_count).multipart_suggestion(\n-                            fluent::suggestion,\n-                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                    BuiltinExplicitOutlives {\n+                        count: bound_count,\n+                        suggestion: BuiltinExplicitOutlivesSuggestion {\n+                            spans: lint_spans,\n                             applicability,\n-                        )\n+                        },\n                     },\n                 );\n             }\n@@ -2463,24 +2379,15 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(&name, _)| features.incomplete(name))\n             .for_each(|(&name, &span)| {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    fluent::lint_builtin_incomplete_features,\n-                    |lint| {\n-                        lint.set_arg(\"name\", name);\n-                        if let Some(n) =\n-                            rustc_feature::find_feature_issue(name, GateIssue::Language)\n-                        {\n-                            lint.set_arg(\"n\", n);\n-                            lint.note(fluent::note);\n-                        }\n-                        if HAS_MIN_FEATURES.contains(&name) {\n-                            lint.help(fluent::help);\n-                        }\n-                        lint\n+                    BuiltinIncompleteFeatures {\n+                        name,\n+                        note: rustc_feature::find_feature_issue(name, GateIssue::Language),\n+                        help: HAS_MIN_FEATURES.contains(&name).then_some(()),\n                     },\n-                )\n+                );\n             });\n     }\n }\n@@ -3275,11 +3182,10 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n \n         if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n             if is_null_ptr(cx, expr_deref) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     DEREF_NULLPTR,\n                     expr.span,\n-                    fluent::lint_builtin_deref_nullptr,\n-                    |lint| lint.span_label(expr.span, fluent::label),\n+                    BuiltinDerefNullptr { label: expr.span },\n                 );\n             }\n         }\n@@ -3464,16 +3370,17 @@ impl EarlyLintPass for SpecialModuleName {\n                 }\n \n                 match item.ident.name.as_str() {\n-                    \"lib\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for lib.rs\", |lint| {\n-                        lint\n-                            .note(\"lib.rs is the root of this crate's library target\")\n-                            .help(\"to refer to it from other targets, use the library's name as the path\")\n-                    }),\n-                    \"main\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for main.rs\", |lint| {\n-                        lint\n-                            .note(\"a binary crate cannot be used as library\")\n-                    }),\n-                    _ => continue\n+                    \"lib\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Lib,\n+                    ),\n+                    \"main\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Main,\n+                    ),\n+                    _ => continue,\n                 }\n             }\n         }\n@@ -3489,31 +3396,16 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid {\n-                if !names_valid.contains(&name) {\n-                    cx.lookup(\n-                        UNEXPECTED_CFGS,\n-                        None::<MultiSpan>,\n-                        fluent::lint_builtin_unexpected_cli_config_name,\n-                        |diag| diag.help(fluent::help).set_arg(\"name\", name),\n-                    );\n-                }\n+            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n+                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n+                    name,\n+                });\n             }\n-            if let Some(value) = value {\n-                if let Some(values) = &check_cfg.values_valid.get(&name) {\n-                    if !values.contains(&value) {\n-                        cx.lookup(\n-                            UNEXPECTED_CFGS,\n-                            None::<MultiSpan>,\n-                            fluent::lint_builtin_unexpected_cli_config_value,\n-                            |diag| {\n-                                diag.help(fluent::help)\n-                                    .set_arg(\"name\", name)\n-                                    .set_arg(\"value\", value)\n-                            },\n-                        );\n-                    }\n-                }\n+            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n+                cx.emit_lint(\n+                    UNEXPECTED_CFGS,\n+                    BuiltinUnexpectedCliConfigValue { name, value },\n+                );\n             }\n         }\n     }"}, {"sha": "ceecc2c9501eeae48abfac8830e889f011f81aa5", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 256, "deletions": 1, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ffecd2059316e2eb07ee0983e62f24027e52704/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=6ffecd2059316e2eb07ee0983e62f24027e52704", "patch": "@@ -1,8 +1,10 @@\n+use std::num::NonZeroU32;\n+\n use rustc_errors::{fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage};\n use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n-use rustc_span::{symbol::Ident, Span, Symbol};\n+use rustc_span::{edition::Edition, symbol::Ident, Span, Symbol};\n \n use crate::{errors::OverruledAttributeSub, LateContext};\n \n@@ -33,6 +35,259 @@ pub enum ArrayIntoIterDiagSub {\n     },\n }\n \n+// builtin.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_while_true)]\n+pub struct BuiltinWhileTrue {\n+    #[suggestion(style = \"short\", code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_box_pointers)]\n+pub struct BuiltinBoxPointers<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_non_shorthand_field_patterns)]\n+pub struct BuiltinNonShorthandFieldPatterns {\n+    pub ident: Ident,\n+    #[suggestion(code = \"{prefix}{ident}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub prefix: &'static str,\n+}\n+\n+// FIXME: add lint::unsafe_code\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_doc)]\n+pub struct BuiltinMissingDoc<'a> {\n+    pub article: &'a str,\n+    pub desc: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_copy_impl)]\n+pub struct BuiltinMissingCopyImpl;\n+\n+pub struct BuiltinMissingDebugImpl<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinMissingDebugImpl<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"debug\", self.tcx.def_path_str(self.def_id));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_builtin_missing_debug_impl\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_anonymous_params)]\n+pub struct BuiltinAnonymousParams<'a> {\n+    #[suggestion(code = \"_: {ty_snip}\")]\n+    pub suggestion: (Span, Applicability),\n+    pub ty_snip: &'a str,\n+}\n+\n+// FIXME: add lint::builtin_deprecated_attr_link\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_used)]\n+pub struct BuiltinDeprecatedAttrUsed {\n+    pub name: String,\n+    #[suggestion(\n+        lint_builtin_deprecated_attr_default_suggestion,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unused_doc_comment)]\n+pub struct BuiltinUnusedDocComment<'a> {\n+    pub kind: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[subdiagnostic]\n+    pub sub: BuiltinUnusedDocCommentSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinUnusedDocCommentSub {\n+    #[help(plain_help)]\n+    PlainHelp,\n+    #[help(block_help)]\n+    BlockHelp,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_no_mangle_generic)]\n+pub struct BuiltinNoMangleGeneric {\n+    // Use of `#[no_mangle]` suggests FFI intent; correct\n+    // fix may be to monomorphize source by hand\n+    #[suggestion(style = \"short\", code = \"\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_const_no_mangle)]\n+pub struct BuiltinConstNoMangle {\n+    #[suggestion(code = \"pub static\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_mutable_transmutes)]\n+pub struct BuiltinMutablesTransmutes;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unstable_features)]\n+pub struct BuiltinUnstableFeatures;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unreachable_pub)]\n+pub struct BuiltinUnreachablePub<'a> {\n+    pub what: &'a str,\n+    #[suggestion(code = \"pub(crate)\")]\n+    pub suggestion: (Span, Applicability),\n+    #[help]\n+    pub help: Option<()>,\n+}\n+\n+// FIXME: migrate builtin_type_alias_where_clause\n+\n+// FIXME: migrate builtin_type_alias_generic_bounds\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_trivial_bounds)]\n+pub struct BuiltinTrivialBounds<'a> {\n+    pub predicate_kind_name: &'a str,\n+    pub predicate: Predicate<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinEllipsisInclusiveRangePatternsLint {\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    Parenthesise {\n+        #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+        replace: String,\n+    },\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    NonParenthesise {\n+        #[suggestion(style = \"short\", code = \"..=\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unnameable_test_items)]\n+pub struct BuiltinUnnameableTestItems;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_keyword_idents)]\n+pub struct BuiltinKeywordIdents {\n+    pub kw: Ident,\n+    pub next: Edition,\n+    #[suggestion(code = \"r#{kw}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_explicit_outlives)]\n+pub struct BuiltinExplicitOutlives {\n+    pub count: usize,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinExplicitOutlivesSuggestion,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion)]\n+pub struct BuiltinExplicitOutlivesSuggestion {\n+    #[suggestion_part(code = \"\")]\n+    pub spans: Vec<Span>,\n+    #[applicability]\n+    pub applicability: Applicability,\n+}\n+\n+pub struct BuiltinIncompleteFeatures {\n+    pub name: Symbol,\n+    pub note: Option<NonZeroU32>,\n+    pub help: Option<()>,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinIncompleteFeatures {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"name\", self.name);\n+        if let Some(n) = self.note {\n+            diag.set_arg(\"n\", n);\n+            diag.note(fluent::note);\n+        }\n+        if let Some(_) = self.help {\n+            diag.help(fluent::help);\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_builtin_incomplete_features\n+    }\n+}\n+\n+// FIXME: migrate \"the type `{}` does not permit {}\"\n+\n+// FIXME: fluent::lint::builtin_clashing_extern_{same,diff}_name\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deref_nullptr)]\n+pub struct BuiltinDerefNullptr {\n+    #[label]\n+    pub label: Span,\n+}\n+\n+// FIXME: migrate fluent::lint::builtin_asm_labels\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinSpecialModuleNameUsed {\n+    #[diag(lint_builtin_special_module_name_used_lib)]\n+    #[note]\n+    #[help]\n+    Lib,\n+    #[diag(lint_builtin_special_module_name_used_main)]\n+    #[note]\n+    Main,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_name)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigName {\n+    pub name: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_value)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigValue {\n+    pub name: Symbol,\n+    pub value: Symbol,\n+}\n+\n // enum_intrinsics_non_enums.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_enum_intrinsics_mem_discriminant)]"}]}