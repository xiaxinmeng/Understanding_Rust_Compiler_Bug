{"sha": "a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjdkNmNlZTQwYzJmMmZhM2RiOTk5YWZiYjJiZDEzODRmNzg0MGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-10T14:43:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-10T14:43:52Z"}, "message": "Auto merge of #34200 - sanxiyn:rollup, r=sanxiyn\n\nRollup of 12 pull requests\n\n- Successful merges: #34088, #34129, #34136, #34145, #34146, #34148, #34159, #34160, #34165, #34175, #34184, #34185\n- Failed merges:", "tree": {"sha": "7f019ee7195a933addb73b8f0dee845c1349bd08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f019ee7195a933addb73b8f0dee845c1349bd08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "html_url": "https://github.com/rust-lang/rust/commit/a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68241f00ad8fb90474748b37ebd68b6bd46c796b", "url": "https://api.github.com/repos/rust-lang/rust/commits/68241f00ad8fb90474748b37ebd68b6bd46c796b", "html_url": "https://github.com/rust-lang/rust/commit/68241f00ad8fb90474748b37ebd68b6bd46c796b"}, {"sha": "107d423f1ab9a110fdf2253e7d0074f0ab5bf868", "url": "https://api.github.com/repos/rust-lang/rust/commits/107d423f1ab9a110fdf2253e7d0074f0ab5bf868", "html_url": "https://github.com/rust-lang/rust/commit/107d423f1ab9a110fdf2253e7d0074f0ab5bf868"}], "stats": {"total": 611, "additions": 349, "deletions": 262}, "files": [{"sha": "bc41e62b36a0094e233e6b0e8baaf23aa888e535", "filename": "README.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -75,13 +75,13 @@ build.\n    $ pacman -Sy pacman-mirrors\n    ```\n \n-Download [MinGW from\n-here](http://mingw-w64.org/doku.php/download/mingw-builds), and choose the\n-`version=4.9.x,threads=win32,exceptions=dwarf/seh` flavor when installing. Also, make sure to install to a path without spaces in it. After installing,\n-add its `bin` directory to your `PATH`. This is due to [#28260](https://github.com/rust-lang/rust/issues/28260), in the future,\n-installing from pacman should be just fine.\n+   Download [MinGW from\n+   here](http://mingw-w64.org/doku.php/download/mingw-builds), and choose the\n+   `version=4.9.x,threads=win32,exceptions=dwarf/seh` flavor when installing. Also, make sure to install to a path without spaces in it. After installing,\n+   add its `bin` directory to your `PATH`. This is due to [#28260](https://github.com/rust-lang/rust/issues/28260), in the future,\n+   installing from pacman should be just fine.\n \n-   ```\n+   ```sh\n    # Make git available in MSYS2 (if not already available on path)\n    $ pacman -S git\n \n@@ -90,6 +90,8 @@ installing from pacman should be just fine.\n \n 3. Run `mingw32_shell.bat` or `mingw64_shell.bat` from wherever you installed\n    MSYS2 (i.e. `C:\\msys`), depending on whether you want 32-bit or 64-bit Rust.\n+   (As of the latest version of MSYS2 you have to run `msys2_shell.cmd -mingw32`\n+   or `msys2_shell.cmd -mingw64` from the command line instead)\n \n 4. Navigate to Rust's source code, configure and build it:\n "}, {"sha": "544f837d69b264171df652134267d1f5f1551491", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -1829,7 +1829,7 @@ use std::error::Error;\n \n fn search<P: AsRef<Path>>\n          (file_path: P, city: &str)\n-         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {\n+         -> Result<Vec<PopulationCount>, Box<Error>> {\n     let mut found = vec![];\n     let file = try!(File::open(file_path));\n     let mut rdr = csv::Reader::from_reader(file);\n@@ -1858,20 +1858,17 @@ Instead of `x.unwrap()`, we now have `try!(x)`. Since our function returns a\n `Result<T, E>`, the `try!` macro will return early from the function if an\n error occurs.\n \n-There is one big gotcha in this code: we used `Box<Error + Send + Sync>`\n-instead of `Box<Error>`. We did this so we could convert a plain string to an\n-error type. We need these extra bounds so that we can use the\n-[corresponding `From`\n-impls](../std/convert/trait.From.html):\n+At the end of `search` we also convert a plain string to an error type \n+by using the [corresponding `From` impls](../std/convert/trait.From.html):\n \n ```rust,ignore\n // We are making use of this impl in the code above, since we call `From::from`\n // on a `&'static str`.\n-impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a>\n+impl<'a> From<&'a str> for Box<Error>\n \n // But this is also useful when you need to allocate a new string for an\n // error message, usually with `format!`.\n-impl From<String> for Box<Error + Send + Sync>\n+impl From<String> for Box<Error>\n ```\n \n Since `search` now returns a `Result<T, E>`, `main` should use case analysis\n@@ -1964,7 +1961,7 @@ use std::io;\n \n fn search<P: AsRef<Path>>\n          (file_path: &Option<P>, city: &str)\n-         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {\n+         -> Result<Vec<PopulationCount>, Box<Error>> {\n     let mut found = vec![];\n     let input: Box<io::Read> = match *file_path {\n         None => Box::new(io::stdin()),\n@@ -2175,9 +2172,8 @@ heuristics!\n   `unwrap`. Be warned: if it winds up in someone else's hands, don't be\n   surprised if they are agitated by poor error messages!\n * If you're writing a quick 'n' dirty program and feel ashamed about panicking\n-  anyway, then use either a `String` or a `Box<Error + Send + Sync>` for your\n-  error type (the `Box<Error + Send + Sync>` type is because of the\n-  [available `From` impls](../std/convert/trait.From.html)).\n+  anyway, then use either a `String` or a `Box<Error>` for your\n+  error type.\n * Otherwise, in a program, define your own error types with appropriate\n   [`From`](../std/convert/trait.From.html)\n   and"}, {"sha": "26e71d20833209e7ccdd2d826e1ee9a7832ca79e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 275, "deletions": 221, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -17,9 +17,9 @@ use core::ops::Index;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{self, Included, Excluded, Unbounded};\n+use Bound::{self, Excluded, Included, Unbounded};\n \n-use super::node::{self, NodeRef, Handle, marker};\n+use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n \n use super::node::InsertResult::*;\n@@ -68,7 +68,7 @@ use self::Entry::*;\n /// // would be `BTreeMap<&str, &str>` in this example).\n /// let mut movie_reviews = BTreeMap::new();\n ///\n-/// // review some books.\n+/// // review some movies.\n /// movie_reviews.insert(\"Office Space\",       \"Deals with real issues in the workplace.\");\n /// movie_reviews.insert(\"Pulp Fiction\",       \"Masterpiece.\");\n /// movie_reviews.insert(\"The Godfather\",      \"Very enjoyable.\");\n@@ -129,35 +129,38 @@ use self::Entry::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: node::Root<K, V>,\n-    length: usize\n+    length: usize,\n }\n \n impl<K, V> Drop for BTreeMap<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n-            for _ in ptr::read(self).into_iter() { }\n+            for _ in ptr::read(self).into_iter() {\n+            }\n         }\n     }\n }\n \n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n-        fn clone_subtree<K: Clone, V: Clone>(\n-                node: node::NodeRef<marker::Immut, K, V, marker::LeafOrInternal>)\n-                -> BTreeMap<K, V> {\n+        fn clone_subtree<K: Clone, V: Clone>(node: node::NodeRef<marker::Immut,\n+                                                                 K,\n+                                                                 V,\n+                                                                 marker::LeafOrInternal>)\n+                                             -> BTreeMap<K, V> {\n \n             match node.force() {\n                 Leaf(leaf) => {\n                     let mut out_tree = BTreeMap {\n                         root: node::Root::new_leaf(),\n-                        length: 0\n+                        length: 0,\n                     };\n \n                     {\n                         let mut out_node = match out_tree.root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n-                            Internal(_) => unreachable!()\n+                            Internal(_) => unreachable!(),\n                         };\n \n                         let mut in_edge = leaf.first_edge();\n@@ -171,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     }\n \n                     out_tree\n-                },\n+                }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n \n@@ -218,20 +221,22 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n     fn get(&self, key: &Q) -> Option<&K> {\n         match search::search_tree(self.root.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                    handle: handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                }.remove_kv().0)\n-            },\n-            GoDown(_) => None\n+                         handle: handle,\n+                         length: &mut self.length,\n+                         _marker: PhantomData,\n+                     }\n+                     .remove_kv()\n+                     .0)\n+            }\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -244,7 +249,8 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n                     handle: handle,\n                     length: &mut self.length,\n                     _marker: PhantomData,\n-                }.insert(());\n+                }\n+                .insert(());\n                 None\n             }\n         }\n@@ -255,22 +261,22 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: Range<'a, K, V>,\n-    length: usize\n+    length: usize,\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     range: RangeMut<'a, K, V>,\n-    length: usize\n+    length: usize,\n }\n \n /// An owning iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n     back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    length: usize\n+    length: usize,\n }\n \n /// An iterator over a BTreeMap's keys.\n@@ -294,7 +300,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// An iterator over a sub-range of BTreeMap's entries.\n pub struct Range<'a, K: 'a, V: 'a> {\n     front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>\n+    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n }\n \n /// A mutable iterator over a sub-range of BTreeMap's entries.\n@@ -311,15 +317,13 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>\n-    ),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+           VacantEntry<'a, K, V>),\n \n     /// An occupied Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>\n-    ),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             OccupiedEntry<'a, K, V>),\n }\n \n /// A vacant Entry.\n@@ -336,11 +340,7 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n /// An occupied Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    handle: Handle<NodeRef<\n-        marker::Mut<'a>,\n-        K, V,\n-        marker::LeafOrInternal\n-    >, marker::KV>,\n+    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n \n     length: &'a mut usize,\n \n@@ -349,7 +349,7 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n }\n \n // An iterator for merging two sorted sequences into one\n-struct MergeIter<K, V, I: Iterator<Item=(K, V)>> {\n+struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n     right: Peekable<I>,\n }\n@@ -373,7 +373,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn new() -> BTreeMap<K, V> {\n         BTreeMap {\n             root: node::Root::new_leaf(),\n-            length: 0\n+            length: 0,\n         }\n     }\n \n@@ -415,10 +415,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -440,7 +443,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -465,10 +471,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -528,16 +537,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                    handle: handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                }.remove())\n-            },\n-            GoDown(_) => None\n+                         handle: handle,\n+                         length: &mut self.length,\n+                         _marker: PhantomData,\n+                     }\n+                     .remove())\n+            }\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -628,47 +641,63 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                                        min: Bound<&Min>,\n                                                        max: Bound<&Max>)\n                                                        -> Range<K, V>\n-        where K: Borrow<Min> + Borrow<Max>,\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n         let front = match min {\n-            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => first_leaf_edge(self.root.as_ref())\n+            Included(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => first_leaf_edge(self.root.as_ref()),\n         };\n \n         let back = match max {\n-            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => last_leaf_edge(self.root.as_ref())\n+            Included(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => last_leaf_edge(self.root.as_ref()),\n         };\n \n         Range {\n             front: front,\n-            back: back\n+            back: back,\n         }\n     }\n \n@@ -704,51 +733,67 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                                            min: Bound<&Min>,\n                                                            max: Bound<&Max>)\n                                                            -> RangeMut<K, V>\n-        where K: Borrow<Min> + Borrow<Max>,\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n \n         let front = match min {\n-            Included(key) => match search::search_tree(root1, key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(root1, key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => first_leaf_edge(root1)\n+            Included(key) => {\n+                match search::search_tree(root1, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(root1, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => first_leaf_edge(root1),\n         };\n \n         let back = match max {\n-            Included(key) => match search::search_tree(root2, key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(root2, key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => last_leaf_edge(root2)\n+            Included(key) => {\n+                match search::search_tree(root2, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(root2, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => last_leaf_edge(root2),\n         };\n \n         RangeMut {\n             front: front,\n             back: back,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -773,21 +818,25 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         match search::search_tree(self.root.as_mut(), &key) {\n-            Found(handle) => Occupied(OccupiedEntry {\n-                handle: handle,\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            }),\n-            GoDown(handle) => Vacant(VacantEntry {\n-                key: key,\n-                handle: handle,\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n+            Found(handle) => {\n+                Occupied(OccupiedEntry {\n+                    handle: handle,\n+                    length: &mut self.length,\n+                    _marker: PhantomData,\n+                })\n+            }\n+            GoDown(handle) => {\n+                Vacant(VacantEntry {\n+                    key: key,\n+                    handle: handle,\n+                    length: &mut self.length,\n+                    _marker: PhantomData,\n+                })\n+            }\n         }\n     }\n \n-    fn from_sorted_iter<I: Iterator<Item=(K, V)>>(&mut self, iter: I) {\n+    fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n@@ -810,12 +859,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 // Go up again.\n                                 test_node = parent.forget_type();\n                             }\n-                        },\n+                        }\n                         Err(node) => {\n                             // We are at the top, create a new root node and push there.\n                             open_node = node.into_root_mut().push_level();\n                             break;\n-                        },\n+                        }\n                     }\n                 }\n \n@@ -890,7 +939,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_split_off\",\n                reason = \"recently added as part of collections reform 2\",\n                issue = \"19986\")]\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where K: Borrow<Q> {\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n+        where K: Borrow<Q>\n+    {\n         if self.is_empty() {\n             return Self::new();\n         }\n@@ -910,7 +961,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let mut split_edge = match search::search_node(left_node, key) {\n                     // key is going to the right tree\n                     Found(handle) => handle.left_edge(),\n-                    GoDown(handle) => handle\n+                    GoDown(handle) => handle,\n                 };\n \n                 split_edge.move_suffix(&mut right_node);\n@@ -920,8 +971,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                         left_node = edge.descend();\n                         right_node = node.first_edge().descend();\n                     }\n-                    (Leaf(_), Leaf(_)) => { break; },\n-                    _ => { unreachable!(); }\n+                    (Leaf(_), Leaf(_)) => {\n+                        break;\n+                    }\n+                    _ => {\n+                        unreachable!();\n+                    }\n                 }\n             }\n         }\n@@ -950,8 +1005,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 loop {\n                     res += dfs(edge.reborrow().descend());\n                     match edge.right_kv() {\n-                        Ok(right_kv) => { edge = right_kv.right_edge(); },\n-                        Err(_) => { break; }\n+                        Ok(right_kv) => {\n+                            edge = right_kv.right_edge();\n+                        }\n+                        Err(_) => {\n+                            break;\n+                        }\n                     }\n                 }\n             }\n@@ -1064,14 +1123,16 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> ExactSizeIterator for Iter<'a, K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             range: self.range.clone(),\n-            length: self.length\n+            length: self.length,\n         }\n     }\n }\n@@ -1114,7 +1175,9 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<K, V> IntoIterator for BTreeMap<K, V> {\n@@ -1130,14 +1193,15 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         IntoIter {\n             front: first_leaf_edge(root1),\n             back: last_leaf_edge(root2),\n-            length: len\n+            length: len,\n         }\n     }\n }\n \n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        for _ in &mut *self { }\n+        for _ in &mut *self {\n+        }\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n@@ -1168,10 +1232,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n                 let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                 self.front = kv.right_edge();\n                 return Some((k, v));\n-            },\n+            }\n             Err(last_edge) => unsafe {\n                 unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            }\n+            },\n         };\n \n         loop {\n@@ -1181,10 +1245,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n                     let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return Some((k, v));\n-                },\n+                }\n                 Err(last_edge) => unsafe {\n                     cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                }\n+                },\n             }\n         }\n     }\n@@ -1210,10 +1274,10 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n                 let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                 self.back = kv.left_edge();\n                 return Some((k, v));\n-            },\n+            }\n             Err(last_edge) => unsafe {\n                 unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            }\n+            },\n         };\n \n         loop {\n@@ -1223,17 +1287,19 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n                     let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return Some((k, v));\n-                },\n+                }\n                 Err(last_edge) => unsafe {\n                     cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                }\n+                },\n             }\n         }\n     }\n }\n \n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n@@ -1262,9 +1328,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n \n impl<'a, K, V> Clone for Keys<'a, K, V> {\n     fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n+        Keys { inner: self.inner.clone() }\n     }\n }\n \n@@ -1294,9 +1358,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n \n impl<'a, K, V> Clone for Values<'a, K, V> {\n     fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n+        Values { inner: self.inner.clone() }\n     }\n }\n \n@@ -1348,7 +1410,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                 let ret = kv.into_kv();\n                 self.front = kv.right_edge();\n                 return ret;\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1361,7 +1423,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                     let ret = kv.into_kv();\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return ret;\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1390,7 +1452,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                 let ret = kv.into_kv();\n                 self.back = kv.left_edge();\n                 return ret;\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1403,7 +1465,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                     let ret = kv.into_kv();\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return ret;\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1417,7 +1479,7 @@ impl<'a, K, V> Clone for Range<'a, K, V> {\n     fn clone(&self) -> Range<'a, K, V> {\n         Range {\n             front: self.front,\n-            back: self.back\n+            back: self.back,\n         }\n     }\n }\n@@ -1429,7 +1491,7 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n         if self.front == self.back {\n             None\n         } else {\n-            unsafe { Some (self.next_unchecked()) }\n+            unsafe { Some(self.next_unchecked()) }\n         }\n     }\n }\n@@ -1443,7 +1505,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                 let (k, v) = ptr::read(&kv).into_kv_mut();\n                 self.front = kv.right_edge();\n                 return (k, v);\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1456,7 +1518,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     let (k, v) = ptr::read(&kv).into_kv_mut();\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return (k, v);\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1485,7 +1547,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                 let (k, v) = ptr::read(&kv).into_kv_mut();\n                 self.back = kv.left_edge();\n                 return (k, v);\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1498,7 +1560,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     let (k, v) = ptr::read(&kv).into_kv_mut();\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return (k, v);\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1509,7 +1571,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n }\n \n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -1518,15 +1580,15 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n \n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n-    fn extend<I: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -1547,8 +1609,7 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n \n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a == b)\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n@@ -1575,7 +1636,8 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n }\n \n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n+    where K: Borrow<Q>,\n+          Q: Ord\n {\n     type Output = V;\n \n@@ -1585,11 +1647,9 @@ impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>(\n-        mut node: NodeRef<BorrowType,\n-                          K, V,\n-                          marker::LeafOrInternal>\n-        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn first_leaf_edge<BorrowType, K, V>\n+    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n+     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.first_edge(),\n@@ -1600,11 +1660,9 @@ fn first_leaf_edge<BorrowType, K, V>(\n     }\n }\n \n-fn last_leaf_edge<BorrowType, K, V>(\n-        mut node: NodeRef<BorrowType,\n-                          K, V,\n-                          marker::LeafOrInternal>\n-        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn last_leaf_edge<BorrowType, K, V>\n+    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n+     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.last_edge(),\n@@ -1653,9 +1711,9 @@ impl<K, V> BTreeMap<K, V> {\n         Iter {\n             range: Range {\n                 front: first_leaf_edge(self.root.as_ref()),\n-                back: last_leaf_edge(self.root.as_ref())\n+                back: last_leaf_edge(self.root.as_ref()),\n             },\n-            length: self.length\n+            length: self.length,\n         }\n     }\n \n@@ -1690,7 +1748,7 @@ impl<K, V> BTreeMap<K, V> {\n                 back: last_leaf_edge(root2),\n                 _marker: PhantomData,\n             },\n-            length: self.length\n+            length: self.length,\n         }\n     }\n \n@@ -1865,15 +1923,17 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n         loop {\n             match cur_parent {\n-                Ok(parent) => match parent.insert(ins_k, ins_v, ins_edge) {\n-                    Fit(_) => return unsafe { &mut *out_ptr },\n-                    Split(left, k, v, right) => {\n-                        ins_k = k;\n-                        ins_v = v;\n-                        ins_edge = right;\n-                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n+                Ok(parent) => {\n+                    match parent.insert(ins_k, ins_v, ins_edge) {\n+                        Fit(_) => return unsafe { &mut *out_ptr },\n+                        Split(left, k, v, right) => {\n+                            ins_k = k;\n+                            ins_v = v;\n+                            ins_edge = right;\n+                            cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n+                        }\n                     }\n-                },\n+                }\n                 Err(root) => {\n                     root.push_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n@@ -1928,7 +1988,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n                 (hole.into_node(), old_key, old_val)\n-            },\n+            }\n             Internal(mut internal) => {\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n@@ -1938,12 +1998,8 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n                 let (hole, key, val) = to_remove.remove();\n \n-                let old_key = unsafe {\n-                    mem::replace(&mut *key_loc, key)\n-                };\n-                let old_val = unsafe {\n-                    mem::replace(&mut *val_loc, val)\n-                };\n+                let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n                 (hole.into_node(), old_key, old_val)\n             }\n@@ -1955,14 +2011,16 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n                 EmptyParent(_) => unreachable!(),\n-                Merged(parent) => if parent.len() == 0 {\n-                    // We must be at the root\n-                    parent.into_root_mut().pop_level();\n-                    break;\n-                } else {\n-                    cur_node = parent.forget_type();\n-                },\n-                Stole(_) => break\n+                Merged(parent) => {\n+                    if parent.len() == 0 {\n+                        // We must be at the root\n+                        parent.into_root_mut().pop_level();\n+                        break;\n+                    } else {\n+                        cur_node = parent.forget_type();\n+                    }\n+                }\n+                Stole(_) => break,\n             }\n         }\n \n@@ -1974,13 +2032,11 @@ enum UnderflowResult<'a, K, V> {\n     AtRoot,\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>)\n+    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n }\n \n-fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n-                                                 K, V,\n-                                                 marker::LeafOrInternal>)\n-                                                 -> UnderflowResult<'a, K, V> {\n+fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>)\n+                                   -> UnderflowResult<'a, K, V> {\n     let parent = if let Ok(parent) = node.ascend() {\n         parent\n     } else {\n@@ -1989,10 +2045,12 @@ fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => match parent.right_kv() {\n-            Ok(right) => (false, right),\n-            Err(parent) => {\n-                return EmptyParent(parent.into_node());\n+        Err(parent) => {\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(parent) => {\n+                    return EmptyParent(parent.into_node());\n+                }\n             }\n         }\n     };\n@@ -2009,7 +2067,7 @@ fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n     }\n }\n \n-impl<K: Ord, V, I: Iterator<Item=(K, V)>> Iterator for MergeIter<K, V, I> {\n+impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n@@ -2023,16 +2081,12 @@ impl<K: Ord, V, I: Iterator<Item=(K, V)>> Iterator for MergeIter<K, V, I> {\n         // Check which elements comes first and only advance the corresponding iterator.\n         // If two keys are equal, take the value from `right`.\n         match res {\n-            Ordering::Less => {\n-                self.left.next()\n-            },\n-            Ordering::Greater => {\n-                self.right.next()\n-            },\n+            Ordering::Less => self.left.next(),\n+            Ordering::Greater => self.right.next(),\n             Ordering::Equal => {\n                 self.left.next();\n                 self.right.next()\n-            },\n+            }\n         }\n     }\n }"}, {"sha": "49304b1f3bfa17d23e632189bfbf942419658292", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -85,7 +85,7 @@ use marker::{Reflect, Sized};\n \n /// A type to emulate dynamic typing.\n ///\n-/// Every type with no non-`'static` references implements `Any`.\n+/// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n /// See the [module-level documentation][mod] for more details.\n ///\n /// [mod]: index.html"}, {"sha": "63913f2878c20f07b0dc7d6e4fe720260e0cc747", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -31,7 +31,7 @@\n \n extern crate libc;\n \n-use libc::{c_void, size_t, c_int};\n+use libc::{c_int, c_void, size_t};\n use std::fmt;\n use std::ops::Deref;\n use std::ptr::Unique;\n@@ -76,9 +76,9 @@ impl Drop for Bytes {\n \n #[link(name = \"miniz\", kind = \"static\")]\n #[cfg(not(cargobuild))]\n-extern {}\n+extern \"C\" {}\n \n-extern {\n+extern \"C\" {\n     /// Raw miniz compression function.\n     fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                   src_buf_len: size_t,\n@@ -154,8 +154,8 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes, Error> {\n #[cfg(test)]\n mod tests {\n     #![allow(deprecated)]\n-    use super::{inflate_bytes, deflate_bytes};\n-    use std::__rand::{thread_rng, Rng};\n+    use super::{deflate_bytes, inflate_bytes};\n+    use std::__rand::{Rng, thread_rng};\n \n     #[test]\n     fn test_flate_round_trip() {"}, {"sha": "afc2e04d446a1140b4724f3192cfb6f0e21dbde5", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -291,8 +291,8 @@ macro_rules! bitflags {\n #[cfg(test)]\n #[allow(non_upper_case_globals)]\n mod tests {\n-    use std::hash::{Hasher, Hash, SipHasher};\n-    use std::option::Option::{Some, None};\n+    use std::hash::{Hash, Hasher, SipHasher};\n+    use std::option::Option::{None, Some};\n \n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]"}, {"sha": "c0cca08b6760282445e255309108c8ca33d61616", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -1174,7 +1174,7 @@ Erroneous code example:\n \n ```compile_fail\n #[repr(i32)]\n-enum NightWatch {} // error: unsupported representation for zero-variant enum\n+enum NightsWatch {} // error: unsupported representation for zero-variant enum\n ```\n \n It is impossible to define an integer type to be used to represent zero-variant\n@@ -1184,16 +1184,16 @@ two solutions. Either you add variants in your enum:\n \n ```\n #[repr(i32)]\n-enum NightWatch {\n-    JohnSnow,\n+enum NightsWatch {\n+    JonSnow,\n     Commander,\n }\n ```\n \n or you remove the integer represention of your enum:\n \n ```\n-enum NightWatch {}\n+enum NightsWatch {}\n ```\n \"##,\n "}, {"sha": "f570375de5ea156ed8828fc75d78880b7031dfb0", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -668,10 +668,13 @@ impl char {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// assert_eq!('C'.to_lowercase().next(), Some('c'));\n+    /// assert_eq!('C'.to_lowercase().collect::<String>(), \"c\");\n+    ///\n+    /// // Sometimes the result is more than one character:\n+    /// assert_eq!('\u0130'.to_lowercase().collect::<String>(), \"i\\u{307}\");\n     ///\n     /// // Japanese scripts do not have case, and so:\n-    /// assert_eq!('\u5c71'.to_lowercase().next(), Some('\u5c71'));\n+    /// assert_eq!('\u5c71'.to_lowercase().collect::<String>(), \"\u5c71\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -702,10 +705,13 @@ impl char {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// assert_eq!('c'.to_uppercase().next(), Some('C'));\n+    /// assert_eq!('c'.to_uppercase().collect::<String>(), \"C\");\n+    ///\n+    /// // Sometimes the result is more than one character:\n+    /// assert_eq!('\u00df'.to_uppercase().collect::<String>(), \"SS\");\n     ///\n     /// // Japanese does not have case, and so:\n-    /// assert_eq!('\u5c71'.to_uppercase().next(), Some('\u5c71'));\n+    /// assert_eq!('\u5c71'.to_uppercase().collect::<String>(), \"\u5c71\");\n     /// ```\n     ///\n     /// In Turkish, the equivalent of 'i' in Latin has five forms instead of two:\n@@ -716,17 +722,17 @@ impl char {\n     /// Note that the lowercase dotted 'i' is the same as the Latin. Therefore:\n     ///\n     /// ```\n-    /// let upper_i = 'i'.to_uppercase().next();\n+    /// let upper_i: String = 'i'.to_uppercase().collect();\n     /// ```\n     ///\n     /// The value of `upper_i` here relies on the language of the text: if we're\n-    /// in `en-US`, it should be `Some('I')`, but if we're in `tr_TR`, it should\n-    /// be `Some('\u0130')`. `to_uppercase()` does not take this into account, and so:\n+    /// in `en-US`, it should be `\"I\"`, but if we're in `tr_TR`, it should\n+    /// be `\"\u0130\"`. `to_uppercase()` does not take this into account, and so:\n     ///\n     /// ```\n-    /// let upper_i = 'i'.to_uppercase().next();\n+    /// let upper_i: String = 'i'.to_uppercase().collect();\n     ///\n-    /// assert_eq!(Some('I'), upper_i);\n+    /// assert_eq!(upper_i, \"I\");\n     /// ```\n     ///\n     /// holds across languages."}, {"sha": "96ddda32ae456f33ba3ba8eae1fabd0e047445b8", "filename": "src/libstd/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -182,8 +182,10 @@ impl FromInner<AnonPipe> for ChildStderr {\n     }\n }\n \n-/// The `Command` type acts as a process builder, providing fine-grained control\n-/// over how a new process should be spawned. A default configuration can be\n+/// A process builder, providing fine-grained control\n+/// over how a new process should be spawned.\n+///\n+/// A default configuration can be\n /// generated using `Command::new(program)`, where `program` gives a path to the\n /// program to be executed. Additional builder methods allow the configuration\n /// to be changed (for example, by adding arguments) prior to spawning:"}, {"sha": "849c9aa18c905a2ca39d4f44c8aca1537943e894", "filename": "src/test/compile-fail/issue-25579.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a267d6cee40c2f2fa3db999afbb2bd1384f7840a/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs?ref=a267d6cee40c2f2fa3db999afbb2bd1384f7840a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Sexpression {\n+    Num(()),\n+    Cons(&'static mut Sexpression)\n+}\n+\n+fn causes_ice(mut l: &mut Sexpression) {\n+    loop { match l {\n+        &mut Sexpression::Num(ref mut n) => {},\n+        &mut Sexpression::Cons(ref mut expr) => { //~ ERROR cannot borrow `l.0`\n+            //~| ERROR cannot borrow `l.0`\n+            l = &mut **expr; //~ ERROR cannot assign to `l`\n+        }\n+    }}\n+}\n+\n+fn main() {\n+}"}]}