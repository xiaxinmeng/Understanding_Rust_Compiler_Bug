{"sha": "36618489975d223e307b9510c8593aebd74ecf23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NjE4NDg5OTc1ZDIyM2UzMDdiOTUxMGM4NTkzYWViZDc0ZWNmMjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-27T16:20:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-27T16:20:47Z"}, "message": "Auto merge of #6375 - camsteffen:reassign-default-private, r=flip1995\n\nReassign default private\n\nchangelog: fix field_reassign_with_default false positive\n\n* Fix #6344\n* Fix assumption that `field: Default::default()` is the same as `..Default::default()`\n* Cleanup some redundant logic", "tree": {"sha": "073eb86a4a69f99e264bb742255ed0263f3258c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073eb86a4a69f99e264bb742255ed0263f3258c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36618489975d223e307b9510c8593aebd74ecf23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36618489975d223e307b9510c8593aebd74ecf23", "html_url": "https://github.com/rust-lang/rust/commit/36618489975d223e307b9510c8593aebd74ecf23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36618489975d223e307b9510c8593aebd74ecf23/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "015496579dae282a7215a6ad17fe053342d8b825", "url": "https://api.github.com/repos/rust-lang/rust/commits/015496579dae282a7215a6ad17fe053342d8b825", "html_url": "https://github.com/rust-lang/rust/commit/015496579dae282a7215a6ad17fe053342d8b825"}, {"sha": "c6450c70ddb5354bc2218bff20a325ded9682613", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6450c70ddb5354bc2218bff20a325ded9682613", "html_url": "https://github.com/rust-lang/rust/commit/c6450c70ddb5354bc2218bff20a325ded9682613"}], "stats": {"total": 204, "additions": 85, "deletions": 119}, "files": [{"sha": "b0d7c7b3baab1b71fa6d0b82090b08aadc9c37c0", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 71, "deletions": 117, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/36618489975d223e307b9510c8593aebd74ecf23/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36618489975d223e307b9510c8593aebd74ecf23/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=36618489975d223e307b9510c8593aebd74ecf23", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Adt, Ty};\n+use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -103,34 +103,50 @@ impl LateLintPass<'_> for Default {\n     }\n \n     fn check_block<'tcx>(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n-        // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n-        // `default` method of the `Default` trait, and store statement index in current block being\n-        // checked and the name of the bound variable\n-        let binding_statements_using_default = enumerate_bindings_using_default(cx, block);\n-\n         // start from the `let mut _ = _::default();` and look at all the following\n         // statements, see if they re-assign the fields of the binding\n-        for (stmt_idx, binding_name, binding_type, span) in binding_statements_using_default {\n-            // the last statement of a block cannot trigger the lint\n-            if stmt_idx == block.stmts.len() - 1 {\n-                break;\n-            }\n+        let stmts_head = match block.stmts {\n+            // Skip the last statement since there cannot possibly be any following statements that re-assign fields.\n+            [head @ .., _] if !head.is_empty() => head,\n+            _ => return,\n+        };\n+        for (stmt_idx, stmt) in stmts_head.iter().enumerate() {\n+            // find all binding statements like `let mut _ = T::default()` where `T::default()` is the\n+            // `default` method of the `Default` trait, and store statement index in current block being\n+            // checked and the name of the bound variable\n+            let (local, variant, binding_name, binding_type, span) = if_chain! {\n+                // only take `let ...` statements\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let Some(expr) = local.init;\n+                // only take bindings to identifiers\n+                if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n+                // only when assigning `... = Default::default()`\n+                if is_expr_default(expr, cx);\n+                let binding_type = cx.typeck_results().node_type(binding_id);\n+                if let Some(adt) = binding_type.ty_adt_def();\n+                if adt.is_struct();\n+                let variant = adt.non_enum_variant();\n+                if adt.did.is_local() || !variant.is_field_list_non_exhaustive();\n+                let module_did = cx.tcx.parent_module(stmt.hir_id).to_def_id();\n+                if variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| field.vis.is_accessible_from(module_did, cx.tcx));\n+                then {\n+                    (local, variant, ident.name, binding_type, expr.span)\n+                } else {\n+                    continue;\n+                }\n+            };\n \n             // find all \"later statement\"'s where the fields of the binding set as\n             // Default::default() get reassigned, unless the reassignment refers to the original binding\n             let mut first_assign = None;\n             let mut assigned_fields = Vec::new();\n             let mut cancel_lint = false;\n             for consecutive_statement in &block.stmts[stmt_idx + 1..] {\n-                // interrupt if the statement is a let binding (`Local`) that shadows the original\n-                // binding\n-                if stmt_shadows_binding(consecutive_statement, binding_name) {\n-                    break;\n-                }\n                 // find out if and which field was set by this `consecutive_statement`\n-                else if let Some((field_ident, assign_rhs)) =\n-                    field_reassigned_by_stmt(consecutive_statement, binding_name)\n-                {\n+                if let Some((field_ident, assign_rhs)) = field_reassigned_by_stmt(consecutive_statement, binding_name) {\n                     // interrupt and cancel lint if assign_rhs references the original binding\n                     if contains_name(binding_name, assign_rhs) {\n                         cancel_lint = true;\n@@ -152,7 +168,7 @@ impl LateLintPass<'_> for Default {\n                         first_assign = Some(consecutive_statement);\n                     }\n                 }\n-                // interrupt also if no field was assigned, since we only want to look at consecutive statements\n+                // interrupt if no field was assigned, since we only want to look at consecutive statements\n                 else {\n                     break;\n                 }\n@@ -161,55 +177,45 @@ impl LateLintPass<'_> for Default {\n             // if there are incorrectly assigned fields, do a span_lint_and_note to suggest\n             // construction using `Ty { fields, ..Default::default() }`\n             if !assigned_fields.is_empty() && !cancel_lint {\n-                // take the original assignment as span\n-                let stmt = &block.stmts[stmt_idx];\n-\n-                if let StmtKind::Local(preceding_local) = &stmt.kind {\n-                    // filter out fields like `= Default::default()`, because the FRU already covers them\n-                    let assigned_fields = assigned_fields\n-                        .into_iter()\n-                        .filter(|(_, rhs)| !is_expr_default(rhs, cx))\n-                        .collect::<Vec<(Symbol, &Expr<'_>)>>();\n+                // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n+                let ext_with_default = !variant\n+                    .fields\n+                    .iter()\n+                    .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.ident.name));\n \n-                    // if all fields of the struct are not assigned, add `.. Default::default()` to the suggestion.\n-                    let ext_with_default = !fields_of_type(binding_type)\n-                        .iter()\n-                        .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.name));\n+                let field_list = assigned_fields\n+                    .into_iter()\n+                    .map(|(field, rhs)| {\n+                        // extract and store the assigned value for help message\n+                        let value_snippet = snippet(cx, rhs.span, \"..\");\n+                        format!(\"{}: {}\", field, value_snippet)\n+                    })\n+                    .collect::<Vec<String>>()\n+                    .join(\", \");\n \n-                    let field_list = assigned_fields\n-                        .into_iter()\n-                        .map(|(field, rhs)| {\n-                            // extract and store the assigned value for help message\n-                            let value_snippet = snippet(cx, rhs.span, \"..\");\n-                            format!(\"{}: {}\", field, value_snippet)\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-\n-                    let sugg = if ext_with_default {\n-                        if field_list.is_empty() {\n-                            format!(\"{}::default()\", binding_type)\n-                        } else {\n-                            format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n-                        }\n+                let sugg = if ext_with_default {\n+                    if field_list.is_empty() {\n+                        format!(\"{}::default()\", binding_type)\n                     } else {\n-                        format!(\"{} {{ {} }}\", binding_type, field_list)\n-                    };\n+                        format!(\"{} {{ {}, ..Default::default() }}\", binding_type, field_list)\n+                    }\n+                } else {\n+                    format!(\"{} {{ {} }}\", binding_type, field_list)\n+                };\n \n-                    // span lint once per statement that binds default\n-                    span_lint_and_note(\n-                        cx,\n-                        FIELD_REASSIGN_WITH_DEFAULT,\n-                        first_assign.unwrap().span,\n-                        \"field assignment outside of initializer for an instance created with Default::default()\",\n-                        Some(preceding_local.span),\n-                        &format!(\n-                            \"consider initializing the variable with `{}` and removing relevant reassignments\",\n-                            sugg\n-                        ),\n-                    );\n-                    self.reassigned_linted.insert(span);\n-                }\n+                // span lint once per statement that binds default\n+                span_lint_and_note(\n+                    cx,\n+                    FIELD_REASSIGN_WITH_DEFAULT,\n+                    first_assign.unwrap().span,\n+                    \"field assignment outside of initializer for an instance created with Default::default()\",\n+                    Some(local.span),\n+                    &format!(\n+                        \"consider initializing the variable with `{}` and removing relevant reassignments\",\n+                        sugg\n+                    ),\n+                );\n+                self.reassigned_linted.insert(span);\n             }\n         }\n     }\n@@ -230,47 +236,6 @@ fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool\n     }\n }\n \n-/// Returns the block indices, identifiers and types of bindings set as `Default::default()`, except\n-/// for when the pattern type is a tuple.\n-fn enumerate_bindings_using_default<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    block: &Block<'tcx>,\n-) -> Vec<(usize, Symbol, Ty<'tcx>, Span)> {\n-    block\n-        .stmts\n-        .iter()\n-        .enumerate()\n-        .filter_map(|(idx, stmt)| {\n-            if_chain! {\n-                // only take `let ...` statements\n-                if let StmtKind::Local(ref local) = stmt.kind;\n-                // only take bindings to identifiers\n-                if let PatKind::Binding(_, _, ident, _) = local.pat.kind;\n-                // that are not tuples\n-                let ty = cx.typeck_results().pat_ty(local.pat);\n-                if !matches!(ty.kind(), ty::Tuple(_));\n-                // only when assigning `... = Default::default()`\n-                if let Some(ref expr) = local.init;\n-                if is_expr_default(expr, cx);\n-                then {\n-                    Some((idx, ident.name, ty, expr.span))\n-                } else {\n-                    None\n-                }\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn stmt_shadows_binding(this: &Stmt<'_>, shadowed: Symbol) -> bool {\n-    if let StmtKind::Local(local) = &this.kind {\n-        if let PatKind::Binding(_, _, ident, _) = local.pat.kind {\n-            return ident.name == shadowed;\n-        }\n-    }\n-    false\n-}\n-\n /// Returns the reassigned field and the assigning expression (right-hand side of assign).\n fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n     if_chain! {\n@@ -290,14 +255,3 @@ fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Op\n         }\n     }\n }\n-\n-/// Returns the vec of fields for a struct and an empty vec for non-struct ADTs.\n-fn fields_of_type(ty: Ty<'_>) -> Vec<Ident> {\n-    if let Adt(adt, _) = ty.kind() {\n-        if adt.is_struct() {\n-            let variant = &adt.non_enum_variant();\n-            return variant.fields.iter().map(|f| f.ident).collect();\n-        }\n-    }\n-    vec![]\n-}"}, {"sha": "3e0921022b4174cf4faa22bae70d821a0055dfc6", "filename": "tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36618489975d223e307b9510c8593aebd74ecf23/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36618489975d223e307b9510c8593aebd74ecf23/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=36618489975d223e307b9510c8593aebd74ecf23", "patch": "@@ -107,4 +107,16 @@ fn main() {\n     x.i = side_effect.next();\n     x.j = 2;\n     x.i = side_effect.next();\n+\n+    // don't lint - some private fields\n+    let mut x = m::F::default();\n+    x.a = 1;\n+}\n+\n+mod m {\n+    #[derive(Default)]\n+    pub struct F {\n+        pub a: u64,\n+        b: u64,\n+    }\n }"}, {"sha": "9a2bc778c3ff7ba5e03faccf7d69eda2e3f61d3a", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36618489975d223e307b9510c8593aebd74ecf23/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36618489975d223e307b9510c8593aebd74ecf23/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=36618489975d223e307b9510c8593aebd74ecf23", "patch": "@@ -53,7 +53,7 @@ error: field assignment outside of initializer for an instance created with Defa\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A::default()` and removing relevant reassignments\n+note: consider initializing the variable with `A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n   --> $DIR/field_reassign_with_default.rs:90:5\n    |\n LL |     let mut a: A = Default::default();\n@@ -65,7 +65,7 @@ error: field assignment outside of initializer for an instance created with Defa\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: consider initializing the variable with `A { j: 45, ..Default::default() }` and removing relevant reassignments\n+note: consider initializing the variable with `A { i: Default::default(), j: 45 }` and removing relevant reassignments\n   --> $DIR/field_reassign_with_default.rs:94:5\n    |\n LL |     let mut a: A = Default::default();"}]}