{"sha": "df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMTk4OTViYTZlODQyOWQ3ZmZhZTAzZTk1Yzc4N2ZkMmQyYmQ2Zjg=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-12T09:50:01Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-12T09:50:01Z"}, "message": "implement feedback from review", "tree": {"sha": "a6a0a240a59c928e836066f964b9694c84c6db2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6a0a240a59c928e836066f964b9694c84c6db2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "html_url": "https://github.com/rust-lang/rust/commit/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed24029c1312c24942dc8003b05bb5a957f532b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed24029c1312c24942dc8003b05bb5a957f532b", "html_url": "https://github.com/rust-lang/rust/commit/8ed24029c1312c24942dc8003b05bb5a957f532b"}], "stats": {"total": 66, "additions": 24, "deletions": 42}, "files": [{"sha": "5916e5676e898590da07b10d8095e8e8f880c0d5", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df19895ba6e8429d7ffae03e95c787fd2d2bd6f8/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=df19895ba6e8429d7ffae03e95c787fd2d2bd6f8", "patch": "@@ -38,10 +38,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let list = enum_.variant_list()?;\n             let mut arms = vec![];\n             for variant in list.variants() {\n-                let name = variant.name()?;\n-                let left = make::ext::ident_path(\"Self\");\n-                let right = make::ext::ident_path(&format!(\"{}\", name));\n-                let variant_name = make::path_concat(left, right);\n+                let variant_name = make_variant_path(&variant)?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -151,9 +148,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let left = make::ext::ident_path(\"Self\");\n-                let right = make::ext::ident_path(&format!(\"{}\", name));\n-                let variant_name = make::path_pat(make::path_concat(left, right));\n+                let variant_name = make::path_pat(make::path_from_text(&format!(\"Self::{}\", name)));\n \n                 let target = make::expr_path(make::ext::ident_path(\"f\").into());\n                 let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n@@ -226,10 +221,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n /// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     fn gen_default_call() -> ast::Expr {\n-        let trait_name = make::ext::ident_path(\"Default\");\n-        let method_name = make::ext::ident_path(\"default\");\n-        let fn_name = make::expr_path(make::path_concat(trait_name, method_name));\n-        make::expr_call(fn_name, make::arg_list(None))\n+        let fn_name = make::path_from_text(&\"Default::default\");\n+        make::expr_call(make::expr_path(fn_name), make::arg_list(None))\n     }\n     match adt {\n         // `Debug` cannot be derived for unions, so no default impl can be provided.\n@@ -283,11 +276,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n         // => std::mem::discriminant(self).hash(state);\n         ast::Adt::Enum(_) => {\n-            let root = make::ext::ident_path(\"core\");\n-            let submodule = make::ext::ident_path(\"mem\");\n-            let fn_name = make::ext::ident_path(\"discriminant\");\n-            let fn_name = make::path_concat(submodule, fn_name);\n-            let fn_name = make::expr_path(make::path_concat(root, fn_name));\n+            let fn_name = make_discriminant();\n \n             let arg = make::expr_path(make::ext::ident_path(\"self\"));\n             let fn_call = make::expr_call(fn_name, make::arg_list(Some(arg)));\n@@ -329,14 +318,6 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n /// Generate a `PartialEq` impl based on the fields and members of the target type.\n fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    fn gen_discriminant() -> ast::Expr {\n-        let root = make::ext::ident_path(\"core\");\n-        let submodule = make::ext::ident_path(\"mem\");\n-        let fn_name = make::ext::ident_path(\"discriminant\");\n-        let fn_name = make::path_concat(submodule, fn_name);\n-        make::expr_path(make::path_concat(root, fn_name))\n-    }\n-\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n             Some(expr) => Some(make::expr_op(ast::BinOp::BooleanAnd, expr, cmp)),\n@@ -355,13 +336,6 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::record_pat_with_fields(record_name, list)\n     }\n \n-    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n-        let first = make::ext::ident_path(\"Self\");\n-        let second = make::path_from_text(&variant.name()?.to_string());\n-        let record_name = make::path_concat(first, second);\n-        Some(record_name)\n-    }\n-\n     fn gen_tuple_field(field_name: &String) -> ast::Pat {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n@@ -370,15 +344,15 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     // generate this code `Self` for the time being.\n \n     let body = match adt {\n-        // `Hash` cannot be derived for unions, so no default impl can be provided.\n+        // `PartialEq` cannot be derived for unions, so no default impl can be provided.\n         ast::Adt::Union(_) => return None,\n \n         ast::Adt::Enum(enum_) => {\n             // => std::mem::discriminant(self) == std::mem::discriminant(other)\n-            let self_name = make::expr_path(make::ext::ident_path(\"self\"));\n-            let lhs = make::expr_call(gen_discriminant(), make::arg_list(Some(self_name.clone())));\n-            let other_name = make::expr_path(make::ext::ident_path(\"other\"));\n-            let rhs = make::expr_call(gen_discriminant(), make::arg_list(Some(other_name.clone())));\n+            let lhs_name = make::expr_path(make::ext::ident_path(\"self\"));\n+            let lhs = make::expr_call(make_discriminant(), make::arg_list(Some(lhs_name.clone())));\n+            let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n+            let rhs = make::expr_call(make_discriminant(), make::arg_list(Some(rhs_name.clone())));\n             let eq_check = make::expr_op(ast::BinOp::EqualityTest, lhs, rhs);\n \n             let mut case_count = 0;\n@@ -407,8 +381,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n-                        let left = gen_record_pat(gen_variant_path(&variant)?, l_fields);\n-                        let right = gen_record_pat(gen_variant_path(&variant)?, r_fields);\n+                        let left = gen_record_pat(make_variant_path(&variant)?, l_fields);\n+                        let right = gen_record_pat(make_variant_path(&variant)?, r_fields);\n                         let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n \n                         if let Some(expr) = expr {\n@@ -436,8 +410,8 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                             expr = gen_eq_chain(expr, cmp);\n                         }\n \n-                        let left = make::tuple_struct_pat(gen_variant_path(&variant)?, l_fields);\n-                        let right = make::tuple_struct_pat(gen_variant_path(&variant)?, r_fields);\n+                        let left = make::tuple_struct_pat(make_variant_path(&variant)?, l_fields);\n+                        let right = make::tuple_struct_pat(make_variant_path(&variant)?, r_fields);\n                         let tuple = make::tuple_pat(vec![left.into(), right.into()]);\n \n                         if let Some(expr) = expr {\n@@ -456,7 +430,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         arms.push(make::match_arm(Some(lhs), None, eq_check));\n                     }\n \n-                    let match_target = make::expr_tuple(vec![self_name, other_name]);\n+                    let match_target = make::expr_tuple(vec![lhs_name, rhs_name]);\n                     let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n                     make::expr_match(match_target, list)\n                 }\n@@ -492,7 +466,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to hash.\n+            // No fields in the body means there's nothing to compare.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n@@ -503,3 +477,11 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n     Some(())\n }\n+\n+fn make_discriminant() -> ast::Expr {\n+    make::expr_path(make::path_from_text(\"core::mem::discriminant\"))\n+}\n+\n+fn make_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n+    Some(make::path_from_text(&format!(\"Self::{}\", &variant.name()?)))\n+}"}]}