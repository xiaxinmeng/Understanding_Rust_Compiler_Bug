{"sha": "4e23179c85b3706e2ff78ecb0c014e42c56b096d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMjMxNzljODViMzcwNmUyZmY3OGVjYjBjMDE0ZTQyYzU2YjA5NmQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-01T11:29:46Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-03T11:10:58Z"}, "message": "Incorporated second review suggestion from eddyb.", "tree": {"sha": "767fc4b5977cf742bc9f2970d36e7167d60c649b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/767fc4b5977cf742bc9f2970d36e7167d60c649b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e23179c85b3706e2ff78ecb0c014e42c56b096d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e23179c85b3706e2ff78ecb0c014e42c56b096d", "html_url": "https://github.com/rust-lang/rust/commit/4e23179c85b3706e2ff78ecb0c014e42c56b096d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e23179c85b3706e2ff78ecb0c014e42c56b096d/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11057fee08a6de23edbb8cb188336c104b4d25f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/11057fee08a6de23edbb8cb188336c104b4d25f9", "html_url": "https://github.com/rust-lang/rust/commit/11057fee08a6de23edbb8cb188336c104b4d25f9"}], "stats": {"total": 138, "additions": 71, "deletions": 67}, "files": [{"sha": "9291f175777fa79c8be766b033cd33fcaf000fae", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4e23179c85b3706e2ff78ecb0c014e42c56b096d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e23179c85b3706e2ff78ecb0c014e42c56b096d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=4e23179c85b3706e2ff78ecb0c014e42c56b096d", "patch": "@@ -225,8 +225,10 @@ pub enum ErrKind {\n     InvalidOpForUintInt(ast::BinOp_),\n     NegateOnString,\n     NegateOnBoolean,\n+    NegateOnBinary,\n     NotOnFloat,\n     NotOnString,\n+    NotOnBinary,\n \n     AddiWithOverflow(i64, i64),\n     SubiWithOverflow(i64, i64),\n@@ -259,8 +261,10 @@ impl ConstEvalErr {\n             InvalidOpForUintInt(..) => \"can't do this op on a uint and int\".into_cow(),\n             NegateOnString => \"negate on string\".into_cow(),\n             NegateOnBoolean => \"negate on boolean\".into_cow(),\n+            NegateOnBinary => \"negate on binary literal\".into_cow(),\n             NotOnFloat => \"not on float or string\".into_cow(),\n             NotOnString => \"not on float or string\".into_cow(),\n+            NotOnBinary => \"not on binary literal\".into_cow(),\n \n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n             SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n@@ -324,45 +328,45 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n                                      ty_hint: Option<Ty<'tcx>>)\n                                      -> Result<const_val, ConstEvalErr> {\n-    fn fromb<T>(b: bool) -> Result<const_val, T> { Ok(const_int(b as i64)) }\n+    fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n-    match e.node {\n+    let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner, ety) {\n-          Ok(const_float(f)) => Ok(const_float(-f)),\n-          Ok(const_int(i)) => Ok(const_int(-i)),\n-          Ok(const_uint(i)) => Ok(const_uint(-i)),\n-          Ok(const_str(_)) => signal!(e, NegateOnString),\n-          Ok(const_bool(_)) => signal!(e, NegateOnBoolean),\n-          err => err\n+        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+          const_float(f) => const_float(-f),\n+          const_int(i) => const_int(-i),\n+          const_uint(i) => const_uint(-i),\n+          const_str(_) => signal!(e, NegateOnString),\n+          const_bool(_) => signal!(e, NegateOnBoolean),\n+          const_binary(_) => signal!(e, NegateOnBinary),\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner, ety) {\n-          Ok(const_int(i)) => Ok(const_int(!i)),\n-          Ok(const_uint(i)) => Ok(const_uint(!i)),\n-          Ok(const_bool(b)) => Ok(const_bool(!b)),\n-          Ok(const_str(_)) => signal!(e, NotOnString),\n-          Ok(const_float(_)) => signal!(e, NotOnFloat),\n-          err => err\n+        match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n+          const_int(i) => const_int(!i),\n+          const_uint(i) => const_uint(!i),\n+          const_bool(b) => const_bool(!b),\n+          const_str(_) => signal!(e, NotOnString),\n+          const_float(_) => signal!(e, NotOnFloat),\n+          const_binary(_) => signal!(e, NotOnBinary),\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n             ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n             _ => ety\n         };\n-        match (eval_const_expr_partial(tcx, &**a, ety),\n-               eval_const_expr_partial(tcx, &**b, b_ty)) {\n-          (Ok(const_float(a)), Ok(const_float(b))) => {\n+        match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n+               try!(eval_const_expr_partial(tcx, &**b, b_ty))) {\n+          (const_float(a), const_float(b)) => {\n             match op.node {\n-              ast::BiAdd => Ok(const_float(a + b)),\n-              ast::BiSub => Ok(const_float(a - b)),\n-              ast::BiMul => Ok(const_float(a * b)),\n-              ast::BiDiv => Ok(const_float(a / b)),\n-              ast::BiRem => Ok(const_float(a % b)),\n+              ast::BiAdd => const_float(a + b),\n+              ast::BiSub => const_float(a - b),\n+              ast::BiMul => const_float(a * b),\n+              ast::BiDiv => const_float(a / b),\n+              ast::BiRem => const_float(a % b),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -372,7 +376,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               _ => signal!(e, InvalidOpForFloats(op.node))\n             }\n           }\n-          (Ok(const_int(a)), Ok(const_int(b))) => {\n+          (const_int(a), const_int(b)) => {\n             let is_a_min_value = || {\n                 let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n                     Some(&ty::ty_int(int_ty)) => int_ty,\n@@ -392,16 +396,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 }\n             };\n             match op.node {\n-              ast::BiAdd => checked_add_int(e, a, b),\n-              ast::BiSub => checked_sub_int(e, a, b),\n-              ast::BiMul => checked_mul_int(e, a, b),\n+              ast::BiAdd => try!(checked_add_int(e, a, b)),\n+              ast::BiSub => try!(checked_sub_int(e, a, b)),\n+              ast::BiMul => try!(checked_mul_int(e, a, b)),\n               ast::BiDiv => {\n                   if b == 0 {\n                       signal!(e, DivideByZero);\n                   } else if b == -1 && is_a_min_value() {\n                       signal!(e, DivideWithOverflow);\n                   } else {\n-                      Ok(const_int(a / b))\n+                      const_int(a / b)\n                   }\n               }\n               ast::BiRem => {\n@@ -410,14 +414,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   } else if b == -1 && is_a_min_value() {\n                       signal!(e, ModuloWithOverflow)\n                   } else {\n-                      Ok(const_int(a % b))\n+                      const_int(a % b)\n                   }\n               }\n-              ast::BiAnd | ast::BiBitAnd => Ok(const_int(a & b)),\n-              ast::BiOr | ast::BiBitOr => Ok(const_int(a | b)),\n-              ast::BiBitXor => Ok(const_int(a ^ b)),\n-              ast::BiShl => Ok(const_int(a << b as uint)),\n-              ast::BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n+              ast::BiOr | ast::BiBitOr => const_int(a | b),\n+              ast::BiBitXor => const_int(a ^ b),\n+              ast::BiShl => const_int(a << b as uint),\n+              ast::BiShr => const_int(a >> b as uint),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -426,20 +430,20 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiGt => fromb(a > b)\n             }\n           }\n-          (Ok(const_uint(a)), Ok(const_uint(b))) => {\n+          (const_uint(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiAdd => checked_add_uint(e, a, b),\n-              ast::BiSub => checked_sub_uint(e, a, b),\n-              ast::BiMul => checked_mul_uint(e, a, b),\n+              ast::BiAdd => try!(checked_add_uint(e, a, b)),\n+              ast::BiSub => try!(checked_sub_uint(e, a, b)),\n+              ast::BiMul => try!(checked_mul_uint(e, a, b)),\n               ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n-              ast::BiDiv => Ok(const_uint(a / b)),\n+              ast::BiDiv => const_uint(a / b),\n               ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n-              ast::BiRem => Ok(const_uint(a % b)),\n-              ast::BiAnd | ast::BiBitAnd => Ok(const_uint(a & b)),\n-              ast::BiOr | ast::BiBitOr => Ok(const_uint(a | b)),\n-              ast::BiBitXor => Ok(const_uint(a ^ b)),\n-              ast::BiShl => Ok(const_uint(a << b as uint)),\n-              ast::BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiRem => const_uint(a % b),\n+              ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n+              ast::BiOr | ast::BiBitOr => const_uint(a | b),\n+              ast::BiBitXor => const_uint(a ^ b),\n+              ast::BiShl => const_uint(a << b as uint),\n+              ast::BiShr => const_uint(a >> b as uint),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -449,22 +453,22 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           // shifts can have any integral type as their rhs\n-          (Ok(const_int(a)), Ok(const_uint(b))) => {\n+          (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => Ok(const_int(a << b as uint)),\n-              ast::BiShr => Ok(const_int(a >> b as uint)),\n+              ast::BiShl => const_int(a << b as uint),\n+              ast::BiShr => const_int(a >> b as uint),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n-          (Ok(const_uint(a)), Ok(const_int(b))) => {\n+          (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => Ok(const_uint(a << b as uint)),\n-              ast::BiShr => Ok(const_uint(a >> b as uint)),\n+              ast::BiShl => const_uint(a << b as uint),\n+              ast::BiShr => const_uint(a >> b as uint),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n-          (Ok(const_bool(a)), Ok(const_bool(b))) => {\n-            Ok(const_bool(match op.node {\n+          (const_bool(a), const_bool(b)) => {\n+            const_bool(match op.node {\n               ast::BiAnd => a && b,\n               ast::BiOr => a || b,\n               ast::BiBitXor => a ^ b,\n@@ -473,10 +477,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiEq => a == b,\n               ast::BiNe => a != b,\n               _ => signal!(e, InvalidOpForBools(op.node)),\n-             }))\n+             })\n           }\n-          (err @ Err(..), _) |\n-          (_, err @ Err(..)) => err,\n \n           _ => signal!(e, MiscBinaryOp),\n         }\n@@ -494,8 +496,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         match cast_const(val, ety) {\n-            Ok(val) => Ok(val),\n-            Err(kind) => Err(ConstEvalErr { span: e.span, kind: kind }),\n+            Ok(val) => val,\n+            Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n       ast::ExprPath(..) => {\n@@ -526,24 +528,24 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               None => signal!(e, NonConstPath)\n           };\n           let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n-          eval_const_expr_partial(tcx, const_expr, ety)\n+          try!(eval_const_expr_partial(tcx, const_expr, ety))\n       }\n       ast::ExprLit(ref lit) => {\n-          Ok(lit_to_const(&**lit, ety))\n+          lit_to_const(&**lit, ety)\n       }\n-      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e, ety),\n+      ast::ExprParen(ref e) => try!(eval_const_expr_partial(tcx, &**e, ety)),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &**expr, ety),\n-            None => Ok(const_int(0i64))\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ety)),\n+            None => const_int(0i64)\n         }\n       }\n       ast::ExprTupField(ref base, index) => {\n         // Get the base tuple if it is constant\n         if let Some(&ast::ExprTup(ref fields)) = lookup_const(tcx, &**base).map(|s| &s.node) {\n             // Check that the given index is within bounds and evaluate its value\n             if fields.len() > index.node {\n-                return eval_const_expr_partial(tcx, &*fields[index.node], None)\n+                return eval_const_expr_partial(tcx, &*fields[index.node], None);\n             } else {\n                 signal!(e, TupleIndexOutOfBounds);\n             }\n@@ -558,7 +560,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             // Check that the given field exists and evaluate it\n             if let Some(f) = fields.iter().find(|f|\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n-                return eval_const_expr_partial(tcx, &*f.expr, None)\n+                return eval_const_expr_partial(tcx, &*f.expr, None);\n             } else {\n                 signal!(e, MissingStructField);\n             }\n@@ -567,7 +569,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         signal!(e, NonConstStruct);\n       }\n       _ => signal!(e, MiscCatchAll)\n-    }\n+    };\n+\n+    Ok(result)\n }\n \n fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {"}]}