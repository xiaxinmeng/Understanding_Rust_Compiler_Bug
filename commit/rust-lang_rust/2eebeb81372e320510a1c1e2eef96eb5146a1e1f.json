{"sha": "2eebeb81372e320510a1c1e2eef96eb5146a1e1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlZWJlYjgxMzcyZTMyMDUxMGExYzFlMmVlZjk2ZWI1MTQ2YTFlMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T01:06:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T01:06:47Z"}, "message": "auto merge of #12081 : cgaebel/rust/robinhood-hashing, r=alexcrichton\n\nPartially addresses #11783.\r\n\r\nPreviously, rust's hashtable was totally unoptimized. It used an Option\r\nper key-value pair, and used very naive open allocation.\r\n\r\nThe old hashtable had very high variance in lookup time. For an example,\r\nsee the 'find_nonexisting' benchmark below. This is fixed by keys in\r\n'lucky' spots with a low probe sequence length getting their good spots\r\nstolen by keys with long probe sequence lengths. This reduces hashtable\r\nprobe length variance, while maintaining the same mean.\r\n\r\nAlso, other optimization liberties were taken. Everything is as cache\r\naware as possible, and this hashtable should perform extremely well for\r\nboth large and small keys and values.\r\n\r\nBenchmarks:\r\n\r\n```\r\ncomprehensive_old_hashmap         378 ns/iter (+/- 8)\r\ncomprehensive_new_hashmap         206 ns/iter (+/- 4)\r\n1.8x faster\r\n\r\nold_hashmap_as_queue              238 ns/iter (+/- 8)\r\nnew_hashmap_as_queue              119 ns/iter (+/- 2)\r\n2x faster\r\n\r\nold_hashmap_insert                172 ns/iter (+/- 8)\r\nnew_hashmap_insert                146 ns/iter (+/- 11)\r\n1.17x faster\r\n\r\nold_hashmap_find_existing         50 ns/iter (+/- 12)\r\nnew_hashmap_find_existing         35 ns/iter (+/- 6)\r\n1.43x faster\r\n\r\nold_hashmap_find_notexisting      49 ns/iter (+/- 49)\r\nnew_hashmap_find_notexisting      34 ns/iter (+/- 4)\r\n1.44x faster\r\n\r\nMemory usage of old hashtable (64-bit assumed):\r\n\r\naligned(8+sizeof(Option)+sizeof(K)+sizeof(V))/0.75 + 48ish bytes\r\n\r\nMemory usage of new hashtable:\r\n\r\n(aligned(sizeof(K))\r\n+ aligned(sizeof(V))\r\n+ 8)/0.9 + 112ish bytes\r\n\r\nTiming of building librustc:\r\n\r\ncompile_and_link: x86_64-unknown-linux-gnu/stage0/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustc\r\ntime: 0.457 s   parsing\r\ntime: 0.028 s   gated feature checking\r\ntime: 0.000 s   crate injection\r\ntime: 0.108 s   configuration 1\r\ntime: 1.049 s   expansion\r\ntime: 0.219 s   configuration 2\r\ntime: 0.222 s   maybe building test harness\r\ntime: 0.223 s   prelude injection\r\ntime: 0.268 s   assinging node ids and indexing ast\r\ntime: 0.075 s   external crate/lib resolution\r\ntime: 0.026 s   language item collection\r\ntime: 1.016 s   resolution\r\ntime: 0.038 s   lifetime resolution\r\ntime: 0.000 s   looking for entry point\r\ntime: 0.030 s   looking for macro registrar\r\ntime: 0.061 s   freevar finding\r\ntime: 0.138 s   region resolution\r\ntime: 0.110 s   type collecting\r\ntime: 0.072 s   variance inference\r\ntime: 0.126 s   coherence checking\r\ntime: 9.110 s   type checking\r\ntime: 0.186 s   const marking\r\ntime: 0.049 s   const checking\r\ntime: 0.418 s   privacy checking\r\ntime: 0.057 s   effect checking\r\ntime: 0.033 s   loop checking\r\ntime: 1.293 s   compute moves\r\ntime: 0.182 s   match checking\r\ntime: 0.242 s   liveness checking\r\ntime: 0.866 s   borrow checking\r\ntime: 0.150 s   kind checking\r\ntime: 0.013 s   reachability checking\r\ntime: 0.175 s   death checking\r\ntime: 0.461 s   lint checking\r\ntime: 13.112 s  translation\r\n  time: 4.352 s llvm function passes\r\n  time: 96.702 s    llvm module passes\r\n  time: 50.574 s    codegen passes\r\ntime: 154.611 s LLVM passes\r\n  time: 2.821 s running linker\r\ntime: 15.750 s  linking\r\n\r\n\r\ncompile_and_link: x86_64-unknown-linux-gnu/stage1/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustc\r\ntime: 0.422 s   parsing\r\ntime: 0.031 s   gated feature checking\r\ntime: 0.000 s   crate injection\r\ntime: 0.126 s   configuration 1\r\ntime: 1.014 s   expansion\r\ntime: 0.251 s   configuration 2\r\ntime: 0.249 s   maybe building test harness\r\ntime: 0.273 s   prelude injection\r\ntime: 0.279 s   assinging node ids and indexing ast\r\ntime: 0.076 s   external crate/lib resolution\r\ntime: 0.033 s   language item collection\r\ntime: 1.028 s   resolution\r\ntime: 0.036 s   lifetime resolution\r\ntime: 0.000 s   looking for entry point\r\ntime: 0.029 s   looking for macro registrar\r\ntime: 0.063 s   freevar finding\r\ntime: 0.133 s   region resolution\r\ntime: 0.111 s   type collecting\r\ntime: 0.077 s   variance inference\r\ntime: 0.565 s   coherence checking\r\ntime: 8.953 s   type checking\r\ntime: 0.176 s   const marking\r\ntime: 0.050 s   const checking\r\ntime: 0.401 s   privacy checking\r\ntime: 0.063 s   effect checking\r\ntime: 0.032 s   loop checking\r\ntime: 1.291 s   compute moves\r\ntime: 0.172 s   match checking\r\ntime: 0.249 s   liveness checking\r\ntime: 0.831 s   borrow checking\r\ntime: 0.121 s   kind checking\r\ntime: 0.013 s   reachability checking\r\ntime: 0.179 s   death checking\r\ntime: 0.503 s   lint checking\r\ntime: 14.385 s  translation\r\n  time: 4.495 s llvm function passes\r\n  time: 92.234 s    llvm module passes\r\n  time: 51.172 s    codegen passes\r\ntime: 150.809 s LLVM passes\r\n  time: 2.542 s running linker\r\ntime: 15.109 s  linking\r\n```\r\n\r\nBUT accesses are much more cache friendly. In fact, if the probe\r\nsequence length is below 8, only two cache lines worth of hashes will be\r\npulled into cache. This is unlike the old version which would have to\r\nstride over the stoerd keys and values, and would be more cache\r\nunfriendly the bigger the stored values got.\r\n\r\nAnd did you notice the higher load factor? We can now reasonably get a\r\nload factor of 0.9 with very good performance.\r\n\r\nPlease review this very closely. This is my first major contribution to Rust. Sorry for the ugly diff!", "tree": {"sha": "5188d6f671912bdd6794a89154714984905574a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5188d6f671912bdd6794a89154714984905574a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eebeb81372e320510a1c1e2eef96eb5146a1e1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eebeb81372e320510a1c1e2eef96eb5146a1e1f", "html_url": "https://github.com/rust-lang/rust/commit/2eebeb81372e320510a1c1e2eef96eb5146a1e1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eebeb81372e320510a1c1e2eef96eb5146a1e1f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d64441bcb820cf35d3e39dde8514c46765a12a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d64441bcb820cf35d3e39dde8514c46765a12a6", "html_url": "https://github.com/rust-lang/rust/commit/4d64441bcb820cf35d3e39dde8514c46765a12a6"}, {"sha": "5bdbd2100946a5204ef82b12eb474e8e4d9ba64e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bdbd2100946a5204ef82b12eb474e8e4d9ba64e", "html_url": "https://github.com/rust-lang/rust/commit/5bdbd2100946a5204ef82b12eb474e8e4d9ba64e"}], "stats": {"total": 2006, "additions": 1412, "deletions": 594}, "files": [{"sha": "85a47d0d62c128d25dc66e5f502567fbfd12acc3", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 1412, "deletions": 594, "changes": 2006, "blob_url": "https://github.com/rust-lang/rust/blob/2eebeb81372e320510a1c1e2eef96eb5146a1e1f/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eebeb81372e320510a1c1e2eef96eb5146a1e1f/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=2eebeb81372e320510a1c1e2eef96eb5146a1e1f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,6 +13,8 @@\n //! The tables use a keyed hash with new random keys generated for each container, so the ordering\n //! of a set of keys in a hash table is randomized.\n //!\n+//! This is currently implemented with robin hood hashing, as described in [1][2][3].\n+//!\n //! # Example\n //!\n //! ```rust\n@@ -51,318 +53,938 @@\n //!     println!(\"{}: \\\"{}\\\"\", *book, *review);\n //! }\n //! ```\n+//!\n+//! Relevant papers/articles:\n+//!\n+//! [1]: Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n+//! [2]: (http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n+//! [3]: (http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n \n-use std::cmp::max;\n+use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n+use std::clone::Clone;\n+use std::cmp::{Eq, Equiv, max};\n use std::default::Default;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n-use std::hash::sip::{SipState, SipHasher};\n-use std::iter::{FilterMap, Chain, Repeat, Zip};\n+use std::fmt::Show;\n+use std::hash::{Hash, Hasher, sip};\n use std::iter;\n+use std::iter::{Iterator, FromIterator, Extendable};\n+use std::iter::{FilterMap, Chain, Repeat, Zip};\n+use std::iter::{range, range_inclusive};\n use std::mem::replace;\n use std::num;\n-use rand::Rng;\n+use std::option::{Option, Some, None};\n use rand;\n-use std::vec::{Items, MutItems};\n-use std::vec_ng::Vec;\n-use std::vec_ng;\n+use rand::Rng;\n+use std::result::{Ok, Err};\n+use std::vec::{ImmutableVector};\n+\n+mod table {\n+    use std::clone::Clone;\n+    use std::cmp::Eq;\n+    use std::hash::{Hash, Hasher};\n+    use std::kinds::marker;\n+    use std::libc;\n+    use std::num::CheckedMul;\n+    use std::option::{Option, Some, None};\n+    use std::prelude::Drop;\n+    use std::ptr;\n+    use std::ptr::RawPtr;\n+    use std::rt::global_heap;\n+    use std::intrinsics::{size_of, transmute, move_val_init};\n+    use std::iter::{Iterator, range_step_inclusive};\n+\n+    static EMPTY_BUCKET: u64 = 0u64;\n+\n+    /// The raw hashtable, providing safe-ish access to the unzipped and highly\n+    /// optimized arrays of hashes, keys, and values.\n+    ///\n+    /// This design uses less memory and is a lot faster than the naive\n+    /// `~[Option<u64, K, V>]`, because we don't pay for the overhead of an\n+    /// option on every element, and we get a generally more cache-aware design.\n+    ///\n+    /// Key invariants of this structure:\n+    ///\n+    ///   - if hashes[i] == EMPTY_BUCKET, then keys[i] and vals[i] have\n+    ///     'undefined' contents. Don't read from them. This invariant is\n+    ///     enforced outside this module with the [EmptyIndex], [FullIndex],\n+    ///     and [SafeHash] types/concepts.\n+    ///\n+    ///   - An `EmptyIndex` is only constructed for a bucket at an index with\n+    ///     a hash of EMPTY_BUCKET.\n+    ///\n+    ///   - A `FullIndex` is only constructed for a bucket at an index with a\n+    ///     non-EMPTY_BUCKET hash.\n+    ///\n+    ///   - A `SafeHash` is only constructed for non-`EMPTY_BUCKET` hash. We get\n+    ///     around hashes of zero by changing them to 0x800_0000, which will\n+    ///     likely hash to the same bucket, but not be represented as \"empty\".\n+    ///\n+    ///   - All three \"arrays represented by pointers\" are the same length:\n+    ///     `capacity`. This is set at creation and never changes. The arrays\n+    ///     are unzipped to save space (we don't have to pay for the padding\n+    ///     between odd sized elements, such as in a map from u64 to u8), and\n+    ///     be more cache aware (scanning through 8 hashes brings in 2 cache\n+    ///     lines, since they're all right beside each other).\n+    ///\n+    /// You can kind of think of this module/data structure as a safe wrapper\n+    /// around just the \"table\" part of the hashtable. It enforces some\n+    /// invariants at the type level and employs some performance trickery,\n+    /// but in general is just a tricked out `~[Option<u64, K, V>]`.\n+    ///\n+    /// FIXME(cgaebel):\n+    ///\n+    /// Feb 11, 2014: This hashtable was just implemented, and, hard as I tried,\n+    /// isn't yet totally safe. There's a \"known exploit\" that you can create\n+    /// multiple FullIndexes for a bucket, `take` one, and then still `take`\n+    /// the other causing undefined behavior. Currently, there's no story\n+    /// for how to protect against this statically. Therefore, there are asserts\n+    /// on `take`, `get`, `get_mut`, and `put` which check the bucket state.\n+    /// With time, and when we're confident this works correctly, they should\n+    /// be removed. Also, the bounds check in `peek` is especially painful,\n+    /// as that's called in the innermost loops of the hashtable and has the\n+    /// potential to be a major performance drain. Remove this too.\n+    ///\n+    /// Or, better than remove, only enable these checks for debug builds.\n+    /// There's currently no \"debug-only\" asserts in rust, so if you're reading\n+    /// this and going \"what? of course there are debug-only asserts!\", then\n+    /// please make this use them!\n+    pub struct RawTable<K, V> {\n+        priv capacity: uint,\n+        priv size:     uint,\n+        priv hashes:   *mut u64,\n+        priv keys:     *mut K,\n+        priv vals:     *mut V,\n+    }\n \n-static INITIAL_CAPACITY: uint = 32u; // 2^5\n+    /// Represents an index into a `RawTable` with no key or value in it.\n+    pub struct EmptyIndex {\n+        priv idx:   int,\n+        priv nopod: marker::NoPod,\n+    }\n \n-struct Bucket<K,V> {\n-    hash: uint,\n-    key: K,\n-    value: V,\n-}\n+    /// Represents an index into a `RawTable` with a key, value, and hash\n+    /// in it.\n+    pub struct FullIndex {\n+        priv idx:   int,\n+        priv hash:  SafeHash,\n+        priv nopod: marker::NoPod,\n+    }\n \n-/// A hash map implementation which uses linear probing along with the SipHash\n-/// hash function for internal state. This means that the order of all hash maps\n-/// is randomized by keying each hash map randomly on creation.\n-///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by using `#[deriving(Eq, Hash)]`.\n-pub struct HashMap<K, V, H = SipHasher> {\n-    priv hasher: H,\n-    priv resize_at: uint,\n-    priv size: uint,\n-    priv buckets: Vec<Option<Bucket<K, V>>>\n-}\n+    impl FullIndex {\n+        /// Since we get the hash for free whenever we check the bucket state,\n+        /// this function is provided for fast access, letting us avoid making\n+        /// redundant trips back to the hashtable.\n+        pub fn hash(&self) -> SafeHash { self.hash }\n \n-// We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n-// which would be nifty\n-enum SearchResult {\n-    FoundEntry(uint), FoundHole(uint), TableFull\n-}\n+        /// Same comment as with `hash`.\n+        pub fn raw_index(&self) -> uint { self.idx as uint }\n+    }\n \n-#[inline]\n-fn resize_at(capacity: uint) -> uint {\n-    (capacity * 3) / 4\n-}\n+    /// Represents the state of a bucket: it can either have a key/value\n+    /// pair (be full) or not (be empty). You cannot `take` empty buckets,\n+    /// and you cannot `put` into full buckets.\n+    pub enum BucketState {\n+        Empty(EmptyIndex),\n+        Full(FullIndex),\n+    }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    #[inline]\n-    fn to_bucket(&self, h: uint) -> uint {\n-        // A good hash function with entropy spread over all of the\n-        // bits is assumed. SipHash is more than good enough.\n-        h % self.buckets.len()\n-    }\n-\n-    #[inline]\n-    fn next_bucket(&self, idx: uint, len_buckets: uint) -> uint {\n-        (idx + 1) % len_buckets\n-    }\n-\n-    #[inline]\n-    fn bucket_sequence(&self, hash: uint, op: |uint| -> bool) -> bool {\n-        let start_idx = self.to_bucket(hash);\n-        let len_buckets = self.buckets.len();\n-        let mut idx = start_idx;\n-        loop {\n-            if !op(idx) { return false; }\n-            idx = self.next_bucket(idx, len_buckets);\n-            if idx == start_idx {\n-                return true;\n-            }\n-        }\n+    /// A hash that is not zero, since we use that to represent empty buckets.\n+    pub struct SafeHash {\n+        priv hash: u64,\n     }\n \n-    #[inline]\n-    fn bucket_for_key(&self, k: &K) -> SearchResult {\n-        let hash = self.hasher.hash(k) as uint;\n-        self.bucket_for_key_with_hash(hash, k)\n+    impl SafeHash {\n+        /// Peek at the hash value, which is guaranteed to be non-zero.\n+        pub fn inspect(&self) -> u64 { self.hash }\n     }\n \n-    #[inline]\n-    fn bucket_for_key_equiv<Q:Hash<S> + Equiv<K>>(&self, k: &Q) -> SearchResult {\n-        let hash = self.hasher.hash(k) as uint;\n-        self.bucket_for_key_with_hash_equiv(hash, k)\n+    impl Eq for SafeHash {\n+        fn eq(&self, other: &SafeHash) -> bool { self.hash == other.hash }\n     }\n \n-    #[inline]\n-    fn bucket_for_key_with_hash(&self,\n-                                hash: uint,\n-                                k: &K)\n-                             -> SearchResult {\n-        let mut ret = TableFull;\n-        self.bucket_sequence(hash, |i| {\n-            match self.buckets.as_slice()[i] {\n-                Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n-                    ret = FoundEntry(i); false\n-                },\n-                None => { ret = FoundHole(i); false }\n-                _ => true,\n+    /// We need to remove hashes of 0. That's reserved for empty buckets.\n+    /// This function wraps up `hash_keyed` to be the only way outside this\n+    /// module to generate a SafeHash.\n+    pub fn make_hash<T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+        match hasher.hash(t) {\n+            // This constant is exceedingly likely to hash to the same\n+            // bucket, but it won't be counted as empty!\n+            EMPTY_BUCKET => SafeHash { hash: 0x8000_0000_0000_0000 },\n+            h            => SafeHash { hash: h },\n+        }\n+    }\n+\n+    impl<K, V> RawTable<K, V> {\n+\n+        /// Does not initialize the buckets. The caller should ensure they,\n+        /// at the very least, set every hash to EMPTY_BUCKET.\n+        unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n+            let hashes_size =\n+                capacity.checked_mul(&size_of::<u64>()).expect(\"capacity overflow\");\n+            let keys_size   =\n+                capacity.checked_mul(&size_of::< K >()).expect(\"capacity overflow\");\n+            let vals_size   =\n+                capacity.checked_mul(&size_of::< V >()).expect(\"capacity overflow\");\n+\n+            /*\n+            The following code was my first pass at making RawTable only\n+            allocate a single buffer, since that's all it needs. There's\n+            no logical reason for this to require three calls to malloc.\n+\n+            However, I'm not convinced the code below is correct. If you\n+            want to take a stab at it, please do! The alignment is\n+            especially tricky to get right, especially if you need more\n+            alignment than malloc guarantees.\n+\n+            let hashes_offset = 0;\n+            let keys_offset   = align_size(hashes_offset + hashes_size, keys_align);\n+            let vals_offset   = align_size(keys_offset + keys_size, vals_align);\n+            let end = vals_offset + vals_size;\n+\n+            let buffer = global_heap::malloc_raw(end);\n+\n+            let hashes = buffer.offset(hashes_offset) as *mut u64;\n+            let keys   = buffer.offset(keys_offset)   as *mut K;\n+            let vals   = buffer.offset(vals_offset)   as *mut V;\n+\n+            */\n+\n+            let hashes = global_heap::malloc_raw(hashes_size) as *mut u64;\n+            let keys   = global_heap::malloc_raw(keys_size)   as *mut K;\n+            let vals   = global_heap::malloc_raw(vals_size)   as *mut V;\n+\n+            RawTable {\n+                capacity: capacity,\n+                size:     0,\n+                hashes:   hashes,\n+                keys:     keys,\n+                vals:     vals,\n             }\n-        });\n-        ret\n-    }\n-\n-    #[inline]\n-    fn bucket_for_key_with_hash_equiv<Q:Equiv<K>>(&self,\n-                                                  hash: uint,\n-                                                  k: &Q)\n-                                               -> SearchResult {\n-        let mut ret = TableFull;\n-        self.bucket_sequence(hash, |i| {\n-            match self.buckets.as_slice()[i] {\n-                Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n-                    ret = FoundEntry(i); false\n-                },\n-                None => { ret = FoundHole(i); false }\n-                _ => true,\n+        }\n+\n+\n+\n+        /// Creates a new raw table from a given capacity. All buckets are\n+        /// initially empty.\n+        pub fn new(capacity: uint) -> RawTable<K, V> {\n+            unsafe {\n+                let ret = RawTable::new_uninitialized(capacity);\n+\n+                for i in range(0, ret.capacity() as int) {\n+                    *ret.hashes.offset(i) = EMPTY_BUCKET;\n+                }\n+\n+                ret\n             }\n-        });\n-        ret\n+        }\n+\n+        /// Reads a bucket at a given index, returning an enum indicating whether\n+        /// there's anything there or not. You need to match on this enum to get\n+        /// the appropriate types to pass on to most of the rest of the functions\n+        /// in this module.\n+        pub fn peek(&self, index: uint) -> BucketState {\n+            // FIXME #12049\n+            if cfg!(test) { assert!(index < self.capacity) }\n+\n+            let idx  = index as int;\n+            let hash = unsafe { *self.hashes.offset(idx) };\n+\n+            let nopod = marker::NoPod;\n+\n+            match hash {\n+                EMPTY_BUCKET =>\n+                    Empty(EmptyIndex {\n+                        idx: idx,\n+                        nopod: nopod\n+                    }),\n+                full_hash =>\n+                    Full(FullIndex {\n+                        idx:   idx,\n+                        hash:  SafeHash { hash: full_hash },\n+                        nopod: nopod,\n+                    })\n+            }\n+        }\n+\n+        /// Gets references to the key and value at a given index.\n+        pub fn read<'a>(&'a self, index: &FullIndex) -> (&'a K, &'a V) {\n+            let idx = index.idx;\n+\n+            unsafe {\n+                // FIXME #12049\n+                if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n+                (&'a *self.keys.offset(idx),\n+                 &'a *self.vals.offset(idx))\n+            }\n+        }\n+\n+        /// Gets references to the key and value at a given index, with the\n+        /// value's reference being mutable.\n+        pub fn read_mut<'a>(&'a mut self, index: &FullIndex) -> (&'a K, &'a mut V) {\n+            let idx = index.idx;\n+\n+            unsafe {\n+                // FIXME #12049\n+                if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n+                (&'a     *self.keys.offset(idx),\n+                 &'a mut *self.vals.offset(idx))\n+            }\n+        }\n+\n+        /// Read everything, mutably.\n+        pub fn read_all_mut<'a>(&'a mut self, index: &FullIndex)\n+            -> (&'a mut SafeHash, &'a mut K, &'a mut V) {\n+            let idx = index.idx;\n+\n+            // I'm totally abusing the fact that a pointer to any u64 in the\n+            // hashtable at a full index is a safe hash. Thanks to `SafeHash`\n+            // just being a wrapper around u64, this is true. It's just really\n+            // really really really unsafe. However, the exposed API is now\n+            // impossible to get wrong. You cannot insert an empty hash into\n+            // this slot now.\n+\n+            unsafe {\n+                // FIXME #12049\n+                if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n+                (transmute(self.hashes.offset(idx)),\n+                 &'a mut *self.keys.offset(idx),\n+                 &'a mut *self.vals.offset(idx))\n+            }\n+        }\n+\n+        /// Puts a key and value pair, along with the key's hash, into a given\n+        /// index in the hashtable. Note how the `EmptyIndex` is 'moved' into this\n+        /// function, because that slot will no longer be empty when we return!\n+        /// Because we know this, a FullIndex is returned for later use, pointing\n+        /// to the newly-filled slot in the hashtable.\n+        ///\n+        /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n+        pub fn put(&mut self, index: EmptyIndex, hash: SafeHash, k: K, v: V) -> FullIndex {\n+            let idx = index.idx;\n+\n+            unsafe {\n+                // FIXME #12049\n+                if cfg!(test) { assert!(*self.hashes.offset(idx) == EMPTY_BUCKET) }\n+                *self.hashes.offset(idx) = hash.inspect();\n+                move_val_init(&mut *self.keys.offset(idx), k);\n+                move_val_init(&mut *self.vals.offset(idx), v);\n+            }\n+\n+            self.size += 1;\n+\n+            FullIndex { idx: idx, hash: hash, nopod: marker::NoPod }\n+        }\n+\n+        /// Removes a key and value from the hashtable.\n+        ///\n+        /// This works similarly to `put`, building an `EmptyIndex` out of the\n+        /// taken FullIndex.\n+        pub fn take(&mut self, index: FullIndex) -> (EmptyIndex, K, V) {\n+            let idx  = index.idx;\n+\n+            unsafe {\n+                // FIXME #12049\n+                if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n+\n+                let hash_ptr = self.hashes.offset(idx);\n+\n+                *hash_ptr = EMPTY_BUCKET;\n+\n+                // Drop the mutable constraint.\n+                let keys = self.keys as *K;\n+                let vals = self.vals as *V;\n+\n+                let k = ptr::read(keys.offset(idx));\n+                let v = ptr::read(vals.offset(idx));\n+\n+                self.size -= 1;\n+\n+                (EmptyIndex { idx: idx, nopod: marker::NoPod }, k, v)\n+            }\n+        }\n+\n+        /// The hashtable's capacity, similar to a vector's.\n+        pub fn capacity(&self) -> uint {\n+            self.capacity\n+        }\n+\n+        /// The number of elements ever `put` in the hashtable, minus the number\n+        /// of elements ever `take`n.\n+        pub fn size(&self) -> uint {\n+            self.size\n+        }\n+\n+        pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+            Entries { table: self, idx: 0 }\n+        }\n+\n+        pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+            MutEntries { table: self, idx: 0 }\n+        }\n+\n+        pub fn move_iter(self) -> MoveEntries<K, V> {\n+            MoveEntries { table: self, idx: 0 }\n+        }\n     }\n \n-    /// Expand the capacity of the array to the next power of two\n-    /// and re-insert each of the existing buckets.\n-    #[inline]\n-    fn expand(&mut self) {\n-        let new_capacity = self.buckets.len() * 2;\n-        self.resize(new_capacity);\n+    pub struct Entries<'a, K, V> {\n+        priv table: &'a RawTable<K, V>,\n+        priv idx: uint,\n     }\n \n-    /// Expands the capacity of the array and re-insert each of the\n-    /// existing buckets.\n-    fn resize(&mut self, new_capacity: uint) {\n-        self.resize_at = resize_at(new_capacity);\n+    pub struct MutEntries<'a, K, V> {\n+        priv table: &'a mut RawTable<K, V>,\n+        priv idx: uint,\n+    }\n+\n+    pub struct MoveEntries<K, V> {\n+        priv table: RawTable<K, V>,\n+        priv idx: uint,\n+    }\n \n-        let old_buckets = replace(&mut self.buckets,\n-                                  Vec::from_fn(new_capacity, |_| None));\n+    impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+        fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+            while self.idx < self.table.capacity() {\n+                let i = self.idx;\n+                self.idx += 1;\n \n-        self.size = 0;\n-        for bucket in old_buckets.move_iter() {\n-            self.insert_opt_bucket(bucket);\n+                match self.table.peek(i) {\n+                    Empty(_)  => {},\n+                    Full(idx) => return Some(self.table.read(&idx))\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        fn size_hint(&self) -> (uint, Option<uint>) {\n+            let size = self.table.size() - self.idx;\n+            (size, Some(size))\n         }\n     }\n \n-    fn insert_opt_bucket(&mut self, bucket: Option<Bucket<K, V>>) {\n-        match bucket {\n-            Some(Bucket{hash: hash, key: key, value: value}) => {\n-                self.insert_internal(hash, key, value);\n+    impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+        fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+            while self.idx < self.table.capacity() {\n+                let i = self.idx;\n+                self.idx += 1;\n+\n+                match self.table.peek(i) {\n+                    Empty(_)  => {},\n+                    // the transmute here fixes:\n+                    // error: lifetime of `self` is too short to guarantee its contents\n+                    //        can be safely reborrowed\n+                    Full(idx) => unsafe {\n+                        return Some(transmute(self.table.read_mut(&idx)))\n+                    }\n+                }\n             }\n-            None => {}\n+\n+            None\n         }\n-    }\n \n-    #[inline]\n-    fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n-        match self.buckets.as_slice()[idx] {\n-            Some(ref bkt) => &bkt.value,\n-            None => fail!(\"HashMap::find: internal logic error\"),\n+        fn size_hint(&self) -> (uint, Option<uint>) {\n+            let size = self.table.size() - self.idx;\n+            (size, Some(size))\n         }\n     }\n \n-    #[inline]\n-    fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n-        match self.buckets.as_mut_slice()[idx] {\n-            Some(ref mut bkt) => &mut bkt.value,\n-            None => unreachable!()\n+    impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n+        fn next(&mut self) -> Option<(SafeHash, K, V)> {\n+            while self.idx < self.table.capacity() {\n+                let i = self.idx;\n+                self.idx += 1;\n+\n+                match self.table.peek(i) {\n+                    Empty(_) => {},\n+                    Full(idx) => {\n+                        let h = idx.hash();\n+                        let (_, k, v) = self.table.take(idx);\n+                        return Some((h, k, v));\n+                    }\n+                }\n+            }\n+\n+            None\n+        }\n+\n+        fn size_hint(&self) -> (uint, Option<uint>) {\n+            let size = self.table.size();\n+            (size, Some(size))\n         }\n     }\n \n-    /// Inserts the key value pair into the buckets.\n-    /// Assumes that there will be a bucket.\n-    /// True if there was no previous entry with that key\n-    fn insert_internal(&mut self, hash: uint, k: K, v: V) -> Option<V> {\n-        match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => { fail!(\"Internal logic error\"); }\n-            FoundHole(idx) => {\n-                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n-                self.size += 1;\n-                None\n-            }\n-            FoundEntry(idx) => {\n-                match self.buckets.as_mut_slice()[idx] {\n-                    None => { fail!(\"insert_internal: Internal logic error\") }\n-                    Some(ref mut b) => {\n-                        b.hash = hash;\n-                        b.key = k;\n-                        Some(replace(&mut b.value, v))\n+    impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n+        fn clone(&self) -> RawTable<K, V> {\n+            unsafe {\n+                let mut new_ht = RawTable::new_uninitialized(self.capacity());\n+\n+                for i in range(0, self.capacity()) {\n+                    match self.peek(i) {\n+                        Empty(_)  => {\n+                            *new_ht.hashes.offset(i as int) = EMPTY_BUCKET;\n+                        },\n+                        Full(idx) => {\n+                            let hash = idx.hash().inspect();\n+                            let (k, v) = self.read(&idx);\n+                            *new_ht.hashes.offset(i as int) = hash;\n+                            move_val_init(&mut *new_ht.keys.offset(i as int), (*k).clone());\n+                            move_val_init(&mut *new_ht.vals.offset(i as int), (*v).clone());\n+                        }\n                     }\n                 }\n+\n+                new_ht.size = self.size();\n+\n+                new_ht\n             }\n         }\n     }\n \n-    fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n-        // Removing from an open-addressed hashtable\n-        // is, well, painful.  The problem is that\n-        // the entry may lie on the probe path for other\n-        // entries, so removing it would make you think that\n-        // those probe paths are empty.\n-        //\n-        // To address this we basically have to keep walking,\n-        // re-inserting entries we find until we reach an empty\n-        // bucket.  We know we will eventually reach one because\n-        // we insert one ourselves at the beginning (the removed\n-        // entry).\n-        //\n-        // I found this explanation elucidating:\n-        // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n-        let mut idx = match self.bucket_for_key_with_hash(hash, k) {\n-            TableFull | FoundHole(_) => return None,\n-            FoundEntry(idx) => idx\n-        };\n \n-        let len_buckets = self.buckets.len();\n-        let bucket = self.buckets.as_mut_slice()[idx].take();\n \n-        let value = bucket.map(|bucket| bucket.value);\n+    #[unsafe_destructor]\n+    impl<K, V> Drop for RawTable<K, V> {\n+        fn drop(&mut self) {\n+            // Ideally, this should be in reverse, since we're likely to have\n+            // partially taken some elements out with `.move_iter()` from the\n+            // front.\n+            for i in range_step_inclusive(self.capacity as int - 1, 0, -1) {\n+                // Check if the size is 0, so we don't do a useless scan when\n+                // dropping empty tables such as on resize.\n \n-        /* re-inserting buckets may cause changes in size, so remember\n-        what our new size is ahead of time before we start insertions */\n-        let size = self.size - 1;\n-        idx = self.next_bucket(idx, len_buckets);\n-        while self.buckets.as_slice()[idx].is_some() {\n-            let bucket = self.buckets.as_mut_slice()[idx].take();\n-            self.insert_opt_bucket(bucket);\n-            idx = self.next_bucket(idx, len_buckets);\n+                if self.size == 0 { break }\n+\n+                match self.peek(i as uint) {\n+                    Empty(_)  => {},\n+                    Full(idx) => { self.take(idx); }\n+                }\n+            }\n+\n+            assert!(self.size == 0);\n+\n+            unsafe {\n+                libc::free(self.vals   as *mut libc::c_void);\n+                libc::free(self.keys   as *mut libc::c_void);\n+                libc::free(self.hashes as *mut libc::c_void);\n+            }\n         }\n-        self.size = size;\n+    }\n+}\n \n-        value\n+// We use this type for the load factor, to avoid floating point operations\n+// which might not be supported efficiently on some hardware.\n+//\n+// We use small u16s here to save space in the hashtable. They get upcasted\n+// to u64s when we actually use them.\n+type Fraction = (u16, u16); // (numerator, denominator)\n+\n+// multiplication by a fraction, in a way that won't generally overflow for\n+// array sizes outside a factor of 10 of U64_MAX.\n+fn fraction_mul(lhs: uint, (num, den): Fraction) -> uint {\n+    (((lhs as u64) * (num as u64)) / (den as u64)) as uint\n+}\n+\n+static INITIAL_LOG2_CAP: uint = 5;\n+static INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n+static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n+\n+// The main performance trick in this hashmap is called Robin Hood Hashing.\n+// It gains its excellent performance from one key invariant:\n+//\n+//    If an insertion collides with an existing element, and that elements\n+//    \"probe distance\" (how far away the element is from its ideal location)\n+//    is higher than how far we've already probed, swap the elements.\n+//\n+// This massively lowers variance in probe distance, and allows us to get very\n+// high load factors with good performance. The 90% load factor I use is rather\n+// conservative.\n+//\n+// > Why a load factor of 90%?\n+//\n+// In general, all the distances to inital buckets will converge on the mean.\n+// At a load factor of \u03b1, the odds of finding the target bucket after k\n+// probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n+// on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n+// this down to 0.90 to make the math easier on the CPU and avoid its FPU.\n+// Since on average we start the probing in the middle of a cache line, this\n+// strategy pulls in two cache lines of hashes on every lookup. I think that's\n+// pretty good, but if you want to trade off some space, it could go down to one\n+// cache line on average with an \u03b1 of 0.84.\n+//\n+// > Wait, what? Where did you get 1-\u03b1^k from?\n+//\n+// On the first probe, your odds of a collision with an existing element is \u03b1.\n+// The odds of doing this twice in a row is approximatelly \u03b1^2. For three times,\n+// \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n+// colliding after k tries is 1-\u03b1^k.\n+//\n+// Future Improvements (FIXME!)\n+// ============================\n+//\n+// Allow the load factor to be changed dynamically and/or at initialization.\n+// I'm having trouble figuring out a sane API for this without exporting my\n+// hackish fraction type, while still avoiding floating point.\n+//\n+// Also, would it be possible for us to reuse storage when growing the\n+// underlying table? This is exactly the use case for 'realloc', and may\n+// be worth exploring.\n+//\n+// Future Optimizations (FIXME!)\n+// =============================\n+//\n+// The paper cited below mentions an implementation which keeps track of the\n+// distance-to-initial-bucket histogram. I'm suspicious of this approach because\n+// it requires maintaining an internal map. If this map were replaced with a\n+// hashmap, it would be faster, but now our data structure is self-referential\n+// and blows up. Also, this allows very good first guesses, but array accesses\n+// are no longer linear and in one direction, as we have now. There is also\n+// memory and cache pressure that this map would entail that would be very\n+// difficult to properly see in a microbenchmark.\n+//\n+// Another possible design choice that I made without any real reason is\n+// parameterizing the raw table over keys and values. Technically, all we need\n+// is the size and alignment of keys and values, and the code should be just as\n+// efficient (well, we might need one for power-of-two size and one for not...).\n+// This has the potential to reduce code bloat in rust executables, without\n+// really losing anything except 4 words (key size, key alignment, val size,\n+// val alignment) which can be passed in to every call of a `RawTable` function.\n+// This would definitely be an avenue worth exploring if people start complaining\n+// about the size of rust executables.\n+//\n+// There's also two optimizations that have been omitted regarding how the\n+// hashtable allocates. The first is that a hashtable which never has an element\n+// inserted should not allocate. I'm suspicious of this one, because supporting\n+// that internally gains no performance over just using an\n+// `Option<HashMap<K, V>>`, and is significantly more complicated.\n+//\n+// The second omitted allocation optimization is that right now we allocate three\n+// arrays to back the hashtable. This is wasteful. In theory, we only need one\n+// array, and each of the three original arrays can just be slices of it. This\n+// would reduce the pressure on the allocator, and will play much nicer with the\n+// rest of the system. An initial implementation is commented out in\n+// `table::RawTable::new`, but I'm not confident it works for all sane alignments,\n+// especially if a type needs more alignment than `malloc` provides.\n+\n+/// A hash map implementation which uses linear probing with Robin Hood bucket\n+/// stealing.\n+///\n+/// The hashes are all keyed by the task-local random number generator\n+/// on creation by default. This can be overriden with one of the constructors.\n+///\n+/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// this can frequently be achieved by using `#[deriving(Eq, Hash)]`.\n+#[deriving(Clone)]\n+pub struct HashMap<K, V, H = sip::SipHasher> {\n+    // All hashes are keyed on these values, to prevent hash collision attacks.\n+    priv hasher: H,\n+\n+    // When size == grow_at, we double the capacity.\n+    priv grow_at: uint,\n+\n+    // The capacity must never drop below this.\n+    priv minimum_capacity: uint,\n+\n+    priv table: table::RawTable<K, V>,\n+\n+    // We keep this at the end since it's 4-bytes, unlike everything else\n+    // in this struct. Might as well save a word of padding!\n+    priv load_factor: Fraction,\n+}\n+\n+/// Get the number of elements which will force the capacity to grow.\n+fn grow_at(capacity: uint, load_factor: Fraction) -> uint {\n+    fraction_mul(capacity, load_factor)\n+}\n+\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+    /// Get the number of elements which will force the capacity to shrink.\n+    /// When size == self.shrink_at(), we halve the capacity.\n+    fn shrink_at(&self) -> uint {\n+        self.table.capacity() >> 2\n+    }\n+\n+    // Probe the `idx`th bucket for a given hash, returning the index of the\n+    // target bucket.\n+    //\n+    // This exploits the power-of-two size of the hashtable. As long as this\n+    // is always true, we can use a bitmask of cap-1 to do modular arithmetic.\n+    //\n+    // Prefer to use this with increasing values of `idx` rather than repeatedly\n+    // calling `probe_next`. This reduces data-dependencies between loops, which\n+    // can help the optimizer, and certainly won't hurt it. `probe_next` is\n+    // simply for convenience, and is no more efficient than `probe`.\n+    fn probe(&self, hash: &table::SafeHash, idx: uint) -> uint {\n+        let hash_mask = self.table.capacity() - 1;\n+\n+        // So I heard a rumor that unsigned overflow is safe in rust..\n+        ((hash.inspect() as uint) + idx) & hash_mask\n+    }\n+\n+    // Generate the next probe in a sequence. Prefer to use 'probe' by itself,\n+    // but this can sometimes be useful.\n+    fn probe_next(&self, probe: uint) -> uint {\n+        let hash_mask = self.table.capacity() - 1;\n+        (probe + 1) & hash_mask\n+    }\n+\n+    fn make_hash<X: Hash<S>>(&self, x: &X) -> table::SafeHash {\n+        table::make_hash(&self.hasher, x)\n+    }\n+\n+    /// Get the distance of the bucket at the given index that it lies\n+    /// from its 'ideal' location.\n+    ///\n+    /// In the cited blog posts above, this is called the \"distance to\n+    /// inital bucket\", or DIB.\n+    fn bucket_distance(&self, index_of_elem: &table::FullIndex) -> uint {\n+        // where the hash of the element that happens to reside at\n+        // `index_of_elem` tried to place itself first.\n+        let first_probe_index = self.probe(&index_of_elem.hash(), 0);\n+\n+        let raw_index = index_of_elem.raw_index();\n+\n+        if first_probe_index <= raw_index {\n+             // probe just went forward\n+            raw_index - first_probe_index\n+        } else {\n+            // probe wrapped around the hashtable\n+            raw_index + (self.table.capacity() - first_probe_index)\n+        }\n+    }\n+\n+    /// Search for a pre-hashed key.\n+    fn search_hashed_generic(&self, hash: &table::SafeHash, is_match: |&K| -> bool)\n+        -> Option<table::FullIndex> {\n+        for num_probes in range(0u, self.table.size()) {\n+            let probe = self.probe(hash, num_probes);\n+\n+            let idx = match self.table.peek(probe) {\n+                table::Empty(_)  => return None, // hit an empty bucket\n+                table::Full(idx) => idx\n+            };\n+\n+            // We can finish the search early if we hit any bucket\n+            // with a lower distance to initial bucket than we've probed.\n+            if self.bucket_distance(&idx) < num_probes { return None }\n+\n+            // If the hash doesn't match, it can't be this one..\n+            if hash != &idx.hash() { continue }\n+\n+            let (k, _) = self.table.read(&idx);\n+\n+            // If the key doesn't match, it can't be this one..\n+            if !is_match(k) { continue }\n+\n+            return Some(idx);\n+        }\n+\n+        return None\n+    }\n+\n+    fn search_hashed(&self, hash: &table::SafeHash, k: &K) -> Option<table::FullIndex> {\n+        self.search_hashed_generic(hash, |k_| *k == *k_)\n+    }\n+\n+    fn search_equiv<Q: Hash<S> + Equiv<K>>(&self, q: &Q) -> Option<table::FullIndex> {\n+        self.search_hashed_generic(&self.make_hash(q), |k| q.equiv(k))\n+    }\n+\n+    /// Search for a key, yielding the index if it's found in the hashtable.\n+    /// If you already have the hash for the key lying around, use\n+    /// search_hashed.\n+    fn search(&self, k: &K) -> Option<table::FullIndex> {\n+        self.search_hashed(&self.make_hash(k), k)\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n     /// Return the number of elements in the map\n-    fn len(&self) -> uint { self.size }\n+    fn len(&self) -> uint { self.table.size() }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Mutable for HashMap<K, V, H> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n-        for bkt in self.buckets.as_mut_slice().mut_iter() {\n-            *bkt = None;\n+        self.minimum_capacity = self.table.size();\n+\n+        for i in range(0, self.table.capacity()) {\n+            match self.table.peek(i) {\n+                table::Empty(_)  => {},\n+                table::Full(idx) => { self.table.take(idx); }\n+            }\n         }\n-        self.size = 0;\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n-    /// Return a reference to the value corresponding to the key\n+\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Map<K, V> for HashMap<K, V, H> {\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n-        match self.bucket_for_key(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n-        }\n+        self.search(k).map(|idx| {\n+            let (_, v) = self.table.read(&idx);\n+            v\n+        })\n+    }\n+\n+    fn contains_key(&self, k: &K) -> bool {\n+        self.search(k).is_some()\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n-    /// Return a mutable reference to the value corresponding to the key\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H> {\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n-        let idx = match self.bucket_for_key(k) {\n-            FoundEntry(idx) => idx,\n-            TableFull | FoundHole(_) => return None\n-        };\n-        Some(self.mut_value_for_bucket(idx))\n+        match self.search(k) {\n+            None => None,\n+            Some(idx) => {\n+                let (_, v) = self.table.read_mut(&idx);\n+                Some(v)\n+            }\n+        }\n     }\n \n-    /// Insert a key-value pair from the map. If the key already had a value\n-    /// present in the map, that value is returned. Otherwise None is returned.\n     fn swap(&mut self, k: K, v: V) -> Option<V> {\n-        // this could be faster.\n+        let hash = self.make_hash(&k);\n+        let potential_new_size = self.table.size() + 1;\n+        self.make_some_room(potential_new_size);\n+\n+        for dib in range_inclusive(0u, self.table.size()) {\n+            let probe = self.probe(&hash, dib);\n+\n+            let idx = match self.table.peek(probe) {\n+                table::Empty(idx) => {\n+                    // Found a hole!\n+                    self.table.put(idx, hash, k, v);\n+                    return None;\n+                },\n+                table::Full(idx) => idx\n+            };\n+\n+            if idx.hash() == hash {\n+                let (bucket_k, bucket_v) = self.table.read_mut(&idx);\n+                if k == *bucket_k {\n+                    // Found an existing value.\n+                    return Some(replace(bucket_v, v));\n+                }\n+            }\n \n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n+            let probe_dib = self.bucket_distance(&idx);\n+\n+            if probe_dib < dib {\n+                // Found a luckier bucket. This implies that the key does not\n+                // already exist in the hashtable. Just do a robin hood\n+                // insertion, then.\n+                self.robin_hood(idx, probe_dib, hash, k, v);\n+                return None;\n+            }\n         }\n \n-        let hash = self.hasher.hash(&k) as uint;\n-        self.insert_internal(hash, k, v)\n+        // We really shouldn't be here.\n+        fail!(\"Internal HashMap error: Out of space.\");\n     }\n \n-    /// Removes a key from the map, returning the value at the key if the key\n-    /// was previously in the map.\n     fn pop(&mut self, k: &K) -> Option<V> {\n-        let hash = self.hasher.hash(k) as uint;\n-        self.pop_internal(hash, k)\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        let potential_new_size = self.table.size() - 1;\n+        self.make_some_room(potential_new_size);\n+\n+        let starting_index = match self.search(k) {\n+            Some(idx) => idx,\n+            None      => return None,\n+        };\n+\n+        let starting_probe = starting_index.raw_index();\n+\n+        let ending_probe = {\n+            let mut probe = self.probe_next(starting_probe);\n+            for _ in range(0u, self.table.size()) {\n+                match self.table.peek(probe) {\n+                    table::Empty(_) => {}, // empty bucket. this is the end of our shifting.\n+                    table::Full(idx) => {\n+                        // Bucket that isn't us, which has a non-zero probe distance.\n+                        // This isn't the ending index, so keep searching.\n+                        if self.bucket_distance(&idx) != 0 {\n+                            probe = self.probe_next(probe);\n+                            continue;\n+                        }\n+\n+                        // if we do have a bucket_distance of zero, we're at the end\n+                        // of what we need to shift.\n+                    }\n+                }\n+                break;\n+            }\n+\n+            probe\n+        };\n+\n+        let (_, _, retval) = self.table.take(starting_index);\n+\n+        let mut      probe = starting_probe;\n+        let mut next_probe = self.probe_next(probe);\n+\n+        // backwards-shift all the elements after our newly-deleted one.\n+        while next_probe != ending_probe {\n+            match self.table.peek(next_probe) {\n+                table::Empty(_) => {\n+                    // nothing to shift in. just empty it out.\n+                    match self.table.peek(probe) {\n+                        table::Empty(_) => {},\n+                        table::Full(idx) => { self.table.take(idx); }\n+                    }\n+                },\n+                table::Full(next_idx) => {\n+                    // something to shift. move it over!\n+                    let next_hash = next_idx.hash();\n+                    let (_, next_key, next_val) = self.table.take(next_idx);\n+                    match self.table.peek(probe) {\n+                        table::Empty(idx) => {\n+                            self.table.put(idx, next_hash, next_key, next_val);\n+                        },\n+                        table::Full(idx) => {\n+                            let (emptyidx, _, _) = self.table.take(idx);\n+                            self.table.put(emptyidx, next_hash, next_key, next_val);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            probe = next_probe;\n+            next_probe = self.probe_next(next_probe);\n+        }\n+\n+        // Done the backwards shift, but there's still an element left!\n+        // Empty it out.\n+        match self.table.peek(probe) {\n+            table::Empty(_) => {},\n+            table::Full(idx) => { self.table.take(idx); }\n+        }\n+\n+        // Now we're done all our shifting. Return the value we grabbed\n+        // earlier.\n+        return Some(retval);\n     }\n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V> {\n-    /// Create an empty HashMap\n-    pub fn new() -> HashMap<K, V, SipHasher> {\n+impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n+    /// Create an empty HashMap.\n+    pub fn new() -> HashMap<K, V, sip::SipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Create an empty HashMap with space for at least `capacity`\n-    /// elements in the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V> {\n+    pub fn with_capacity(capacity: uint) -> HashMap<K, V, sip::SipHasher> {\n         let mut r = rand::task_rng();\n-        let hasher = SipHasher::new_with_keys(r.gen(), r.gen());\n+        let r0 = r.gen();\n+        let r1 = r.gen();\n+        let hasher = sip::SipHasher::new_with_keys(r0, r1);\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -375,106 +997,209 @@ impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n-        let cap = max(INITIAL_CAPACITY, capacity);\n+        let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n         HashMap {\n-            hasher: hasher,\n-            resize_at: resize_at(cap),\n-            size: 0,\n-            buckets: Vec::from_fn(cap, |_| None)\n+            hasher:           hasher,\n+            load_factor:      INITIAL_LOAD_FACTOR,\n+            grow_at:          grow_at(cap, INITIAL_LOAD_FACTOR),\n+            minimum_capacity: cap,\n+            table:            table::RawTable::new(cap),\n+        }\n+    }\n+\n+    /// The hashtable will never try to shrink below this size. You can use\n+    /// this function to reduce reallocations if your hashtable frequently\n+    /// grows and shrinks by large amounts.\n+    ///\n+    /// This function has no effect on the operational semantics of the\n+    /// hashtable, only on performance.\n+    pub fn reserve(&mut self, new_minimum_capacity: uint) {\n+        let cap = num::next_power_of_two(\n+            max(INITIAL_CAPACITY, new_minimum_capacity));\n+\n+        self.minimum_capacity = cap;\n+\n+        if self.table.capacity() < cap {\n+            self.resize(cap);\n+        }\n+    }\n+\n+    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n+    ///   1) Make sure the new capacity is enough for all the elements, accounting\n+    ///      for the load factor.\n+    ///   2) Ensure new_capacity is a power of two.\n+    fn resize(&mut self, new_capacity: uint) {\n+        assert!(self.table.size() <= new_capacity);\n+        assert!((new_capacity - 1) & new_capacity == 0);\n+\n+        self.grow_at = grow_at(new_capacity, self.load_factor);\n+\n+        let old_table = replace(&mut self.table, table::RawTable::new(new_capacity));\n+        let old_size  = old_table.size();\n+\n+        for (h, k, v) in old_table.move_iter() {\n+            self.manual_insert_hashed_nocheck(h, k, v);\n+        }\n+\n+        assert_eq!(self.table.size(), old_size);\n+    }\n+\n+    /// Performs any necessary resize operations, such that there's space for\n+    /// new_size elements.\n+    fn make_some_room(&mut self, new_size: uint) {\n+        let should_shrink = new_size <= self.shrink_at();\n+        let should_grow   = self.grow_at <= new_size;\n+\n+        if should_grow {\n+            let new_capacity = self.table.capacity() << 1;\n+            self.resize(new_capacity);\n+        } else if should_shrink {\n+            let new_capacity = self.table.capacity() >> 1;\n+\n+            // Never shrink below the minimum capacity\n+            if self.minimum_capacity <= new_capacity {\n+                self.resize(new_capacity);\n+            }\n+        }\n+    }\n+\n+    /// Perform robin hood bucket stealing at the given 'index'. You must\n+    /// also pass that probe's \"distance to initial bucket\" so we don't have\n+    /// to recalculate it, as well as the total number of probes already done\n+    /// so we have some sort of upper bound on the number of probes to do.\n+    ///\n+    /// 'hash', 'k', and 'v' are the elements to robin hood into the hashtable.\n+    fn robin_hood(&mut self, index: table::FullIndex, dib_param: uint,\n+                  hash: table::SafeHash, k: K, v: V) {\n+        let (old_hash, old_key, old_val) = {\n+            let (old_hash_ref, old_key_ref, old_val_ref) = self.table.read_all_mut(&index);\n+\n+            let old_hash = replace(old_hash_ref, hash);\n+            let old_key  = replace(old_key_ref,  k);\n+            let old_val  = replace(old_val_ref,  v);\n+\n+            (old_hash, old_key, old_val)\n+        };\n+\n+        let mut probe = self.probe_next(index.raw_index());\n+\n+        for dib in range(dib_param + 1, self.table.size()) {\n+            let full_index = match self.table.peek(probe) {\n+                table::Empty(idx) => {\n+                    // Finally. A hole!\n+                    self.table.put(idx, old_hash, old_key, old_val);\n+                    return;\n+                },\n+                table::Full(idx) => idx\n+            };\n+\n+            let probe_dib = self.bucket_distance(&full_index);\n+\n+            if probe_dib < dib {\n+                // Robin hood! Steal the spot. This had better be tail call.\n+                return self.robin_hood(full_index, probe_dib, old_hash, old_key, old_val);\n+            }\n+\n+            probe = self.probe_next(probe);\n+        }\n+\n+        fail!(\"HashMap fatal error: 100% load factor?\");\n+    }\n+\n+    /// Manually insert a pre-hashed key-value pair, without first checking\n+    /// that there's enough room in the buckets. Returns a reference to the\n+    /// newly insert value.\n+    ///\n+    /// If the key already exists, the hashtable will be returned untouched\n+    /// and a reference to the existing element will be returned.\n+    fn manual_insert_hashed_nocheck<'a>(\n+        &'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n+\n+        for dib in range_inclusive(0u, self.table.size()) {\n+            let probe = self.probe(&hash, dib);\n+\n+            let idx = match self.table.peek(probe) {\n+                table::Empty(idx) => {\n+                    // Found a hole!\n+                    let fullidx  = self.table.put(idx, hash, k, v);\n+                    let (_, val) = self.table.read_mut(&fullidx);\n+                    return val;\n+                },\n+                table::Full(idx) => idx\n+            };\n+\n+            if idx.hash() == hash {\n+                let (bucket_k, bucket_v) = self.table.read_mut(&idx);\n+                // FIXME #12147 the conditional return confuses\n+                // borrowck if we return bucket_v directly\n+                let bv: *mut V = bucket_v;\n+                if k == *bucket_k {\n+                    // Key already exists. Get its reference.\n+                    return unsafe {&mut *bv};\n+                }\n+            }\n+\n+            let probe_dib = self.bucket_distance(&idx);\n+\n+            if  probe_dib < dib {\n+                // Found a luckier bucket than me. Better steal his spot.\n+                self.robin_hood(idx, probe_dib, hash, k, v);\n+\n+                // Now that it's stolen, just read the value's pointer\n+                // right out of the table!\n+                match self.table.peek(probe) {\n+                    table::Empty(_)  => fail!(\"Just stole a spot, but now that spot's empty.\"),\n+                    table::Full(idx) => {\n+                        let (_, v) = self.table.read_mut(&idx);\n+                        return v;\n+                    }\n+                }\n+            }\n         }\n-    }\n \n-    /// Reserve space for at least `n` elements in the hash table.\n-    pub fn reserve(&mut self, n: uint) {\n-        if n > self.buckets.len() {\n-            let buckets = n * 4 / 3 + 1;\n-            self.resize(num::next_power_of_two(buckets));\n-        }\n+        // We really shouldn't be here.\n+        fail!(\"Internal HashMap error: Out of space.\");\n     }\n \n-    /// Modify and return the value corresponding to the key in the map, or\n-    /// insert and return a new value if it doesn't exist.\n-    ///\n-    /// This method allows for all insertion behaviours of a hashmap,\n-    /// see methods like `insert`, `find_or_insert` and\n-    /// `insert_or_update_with` for less general and more friendly\n-    /// variations of this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use collections::HashMap;\n-    ///\n-    /// // map some strings to vectors of strings\n-    /// let mut map = HashMap::<~str, ~[~str]>::new();\n-    /// map.insert(~\"a key\", ~[~\"value\"]);\n-    /// map.insert(~\"z key\", ~[~\"value\"]);\n-    ///\n-    /// let new = ~[~\"a key\", ~\"b key\", ~\"z key\"];\n-    /// for k in new.move_iter() {\n-    ///     map.mangle(k, ~\"new value\",\n-    ///                // if the key doesn't exist in the map yet, add it in\n-    ///                // the obvious way.\n-    ///                |_k, v| ~[v],\n-    ///                // if the key does exist either prepend or append this\n-    ///                // new value based on the first letter of the key.\n-    ///                |key, already, new| {\n-    ///                     if key.starts_with(\"z\") {\n-    ///                         already.unshift(new);\n-    ///                     } else {\n-    ///                         already.push(new);\n-    ///                     }\n-    ///                });\n-    /// }\n-    ///\n-    /// for (k, v) in map.iter() {\n-    ///    println!(\"{} -> {:?}\", *k, *v);\n-    /// }\n-    /// ```\n-    pub fn mangle<'a,\n-                  A>(\n-                  &'a mut self,\n-                  k: K,\n-                  a: A,\n-                  not_found: |&K, A| -> V,\n-                  found: |&K, &mut V, A|)\n-                  -> &'a mut V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = self.hasher.hash(&k) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n-            FoundHole(idx) => {\n-                let v = not_found(&k, a);\n-                self.buckets.as_mut_slice()[idx] = Some(Bucket{hash: hash, key: k, value: v});\n-                self.size += 1;\n-                idx\n-            }\n-        };\n+    fn manual_insert_hashed<'a>(&'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n+        let potential_new_size = self.table.size() + 1;\n+        self.make_some_room(potential_new_size);\n+        self.manual_insert_hashed_nocheck(hash, k, v)\n+    }\n \n-        self.mut_value_for_bucket(idx)\n+    /// Inserts an element, returning a reference to that element inside the\n+    /// hashtable.\n+    fn manual_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n+        let hash = self.make_hash(&k);\n+        self.manual_insert_hashed(hash, k, v)\n     }\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        self.mangle(k, v, |_k, a| a, |_k,_v,_a| ())\n+        match self.search(&k) {\n+            Some(idx) => {\n+                let (_, v_ref) = self.table.read_mut(&idx);\n+                v_ref\n+            },\n+            None => self.manual_insert(k, v)\n+        }\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n-        self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n+        match self.search(&k) {\n+            Some(idx) => {\n+                let (_, v_ref) = self.table.read_mut(&idx);\n+                v_ref\n+            },\n+            None      => {\n+                let v = f(&k);\n+                self.manual_insert(k, v)\n+            }\n+        }\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n@@ -486,42 +1211,47 @@ impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                  v: V,\n                                  f: |&K, &mut V|)\n                                  -> &'a mut V {\n-        self.mangle(k, v, |_k,a| a, |k,v,_a| f(k,v))\n+        match self.search(&k) {\n+            None      => self.manual_insert(k, v),\n+            Some(idx) => {\n+                let (_, v_ref) = self.table.read_mut(&idx);\n+                f(&k, v_ref);\n+                v_ref\n+            }\n+        }\n     }\n \n-    /// Retrieves a value for the given key, failing if the key is not\n-    /// present.\n+    /// Retrieves a value for the given key, failing if the key is not present.\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k),\n+            None => fail!(\"No entry found for key: {:?}\", k)\n         }\n     }\n \n-    /// Retrieves a (mutable) value for the given key, failing if the key\n-    /// is not present.\n+    /// Retrieves a (mutable) value for the given key, failing if the key is not present.\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k),\n+            None => fail!(\"No entry found for key: {:?}\", k)\n         }\n     }\n \n     /// Return true if the map contains a value for the specified key,\n-    /// using equivalence\n-    pub fn contains_key_equiv<Q:Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n-        match self.bucket_for_key_equiv(key) {\n-            FoundEntry(_) => {true}\n-            TableFull | FoundHole(_) => {false}\n-        }\n+    /// using equivalence.\n+    pub fn contains_key_equiv<Q: Hash<S> + Equiv<K>>(&self, key: &Q) -> bool {\n+        self.search_equiv(key).is_some()\n     }\n \n     /// Return the value corresponding to the key in the map, using\n-    /// equivalence\n-    pub fn find_equiv<'a, Q:Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n-        match self.bucket_for_key_equiv(k) {\n-            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n-            TableFull | FoundHole(_) => None,\n+    /// equivalence.\n+    pub fn find_equiv<'a, Q: Hash<S> + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n+        match self.search_equiv(k) {\n+            None      => None,\n+            Some(idx) => {\n+                let (_, v_ref) = self.table.read(&idx);\n+                Some(v_ref)\n+            }\n         }\n     }\n \n@@ -540,25 +1270,25 @@ impl<K: Hash<S> + Eq, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-        Entries { iter: self.buckets.as_slice().iter() }\n+        self.table.iter()\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is (&'a K, &'a mut V).\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        MutEntries { iter: self.buckets.as_mut_slice().mut_iter() }\n+        self.table.mut_iter()\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n-        MoveEntries {iter: self.buckets.move_iter()}\n+        self.table.move_iter().map(|(_, k, v)| (k, v))\n     }\n }\n \n-impl<K: Hash<S> + Eq, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Like `find`, but returns a copy of the value.\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n         self.find(k).map(|v| (*v).clone())\n@@ -570,63 +1300,47 @@ impl<K: Hash<S> + Eq, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Hash<S> + Eq, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)| {\n             match other.find(key) {\n-                None => false,\n-                Some(v) => value == v\n+                None    => false,\n+                Some(v) => *value == *v\n             }\n         })\n     }\n-\n-    fn ne(&self, other: &HashMap<K, V, H>) -> bool { !self.eq(other) }\n }\n \n-impl<K: Hash<S> + Eq + Clone, V:Clone, S, H: Hasher<S> + Clone> Clone for HashMap<K, V, H> {\n-    fn clone(&self) -> HashMap<K, V, H> {\n-        let mut new_map = HashMap::with_capacity_and_hasher(self.len(),\n-                                                            self.hasher.clone());\n-        for (key, value) in self.iter() {\n-            new_map.insert((*key).clone(), (*value).clone());\n+impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f.buf, r\"\\{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f.buf, \", \")); }\n+            try!(write!(f.buf, \"{}: {}\", *k, *v));\n         }\n-        new_map\n+\n+        write!(f.buf, r\"\\}\")\n     }\n }\n \n-impl<K: fmt::Show + Hash<S> + Eq, V: fmt::Show, S, H: Hasher<S>> fmt::Show for HashMap<K, V, H> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"))\n-        let mut first = true;\n-        for (key, value) in self.iter() {\n-            if first {\n-                first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n-            try!(write!(f.buf, \"{}: {}\", *key, *value));\n-        }\n-        write!(f.buf, r\"\\}\")\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n+    fn default() -> HashMap<K, V, H> {\n+        HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, Default::default())\n     }\n }\n \n /// HashMap iterator\n-#[deriving(Clone)]\n-pub struct Entries<'a, K, V> {\n-    priv iter: Items<'a, Option<Bucket<K, V>>>,\n-}\n+pub type Entries<'a, K, V> = table::Entries<'a, K, V>;\n \n /// HashMap mutable values iterator\n-pub struct MutEntries<'a, K, V> {\n-    priv iter: MutItems<'a, Option<Bucket<K, V>>>,\n-}\n+pub type MutEntries<'a, K, V> = table::MutEntries<'a, K, V>;\n \n /// HashMap move iterator\n-pub struct MoveEntries<K, V> {\n-    priv iter: vec_ng::MoveItems<Option<Bucket<K, V>>>,\n-}\n+pub type MoveEntries<K, V> =\n+    iter::Map<'static, (table::SafeHash, K, V), (K, V), table::MoveEntries<K, V>>;\n \n /// HashMap keys iterator\n pub type Keys<'a, K, V> =\n@@ -636,83 +1350,7 @@ pub type Keys<'a, K, V> =\n pub type Values<'a, K, V> =\n     iter::Map<'static, (&'a K, &'a V), &'a V, Entries<'a, K, V>>;\n \n-/// HashSet iterator\n-#[deriving(Clone)]\n-pub struct SetItems<'a, K> {\n-    priv iter: Items<'a, Option<Bucket<K, ()>>>,\n-}\n-\n-/// HashSet move iterator\n-pub struct SetMoveItems<K> {\n-    priv iter: vec_ng::MoveItems<Option<Bucket<K, ()>>>,\n-}\n-\n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(K, V)> {\n-        for elt in self.iter {\n-            match elt {\n-                Some(Bucket {key, value, ..}) => return Some((key, value)),\n-                None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a K> {\n-        for elt in self.iter {\n-            match elt {\n-                &Some(ref bucket) => return Some(&bucket.key),\n-                &None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K> Iterator<K> for SetMoveItems<K> {\n-    #[inline]\n-    fn next(&mut self) -> Option<K> {\n-        for elt in self.iter {\n-            match elt {\n-                Some(bucket) => return Some(bucket.key),\n-                None => {},\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iterator<T: Iterator<(K, V)>>(iter: &mut T) -> HashMap<K, V, H> {\n         let (lower, _) = iter.size_hint();\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n@@ -721,45 +1359,54 @@ impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for Has\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extendable<(K, V)> for HashMap<K, V, H> {\n     fn extend<T: Iterator<(K, V)>>(&mut self, iter: &mut T) {\n         for (k, v) in *iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n-impl<K: Hash<S> + Eq, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n-    fn default() -> HashMap<K, V, H> {\n-        HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, Default::default())\n-    }\n-}\n+/// HashSet iterator\n+pub type SetItems<'a, K> =\n+    iter::Map<'static, (&'a K, &'a ()), &'a K, Entries<'a, K, ()>>;\n+\n+/// HashSet move iterator\n+pub type SetMoveItems<K> =\n+    iter::Map<'static, (K, ()), K, MoveEntries<K, ()>>;\n \n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n-pub struct HashSet<T, H = SipHasher> {\n+#[deriving(Clone)]\n+pub struct HashSet<T, H = sip::SipHasher> {\n     priv map: HashMap<T, (), H>\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> Eq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool { self.map == other.map }\n-    fn ne(&self, other: &HashSet<T, H>) -> bool { self.map != other.map }\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n+    // FIXME #11998: Since the value is a (), and `find` returns a Some(&()),\n+    // we trigger #11998 when matching on it. I've fallen back to manual\n+    // iteration until this is fixed.\n+    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|key| other.map.contains_key(key))\n+    }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> Container for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Container for HashSet<T, H> {\n     /// Return the number of elements in the set\n     fn len(&self) -> uint { self.map.len() }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     /// Return true if the set contains a value\n-    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+    fn contains(&self, value: &T) -> bool { self.map.search(value).is_some() }\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n@@ -778,7 +1425,7 @@ impl<T: Hash<S> + Eq, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n     }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     /// Add a value to the set. Return true if the value was not already\n     /// present in the set.\n     fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n@@ -788,35 +1435,33 @@ impl<T: Hash<S> + Eq, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n-impl<T: Hash<SipState> + Eq> HashSet<T, SipHasher> {\n+impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n     /// Create an empty HashSet\n-    pub fn new() -> HashSet<T, SipHasher> {\n+    pub fn new() -> HashSet<T, sip::SipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, SipHasher> {\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, sip::SipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S>> HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n \n     /// Create an empty HashSet with space for at least `capacity`\n-    /// elements in the hash table, using `k0` and `k1` as the keys.\n+    /// elements in the hash table, using `hasher` to hash the keys.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n-    /// are designed to allow HashSets to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting them\n+    /// is designed to allow `HashSet`s to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n-        HashSet {\n-            map: HashMap::with_capacity_and_hasher(capacity, hasher)\n-        }\n+        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n@@ -833,14 +1478,14 @@ impl<T: Hash<S> + Eq, S, H: Hasher<S>> HashSet<T, H> {\n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        SetItems { iter: self.map.buckets.as_slice().iter() }\n+        self.map.keys()\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n     pub fn move_iter(self) -> SetMoveItems<T> {\n-        SetMoveItems {iter: self.map.buckets.move_iter()}\n+        self.map.move_iter().map(|(k, _)| k)\n     }\n \n     /// Visit the values representing the difference\n@@ -876,80 +1521,224 @@ impl<T: Hash<S> + Eq, S, H: Hasher<S>> HashSet<T, H> {\n \n }\n \n-impl<T: Hash<S> + Eq + Clone, S, H: Hasher<S> + Clone> Clone for HashSet<T, H> {\n-    fn clone(&self) -> HashSet<T, H> {\n-        HashSet {\n-            map: self.map.clone()\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Show + Hash<S> + Eq, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, r\"\\{\"))\n-        let mut first = true;\n-        for x in self.iter() {\n-            if first {\n-                first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n+        try!(write!(f.buf, r\"\\{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f.buf, \", \")); }\n             try!(write!(f.buf, \"{}\", *x));\n         }\n+\n         write!(f.buf, r\"\\}\")\n     }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n-    fn from_iterator<Iter: Iterator<T>>(iter: &mut Iter) -> HashSet<T, H> {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+    fn from_iterator<I: Iterator<T>>(iter: &mut I) -> HashSet<T, H> {\n         let (lower, _) = iter.size_hint();\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n         set.extend(iter);\n         set\n     }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n-    fn extend<Iter: Iterator<T>>(&mut self, iter: &mut Iter) {\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+    fn extend<I: Iterator<T>>(&mut self, iter: &mut I) {\n         for k in *iter {\n             self.insert(k);\n         }\n     }\n }\n \n-impl<T: Hash<S> + Eq, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n-    fn default() -> HashSet<T, H> {\n-        HashSet {\n-            map: Default::default(),\n-        }\n-    }\n+impl<T: Eq + Hash> Default for HashSet<T, sip::SipHasher> {\n+    fn default() -> HashSet<T> { HashSet::new() }\n }\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator\n pub type SetAlgebraItems<'a, T, H> =\n-    FilterMap<'static,(&'a HashSet<T, H>, &'a T), &'a T,\n+    FilterMap<'static, (&'a HashSet<T, H>, &'a T), &'a T,\n               Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>>;\n \n #[cfg(test)]\n mod test_map {\n-    use super::{HashMap, HashSet};\n-    use std::fmt;\n+    use super::HashMap;\n+    use std::iter::{Iterator,range_inclusive,range_step_inclusive};\n+    use std::local_data;\n+    use std::vec_ng;\n \n     #[test]\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n+\n         assert!(m.insert(1, 1));\n+\n+        assert!(m.contains_key(&1));\n+        assert!(!m.contains_key(&0));\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut m = HashMap::new();\n+        assert_eq!(m.len(), 0);\n         assert!(m.insert(1, 2));\n+        assert_eq!(m.len(), 1);\n         assert!(m.insert(2, 4));\n-        assert_eq!(*m.get(&1), 2);\n-        assert_eq!(*m.get(&2), 4);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n+        assert_eq!(*m.find(&2).unwrap(), 4);\n+    }\n+\n+    local_data_key!(drop_vector: vec_ng::Vec<int>)\n+\n+    #[deriving(Hash, Eq)]\n+    struct Dropable {\n+        k: int\n+    }\n+\n+\n+    impl Dropable {\n+        fn new(k: int) -> Dropable {\n+            local_data::get_mut(drop_vector,\n+                |v| { v.unwrap().as_mut_slice()[k] += 1; });\n+\n+            Dropable { k: k }\n+        }\n+    }\n+\n+    impl Drop for Dropable {\n+        fn drop(&mut self) {\n+            local_data::get_mut(drop_vector, |v|\n+                { v.unwrap().as_mut_slice()[self.k] -= 1; });\n+        }\n+    }\n+\n+    #[test]\n+    fn test_drops() {\n+        local_data::set(drop_vector, vec_ng::Vec::from_elem(200, 0));\n+\n+        {\n+            let mut m = HashMap::new();\n+\n+            local_data::get(drop_vector, |v| {\n+                for i in range(0, 200) {\n+                    assert_eq!(v.unwrap().as_slice()[i], 0);\n+                }\n+            });\n+\n+            for i in range(0, 100) {\n+                let d1 = Dropable::new(i);\n+                let d2 = Dropable::new(i+100);\n+                m.insert(d1, d2);\n+            }\n+\n+            local_data::get(drop_vector, |v| {\n+                for i in range(0, 200) {\n+                    assert_eq!(v.unwrap().as_slice()[i], 1);\n+                }\n+            });\n+\n+            for i in range(0, 50) {\n+                let k = Dropable::new(i);\n+                let v = m.pop(&k);\n+\n+                assert!(v.is_some());\n+\n+                local_data::get(drop_vector, |v| {\n+                    assert_eq!(v.unwrap().as_slice()[i], 1);\n+                    assert_eq!(v.unwrap().as_slice()[i+100], 1);\n+                });\n+            }\n+\n+            local_data::get(drop_vector, |v| {\n+                for i in range(0, 50) {\n+                    assert_eq!(v.unwrap().as_slice()[i], 0);\n+                    assert_eq!(v.unwrap().as_slice()[i+100], 0);\n+                }\n+\n+                for i in range(50, 100) {\n+                    assert_eq!(v.unwrap().as_slice()[i], 1);\n+                    assert_eq!(v.unwrap().as_slice()[i+100], 1);\n+                }\n+            });\n+        }\n+\n+        local_data::get(drop_vector, |v| {\n+            for i in range(0, 200) {\n+                assert_eq!(v.unwrap().as_slice()[i], 0);\n+            }\n+        });\n+    }\n+\n+    #[test]\n+    fn test_empty_pop() {\n+        let mut m: HashMap<int, bool> = HashMap::new();\n+        assert_eq!(m.pop(&0), None);\n+    }\n+\n+    #[test]\n+    fn test_lots_of_insertions() {\n+        let mut m = HashMap::new();\n+\n+        // Try this a few times to make sure we never screw up the hashmap's\n+        // internal state.\n+        for _ in range(0, 10) {\n+            assert!(m.is_empty());\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.insert(i, i));\n+\n+                for j in range_inclusive(1, i) {\n+                    let r = m.find(&j);\n+                    assert_eq!(r, Some(&j));\n+                }\n+\n+                for j in range_inclusive(i+1, 1000) {\n+                    let r = m.find(&j);\n+                    assert_eq!(r, None);\n+                }\n+            }\n+\n+            for i in range_inclusive(1001, 2000) {\n+                assert!(!m.contains_key(&i));\n+            }\n+\n+            // remove forwards\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.remove(&i));\n+\n+                for j in range_inclusive(1, i) {\n+                    assert!(!m.contains_key(&j));\n+                }\n+\n+                for j in range_inclusive(i+1, 1000) {\n+                    assert!(m.contains_key(&j));\n+                }\n+            }\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(!m.contains_key(&i));\n+            }\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.insert(i, i));\n+            }\n+\n+            // remove backwards\n+            for i in range_step_inclusive(1000, 1, -1) {\n+                assert!(m.remove(&i));\n+\n+                for j in range_inclusive(i, 1000) {\n+                    assert!(!m.contains_key(&j));\n+                }\n+\n+                for j in range_inclusive(1, i-1) {\n+                    assert!(m.contains_key(&j));\n+                }\n+            }\n+        }\n     }\n \n     #[test]\n@@ -969,9 +1758,9 @@ mod test_map {\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n-        assert_eq!(*m.get(&1), 2);\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n         assert!(!m.insert(1, 3));\n-        assert_eq!(*m.get(&1), 3);\n+        assert_eq!(*m.find(&1).unwrap(), 3);\n     }\n \n     #[test]\n@@ -980,20 +1769,26 @@ mod test_map {\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n         assert!(m.insert(9, 4));\n-        assert_eq!(*m.get(&9), 4);\n-        assert_eq!(*m.get(&5), 3);\n-        assert_eq!(*m.get(&1), 2);\n+        assert_eq!(*m.find(&9).unwrap(), 4);\n+        assert_eq!(*m.find(&5).unwrap(), 3);\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n     }\n \n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);\n         assert!(m.insert(1, 2));\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n         assert!(m.insert(5, 3));\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n+        assert_eq!(*m.find(&5).unwrap(), 3);\n         assert!(m.insert(9, 4));\n+        assert_eq!(*m.find(&1).unwrap(), 2);\n+        assert_eq!(*m.find(&5).unwrap(), 3);\n+        assert_eq!(*m.find(&9).unwrap(), 4);\n         assert!(m.remove(&1));\n-        assert_eq!(*m.get(&9), 4);\n-        assert_eq!(*m.get(&5), 3);\n+        assert_eq!(*m.find(&9).unwrap(), 4);\n+        assert_eq!(*m.find(&5).unwrap(), 3);\n     }\n \n     #[test]\n@@ -1021,27 +1816,6 @@ mod test_map {\n         assert_eq!(m.swap(1, 4), Some(3));\n     }\n \n-    #[test]\n-    fn test_find_or_insert() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.find_or_insert(1, 2), 2);\n-        assert_eq!(*m.find_or_insert(1, 3), 2);\n-    }\n-\n-    #[test]\n-    fn test_find_or_insert_with() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n-        assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n-    }\n-\n-    #[test]\n-    fn test_insert_or_update_with() {\n-        let mut m: HashMap<int,int> = HashMap::new();\n-        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 2);\n-        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 3);\n-    }\n-\n     #[test]\n     fn test_move_iter() {\n         let hm = {\n@@ -1063,7 +1837,10 @@ mod test_map {\n         for i in range(0u, 32) {\n             assert!(m.insert(i, i*2));\n         }\n+        assert_eq!(m.len(), 32);\n+\n         let mut observed = 0;\n+\n         for (k, v) in m.iter() {\n             assert_eq!(*v, *k * 2);\n             observed |= 1 << *k;\n@@ -1130,8 +1907,8 @@ mod test_map {\n         assert!(m.is_empty());\n \n         let mut i = 0u;\n-        let old_resize_at = m.resize_at;\n-        while old_resize_at == m.resize_at {\n+        let old_resize_at = m.grow_at;\n+        while old_resize_at == m.grow_at {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -1167,73 +1944,14 @@ mod test_map {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n-\n-    struct ShowableStruct {\n-        value: int,\n-    }\n-\n-    impl fmt::Show for ShowableStruct {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f.buf, r\"s{}\", self.value)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut table: HashMap<int, ShowableStruct> = HashMap::new();\n-        let empty: HashMap<int, ShowableStruct> = HashMap::new();\n-\n-        table.insert(3, ShowableStruct { value: 4 });\n-        table.insert(1, ShowableStruct { value: 2 });\n-\n-        let table_str = format!(\"{}\", table);\n-\n-        assert!(table_str == ~\"{1: s2, 3: s4}\" || table_str == ~\"{3: s4, 1: s2}\");\n-        assert_eq!(format!(\"{}\", empty), ~\"{}\");\n-    }\n-\n-    struct StructWithToStrWithoutEqOrHash {\n-        value: int\n-    }\n-\n-    impl fmt::Show for StructWithToStrWithoutEqOrHash {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            write!(f.buf, \"s{}\", self.value)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hashset() {\n-        let mut set: HashSet<int> = HashSet::new();\n-        let empty_set: HashSet<int> = HashSet::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = set.to_str();\n-\n-        assert!(set_str == ~\"{1, 2}\" || set_str == ~\"{2, 1}\");\n-        assert_eq!(empty_set.to_str(), ~\"{}\");\n-    }\n-\n-    #[test]\n-    fn test_hashmap() {\n-        let mut table: HashMap<int, StructWithToStrWithoutEqOrHash> = HashMap::new();\n-        let empty: HashMap<int, StructWithToStrWithoutEqOrHash> = HashMap::new();\n-\n-        table.insert(3, StructWithToStrWithoutEqOrHash { value: 4 });\n-        table.insert(1, StructWithToStrWithoutEqOrHash { value: 2 });\n-\n-        let table_str = table.to_str();\n-\n-        assert!(table_str == ~\"{1: s2, 3: s4}\" || table_str == ~\"{3: s4, 1: s2}\");\n-        assert_eq!(empty.to_str(), ~\"{}\");\n-    }\n }\n \n #[cfg(test)]\n mod test_set {\n+    use super::HashMap;\n     use super::HashSet;\n+    use std::container::Container;\n+    use std::vec::ImmutableEqVector;\n \n     #[test]\n     fn test_disjoint() {\n@@ -1436,12 +2154,16 @@ mod test_set {\n \n     #[test]\n     fn test_eq() {\n+        // These constants once happened to expose a bug in insert().\n+        // I'm keeping them around to prevent a regression.\n         let mut s1 = HashSet::new();\n+\n         s1.insert(1);\n         s1.insert(2);\n         s1.insert(3);\n \n         let mut s2 = HashSet::new();\n+\n         s2.insert(1);\n         s2.insert(2);\n \n@@ -1466,3 +2188,99 @@ mod test_set {\n         assert_eq!(format!(\"{}\", empty), ~\"{}\");\n     }\n }\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use self::test::BenchHarness;\n+    use std::iter;\n+    use std::iter::{range_inclusive};\n+\n+    #[bench]\n+    fn insert(b: &mut BenchHarness) {\n+        use super::HashMap;\n+\n+        let mut m = HashMap::new();\n+\n+        for i in range_inclusive(1, 1000) {\n+            m.insert(i, i);\n+        }\n+\n+        let mut k = 1001;\n+\n+        b.iter(|| {\n+            m.insert(k, k);\n+            k += 1;\n+        });\n+    }\n+\n+    #[bench]\n+    fn find_existing(b: &mut BenchHarness) {\n+        use super::HashMap;\n+\n+        let mut m = HashMap::new();\n+\n+        for i in range_inclusive(1, 1000) {\n+            m.insert(i, i);\n+        }\n+\n+        b.iter(|| {\n+            m.contains_key(&412);\n+        });\n+    }\n+\n+    #[bench]\n+    fn find_nonexisting(b: &mut BenchHarness) {\n+        use super::HashMap;\n+\n+        let mut m = HashMap::new();\n+\n+        for i in range_inclusive(1, 1000) {\n+            m.insert(i, i);\n+        }\n+\n+        b.iter(|| {\n+            m.contains_key(&2048);\n+        });\n+    }\n+\n+    #[bench]\n+    fn hashmap_as_queue(b: &mut BenchHarness) {\n+        use super::HashMap;\n+\n+        let mut m = HashMap::new();\n+\n+        for i in range_inclusive(1, 1000) {\n+            m.insert(i, i);\n+        }\n+\n+        let mut k = 1;\n+\n+        b.iter(|| {\n+            m.pop(&k);\n+            m.insert(k + 1000, k + 1000);\n+            k += 1;\n+        });\n+    }\n+\n+    #[bench]\n+    fn find_pop_insert(b: &mut BenchHarness) {\n+        use super::HashMap;\n+\n+        let mut m = HashMap::new();\n+\n+        for i in range_inclusive(1, 1000) {\n+            m.insert(i, i);\n+        }\n+\n+        let mut k = 1;\n+\n+        b.iter(|| {\n+            m.find(&(k + 400));\n+            m.find(&(k + 2000));\n+            m.pop(&k);\n+            m.insert(k + 1000, k + 1000);\n+            k += 1;\n+        })\n+    }\n+}"}]}