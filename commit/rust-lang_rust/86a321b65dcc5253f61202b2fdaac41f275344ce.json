{"sha": "86a321b65dcc5253f61202b2fdaac41f275344ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YTMyMWI2NWRjYzUyNTNmNjEyMDJiMmZkYWFjNDFmMjc1MzQ0Y2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-08T04:13:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:12Z"}, "message": "Another round of test fixes from previous commits", "tree": {"sha": "e6dd37093bbab2dad2ae7f2f6175b44bb53d9adb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6dd37093bbab2dad2ae7f2f6175b44bb53d9adb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86a321b65dcc5253f61202b2fdaac41f275344ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86a321b65dcc5253f61202b2fdaac41f275344ce", "html_url": "https://github.com/rust-lang/rust/commit/86a321b65dcc5253f61202b2fdaac41f275344ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86a321b65dcc5253f61202b2fdaac41f275344ce/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9", "html_url": "https://github.com/rust-lang/rust/commit/3a3eefc5c3ce95de3001d8ee830296345c2f6bc9"}], "stats": {"total": 387, "additions": 312, "deletions": 75}, "files": [{"sha": "39679cbed6961566d9d801425c5b6bc445365057", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -218,7 +218,7 @@ $$(LIBUV_MAKEFILE_$(1)): $$(LIBUV_DEPS)\n ifdef CFG_WINDOWSY_$(1)\n $$(LIBUV_LIB_$(1)): $$(LIBUV_DEPS)\n \t$$(Q)$$(MAKE) -C $$(S)src/libuv -f Makefile.mingw \\\n-\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n+\t\tCC=\"$$(CC) $$(CFG_GCCISH_CFLAGS) $$(LIBUV_FLAGS_$$(HOST_$(1))) $$(SNAP_DEFINES)\" \\\n \t\tAR=\"$$(AR_$(1))\" \\\n \t\tV=$$(VERBOSE)\n \t$$(Q)cp $$(S)src/libuv/libuv.a $$@"}, {"sha": "a5848194d05bbb0ff1fe9923bc52feb3777e8205", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -12,14 +12,15 @@ use std::c_str::CString;\n use std::c_str;\n use std::cast::transmute;\n use std::cast;\n-use std::libc::{c_int, c_char, c_void, c_uint};\n+use std::libc::{c_int, c_char, c_void, size_t};\n use std::libc;\n use std::rt::BlockedTask;\n use std::rt::io::{FileStat, IoError};\n use std::rt::io;\n use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n+use std::task;\n use std::vec;\n \n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n@@ -79,7 +80,7 @@ impl FsRequest {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_write(loop_.handle, req,\n                               fd, vec::raw::to_ptr(buf) as *c_void,\n-                              buf.len() as c_uint, offset, cb)\n+                              buf.len() as size_t, offset, cb)\n         })\n     }\n \n@@ -89,7 +90,7 @@ impl FsRequest {\n         do execute(|req, cb| unsafe {\n             uvll::uv_fs_read(loop_.handle, req,\n                              fd, vec::raw::to_ptr(buf) as *c_void,\n-                             buf.len() as c_uint, offset, cb)\n+                             buf.len() as size_t, offset, cb)\n         }).map |req| {\n             req.get_result() as int\n         }\n@@ -297,24 +298,26 @@ impl Drop for FsRequest {\n fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n     -> Result<FsRequest, UvError>\n {\n-    let mut req = FsRequest {\n-        fired: false,\n-        req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n-    };\n-    return match f(req.req, fs_cb) {\n-        0 => {\n-            req.fired = true;\n-            let mut slot = None;\n-            do wait_until_woken_after(&mut slot) {\n-                unsafe { uvll::set_data_for_req(req.req, &slot) }\n-            }\n-            match req.get_result() {\n-                n if n < 0 => Err(UvError(n)),\n-                _ => Ok(req),\n+    return do task::unkillable {\n+        let mut req = FsRequest {\n+            fired: false,\n+            req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n+        };\n+        match f(req.req, fs_cb) {\n+            0 => {\n+                req.fired = true;\n+                let mut slot = None;\n+                do wait_until_woken_after(&mut slot) {\n+                    unsafe { uvll::set_data_for_req(req.req, &slot) }\n+                }\n+                match req.get_result() {\n+                    n if n < 0 => Err(UvError(n)),\n+                    _ => Ok(req),\n+                }\n             }\n-        }\n-        n => Err(UvError(n))\n+            n => Err(UvError(n))\n \n+        }\n     };\n \n     extern fn fs_cb(req: *uvll::uv_fs_t) {"}, {"sha": "80481498881c49440c515f0eddd6e40f5c4a1d8e", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -126,6 +126,15 @@ mod test {\n         tube.recv();\n     }\n \n+    #[test] #[should_fail]\n+    fn smoke_fail() {\n+        let tube = Tube::new();\n+        let cb = ~MyCallback(tube.clone(), 1);\n+        let mut idle = IdleWatcher::new(local_loop(), cb as ~Callback);\n+        idle.resume();\n+        fail!();\n+    }\n+\n     #[test]\n     fn fun_combinations_of_methods() {\n         let mut tube = Tube::new();"}, {"sha": "edb1953b9b1c39b2716f2e980c55ea69f83a908c", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -154,6 +154,26 @@ pub trait UvHandle<T> {\n     }\n }\n \n+pub struct ForbidSwitch {\n+    msg: &'static str,\n+    sched: uint,\n+}\n+\n+impl ForbidSwitch {\n+    fn new(s: &'static str) -> ForbidSwitch {\n+        ForbidSwitch {\n+            msg: s, sched: Local::borrow(|s: &mut Scheduler| s.sched_id())\n+        }\n+    }\n+}\n+\n+impl Drop for ForbidSwitch {\n+    fn drop(&mut self) {\n+        assert!(self.sched == Local::borrow(|s: &mut Scheduler| s.sched_id()),\n+                \"didnt want a scheduler switch: {}\", self.msg);\n+    }\n+}\n+\n pub struct ForbidUnwind {\n     msg: &'static str,\n     failing_before: bool,\n@@ -170,7 +190,7 @@ impl ForbidUnwind {\n impl Drop for ForbidUnwind {\n     fn drop(&mut self) {\n         assert!(self.failing_before == task::failing(),\n-                \"failing sadface {}\", self.msg);\n+                \"didnt want an unwind during: {}\", self.msg);\n     }\n }\n "}, {"sha": "0fc87e4e4fa99e0188bd1860e2871f9de877c627", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -1168,6 +1168,56 @@ mod test {\n         }\n     }\n \n+    #[should_fail] #[test]\n+    fn tcp_listener_fail_cleanup() {\n+        let addr = next_test_ip4();\n+        let w = TcpListener::bind(local_loop(), addr).unwrap();\n+        let _w = w.listen().unwrap();\n+        fail!();\n+    }\n+\n+    #[should_fail] #[test]\n+    fn tcp_stream_fail_cleanup() {\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        let addr = next_test_ip4();\n+\n+        do task::spawn_unlinked { // please no linked failure\n+            let w = TcpListener::bind(local_loop(), addr).unwrap();\n+            let mut w = w.listen().unwrap();\n+            chan.take().send(());\n+            w.accept();\n+        }\n+        port.recv();\n+        let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n+        fail!();\n+    }\n+\n+    #[should_fail] #[test]\n+    fn udp_listener_fail_cleanup() {\n+        let addr = next_test_ip4();\n+        let _w = UdpWatcher::bind(local_loop(), addr).unwrap();\n+        fail!();\n+    }\n+\n+    #[should_fail] #[test]\n+    fn udp_fail_other_task() {\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+\n+        // force the handle to be created on a different scheduler, failure in\n+        // the original task will force a homing operation back to this\n+        // scheduler.\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n+            chan.take().send(w);\n+        }\n+\n+        let _w = port.recv();\n+        fail!();\n+    }\n+\n     #[should_fail]\n     #[test]\n     #[ignore(reason = \"linked failure\")]"}, {"sha": "1b0f352dc4df1dc1b0710574564a5652defe6c95", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -238,3 +238,91 @@ impl RtioUnixAcceptor for PipeAcceptor {\n impl HomingIO for PipeAcceptor {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::cell::Cell;\n+    use std::comm::oneshot;\n+    use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n+    use std::rt::test::next_test_unix;\n+    use std::task;\n+\n+    use super::*;\n+    use super::super::local_loop;\n+\n+    #[test]\n+    fn connect_err() {\n+        match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n+            Ok(*) => fail!(),\n+            Err(*) => {}\n+        }\n+    }\n+\n+    #[test]\n+    fn bind_err() {\n+        match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n+            Ok(*) => fail!(),\n+            Err(e) => assert_eq!(e.name(), ~\"EACCES\"),\n+        }\n+    }\n+\n+    #[test]\n+    fn bind() {\n+        let p = next_test_unix().to_c_str();\n+        match PipeListener::bind(local_loop(), &p) {\n+            Ok(*) => {}\n+            Err(*) => fail!(),\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn bind_fail() {\n+        let p = next_test_unix().to_c_str();\n+        let _w = PipeListener::bind(local_loop(), &p).unwrap();\n+        fail!();\n+    }\n+\n+    #[test]\n+    fn connect() {\n+        let path = next_test_unix();\n+        let path2 = path.clone();\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+\n+        do spawn {\n+            let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n+            let mut p = p.listen().unwrap();\n+            chan.take().send(());\n+            let mut client = p.accept().unwrap();\n+            let mut buf = [0];\n+            assert!(client.read(buf).unwrap() == 1);\n+            assert_eq!(buf[0], 1);\n+            assert!(client.write([2]).is_ok());\n+        }\n+        port.recv();\n+        let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n+        assert!(c.write([1]).is_ok());\n+        let mut buf = [0];\n+        assert!(c.read(buf).unwrap() == 1);\n+        assert_eq!(buf[0], 2);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn connect_fail() {\n+        let path = next_test_unix();\n+        let path2 = path.clone();\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+\n+        do task::spawn_unlinked { // plz no linked failure\n+            let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n+            let mut p = p.listen().unwrap();\n+            chan.take().send(());\n+            p.accept();\n+        }\n+        port.recv();\n+        let _c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n+        fail!()\n+\n+    }\n+}"}, {"sha": "840ae814f35c81625c04d9182538df6bcc361531", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -77,23 +77,18 @@ impl Process {\n                 };\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n+                let process = ~Process {\n+                    handle: handle,\n+                    home: get_handle_to_current_scheduler!(),\n+                    to_wake: None,\n+                    exit_status: None,\n+                    term_signal: None,\n+                };\n                 match unsafe {\n                     uvll::uv_spawn(loop_.handle, handle, &options)\n                 } {\n-                    0 => {\n-                        let process = ~Process {\n-                            handle: handle,\n-                            home: get_handle_to_current_scheduler!(),\n-                            to_wake: None,\n-                            exit_status: None,\n-                            term_signal: None,\n-                        };\n-                        Ok(process.install())\n-                    }\n-                    err => {\n-                        unsafe { uvll::free_handle(handle) }\n-                        Err(UvError(err))\n-                    }\n+                    0 => Ok(process.install()),\n+                    err => Err(UvError(err)),\n                 }\n             }\n         };"}, {"sha": "664875dd19903886eec9edd47dbec4e2c2658433", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -16,7 +16,7 @@ use std::rt::rtio::RtioTimer;\n use std::rt::sched::{Scheduler, SchedHandle};\n \n use uvll;\n-use super::{Loop, UvHandle, ForbidUnwind};\n+use super::{Loop, UvHandle, ForbidUnwind, ForbidSwitch};\n use uvio::HomingIO;\n \n pub struct TimerWatcher {\n@@ -100,7 +100,9 @@ impl RtioTimer for TimerWatcher {\n     }\n }\n \n-extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n+extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n+    let _f = ForbidSwitch::new(\"timer callback can't switch\");\n+    assert_eq!(status, 0);\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     match timer.action.take_unwrap() {\n@@ -168,4 +170,76 @@ mod test {\n         timer.sleep(1);\n         timer.sleep(1);\n     }\n+\n+    #[test] #[should_fail]\n+    fn oneshot_fail() {\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let _port = timer.oneshot(1);\n+        fail!();\n+    }\n+\n+    #[test] #[should_fail]\n+    fn period_fail() {\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let _port = timer.period(1);\n+        fail!();\n+    }\n+\n+    #[test] #[should_fail]\n+    fn normal_fail() {\n+        let _timer = TimerWatcher::new(local_loop());\n+        fail!();\n+    }\n+\n+    #[test]\n+    fn closing_channel_during_drop_doesnt_kill_everything() {\n+        // see issue #10375\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let timer_port = Cell::new(timer.period(1000));\n+\n+        do spawn {\n+            timer_port.take().try_recv();\n+        }\n+\n+        // when we drop the TimerWatcher we're going to destroy the channel,\n+        // which must wake up the task on the other end\n+    }\n+\n+    #[test]\n+    fn sender_goes_away_oneshot() {\n+        let port = {\n+            let mut timer = TimerWatcher::new(local_loop());\n+            timer.oneshot(1000)\n+        };\n+        assert_eq!(port.try_recv(), None);\n+    }\n+\n+    #[test]\n+    fn sender_goes_away_period() {\n+        let port = {\n+            let mut timer = TimerWatcher::new(local_loop());\n+            timer.period(1000)\n+        };\n+        assert_eq!(port.try_recv(), None);\n+    }\n+\n+    #[test]\n+    fn receiver_goes_away_oneshot() {\n+        let mut timer1 = TimerWatcher::new(local_loop());\n+        timer1.oneshot(1);\n+        let mut timer2 = TimerWatcher::new(local_loop());\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    }\n+\n+    #[test]\n+    fn receiver_goes_away_period() {\n+        let mut timer1 = TimerWatcher::new(local_loop());\n+        timer1.period(1);\n+        let mut timer2 = TimerWatcher::new(local_loop());\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    }\n }"}, {"sha": "5f68ac5e71d0ba5e568eda058afa3285ece185da", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -676,9 +676,9 @@ externfn!(fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n externfn!(fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n                           cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                         len: c_uint, offset: i64, cb: uv_fs_cb) -> c_int)\n+                         len: size_t, offset: i64, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                        len: c_uint, offset: i64, cb: uv_fs_cb) -> c_int)\n+                        len: size_t, offset: i64, cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n                          cb: uv_fs_cb) -> c_int)\n externfn!(fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,"}, {"sha": "ce9504a5b43d9b01abec0b4a34be4ac175199b22", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -423,7 +423,11 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n /// closure if no error occurred.\n pub fn result<T>(cb: &fn() -> T) -> Result<T, IoError> {\n     let mut err = None;\n-    let ret = io_error::cond.trap(|e| err = Some(e)).inside(cb);\n+    let ret = io_error::cond.trap(|e| {\n+        if err.is_none() {\n+            err = Some(e);\n+        }\n+    }).inside(cb);\n     match err {\n         Some(e) => Err(e),\n         None => Ok(ret),"}, {"sha": "6d4f29182dda6cf19b6fc1e079a9f25f98aa541b", "filename": "src/libstd/rt/io/native/file.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Ffile.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -80,18 +80,20 @@ pub type fd_t = libc::c_int;\n \n pub struct FileDesc {\n     priv fd: fd_t,\n+    priv close_on_drop: bool,\n }\n \n impl FileDesc {\n     /// Create a `FileDesc` from an open C file descriptor.\n     ///\n     /// The `FileDesc` will take ownership of the specified file descriptor and\n-    /// close it upon destruction.\n+    /// close it upon destruction if the `close_on_drop` flag is true, otherwise\n+    /// it will not close the file descriptor when this `FileDesc` is dropped.\n     ///\n     /// Note that all I/O operations done on this object will be *blocking*, but\n     /// they do not require the runtime to be active.\n-    pub fn new(fd: fd_t) -> FileDesc {\n-        FileDesc { fd: fd }\n+    pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n+        FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n }\n \n@@ -137,7 +139,9 @@ impl Writer for FileDesc {\n impl Drop for FileDesc {\n     #[fixed_stack_segment] #[inline(never)]\n     fn drop(&mut self) {\n-        unsafe { libc::close(self.fd); }\n+        if self.close_on_drop {\n+            unsafe { libc::close(self.fd); }\n+        }\n     }\n }\n \n@@ -245,8 +249,8 @@ mod tests {\n         // opening or closing files.\n         unsafe {\n             let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input);\n-            let mut writer = FileDesc::new(out);\n+            let mut reader = FileDesc::new(input, true);\n+            let mut writer = FileDesc::new(out, true);\n \n             writer.write(bytes!(\"test\"));\n             let mut buf = [0u8, ..4];"}, {"sha": "f5c39de1bf44ecfd76e69f5bf274fea4193990a2", "filename": "src/libstd/rt/io/native/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fprocess.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -105,9 +105,9 @@ impl Process {\n         Process {\n             pid: res.pid,\n             handle: res.handle,\n-            input: in_pipe.map(|pipe| file::FileDesc::new(pipe.out)),\n-            output: out_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n-            error: err_pipe.map(|pipe| file::FileDesc::new(pipe.input)),\n+            input: in_pipe.map(|pipe| file::FileDesc::new(pipe.out, true)),\n+            output: out_pipe.map(|pipe| file::FileDesc::new(pipe.input, true)),\n+            error: err_pipe.map(|pipe| file::FileDesc::new(pipe.input, true)),\n             exit_code: None,\n         }\n     }"}, {"sha": "ddfbb9a8f8c28f2edf0f5578465876ad6c5dd20e", "filename": "src/libstd/rt/io/native/stdio.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnative%2Fstdio.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -36,10 +36,8 @@ pub struct StdIn {\n \n impl StdIn {\n     /// Duplicates the stdin file descriptor, returning an io::Reader\n-    #[fixed_stack_segment] #[inline(never)]\n     pub fn new() -> StdIn {\n-        let fd = unsafe { libc::dup(libc::STDIN_FILENO) };\n-        StdIn { fd: file::FileDesc::new(fd) }\n+        StdIn { fd: file::FileDesc::new(libc::STDIN_FILENO, false) }\n     }\n }\n \n@@ -54,10 +52,8 @@ pub struct StdOut {\n \n impl StdOut {\n     /// Duplicates the specified file descriptor, returning an io::Writer\n-    #[fixed_stack_segment] #[inline(never)]\n     pub fn new(fd: file::fd_t) -> StdOut {\n-        let fd = unsafe { libc::dup(fd) };\n-        StdOut { fd: file::FileDesc::new(fd) }\n+        StdOut { fd: file::FileDesc::new(fd, false) }\n     }\n }\n "}, {"sha": "fed6b9daa64cd376340ce6349b0dd8fa782e7fb1", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -160,11 +160,7 @@ mod test {\n             let port = timer.oneshot(100000000000);\n             timer.sleep(1); // this should invalidate the port\n \n-            let port = Cell::new(port);\n-            let ret = do task::try {\n-                port.take().recv();\n-            };\n-            assert!(ret.is_err());\n+            assert_eq!(port.try_recv(), None);\n         }\n     }\n "}, {"sha": "3ef57710344dc06c700b834770099fa83a292dde", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -42,8 +42,7 @@ macro_rules! rtassert (\n \n \n macro_rules! rtabort (\n-    ($msg:expr $($arg:tt)*) => ( {\n-        ::rt::util::abort(format!(concat!(file!(), \":\", line!(), \" \", $msg)\n-                                  $($arg)*));\n+    ($($arg:tt)*) => ( {\n+        ::rt::util::abort(format!($($arg)*));\n     } )\n )"}, {"sha": "fe23944397d87dde8a576d05abdfa91828c1f22c", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -436,13 +436,13 @@ mod tests {\n     }\n \n     fn writeclose(fd: c_int, s: &str) {\n-        let mut writer = file::FileDesc::new(fd);\n+        let mut writer = file::FileDesc::new(fd, true);\n         writer.write(s.as_bytes());\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n         let mut res = ~[];\n-        let mut reader = file::FileDesc::new(fd);\n+        let mut reader = file::FileDesc::new(fd, true);\n         let mut buf = [0, ..1024];\n         loop {\n             match reader.read(buf) {"}, {"sha": "f3be486a25ab2b3cf3554731a3e7446d252662af", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -93,8 +93,7 @@ rust_sockaddr_size() {\n \n extern \"C\" struct sockaddr*\n rust_malloc_ip4_addr(char *name, int port) {\n-    struct sockaddr_in *addr = (struct sockaddr_in*) malloc(sizeof(struct sockaddr_in));\n-    memset(addr, 0, sizeof(struct sockaddr_in));\n+    struct sockaddr_in *addr = (struct sockaddr_in*) calloc(1, rust_sockaddr_size());\n     assert(addr != NULL);\n     addr->sin_port = htons(port);\n     assert(uv_inet_pton(AF_INET, name, &addr->sin_addr) == 0);\n@@ -104,8 +103,7 @@ rust_malloc_ip4_addr(char *name, int port) {\n \n extern \"C\" struct sockaddr*\n rust_malloc_ip6_addr(char *name, int port) {\n-    struct sockaddr_in6 *addr = (struct sockaddr_in6*) malloc(sizeof(struct sockaddr_in6));\n-    memset(addr, 0, sizeof(struct sockaddr));\n+    struct sockaddr_in6 *addr = (struct sockaddr_in6*) calloc(1, rust_sockaddr_size());\n     assert(addr != NULL);\n     addr->sin6_port = htons(port);\n     assert(uv_inet_pton(AF_INET6, name, &addr->sin6_addr) == 0);"}, {"sha": "629a807266182f10330717afb453fa082bb013ea", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -67,7 +67,8 @@ pub fn main() {\n     call_that(|x, y| *x + *y - z);\n \n     call_cramped(|| 1, || unsafe {\n-        cast::transmute(&100)\n+        static a: uint = 100;\n+        cast::transmute(&a)\n     });\n \n     // External functions"}, {"sha": "f45889eeb03b6476dbd81893fbdc01c1cb5c9f1d", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86a321b65dcc5253f61202b2fdaac41f275344ce/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=86a321b65dcc5253f61202b2fdaac41f275344ce", "patch": "@@ -23,8 +23,8 @@\n //\n // See #9341\n \n+use std::rt::io;\n use std::rt::io::process::{Process, ProcessConfig, CreatePipe, Ignored};\n-use std::rt::io::{Reader, Writer};\n use std::str;\n \n #[test]\n@@ -55,10 +55,10 @@ fn smoke_failure() {\n         cwd: None,\n         io: io,\n     };\n-    let p = Process::new(args);\n-    assert!(p.is_some());\n-    let mut p = p.unwrap();\n-    assert!(p.wait() != 0);\n+    match io::result(|| Process::new(args)) {\n+        Ok(*) => fail!(),\n+        Err(*) => {}\n+    }\n }\n \n #[test]"}]}