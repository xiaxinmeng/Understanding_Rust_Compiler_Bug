{"sha": "d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YTI3YTBlMGM2ZTY0ZDE1MzI0NDNhNmJkNDViMzQxNmU3NTk3ZmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-27T01:23:45Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-27T01:23:45Z"}, "message": "rustc: Translate monomorphic intra-crate automatically-derived methods that follow the \"eq\" format", "tree": {"sha": "84610cc23f57bece7e6c9ad918b8be2402e0a9c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84610cc23f57bece7e6c9ad918b8be2402e0a9c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "html_url": "https://github.com/rust-lang/rust/commit/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7ec183b34805ba6af0c49581639b16dbd33e47a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ec183b34805ba6af0c49581639b16dbd33e47a", "html_url": "https://github.com/rust-lang/rust/commit/c7ec183b34805ba6af0c49581639b16dbd33e47a"}], "stats": {"total": 299, "additions": 266, "deletions": 33}, "files": [{"sha": "38ccb64899ca93dbf94fc11d0f85bffec9b38b55", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -74,7 +74,7 @@ enum ast_node {\n     // Destructor for a class\n     node_dtor(~[ty_param], @class_dtor, def_id, @path),\n     node_block(blk),\n-    node_struct_ctor(@struct_def, @item, @path)\n+    node_struct_ctor(@struct_def, @item, @path),\n }\n \n type map = std::map::HashMap<node_id, ast_node>;"}, {"sha": "40792ce45ed4f39d6ee1c67188d18e4e99bc1731", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -42,6 +42,7 @@ use util::ppaux;\n use util::ppaux::{ty_to_str, ty_to_short_str};\n use syntax::diagnostic::expect;\n use util::common::indenter;\n+use ty::DerivedMethodInfo;\n \n use build::*;\n use shape::*;\n@@ -1843,7 +1844,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         match ms_opt {\n             None => {\n                 deriving::trans_deriving_impl(ccx, *path, item.ident, tps,\n-                                              None, item.id);\n+                                              item.id);\n             }\n             Some(ms) => {\n                 meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n@@ -2079,6 +2080,20 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     match ccx.item_vals.find(id) {\n       Some(v) => v,\n       None => {\n+        // First, check whether we need to automatically generate a method\n+        // via the deriving mechanism.\n+        match ccx.tcx.automatically_derived_methods.find(local_def(id)) {\n+            None => {}  // Continue.\n+            Some(ref derived_method_info) => {\n+                // XXX: Mark as internal if necessary.\n+                let llfn = register_deriving_method(\n+                    ccx, id, derived_method_info);\n+                ccx.item_vals.insert(id, llfn);\n+                return llfn;\n+            }\n+        }\n+\n+        // Failing that, look for an item.\n         let mut exprt = false;\n         let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n@@ -2226,6 +2241,32 @@ fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n     llfn\n }\n \n+fn register_deriving_method(ccx: @crate_ctxt,\n+                            id: ast::node_id,\n+                            derived_method_info: &DerivedMethodInfo) ->\n+                            ValueRef {\n+    // Find the path of the item.\n+    let path, span;\n+    match ccx.tcx.items.get(derived_method_info.containing_impl.node) {\n+        ast_map::node_item(item, found_path) => {\n+            path = found_path;\n+            span = item.span;\n+        }\n+        _ => {\n+            ccx.tcx.sess.bug(~\"derived method info containing impl didn't \\\n+                               refer to an item\");\n+        }\n+    }\n+\n+    let path = vec::append(*path, ~[\n+        ast_map::path_name(derived_method_info.method_info.ident)\n+    ]);\n+    let mty = ty::lookup_item_type(ccx.tcx, local_def(id)).ty;\n+    let llfn = register_fn_full(ccx, span, path, id, mty);\n+    // XXX: Inline hint.\n+    llfn\n+}\n+\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_constant\");"}, {"sha": "bd1facdddce705c820669702a984d4bb5b7bdd1f", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -210,23 +210,30 @@ fn trans_fn_ref_with_vtables(\n     // intrinsic, or is a default method.  In particular, if we see an\n     // intrinsic that is inlined from a different crate, we want to reemit the\n     // intrinsic instead of trying to call it in the other crate.\n-    let must_monomorphise = type_params.len() > 0 ||\n-        opt_impl_did.is_some() || {\n-        if def_id.crate == ast::local_crate {\n-            let map_node = session::expect(\n-                ccx.sess,\n-                ccx.tcx.items.find(def_id.node),\n-                || fmt!(\"local item should be in ast map\"));\n-\n-            match map_node {\n-              ast_map::node_foreign_item(\n-                  _, ast::foreign_abi_rust_intrinsic, _) => true,\n-              _ => false\n+    let must_monomorphise;\n+    if type_params.len() > 0 || opt_impl_did.is_some() {\n+        must_monomorphise = true;\n+    } else if ccx.tcx.automatically_derived_methods.contains_key(def_id) {\n+        must_monomorphise = false;\n+    } else if def_id.crate == ast::local_crate {\n+        let map_node = session::expect(\n+            ccx.sess,\n+            ccx.tcx.items.find(def_id.node),\n+            || fmt!(\"local item should be in ast map\"));\n+\n+        match map_node {\n+            ast_map::node_foreign_item(_,\n+                                       ast::foreign_abi_rust_intrinsic,\n+                                       _) => {\n+                must_monomorphise = true;\n+            }\n+            _ => {\n+                must_monomorphise = false;\n             }\n-        } else {\n-            false\n         }\n-    };\n+    } else {\n+        must_monomorphise = false;\n+    }\n \n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n@@ -434,6 +441,15 @@ fn trans_call_inner(\n             _ => {}\n         }\n \n+        // Uncomment this to debug calls.\n+        /*\n+        io::println(fmt!(\"calling: %s\", bcx.val_str(llfn)));\n+        for llargs.each |llarg| {\n+            io::println(fmt!(\"arg: %s\", bcx.val_str(*llarg)));\n+        }\n+        io::println(\"---\");\n+        */\n+\n         // If the block is terminated, then one or more of the args\n         // has type _|_. Since that means it diverges, the code for\n         // the call itself is unreachable."}, {"sha": "0e4a72f563d31465e1453c0308add4d055bcc774", "filename": "src/rustc/middle/trans/deriving.rs", "status": "modified", "additions": 111, "deletions": 6, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -1,21 +1,126 @@\n // Translation of automatically-derived trait implementations. This handles\n // enums and structs only; other types cannot be automatically derived.\n \n-use middle::trans::base::get_insn_ctxt;\n-use middle::trans::common::crate_ctxt;\n-use syntax::ast::{ident, node_id, ty_param};\n+use lib::llvm::llvm;\n+use middle::trans::base::{finish_fn, get_insn_ctxt, get_item_val};\n+use middle::trans::base::{new_fn_ctxt, sub_block, top_scope_block};\n+use middle::trans::build::{Br, CondBr, GEPi, Load, PointerCast, Store};\n+use middle::trans::build::{ValueRef};\n+use middle::trans::callee;\n+use middle::trans::callee::{ArgVals, Callee, DontAutorefArg, Method};\n+use middle::trans::callee::{MethodData};\n+use middle::trans::common;\n+use middle::trans::common::{C_bool, T_ptr, block, crate_ctxt};\n+use middle::trans::expr::SaveIn;\n+use middle::trans::type_of::type_of;\n+use middle::typeck::method_static;\n+use syntax::ast;\n+use syntax::ast::{def_id, ident, node_id, ty_param};\n use syntax::ast_map::path;\n+use syntax::ast_util;\n+use syntax::ast_util::local_def;\n \n /// The main \"translation\" pass for automatically-derived impls. Generates\n /// code for monomorphic methods only. Other methods will be generated when\n /// they are invoked with specific type parameters; see\n /// `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n-                           tps: ~[ty_param], _self_ty: Option<ty::t>,\n-                           _id: node_id) {\n+                           tps: ~[ty_param], id: node_id) {\n     let _icx = ccx.insn_ctxt(\"deriving::trans_deriving_impl\");\n     if tps.len() > 0 { return; }\n \n-    // XXX: Unimplemented.\n+    let impl_def_id = local_def(id);\n+    let self_ty = ty::lookup_item_type(ccx.tcx, impl_def_id);\n+    let method_dids = ccx.tcx.automatically_derived_methods_for_impl.get(\n+        impl_def_id);\n+\n+    for method_dids.each |method_did| {\n+        let llfn = get_item_val(ccx, method_did.node);\n+        match ty::get(self_ty.ty).sty {\n+            ty::ty_class(*) => {\n+                trans_deriving_struct_method(ccx, llfn, impl_def_id,\n+                                             self_ty.ty);\n+            }\n+            _ => {\n+                ccx.tcx.sess.unimpl(~\"translation of non-struct deriving \\\n+                                      method\");\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_deriving_struct_method(ccx: @crate_ctxt, llfn: ValueRef,\n+                                impl_did: def_id, self_ty: ty::t) {\n+    let _icx = ccx.insn_ctxt(\"trans_deriving_struct_method\");\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n+    let top_bcx = top_scope_block(fcx, None);\n+    let lltop = top_bcx.llbb;\n+    let mut bcx = top_bcx;\n+\n+    let llselfty = type_of(ccx, self_ty);\n+    let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n+    let llotherval = llvm::LLVMGetParam(llfn, 2);\n+\n+    let struct_field_tys;\n+    match ty::get(self_ty).sty {\n+        ty::ty_class(struct_id, ref struct_substs) => {\n+            struct_field_tys = ty::class_items_as_fields(\n+                ccx.tcx, struct_id, struct_substs);\n+        }\n+        _ => {\n+            ccx.tcx.sess.bug(~\"passed non-struct to \\\n+                               trans_deriving_struct_method\");\n+        }\n+    }\n+\n+    // Iterate over every element of the struct.\n+    for ccx.tcx.deriving_struct_methods.get(impl_did).eachi\n+            |i, derived_method_info| {\n+        let target_method_def_id;\n+        match *derived_method_info {\n+            method_static(did) => target_method_def_id = did,\n+            _ => fail ~\"derived method didn't resolve to a static method\"\n+        }\n+\n+        let fn_expr_ty =\n+            ty::lookup_item_type(ccx.tcx, target_method_def_id).ty;\n+\n+        let llselfval = GEPi(bcx, llselfval, [0, 0, i]);\n+        let llotherval = GEPi(bcx, llotherval, [0, 0, i]);\n+\n+        // XXX: Cross-crate won't work!\n+        let llfn = get_item_val(ccx, target_method_def_id.node);\n+        let cb: &fn(block) -> Callee = |block| {\n+            Callee {\n+                bcx: block,\n+                data: Method(MethodData {\n+                    llfn: llfn,\n+                    llself: llselfval,\n+                    self_ty: struct_field_tys[i].mt.ty,\n+                    self_mode: ast::by_copy\n+                })\n+            }\n+        };\n+\n+        bcx = callee::trans_call_inner(bcx,\n+                                       None,\n+                                       fn_expr_ty,\n+                                       ty::mk_bool(ccx.tcx),\n+                                       cb,\n+                                       ArgVals(~[llotherval]),\n+                                       SaveIn(fcx.llretptr),\n+                                       DontAutorefArg);\n+\n+        // Return immediately if the call returned false.\n+        let next_block = sub_block(top_bcx, ~\"next\");\n+        let llcond = Load(bcx, fcx.llretptr);\n+        CondBr(bcx, llcond, next_block.llbb, fcx.llreturn);\n+        bcx = next_block;\n+    }\n+\n+    Store(bcx, C_bool(true), fcx.llretptr);\n+    Br(bcx, fcx.llreturn);\n+\n+    finish_fn(fcx, lltop);\n }\n "}, {"sha": "8af38e96999f38b7e23fd20f864f7f51ffc15922", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -200,6 +200,7 @@ export provided_trait_methods;\n export trait_supertraits;\n export AutoAdjustment;\n export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n+export DerivedMethodInfo;\n \n // Data types\n \n@@ -333,6 +334,11 @@ struct InstantiatedTraitRef {\n     tpt: ty_param_substs_and_ty\n }\n \n+struct DerivedMethodInfo {\n+    method_info: @middle::resolve::MethodInfo,\n+    containing_impl: ast::def_id\n+}\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n@@ -379,7 +385,17 @@ type ctxt =\n       provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n       supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n       deriving_struct_methods: HashMap<ast::def_id,\n-                                       @~[typeck::method_origin]>};\n+                                       @~[typeck::method_origin]>,\n+\n+      // A mapping from the def ID of a method that was automatically derived\n+      // to information about it.\n+      automatically_derived_methods: HashMap<ast::def_id, DerivedMethodInfo>,\n+\n+      // A mapping from the def ID of an impl to the IDs of the derived\n+      // methods within it.\n+      automatically_derived_methods_for_impl:\n+            HashMap<ast::def_id, @~[ast::def_id]>\n+      };\n \n enum tbox_flag {\n     has_params = 1,\n@@ -942,7 +958,9 @@ fn mk_ctxt(s: session::Session,\n       legacy_boxed_traits: HashMap(),\n       provided_method_sources: HashMap(),\n       supertraits: HashMap(),\n-      deriving_struct_methods: HashMap()}\n+      deriving_struct_methods: HashMap(),\n+      automatically_derived_methods: HashMap(),\n+      automatically_derived_methods_for_impl: HashMap()}\n }\n \n "}, {"sha": "d0ec2b3cfc5547baf928f4c6464726cae9dcdacf", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -9,10 +9,10 @@ use metadata::csearch::{get_impls_for_mod};\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{ProvidedMethodSource, get, lookup_item_type, subst, t};\n-use middle::ty::{ty_box, ty_uniq, ty_ptr, ty_rptr, ty_enum};\n-use middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n-use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec};\n+use middle::ty::{DerivedMethodInfo, ProvidedMethodSource, get};\n+use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_class};\n+use middle::ty::{ty_bool, ty_enum, ty_int, ty_nil, ty_ptr, ty_rptr, ty_uint};\n+use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec, ty_uniq};\n use middle::ty::{ty_fn, ty_trait, ty_tup, ty_infer};\n use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n@@ -592,17 +592,33 @@ impl CoherenceChecker {\n     }\n \n     fn add_automatically_derived_methods_from_trait(\n-        all_methods: &mut ~[@MethodInfo], trait_did: def_id, self_ty: ty::t) {\n+            all_methods: &mut ~[@MethodInfo],\n+            trait_did: def_id,\n+            self_ty: ty::t,\n+            impl_did: def_id) {\n         let tcx = self.crate_context.tcx;\n+        let new_method_dids = dvec::DVec();\n         for (*ty::trait_methods(tcx, trait_did)).each |method| {\n             // Generate a def ID for each node.\n             let new_def_id = local_def(tcx.sess.next_node_id());\n-            all_methods.push(@{\n+            let method_info = @{\n                 did: new_def_id,\n                 n_tps: method.tps.len(),\n                 ident: method.ident,\n                 self_type: method.self_ty\n-            });\n+            };\n+            all_methods.push(method_info);\n+\n+            // Note that this method was automatically derived so that trans\n+            // can handle it differently.\n+            let derived_method_info = DerivedMethodInfo {\n+                method_info: method_info,\n+                containing_impl: impl_did\n+            };\n+            tcx.automatically_derived_methods.insert(new_def_id,\n+                                                     derived_method_info);\n+\n+            new_method_dids.push(new_def_id);\n \n             // Additionally, generate the type for the derived method and add\n             // it to the type cache.\n@@ -615,6 +631,10 @@ impl CoherenceChecker {\n                 ty: ty::subst(tcx, &substs, ty::mk_fn(tcx, method.fty))\n             });\n         }\n+\n+        let new_method_dids = @dvec::unwrap(move new_method_dids);\n+        tcx.automatically_derived_methods_for_impl.insert(impl_did,\n+                                                          new_method_dids);\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n@@ -651,7 +671,8 @@ impl CoherenceChecker {\n                             let trait_did =\n                                 self.trait_ref_to_trait_def_id(*trait_ref);\n                             self.add_automatically_derived_methods_from_trait(\n-                                &mut methods, trait_did, self_ty.ty);\n+                                &mut methods, trait_did, self_ty.ty,\n+                                local_def(item.id));\n                         }\n                     }\n                 }"}, {"sha": "04167893507a95b73755f87c935b9ac6a8442e81", "filename": "src/test/run-pass/deriving-simple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5a27a0e0c6e64d1532443a6bd45b3416e7597fe/src%2Ftest%2Frun-pass%2Fderiving-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-simple.rs?ref=d5a27a0e0c6e64d1532443a6bd45b3416e7597fe", "patch": "@@ -0,0 +1,32 @@\n+trait MyEq {\n+    pure fn eq(other: &self) -> bool;\n+}\n+\n+struct A {\n+    x: int\n+}\n+\n+struct B {\n+    x: A,\n+    y: A,\n+    z: A\n+}\n+\n+impl A : MyEq {\n+    pure fn eq(other: &A) -> bool {\n+        unsafe { io::println(fmt!(\"eq %d %d\", self.x, other.x)); }\n+        self.x == other.x\n+    }\n+}\n+\n+impl B : MyEq;\n+\n+fn main() {\n+    let b = B { x: A { x: 1 }, y: A { x: 2 }, z: A { x: 3 } };\n+    let c = B { x: A { x: 1 }, y: A { x: 3 }, z: A { x: 4 } };\n+    assert b.eq(&b);\n+    assert c.eq(&c);\n+    assert !b.eq(&c);\n+    assert !c.eq(&b);\n+}\n+"}]}