{"sha": "e118eb6c7970385fbcdd688d03975f65d88e642e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMThlYjZjNzk3MDM4NWZiY2RkNjg4ZDAzOTc1ZjY1ZDg4ZTY0MmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T20:57:23Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-01T22:59:01Z"}, "message": "librustc_data_structures: Unconfigure tests during normal build", "tree": {"sha": "52f7b93573ee2e7c0963f66f4907fc44e6c15443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f7b93573ee2e7c0963f66f4907fc44e6c15443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e118eb6c7970385fbcdd688d03975f65d88e642e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e118eb6c7970385fbcdd688d03975f65d88e642e", "html_url": "https://github.com/rust-lang/rust/commit/e118eb6c7970385fbcdd688d03975f65d88e642e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e118eb6c7970385fbcdd688d03975f65d88e642e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca0ef0fcf66b0fe913c19a3a00729af4494866e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca0ef0fcf66b0fe913c19a3a00729af4494866e6", "html_url": "https://github.com/rust-lang/rust/commit/ca0ef0fcf66b0fe913c19a3a00729af4494866e6"}], "stats": {"total": 2349, "additions": 1180, "deletions": 1169}, "files": [{"sha": "9b63a892b8c93773a25cb3dd8ba100b00cdd32a1", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -3,6 +3,9 @@\n \n use std::str;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub const MAX_BASE: usize = 64;\n pub const ALPHANUMERIC_ONLY: usize = 62;\n pub const CASE_INSENSITIVE: usize = 36;\n@@ -38,24 +41,3 @@ pub fn encode(n: u128, base: usize) -> String {\n     push_str(n, base, &mut s);\n     s\n }\n-\n-#[test]\n-fn test_encode() {\n-    fn test(n: u128, base: usize) {\n-        assert_eq!(Ok(n), u128::from_str_radix(&encode(n, base), base as u32));\n-    }\n-\n-    for base in 2..37 {\n-        test(0, base);\n-        test(1, base);\n-        test(35, base);\n-        test(36, base);\n-        test(37, base);\n-        test(u64::max_value() as u128, base);\n-        test(u128::max_value(), base);\n-\n-        for i in 0 .. 1_000 {\n-            test(i * 983, base);\n-        }\n-    }\n-}"}, {"sha": "0b0a8c5e256e47cd1fc93e4a3525efb1d5ac6721", "filename": "src/librustc_data_structures/base_n/tests.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,22 @@\n+use super::*;\n+\n+#[test]\n+fn test_encode() {\n+    fn test(n: u128, base: usize) {\n+        assert_eq!(Ok(n), u128::from_str_radix(&encode(n, base), base as u32));\n+    }\n+\n+    for base in 2..37 {\n+        test(0, base);\n+        test(1, base);\n+        test(35, base);\n+        test(36, base);\n+        test(37, base);\n+        test(u64::max_value() as u128, base);\n+        test(u128::max_value(), base);\n+\n+        for i in 0 .. 1_000 {\n+            test(i * 983, base);\n+        }\n+    }\n+}"}, {"sha": "6d1e1abbcef1d0c9692bd733f11c443be83a18d2", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -1,5 +1,5 @@\n #[cfg(test)]\n-mod test;\n+mod tests;\n \n /// Uses a sorted slice `data: &[E]` as a kind of \"multi-map\". The\n /// `key_fn` extracts a key of type `K` from the data, and this"}, {"sha": "d74febb5c0fc4a13e2530de71982520e3a944fcf", "filename": "src/librustc_data_structures/binary_search_util/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "previous_filename": "src/librustc_data_structures/binary_search_util/test.rs"}, {"sha": "fe8ef642430adcc6bd7628034a61208be730b4b0", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 2, "deletions": 368, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -5,10 +5,9 @@ use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::slice;\n+\n #[cfg(test)]\n-extern crate test;\n-#[cfg(test)]\n-use test::Bencher;\n+mod tests;\n \n pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n@@ -983,368 +982,3 @@ fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     let mask = 1 << (elem % WORD_BITS);\n     (word_index, mask)\n }\n-\n-#[test]\n-fn test_new_filled() {\n-    for i in 0..128 {\n-        let idx_buf = BitSet::new_filled(i);\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..i).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn bitset_iter_works() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(100);\n-    bitset.insert(1);\n-    bitset.insert(10);\n-    bitset.insert(19);\n-    bitset.insert(62);\n-    bitset.insert(63);\n-    bitset.insert(64);\n-    bitset.insert(65);\n-    bitset.insert(66);\n-    bitset.insert(99);\n-    assert_eq!(\n-        bitset.iter().collect::<Vec<_>>(),\n-        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n-    );\n-}\n-\n-#[test]\n-fn bitset_iter_works_2() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n-    bitset.insert(0);\n-    bitset.insert(127);\n-    bitset.insert(191);\n-    bitset.insert(255);\n-    bitset.insert(319);\n-    assert_eq!(bitset.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n-}\n-\n-#[test]\n-fn union_two_sets() {\n-    let mut set1: BitSet<usize> = BitSet::new_empty(65);\n-    let mut set2: BitSet<usize> = BitSet::new_empty(65);\n-    assert!(set1.insert(3));\n-    assert!(!set1.insert(3));\n-    assert!(set2.insert(5));\n-    assert!(set2.insert(64));\n-    assert!(set1.union(&set2));\n-    assert!(!set1.union(&set2));\n-    assert!(set1.contains(3));\n-    assert!(!set1.contains(4));\n-    assert!(set1.contains(5));\n-    assert!(!set1.contains(63));\n-    assert!(set1.contains(64));\n-}\n-\n-#[test]\n-fn hybrid_bitset() {\n-    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    assert!(sparse038.is_empty());\n-    assert!(sparse038.insert(0));\n-    assert!(sparse038.insert(1));\n-    assert!(sparse038.insert(8));\n-    assert!(sparse038.insert(3));\n-    assert!(!sparse038.insert(3));\n-    assert!(sparse038.remove(1));\n-    assert!(!sparse038.is_empty());\n-    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n-\n-    for i in 0..256 {\n-        if i == 0 || i == 3 || i == 8 {\n-            assert!(sparse038.contains(i));\n-        } else {\n-            assert!(!sparse038.contains(i));\n-        }\n-    }\n-\n-    let mut sparse01358 = sparse038.clone();\n-    assert!(sparse01358.insert(1));\n-    assert!(sparse01358.insert(5));\n-    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n-\n-    let mut dense10 = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(dense10.insert(i));\n-    }\n-    assert!(!dense10.is_empty());\n-    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n-\n-    let mut dense256 = HybridBitSet::new_empty(256);\n-    assert!(dense256.is_empty());\n-    dense256.insert_all();\n-    assert!(!dense256.is_empty());\n-    for i in 0..256 {\n-        assert!(dense256.contains(i));\n-    }\n-\n-    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n-    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n-    assert!(dense10.superset(&sparse038));      // dense + sparse\n-    assert!(dense10.superset(&dense10));        // dense + dense (self)\n-    assert!(dense256.superset(&dense10));       // dense + dense\n-\n-    let mut hybrid = sparse038;\n-    assert!(!sparse01358.union(&hybrid));       // no change\n-    assert!(hybrid.union(&sparse01358));\n-    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n-    assert!(!dense10.union(&sparse01358));\n-    assert!(!dense256.union(&dense10));\n-    let mut dense = dense10;\n-    assert!(dense.union(&dense256));\n-    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n-    assert!(hybrid.union(&dense256));\n-    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n-\n-    assert_eq!(dense256.iter().count(), 256);\n-    let mut dense0 = dense256;\n-    for i in 0..256 {\n-        assert!(dense0.remove(i));\n-    }\n-    assert!(!dense0.remove(0));\n-    assert!(dense0.is_empty());\n-}\n-\n-#[test]\n-fn grow() {\n-    let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);\n-    for index in 0..65 {\n-        assert!(set.insert(index));\n-        assert!(!set.insert(index));\n-    }\n-    set.ensure(128);\n-\n-    // Check if the bits set before growing are still set\n-    for index in 0..65 {\n-        assert!(set.contains(index));\n-    }\n-\n-    // Check if the new bits are all un-set\n-    for index in 65..128 {\n-        assert!(!set.contains(index));\n-    }\n-\n-    // Check that we can set all new bits without running out of bounds\n-    for index in 65..128 {\n-        assert!(set.insert(index));\n-        assert!(!set.insert(index));\n-    }\n-}\n-\n-#[test]\n-fn matrix_intersection() {\n-    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n-\n-    // (*) Elements reachable from both 2 and 65.\n-\n-    matrix.insert(2, 3);\n-    matrix.insert(2, 6);\n-    matrix.insert(2, 10); // (*)\n-    matrix.insert(2, 64); // (*)\n-    matrix.insert(2, 65);\n-    matrix.insert(2, 130);\n-    matrix.insert(2, 160); // (*)\n-\n-    matrix.insert(64, 133);\n-\n-    matrix.insert(65, 2);\n-    matrix.insert(65, 8);\n-    matrix.insert(65, 10); // (*)\n-    matrix.insert(65, 64); // (*)\n-    matrix.insert(65, 68);\n-    matrix.insert(65, 133);\n-    matrix.insert(65, 160); // (*)\n-\n-    let intersection = matrix.intersect_rows(2, 64);\n-    assert!(intersection.is_empty());\n-\n-    let intersection = matrix.intersect_rows(2, 65);\n-    assert_eq!(intersection, &[10, 64, 160]);\n-}\n-\n-#[test]\n-fn matrix_iter() {\n-    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n-    matrix.insert(3, 22);\n-    matrix.insert(3, 75);\n-    matrix.insert(2, 99);\n-    matrix.insert(4, 0);\n-    matrix.union_rows(3, 5);\n-    matrix.insert_all_into_row(6);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(3), expected.len());\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(4), expected.len());\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(5), expected.len());\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    assert_eq!(matrix.count(6), 100);\n-    let mut count = 0;\n-    for (idx, i) in matrix.iter(6).enumerate() {\n-        assert_eq!(idx, i);\n-        count += 1;\n-    }\n-    assert_eq!(count, 100);\n-\n-    if let Some(i) = matrix.iter(7).next() {\n-        panic!(\"expected no elements in row, but contains element {:?}\", i);\n-    }\n-}\n-\n-#[test]\n-fn sparse_matrix_iter() {\n-    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n-    matrix.insert(3, 22);\n-    matrix.insert(3, 75);\n-    matrix.insert(2, 99);\n-    matrix.insert(4, 0);\n-    matrix.union_rows(3, 5);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-}\n-\n-/// Merge dense hybrid set into empty sparse hybrid set.\n-#[bench]\n-fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set with same indices.\n-#[bench]\n-fn union_hybrid_sparse_full_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set with indices over the whole domain.\n-#[bench]\n-fn union_hybrid_sparse_domain_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i*64));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into empty hybrid set where the domain is very small.\n-#[bench]\n-fn union_hybrid_sparse_empty_small_domain(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set where the domain is very small.\n-#[bench]\n-fn union_hybrid_sparse_full_small_domain(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}"}, {"sha": "ac7913815ffd434fce82663fd2263ec4af5bcb1f", "filename": "src/librustc_data_structures/bit_set/tests.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,369 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[test]\n+fn test_new_filled() {\n+    for i in 0..128 {\n+        let idx_buf = BitSet::new_filled(i);\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..i).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn bitset_iter_works() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(100);\n+    bitset.insert(1);\n+    bitset.insert(10);\n+    bitset.insert(19);\n+    bitset.insert(62);\n+    bitset.insert(63);\n+    bitset.insert(64);\n+    bitset.insert(65);\n+    bitset.insert(66);\n+    bitset.insert(99);\n+    assert_eq!(\n+        bitset.iter().collect::<Vec<_>>(),\n+        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n+    );\n+}\n+\n+#[test]\n+fn bitset_iter_works_2() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n+    bitset.insert(0);\n+    bitset.insert(127);\n+    bitset.insert(191);\n+    bitset.insert(255);\n+    bitset.insert(319);\n+    assert_eq!(bitset.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n+}\n+\n+#[test]\n+fn union_two_sets() {\n+    let mut set1: BitSet<usize> = BitSet::new_empty(65);\n+    let mut set2: BitSet<usize> = BitSet::new_empty(65);\n+    assert!(set1.insert(3));\n+    assert!(!set1.insert(3));\n+    assert!(set2.insert(5));\n+    assert!(set2.insert(64));\n+    assert!(set1.union(&set2));\n+    assert!(!set1.union(&set2));\n+    assert!(set1.contains(3));\n+    assert!(!set1.contains(4));\n+    assert!(set1.contains(5));\n+    assert!(!set1.contains(63));\n+    assert!(set1.contains(64));\n+}\n+\n+#[test]\n+fn hybrid_bitset() {\n+    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    assert!(sparse038.is_empty());\n+    assert!(sparse038.insert(0));\n+    assert!(sparse038.insert(1));\n+    assert!(sparse038.insert(8));\n+    assert!(sparse038.insert(3));\n+    assert!(!sparse038.insert(3));\n+    assert!(sparse038.remove(1));\n+    assert!(!sparse038.is_empty());\n+    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n+\n+    for i in 0..256 {\n+        if i == 0 || i == 3 || i == 8 {\n+            assert!(sparse038.contains(i));\n+        } else {\n+            assert!(!sparse038.contains(i));\n+        }\n+    }\n+\n+    let mut sparse01358 = sparse038.clone();\n+    assert!(sparse01358.insert(1));\n+    assert!(sparse01358.insert(5));\n+    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n+\n+    let mut dense10 = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(dense10.insert(i));\n+    }\n+    assert!(!dense10.is_empty());\n+    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut dense256 = HybridBitSet::new_empty(256);\n+    assert!(dense256.is_empty());\n+    dense256.insert_all();\n+    assert!(!dense256.is_empty());\n+    for i in 0..256 {\n+        assert!(dense256.contains(i));\n+    }\n+\n+    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n+    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n+    assert!(dense10.superset(&sparse038));      // dense + sparse\n+    assert!(dense10.superset(&dense10));        // dense + dense (self)\n+    assert!(dense256.superset(&dense10));       // dense + dense\n+\n+    let mut hybrid = sparse038;\n+    assert!(!sparse01358.union(&hybrid));       // no change\n+    assert!(hybrid.union(&sparse01358));\n+    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n+    assert!(!dense10.union(&sparse01358));\n+    assert!(!dense256.union(&dense10));\n+    let mut dense = dense10;\n+    assert!(dense.union(&dense256));\n+    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n+    assert!(hybrid.union(&dense256));\n+    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n+\n+    assert_eq!(dense256.iter().count(), 256);\n+    let mut dense0 = dense256;\n+    for i in 0..256 {\n+        assert!(dense0.remove(i));\n+    }\n+    assert!(!dense0.remove(0));\n+    assert!(dense0.is_empty());\n+}\n+\n+#[test]\n+fn grow() {\n+    let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);\n+    for index in 0..65 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+    set.ensure(128);\n+\n+    // Check if the bits set before growing are still set\n+    for index in 0..65 {\n+        assert!(set.contains(index));\n+    }\n+\n+    // Check if the new bits are all un-set\n+    for index in 65..128 {\n+        assert!(!set.contains(index));\n+    }\n+\n+    // Check that we can set all new bits without running out of bounds\n+    for index in 65..128 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+}\n+\n+#[test]\n+fn matrix_intersection() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n+\n+    // (*) Elements reachable from both 2 and 65.\n+\n+    matrix.insert(2, 3);\n+    matrix.insert(2, 6);\n+    matrix.insert(2, 10); // (*)\n+    matrix.insert(2, 64); // (*)\n+    matrix.insert(2, 65);\n+    matrix.insert(2, 130);\n+    matrix.insert(2, 160); // (*)\n+\n+    matrix.insert(64, 133);\n+\n+    matrix.insert(65, 2);\n+    matrix.insert(65, 8);\n+    matrix.insert(65, 10); // (*)\n+    matrix.insert(65, 64); // (*)\n+    matrix.insert(65, 68);\n+    matrix.insert(65, 133);\n+    matrix.insert(65, 160); // (*)\n+\n+    let intersection = matrix.intersect_rows(2, 64);\n+    assert!(intersection.is_empty());\n+\n+    let intersection = matrix.intersect_rows(2, 65);\n+    assert_eq!(intersection, &[10, 64, 160]);\n+}\n+\n+#[test]\n+fn matrix_iter() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+    matrix.insert_all_into_row(6);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(3), expected.len());\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(4), expected.len());\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(5), expected.len());\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    assert_eq!(matrix.count(6), 100);\n+    let mut count = 0;\n+    for (idx, i) in matrix.iter(6).enumerate() {\n+        assert_eq!(idx, i);\n+        count += 1;\n+    }\n+    assert_eq!(count, 100);\n+\n+    if let Some(i) = matrix.iter(7).next() {\n+        panic!(\"expected no elements in row, but contains element {:?}\", i);\n+    }\n+}\n+\n+#[test]\n+fn sparse_matrix_iter() {\n+    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}\n+\n+/// Merge dense hybrid set into empty sparse hybrid set.\n+#[bench]\n+fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with same indices.\n+#[bench]\n+fn union_hybrid_sparse_full_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with indices over the whole domain.\n+#[bench]\n+fn union_hybrid_sparse_domain_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i*64));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into empty hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_empty_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_full_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}"}, {"sha": "04ddca7896a69b63fa9081dc30d46d0878b1a2c0", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -9,7 +9,7 @@ use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     let start_node = graph.start_node();"}, {"sha": "70408fb6df16928a8309e21038f6eb30d7c679ac", "filename": "src/librustc_data_structures/graph/dominators/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -1,4 +1,4 @@\n-use super::super::test::TestGraph;\n+use super::super::tests::TestGraph;\n \n use super::*;\n ", "previous_filename": "src/librustc_data_structures/graph/dominators/test.rs"}, {"sha": "c4185fc7cd9c3f60b52960473f8ea176d39042d4", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -3,7 +3,7 @@ use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n use crate::bit_set::BitSet;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub fn post_order_from<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n     graph: &G,"}, {"sha": "6c7cfd6d8a7779852ac38d555c048e8cf7b06eee", "filename": "src/librustc_data_structures/graph/iterate/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -1,4 +1,4 @@\n-use super::super::test::TestGraph;\n+use super::super::tests::TestGraph;\n \n use super::*;\n ", "previous_filename": "src/librustc_data_structures/graph/iterate/test.rs"}, {"sha": "662581ca1e4984d6a5808f282e5fa433aec04388", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -8,7 +8,7 @@ pub mod scc;\n pub mod vec_graph;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub trait DirectedGraph {\n     type Node: Idx;"}, {"sha": "23a1a2a90a4d52fee2f6fff34f76ab1e023b3056", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -9,7 +9,8 @@ use crate::graph::vec_graph::VecGraph;\n use crate::indexed_vec::{Idx, IndexVec};\n use std::ops::Range;\n \n-mod test;\n+#[cfg(test)]\n+mod tests;\n \n /// Strongly connected components (SCC) of a graph. The type `N` is\n /// the index type for the graph nodes and `S` is the index type for"}, {"sha": "6da3ac0ecb8b9b59a36b06be6b5d6d8cd36e14ff", "filename": "src/librustc_data_structures/graph/scc/tests.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -1,6 +1,4 @@\n-#![cfg(test)]\n-\n-use crate::graph::test::TestGraph;\n+use crate::graph::tests::TestGraph;\n use super::*;\n \n #[test]", "previous_filename": "src/librustc_data_structures/graph/scc/test.rs"}, {"sha": "bc142144e930f24e8790df0d40e4b13dc1c8fff3", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "previous_filename": "src/librustc_data_structures/graph/test.rs"}, {"sha": "19c61f2680d1d9a5dba559462f3000d7b4af143b", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -2,7 +2,7 @@ use crate::indexed_vec::{Idx, IndexVec};\n use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub struct VecGraph<N: Idx> {\n     /// Maps from a given node to an index where the set of successors"}, {"sha": "97a9bd2ad0b08c74fb5528ddcef46aab09669409", "filename": "src/librustc_data_structures/graph/vec_graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "previous_filename": "src/librustc_data_structures/graph/vec_graph/test.rs"}, {"sha": "04d2b23ab1a1c4ee36b72d7e301e3a0f7e01bc55", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -94,7 +94,7 @@ use self::node_index::NodeIndex;\n mod graphviz;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;"}, {"sha": "27d4bf4959e63cc641c7000800dd86ba37d737cd", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "previous_filename": "src/librustc_data_structures/obligation_forest/test.rs"}, {"sha": "1c58eda24f459be23ec2fbb0c4808d1ba672f5c3", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 3, "deletions": 230, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -6,6 +6,9 @@ use std::slice;\n use std::ptr;\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Debug, Clone)]\n pub struct SipHasher128 {\n     k0: u64,\n@@ -291,233 +294,3 @@ impl Sip24Rounds {\n         compress!(state);\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use std::hash::{Hash, Hasher};\n-    use std::{slice, mem};\n-    use super::SipHasher128;\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'a>(&'a [u8]);\n-\n-    impl<'a> Hash for Bytes<'a> {\n-        #[allow(unused_must_use)]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            for byte in self.0 {\n-                state.write_u8(*byte);\n-            }\n-        }\n-    }\n-\n-    fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n-        x.hash(&mut st);\n-        st.finish128()\n-    }\n-\n-    fn hash<T: Hash>(x: &T) -> (u64, u64) {\n-        hash_with(SipHasher128::new_with_keys(0, 0), x)\n-    }\n-\n-    const TEST_VECTOR : [[u8; 16]; 64] = [\n-        [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n-        [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n-        [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n-        [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n-        [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n-        [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n-        [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n-        [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n-        [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n-        [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n-        [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n-        [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n-        [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n-        [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n-        [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n-        [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n-        [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n-        [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n-        [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n-        [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n-        [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n-        [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n-        [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n-        [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n-        [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n-        [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n-        [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n-        [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n-        [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n-        [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n-        [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n-        [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n-        [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n-        [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n-        [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n-        [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n-        [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n-        [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n-        [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n-        [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n-        [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n-        [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n-        [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n-        [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n-        [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n-        [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n-        [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n-        [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n-        [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n-        [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n-        [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n-        [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n-        [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n-        [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n-        [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n-        [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n-        [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n-        [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n-        [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n-        [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n-        [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n-        [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n-        [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n-        [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n-    ];\n-\n-    // Test vector from reference implementation\n-    #[test]\n-    fn test_siphash_2_4_test_vector() {\n-        let k0 = 0x_07_06_05_04_03_02_01_00;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n-\n-        let mut input: Vec<u8> = Vec::new();\n-\n-        for i in 0 .. 64 {\n-            let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n-                                &Bytes(&input[..]));\n-            let expected = (\n-                ((TEST_VECTOR[i][0] as u64) <<  0) |\n-                ((TEST_VECTOR[i][1] as u64) <<  8) |\n-                ((TEST_VECTOR[i][2] as u64) << 16) |\n-                ((TEST_VECTOR[i][3] as u64) << 24) |\n-                ((TEST_VECTOR[i][4] as u64) << 32) |\n-                ((TEST_VECTOR[i][5] as u64) << 40) |\n-                ((TEST_VECTOR[i][6] as u64) << 48) |\n-                ((TEST_VECTOR[i][7] as u64) << 56),\n-\n-                ((TEST_VECTOR[i][8] as u64) <<  0) |\n-                ((TEST_VECTOR[i][9] as u64) <<  8) |\n-                ((TEST_VECTOR[i][10] as u64) << 16) |\n-                ((TEST_VECTOR[i][11] as u64) << 24) |\n-                ((TEST_VECTOR[i][12] as u64) << 32) |\n-                ((TEST_VECTOR[i][13] as u64) << 40) |\n-                ((TEST_VECTOR[i][14] as u64) << 48) |\n-                ((TEST_VECTOR[i][15] as u64) << 56),\n-            );\n-\n-            assert_eq!(out, expected);\n-            input.push(i as u8);\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n-        assert!(hash(&(val as u32)) != hash(&(val as usize)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&val64), hash(&val64));\n-        let val32 = 0xdeadbeef_u32;\n-        assert_eq!(hash(&val32), hash(&val32));\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n-\n-        fn zero_byte(val: u64, byte: usize) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-\n-        fn zero_byte(val: u32, byte: usize) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        assert!(s != t && t != u);\n-        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n-\n-        let u = [1, 0, 0, 0];\n-        let v = (&u[..1], &u[1..3], &u[3..]);\n-        let w = (&u[..], &u[4..4], &u[4..4]);\n-\n-        assert!(v != w);\n-        assert!(hash(&v) != hash(&w));\n-    }\n-\n-    #[test]\n-    fn test_write_short_works() {\n-        let test_usize = 0xd0c0b0a0usize;\n-        let mut h1 = SipHasher128::new_with_keys(0, 0);\n-        h1.write_usize(test_usize);\n-        h1.write(b\"bytes\");\n-        h1.write(b\"string\");\n-        h1.write_u8(0xFFu8);\n-        h1.write_u8(0x01u8);\n-        let mut h2 = SipHasher128::new_with_keys(0, 0);\n-        h2.write(unsafe {\n-            slice::from_raw_parts(&test_usize as *const _ as *const u8,\n-                                  mem::size_of::<usize>())\n-        });\n-        h2.write(b\"bytes\");\n-        h2.write(b\"string\");\n-        h2.write(&[0xFFu8, 0x01u8]);\n-        assert_eq!(h1.finish128(), h2.finish128());\n-    }\n-\n-}"}, {"sha": "90cc54448b40737a7c1bf82d7a39e78fed13558c", "filename": "src/librustc_data_structures/sip128/tests.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,226 @@\n+use super::*;\n+\n+use std::hash::{Hash, Hasher};\n+use std::{slice, mem};\n+\n+// Hash just the bytes of the slice, without length prefix\n+struct Bytes<'a>(&'a [u8]);\n+\n+impl<'a> Hash for Bytes<'a> {\n+    #[allow(unused_must_use)]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        for byte in self.0 {\n+            state.write_u8(*byte);\n+        }\n+    }\n+}\n+\n+fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n+    x.hash(&mut st);\n+    st.finish128()\n+}\n+\n+fn hash<T: Hash>(x: &T) -> (u64, u64) {\n+    hash_with(SipHasher128::new_with_keys(0, 0), x)\n+}\n+\n+const TEST_VECTOR : [[u8; 16]; 64] = [\n+    [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n+    [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n+    [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n+    [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n+    [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n+    [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n+    [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n+    [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n+    [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n+    [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n+    [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n+    [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n+    [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n+    [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n+    [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n+    [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n+    [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n+    [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n+    [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n+    [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n+    [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n+    [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n+    [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n+    [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n+    [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n+    [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n+    [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n+    [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n+    [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n+    [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n+    [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n+    [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n+    [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n+    [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n+    [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n+    [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n+    [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n+    [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n+    [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n+    [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n+    [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n+    [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n+    [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n+    [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n+    [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n+    [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n+    [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n+    [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n+    [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n+    [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n+    [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n+    [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n+    [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n+    [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n+    [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n+    [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n+    [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n+    [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n+    [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n+    [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n+    [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n+    [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n+    [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n+    [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n+];\n+\n+// Test vector from reference implementation\n+#[test]\n+fn test_siphash_2_4_test_vector() {\n+    let k0 = 0x_07_06_05_04_03_02_01_00;\n+    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+\n+    let mut input: Vec<u8> = Vec::new();\n+\n+    for i in 0 .. 64 {\n+        let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n+                            &Bytes(&input[..]));\n+        let expected = (\n+            ((TEST_VECTOR[i][0] as u64) <<  0) |\n+            ((TEST_VECTOR[i][1] as u64) <<  8) |\n+            ((TEST_VECTOR[i][2] as u64) << 16) |\n+            ((TEST_VECTOR[i][3] as u64) << 24) |\n+            ((TEST_VECTOR[i][4] as u64) << 32) |\n+            ((TEST_VECTOR[i][5] as u64) << 40) |\n+            ((TEST_VECTOR[i][6] as u64) << 48) |\n+            ((TEST_VECTOR[i][7] as u64) << 56),\n+\n+            ((TEST_VECTOR[i][8] as u64) <<  0) |\n+            ((TEST_VECTOR[i][9] as u64) <<  8) |\n+            ((TEST_VECTOR[i][10] as u64) << 16) |\n+            ((TEST_VECTOR[i][11] as u64) << 24) |\n+            ((TEST_VECTOR[i][12] as u64) << 32) |\n+            ((TEST_VECTOR[i][13] as u64) << 40) |\n+            ((TEST_VECTOR[i][14] as u64) << 48) |\n+            ((TEST_VECTOR[i][15] as u64) << 56),\n+        );\n+\n+        assert_eq!(out, expected);\n+        input.push(i as u8);\n+    }\n+}\n+\n+#[test] #[cfg(target_arch = \"arm\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+}\n+#[test] #[cfg(target_arch = \"x86_64\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+    assert!(hash(&(val as u32)) != hash(&(val as usize)));\n+}\n+#[test] #[cfg(target_arch = \"x86\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+}\n+\n+#[test]\n+fn test_hash_idempotent() {\n+    let val64 = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&val64), hash(&val64));\n+    let val32 = 0xdeadbeef_u32;\n+    assert_eq!(hash(&val32), hash(&val32));\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_64() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+    fn zero_byte(val: u64, byte: usize) -> u64 {\n+        assert!(byte < 8);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_32() {\n+    let val = 0xdeadbeef_u32;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+    fn zero_byte(val: u32, byte: usize) -> u32 {\n+        assert!(byte < 4);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_concat_alias() {\n+    let s = (\"aa\", \"bb\");\n+    let t = (\"aabb\", \"\");\n+    let u = (\"a\", \"abb\");\n+\n+    assert!(s != t && t != u);\n+    assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+    let u = [1, 0, 0, 0];\n+    let v = (&u[..1], &u[1..3], &u[3..]);\n+    let w = (&u[..], &u[4..4], &u[4..4]);\n+\n+    assert!(v != w);\n+    assert!(hash(&v) != hash(&w));\n+}\n+\n+#[test]\n+fn test_write_short_works() {\n+    let test_usize = 0xd0c0b0a0usize;\n+    let mut h1 = SipHasher128::new_with_keys(0, 0);\n+    h1.write_usize(test_usize);\n+    h1.write(b\"bytes\");\n+    h1.write(b\"string\");\n+    h1.write_u8(0xFFu8);\n+    h1.write_u8(0x01u8);\n+    let mut h2 = SipHasher128::new_with_keys(0, 0);\n+    h2.write(unsafe {\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                                mem::size_of::<usize>())\n+    });\n+    h2.write(b\"bytes\");\n+    h2.write(b\"string\");\n+    h2.write(&[0xFFu8, 0x01u8]);\n+    assert_eq!(h1.finish128(), h2.finish128());\n+}"}, {"sha": "9d90b9052d1c200f9724c1e8ddb1c6bd01072a2b", "filename": "src/librustc_data_structures/small_c_str.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -3,6 +3,9 @@ use std::ops::Deref;\n \n use smallvec::SmallVec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const SIZE: usize = 36;\n \n /// Like SmallVec but for C strings.\n@@ -66,47 +69,3 @@ impl Deref for SmallCStr {\n         self.as_c_str()\n     }\n }\n-\n-#[test]\n-fn short() {\n-    const TEXT: &str = \"abcd\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(!scs.spilled());\n-}\n-\n-#[test]\n-fn empty() {\n-    const TEXT: &str = \"\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(!scs.spilled());\n-}\n-\n-#[test]\n-fn long() {\n-    const TEXT: &str = \"01234567890123456789012345678901234567890123456789\\\n-                        01234567890123456789012345678901234567890123456789\\\n-                        01234567890123456789012345678901234567890123456789\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(scs.spilled());\n-}\n-\n-#[test]\n-#[should_panic]\n-fn internal_nul() {\n-    let _ = SmallCStr::new(\"abcd\\0def\");\n-}"}, {"sha": "47277604b2b71e8a5da91d85cb8b2c11e550c3e1", "filename": "src/librustc_data_structures/small_c_str/tests.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,45 @@\n+use super::*;\n+\n+#[test]\n+fn short() {\n+    const TEXT: &str = \"abcd\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(!scs.spilled());\n+}\n+\n+#[test]\n+fn empty() {\n+    const TEXT: &str = \"\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(!scs.spilled());\n+}\n+\n+#[test]\n+fn long() {\n+    const TEXT: &str = \"01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(scs.spilled());\n+}\n+\n+#[test]\n+#[should_panic]\n+fn internal_nul() {\n+    let _ = SmallCStr::new(\"abcd\\0def\");\n+}"}, {"sha": "ce0aa07cc282c4787d39a6a2ddb34799ccc5d356", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -4,7 +4,7 @@ use std::ops;\n use std::mem;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub struct SnapshotMap<K, V>\n     where K: Hash + Clone + Eq"}, {"sha": "72ca53c2be9ed2fe2750444de3f037aee806bd9f", "filename": "src/librustc_data_structures/snapshot_map/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "previous_filename": "src/librustc_data_structures/snapshot_map/test.rs"}, {"sha": "1c0d9360f2511217816ab2a0b4ddc52187511474", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -11,6 +11,9 @@\n //! If you expect to store more than 1 element in the common case, steer clear\n //! and use a `Vec<T>`, `Box<[T]>`, or a `SmallVec<T>`.\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Hash, Debug, PartialEq)]\n pub struct TinyList<T: PartialEq> {\n     head: Option<Element<T>>\n@@ -118,139 +121,3 @@ impl<T: PartialEq> Element<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    extern crate test;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn test_contains_and_insert() {\n-        fn do_insert(i : u32) -> bool {\n-            i % 2 == 0\n-        }\n-\n-        let mut list = TinyList::new();\n-\n-        for i in 0 .. 10 {\n-            for j in 0 .. i {\n-                if do_insert(j) {\n-                    assert!(list.contains(&j));\n-                } else {\n-                    assert!(!list.contains(&j));\n-                }\n-            }\n-\n-            assert!(!list.contains(&i));\n-\n-            if do_insert(i) {\n-                list.insert(i);\n-                assert!(list.contains(&i));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove_first() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&4));\n-        assert!(!list.contains(&4));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&1));\n-        assert!(list.contains(&2));\n-        assert!(list.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_remove_last() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&1));\n-        assert!(!list.contains(&1));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&2));\n-        assert!(list.contains(&3));\n-        assert!(list.contains(&4));\n-    }\n-\n-    #[test]\n-    fn test_remove_middle() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&2));\n-        assert!(!list.contains(&2));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&1));\n-        assert!(list.contains(&3));\n-        assert!(list.contains(&4));\n-    }\n-\n-    #[test]\n-    fn test_remove_single() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        assert_eq!(list.len(), 1);\n-\n-        assert!(list.remove(&1));\n-        assert!(!list.contains(&1));\n-\n-        assert_eq!(list.len(), 0);\n-    }\n-\n-    #[bench]\n-    fn bench_insert_empty(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut list = TinyList::new();\n-            list.insert(1);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_insert_one(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut list = TinyList::new_single(0);\n-            list.insert(1);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_remove_empty(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new().remove(&1)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove_unknown(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new_single(0).remove(&1)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove_one(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new_single(1).remove(&1)\n-        });\n-    }\n-}"}, {"sha": "8374659e1e67b021d9ef0761b90e58406d8e94ca", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,133 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[test]\n+fn test_contains_and_insert() {\n+    fn do_insert(i : u32) -> bool {\n+        i % 2 == 0\n+    }\n+\n+    let mut list = TinyList::new();\n+\n+    for i in 0 .. 10 {\n+        for j in 0 .. i {\n+            if do_insert(j) {\n+                assert!(list.contains(&j));\n+            } else {\n+                assert!(!list.contains(&j));\n+            }\n+        }\n+\n+        assert!(!list.contains(&i));\n+\n+        if do_insert(i) {\n+            list.insert(i);\n+            assert!(list.contains(&i));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove_first() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&4));\n+    assert!(!list.contains(&4));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&1));\n+    assert!(list.contains(&2));\n+    assert!(list.contains(&3));\n+}\n+\n+#[test]\n+fn test_remove_last() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&1));\n+    assert!(!list.contains(&1));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&2));\n+    assert!(list.contains(&3));\n+    assert!(list.contains(&4));\n+}\n+\n+#[test]\n+fn test_remove_middle() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&2));\n+    assert!(!list.contains(&2));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&1));\n+    assert!(list.contains(&3));\n+    assert!(list.contains(&4));\n+}\n+\n+#[test]\n+fn test_remove_single() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    assert_eq!(list.len(), 1);\n+\n+    assert!(list.remove(&1));\n+    assert!(!list.contains(&1));\n+\n+    assert_eq!(list.len(), 0);\n+}\n+\n+#[bench]\n+fn bench_insert_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+    })\n+}\n+\n+#[bench]\n+fn bench_insert_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut list = TinyList::new_single(0);\n+        list.insert(1);\n+    })\n+}\n+\n+#[bench]\n+fn bench_remove_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new().remove(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_remove_unknown(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new_single(0).remove(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_remove_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new_single(1).remove(&1)\n+    });\n+}"}, {"sha": "ffc964ddb5ae2cece3901fe2d2cdc2a6ad5a9bd2", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 356, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -7,6 +7,8 @@ use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n \n #[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n@@ -481,359 +483,3 @@ impl<CTX> HashStable<CTX> for Index {\n         idx.hash_stable(hcx, hasher);\n     }\n }\n-\n-#[test]\n-fn test_one_step() {\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"b\");\n-    relation.add(\"a\", \"c\");\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(!relation.contains(&\"b\", &\"a\"));\n-    assert!(!relation.contains(&\"a\", &\"d\"));\n-}\n-\n-#[test]\n-fn test_many_steps() {\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"b\");\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"a\", \"f\");\n-\n-    relation.add(\"b\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    relation.add(\"e\", \"g\");\n-\n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"d\"));\n-    assert!(relation.contains(&\"a\", &\"e\"));\n-    assert!(relation.contains(&\"a\", &\"f\"));\n-    assert!(relation.contains(&\"a\", &\"g\"));\n-\n-    assert!(relation.contains(&\"b\", &\"g\"));\n-\n-    assert!(!relation.contains(&\"a\", &\"x\"));\n-    assert!(!relation.contains(&\"b\", &\"f\"));\n-}\n-\n-#[test]\n-fn mubs_triangle() {\n-    // a -> tcx\n-    //      ^\n-    //      |\n-    //      b\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"tcx\");\n-    relation.add(\"b\", \"tcx\");\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n-}\n-\n-#[test]\n-fn mubs_best_choice1() {\n-    // 0 -> 1 <- 3\n-    // |    ^    |\n-    // |    |    |\n-    // +--> 2 <--+\n-    //\n-    // mubs(0,3) = [1]\n-\n-    // This tests a particular state in the algorithm, in which we\n-    // need the second pare down call to get the right result (after\n-    // intersection, we have [1, 2], but 2 -> 1).\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"2\", \"1\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n-    assert!(relation.parents(&\"1\").is_empty());\n-}\n-\n-#[test]\n-fn mubs_best_choice2() {\n-    // 0 -> 1 <- 3\n-    // |    |    |\n-    // |    v    |\n-    // +--> 2 <--+\n-    //\n-    // mubs(0,3) = [2]\n-\n-    // Like the precedecing test, but in this case intersection is [2,\n-    // 1], and hence we rely on the first pare down call.\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"1\", \"2\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n-    assert!(relation.parents(&\"2\").is_empty());\n-}\n-\n-#[test]\n-fn mubs_no_best_choice() {\n-    // in this case, the intersection yields [1, 2], and the \"pare\n-    // down\" calls find nothing to remove.\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n-}\n-\n-#[test]\n-fn mubs_best_choice_scc() {\n-    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n-    // consistently).\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"1\", \"2\");\n-    relation.add(\"2\", \"1\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n-}\n-\n-#[test]\n-fn pdub_crisscross() {\n-    // diagonal edges run left-to-right\n-    // a -> a1 -> x\n-    //   \\/       ^\n-    //   /\\       |\n-    // b -> b1 ---+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"a\", \"b1\");\n-    relation.add(\"b\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-    relation.add(\"a1\", \"x\");\n-    relation.add(\"b1\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n-               vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn pdub_crisscross_more() {\n-    // diagonal edges run left-to-right\n-    // a -> a1 -> a2 -> a3 -> x\n-    //   \\/    \\/             ^\n-    //   /\\    /\\             |\n-    // b -> b1 -> b2 ---------+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"a\", \"b1\");\n-    relation.add(\"b\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-\n-    relation.add(\"a1\", \"a2\");\n-    relation.add(\"a1\", \"b2\");\n-    relation.add(\"b1\", \"a2\");\n-    relation.add(\"b1\", \"b2\");\n-\n-    relation.add(\"a2\", \"a3\");\n-\n-    relation.add(\"a3\", \"x\");\n-    relation.add(\"b2\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n-               vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n-               vec![&\"a2\", &\"b2\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn pdub_lub() {\n-    // a -> a1 -> x\n-    //            ^\n-    //            |\n-    // b -> b1 ---+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-    relation.add(\"a1\", \"x\");\n-    relation.add(\"b1\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n-    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn mubs_intermediate_node_on_one_side_only() {\n-    // a -> c -> d\n-    //           ^\n-    //           |\n-    //           b\n-\n-    // \"digraph { a -> c -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"b\", \"d\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_1() {\n-    // +-------------+\n-    // |    +----+   |\n-    // |    v    |   |\n-    // a -> c -> d <-+\n-    //           ^\n-    //           |\n-    //           b\n-\n-    // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"c\");\n-    relation.add(\"a\", \"d\");\n-    relation.add(\"b\", \"d\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_2() {\n-    //      +----+\n-    //      v    |\n-    // a -> c -> d\n-    //      ^    ^\n-    //      |    |\n-    //      +--- b\n-\n-    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"c\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_3() {\n-    //      +---------+\n-    //      v         |\n-    // a -> c -> d -> e\n-    //           ^    ^\n-    //           |    |\n-    //           b ---+\n-\n-    // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"e\");\n-    relation.add(\"e\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_4() {\n-    //      +---------+\n-    //      v         |\n-    // a -> c -> d -> e\n-    // |         ^    ^\n-    // +---------+    |\n-    //                |\n-    //           b ---+\n-\n-    // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"e\");\n-    relation.add(\"e\", \"c\");\n-    relation.add(\"a\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn parent() {\n-    // An example that was misbehaving in the compiler.\n-    //\n-    // 4 -> 1 -> 3\n-    //   \\  |   /\n-    //    \\ v  /\n-    // 2 -> 0\n-    //\n-    // plus a bunch of self-loops\n-    //\n-    // Here `->` represents `<=` and `0` is `'static`.\n-\n-    let pairs = vec![\n-        (2, /*->*/ 0),\n-        (2, /*->*/ 2),\n-        (0, /*->*/ 0),\n-        (0, /*->*/ 0),\n-        (1, /*->*/ 0),\n-        (1, /*->*/ 1),\n-        (3, /*->*/ 0),\n-        (3, /*->*/ 3),\n-        (4, /*->*/ 0),\n-        (4, /*->*/ 1),\n-        (1, /*->*/ 3),\n-    ];\n-\n-    let mut relation = TransitiveRelation::default();\n-    for (a, b) in pairs {\n-        relation.add(a, b);\n-    }\n-\n-    let p = relation.postdom_parent(&3);\n-    assert_eq!(p, Some(&0));\n-}"}, {"sha": "a462dbdb58383dcd650138b79cf23717909c1600", "filename": "src/librustc_data_structures/transitive_relation/tests.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -0,0 +1,357 @@\n+use super::*;\n+\n+#[test]\n+fn test_one_step() {\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(!relation.contains(&\"b\", &\"a\"));\n+    assert!(!relation.contains(&\"a\", &\"d\"));\n+}\n+\n+#[test]\n+fn test_many_steps() {\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"a\", \"f\");\n+\n+    relation.add(\"b\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    relation.add(\"e\", \"g\");\n+\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"d\"));\n+    assert!(relation.contains(&\"a\", &\"e\"));\n+    assert!(relation.contains(&\"a\", &\"f\"));\n+    assert!(relation.contains(&\"a\", &\"g\"));\n+\n+    assert!(relation.contains(&\"b\", &\"g\"));\n+\n+    assert!(!relation.contains(&\"a\", &\"x\"));\n+    assert!(!relation.contains(&\"b\", &\"f\"));\n+}\n+\n+#[test]\n+fn mubs_triangle() {\n+    // a -> tcx\n+    //      ^\n+    //      |\n+    //      b\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"tcx\");\n+    relation.add(\"b\", \"tcx\");\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice1() {\n+    // 0 -> 1 <- 3\n+    // |    ^    |\n+    // |    |    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [1]\n+\n+    // This tests a particular state in the algorithm, in which we\n+    // need the second pare down call to get the right result (after\n+    // intersection, we have [1, 2], but 2 -> 1).\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n+    assert!(relation.parents(&\"1\").is_empty());\n+}\n+\n+#[test]\n+fn mubs_best_choice2() {\n+    // 0 -> 1 <- 3\n+    // |    |    |\n+    // |    v    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [2]\n+\n+    // Like the precedecing test, but in this case intersection is [2,\n+    // 1], and hence we rely on the first pare down call.\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n+    assert!(relation.parents(&\"2\").is_empty());\n+}\n+\n+#[test]\n+fn mubs_no_best_choice() {\n+    // in this case, the intersection yields [1, 2], and the \"pare\n+    // down\" calls find nothing to remove.\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice_scc() {\n+    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n+    // consistently).\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn pdub_crisscross() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> x\n+    //   \\/       ^\n+    //   /\\       |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_crisscross_more() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> a2 -> a3 -> x\n+    //   \\/    \\/             ^\n+    //   /\\    /\\             |\n+    // b -> b1 -> b2 ---------+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+\n+    relation.add(\"a1\", \"a2\");\n+    relation.add(\"a1\", \"b2\");\n+    relation.add(\"b1\", \"a2\");\n+    relation.add(\"b1\", \"b2\");\n+\n+    relation.add(\"a2\", \"a3\");\n+\n+    relation.add(\"a3\", \"x\");\n+    relation.add(\"b2\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n+               vec![&\"a2\", &\"b2\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_lub() {\n+    // a -> a1 -> x\n+    //            ^\n+    //            |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n+    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn mubs_intermediate_node_on_one_side_only() {\n+    // a -> c -> d\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"b\", \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_1() {\n+    // +-------------+\n+    // |    +----+   |\n+    // |    v    |   |\n+    // a -> c -> d <-+\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_2() {\n+    //      +----+\n+    //      v    |\n+    // a -> c -> d\n+    //      ^    ^\n+    //      |    |\n+    //      +--- b\n+\n+    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"c\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_3() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    //           ^    ^\n+    //           |    |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_4() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    // |         ^    ^\n+    // +---------+    |\n+    //                |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn parent() {\n+    // An example that was misbehaving in the compiler.\n+    //\n+    // 4 -> 1 -> 3\n+    //   \\  |   /\n+    //    \\ v  /\n+    // 2 -> 0\n+    //\n+    // plus a bunch of self-loops\n+    //\n+    // Here `->` represents `<=` and `0` is `'static`.\n+\n+    let pairs = vec![\n+        (2, /*->*/ 0),\n+        (2, /*->*/ 2),\n+        (0, /*->*/ 0),\n+        (0, /*->*/ 0),\n+        (1, /*->*/ 0),\n+        (1, /*->*/ 1),\n+        (3, /*->*/ 0),\n+        (3, /*->*/ 3),\n+        (4, /*->*/ 0),\n+        (4, /*->*/ 1),\n+        (1, /*->*/ 3),\n+    ];\n+\n+    let mut relation = TransitiveRelation::default();\n+    for (a, b) in pairs {\n+        relation.add(a, b);\n+    }\n+\n+    let p = relation.postdom_parent(&3);\n+    assert_eq!(p, Some(&0));\n+}"}, {"sha": "f4de9bb07b5fec446334eef31ed04f10c5a1e2ee", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e118eb6c7970385fbcdd688d03975f65d88e642e/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=e118eb6c7970385fbcdd688d03975f65d88e642e", "patch": "@@ -27,7 +27,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n     };\n     let fixme = [\n         \"liballoc\",\n-        \"librustc_data_structures\",\n         \"librustdoc\",\n         \"libstd\",\n         \"libsyntax\","}]}