{"sha": "69fbd64e2a4a4bd52dd8b965316c91902ab90797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZmJkNjRlMmE0YTRiZDUyZGQ4Yjk2NTMxNmM5MTkwMmFiOTA3OTc=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-07-15T08:21:01Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-07-15T08:32:06Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "9f6c7a3bdab5f6e804af42c1a9b1210be9f8c86d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f6c7a3bdab5f6e804af42c1a9b1210be9f8c86d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69fbd64e2a4a4bd52dd8b965316c91902ab90797", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmDv8oYACgkQHKDfKvWd\naKUNWRAAtnuw3pOW4aIxcAR9BB9SxE7+Jz8WVxwE0CZklQHKsQ8PA5C2nTR9Tbi+\n7Jg8sZSHVYnNY14vwnC68cWUwBJPVO+KNyMRuxSp0gY6mFu0scu8PoYiRGP4uOBu\n1bHQKtuGpBkjpBYuwaE0VUS11FnHDIvNqRLKhRj4y7zcVTSYuYehK2lCUJcRU9K9\nnCDn0exE+ULMp/iDKWiS/OgVwX1D+t1MuoeZRaconwEJFV6ITDsF35zO9k1G8+Hd\nrhjSRItuEwzbw2Q2I8ObZ6KqgpnqR9uN8tzVp9RKROckuoOQA0UV+p1vPtqVgoU4\njSw0ciRjxI7Kgp5H7ufZgXzl8tBRxQ4LllqOtkBcgl4+DQLDb6Mqp+83D/SVSnct\n13coQS0xt4qVOOzj7aQmSCxK9/dDh2QevFV91onb9AfKnuCIWTQxNKy0osy0V8+V\n42LYBMyn/MXJTdmxV91Ymq2WTuBJCD0ULqOW5oEbOG2DyR4jHIomCclU1xHZfnGD\nnsRo0U3EkMvsIJiU+GcjjYTt1h8QqCVYvsGdHmqJHPHX2oXS/Z9BnUZcCCPFY3Vb\nVSD1HkGANWvZggrOLO5IQKPjSWeTw6dH+idmh3pVa+kCe3XKr9h6iGmTNql+3uHW\n1mmiMxI64m7fbuSPc4kEuw91GQ7RlChZ/PzY++QFVQF48Ldv2DI=\n=e0EX\n-----END PGP SIGNATURE-----", "payload": "tree 9f6c7a3bdab5f6e804af42c1a9b1210be9f8c86d\nparent 2fd8dbc8af543a021b87a01e1a34242dec54cb80\nparent 09f5f15d8ba660d9c657fdc4a34d7aab7bc4ecad\nauthor flip1995 <philipp.krones@embecosm.com> 1626337261 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1626337926 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69fbd64e2a4a4bd52dd8b965316c91902ab90797", "html_url": "https://github.com/rust-lang/rust/commit/69fbd64e2a4a4bd52dd8b965316c91902ab90797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69fbd64e2a4a4bd52dd8b965316c91902ab90797/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fd8dbc8af543a021b87a01e1a34242dec54cb80", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd8dbc8af543a021b87a01e1a34242dec54cb80", "html_url": "https://github.com/rust-lang/rust/commit/2fd8dbc8af543a021b87a01e1a34242dec54cb80"}, {"sha": "09f5f15d8ba660d9c657fdc4a34d7aab7bc4ecad", "url": "https://api.github.com/repos/rust-lang/rust/commits/09f5f15d8ba660d9c657fdc4a34d7aab7bc4ecad", "html_url": "https://github.com/rust-lang/rust/commit/09f5f15d8ba660d9c657fdc4a34d7aab7bc4ecad"}], "stats": {"total": 2876, "additions": 2249, "deletions": 627}, "files": [{"sha": "9f89f74e7450361f45def111ae1aeea75ef3e328", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -2744,6 +2744,7 @@ Released 2018-09-13\n [`range_step_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_step_by_zero\n [`range_zip_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_zip_with_len\n [`rc_buffer`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_buffer\n+[`rc_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex\n [`redundant_allocation`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation\n [`redundant_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n@@ -2797,6 +2798,7 @@ Released 2018-09-13\n [`string_from_utf8_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_from_utf8_as_bytes\n [`string_lit_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_lit_as_bytes\n [`string_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_to_string\n+[`strlen_on_c_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#strlen_on_c_strings\n [`struct_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools\n [`suboptimal_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#suboptimal_flops\n [`suspicious_arithmetic_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl"}, {"sha": "21c7b2448cec8dffdc714d22e628b1e1d801e6df", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -2,8 +2,7 @@\n \n use std::path::PathBuf;\n \n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::run_lints;\n+use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n use rustc_hir::{hir_id::CRATE_HIR_ID, Crate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -85,7 +84,7 @@ fn is_empty_vec(value: &[String]) -> bool {\n \n impl LateLintPass<'_> for CargoCommonMetadata {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n-        if !run_lints(cx, &[CARGO_COMMON_METADATA], CRATE_HIR_ID) {\n+        if is_lint_allowed(cx, CARGO_COMMON_METADATA, CRATE_HIR_ID) {\n             return;\n         }\n "}, {"sha": "9cbcde597686e8c212c45ce95d4e28ad954624cf", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n use clippy_utils::{\n     both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, is_else_clause,\n-    run_lints, search_same, ContainsName, SpanlessEq, SpanlessHash,\n+    is_lint_allowed, search_same, ContainsName, SpanlessEq, SpanlessHash,\n };\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n@@ -120,7 +120,10 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** Duplicate code is less maintainable.\n     ///\n-    /// **Known problems:** Hopefully none.\n+    /// **Known problems:**\n+    /// * The lint doesn't check if the moved expressions modify values that are beeing used in\n+    ///   the if condition. The suggestion can in that case modify the behavior of the program.\n+    ///   See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n     ///\n     /// **Example:**\n     /// ```ignore\n@@ -337,8 +340,8 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n             if block_expr_eq;\n             if l_stmts.len() == r_stmts.len();\n             if l_stmts.len() == current_start_eq;\n-            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[0].hir_id);\n-            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[1].hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[0].hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[1].hir_id);\n             then {\n                 span_lint_and_note(\n                     cx,\n@@ -358,8 +361,7 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n         expr_eq &= block_expr_eq;\n     }\n \n-    let has_expr = blocks[0].expr.is_some();\n-    if has_expr && !expr_eq {\n+    if !expr_eq {\n         end_eq = 0;\n     }\n "}, {"sha": "e719a1b0abf8744dd2f483d542c9c017e96e6b67", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n+use clippy_utils::numeric_literal;\n+use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::Applicability;\n@@ -78,16 +79,25 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(ty_bound) = self.ty_bounds.last();\n                 if matches!(lit.node,\n                             LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n-                if !ty_bound.is_integral();\n+                if !ty_bound.is_numeric();\n                 then {\n-                    let suffix = match lit_ty.kind() {\n-                        ty::Int(IntTy::I32) => \"i32\",\n-                        ty::Float(FloatTy::F64) => \"f64\",\n+                    let (suffix, is_float) = match lit_ty.kind() {\n+                        ty::Int(IntTy::I32) => (\"i32\", false),\n+                        ty::Float(FloatTy::F64) => (\"f64\", true),\n                         // Default numeric fallback never results in other types.\n                         _ => return,\n                     };\n \n-                    let sugg = format!(\"{}_{}\", snippet(self.cx, lit.span, \"\"), suffix);\n+                    let src = if let Some(src) = snippet_opt(self.cx, lit.span) {\n+                        src\n+                    } else {\n+                        match lit.node {\n+                            LitKind::Int(src, _) => format!(\"{}\", src),\n+                            LitKind::Float(src, _) => format!(\"{}\", src),\n+                            _ => return,\n+                        }\n+                    };\n+                    let sugg = numeric_literal::format(&src, Some(suffix), is_float);\n                     span_lint_and_sugg(\n                         self.cx,\n                         DEFAULT_NUMERIC_FALLBACK,\n@@ -219,10 +229,10 @@ enum TyBound<'tcx> {\n }\n \n impl<'tcx> TyBound<'tcx> {\n-    fn is_integral(self) -> bool {\n+    fn is_numeric(self) -> bool {\n         match self {\n             TyBound::Any => true,\n-            TyBound::Ty(t) => t.is_integral(),\n+            TyBound::Ty(t) => t.is_numeric(),\n             TyBound::Nothing => false,\n         }\n     }"}, {"sha": "682003f9c2c4c99d71d8bccb329b9409ed48d0bf", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_node, in_macro, is_allowed};\n+use clippy_utils::{get_parent_node, in_macro, is_lint_allowed};\n use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, MatchSource, Mutability, Node, UnOp};\n@@ -107,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n \n                 match kind {\n                     RefOp::Method(target_mut)\n-                        if !is_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n+                        if !is_lint_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n                             && is_linted_explicit_deref_position(parent, expr.hir_id, expr.span) =>\n                     {\n                         self.state = Some(("}, {"sha": "7aafaf71383011a93c298bf5d7b5931616264344", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::paths;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{get_trait_def_id, is_allowed, is_automatically_derived, match_def_path};\n+use clippy_utils::{get_trait_def_id, is_automatically_derived, is_lint_allowed, match_def_path};\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, walk_fn, walk_item, FnKind, NestedVisitorMap, Visitor};\n@@ -362,7 +362,7 @@ fn check_unsafe_derive_deserialize<'tcx>(\n         if let ty::Adt(def, _) = ty.kind();\n         if let Some(local_def_id) = def.did.as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        if !is_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n+        if !is_lint_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n         if cx.tcx.inherent_impls(def.did)\n             .iter()\n             .map(|imp_did| item_from_def_id(cx, *imp_did))"}, {"sha": "0c19988a975a85b156031f4616084317be3c6059", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -550,7 +550,7 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n             FootnoteReference(text) | Text(text) => {\n                 let (begin, span) = get_current_span(spans, range.start);\n                 paragraph_span = paragraph_span.with_hi(span.hi());\n-                ticks_unbalanced |= text.contains('`');\n+                ticks_unbalanced |= text.contains('`') && !in_code;\n                 if Some(&text) == in_link.as_ref() || ticks_unbalanced {\n                     // Probably a link of the form `<http://example.com>`\n                     // Which are represented as a link to \"http://example.com\" with\n@@ -595,7 +595,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let handler = Handler::with_emitter(false, None, box emitter);\n                 let sess = ParseSess::with_span_handler(handler, sm);\n \n-                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code) {\n                     Ok(p) => p,\n                     Err(errs) => {\n                         for mut err in errs {\n@@ -653,7 +653,10 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n     // Because of the global session, we need to create a new session in a different thread with\n     // the edition we need.\n     let text = text.to_owned();\n-    if thread::spawn(move || has_needless_main(text, edition)).join().expect(\"thread::spawn failed\") {\n+    if thread::spawn(move || has_needless_main(text, edition))\n+        .join()\n+        .expect(\"thread::spawn failed\")\n+    {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "667eb8eb283bbb09997d47f8589bd86118e53e52", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,15 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher;\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, type_is_unsafe_function};\n+use clippy_utils::usage::UsedAfterExprVisitor;\n+use clippy_utils::{get_enclosing_loop_or_closure, higher};\n use clippy_utils::{is_adjusted, iter_input_pats};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{def_id, Expr, ExprKind, Param, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, ClosureKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -86,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     }\n }\n \n-fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n@@ -131,7 +132,18 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n-                    if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                    if let Some(mut snippet) = snippet_opt(cx, caller.span) {\n+                        if_chain! {\n+                            if let ty::Closure(_, substs) = fn_ty.kind();\n+                            if let ClosureKind::FnMut = substs.as_closure().kind();\n+                            if UsedAfterExprVisitor::is_found(cx, caller)\n+                                || get_enclosing_loop_or_closure(cx.tcx, expr).is_some();\n+\n+                            then {\n+                                // Mutable closure is used after current expr; we cannot consume it.\n+                                snippet = format!(\"&mut {}\", snippet);\n+                            }\n+                        }\n                         diag.span_suggestion(\n                             expr.span,\n                             \"replace the closure with the function itself\","}, {"sha": "66724294804a8414d1dfbbda3ac5050051fc4349", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 36, "deletions": 81, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,9 +1,9 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::higher::FormatArgsExpn;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -34,29 +34,26 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, _, unwrap_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, _, [write_call], _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n-            if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(write_fun, _, write_args, _) =\n-                unwrap_args[0].kind;\n+            if let ExprKind::MethodCall(write_fun, _, [write_recv, write_arg], _) = write_call.kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if !write_args.is_empty();\n-            if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n+            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n-            } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n+            } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n             };\n+            if let Some(format_args) = FormatArgsExpn::parse(write_arg);\n             then {\n-                let write_span = unwrap_args[0].span;\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n-                    if is_expn_of(write_span, \"writeln\").is_some() {\n+                    if is_expn_of(write_call.span, \"writeln\").is_some() {\n                         Some(\"writeln\")\n-                    } else if is_expn_of(write_span, \"write\").is_some() {\n+                    } else if is_expn_of(write_call.span, \"write\").is_some() {\n                         Some(\"write\")\n                     } else {\n                         None\n@@ -70,82 +67,40 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 // We need to remove the last trailing newline from the string because the\n                 // underlying `fmt::write` function doesn't know whether `println!` or `print!` was\n                 // used.\n-                if let Some(mut write_output) = write_output_string(write_args) {\n+                let (used, sugg_mac) = if let Some(macro_name) = calling_macro {\n+                    (\n+                        format!(\"{}!({}(), ...)\", macro_name, dest_name),\n+                        macro_name.replace(\"write\", \"print\"),\n+                    )\n+                } else {\n+                    (\n+                        format!(\"{}().write_fmt(...)\", dest_name),\n+                        \"print\".into(),\n+                    )\n+                };\n+                let msg = format!(\"use of `{}.unwrap()`\", used);\n+                if let [write_output] = *format_args.format_string_symbols {\n+                    let mut write_output = write_output.to_string();\n                     if write_output.ends_with('\\n') {\n                         write_output.pop();\n                     }\n \n-                    if let Some(macro_name) = calling_macro {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\n-                                \"use of `{}!({}(), ...).unwrap()`\",\n-                                macro_name,\n-                                dest_name\n-                            ),\n-                            \"try this\",\n-                            format!(\"{}{}!(\\\"{}\\\")\", prefix, macro_name.replace(\"write\", \"print\"), write_output.escape_default()),\n-                            Applicability::MachineApplicable\n-                        );\n-                    } else {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\"use of `{}().write_fmt(...).unwrap()`\", dest_name),\n-                            \"try this\",\n-                            format!(\"{}print!(\\\"{}\\\")\", prefix, write_output.escape_default()),\n-                            Applicability::MachineApplicable\n-                        );\n-                    }\n+                    let sugg = format!(\"{}{}!(\\\"{}\\\")\", prefix, sugg_mac, write_output.escape_default());\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXPLICIT_WRITE,\n+                        expr.span,\n+                        &msg,\n+                        \"try this\",\n+                        sugg,\n+                        Applicability::MachineApplicable\n+                    );\n                 } else {\n                     // We don't have a proper suggestion\n-                    if let Some(macro_name) = calling_macro {\n-                        span_lint(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\n-                                \"use of `{}!({}(), ...).unwrap()`. Consider using `{}{}!` instead\",\n-                                macro_name,\n-                                dest_name,\n-                                prefix,\n-                                macro_name.replace(\"write\", \"print\")\n-                            )\n-                        );\n-                    } else {\n-                        span_lint(\n-                            cx,\n-                            EXPLICIT_WRITE,\n-                            expr.span,\n-                            &format!(\"use of `{}().write_fmt(...).unwrap()`. Consider using `{}print!` instead\", dest_name, prefix),\n-                        );\n-                    }\n+                    let help = format!(\"consider using `{}{}!` instead\", prefix, sugg_mac);\n+                    span_lint_and_help(cx, EXPLICIT_WRITE, expr.span, &msg, None, &help);\n                 }\n-\n             }\n         }\n     }\n }\n-\n-// Extract the output string from the given `write_args`.\n-fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n-    if_chain! {\n-        // Obtain the string that should be printed\n-        if write_args.len() > 1;\n-        if let ExprKind::Call(_, output_args) = write_args[1].kind;\n-        if !output_args.is_empty();\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, output_string_expr) = output_args[0].kind;\n-        if let ExprKind::Array(string_exprs) = output_string_expr.kind;\n-        // we only want to provide an automatic suggestion for simple (non-format) strings\n-        if string_exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = string_exprs[0].kind;\n-        if let LitKind::Str(ref write_output, _) = lit.node;\n-        then {\n-            return Some(write_output.to_string())\n-        }\n-    }\n-    None\n-}"}, {"sha": "ca3490d8edad98c95df69f46abab20acf2335791", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 69, "deletions": 123, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,17 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::paths;\n-use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::last_path_segment;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_expn_of, last_path_segment, match_def_path, match_function_call};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, MatchSource, PatKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n+use rustc_span::symbol::kw;\n+use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `format!(\"string literal with no\n@@ -44,130 +43,78 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let span = match is_expn_of(expr.span, \"format\") {\n-            Some(s) if !s.from_expansion() => s,\n+        let FormatExpn { call_site, format_args } = match FormatExpn::parse(expr) {\n+            Some(e) if !e.call_site.from_expansion() => e,\n             _ => return,\n         };\n \n-        // Operate on the only argument of `alloc::fmt::format`.\n-        if let Some(sugg) = on_new_v1(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n-            span_useless_format(cx, span, \"consider using `.to_string()`\", sugg);\n-        }\n-    }\n-}\n-\n-fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg: String) {\n-    let to_replace = span.source_callsite();\n-\n-    // The callsite span contains the statement semicolon for some reason.\n-    let snippet = snippet(cx, to_replace, \"..\");\n-    if snippet.ends_with(';') {\n-        sugg.push(';');\n-    }\n-\n-    span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |diag| {\n-        diag.span_suggestion(\n-            to_replace,\n-            help,\n-            sugg,\n-            Applicability::MachineApplicable, // snippet\n-        );\n-    });\n-}\n-\n-fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n-    if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, format_args) = expr.kind;\n-        if let ExprKind::Array(elems) = arms[0].body.kind;\n-        if elems.len() == 1;\n-        if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n-        // matches `core::fmt::Display::fmt`\n-        if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].kind;\n-        if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n-        // check `(arg0,)` in match block\n-        if let PatKind::Tuple(pats, None) = arms[0].pat.kind;\n-        if pats.len() == 1;\n-        then {\n-            let ty = cx.typeck_results().pat_ty(pats[0]).peel_refs();\n-            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n-                return None;\n-            }\n-            if let ExprKind::Lit(ref lit) = format_args.kind {\n-                if let LitKind::Str(ref s, _) = lit.node {\n-                    return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+        let mut applicability = Applicability::MachineApplicable;\n+        if format_args.value_args.is_empty() {\n+            if_chain! {\n+                if let [e] = &*format_args.format_string_parts;\n+                if let ExprKind::Lit(lit) = &e.kind;\n+                if let Some(s_src) = snippet_opt(cx, lit.span);\n+                then {\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let sugg = format!(\"{}.to_string()\", s_expand);\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-            } else {\n-                let sugg = Sugg::hir(cx, format_args, \"<arg>\");\n-                if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n-                    if path.ident.name == sym!(to_string) {\n-                        return Some(format!(\"{}\", sugg));\n-                    }\n-                } else if let ExprKind::Binary(..) = format_args.kind {\n-                    return Some(format!(\"{}\", sugg));\n+            }\n+        } else if let [value] = *format_args.value_args {\n+            if_chain! {\n+                if format_args.format_string_symbols == [kw::Empty];\n+                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                    ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::string_type, adt.did),\n+                    ty::Str => true,\n+                    _ => false,\n+                };\n+                if format_args.args.iter().all(|e| is_display_arg(e));\n+                if format_args.fmt_expr.map_or(true, |e| check_unformatted(e));\n+                then {\n+                    let is_new_string = match value.kind {\n+                        ExprKind::Binary(..) => true,\n+                        ExprKind::MethodCall(path, ..) => path.ident.name.as_str() == \"to_string\",\n+                        _ => false,\n+                    };\n+                    let sugg = if is_new_string {\n+                        snippet_with_applicability(cx, value.span, \"..\", &mut applicability).into_owned()\n+                    } else {\n+                        let sugg = Sugg::hir_with_applicability(cx, value, \"<arg>\", &mut applicability);\n+                        format!(\"{}.to_string()\", sugg.maybe_par())\n+                    };\n+                    span_useless_format(cx, call_site, sugg, applicability);\n                 }\n-                return Some(format!(\"{}.to_string()\", sugg.maybe_par()));\n             }\n-        }\n+        };\n     }\n-    None\n }\n \n-fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n-    if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n-        if args.len() == 2;\n-        // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(ref s, _) = lit.node;\n-        // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-            if tup.is_empty() {\n-                if let Some(s_src) = snippet_opt(cx, lit.span) {\n-                    // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n-                    return Some(format!(\"{}.to_string()\", s_expand));\n-                }\n-            } else if s.as_str().is_empty() {\n-                return on_argumentv1_new(cx, &tup[0], arms);\n-            }\n-        }\n+fn span_useless_format(cx: &LateContext<'_>, span: Span, mut sugg: String, mut applicability: Applicability) {\n+    // The callsite span contains the statement semicolon for some reason.\n+    if snippet_with_applicability(cx, span, \"..\", &mut applicability).ends_with(';') {\n+        sugg.push(';');\n     }\n-    None\n+\n+    span_lint_and_sugg(\n+        cx,\n+        USELESS_FORMAT,\n+        span,\n+        \"useless use of `format!`\",\n+        \"consider using `.to_string()`\",\n+        sugg,\n+        applicability,\n+    );\n }\n \n-fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n+fn is_display_arg(expr: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n-        if args.len() == 3;\n-        if check_unformatted(&args[2]);\n-        // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n-        if let ExprKind::Array(pieces) = arr.kind;\n-        if pieces.len() == 1;\n-        if let ExprKind::Lit(ref lit) = pieces[0].kind;\n-        if let LitKind::Str(..) = lit.node;\n-        // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n-        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n-        if arms.len() == 1;\n-        if let ExprKind::Tup(tup) = matchee.kind;\n-        then {\n-            return on_argumentv1_new(cx, &tup[0], arms);\n-        }\n+        if let ExprKind::Call(_, [_, fmt]) = expr.kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = fmt.kind;\n+        if let [.., t, _] = path.segments;\n+        if t.ident.name.as_str() == \"Display\";\n+        then { true } else { false }\n     }\n-    None\n }\n \n /// Checks if the expression matches\n@@ -184,10 +131,9 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n-        if let ExprKind::Array(exprs) = expr.kind;\n-        if exprs.len() == 1;\n+        if let ExprKind::Array([expr]) = expr.kind;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, fields, _) = exprs[0].kind;\n+        if let ExprKind::Struct(_, fields, _) = expr.kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;"}, {"sha": "4f8f3aa96cb1b124add8817ab4358da09f6c9245", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,3 @@\n-#![cfg_attr(bootstrap, allow(rustc::default_hash_types))]\n-\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n "}, {"sha": "9641784eb9a27cbec1dd95e5886e417d0fb3b7a4", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,7 +1,7 @@\n //! lint on inherent implementations\n \n use clippy_utils::diagnostics::span_lint_and_note;\n-use clippy_utils::{in_macro, is_allowed};\n+use clippy_utils::{in_macro, is_lint_allowed};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{def_id::LocalDefId, Crate, Item, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n             .filter(|(&id, impls)| {\n                 impls.len() > 1\n                     // Check for `#[allow]` on the type definition\n-                    && !is_allowed(\n+                    && !is_lint_allowed(\n                         cx,\n                         MULTIPLE_INHERENT_IMPL,\n                         cx.tcx.hir().local_def_id_to_hir_id(id),\n@@ -123,7 +123,7 @@ fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n         ..\n     }) = cx.tcx.hir().get(id)\n     {\n-        (!in_macro(span) && impl_item.generics.params.is_empty() && !is_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n+        (!in_macro(span) && impl_item.generics.params.is_empty() && !is_lint_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n             .then(|| span)\n     } else {\n         None"}, {"sha": "892b3af0b32036b3d711d80c85b5d37d35c54c1b", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_item_name, get_parent_as_impl, is_allowed};\n+use clippy_utils::{get_item_name, get_parent_as_impl, is_lint_allowed};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -139,7 +139,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if let Some(ty_id) = cx.qpath_res(ty_path, imp.self_ty.hir_id).opt_def_id();\n             if let Some(local_id) = ty_id.as_local();\n             let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n-            if !is_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n+            if !is_lint_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n             if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.def_id).skip_binder());\n             then {\n                 let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {"}, {"sha": "1af3a215f4468b4211bd7aa28a1e74ce8648604f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -338,6 +338,7 @@ mod size_of_in_element_count;\n mod slow_vector_initialization;\n mod stable_sort_primitive;\n mod strings;\n+mod strlen_on_c_strings;\n mod suspicious_operation_groupings;\n mod suspicious_trait_impl;\n mod swap;\n@@ -914,6 +915,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         strings::STRING_LIT_AS_BYTES,\n         strings::STRING_TO_STRING,\n         strings::STR_TO_STRING,\n+        strlen_on_c_strings::STRLEN_ON_C_STRINGS,\n         suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n         suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n         suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL,\n@@ -944,6 +946,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         types::LINKEDLIST,\n         types::OPTION_OPTION,\n         types::RC_BUFFER,\n+        types::RC_MUTEX,\n         types::REDUNDANT_ALLOCATION,\n         types::TYPE_COMPLEXITY,\n         types::VEC_BOX,\n@@ -1042,6 +1045,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(strings::STRING_TO_STRING),\n         LintId::of(strings::STR_TO_STRING),\n         LintId::of(types::RC_BUFFER),\n+        LintId::of(types::RC_MUTEX),\n         LintId::of(unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS),\n         LintId::of(unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(verbose_file_reads::VERBOSE_FILE_READS),\n@@ -1375,7 +1379,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n         LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n         LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-        LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n         LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n         LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n         LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n@@ -1409,6 +1412,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n         LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n+        LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n         LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n         LintId::of(swap::ALMOST_SWAPPED),\n@@ -1546,7 +1550,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n         LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n         LintId::of(non_expressive_names::MANY_SINGLE_CHAR_NAMES),\n-        LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n         LintId::of(ptr::CMP_NULL),\n         LintId::of(ptr::PTR_ARG),\n         LintId::of(ptr_eq::PTR_EQ),\n@@ -1639,6 +1642,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(reference::REF_IN_DEREF),\n         LintId::of(repeat_once::REPEAT_ONCE),\n         LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n+        LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n         LintId::of(swap::MANUAL_SWAP),\n         LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n@@ -1791,6 +1795,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(mutex_atomic::MUTEX_INTEGER),\n+        LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n         LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n         LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n         LintId::of(regex::TRIVIAL_REGEX),\n@@ -2095,6 +2100,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box missing_enforced_import_rename::ImportRename::new(import_renames.clone()));\n     let scripts = conf.allowed_scripts.clone();\n     store.register_early_pass(move || box disallowed_script_idents::DisallowedScriptIdents::new(&scripts));\n+    store.register_late_pass(|| box strlen_on_c_strings::StrlenOnCStrings);\n }\n \n #[rustfmt::skip]"}, {"sha": "7d5ed3ab0a751ff67101324c4479fdf138981f04", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "563d5cdb5fb568046dfb447e2c5db8ee6626fe4a", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, path_to_local_id,\n+    can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n     peel_hir_expr_refs,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n@@ -102,7 +102,7 @@ impl LateLintPass<'_> for ManualMap {\n \n             // These two lints will go back and forth with each other.\n             if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n-                && !is_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+                && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n             {\n                 return;\n             }\n@@ -146,7 +146,7 @@ impl LateLintPass<'_> for ManualMap {\n                     },\n                     _ => {\n                         if path_to_local_id(some_expr, id)\n-                            && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                            && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                             && binding_ref.is_some()\n                         {\n                             return;"}, {"sha": "986469a2b698cd47133f6c5a1660ef568843e6a4", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -7,7 +7,7 @@ use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n use clippy_utils::visitors::LocalUsedVisitor;\n use clippy_utils::{\n-    get_parent_expr, in_macro, is_allowed, is_expn_of, is_lang_ctor, is_refutable, is_wild, meets_msrv, msrvs,\n+    get_parent_expr, in_macro, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_wild, meets_msrv, msrvs,\n     path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n     strip_pat_refs,\n };\n@@ -707,7 +707,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n         };\n \n         let ty = cx.typeck_results().expr_ty(ex);\n-        if *ty.kind() != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }"}, {"sha": "f8ee31a00df821ebc0e6f7834d666b3adb3a40d5", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_expn_of;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::higher::FormatExpn;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -94,27 +93,6 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         }\n     }\n \n-    fn generate_format_arg_snippet(\n-        cx: &LateContext<'_>,\n-        a: &hir::Expr<'_>,\n-        applicability: &mut Applicability,\n-    ) -> Vec<String> {\n-        if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, format_arg) = a.kind;\n-            if let hir::ExprKind::Match(format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(format_arg_expr_tup) = format_arg_expr.kind;\n-\n-            then {\n-                format_arg_expr_tup\n-                    .iter()\n-                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n-                    .collect()\n-            } else {\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n     fn is_call(node: &hir::ExprKind<'_>) -> bool {\n         match node {\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n@@ -150,36 +128,22 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n     let mut applicability = Applicability::MachineApplicable;\n \n     //Special handling for `format!` as arg_root\n-    if_chain! {\n-        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n-        if block.stmts.len() == 1;\n-        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n-        if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(inner_fun, inner_args) = arg_root.kind;\n-        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n-        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n-        then {\n-            let fmt_spec = &format_args[0];\n-            let fmt_args = &format_args[1];\n-\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n-\n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n-\n-            let sugg = args.join(\", \");\n-\n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n-                applicability,\n-            );\n-\n-            return;\n-        }\n+    if let Some(format_expn) = FormatExpn::parse(arg_root) {\n+        let span = match *format_expn.format_args.value_args {\n+            [] => format_expn.format_args.format_string_span,\n+            [.., last] => format_expn.format_args.format_string_span.to(last.span),\n+        };\n+        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+        span_lint_and_sugg(\n+            cx,\n+            EXPECT_FUN_CALL,\n+            span_replace_word,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+            applicability,\n+        );\n+        return;\n     }\n \n     let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);"}, {"sha": "ec1572c26c262acc21ace9b4e95479828d4d86cd", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -55,6 +56,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.doc_str().is_some());\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "f5ce3e325512d5b838a9447c8b3517ca44315bbe", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,7 +1,7 @@\n //! lint on multiple versions of a crate being used\n \n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::run_lints;\n+use clippy_utils::is_lint_allowed;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::{Crate, CRATE_HIR_ID};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -39,7 +39,7 @@ declare_lint_pass!(MultipleCrateVersions => [MULTIPLE_CRATE_VERSIONS]);\n \n impl LateLintPass<'_> for MultipleCrateVersions {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n-        if !run_lints(cx, &[MULTIPLE_CRATE_VERSIONS], CRATE_HIR_ID) {\n+        if is_lint_allowed(cx, MULTIPLE_CRATE_VERSIONS, CRATE_HIR_ID) {\n             return;\n         }\n "}, {"sha": "4dbbb14c504fa445f334b4b008ac248ed911a17b", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -120,8 +120,8 @@ fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bo\n         },\n         Tuple(..) => ty.tuple_fields().any(|ty| is_mutable_type(cx, ty, span)),\n         Adt(..) => {\n-            cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                && !ty.has_escaping_bound_vars()\n+            !ty.has_escaping_bound_vars()\n+                && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n                 && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n         },\n         _ => false,"}, {"sha": "81bf853300fe5aa4014612ec533aa55e572ea1a9", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "780690548e52b7008d3ccd590a4592050e054161", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -71,6 +71,9 @@ declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n+        if e.span.from_expansion() {\n+            return;\n+        }\n         if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "b81f8d24a33e98a9dfd166fc0dc865e8269812ba", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "043e7fa30d6e96867dec515ecc2c5ed6800de8dc", "filename": "clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -31,7 +31,7 @@ declare_clippy_lint! {\n     /// vec![1, 2, 3];\n     /// ```\n     pub NONSTANDARD_MACRO_BRACES,\n-    style,\n+    nursery,\n     \"check consistent use of braces in macro\"\n }\n \n@@ -92,14 +92,18 @@ impl EarlyLintPass for MacroBraces {\n     }\n }\n \n-fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, this: &'a MacroBraces) -> Option<MacroInfo<'a>> {\n+fn is_offending_macro<'a>(cx: &EarlyContext<'_>, span: Span, mac_braces: &'a MacroBraces) -> Option<MacroInfo<'a>> {\n     if_chain! {\n         if in_macro(span);\n-        if let Some((name, braces)) = find_matching_macro(span, &this.macro_braces);\n+        if let Some((name, braces)) = find_matching_macro(span, &mac_braces.macro_braces);\n         if let Some(snip) = snippet_opt(cx, span.ctxt().outer_expn_data().call_site);\n-        let c = snip.replace(\" \", \"\"); // make formatting consistent\n+        // we must check only invocation sites\n+        // https://github.com/rust-lang/rust-clippy/issues/7422\n+        if snip.starts_with(name);\n+        // make formatting consistent\n+        let c = snip.replace(\" \", \"\");\n         if !c.starts_with(&format!(\"{}!{}\", name, braces.0));\n-        if !this.done.contains(&span.ctxt().outer_expn_data().call_site);\n+        if !mac_braces.done.contains(&span.ctxt().outer_expn_data().call_site);\n         then {\n             Some((name, braces, snip))\n         } else {"}, {"sha": "dc28874c16e67febf474f13cda31f1dcb38e5711", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -74,7 +74,9 @@ declare_lint_pass!(PanicUnimplemented => [UNIMPLEMENTED, UNREACHABLE, TODO, PANI\n \n impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if match_panic_call(cx, expr).is_some() && is_expn_of(expr.span, \"debug_assert\").is_none() {\n+        if match_panic_call(cx, expr).is_some()\n+            && (is_expn_of(expr.span, \"debug_assert\").is_none() && is_expn_of(expr.span, \"assert\").is_none())\n+        {\n             let span = get_outer_span(expr);\n             if is_expn_of(expr.span, \"unimplemented\").is_some() {\n                 span_lint("}, {"sha": "dba3b1805cd595df2029aa7c67ce823e8b8423c8", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_the\n use clippy_utils::ptr::get_spans;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{is_type_diagnostic_item, match_type, walk_ptrs_hir_ty};\n-use clippy_utils::{expr_path_res, is_allowed, match_any_def_paths, paths};\n+use clippy_utils::{expr_path_res, is_lint_allowed, match_any_def_paths, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -246,7 +246,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n     for (idx, (arg, ty)) in decl.inputs.iter().zip(fn_ty.inputs()).enumerate() {\n         // Honor the allow attribute on parameters. See issue 5644.\n         if let Some(body) = &body {\n-            if is_allowed(cx, PTR_ARG, body.params[idx].hir_id) {\n+            if is_lint_allowed(cx, PTR_ARG, body.params[idx].hir_id) {\n                 continue;\n             }\n         }"}, {"sha": "56ef95a88c88081da4b83fbc44da66b8759df5cf", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 103, "deletions": 7, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -12,6 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::{\n     self, traversal,\n     visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n+    Mutability,\n };\n use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n@@ -87,13 +88,18 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n \n         let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n \n+        let possible_origin = {\n+            let mut vis = PossibleOriginVisitor::new(mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx)\n+        };\n         let maybe_storage_live_result = MaybeStorageLive\n             .into_engine(cx.tcx, mir)\n             .pass_name(\"redundant_clone\")\n             .iterate_to_fixpoint()\n             .into_results_cursor(mir);\n         let mut possible_borrower = {\n-            let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n+            let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n             vis.visit_body(mir);\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n@@ -509,14 +515,20 @@ struct PossibleBorrowerVisitor<'a, 'tcx> {\n     possible_borrower: TransitiveRelation<mir::Local>,\n     body: &'a mir::Body<'tcx>,\n     cx: &'a LateContext<'tcx>,\n+    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n }\n \n impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, body: &'a mir::Body<'tcx>) -> Self {\n+    fn new(\n+        cx: &'a LateContext<'tcx>,\n+        body: &'a mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n         Self {\n             possible_borrower: TransitiveRelation::default(),\n             cx,\n             body,\n+            possible_origin,\n         }\n     }\n \n@@ -585,21 +597,105 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n             ..\n         } = &terminator.kind\n         {\n+            // TODO add doc\n             // If the call returns something with lifetimes,\n             // let's conservatively assume the returned value contains lifetime of all the arguments.\n             // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_continue() {\n-                return;\n-            }\n+\n+            let mut immutable_borrowers = vec![];\n+            let mut mutable_borrowers = vec![];\n \n             for op in args {\n                 match op {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                        self.possible_borrower.add(p.local, *dest);\n+                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n+                            mutable_borrowers.push(p.local);\n+                        } else {\n+                            immutable_borrowers.push(p.local);\n+                        }\n                     },\n                     mir::Operand::Constant(..) => (),\n                 }\n             }\n+\n+            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n+                .iter()\n+                .filter_map(|r| self.possible_origin.get(r))\n+                .flat_map(HybridBitSet::iter)\n+                .collect();\n+\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+                mutable_variables.push(*dest);\n+            }\n+\n+            for y in mutable_variables {\n+                for x in &immutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+                for x in &mutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Collect possible borrowed for every `&mut` local.\n+/// For exampel, `_1 = &mut _2` generate _1: {_2,...}\n+/// Known Problems: not sure all borrowed are tracked\n+struct PossibleOriginVisitor<'a, 'tcx> {\n+    possible_origin: TransitiveRelation<mir::Local>,\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n+    fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_origin: TransitiveRelation::default(),\n+            body,\n+        }\n+    }\n+\n+    fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let borrowers = self.possible_origin.reachable_from(&row);\n+            if !borrowers.is_empty() {\n+                let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n+                for &c in borrowers {\n+                    if c != mir::Local::from_usize(0) {\n+                        bs.insert(c);\n+                    }\n+                }\n+\n+                if !bs.is_empty() {\n+                    map.insert(row, bs);\n+                }\n+            }\n+        }\n+        map\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            // Only consider `&mut`, which can modify origin place\n+            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n+            // _2: &mut _;\n+            // _3 = move _2\n+            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n+            // _3 = move _2 as &mut _;\n+            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n+                => {\n+                self.possible_origin.add(lhs, borrowed.local);\n+            },\n+            _ => {},\n         }\n     }\n }\n@@ -628,7 +724,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "958e462125ef1cafc3d823bdc1d984de575db6f6", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sug\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n-use clippy_utils::{get_parent_expr, is_allowed, match_function_call, method_calls, paths};\n+use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method_calls, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n         ) = e.kind\n         {\n             if is_string(cx, left) {\n-                if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n+                if !is_lint_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n                         if let ExprKind::Assign(target, _, _) = p.kind {"}, {"sha": "2ccf3a3796d512379b7b6f9f067747384c3bf9d1", "filename": "clippy_lints/src/strlen_on_c_strings.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,82 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::in_macro;\n+use clippy_utils::paths;\n+use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_ref_to_diagnostic_item};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::{sym, Symbol};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `libc::strlen` on a `CString` or `CStr` value,\n+    /// and suggest calling `as_bytes().len()` or `to_bytes().len()` respectively instead.\n+    ///\n+    /// **Why is this bad?** This avoids calling an unsafe `libc` function.\n+    /// Currently, it also avoids calculating the length.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust, ignore\n+    /// use std::ffi::CString;\n+    /// let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n+    /// let len = unsafe { libc::strlen(cstring.as_ptr()) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust, no_run\n+    /// use std::ffi::CString;\n+    /// let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n+    /// let len = cstring.as_bytes().len();\n+    /// ```\n+    pub STRLEN_ON_C_STRINGS,\n+    complexity,\n+    \"using `libc::strlen` on a `CString` or `CStr` value, while `as_bytes().len()` or `to_bytes().len()` respectively can be used instead\"\n+}\n+\n+declare_lint_pass!(StrlenOnCStrings => [STRLEN_ON_C_STRINGS]);\n+\n+impl LateLintPass<'tcx> for StrlenOnCStrings {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if in_macro(expr.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let hir::ExprKind::Call(func, [recv]) = expr.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = func.kind;\n+\n+            if (&paths::LIBC_STRLEN).iter().map(|x| Symbol::intern(x)).eq(\n+                path.segments.iter().map(|seg| seg.ident.name));\n+            if let hir::ExprKind::MethodCall(path, _, args, _) = recv.kind;\n+            if args.len() == 1;\n+            if !args.iter().any(|e| e.span.from_expansion());\n+            if path.ident.name == sym::as_ptr;\n+            then {\n+                let cstring = &args[0];\n+                let ty = cx.typeck_results().expr_ty(cstring);\n+                let val_name = snippet_with_macro_callsite(cx, cstring.span, \"..\");\n+                let sugg = if is_type_diagnostic_item(cx, ty, sym::cstring_type){\n+                    format!(\"{}.as_bytes().len()\", val_name)\n+                } else if is_type_ref_to_diagnostic_item(cx, ty, sym::CStr){\n+                    format!(\"{}.to_bytes().len()\", val_name)\n+                } else {\n+                    return;\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    STRLEN_ON_C_STRINGS,\n+                    expr.span,\n+                    \"using `libc::strlen` on a `CString` or `CStr` value\",\n+                    \"try this (you might also need to get rid of `unsafe` block in some cases):\",\n+                    sugg,\n+                    Applicability::Unspecified // Sometimes unnecessary `unsafe` block\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "7d629b5455b62913f4b480ce67fed09e65c1c4f1", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -3,6 +3,7 @@ mod box_vec;\n mod linked_list;\n mod option_option;\n mod rc_buffer;\n+mod rc_mutex;\n mod redundant_allocation;\n mod type_complexity;\n mod utils;\n@@ -177,8 +178,8 @@ declare_clippy_lint! {\n declare_clippy_lint! {\n     /// **What it does:** Checks for use of redundant allocations anywhere in the code.\n     ///\n-    /// **Why is this bad?** Expressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Box<T>>`, `Box<&T>`\n-    /// add an unnecessary level of indirection.\n+    /// **Why is this bad?** Expressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, Arc<&T>`, `Arc<Rc<T>>`,\n+    /// `Arc<Arc<T>>`, `Arc<Box<T>>`, `Box<&T>`, `Box<Rc<T>>`, `Box<Arc<T>>`, `Box<Box<T>>`, add an unnecessary level of indirection.\n     ///\n     /// **Known problems:** None.\n     ///\n@@ -250,12 +251,41 @@ declare_clippy_lint! {\n     \"usage of very complex types that might be better factored into `type` definitions\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `Rc<Mutex<T>>`.\n+    ///\n+    /// **Why is this bad?** `Rc` is used in single thread and `Mutex` is used in multi thread.\n+    /// Consider using `Rc<RefCell<T>>` in single thread or `Arc<Mutex<T>>` in multi thread.\n+    ///\n+    /// **Known problems:** Sometimes combining generic types can lead to the requirement that a\n+    /// type use Rc in conjunction with Mutex. We must consider those cases false positives, but\n+    /// alas they are quite hard to rule out. Luckily they are also rare.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// use std::rc::Rc;\n+    /// use std::sync::Mutex;\n+    /// fn foo(interned: Rc<Mutex<i32>>) { ... }\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust,ignore\n+    /// use std::rc::Rc;\n+    /// use std::cell::RefCell\n+    /// fn foo(interned: Rc<RefCell<i32>>) { ... }\n+    /// ```\n+    pub RC_MUTEX,\n+    restriction,\n+    \"usage of `Rc<Mutex<T>>`\"\n+}\n+\n pub struct Types {\n     vec_box_size_threshold: u64,\n     type_complexity_threshold: u64,\n }\n \n-impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, TYPE_COMPLEXITY]);\n+impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, RC_MUTEX, TYPE_COMPLEXITY]);\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n@@ -375,6 +405,7 @@ impl Types {\n                     triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n                     triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n                     triggered |= linked_list::check(cx, hir_ty, def_id);\n+                    triggered |= rc_mutex::check(cx, hir_ty, qpath, def_id);\n \n                     if triggered {\n                         return;"}, {"sha": "bd7a0ee6408fa2078868c1d493d8d4192dc9ad30", "filename": "clippy_lints/src/types/rc_mutex.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,27 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_ty_param_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::RC_MUTEX;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if_chain! {\n+        if cx.tcx.is_diagnostic_item(sym::Rc, def_id) ;\n+        if let Some(_) = is_ty_param_diagnostic_item(cx, qpath, sym!(mutex_type)) ;\n+\n+        then{\n+            span_lint(\n+                cx,\n+                RC_MUTEX,\n+                hir_ty.span,\n+                \"found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\",\n+            );\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "8e83dcbf704e0930fecd8384910e51acbc10fa9e", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 89, "deletions": 64, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,5 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::{get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item};\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n@@ -9,74 +9,99 @@ use rustc_span::symbol::sym;\n use super::{utils, REDUNDANT_ALLOCATION};\n \n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n-    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-        if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                REDUNDANT_ALLOCATION,\n-                hir_ty.span,\n-                \"usage of `Box<&T>`\",\n-                \"try\",\n-                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                applicability,\n-            );\n-            return true;\n-        }\n+    let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+        \"Box\"\n+    } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        \"Rc\"\n+    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n+        \"Arc\"\n+    } else {\n+        return false;\n+    };\n+\n+    if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n+        let mut applicability = Applicability::MaybeIncorrect;\n+        let generic_snippet = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_ALLOCATION,\n+            hir_ty.span,\n+            &format!(\"usage of `{}<{}>`\", outer_sym, generic_snippet),\n+            |diag| {\n+                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{}\", generic_snippet), applicability);\n+                diag.note(&format!(\n+                    \"`{generic}` is already a pointer, `{outer}<{generic}>` allocates a pointer on the heap\",\n+                    outer = outer_sym,\n+                    generic = generic_snippet\n+                ));\n+            },\n+        );\n+        return true;\n     }\n \n-    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                REDUNDANT_ALLOCATION,\n-                hir_ty.span,\n-                \"usage of `Rc<Rc<T>>`\",\n-                \"try\",\n-                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n-                applicability,\n-            );\n-            true\n-        } else if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n-            let qpath = match &ty.kind {\n-                TyKind::Path(qpath) => qpath,\n-                _ => return false,\n-            };\n-            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                Some(ty) => ty.span,\n-                None => return false,\n-            };\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                REDUNDANT_ALLOCATION,\n-                hir_ty.span,\n-                \"usage of `Rc<Box<T>>`\",\n-                \"try\",\n-                format!(\n-                    \"Rc<{}>\",\n-                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-            true\n-        } else {\n-            utils::match_borrows_parameter(cx, qpath).map_or(false, |span| {\n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_ALLOCATION,\n+    let (inner_sym, ty) = if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n+        (\"Box\", ty)\n+    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n+        (\"Rc\", ty)\n+    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Arc) {\n+        (\"Arc\", ty)\n+    } else {\n+        return false;\n+    };\n+\n+    let inner_qpath = match &ty.kind {\n+        TyKind::Path(inner_qpath) => inner_qpath,\n+        _ => return false,\n+    };\n+    let inner_span = match get_qpath_generic_tys(inner_qpath).next() {\n+        Some(ty) => ty.span,\n+        None => return false,\n+    };\n+    if inner_sym == outer_sym {\n+        let mut applicability = Applicability::MaybeIncorrect;\n+        let generic_snippet = snippet_with_applicability(cx, inner_span, \"..\", &mut applicability);\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_ALLOCATION,\n+            hir_ty.span,\n+            &format!(\"usage of `{}<{}<{}>>`\", outer_sym, inner_sym, generic_snippet),\n+            |diag| {\n+                diag.span_suggestion(\n                     hir_ty.span,\n-                    \"usage of `Rc<&T>`\",\n                     \"try\",\n-                    snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                    format!(\"{}<{}>\", outer_sym, generic_snippet),\n                     applicability,\n                 );\n-                true\n-            })\n-        }\n+                diag.note(&format!(\n+                    \"`{inner}<{generic}>` is already on the heap, `{outer}<{inner}<{generic}>>` makes an extra allocation\",\n+                    outer = outer_sym,\n+                    inner = inner_sym,\n+                    generic = generic_snippet\n+                ));\n+            },\n+        );\n     } else {\n-        false\n+        let generic_snippet = snippet(cx, inner_span, \"..\");\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_ALLOCATION,\n+            hir_ty.span,\n+            &format!(\"usage of `{}<{}<{}>>`\", outer_sym, inner_sym, generic_snippet),\n+            |diag| {\n+                diag.note(&format!(\n+                    \"`{inner}<{generic}>` is already on the heap, `{outer}<{inner}<{generic}>>` makes an extra allocation\",\n+                    outer = outer_sym,\n+                    inner = inner_sym,\n+                    generic = generic_snippet\n+                ));\n+                diag.help(&format!(\n+                    \"consider using just `{outer}<{generic}>` or `{inner}<{generic}>`\",\n+                    outer = outer_sym,\n+                    inner = inner_sym,\n+                    generic = generic_snippet\n+                ));\n+            },\n+        );\n     }\n+    true\n }"}, {"sha": "2f0a61898ba75347c7a702004c54826e6ca9e045", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_allowed;\n+use clippy_utils::is_lint_allowed;\n use clippy_utils::source::snippet;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -114,15 +114,15 @@ fn check_str(cx: &LateContext<'_>, span: Span, id: HirId) {\n             span,\n             \"literal non-ASCII character detected\",\n             \"consider replacing the string with\",\n-            if is_allowed(cx, UNICODE_NOT_NFC, id) {\n+            if is_lint_allowed(cx, UNICODE_NOT_NFC, id) {\n                 escape(string.chars())\n             } else {\n                 escape(string.nfc())\n             },\n             Applicability::MachineApplicable,\n         );\n     }\n-    if is_allowed(cx, NON_ASCII_LITERAL, id) && string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n+    if is_lint_allowed(cx, NON_ASCII_LITERAL, id) && string.chars().zip(string.nfc()).any(|(a, b)| a != b) {\n         span_lint_and_sugg(\n             cx,\n             UNICODE_NOT_NFC,"}, {"sha": "ab0cdf75ffe0a02feceb516f65091d1f0e0e93ef", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -24,6 +24,10 @@ declare_clippy_lint! {\n     ///     ()\n     /// }\n     /// ```\n+    /// is equivalent to\n+    /// ```rust\n+    /// fn return_unit() {}\n+    /// ```\n     pub UNUSED_UNIT,\n     style,\n     \"needless unit expression\""}, {"sha": "71117e967e31941af9da90b9239e05edf794c4bf", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -87,11 +87,8 @@ const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     fn check_item(&mut self, _cx: &LateContext<'_>, item: &Item<'_>) {\n-        if !is_item_interesting(item) {\n-            // This does two things:\n-            //  1) Reduce needless churn on `self.stack`\n-            //  2) Don't push `StackItem::NoCheck` when entering `ItemKind::OpaqueTy`,\n-            //     in order to lint `foo() -> impl <..>`\n+        if matches!(item.kind, ItemKind::OpaqueTy(_)) {\n+            // skip over `ItemKind::OpaqueTy` in order to lint `foo() -> impl <..>`\n             return;\n         }\n         // We push the self types of `impl`s on a stack here. Only the top type on the stack is\n@@ -119,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'_>, item: &Item<'_>) {\n-        if is_item_interesting(item) {\n+        if !matches!(item.kind, ItemKind::OpaqueTy(_)) {\n             self.stack.pop();\n         }\n     }\n@@ -297,11 +294,3 @@ fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n         span_lint(cx, span);\n     }\n }\n-\n-fn is_item_interesting(item: &Item<'_>) -> bool {\n-    use rustc_hir::ItemKind::{Const, Enum, Fn, Impl, Static, Struct, Trait, Union};\n-    matches!(\n-        item.kind,\n-        Impl { .. } | Static(..) | Const(..) | Fn(..) | Enum(..) | Struct(..) | Union(..) | Trait(..)\n-    )\n-}"}, {"sha": "668807f499f3ffde3a121cc87b1a92dc8f0a6a49", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sug\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, is_expr_path_def_path, match_def_path, method_calls, path_to_res, paths, run_lints,\n-    SpanlessEq,\n+    is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls, path_to_res,\n+    paths, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n@@ -353,7 +353,7 @@ impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if !run_lints(cx, &[DEFAULT_LINT], item.hir_id()) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id()) {\n             return;\n         }\n \n@@ -411,7 +411,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     }\n \n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n-        if !run_lints(cx, &[LINT_WITHOUT_LINT_PASS], CRATE_HIR_ID) {\n+        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n             return;\n         }\n \n@@ -497,7 +497,7 @@ impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !run_lints(cx, &[COMPILER_LINT_FUNCTIONS], expr.hir_id) {\n+        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n             return;\n         }\n \n@@ -526,7 +526,7 @@ declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n \n impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !run_lints(cx, &[OUTER_EXPN_EXPN_DATA], expr.hir_id) {\n+        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n             return;\n         }\n \n@@ -576,7 +576,7 @@ declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n \n impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !run_lints(cx, &[COLLAPSIBLE_SPAN_LINT_CALLS], expr.hir_id) {\n+        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n             return;\n         }\n \n@@ -757,7 +757,7 @@ declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n \n impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !run_lints(cx, &[MATCH_TYPE_ON_DIAGNOSTIC_ITEM], expr.hir_id) {\n+        if is_lint_allowed(cx, MATCH_TYPE_ON_DIAGNOSTIC_ITEM, expr.hir_id) {\n             return;\n         }\n "}, {"sha": "3eccc89cdeb808f813a32177d5af76f6819c0fed", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -520,7 +520,9 @@ fn get_lint_group_and_level_or_lint(\n     lint_name: &str,\n     item: &'hir Item<'_>,\n ) -> Option<(String, &'static str)> {\n-    let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n+    let result = cx\n+        .lint_store\n+        .check_lint_name(cx.sess(), lint_name, Some(sym::clippy), &[]);\n     if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n         if let Some(group) = get_lint_group(cx, lint_lst[0]) {\n             if EXCLUDED_LINT_GROUPS.contains(&group.as_str()) {"}, {"sha": "1ca1117a41ea5fccef9b7eb067b6a46f3856e81e", "filename": "clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::run_lints;\n+use clippy_utils::{diagnostics::span_lint, is_lint_allowed};\n use rustc_hir::{hir_id::CRATE_HIR_ID, Crate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -31,7 +30,7 @@ declare_lint_pass!(WildcardDependencies => [WILDCARD_DEPENDENCIES]);\n \n impl LateLintPass<'_> for WildcardDependencies {\n     fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n-        if !run_lints(cx, &[WILDCARD_DEPENDENCIES], CRATE_HIR_ID) {\n+        if is_lint_allowed(cx, WILDCARD_DEPENDENCIES, CRATE_HIR_ID) {\n             return;\n         }\n "}, {"sha": "3e3e472e99fb69215e7e07b2c70d34c4842674dd", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -5,11 +5,11 @@\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n-use rustc_span::source_map::Span;\n+use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -266,3 +266,107 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n     }\n     None\n }\n+\n+/// A parsed `format!` expansion\n+pub struct FormatExpn<'tcx> {\n+    /// Span of `format!(..)`\n+    pub call_site: Span,\n+    /// Inner `format_args!` expansion\n+    pub format_args: FormatArgsExpn<'tcx>,\n+}\n+\n+impl FormatExpn<'tcx> {\n+    /// Parses an expanded `format!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExprKind::Block(block, _) = expr.kind;\n+            if let [stmt] = block.stmts;\n+            if let StmtKind::Local(local) = stmt.kind;\n+            if let Some(init) = local.init;\n+            if let ExprKind::Call(_, [format_args]) = init.kind;\n+            let expn_data = expr.span.ctxt().outer_expn_data();\n+            if let ExpnKind::Macro(_, sym::format) = expn_data.kind;\n+            if let Some(format_args) = FormatArgsExpn::parse(format_args);\n+            then {\n+                Some(FormatExpn {\n+                    call_site: expn_data.call_site,\n+                    format_args,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// A parsed `format_args!` expansion\n+pub struct FormatArgsExpn<'tcx> {\n+    /// Span of the first argument, the format string\n+    pub format_string_span: Span,\n+    /// Values passed after the format string\n+    pub value_args: Vec<&'tcx Expr<'tcx>>,\n+\n+    /// String literal expressions which represent the format string split by \"{}\"\n+    pub format_string_parts: &'tcx [Expr<'tcx>],\n+    /// Symbols corresponding to [`format_string_parts`]\n+    pub format_string_symbols: Vec<Symbol>,\n+    /// Expressions like `ArgumentV1::new(arg0, Debug::fmt)`\n+    pub args: &'tcx [Expr<'tcx>],\n+    /// The final argument passed to `Arguments::new_v1_formatted`, if applicable\n+    pub fmt_expr: Option<&'tcx Expr<'tcx>>,\n+}\n+\n+impl FormatArgsExpn<'tcx> {\n+    /// Parses an expanded `format_args!` or `format_args_nl!` invocation\n+    pub fn parse(expr: &'tcx Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let ExpnKind::Macro(_, name) = expr.span.ctxt().outer_expn_data().kind;\n+            let name = name.as_str();\n+            if name.ends_with(\"format_args\") || name.ends_with(\"format_args_nl\");\n+            if let ExprKind::Call(_, args) = expr.kind;\n+            if let Some((strs_ref, args, fmt_expr)) = match args {\n+                // Arguments::new_v1\n+                [strs_ref, args] => Some((strs_ref, args, None)),\n+                // Arguments::new_v1_formatted\n+                [strs_ref, args, fmt_expr] => Some((strs_ref, args, Some(fmt_expr))),\n+                _ => None,\n+            };\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, strs_arr) = strs_ref.kind;\n+            if let ExprKind::Array(format_string_parts) = strs_arr.kind;\n+            if let Some(format_string_symbols) = format_string_parts\n+                .iter()\n+                .map(|e| {\n+                    if let ExprKind::Lit(lit) = &e.kind {\n+                        if let LitKind::Str(symbol, _style) = lit.node {\n+                            return Some(symbol);\n+                        }\n+                    }\n+                    None\n+                })\n+                .collect();\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args.kind;\n+            if let ExprKind::Match(args, [arm], _) = args.kind;\n+            if let ExprKind::Tup(value_args) = args.kind;\n+            if let Some(value_args) = value_args\n+                .iter()\n+                .map(|e| match e.kind {\n+                    ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                })\n+                .collect();\n+            if let ExprKind::Array(args) = arm.body.kind;\n+            then {\n+                Some(FormatArgsExpn {\n+                    format_string_span: strs_ref.span,\n+                    value_args,\n+                    format_string_parts,\n+                    format_string_symbols,\n+                    args,\n+                    fmt_expr,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "6db221ab0fdfdf2a3893c623e14afc0d7eb479a5", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1163,7 +1163,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n /// Returns `true` if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n+pub fn is_lint_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1531,25 +1531,6 @@ pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n     }\n }\n \n-/// This function checks if any of the lints in the slice is enabled for the provided `HirId`.\n-/// A lint counts as enabled with any of the levels: `Level::Forbid` | `Level::Deny` | `Level::Warn`\n-///\n-/// ```ignore\n-/// #[deny(clippy::YOUR_AWESOME_LINT)]\n-/// println!(\"Hello, World!\"); // <- Clippy code: run_lints(cx, &[YOUR_AWESOME_LINT], id) == true\n-///\n-/// #[allow(clippy::YOUR_AWESOME_LINT)]\n-/// println!(\"See you soon!\"); // <- Clippy code: run_lints(cx, &[YOUR_AWESOME_LINT], id) == false\n-/// ```\n-pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n-    lints.iter().any(|lint| {\n-        matches!(\n-            cx.tcx.lint_level_at_node(lint, id),\n-            (Level::Forbid | Level::Deny | Level::Warn, _)\n-        )\n-    })\n-}\n-\n /// Returns Option<String> where String is a textual representation of the type encapsulated in the\n /// slice iff the given expression is a slice of primitives (as defined in the\n /// `is_recursively_primitive_type` function) and None otherwise."}, {"sha": "4a28c7dd9a04a3885251ef7ab44e7d5ea65aa7fe", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -162,6 +162,9 @@ impl<'a> NumericLiteral<'a> {\n         }\n \n         if let Some(suffix) = self.suffix {\n+            if output.ends_with('.') {\n+                output.push('0');\n+            }\n             output.push('_');\n             output.push_str(suffix);\n         }"}, {"sha": "c960eec306414620449cd6d05e189080b8752867", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -38,7 +38,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n-pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n@@ -50,9 +49,6 @@ pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n-pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n-pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n@@ -82,6 +78,7 @@ pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n+pub const LIBC_STRLEN: [&str; 2] = [\"libc\", \"strlen\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n #[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];"}, {"sha": "3f5c5604d43f5e5b481cb370ad45739cf05e3942", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -14,8 +14,8 @@ use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n-use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n \n use crate::{match_def_path, must_use_attr};\n \n@@ -129,10 +129,11 @@ pub fn implements_trait<'tcx>(\n         return false;\n     }\n     let ty_params = cx.tcx.mk_substs(ty_params.iter());\n-    cx.tcx.infer_ctxt().enter(|infcx|\n-        infcx.type_implements_trait(trait_id, ty, ty_params, cx.param_env)\n-        .must_apply_modulo_regions()\n-    )\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx\n+            .type_implements_trait(trait_id, ty, ty_params, cx.param_env)\n+            .must_apply_modulo_regions()\n+    })\n }\n \n /// Checks whether this type implements `Drop`.\n@@ -235,6 +236,17 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     }\n }\n \n+/// Checks if the type is a reference equals to a diagnostic item\n+pub fn is_type_ref_to_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n+    match ty.kind() {\n+        ty::Ref(_, ref_ty, _) => match ref_ty.kind() {\n+            ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n+            _ => false,\n+        },\n+        _ => false,\n+    }\n+}\n+\n /// Checks if the type is equal to a diagnostic item\n ///\n /// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`"}, {"sha": "182d8cb11ea80df397453a5bd62cb995ca8636ad", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -199,3 +199,50 @@ pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n     recursive_visitor.visit_expr(expression);\n     recursive_visitor.seen_return_break_continue\n }\n+\n+pub struct UsedAfterExprVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    definition: HirId,\n+    past_expr: bool,\n+    used_after_expr: bool,\n+}\n+impl<'a, 'tcx> UsedAfterExprVisitor<'a, 'tcx> {\n+    pub fn is_found(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+        utils::path_to_local(expr).map_or(false, |definition| {\n+            let mut visitor = UsedAfterExprVisitor {\n+                cx,\n+                expr,\n+                definition,\n+                past_expr: false,\n+                used_after_expr: false,\n+            };\n+            utils::get_enclosing_block(cx, definition).map_or(false, |block| {\n+                visitor.visit_block(block);\n+                visitor.used_after_expr\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for UsedAfterExprVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if self.used_after_expr {\n+            return;\n+        }\n+\n+        if expr.hir_id == self.expr.hir_id {\n+            self.past_expr = true;\n+        } else if self.past_expr && utils::path_to_local_id(expr, self.definition) {\n+            self.used_after_expr = true;\n+        } else {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+}"}, {"sha": "6452189a4615b818d8935e30471f448ab080b976", "filename": "tests/ui-toml/nonstandard_macro_braces/auxiliary/proc_macro_derive.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fauxiliary%2Fproc_macro_derive.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --emit=link\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(DeriveSomething)]\n+pub fn derive(_: TokenStream) -> TokenStream {\n+    \"fn _f() -> Vec<u8> { vec![] }\".parse().unwrap()\n+}\n+\n+#[proc_macro]\n+pub fn foo_bar(_: TokenStream) -> TokenStream {\n+    \"fn issue_7422() { eprintln!(); }\".parse().unwrap()\n+}"}, {"sha": "e9f042ddefcde5711e361c3979854c555c2272f5", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,9 +1,17 @@\n-// #![warn(clippy::nonstandard_macro_braces)]\n+// aux-build:proc_macro_derive.rs\n \n+#![warn(clippy::nonstandard_macro_braces)]\n+\n+extern crate proc_macro_derive;\n extern crate quote;\n \n use quote::quote;\n \n+#[derive(proc_macro_derive::DeriveSomething)]\n+pub struct S;\n+\n+proc_macro_derive::foo_bar!();\n+\n #[rustfmt::skip]\n macro_rules! test {\n     () => {"}, {"sha": "86063a08280867dd59589b58ecf021ad35b608f4", "filename": "tests/ui-toml/nonstandard_macro_braces/conf_nonstandard_macro_braces.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fnonstandard_macro_braces%2Fconf_nonstandard_macro_braces.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,54 +1,54 @@\n error: use of irregular braces for `vec!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:29:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:37:13\n    |\n LL |     let _ = vec! {1, 2, 3};\n    |             ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::nonstandard-macro-braces` implied by `-D warnings`\n help: consider writing `vec![1, 2, 3]`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:29:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:37:13\n    |\n LL |     let _ = vec! {1, 2, 3};\n    |             ^^^^^^^^^^^^^^\n \n error: use of irregular braces for `format!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:30:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:38:13\n    |\n LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `format!(\"ugh () stop being such a good compiler\", \"hello\")`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:30:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:38:13\n    |\n LL |     let _ = format![\"ugh {} stop being such a good compiler\", \"hello\"];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `quote!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:31:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:39:13\n    |\n LL |     let _ = quote!(let x = 1;);\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `quote! {let x = 1;}`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:31:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:39:13\n    |\n LL |     let _ = quote!(let x = 1;);\n    |             ^^^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `quote::quote!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:32:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:40:13\n    |\n LL |     let _ = quote::quote!(match match match);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `quote::quote! {match match match}`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:32:13\n+  --> $DIR/conf_nonstandard_macro_braces.rs:40:13\n    |\n LL |     let _ = quote::quote!(match match match);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `vec!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:10:9\n+  --> $DIR/conf_nonstandard_macro_braces.rs:18:9\n    |\n LL |         vec!{0, 0, 0}\n    |         ^^^^^^^^^^^^^\n@@ -57,7 +57,7 @@ LL |     let _ = test!();\n    |             ------- in this macro invocation\n    |\n help: consider writing `vec![0, 0, 0]`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:10:9\n+  --> $DIR/conf_nonstandard_macro_braces.rs:18:9\n    |\n LL |         vec!{0, 0, 0}\n    |         ^^^^^^^^^^^^^\n@@ -67,25 +67,25 @@ LL |     let _ = test!();\n    = note: this error originates in the macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: use of irregular braces for `type_pos!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:41:12\n+  --> $DIR/conf_nonstandard_macro_braces.rs:49:12\n    |\n LL |     let _: type_pos!(usize) = vec![];\n    |            ^^^^^^^^^^^^^^^^\n    |\n help: consider writing `type_pos![usize]`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:41:12\n+  --> $DIR/conf_nonstandard_macro_braces.rs:49:12\n    |\n LL |     let _: type_pos!(usize) = vec![];\n    |            ^^^^^^^^^^^^^^^^\n \n error: use of irregular braces for `eprint!` macro\n-  --> $DIR/conf_nonstandard_macro_braces.rs:43:5\n+  --> $DIR/conf_nonstandard_macro_braces.rs:51:5\n    |\n LL |     eprint!(\"test if user config overrides defaults\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider writing `eprint![\"test if user config overrides defaults\"];`\n-  --> $DIR/conf_nonstandard_macro_braces.rs:43:5\n+  --> $DIR/conf_nonstandard_macro_braces.rs:51:5\n    |\n LL |     eprint!(\"test if user config overrides defaults\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "7f42df463411d53f8371c6b29cd431ba1580f4cd", "filename": "tests/ui/branches_sharing_code/false_positives.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Ffalse_positives.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,28 @@\n+#![allow(dead_code)]\n+#![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+\n+// ##################################\n+// # Issue clippy#7369\n+// ##################################\n+#[derive(Debug)]\n+pub struct FooBar {\n+    foo: Vec<u32>,\n+}\n+\n+impl FooBar {\n+    pub fn bar(&mut self) {\n+        if true {\n+            self.foo.pop();\n+        } else {\n+            self.baz();\n+\n+            self.foo.pop();\n+\n+            self.baz()\n+        }\n+    }\n+\n+    fn baz(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "31340b012dd0e01418be72e51cf1baecf2de6af5", "filename": "tests/ui/crashes/ice-7423.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fcrashes%2Fice-7423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fcrashes%2Fice-7423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7423.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,13 @@\n+pub trait Trait {\n+    fn f();\n+}\n+\n+impl Trait for usize {\n+    fn f() {\n+        extern \"C\" {\n+            fn g() -> usize;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1b0e7544e79c6289f17b6d48b9f1a0dc7c51e579", "filename": "tests/ui/default_numeric_fallback_f64.fixed", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,174 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+#![allow(clippy::match_single_binding)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12_f64;\n+        let x = [1.0_f64, 2.0_f64, 3.0_f64];\n+        let x = if true { (1.0_f64, 2.0_f64) } else { (3.0_f64, 4.0_f64) };\n+        let x = match 1.0_f64 {\n+            _ => 1.0_f64,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [f64; 3] = [1., 2., 3.];\n+        let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n+        let x: _ = 1.;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2.\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_f64() -> f64 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1.0_f64\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `f64` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1.0_f64 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> f64 { 1.0_f64 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(f: f64) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        generic_arg(1.0_f64);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1.0_f64);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: f64,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericStruct { x: 1.0_f64 };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1.0_f64 };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(f64),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1.);\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericEnum::X(1.0_f64);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, f: f64) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1.);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1.0_f64);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22.0_f64;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e9687777bbd0bed95d74767187deb9566e5e8167", "filename": "tests/ui/default_numeric_fallback_f64.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,174 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+#![allow(clippy::match_single_binding)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `f64`.\n+        let x = 0.12;\n+        let x = [1., 2., 3.];\n+        let x = if true { (1., 2.) } else { (3., 4.) };\n+        let x = match 1. {\n+            _ => 1.,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 0.12_f64;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: f64 = 0.1;\n+        let x: [f64; 3] = [1., 2., 3.];\n+        let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n+        let x: _ = 1.;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2.\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_f64() -> f64 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1.\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `f64` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1. };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> f64 { 1. };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(f: f64) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        generic_arg(1.);\n+\n+        // Should lint this because the argument type is inferred to `f64` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1.);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: f64,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericStruct { x: 1. };\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1. };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(f64),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1.);\n+\n+        // Should lint this because the field type is inferred to `f64` and NOT bound to a concrete type.\n+        GenericEnum::X(1.);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, f: f64) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1.);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1.);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22.;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "961c7cb57c523f2746985606bb43cd4f8a55eb64", "filename": "tests/ui/default_numeric_fallback_f64.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,147 @@\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:18:17\n+   |\n+LL |         let x = 0.12;\n+   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n+   |\n+   = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:18\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                  ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:22\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                      ^^ help: consider adding suffix: `2.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:19:26\n+   |\n+LL |         let x = [1., 2., 3.];\n+   |                          ^^ help: consider adding suffix: `3.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:28\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                            ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:32\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                ^^ help: consider adding suffix: `2.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:46\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                              ^^ help: consider adding suffix: `3.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:20:50\n+   |\n+LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n+   |                                                  ^^ help: consider adding suffix: `4.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:21:23\n+   |\n+LL |         let x = match 1. {\n+   |                       ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:22:18\n+   |\n+LL |             _ => 1.,\n+   |                  ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:40:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:48:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:54:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:66:9\n+   |\n+LL |         1.\n+   |         ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:72:27\n+   |\n+LL |         let f = || -> _ { 1. };\n+   |                           ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:76:29\n+   |\n+LL |         let f = || -> f64 { 1. };\n+   |                             ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:90:21\n+   |\n+LL |         generic_arg(1.);\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:93:32\n+   |\n+LL |         let x: _ = generic_arg(1.);\n+   |                                ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:111:28\n+   |\n+LL |         GenericStruct { x: 1. };\n+   |                            ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:114:36\n+   |\n+LL |         let _ = GenericStruct { x: 1. };\n+   |                                    ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:132:24\n+   |\n+LL |         GenericEnum::X(1.);\n+   |                        ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:152:23\n+   |\n+LL |         s.generic_arg(1.);\n+   |                       ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:159:21\n+   |\n+LL |             let x = 22.;\n+   |                     ^^^ help: consider adding suffix: `22.0_f64`\n+...\n+LL |         internal_macro!();\n+   |         ------------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 23 previous errors\n+"}, {"sha": "55c082fcb19fb7f1b563539721f9a89b111ba14b", "filename": "tests/ui/default_numeric_fallback_i32.fixed", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,173 @@\n+// run-rustfix\n+// aux-build:macro_rules.rs\n+\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n+\n+#[macro_use]\n+extern crate macro_rules;\n+\n+mod basic_expr {\n+    fn test() {\n+        // Should lint unsuffixed literals typed `i32`.\n+        let x = 22_i32;\n+        let x = [1_i32, 2_i32, 3_i32];\n+        let x = if true { (1_i32, 2_i32) } else { (3_i32, 4_i32) };\n+        let x = match 1_i32 {\n+            1_i32 => 1_i32,\n+            _ => 2_i32,\n+        };\n+\n+        // Should NOT lint suffixed literals.\n+        let x = 22_i32;\n+\n+        // Should NOT lint literals in init expr if `Local` has a type annotation.\n+        let x: [i32; 3] = [1, 2, 3];\n+        let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n+        let x: _ = 1;\n+    }\n+}\n+\n+mod nested_local {\n+    fn test() {\n+        let x: _ = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n+\n+        let x: _ = if true {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        } else {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            2\n+        };\n+    }\n+}\n+\n+mod function_def {\n+    fn ret_i32() -> i32 {\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        1_i32\n+    }\n+\n+    fn test() {\n+        // Should lint this because return type is inferred to `i32` and NOT bound to a concrete\n+        // type.\n+        let f = || -> _ { 1_i32 };\n+\n+        // Even though the output type is specified,\n+        // this unsuffixed literal is linted to reduce heuristics and keep codebase simple.\n+        let f = || -> i32 { 1_i32 };\n+    }\n+}\n+\n+mod function_calls {\n+    fn concrete_arg(x: i32) {}\n+\n+    fn generic_arg<T>(t: T) {}\n+\n+    fn test() {\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        concrete_arg(1);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        generic_arg(1_i32);\n+\n+        // Should lint this because the argument type is inferred to `i32` and NOT bound to a concrete type.\n+        let x: _ = generic_arg(1_i32);\n+    }\n+}\n+\n+mod struct_ctor {\n+    struct ConcreteStruct {\n+        x: i32,\n+    }\n+\n+    struct GenericStruct<T> {\n+        x: T,\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteStruct { x: 1 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericStruct { x: 1_i32 };\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        let _ = GenericStruct { x: 1_i32 };\n+    }\n+}\n+\n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(i32),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1);\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericEnum::X(1_i32);\n+    }\n+}\n+\n+mod method_calls {\n+    struct StructForMethodCallTest {}\n+\n+    impl StructForMethodCallTest {\n+        fn concrete_arg(&self, x: i32) {}\n+\n+        fn generic_arg<T>(&self, t: T) {}\n+    }\n+\n+    fn test() {\n+        let s = StructForMethodCallTest {};\n+\n+        // Should NOT lint this because the argument type is bound to a concrete type.\n+        s.concrete_arg(1);\n+\n+        // Should lint this because the argument type is bound to a concrete type.\n+        s.generic_arg(1_i32);\n+    }\n+}\n+\n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22_i32;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e0a4828ce9ff636aed3c8c510e6e094b9f370826", "filename": "tests/ui/default_numeric_fallback_i32.rs", "status": "renamed", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n@@ -21,15 +22,10 @@ mod basic_expr {\n             _ => 2,\n         };\n \n-        // Should lint unsuffixed literals typed `f64`.\n-        let x = 0.12;\n-\n         // Should NOT lint suffixed literals.\n         let x = 22_i32;\n-        let x = 0.12_f64;\n \n         // Should NOT lint literals in init expr if `Local` has a type annotation.\n-        let x: f64 = 0.1;\n         let x: [i32; 3] = [1, 2, 3];\n         let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n         let x: _ = 1;\n@@ -118,6 +114,24 @@ mod struct_ctor {\n     }\n }\n \n+mod enum_ctor {\n+    enum ConcreteEnum {\n+        X(i32),\n+    }\n+\n+    enum GenericEnum<T> {\n+        X(T),\n+    }\n+\n+    fn test() {\n+        // Should NOT lint this because the field type is bound to a concrete type.\n+        ConcreteEnum::X(1);\n+\n+        // Should lint this because the field type is inferred to `i32` and NOT bound to a concrete type.\n+        GenericEnum::X(1);\n+    }\n+}\n+\n mod method_calls {\n     struct StructForMethodCallTest {}\n ", "previous_filename": "tests/ui/default_numeric_fallback.rs"}, {"sha": "5edf48b202087d01335588de9b0a7823926030ea", "filename": "tests/ui/default_numeric_fallback_i32.stderr", "status": "renamed", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,151 +1,151 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:16:17\n+  --> $DIR/default_numeric_fallback_i32.rs:17:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:18\n+  --> $DIR/default_numeric_fallback_i32.rs:18:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:21\n+  --> $DIR/default_numeric_fallback_i32.rs:18:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:17:24\n+  --> $DIR/default_numeric_fallback_i32.rs:18:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:28\n+  --> $DIR/default_numeric_fallback_i32.rs:19:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:31\n+  --> $DIR/default_numeric_fallback_i32.rs:19:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:44\n+  --> $DIR/default_numeric_fallback_i32.rs:19:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:18:47\n+  --> $DIR/default_numeric_fallback_i32.rs:19:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:19:23\n+  --> $DIR/default_numeric_fallback_i32.rs:20:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:13\n+  --> $DIR/default_numeric_fallback_i32.rs:21:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:18\n+  --> $DIR/default_numeric_fallback_i32.rs:21:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:21:18\n+  --> $DIR/default_numeric_fallback_i32.rs:22:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:25:17\n-   |\n-LL |         let x = 0.12;\n-   |                 ^^^^ help: consider adding suffix: `0.12_f64`\n-\n-error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:43:21\n+  --> $DIR/default_numeric_fallback_i32.rs:39:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:51:21\n+  --> $DIR/default_numeric_fallback_i32.rs:47:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:57:21\n+  --> $DIR/default_numeric_fallback_i32.rs:53:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:69:9\n+  --> $DIR/default_numeric_fallback_i32.rs:65:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:75:27\n+  --> $DIR/default_numeric_fallback_i32.rs:71:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:79:29\n+  --> $DIR/default_numeric_fallback_i32.rs:75:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:93:21\n+  --> $DIR/default_numeric_fallback_i32.rs:89:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:96:32\n+  --> $DIR/default_numeric_fallback_i32.rs:92:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:114:28\n+  --> $DIR/default_numeric_fallback_i32.rs:110:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:117:36\n+  --> $DIR/default_numeric_fallback_i32.rs:113:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:137:23\n+  --> $DIR/default_numeric_fallback_i32.rs:131:24\n+   |\n+LL |         GenericEnum::X(1);\n+   |                        ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_i32.rs:151:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:144:21\n+  --> $DIR/default_numeric_fallback_i32.rs:158:21\n    |\n LL |             let x = 22;\n    |                     ^^ help: consider adding suffix: `22_i32`", "previous_filename": "tests/ui/default_numeric_fallback.stderr"}, {"sha": "8e8324b30f0fb02cac16001c22685a7205a48e56", "filename": "tests/ui/doc/unbalanced_ticks.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc%2Funbalanced_ticks.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -34,3 +34,10 @@ fn in_code_block() {}\n /// - This `item has unbalanced tick marks\n /// - This item needs backticks_here\n fn other_markdown() {}\n+\n+#[rustfmt::skip]\n+/// - ```rust\n+///   /// `lol`\n+///   pub struct Struct;\n+///   ```\n+fn iss_7421() {}"}, {"sha": "91b837f9a85884d19cc74471d262c1016987cf79", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -220,3 +220,19 @@ impl std::ops::Deref for Bar {\n fn test_deref_with_trait_method() {\n     let _ = [Bar].iter().map(|s| s.to_string()).collect::<Vec<_>>();\n }\n+\n+fn mutable_closure_used_again(x: Vec<i32>, y: Vec<i32>, z: Vec<i32>) {\n+    let mut res = Vec::new();\n+    let mut add_to_res = |n| res.push(n);\n+    x.into_iter().for_each(&mut add_to_res);\n+    y.into_iter().for_each(&mut add_to_res);\n+    z.into_iter().for_each(add_to_res);\n+}\n+\n+fn mutable_closure_in_loop() {\n+    let mut value = 0;\n+    let mut closure = |n| value += n;\n+    for _ in 0..5 {\n+        Some(1).map(&mut closure);\n+    }\n+}"}, {"sha": "1b53700289db303678d57850d0b59eb7a17b998d", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -220,3 +220,19 @@ impl std::ops::Deref for Bar {\n fn test_deref_with_trait_method() {\n     let _ = [Bar].iter().map(|s| s.to_string()).collect::<Vec<_>>();\n }\n+\n+fn mutable_closure_used_again(x: Vec<i32>, y: Vec<i32>, z: Vec<i32>) {\n+    let mut res = Vec::new();\n+    let mut add_to_res = |n| res.push(n);\n+    x.into_iter().for_each(|x| add_to_res(x));\n+    y.into_iter().for_each(|x| add_to_res(x));\n+    z.into_iter().for_each(|x| add_to_res(x));\n+}\n+\n+fn mutable_closure_in_loop() {\n+    let mut value = 0;\n+    let mut closure = |n| value += n;\n+    for _ in 0..5 {\n+        Some(1).map(|n| closure(n));\n+    }\n+}"}, {"sha": "28da8941346192d0a6e6c61c478a1cc57bb5415d", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -82,5 +82,29 @@ error: redundant closure\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n-error: aborting due to 13 previous errors\n+error: redundant closure\n+  --> $DIR/eta.rs:227:28\n+   |\n+LL |     x.into_iter().for_each(|x| add_to_res(x));\n+   |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:228:28\n+   |\n+LL |     y.into_iter().for_each(|x| add_to_res(x));\n+   |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:229:28\n+   |\n+LL |     z.into_iter().for_each(|x| add_to_res(x));\n+   |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:236:21\n+   |\n+LL |         Some(1).map(|n| closure(n));\n+   |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "b94ec6403ddcea3c63bfd188bbd6914679581c70", "filename": "tests/ui/explicit_write_non_rustfix.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fexplicit_write_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_write_non_rustfix.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,10 +1,11 @@\n-error: use of `writeln!(stderr(), ...).unwrap()`. Consider using `eprintln!` instead\n+error: use of `writeln!(stderr(), ...).unwrap()`\n   --> $DIR/explicit_write_non_rustfix.rs:7:5\n    |\n LL |     writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::explicit-write` implied by `-D warnings`\n+   = help: consider using `eprintln!` instead\n \n error: aborting due to previous error\n "}, {"sha": "5dd64140e81165880f3d6285c60825838d96a0e2", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -69,4 +69,6 @@ fn main() {\n     // Wrap it with braces\n     let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n     let _s: String = (&*v.join(\"\\n\")).to_string();\n+\n+    format!(\"prepend {:+}\", \"s\");\n }"}, {"sha": "4599fb5207ea85c280f07b863d39f798f6262eaa", "filename": "tests/ui/format.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -71,4 +71,6 @@ fn main() {\n     // Wrap it with braces\n     let v: Vec<String> = vec![\"foo\".to_string(), \"bar\".to_string()];\n     let _s: String = format!(\"{}\", &*v.join(\"\\n\"));\n+\n+    format!(\"prepend {:+}\", \"s\");\n }"}, {"sha": "7338064646244ca7611a01d73c61203a15a0631f", "filename": "tests/ui/panicking_macros.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fpanicking_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fpanicking_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanicking_macros.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -43,6 +43,18 @@ fn core_versions() {\n     unreachable!();\n }\n \n+fn assert() {\n+    assert!(true);\n+    assert_eq!(true, true);\n+    assert_ne!(true, false);\n+}\n+\n+fn assert_msg() {\n+    assert!(true, \"this should not panic\");\n+    assert_eq!(true, true, \"this should not panic\");\n+    assert_ne!(true, false, \"this should not panic\");\n+}\n+\n fn debug_assert() {\n     debug_assert!(true);\n     debug_assert_eq!(true, true);\n@@ -61,4 +73,8 @@ fn main() {\n     unimplemented();\n     unreachable();\n     core_versions();\n+    assert();\n+    assert_msg();\n+    debug_assert();\n+    debug_assert_msg();\n }"}, {"sha": "657a3ecf6a006146575f6fe4d8b71c6a979a12f9", "filename": "tests/ui/rc_mutex.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_mutex.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,34 @@\n+#![warn(clippy::rc_mutex)]\n+#![allow(clippy::blacklisted_name)]\n+\n+use std::rc::Rc;\n+use std::sync::Mutex;\n+\n+pub struct MyStruct {\n+    foo: Rc<Mutex<i32>>,\n+}\n+\n+pub struct SubT<T> {\n+    foo: T,\n+}\n+\n+pub enum MyEnum {\n+    One,\n+    Two,\n+}\n+\n+pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n+\n+pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+\n+pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+\n+fn main() {\n+    test1(Rc::new(Mutex::new(1)));\n+    test2(Rc::new(Mutex::new(MyEnum::One)));\n+    test3(Rc::new(Mutex::new(SubT { foo: 1 })));\n+\n+    let _my_struct = MyStruct {\n+        foo: Rc::new(Mutex::new(1)),\n+    };\n+}"}, {"sha": "8e58e2bc2d0bf1b5a66658cc4471dd1ea3ac8650", "filename": "tests/ui/rc_mutex.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Frc_mutex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Frc_mutex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frc_mutex.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,28 @@\n+error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+  --> $DIR/rc_mutex.rs:8:10\n+   |\n+LL |     foo: Rc<Mutex<i32>>,\n+   |          ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::rc-mutex` implied by `-D warnings`\n+\n+error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+  --> $DIR/rc_mutex.rs:20:22\n+   |\n+LL | pub fn test1<T>(foo: Rc<Mutex<T>>) {}\n+   |                      ^^^^^^^^^^^^\n+\n+error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+  --> $DIR/rc_mutex.rs:22:19\n+   |\n+LL | pub fn test2(foo: Rc<Mutex<MyEnum>>) {}\n+   |                   ^^^^^^^^^^^^^^^^^\n+\n+error: found `Rc<Mutex<_>>`. Consider using `Rc<RefCell<_>>` or `Arc<Mutex<_>>` instead\n+  --> $DIR/rc_mutex.rs:24:19\n+   |\n+LL | pub fn test3(foo: Rc<Mutex<SubT<usize>>>) {}\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6514fd6d1ac76bbe7ebbbd37453af5002e3c3308", "filename": "tests/ui/redundant_allocation.fixed", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fd8dbc8af543a021b87a01e1a34242dec54cb80/tests%2Fui%2Fredundant_allocation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2fd8dbc8af543a021b87a01e1a34242dec54cb80/tests%2Fui%2Fredundant_allocation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.fixed?ref=2fd8dbc8af543a021b87a01e1a34242dec54cb80", "patch": "@@ -1,48 +0,0 @@\n-// run-rustfix\n-#![warn(clippy::all)]\n-#![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n-#![allow(clippy::blacklisted_name, unused_variables, dead_code)]\n-\n-use std::boxed::Box;\n-use std::rc::Rc;\n-\n-pub struct MyStruct {}\n-\n-pub struct SubT<T> {\n-    foo: T,\n-}\n-\n-pub enum MyEnum {\n-    One,\n-    Two,\n-}\n-\n-// Rc<&T>\n-\n-pub fn test1<T>(foo: &T) {}\n-\n-pub fn test2(foo: &MyStruct) {}\n-\n-pub fn test3(foo: &MyEnum) {}\n-\n-pub fn test4_neg(foo: Rc<SubT<&usize>>) {}\n-\n-// Rc<Rc<T>>\n-\n-pub fn test5(a: Rc<bool>) {}\n-\n-// Rc<Box<T>>\n-\n-pub fn test6(a: Rc<bool>) {}\n-\n-// Box<&T>\n-\n-pub fn test7<T>(foo: &T) {}\n-\n-pub fn test8(foo: &MyStruct) {}\n-\n-pub fn test9(foo: &MyEnum) {}\n-\n-pub fn test10_neg(foo: Box<SubT<&usize>>) {}\n-\n-fn main() {}"}, {"sha": "1b4f2a66c705ec088d5396bc3dbed187e12579df", "filename": "tests/ui/redundant_allocation.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,10 +1,7 @@\n-// run-rustfix\n #![warn(clippy::all)]\n #![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n #![allow(clippy::blacklisted_name, unused_variables, dead_code)]\n-\n-use std::boxed::Box;\n-use std::rc::Rc;\n+#![allow(unused_imports)]\n \n pub struct MyStruct {}\n \n@@ -17,32 +14,67 @@ pub enum MyEnum {\n     Two,\n }\n \n-// Rc<&T>\n+mod outer_box {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n \n-pub fn test1<T>(foo: Rc<&T>) {}\n+    pub fn box_test6<T>(foo: Box<Rc<T>>) {}\n \n-pub fn test2(foo: Rc<&MyStruct>) {}\n+    pub fn box_test7<T>(foo: Box<Arc<T>>) {}\n \n-pub fn test3(foo: Rc<&MyEnum>) {}\n+    pub fn box_test8() -> Box<Rc<SubT<usize>>> {\n+        unimplemented!();\n+    }\n \n-pub fn test4_neg(foo: Rc<SubT<&usize>>) {}\n+    pub fn box_test9<T>(foo: Box<Arc<T>>) -> Box<Arc<SubT<T>>> {\n+        unimplemented!();\n+    }\n+}\n \n-// Rc<Rc<T>>\n+mod outer_rc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n \n-pub fn test5(a: Rc<Rc<bool>>) {}\n+    pub fn rc_test5(a: Rc<Box<bool>>) {}\n \n-// Rc<Box<T>>\n+    pub fn rc_test7(a: Rc<Arc<bool>>) {}\n \n-pub fn test6(a: Rc<Box<bool>>) {}\n+    pub fn rc_test8() -> Rc<Box<SubT<usize>>> {\n+        unimplemented!();\n+    }\n \n-// Box<&T>\n+    pub fn rc_test9<T>(foo: Rc<Arc<T>>) -> Rc<Arc<SubT<T>>> {\n+        unimplemented!();\n+    }\n+}\n \n-pub fn test7<T>(foo: Box<&T>) {}\n+mod outer_arc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n \n-pub fn test8(foo: Box<&MyStruct>) {}\n+    pub fn arc_test5(a: Arc<Box<bool>>) {}\n \n-pub fn test9(foo: Box<&MyEnum>) {}\n+    pub fn arc_test6(a: Arc<Rc<bool>>) {}\n \n-pub fn test10_neg(foo: Box<SubT<&usize>>) {}\n+    pub fn arc_test8() -> Arc<Box<SubT<usize>>> {\n+        unimplemented!();\n+    }\n+\n+    pub fn arc_test9<T>(foo: Arc<Rc<T>>) -> Arc<Rc<SubT<T>>> {\n+        unimplemented!();\n+    }\n+}\n \n fn main() {}"}, {"sha": "fdab74eb538e3e7c88cc341707db01439c91395b", "filename": "tests/ui/redundant_allocation.stderr", "status": "modified", "additions": 119, "deletions": 33, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,52 +1,138 @@\n-error: usage of `Rc<&T>`\n-  --> $DIR/redundant_allocation.rs:22:22\n+error: usage of `Box<Rc<T>>`\n+  --> $DIR/redundant_allocation.rs:25:30\n    |\n-LL | pub fn test1<T>(foo: Rc<&T>) {}\n-   |                      ^^^^^^ help: try: `&T`\n+LL |     pub fn box_test6<T>(foo: Box<Rc<T>>) {}\n+   |                              ^^^^^^^^^^\n    |\n    = note: `-D clippy::redundant-allocation` implied by `-D warnings`\n+   = note: `Rc<T>` is already on the heap, `Box<Rc<T>>` makes an extra allocation\n+   = help: consider using just `Box<T>` or `Rc<T>`\n \n-error: usage of `Rc<&T>`\n-  --> $DIR/redundant_allocation.rs:24:19\n+error: usage of `Box<Arc<T>>`\n+  --> $DIR/redundant_allocation.rs:27:30\n    |\n-LL | pub fn test2(foo: Rc<&MyStruct>) {}\n-   |                   ^^^^^^^^^^^^^ help: try: `&MyStruct`\n+LL |     pub fn box_test7<T>(foo: Box<Arc<T>>) {}\n+   |                              ^^^^^^^^^^^\n+   |\n+   = note: `Arc<T>` is already on the heap, `Box<Arc<T>>` makes an extra allocation\n+   = help: consider using just `Box<T>` or `Arc<T>`\n+\n+error: usage of `Box<Rc<SubT<usize>>>`\n+  --> $DIR/redundant_allocation.rs:29:27\n+   |\n+LL |     pub fn box_test8() -> Box<Rc<SubT<usize>>> {\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Rc<SubT<usize>>` is already on the heap, `Box<Rc<SubT<usize>>>` makes an extra allocation\n+   = help: consider using just `Box<SubT<usize>>` or `Rc<SubT<usize>>`\n+\n+error: usage of `Box<Arc<T>>`\n+  --> $DIR/redundant_allocation.rs:33:30\n+   |\n+LL |     pub fn box_test9<T>(foo: Box<Arc<T>>) -> Box<Arc<SubT<T>>> {\n+   |                              ^^^^^^^^^^^\n+   |\n+   = note: `Arc<T>` is already on the heap, `Box<Arc<T>>` makes an extra allocation\n+   = help: consider using just `Box<T>` or `Arc<T>`\n+\n+error: usage of `Box<Arc<SubT<T>>>`\n+  --> $DIR/redundant_allocation.rs:33:46\n+   |\n+LL |     pub fn box_test9<T>(foo: Box<Arc<T>>) -> Box<Arc<SubT<T>>> {\n+   |                                              ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Arc<SubT<T>>` is already on the heap, `Box<Arc<SubT<T>>>` makes an extra allocation\n+   = help: consider using just `Box<SubT<T>>` or `Arc<SubT<T>>`\n+\n+error: usage of `Rc<Box<bool>>`\n+  --> $DIR/redundant_allocation.rs:46:24\n+   |\n+LL |     pub fn rc_test5(a: Rc<Box<bool>>) {}\n+   |                        ^^^^^^^^^^^^^\n+   |\n+   = note: `Box<bool>` is already on the heap, `Rc<Box<bool>>` makes an extra allocation\n+   = help: consider using just `Rc<bool>` or `Box<bool>`\n+\n+error: usage of `Rc<Arc<bool>>`\n+  --> $DIR/redundant_allocation.rs:48:24\n+   |\n+LL |     pub fn rc_test7(a: Rc<Arc<bool>>) {}\n+   |                        ^^^^^^^^^^^^^\n+   |\n+   = note: `Arc<bool>` is already on the heap, `Rc<Arc<bool>>` makes an extra allocation\n+   = help: consider using just `Rc<bool>` or `Arc<bool>`\n+\n+error: usage of `Rc<Box<SubT<usize>>>`\n+  --> $DIR/redundant_allocation.rs:50:26\n+   |\n+LL |     pub fn rc_test8() -> Rc<Box<SubT<usize>>> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Box<SubT<usize>>` is already on the heap, `Rc<Box<SubT<usize>>>` makes an extra allocation\n+   = help: consider using just `Rc<SubT<usize>>` or `Box<SubT<usize>>`\n+\n+error: usage of `Rc<Arc<T>>`\n+  --> $DIR/redundant_allocation.rs:54:29\n+   |\n+LL |     pub fn rc_test9<T>(foo: Rc<Arc<T>>) -> Rc<Arc<SubT<T>>> {\n+   |                             ^^^^^^^^^^\n+   |\n+   = note: `Arc<T>` is already on the heap, `Rc<Arc<T>>` makes an extra allocation\n+   = help: consider using just `Rc<T>` or `Arc<T>`\n \n-error: usage of `Rc<&T>`\n-  --> $DIR/redundant_allocation.rs:26:19\n+error: usage of `Rc<Arc<SubT<T>>>`\n+  --> $DIR/redundant_allocation.rs:54:44\n+   |\n+LL |     pub fn rc_test9<T>(foo: Rc<Arc<T>>) -> Rc<Arc<SubT<T>>> {\n+   |                                            ^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test3(foo: Rc<&MyEnum>) {}\n-   |                   ^^^^^^^^^^^ help: try: `&MyEnum`\n+   = note: `Arc<SubT<T>>` is already on the heap, `Rc<Arc<SubT<T>>>` makes an extra allocation\n+   = help: consider using just `Rc<SubT<T>>` or `Arc<SubT<T>>`\n \n-error: usage of `Rc<Rc<T>>`\n-  --> $DIR/redundant_allocation.rs:32:17\n+error: usage of `Arc<Box<bool>>`\n+  --> $DIR/redundant_allocation.rs:67:25\n    |\n-LL | pub fn test5(a: Rc<Rc<bool>>) {}\n-   |                 ^^^^^^^^^^^^ help: try: `Rc<bool>`\n+LL |     pub fn arc_test5(a: Arc<Box<bool>>) {}\n+   |                         ^^^^^^^^^^^^^^\n+   |\n+   = note: `Box<bool>` is already on the heap, `Arc<Box<bool>>` makes an extra allocation\n+   = help: consider using just `Arc<bool>` or `Box<bool>`\n \n-error: usage of `Rc<Box<T>>`\n-  --> $DIR/redundant_allocation.rs:36:17\n+error: usage of `Arc<Rc<bool>>`\n+  --> $DIR/redundant_allocation.rs:69:25\n+   |\n+LL |     pub fn arc_test6(a: Arc<Rc<bool>>) {}\n+   |                         ^^^^^^^^^^^^^\n    |\n-LL | pub fn test6(a: Rc<Box<bool>>) {}\n-   |                 ^^^^^^^^^^^^^ help: try: `Rc<bool>`\n+   = note: `Rc<bool>` is already on the heap, `Arc<Rc<bool>>` makes an extra allocation\n+   = help: consider using just `Arc<bool>` or `Rc<bool>`\n \n-error: usage of `Box<&T>`\n-  --> $DIR/redundant_allocation.rs:40:22\n+error: usage of `Arc<Box<SubT<usize>>>`\n+  --> $DIR/redundant_allocation.rs:71:27\n    |\n-LL | pub fn test7<T>(foo: Box<&T>) {}\n-   |                      ^^^^^^^ help: try: `&T`\n+LL |     pub fn arc_test8() -> Arc<Box<SubT<usize>>> {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Box<SubT<usize>>` is already on the heap, `Arc<Box<SubT<usize>>>` makes an extra allocation\n+   = help: consider using just `Arc<SubT<usize>>` or `Box<SubT<usize>>`\n \n-error: usage of `Box<&T>`\n-  --> $DIR/redundant_allocation.rs:42:19\n+error: usage of `Arc<Rc<T>>`\n+  --> $DIR/redundant_allocation.rs:75:30\n+   |\n+LL |     pub fn arc_test9<T>(foo: Arc<Rc<T>>) -> Arc<Rc<SubT<T>>> {\n+   |                              ^^^^^^^^^^\n    |\n-LL | pub fn test8(foo: Box<&MyStruct>) {}\n-   |                   ^^^^^^^^^^^^^^ help: try: `&MyStruct`\n+   = note: `Rc<T>` is already on the heap, `Arc<Rc<T>>` makes an extra allocation\n+   = help: consider using just `Arc<T>` or `Rc<T>`\n \n-error: usage of `Box<&T>`\n-  --> $DIR/redundant_allocation.rs:44:19\n+error: usage of `Arc<Rc<SubT<T>>>`\n+  --> $DIR/redundant_allocation.rs:75:45\n+   |\n+LL |     pub fn arc_test9<T>(foo: Arc<Rc<T>>) -> Arc<Rc<SubT<T>>> {\n+   |                                             ^^^^^^^^^^^^^^^^\n    |\n-LL | pub fn test9(foo: Box<&MyEnum>) {}\n-   |                   ^^^^^^^^^^^^ help: try: `&MyEnum`\n+   = note: `Rc<SubT<T>>` is already on the heap, `Arc<Rc<SubT<T>>>` makes an extra allocation\n+   = help: consider using just `Arc<SubT<T>>` or `Rc<SubT<T>>`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "ef089b25f47fdae22b8d18c322320fd1cd6f7200", "filename": "tests/ui/redundant_allocation_fixable.fixed", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation_fixable.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,75 @@\n+// run-rustfix\n+#![warn(clippy::all)]\n+#![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n+#![allow(clippy::blacklisted_name, unused_variables, dead_code)]\n+#![allow(unused_imports)]\n+\n+pub struct MyStruct {}\n+\n+pub struct SubT<T> {\n+    foo: T,\n+}\n+\n+pub enum MyEnum {\n+    One,\n+    Two,\n+}\n+\n+mod outer_box {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn box_test1<T>(foo: &T) {}\n+\n+    pub fn box_test2(foo: &MyStruct) {}\n+\n+    pub fn box_test3(foo: &MyEnum) {}\n+\n+    pub fn box_test4_neg(foo: Box<SubT<&usize>>) {}\n+\n+    pub fn box_test5<T>(foo: Box<T>) {}\n+}\n+\n+mod outer_rc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn rc_test1<T>(foo: &T) {}\n+\n+    pub fn rc_test2(foo: &MyStruct) {}\n+\n+    pub fn rc_test3(foo: &MyEnum) {}\n+\n+    pub fn rc_test4_neg(foo: Rc<SubT<&usize>>) {}\n+\n+    pub fn rc_test6(a: Rc<bool>) {}\n+}\n+\n+mod outer_arc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn arc_test1<T>(foo: &T) {}\n+\n+    pub fn arc_test2(foo: &MyStruct) {}\n+\n+    pub fn arc_test3(foo: &MyEnum) {}\n+\n+    pub fn arc_test4_neg(foo: Arc<SubT<&usize>>) {}\n+\n+    pub fn arc_test7(a: Arc<bool>) {}\n+}\n+\n+fn main() {}"}, {"sha": "fefa87721d720b9deeb77fe4d27657abb5783b88", "filename": "tests/ui/redundant_allocation_fixable.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation_fixable.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,75 @@\n+// run-rustfix\n+#![warn(clippy::all)]\n+#![allow(clippy::boxed_local, clippy::needless_pass_by_value)]\n+#![allow(clippy::blacklisted_name, unused_variables, dead_code)]\n+#![allow(unused_imports)]\n+\n+pub struct MyStruct {}\n+\n+pub struct SubT<T> {\n+    foo: T,\n+}\n+\n+pub enum MyEnum {\n+    One,\n+    Two,\n+}\n+\n+mod outer_box {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn box_test1<T>(foo: Box<&T>) {}\n+\n+    pub fn box_test2(foo: Box<&MyStruct>) {}\n+\n+    pub fn box_test3(foo: Box<&MyEnum>) {}\n+\n+    pub fn box_test4_neg(foo: Box<SubT<&usize>>) {}\n+\n+    pub fn box_test5<T>(foo: Box<Box<T>>) {}\n+}\n+\n+mod outer_rc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn rc_test1<T>(foo: Rc<&T>) {}\n+\n+    pub fn rc_test2(foo: Rc<&MyStruct>) {}\n+\n+    pub fn rc_test3(foo: Rc<&MyEnum>) {}\n+\n+    pub fn rc_test4_neg(foo: Rc<SubT<&usize>>) {}\n+\n+    pub fn rc_test6(a: Rc<Rc<bool>>) {}\n+}\n+\n+mod outer_arc {\n+    use crate::MyEnum;\n+    use crate::MyStruct;\n+    use crate::SubT;\n+    use std::boxed::Box;\n+    use std::rc::Rc;\n+    use std::sync::Arc;\n+\n+    pub fn arc_test1<T>(foo: Arc<&T>) {}\n+\n+    pub fn arc_test2(foo: Arc<&MyStruct>) {}\n+\n+    pub fn arc_test3(foo: Arc<&MyEnum>) {}\n+\n+    pub fn arc_test4_neg(foo: Arc<SubT<&usize>>) {}\n+\n+    pub fn arc_test7(a: Arc<Arc<bool>>) {}\n+}\n+\n+fn main() {}"}, {"sha": "fdd76ef17a55e884de278a3902ee9d03b5a6da46", "filename": "tests/ui/redundant_allocation_fixable.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_allocation_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_allocation_fixable.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,99 @@\n+error: usage of `Box<&T>`\n+  --> $DIR/redundant_allocation_fixable.rs:26:30\n+   |\n+LL |     pub fn box_test1<T>(foo: Box<&T>) {}\n+   |                              ^^^^^^^ help: try: `&T`\n+   |\n+   = note: `-D clippy::redundant-allocation` implied by `-D warnings`\n+   = note: `&T` is already a pointer, `Box<&T>` allocates a pointer on the heap\n+\n+error: usage of `Box<&MyStruct>`\n+  --> $DIR/redundant_allocation_fixable.rs:28:27\n+   |\n+LL |     pub fn box_test2(foo: Box<&MyStruct>) {}\n+   |                           ^^^^^^^^^^^^^^ help: try: `&MyStruct`\n+   |\n+   = note: `&MyStruct` is already a pointer, `Box<&MyStruct>` allocates a pointer on the heap\n+\n+error: usage of `Box<&MyEnum>`\n+  --> $DIR/redundant_allocation_fixable.rs:30:27\n+   |\n+LL |     pub fn box_test3(foo: Box<&MyEnum>) {}\n+   |                           ^^^^^^^^^^^^ help: try: `&MyEnum`\n+   |\n+   = note: `&MyEnum` is already a pointer, `Box<&MyEnum>` allocates a pointer on the heap\n+\n+error: usage of `Box<Box<T>>`\n+  --> $DIR/redundant_allocation_fixable.rs:34:30\n+   |\n+LL |     pub fn box_test5<T>(foo: Box<Box<T>>) {}\n+   |                              ^^^^^^^^^^^ help: try: `Box<T>`\n+   |\n+   = note: `Box<T>` is already on the heap, `Box<Box<T>>` makes an extra allocation\n+\n+error: usage of `Rc<&T>`\n+  --> $DIR/redundant_allocation_fixable.rs:45:29\n+   |\n+LL |     pub fn rc_test1<T>(foo: Rc<&T>) {}\n+   |                             ^^^^^^ help: try: `&T`\n+   |\n+   = note: `&T` is already a pointer, `Rc<&T>` allocates a pointer on the heap\n+\n+error: usage of `Rc<&MyStruct>`\n+  --> $DIR/redundant_allocation_fixable.rs:47:26\n+   |\n+LL |     pub fn rc_test2(foo: Rc<&MyStruct>) {}\n+   |                          ^^^^^^^^^^^^^ help: try: `&MyStruct`\n+   |\n+   = note: `&MyStruct` is already a pointer, `Rc<&MyStruct>` allocates a pointer on the heap\n+\n+error: usage of `Rc<&MyEnum>`\n+  --> $DIR/redundant_allocation_fixable.rs:49:26\n+   |\n+LL |     pub fn rc_test3(foo: Rc<&MyEnum>) {}\n+   |                          ^^^^^^^^^^^ help: try: `&MyEnum`\n+   |\n+   = note: `&MyEnum` is already a pointer, `Rc<&MyEnum>` allocates a pointer on the heap\n+\n+error: usage of `Rc<Rc<bool>>`\n+  --> $DIR/redundant_allocation_fixable.rs:53:24\n+   |\n+LL |     pub fn rc_test6(a: Rc<Rc<bool>>) {}\n+   |                        ^^^^^^^^^^^^ help: try: `Rc<bool>`\n+   |\n+   = note: `Rc<bool>` is already on the heap, `Rc<Rc<bool>>` makes an extra allocation\n+\n+error: usage of `Arc<&T>`\n+  --> $DIR/redundant_allocation_fixable.rs:64:30\n+   |\n+LL |     pub fn arc_test1<T>(foo: Arc<&T>) {}\n+   |                              ^^^^^^^ help: try: `&T`\n+   |\n+   = note: `&T` is already a pointer, `Arc<&T>` allocates a pointer on the heap\n+\n+error: usage of `Arc<&MyStruct>`\n+  --> $DIR/redundant_allocation_fixable.rs:66:27\n+   |\n+LL |     pub fn arc_test2(foo: Arc<&MyStruct>) {}\n+   |                           ^^^^^^^^^^^^^^ help: try: `&MyStruct`\n+   |\n+   = note: `&MyStruct` is already a pointer, `Arc<&MyStruct>` allocates a pointer on the heap\n+\n+error: usage of `Arc<&MyEnum>`\n+  --> $DIR/redundant_allocation_fixable.rs:68:27\n+   |\n+LL |     pub fn arc_test3(foo: Arc<&MyEnum>) {}\n+   |                           ^^^^^^^^^^^^ help: try: `&MyEnum`\n+   |\n+   = note: `&MyEnum` is already a pointer, `Arc<&MyEnum>` allocates a pointer on the heap\n+\n+error: usage of `Arc<Arc<bool>>`\n+  --> $DIR/redundant_allocation_fixable.rs:72:25\n+   |\n+LL |     pub fn arc_test7(a: Arc<Arc<bool>>) {}\n+   |                         ^^^^^^^^^^^^^^ help: try: `Arc<bool>`\n+   |\n+   = note: `Arc<bool>` is already on the heap, `Arc<Arc<bool>>` makes an extra allocation\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "2d711082746e73aab40867f0bcc2285137e5aca2", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -55,6 +55,8 @@ fn main() {\n     issue_5405();\n     manually_drop();\n     clone_then_move_cloned();\n+    hashmap_neg();\n+    false_negative_5707();\n }\n \n #[derive(Clone)]\n@@ -206,3 +208,29 @@ fn clone_then_move_cloned() {\n     let mut x = S(String::new());\n     x.0.clone().chars().for_each(|_| x.m());\n }\n+\n+fn hashmap_neg() {\n+    // issue 5707\n+    use std::collections::HashMap;\n+    use std::path::PathBuf;\n+\n+    let p = PathBuf::from(\"/\");\n+\n+    let mut h: HashMap<&str, &str> = HashMap::new();\n+    h.insert(\"orig-p\", p.to_str().unwrap());\n+\n+    let mut q = p.clone();\n+    q.push(\"foo\");\n+\n+    println!(\"{:?} {}\", h, q.display());\n+}\n+\n+fn false_negative_5707() {\n+    fn foo(_x: &Alpha, _y: &mut Alpha) {}\n+\n+    let x = Alpha;\n+    let mut y = Alpha;\n+    foo(&x, &mut y);\n+    let _z = x.clone(); // pr 7346 can't lint on `x`\n+    drop(y);\n+}"}, {"sha": "bd3d7365229fb83ccd13ca555e53d9941f867c43", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -55,6 +55,8 @@ fn main() {\n     issue_5405();\n     manually_drop();\n     clone_then_move_cloned();\n+    hashmap_neg();\n+    false_negative_5707();\n }\n \n #[derive(Clone)]\n@@ -206,3 +208,29 @@ fn clone_then_move_cloned() {\n     let mut x = S(String::new());\n     x.0.clone().chars().for_each(|_| x.m());\n }\n+\n+fn hashmap_neg() {\n+    // issue 5707\n+    use std::collections::HashMap;\n+    use std::path::PathBuf;\n+\n+    let p = PathBuf::from(\"/\");\n+\n+    let mut h: HashMap<&str, &str> = HashMap::new();\n+    h.insert(\"orig-p\", p.to_str().unwrap());\n+\n+    let mut q = p.clone();\n+    q.push(\"foo\");\n+\n+    println!(\"{:?} {}\", h, q.display());\n+}\n+\n+fn false_negative_5707() {\n+    fn foo(_x: &Alpha, _y: &mut Alpha) {}\n+\n+    let x = Alpha;\n+    let mut y = Alpha;\n+    foo(&x, &mut y);\n+    let _z = x.clone(); // pr 7346 can't lint on `x`\n+    drop(y);\n+}"}, {"sha": "fbc90493ae94b85986e8381ef82e395fbc202e9e", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -108,61 +108,61 @@ LL |     let _t = tup.0.clone();\n    |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:63:25\n+  --> $DIR/redundant_clone.rs:65:25\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                         ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:63:24\n+  --> $DIR/redundant_clone.rs:65:24\n    |\n LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n    |                        ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:120:15\n+  --> $DIR/redundant_clone.rs:122:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:120:14\n+  --> $DIR/redundant_clone.rs:122:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:121:15\n+  --> $DIR/redundant_clone.rs:123:15\n    |\n LL |     let _t = t.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:121:14\n+  --> $DIR/redundant_clone.rs:123:14\n    |\n LL |     let _t = t.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:131:19\n+  --> $DIR/redundant_clone.rs:133:19\n    |\n LL |         let _f = f.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:131:18\n+  --> $DIR/redundant_clone.rs:133:18\n    |\n LL |         let _f = f.clone();\n    |                  ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:143:14\n+  --> $DIR/redundant_clone.rs:145:14\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |              ^^^^^^^^ help: remove this\n    |\n note: cloned value is neither consumed nor mutated\n-  --> $DIR/redundant_clone.rs:143:13\n+  --> $DIR/redundant_clone.rs:145:13\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |             ^^^^^^^^^"}, {"sha": "21902fa8483f3e9913fedd1572daa511fee13477", "filename": "tests/ui/strlen_on_c_strings.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,16 @@\n+#![warn(clippy::strlen_on_c_strings)]\n+#![allow(dead_code)]\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+use std::ffi::{CStr, CString};\n+\n+fn main() {\n+    // CString\n+    let cstring = CString::new(\"foo\").expect(\"CString::new failed\");\n+    let len = unsafe { libc::strlen(cstring.as_ptr()) };\n+\n+    // CStr\n+    let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    let len = unsafe { libc::strlen(cstr.as_ptr()) };\n+}"}, {"sha": "a212bd327c35dc71ee16e6e948ff3e2af26769d9", "filename": "tests/ui/strlen_on_c_strings.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fstrlen_on_c_strings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Fstrlen_on_c_strings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstrlen_on_c_strings.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -0,0 +1,25 @@\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:11:24\n+   |\n+LL |     let len = unsafe { libc::strlen(cstring.as_ptr()) };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::strlen-on-c-strings` implied by `-D warnings`\n+help: try this (you might also need to get rid of `unsafe` block in some cases):\n+   |\n+LL |     let len = unsafe { cstring.as_bytes().len() };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `libc::strlen` on a `CString` or `CStr` value\n+  --> $DIR/strlen_on_c_strings.rs:15:24\n+   |\n+LL |     let len = unsafe { libc::strlen(cstr.as_ptr()) };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try this (you might also need to get rid of `unsafe` block in some cases):\n+   |\n+LL |     let len = unsafe { cstr.to_bytes().len() };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69fbd64e2a4a4bd52dd8b965316c91902ab90797/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=69fbd64e2a4a4bd52dd8b965316c91902ab90797", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}]}