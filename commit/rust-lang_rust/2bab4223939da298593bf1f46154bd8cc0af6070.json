{"sha": "2bab4223939da298593bf1f46154bd8cc0af6070", "node_id": "C_kwDOAAsO6NoAKDJiYWI0MjIzOTM5ZGEyOTg1OTNiZjFmNDYxNTRiZDhjYzBhZjYwNzA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-22T16:23:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-23T19:00:04Z"}, "message": "Return nested obligations from canonical response var unification", "tree": {"sha": "9b2e97f03197ed284385cc5fdc3cf70fc9052266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b2e97f03197ed284385cc5fdc3cf70fc9052266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bab4223939da298593bf1f46154bd8cc0af6070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bab4223939da298593bf1f46154bd8cc0af6070", "html_url": "https://github.com/rust-lang/rust/commit/2bab4223939da298593bf1f46154bd8cc0af6070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bab4223939da298593bf1f46154bd8cc0af6070/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7fd9995f10627f25ccb325f693a11b3395a73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7fd9995f10627f25ccb325f693a11b3395a73c", "html_url": "https://github.com/rust-lang/rust/commit/df7fd9995f10627f25ccb325f693a11b3395a73c"}], "stats": {"total": 103, "additions": 78, "deletions": 25}, "files": [{"sha": "efecaf33ef987a9579ab622f09c4d821760952aa", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=2bab4223939da298593bf1f46154bd8cc0af6070", "patch": "@@ -99,20 +99,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: Vec<ty::GenericArg<'tcx>>,\n         response: CanonicalResponse<'tcx>,\n-    ) -> Result<Certainty, NoSolution> {\n+    ) -> Result<(Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let substitution = self.compute_query_response_substitution(&original_values, &response);\n \n         let Response { var_values, external_constraints, certainty } =\n             response.substitute(self.tcx(), &substitution);\n \n-        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+        let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n         // FIXME: implement external constraints.\n         let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n \n-        Ok(certainty)\n+        Ok((certainty, nested_goals))\n     }\n \n     /// This returns the substitutions to instantiate the bound variables of\n@@ -205,21 +205,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         original_values: &[ty::GenericArg<'tcx>],\n         var_values: CanonicalVarValues<'tcx>,\n-    ) -> Result<(), NoSolution> {\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         assert_eq!(original_values.len(), var_values.len());\n+\n+        let mut nested_goals = vec![];\n         for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n-            // This can fail due to the occurs check, see\n-            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n-            // where that can happen.\n-            //\n-            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n-            // some point. We can figure out how to deal with this once we actually have\n-            // an ICE.\n-            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n-            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+            nested_goals.extend(self.eq_and_get_goals(param_env, orig, response)?);\n         }\n \n-        Ok(())\n+        Ok(nested_goals)\n     }\n \n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {"}, {"sha": "e47b5ae21b5afafcc5e155c74bb05c84224193b7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=2bab4223939da298593bf1f46154bd8cc0af6070", "patch": "@@ -70,17 +70,16 @@ pub trait InferCtxtEvalExt<'tcx> {\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution>;\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution>;\n }\n \n impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n-\n         let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n@@ -152,13 +151,13 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         is_normalizes_to_hack: IsNormalizesToHack,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> Result<(bool, Certainty), NoSolution> {\n+    ) -> Result<(bool, Certainty, Vec<Goal<'tcx, ty::Predicate<'tcx>>>), NoSolution> {\n         let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty = self.instantiate_and_apply_query_response(\n+        let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n             canonical_response,\n@@ -186,7 +185,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n-        Ok((has_changed, certainty))\n+        Ok((has_changed, certainty, nested_goals))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {\n@@ -263,13 +262,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty) = match this.evaluate_goal(\n+                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n                         IsNormalizesToHack::Yes,\n                         goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n                     ) {\n                         Ok(r) => r,\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n@@ -308,11 +308,12 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 }\n \n                 for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty) =\n+                    let (changed, certainty, nested_goals) =\n                         match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n+                    new_goals.goals.extend(nested_goals);\n \n                     if changed {\n                         has_changed = Ok(());"}, {"sha": "76a2a5879114dc9377d15c8d03464bbf5a3657b4", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=2bab4223939da298593bf1f46154bd8cc0af6070", "patch": "@@ -1,6 +1,7 @@\n use std::mem;\n \n use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::Obligation;\n use rustc_infer::traits::{\n     query::NoSolution, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n     PredicateObligation, SelectionError, TraitEngine,\n@@ -61,7 +62,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n                 let goal = obligation.clone().into();\n-                let (changed, certainty) = match infcx.evaluate_root_goal(goal) {\n+                let (changed, certainty, nested_goals) = match infcx.evaluate_root_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n@@ -125,7 +126,16 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                         continue;\n                     }\n                 };\n-\n+                // Push any nested goals that we get from unifying our canonical response\n+                // with our obligation onto the fulfillment context.\n+                self.obligations.extend(nested_goals.into_iter().map(|goal| {\n+                    Obligation::new(\n+                        infcx.tcx,\n+                        obligation.cause.clone(),\n+                        goal.param_env,\n+                        goal.predicate,\n+                    )\n+                }));\n                 has_changed |= changed;\n                 match certainty {\n                     Certainty::Yes => {}"}, {"sha": "af42983bd9cf0453ee42989d1479e201b78e3534", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bab4223939da298593bf1f46154bd8cc0af6070/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=2bab4223939da298593bf1f46154bd8cc0af6070", "patch": "@@ -81,10 +81,18 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         if self.tcx.trait_solver_next() {\n             self.probe(|snapshot| {\n-                if let Ok((_, certainty)) =\n+                if let Ok((_, certainty, nested_goals)) =\n                     self.evaluate_root_goal(Goal::new(self.tcx, param_env, obligation.predicate))\n                 {\n                     match certainty {\n+                        // If we have nested obligations from instantiating the canonical\n+                        // response from this goal, just treat the response as ambiguous.\n+                        //\n+                        // FIXME(deferred_projection_equality): We need to process this\n+                        // in a loop probably... can't be worse than an ICE though\n+                        Certainty::Yes if !nested_goals.is_empty() => {\n+                            Ok(EvaluationResult::EvaluatedToAmbig)\n+                        }\n                         Certainty::Yes => {\n                             if self.opaque_types_added_in_snapshot(snapshot) {\n                                 Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)"}, {"sha": "4bfb6323a53662b32f8db005a7eb4a8ca5024e94", "filename": "tests/ui/traits/new-solver/alias-eq-in-canonical-response.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2bab4223939da298593bf1f46154bd8cc0af6070/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bab4223939da298593bf1f46154bd8cc0af6070/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-eq-in-canonical-response.rs?ref=2bab4223939da298593bf1f46154bd8cc0af6070", "patch": "@@ -0,0 +1,40 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo {\n+    type Gat<'a>\n+    where\n+        Self: 'a;\n+    fn bar(&self) -> Self::Gat<'_>;\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+impl<T> Option<T> {\n+    fn as_ref(&self) -> Option<&T> {\n+        match self {\n+            Option::Some(t) => Option::Some(t),\n+            Option::None => Option::None,\n+        }\n+    }\n+\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Option<U> {\n+        match self {\n+            Option::Some(t) => Option::Some(f(t)),\n+            Option::None => Option::None,\n+        }\n+    }\n+}\n+\n+impl<T: Foo + 'static> Foo for Option<T> {\n+    type Gat<'a> = Option<<T as Foo>::Gat<'a>> where Self: 'a;\n+\n+    fn bar(&self) -> Self::Gat<'_> {\n+        self.as_ref().map(Foo::bar)\n+    }\n+}\n+\n+fn main() {}"}]}