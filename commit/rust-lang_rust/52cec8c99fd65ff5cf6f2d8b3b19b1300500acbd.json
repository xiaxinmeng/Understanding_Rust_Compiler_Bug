{"sha": "52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "node_id": "C_kwDOAAsO6NoAKDUyY2VjOGM5OWZkNjVmZjVjZjZmMmQ4YjNiMTliMTMwMDUwMGFjYmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-07T14:39:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-07T14:39:07Z"}, "message": "Rollup merge of #105368 - WaffleLapkin:deref-even-harder, r=TaKO8Ki\n\nRemove more `ref` patterns from the compiler\n\nPrevious PR: #105045", "tree": {"sha": "8cf69cc61e08cdc0b56fca3a6d840e581232dc9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cf69cc61e08cdc0b56fca3a6d840e581232dc9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjkKWLCRBK7hj4Ov3rIwAAyDQIAFGC2lD5lG7Al0jK+tVsjUGp\n2qmzZ4P/AnUU6s3V2gg1cD+r563D737n8EiYd+e+r6GTIuUyipBpsVVUFnGOcU6O\nH5MOq/EFp8HN+fBx0m+XRFNv9vFbUcQTNa1tuYtVUR2M4e6npbBwI93t7Km7pPJo\ntb/MwNlUJwM1lYMmmktKIQTELOl3ZR1q+2PIN7yStEhuKatnMoS6yo9HfMyqQHXl\nbz54QjxDwXnENDR9mh9c5LBYLOxrC8BVMozNQMh81rU8bINUklE3EEBSrA/unQ8u\ngIx3BM2jpONkQuCJJ4gm749+ZgvSJS49EziWk5+/navk4CepgQvlkAkm0KHUMTs=\n=ETe6\n-----END PGP SIGNATURE-----\n", "payload": "tree 8cf69cc61e08cdc0b56fca3a6d840e581232dc9b\nparent 95da525982abf0bdf6304596b3b91f50dcc7154a\nparent 700c095306ce89b0b18e2487aae9c0721e60a5e3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670423947 +0100\ncommitter GitHub <noreply@github.com> 1670423947 +0100\n\nRollup merge of #105368 - WaffleLapkin:deref-even-harder, r=TaKO8Ki\n\nRemove more `ref` patterns from the compiler\n\nPrevious PR: #105045\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "html_url": "https://github.com/rust-lang/rust/commit/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95da525982abf0bdf6304596b3b91f50dcc7154a", "url": "https://api.github.com/repos/rust-lang/rust/commits/95da525982abf0bdf6304596b3b91f50dcc7154a", "html_url": "https://github.com/rust-lang/rust/commit/95da525982abf0bdf6304596b3b91f50dcc7154a"}, {"sha": "700c095306ce89b0b18e2487aae9c0721e60a5e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/700c095306ce89b0b18e2487aae9c0721e60a5e3", "html_url": "https://github.com/rust-lang/rust/commit/700c095306ce89b0b18e2487aae9c0721e60a5e3"}], "stats": {"total": 811, "additions": 390, "deletions": 421}, "files": [{"sha": "ab5e19050ead2ffbb0a0d475c69d985ec86fb588", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -277,8 +277,7 @@ where\n             allowed_through_unstable_modules = true;\n         }\n         // attributes with data\n-        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n+        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n@@ -533,25 +532,24 @@ where\n \n     // Merge the const-unstable info into the stability info\n     if promotable {\n-        if let Some((ref mut stab, _)) = const_stab {\n-            stab.promotable = promotable;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n+        match &mut const_stab {\n+            Some((stab, _)) => stab.promotable = promotable,\n+            _ => _ = sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp }),\n         }\n     }\n \n     if allowed_through_unstable_modules {\n-        if let Some((\n-            Stability {\n-                level: StabilityLevel::Stable { ref mut allowed_through_unstable_modules, .. },\n-                ..\n-            },\n-            _,\n-        )) = stab\n-        {\n-            *allowed_through_unstable_modules = true;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n         }\n     }\n \n@@ -654,8 +652,8 @@ pub fn eval_condition(\n     features: Option<&Features>,\n     eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n-    match cfg.kind {\n-        ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n+    match &cfg.kind {\n+        ast::MetaItemKind::List(mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n@@ -688,7 +686,7 @@ pub fn eval_condition(\n                 rustc_version >= min_version\n             }\n         }\n-        ast::MetaItemKind::List(ref mis) => {\n+        ast::MetaItemKind::List(mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(\n@@ -759,7 +757,7 @@ pub fn eval_condition(\n             sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n-        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n@@ -1036,52 +1034,58 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n-                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                        let name = meta_item.name_or_empty().to_ident_string();\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n-                            span: item.span(),\n-                            repr_arg: &name,\n-                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n-                                item.span(),\n-                                &value.kind,\n-                                &name,\n-                            ),\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                match &meta_item.kind {\n+                    MetaItemKind::NameValue(value) => {\n+                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                            let name = meta_item.name_or_empty().to_ident_string();\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                                span: item.span(),\n+                                repr_arg: &name,\n+                                cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                    item.span(),\n+                                    &value.kind,\n+                                    &name,\n+                                ),\n+                            });\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n-                } else if let MetaItemKind::List(_) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if meta_item.has_name(sym::packed) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                    MetaItemKind::List(_) => {\n+                        if meta_item.has_name(sym::align) {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                                span: meta_item.span,\n+                            });\n+                        } else if meta_item.has_name(sym::packed) {\n+                            recognised = true;\n+                            sess.emit_err(\n+                                session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                                    span: meta_item.span,\n+                                },\n+                            );\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n+                    _ => (),\n                 }\n             }\n             if !recognised {"}, {"sha": "5bb92a3582612f829cadce85e1b52118f4047916", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         rvalue: &mir::Rvalue<'tcx>,\n         location: mir::Location,\n     ) {\n-        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, borrowed_place) = rvalue {\n             if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n                 debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: *borrowed_place,\n+                borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n             let (idx, _) = self.location_map.insert_full(location, borrow);\n@@ -273,14 +273,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n-        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, place) = rvalue {\n             // double-check that we already registered a BorrowData for this\n \n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n-            assert_eq!(borrow_data.borrowed_place, *place);\n+            assert_eq!(borrow_data.borrowed_place, place);\n         }\n \n         self.super_rvalue(rvalue, location)"}, {"sha": "f825b1d8f70ef502952699fe81e4aecf57edb849", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -358,9 +358,9 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         stmt: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        match stmt.kind {\n-            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n+        match &stmt.kind {\n+            mir::StatementKind::Assign(box (lhs, rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -377,13 +377,13 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n \n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                self.kill_borrows_on_place(trans, lhs);\n+                self.kill_borrows_on_place(trans, *lhs);\n             }\n \n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(*local));\n             }\n \n             mir::StatementKind::FakeRead(..)"}, {"sha": "1550958ab8eee3942710ba5103fab472f560fa02", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -243,9 +243,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_prove_predicate_with_cause(&ocx, key, cause);\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n@@ -284,9 +284,9 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -328,9 +328,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }"}, {"sha": "5e3745f17353af8543cc8cbdf52dcf7b1e25cfd6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -265,7 +265,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(ref name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -1417,7 +1417,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n             (\n-                Some(ref name),\n+                Some(name),\n                 BorrowExplanation::MustBeValidFor {\n                     category:\n                         category @ (ConstraintCategory::Return(_)\n@@ -1438,7 +1438,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &format!(\"`{}`\", name),\n                 ),\n             (\n-                ref name,\n+                name,\n                 BorrowExplanation::MustBeValidFor {\n                     category: ConstraintCategory::Assignment,\n                     from_closure: false,\n@@ -1450,7 +1450,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     span,\n                     ..\n                 },\n-            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n+            ) => self.report_escaping_data(borrow_span, &name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n                 location,\n                 &name,\n@@ -2452,7 +2452,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n         debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        if let Some(&Statement { kind: StatementKind::Assign(box (ref reservation, _)), .. }) =\n+        if let Some(Statement { kind: StatementKind::Assign(box (reservation, _)), .. }) =\n             &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n@@ -2480,8 +2480,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n                             box AggregateKind::Closure(def_id, substs),\n-                            ref operands,\n-                        ) = *rvalue\n+                            operands,\n+                        ) = rvalue\n                         {\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n@@ -2505,7 +2505,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "304683618d83ef9dc531c7fcb7f7ed91ed329a7f", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -469,8 +469,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n-                    if let TerminatorKind::Call { ref func, from_hir_call: true, .. } =\n-                        block.terminator().kind\n+                    if let TerminatorKind::Call { func, from_hir_call: true, .. } =\n+                        &block.terminator().kind\n                     {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n@@ -515,19 +515,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n-        let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box (ref place, _)),\n-            ..\n-        }) = stmt\n-        {\n-            if let Some(local) = place.as_local() {\n-                local\n+        let mut target =\n+            if let Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) = stmt {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return false;\n+                }\n             } else {\n                 return false;\n-            }\n-        } else {\n-            return false;\n-        };\n+            };\n \n         debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n         while let Some(current_location) = queue.pop() {"}, {"sha": "4e2271a30672270a5ff8c49c1b4460ab8c11938b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -78,7 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let StatementKind::Assign(box (into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n-                    Operand::Copy(ref place) | Operand::Move(ref place)\n+                    Operand::Copy(place) | Operand::Move(place)\n                         if target == place.local_or_deref_local() =>\n                     {\n                         target = into.local_or_deref_local()\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n                 if Some(self.infcx.tcx.parent(id)) == self.infcx.tcx.lang_items().fn_once_trait() {\n                     let closure = match args.first() {\n-                        Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n+                        Some(Operand::Copy(place) | Operand::Move(place))\n                             if target == place.local_or_deref_local() =>\n                         {\n                             place.local_or_deref_local().unwrap()\n@@ -439,9 +439,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if !is_terminator {\n                         continue;\n                     } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call { ref func, from_hir_call: false, .. },\n+                        kind: TerminatorKind::Call { func, from_hir_call: false, .. },\n                         ..\n-                    }) = bbd.terminator\n+                    }) = &bbd.terminator\n                     {\n                         if let Some(source) =\n                             BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n@@ -811,33 +811,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n-        if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            match **kind {\n-                AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n-                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-                    if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(def_id, moved_place, places)\n-                    {\n-                        return ClosureUse {\n-                            generator_kind,\n-                            args_span,\n-                            capture_kind_span,\n-                            path_span,\n-                        };\n-                    }\n-                }\n-                _ => {}\n+        if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind\n+            && let AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) = **kind\n+        {\n+            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+            if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n+                self.closure_span(def_id, moved_place, places)\n+            {\n+                return ClosureUse {\n+                    generator_kind,\n+                    args_span,\n+                    capture_kind_span,\n+                    path_span,\n+                };\n             }\n         }\n \n         // StatementKind::FakeRead only contains a def_id if they are introduced as a result\n         // of pattern matching within a closure.\n-        if let StatementKind::FakeRead(box (cause, ref place)) = stmt.kind {\n+        if let StatementKind::FakeRead(box (cause, place)) = stmt.kind {\n             match cause {\n                 FakeReadCause::ForMatchedPlace(Some(closure_def_id))\n                 | FakeReadCause::ForLet(Some(closure_def_id)) => {\n                     debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n-                    let places = &[Operand::Move(*place)];\n+                    let places = &[Operand::Move(place)];\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n                         self.closure_span(closure_def_id, moved_place, places)\n                     {\n@@ -924,7 +921,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n         let target = match self.body[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(box (ref place, _)), .. }) => {\n+            Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) => {\n                 if let Some(local) = place.as_local() {\n                     local\n                 } else {\n@@ -940,9 +937,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) =\n-                stmt.kind\n-            {\n+            if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),"}, {"sha": "3319a80681fde277dc0fd3f361c2656adfafe6b6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -219,8 +219,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 local,\n                 projection:\n-                    &[\n-                        ref proj_base @ ..,\n+                    [\n+                        proj_base @ ..,\n                         ProjectionElem::Deref,\n                         ProjectionElem::Field(field, _),\n                         ProjectionElem::Deref,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n-                    field,\n+                    *field,\n                 ) {\n                     err.span_suggestion_verbose(\n                         span,"}, {"sha": "9bc2e79e29bc17c9b96a77b7ca99013312159a76", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Block(blk, _) => {\n-                if let Some(ref expr) = blk.expr {\n+                if let Some(expr) = blk.expr {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,"}, {"sha": "171e62d91e136463dfd600eb3dc9b51977b6ca59", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -254,7 +254,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n-        if let Some(ref value) = value {\n+        if let Some(value) = &value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n "}, {"sha": "f66a7ab3c031aa87ae54fc658047f2b4cf8384be", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, op);\n             }\n             StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n+                src,\n+                dst,\n+                count,\n             })) => {\n                 self.consume_operand(location, src);\n                 self.consume_operand(location, dst);\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n@@ -119,16 +119,16 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.mutate_place(location, *drop_place, Deep);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -141,15 +141,15 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n                 self.mutate_place(location, *destination, Deep);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(location, cond);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }\n             }\n-            TerminatorKind::Yield { ref value, resume, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume, resume_arg, drop: _ } => {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n@@ -175,25 +175,25 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(location, value);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n-                            if let Some(place) = place {\n+                            if let &Some(place) = place {\n                                 self.mutate_place(location, place, Shallow(None));\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(location, in_value);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(location, out_place, Shallow(None));\n                             }\n                         }\n@@ -252,8 +252,8 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -288,20 +288,19 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n-                self.consume_operand(location, operand)\n-            }\n-            Rvalue::CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => self.consume_operand(location, operand),\n+\n+            &Rvalue::CopyForDeref(place) => {\n+                let op = &Operand::Copy(place);\n                 self.consume_operand(location, op);\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n-                let af = match *rvalue {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n+                let af = match rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n@@ -314,15 +313,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, operand1);\n                 self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {}\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for operand in operands {\n                     self.consume_operand(location, operand);\n                 }"}, {"sha": "74b4e4a0cabdd6826807ba410ff4af8884fb2c4d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -578,12 +578,12 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n         self.check_activations(location, span, flow_state);\n \n         match &stmt.kind {\n-            StatementKind::Assign(box (lhs, ref rhs)) => {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n                 self.mutate_place(location, (*lhs, span), Shallow(None), flow_state);\n             }\n-            StatementKind::FakeRead(box (_, ref place)) => {\n+            StatementKind::FakeRead(box (_, place)) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -601,7 +601,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.consume_operand(location, (op, span), flow_state),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     span,\n@@ -643,8 +643,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n         self.check_activations(loc, span, flow_state);\n \n-        match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+        match &term.kind {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place, target: _, unwind: _ } => {\n@@ -656,24 +656,24 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n                 self.access_place(\n                     loc,\n-                    (place, span),\n+                    (*place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(loc, (drop_place, span), Deep, flow_state);\n+                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n                 self.consume_operand(loc, (new_value, span), flow_state);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -684,43 +684,43 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                self.mutate_place(loc, (destination, span), Deep, flow_state);\n+                self.mutate_place(loc, (*destination, span), Deep, flow_state);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n-                self.mutate_place(loc, (resume_arg, span), Deep, flow_state);\n+                self.mutate_place(loc, (*resume_arg, span), Deep, flow_state);\n             }\n \n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(loc, (value, span), flow_state);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n                             if let Some(place) = place {\n-                                self.mutate_place(loc, (place, span), Shallow(None), flow_state);\n+                                self.mutate_place(loc, (*place, span), Shallow(None), flow_state);\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(loc, (in_value, span), flow_state);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(\n                                     loc,\n                                     (out_place, span),\n@@ -1164,8 +1164,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1203,7 +1203,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1232,14 +1232,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n-            Rvalue::CopyForDeref(place) => {\n+\n+            &Rvalue::CopyForDeref(place) => {\n                 self.access_place(\n                     location,\n                     (place, span),\n@@ -1257,7 +1258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1278,8 +1279,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, (operand1, span), flow_state);\n                 self.consume_operand(location, (operand2, span), flow_state);\n             }\n@@ -1288,7 +1289,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // nullary ops take no dynamic input; no borrowck effect.\n             }\n \n-            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+            Rvalue::Aggregate(aggregate_kind, operands) => {\n                 // We need to report back the list of mutable upvars that were\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set."}, {"sha": "6d4ec6b726eb027f6e330b084370048445bce315", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -1189,8 +1189,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         let tcx = self.tcx();\n         debug!(\"stmt kind: {:?}\", stmt.kind);\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rv)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n@@ -1279,11 +1279,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n+            StatementKind::AscribeUserType(box (place, projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n-                    variance,\n+                    *variance,\n                     projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.check_operand(op, location),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     stmt.source_info.span,\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         debug!(\"terminator kind: {:?}\", term.kind);\n-        match term.kind {\n+        match &term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n@@ -1360,13 +1360,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, .. } => {\n                 self.check_operand(discr, term_location);\n \n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n-                    switch_ty,\n+                    *switch_ty,\n                     term_location.to_locations(),\n                     ConstraintCategory::Assignment,\n                 ) {\n@@ -1384,14 +1384,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                from_hir_call,\n-                target,\n-                ..\n-            } => {\n+            TerminatorKind::Call { func, args, destination, from_hir_call, target, .. } => {\n                 self.check_operand(func, term_location);\n                 for arg in args {\n                     self.check_operand(arg, term_location);\n@@ -1431,7 +1424,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     ConstraintCategory::Boring,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(body, term, &sig, *destination, target, term_location);\n+                self.check_call_dest(body, term, &sig, *destination, *target, term_location);\n \n                 // The ordinary liveness rules will ensure that all\n                 // regions in the type of the callee are live here. We\n@@ -1449,17 +1442,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         .add_element(region_vid, term_location);\n                 }\n \n-                self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n+                self.check_call_inputs(body, term, &sig, args, term_location, *from_hir_call);\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert { cond, msg, .. } => {\n                 self.check_operand(cond, term_location);\n \n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n@@ -1468,7 +1461,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::Yield { ref value, .. } => {\n+            TerminatorKind::Yield { value, .. } => {\n                 self.check_operand(value, term_location);\n \n                 let value_ty = value.ty(body, tcx);\n@@ -2630,7 +2623,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+        if let Some(closure_requirements) = &tcx.mir_borrowck(def_id).closure_requirements {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 self.borrowck_context.universal_regions,"}, {"sha": "a4a0c5b90fed32d2a20372aa908806b81aa9a2fe", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -587,9 +587,9 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ref substs)\n-            | DefiningTy::Generator(_, ref substs, _)\n-            | DefiningTy::InlineConst(_, ref substs) => {\n+            DefiningTy::Closure(_, substs)\n+            | DefiningTy::Generator(_, substs, _)\n+            | DefiningTy::InlineConst(_, substs) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `typeck_root_def_id`."}, {"sha": "95e38e4b053f496604f25079b22722e2fbf3dc4b", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -17,32 +17,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n \n     let orig_item = item.clone();\n-    let not_function = || {\n-        ecx.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .span_err(item.span(), \"alloc_error_handler must be a function\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[alloc_error_handler]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, sig_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n-            _ => return not_function(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Fn(ref fn_kind) => {\n-                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n-                }\n-                _ => return not_function(),\n-            },\n-            _ => return not_function(),\n-        },\n-        _ => return not_function(),\n-    };\n+    let (item, is_stmt, sig_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            return vec![orig_item.clone()];\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "93b07801e035d7de24d995980ccd1568063ffb29", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -191,19 +191,19 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     ///\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n-        match (*expr).kind {\n-            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+        match &mut expr.kind {\n+            ExprKind::AddrOf(_, mutability, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(mutability, Mutability::Mut),\n                     |this| this.manage_cond_expr(local_expr)\n                 );\n             }\n-            ExprKind::Array(ref mut local_exprs) => {\n+            ExprKind::Array(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+            ExprKind::Binary(op, lhs, rhs) => {\n                 self.with_is_consumed_management(\n                     matches!(\n                         op.node,\n@@ -226,56 +226,56 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     }\n                 );\n             }\n-            ExprKind::Call(_, ref mut local_exprs) => {\n+            ExprKind::Call(_, local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Cast(ref mut local_expr, _) => {\n+            ExprKind::Cast(local_expr, _) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Index(ref mut prefix, ref mut suffix) => {\n+            ExprKind::Index(prefix, suffix) => {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n-            ExprKind::MethodCall(ref mut call) => {\n-                for arg in call.args.iter_mut() {\n+            ExprKind::MethodCall(call) => {\n+                for arg in &mut call.args {\n                     self.manage_cond_expr(arg);\n                 }\n             }\n-            ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n+            ExprKind::Path(_, Path { segments, .. }) if let [path_segment] = &segments[..] => {\n                 let path_ident = path_segment.ident;\n                 self.manage_initial_capture(expr, path_ident);\n             }\n-            ExprKind::Paren(ref mut local_expr) => {\n+            ExprKind::Paren(local_expr) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Range(ref mut prefix, ref mut suffix, _) => {\n-                if let Some(ref mut elem) = prefix {\n+            ExprKind::Range(prefix, suffix, _) => {\n+                if let Some(elem) = prefix {\n                     self.manage_cond_expr(elem);\n                 }\n-                if let Some(ref mut elem) = suffix {\n+                if let Some(elem) = suffix {\n                     self.manage_cond_expr(elem);\n                 }\n             }\n-            ExprKind::Repeat(ref mut local_expr, ref mut elem) => {\n+            ExprKind::Repeat(local_expr, elem) => {\n                 self.manage_cond_expr(local_expr);\n                 self.manage_cond_expr(&mut elem.value);\n             }\n-            ExprKind::Struct(ref mut elem) => {\n+            ExprKind::Struct(elem) => {\n                 for field in &mut elem.fields {\n                     self.manage_cond_expr(&mut field.expr);\n                 }\n-                if let StructRest::Base(ref mut local_expr) = elem.rest {\n+                if let StructRest::Base(local_expr) = &mut elem.rest {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Tup(ref mut local_exprs) => {\n+            ExprKind::Tup(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(un_op, ref mut local_expr) => {\n+            ExprKind::Unary(un_op, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(un_op, UnOp::Neg | UnOp::Not),\n                     |this| this.manage_cond_expr(local_expr)"}, {"sha": "e2d71825d556f69ca9bbc4277848b4aaf89047ad", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -20,7 +20,7 @@ pub fn expand_concat(\n     for e in es {\n         match e.kind {\n             ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n-                Ok(ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _)) => {\n+                Ok(ast::LitKind::Str(s, _) | ast::LitKind::Float(s, _)) => {\n                     accumulator.push_str(s.as_str());\n                 }\n                 Ok(ast::LitKind::Char(c)) => {"}, {"sha": "d1124145dcbbb663febddf26081de93812aa39d5", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -144,8 +144,8 @@ pub fn expand_concat_bytes(\n     let mut missing_literals = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.kind {\n-            ast::ExprKind::Array(ref exprs) => {\n+        match &e.kind {\n+            ast::ExprKind::Array(exprs) => {\n                 for expr in exprs {\n                     if let Some(elem) =\n                         handle_array_element(cx, &mut has_errors, &mut missing_literals, expr)\n@@ -154,7 +154,7 @@ pub fn expand_concat_bytes(\n                     }\n                 }\n             }\n-            ast::ExprKind::Repeat(ref expr, ref count) => {\n+            ast::ExprKind::Repeat(expr, count) => {\n                 if let ast::ExprKind::Lit(token_lit) = count.value.kind\n                 && let Ok(ast::LitKind::Int(count_val, _)) =\n                     ast::LitKind::from_token_lit(token_lit)\n@@ -170,7 +170,7 @@ pub fn expand_concat_bytes(\n                     cx.span_err(count.value.span, \"repeat count is not a positive number\");\n                 }\n             }\n-            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n@@ -184,7 +184,7 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 accumulator.extend_from_slice(bytes);\n             }\n             ast::ExprKind::Err => {"}, {"sha": "d59b3b8c86d35ef6303bb8a3adbd5e9aecf2d1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -32,10 +32,10 @@ pub fn expand_deriving_clone(\n     let bounds;\n     let substructure;\n     let is_simple;\n-    match *item {\n-        Annotatable::Item(ref annitem) => match annitem.kind {\n-            ItemKind::Struct(_, Generics { ref params, .. })\n-            | ItemKind::Enum(_, Generics { ref params, .. }) => {\n+    match item {\n+        Annotatable::Item(annitem) => match &annitem.kind {\n+            ItemKind::Struct(_, Generics { params, .. })\n+            | ItemKind::Enum(_, Generics { params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let has_derive_copy = cx.resolver.has_derive_copy(container_id);\n                 if has_derive_copy\n@@ -166,13 +166,13 @@ fn cs_clone(\n     };\n \n     let vdata;\n-    match *substr.fields {\n-        Struct(vdata_, ref af) => {\n+    match substr.fields {\n+        Struct(vdata_, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident]);\n             all_fields = af;\n-            vdata = vdata_;\n+            vdata = *vdata_;\n         }\n-        EnumMatching(.., variant, ref af) => {\n+        EnumMatching(.., variant, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n             vdata = &variant.data;"}, {"sha": "62af02c2bb4b2d35304cf4eafd42036fba31d5ef", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -78,11 +78,11 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    let expr = match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            let nfields = match *summary {\n-                Unnamed(ref fields, _) => fields.len(),\n-                Named(ref fields) => fields.len(),\n+    let expr = match substr.fields {\n+        StaticStruct(_, summary) => {\n+            let nfields = match summary {\n+                Unnamed(fields, _) => fields.len(),\n+                Named(fields) => fields.len(),\n             };\n             let fn_read_struct_field_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct_field]);\n@@ -119,7 +119,7 @@ fn decodable_substructure(\n                 ],\n             )\n         }\n-        StaticEnum(_, ref fields) => {\n+        StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n@@ -194,10 +194,10 @@ fn decode_static_fields<F>(\n where\n     F: FnMut(&mut ExtCtxt<'_>, Span, Symbol, usize) -> P<Expr>,\n {\n-    match *fields {\n-        Unnamed(ref fields, is_tuple) => {\n+    match fields {\n+        Unnamed(fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if !is_tuple {\n+            if !*is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields\n@@ -209,7 +209,7 @@ where\n                 cx.expr_call(trait_span, path_expr, fields)\n             }\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields\n                 .iter()"}, {"sha": "eb66c4a69a69bc25bab4126e1649d5f3097a940f", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -62,15 +62,12 @@ fn default_struct_substructure(\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     let expr = match summary {\n-        Unnamed(ref fields, is_tuple) => {\n-            if !is_tuple {\n-                cx.expr_ident(trait_span, substr.type_ident)\n-            } else {\n-                let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n-                cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n-            }\n+        Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),\n+        Unnamed(fields, true) => {\n+            let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n+            cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             let default_fields = fields\n                 .iter()\n                 .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))"}, {"sha": "68bc0ff2ec0b41c553339586a0874ef5fcb6a1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -164,8 +164,8 @@ fn encodable_substructure(\n         ],\n     ));\n \n-    match *substr.fields {\n-        Struct(_, ref fields) => {\n+    match substr.fields {\n+        Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n@@ -224,7 +224,7 @@ fn encodable_substructure(\n             BlockOrExpr::new_expr(expr)\n         }\n \n-        EnumMatching(idx, _, variant, ref fields) => {\n+        EnumMatching(idx, _, variant, fields) => {\n             // We're not generating an AST that the borrow checker is expecting,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n@@ -274,7 +274,7 @@ fn encodable_substructure(\n                 vec![\n                     blkencoder,\n                     name,\n-                    cx.expr_usize(trait_span, idx),\n+                    cx.expr_usize(trait_span, *idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],"}, {"sha": "beac591bfc879065a2c6fd411be0673ba59a3383", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -369,15 +369,14 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.kind {\n-                if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.ident.name) {\n-                        self.type_params.push(TypeParameter {\n-                            bound_generic_params: self.bound_generic_params_stack.clone(),\n-                            ty: P(ty.clone()),\n-                        });\n-                    }\n-                }\n+            if let ast::TyKind::Path(_, path) = &ty.kind\n+                && let Some(segment) = path.segments.first()\n+                && self.ty_param_names.contains(&segment.ident.name)\n+            {\n+                self.type_params.push(TypeParameter {\n+                    bound_generic_params: self.bound_generic_params_stack.clone(),\n+                    ty: P(ty.clone()),\n+                });\n             }\n \n             visit::walk_ty(self, ty)\n@@ -428,8 +427,8 @@ impl<'a> TraitDef<'a> {\n         push: &mut dyn FnMut(Annotatable),\n         from_scratch: bool,\n     ) {\n-        match *item {\n-            Annotatable::Item(ref item) => {\n+        match item {\n+            Annotatable::Item(item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n                     for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n@@ -438,10 +437,10 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.kind {\n-                    ast::ItemKind::Struct(_, ref generics)\n-                    | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                let has_no_type_params = match &item.kind {\n+                    ast::ItemKind::Struct(_, generics)\n+                    | ast::ItemKind::Enum(_, generics)\n+                    | ast::ItemKind::Union(_, generics) => !generics\n                         .params\n                         .iter()\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n@@ -451,24 +450,24 @@ impl<'a> TraitDef<'a> {\n                 let copy_fields =\n                     is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n-                let newitem = match item.kind {\n-                    ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n+                let newitem = match &item.kind {\n+                    ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n                         cx,\n                         &struct_def,\n                         item.ident,\n                         generics,\n                         from_scratch,\n                         copy_fields,\n                     ),\n-                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n                         // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n-                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Union(struct_def, generics) => {\n                         if self.supports_unions {\n                             self.expand_struct_def(\n                                 cx,\n@@ -663,12 +662,11 @@ impl<'a> TraitDef<'a> {\n \n                     for field_ty_param in field_ty_params {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = field_ty_param.ty.kind {\n-                            if p.segments.len() == 1\n-                                && ty_param_names.contains(&p.segments[0].ident.name)\n-                            {\n-                                continue;\n-                            };\n+                        if let ast::TyKind::Path(_, p) = &field_ty_param.ty.kind\n+                            && let [sole_segment] = &*p.segments\n+                            && ty_param_names.contains(&sole_segment.ident.name)\n+                        {\n+                            continue;\n                         }\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds"}, {"sha": "eaa4881906a8e3aed446cec6b99657d64972d02f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -115,7 +115,7 @@ impl Ty {\n         self_ty: Ident,\n         generics: &Generics,\n     ) -> ast::Path {\n-        match *self {\n+        match self {\n             Self_ => {\n                 let params: Vec<_> = generics\n                     .params\n@@ -135,7 +135,7 @@ impl Ty {\n \n                 cx.path_all(span, false, vec![self_ty], params)\n             }\n-            Path(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Path(p) => p.to_path(cx, span, self_ty, generics),\n             Ref(..) => cx.span_bug(span, \"ref in a path in generic `derive`\"),\n             Unit => cx.span_bug(span, \"unit in a path in generic `derive`\"),\n         }\n@@ -180,10 +180,7 @@ impl Bounds {\n         let params = self\n             .bounds\n             .iter()\n-            .map(|t| {\n-                let (name, ref bounds) = *t;\n-                mk_ty_param(cx, span, name, &bounds, self_ty, self_generics)\n-            })\n+            .map(|&(name, ref bounds)| mk_ty_param(cx, span, name, &bounds, self_ty, self_generics))\n             .collect();\n \n         Generics {"}, {"sha": "de657e4e6006dcd8aea6ce578dd2657242a488b2", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -125,12 +125,12 @@ fn inject_impl_of_structural_trait(\n     structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let Annotatable::Item(ref item) = *item else {\n+    let Annotatable::Item(item) = item else {\n         unreachable!();\n     };\n \n-    let generics = match item.kind {\n-        ItemKind::Struct(_, ref generics) | ItemKind::Enum(_, ref generics) => generics,\n+    let generics = match &item.kind {\n+        ItemKind::Struct(_, generics) | ItemKind::Enum(_, generics) => generics,\n         // Do not inject `impl Structural for Union`. (`PartialEq` does not\n         // support unions, so we will see error downstream.)\n         ItemKind::Union(..) => return,"}, {"sha": "0b4e545f7a3d0360757c9588e97742e7f4e1f0c6", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }"}, {"sha": "6f7fc3a95ba640e21311aca2d37b403f0f25a2c4", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -13,23 +13,23 @@ pub(crate) mod printf {\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> &str {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.span,\n+            match self {\n+                Substitution::Format(fmt) => fmt.span,\n                 Substitution::Escape(_) => \"%%\",\n             }\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match *self {\n-                Substitution::Format(ref fmt) => Some(fmt.position),\n-                Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n+            match self {\n+                Substitution::Format(fmt) => Some(fmt.position),\n+                &Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n             }\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n-                Substitution::Format(ref mut fmt) => fmt.position = InnerSpan::new(start, end),\n-                Substitution::Escape(ref mut pos) => *pos = (start, end),\n+                Substitution::Format(fmt) => fmt.position = InnerSpan::new(start, end),\n+                Substitution::Escape(pos) => *pos = (start, end),\n             }\n         }\n \n@@ -38,8 +38,8 @@ pub(crate) mod printf {\n         /// This ignores cases where the substitution does not have an exact equivalent, or where\n         /// the substitution would be unnecessary.\n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.translate(),\n+            match self {\n+                Substitution::Format(fmt) => fmt.translate(),\n                 Substitution::Escape(_) => Err(None),\n             }\n         }\n@@ -635,23 +635,17 @@ pub mod shell {\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match self {\n-                Substitution::Ordinal(_, pos)\n-                | Substitution::Name(_, pos)\n-                | Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            Some(InnerSpan::new(pos.0, pos.1))\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Ordinal(_, ref mut pos)\n-                | Substitution::Name(_, ref mut pos)\n-                | Substitution::Escape(ref mut pos) => *pos = (start, end),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            *pos = (start, end);\n         }\n \n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n+            match self {\n                 Substitution::Ordinal(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Name(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Escape(_) => Err(None),"}, {"sha": "41531580c1987ca92c0a2e76c10dc993c1c7e16a", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -20,27 +20,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let orig_item = item.clone();\n-    let not_static = || {\n-        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[global_allocator]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, ty_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Static(ref ty, ..) => (item, false, ecx.with_def_site_ctxt(ty.span)),\n-            _ => return not_static(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Static(ref ty, ..) => (item_, true, ecx.with_def_site_ctxt(ty.span)),\n-                _ => return not_static(),\n-            },\n-            _ => return not_static(),\n-        },\n-        _ => return not_static(),\n-    };\n+    let (item, is_stmt, ty_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(ty.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(ty.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+            return vec![orig_item.clone()]\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "f5f02fc772ab6b5b08b1082ab3fdb8ee6ec99f3c", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -466,61 +466,67 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(box ast::Fn { ref sig, ref generics, .. }) = i.kind {\n-        if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-            sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                .span_label(span, \"`unsafe` because of this\")\n-                .emit();\n-            return false;\n-        }\n-        if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-            sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                .span_label(span, \"`async` because of this\")\n-                .emit();\n-            return false;\n-        }\n-\n-        // If the termination trait is active, the compiler will check that the output\n-        // type implements the `Termination` trait as `libtest` enforces that.\n-        let has_output = match sig.decl.output {\n-            ast::FnRetTy::Default(..) => false,\n-            ast::FnRetTy::Ty(ref t) if t.kind.is_unit() => false,\n-            _ => true,\n-        };\n-\n-        if !sig.decl.inputs.is_empty() {\n-            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n-            return false;\n-        }\n+    match &i.kind {\n+        ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n+            if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n+                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n+                    .span_label(span, \"`unsafe` because of this\")\n+                    .emit();\n+                return false;\n+            }\n+            if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n+                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n+                    .span_label(span, \"`async` because of this\")\n+                    .emit();\n+                return false;\n+            }\n \n-        match (has_output, has_should_panic_attr) {\n-            (true, true) => {\n-                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n-                false\n+            // If the termination trait is active, the compiler will check that the output\n+            // type implements the `Termination` trait as `libtest` enforces that.\n+            let has_output = match &sig.decl.output {\n+                ast::FnRetTy::Default(..) => false,\n+                ast::FnRetTy::Ty(t) if t.kind.is_unit() => false,\n+                _ => true,\n+            };\n+\n+            if !sig.decl.inputs.is_empty() {\n+                sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                return false;\n             }\n-            (true, false) => {\n-                if !generics.params.is_empty() {\n-                    sd.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+\n+            match (has_output, has_should_panic_attr) {\n+                (true, true) => {\n+                    sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n                     false\n-                } else {\n-                    true\n                 }\n+                (true, false) => {\n+                    if !generics.params.is_empty() {\n+                        sd.span_err(\n+                            i.span,\n+                            \"functions used as tests must have signature fn() -> ()\",\n+                        );\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                }\n+                (false, _) => true,\n             }\n-            (false, _) => true,\n         }\n-    } else {\n-        // should be unreachable because `is_test_fn_item` should catch all non-fn items\n-        false\n+        _ => {\n+            // should be unreachable because `is_test_fn_item` should catch all non-fn items\n+            debug_assert!(false);\n+            false\n+        }\n     }\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(box ast::Fn { ref sig, .. }) = i.kind {\n+    let has_sig = match &i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n-        sig.decl.inputs.len() == 1\n-    } else {\n-        false\n+        ast::ItemKind::Fn(box ast::Fn { sig, .. }) => sig.decl.inputs.len() == 1,\n+        _ => false,\n     };\n \n     if !has_sig {"}, {"sha": "ad8871080910640e11e123b8f27221101f2a543d", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=52cec8c99fd65ff5cf6f2d8b3b19b1300500acbd", "patch": "@@ -131,8 +131,9 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ref spans)) = item.kind {\n-            let ast::ModSpans { inner_span: span, inject_use_span: _ } = *spans;\n+        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ast::ModSpans { inner_span: span, .. })) =\n+            item.kind\n+        {\n             let prev_tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n             self.add_test_cases(item.id, span, prev_tests);"}]}