{"sha": "6bde542a39fe63298a31b838e59705797ed8a2cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZGU1NDJhMzlmZTYzMjk4YTMxYjgzOGU1OTcwNTc5N2VkOGEyY2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-07-01T15:15:20Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-07-01T15:15:20Z"}, "message": "Split `CrateImplDefs` in inherent and trait impls\n\nThis makes the intention of inherent vs. trait impls somewhat more\nclear and also fixes (?) an issue where trait impls with an unresolved\ntrait were added as inherent impls instead (hence the test changes).", "tree": {"sha": "da737bc4b3e1d80782ae4adc132d99c0413aa1d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da737bc4b3e1d80782ae4adc132d99c0413aa1d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bde542a39fe63298a31b838e59705797ed8a2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bde542a39fe63298a31b838e59705797ed8a2cf", "html_url": "https://github.com/rust-lang/rust/commit/6bde542a39fe63298a31b838e59705797ed8a2cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bde542a39fe63298a31b838e59705797ed8a2cf/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07ba986db7b9f7c275bc2b6a32487e0aa8b70864", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ba986db7b9f7c275bc2b6a32487e0aa8b70864", "html_url": "https://github.com/rust-lang/rust/commit/07ba986db7b9f7c275bc2b6a32487e0aa8b70864"}], "stats": {"total": 248, "additions": 130, "deletions": 118}, "files": [{"sha": "cc72964ffd869a2a0d614e15bc72bb4178fb25cd", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -1053,12 +1053,14 @@ pub struct ImplDef {\n \n impl ImplDef {\n     pub fn all_in_crate(db: &dyn HirDatabase, krate: Crate) -> Vec<ImplDef> {\n-        let impls = db.impls_in_crate(krate.id);\n-        impls.all_impls().map(Self::from).collect()\n+        let inherent = db.inherent_impls_in_crate(krate.id);\n+        let trait_ = db.trait_impls_in_crate(krate.id);\n+\n+        inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n     pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<ImplDef> {\n-        let impls = db.impls_in_crate(krate.id);\n-        impls.lookup_impl_defs_for_trait(trait_.id).map(Self::from).collect()\n+        let impls = db.trait_impls_in_crate(krate.id);\n+        impls.for_trait(trait_.id).map(Self::from).collect()\n     }\n \n     pub fn target_trait(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n@@ -1303,10 +1305,10 @@ impl Type {\n         mut callback: impl FnMut(AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         for krate in self.ty.value.def_crates(db, krate.id)? {\n-            let impls = db.impls_in_crate(krate);\n+            let impls = db.inherent_impls_in_crate(krate);\n \n-            for impl_def in impls.lookup_impl_defs(&self.ty.value) {\n-                for &item in db.impl_data(impl_def).items.iter() {\n+            for impl_def in impls.for_self_ty(&self.ty.value) {\n+                for &item in db.impl_data(*impl_def).items.iter() {\n                     if let Some(result) = callback(item.into()) {\n                         return Some(result);\n                     }"}, {"sha": "cb48ca0656c747a7bef08b67f2dd7033b5188fdf", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -16,10 +16,10 @@ pub use hir_expand::db::{\n pub use hir_ty::db::{\n     AssociatedTyDataQuery, AssociatedTyValueQuery, CallableItemSignatureQuery, FieldTypesQuery,\n     GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery, HirDatabase,\n-    HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, ImplsFromDepsQuery,\n-    ImplsInCrateQuery, InferQueryQuery, InternAssocTyValueQuery, InternChalkImplQuery,\n-    InternTypeCtorQuery, InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery,\n-    TraitDatumQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n+    HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, InferQueryQuery,\n+    InherentImplsInCrateQuery, InternAssocTyValueQuery, InternChalkImplQuery, InternTypeCtorQuery,\n+    InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery, TraitDatumQuery,\n+    TraitImplsInCrateQuery, TraitImplsInDepsQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n };\n \n #[test]"}, {"sha": "dc06c0ee720d704eec2b15de640230ab50de01d1", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -11,7 +11,7 @@ use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n use ra_prof::profile;\n \n use crate::{\n-    method_resolution::CrateImplDefs,\n+    method_resolution::{InherentImpls, TraitImpls},\n     traits::{chalk, AssocTyValue, Impl},\n     Binders, CallableDef, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n     ReturnTypeImplTraits, TraitRef, Ty, TyDefId, TypeCtor, ValueTyDefId,\n@@ -67,11 +67,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::generic_defaults_query)]\n     fn generic_defaults(&self, def: GenericDefId) -> Arc<[Binders<Ty>]>;\n \n-    #[salsa::invoke(crate::method_resolution::CrateImplDefs::impls_in_crate_query)]\n-    fn impls_in_crate(&self, krate: CrateId) -> Arc<CrateImplDefs>;\n+    #[salsa::invoke(InherentImpls::inherent_impls_in_crate_query)]\n+    fn inherent_impls_in_crate(&self, krate: CrateId) -> Arc<InherentImpls>;\n \n-    #[salsa::invoke(crate::method_resolution::CrateImplDefs::impls_from_deps_query)]\n-    fn impls_from_deps(&self, krate: CrateId) -> Arc<CrateImplDefs>;\n+    #[salsa::invoke(TraitImpls::trait_impls_in_crate_query)]\n+    fn trait_impls_in_crate(&self, krate: CrateId) -> Arc<TraitImpls>;\n+\n+    #[salsa::invoke(TraitImpls::trait_impls_in_deps_query)]\n+    fn trait_impls_in_deps(&self, krate: CrateId) -> Arc<TraitImpls>;\n \n     // Interned IDs for Chalk integration\n     #[salsa::interned]"}, {"sha": "5dbabd12b3b37ff65d17e17cf606eb736c35ee52", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 98, "deletions": 94, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -38,127 +38,131 @@ impl TyFingerprint {\n     }\n }\n \n-/// A queryable and mergeable collection of impls.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct CrateImplDefs {\n-    inherent_impls: FxHashMap<TyFingerprint, Vec<ImplId>>,\n-    impls_by_trait: FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>,\n+/// Trait impls defined or available in some crate.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct TraitImpls {\n+    // If the `Option<TyFingerprint>` is `None`, the impl may apply to any self type.\n+    map: FxHashMap<TraitId, FxHashMap<Option<TyFingerprint>, Vec<ImplId>>>,\n }\n \n-impl CrateImplDefs {\n-    pub(crate) fn impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<CrateImplDefs> {\n-        let _p = profile(\"impls_in_crate_query\");\n-        let mut res = CrateImplDefs {\n-            inherent_impls: FxHashMap::default(),\n-            impls_by_trait: FxHashMap::default(),\n-        };\n-        res.fill(db, krate);\n+impl TraitImpls {\n+    pub(crate) fn trait_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = profile(\"trait_impls_in_crate_query\");\n+        let mut impls = Self { map: FxHashMap::default() };\n \n-        Arc::new(res)\n+        let crate_def_map = db.crate_def_map(krate);\n+        for (_module_id, module_data) in crate_def_map.modules.iter() {\n+            for impl_id in module_data.scope.impls() {\n+                let target_trait = match db.impl_trait(impl_id) {\n+                    Some(tr) => tr.value.trait_,\n+                    None => continue,\n+                };\n+                let self_ty = db.impl_self_ty(impl_id);\n+                let self_ty_fp = TyFingerprint::for_impl(&self_ty.value);\n+                impls\n+                    .map\n+                    .entry(target_trait)\n+                    .or_default()\n+                    .entry(self_ty_fp)\n+                    .or_default()\n+                    .push(impl_id);\n+            }\n+        }\n+\n+        Arc::new(impls)\n     }\n \n-    /// Collects all impls from transitive dependencies of `krate` that may be used by `krate`.\n-    ///\n-    /// The full set of impls that can be used by `krate` is the returned map plus all the impls\n-    /// from `krate` itself.\n-    pub(crate) fn impls_from_deps_query(\n-        db: &dyn HirDatabase,\n-        krate: CrateId,\n-    ) -> Arc<CrateImplDefs> {\n-        let _p = profile(\"impls_from_deps_query\");\n+    pub(crate) fn trait_impls_in_deps_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = profile(\"trait_impls_in_deps_query\");\n         let crate_graph = db.crate_graph();\n-        let mut res = CrateImplDefs {\n-            inherent_impls: FxHashMap::default(),\n-            impls_by_trait: FxHashMap::default(),\n-        };\n+        let mut res = Self { map: FxHashMap::default() };\n \n         for krate in crate_graph.transitive_deps(krate) {\n-            res.merge(&db.impls_in_crate(krate));\n+            res.merge(&db.trait_impls_in_crate(krate));\n         }\n \n         Arc::new(res)\n     }\n \n-    fn fill(&mut self, db: &dyn HirDatabase, krate: CrateId) {\n-        let crate_def_map = db.crate_def_map(krate);\n-        for (_module_id, module_data) in crate_def_map.modules.iter() {\n-            for impl_id in module_data.scope.impls() {\n-                match db.impl_trait(impl_id) {\n-                    Some(tr) => {\n-                        let self_ty = db.impl_self_ty(impl_id);\n-                        let self_ty_fp = TyFingerprint::for_impl(&self_ty.value);\n-                        self.impls_by_trait\n-                            .entry(tr.value.trait_)\n-                            .or_default()\n-                            .entry(self_ty_fp)\n-                            .or_default()\n-                            .push(impl_id);\n-                    }\n-                    None => {\n-                        let self_ty = db.impl_self_ty(impl_id);\n-                        if let Some(self_ty_fp) = TyFingerprint::for_impl(&self_ty.value) {\n-                            self.inherent_impls.entry(self_ty_fp).or_default().push(impl_id);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn merge(&mut self, other: &Self) {\n-        for (fp, impls) in &other.inherent_impls {\n-            let vec = self.inherent_impls.entry(*fp).or_default();\n-            vec.extend(impls);\n-        }\n-\n-        for (trait_, other_map) in &other.impls_by_trait {\n-            let map = self.impls_by_trait.entry(*trait_).or_default();\n+        for (trait_, other_map) in &other.map {\n+            let map = self.map.entry(*trait_).or_default();\n             for (fp, impls) in other_map {\n                 let vec = map.entry(*fp).or_default();\n                 vec.extend(impls);\n             }\n         }\n     }\n \n-    pub fn lookup_impl_defs(&self, ty: &Ty) -> impl Iterator<Item = ImplId> + '_ {\n-        let fingerprint = TyFingerprint::for_impl(ty);\n-        fingerprint.and_then(|f| self.inherent_impls.get(&f)).into_iter().flatten().copied()\n-    }\n-\n-    pub fn lookup_impl_defs_for_trait(&self, tr: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n-        self.impls_by_trait\n-            .get(&tr)\n+    /// Queries all impls of the given trait.\n+    pub fn for_trait(&self, trait_: TraitId) -> impl Iterator<Item = ImplId> + '_ {\n+        self.map\n+            .get(&trait_)\n             .into_iter()\n-            .flat_map(|m| m.values().flat_map(|v| v.iter().copied()))\n+            .flat_map(|map| map.values().flat_map(|v| v.iter().copied()))\n     }\n \n-    pub fn lookup_impl_defs_for_trait_and_ty(\n+    /// Queries all impls of `trait_` that may apply to `self_ty`.\n+    pub fn for_trait_and_self_ty(\n         &self,\n-        tr: TraitId,\n-        fp: TyFingerprint,\n+        trait_: TraitId,\n+        self_ty: TyFingerprint,\n     ) -> impl Iterator<Item = ImplId> + '_ {\n-        self.impls_by_trait\n-            .get(&tr)\n-            .and_then(|m| m.get(&Some(fp)))\n+        self.map\n+            .get(&trait_)\n             .into_iter()\n-            .flatten()\n-            .copied()\n-            .chain(\n-                self.impls_by_trait\n-                    .get(&tr)\n-                    .and_then(|m| m.get(&None))\n-                    .into_iter()\n-                    .flatten()\n-                    .copied(),\n-            )\n+            .flat_map(move |map| map.get(&None).into_iter().chain(map.get(&Some(self_ty))))\n+            .flat_map(|v| v.iter().copied())\n+    }\n+\n+    pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n+        self.map.values().flat_map(|map| map.values().flat_map(|v| v.iter().copied()))\n+    }\n+}\n+\n+/// Inherent impls defined in some crate.\n+///\n+/// Inherent impls can only be defined in the crate that also defines the self type of the impl\n+/// (note that some primitives are considered to be defined by both libcore and liballoc).\n+///\n+/// This makes inherent impl lookup easier than trait impl lookup since we only have to consider a\n+/// single crate.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct InherentImpls {\n+    map: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+}\n+\n+impl InherentImpls {\n+    pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n+        let mut map: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+        for (_module_id, module_data) in crate_def_map.modules.iter() {\n+            for impl_id in module_data.scope.impls() {\n+                let data = db.impl_data(impl_id);\n+                if data.target_trait.is_some() {\n+                    continue;\n+                }\n+\n+                let self_ty = db.impl_self_ty(impl_id);\n+                if let Some(fp) = TyFingerprint::for_impl(&self_ty.value) {\n+                    map.entry(fp).or_default().push(impl_id);\n+                }\n+            }\n+        }\n+\n+        Arc::new(Self { map })\n+    }\n+\n+    pub fn for_self_ty(&self, self_ty: &Ty) -> &[ImplId] {\n+        match TyFingerprint::for_impl(self_ty) {\n+            Some(fp) => self.map.get(&fp).map(|vec| vec.as_ref()).unwrap_or(&[]),\n+            None => &[],\n+        }\n     }\n \n-    pub fn all_impls<'a>(&'a self) -> impl Iterator<Item = ImplId> + 'a {\n-        self.inherent_impls\n-            .values()\n-            .chain(self.impls_by_trait.values().flat_map(|m| m.values()))\n-            .flatten()\n-            .copied()\n+    pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n+        self.map.values().flat_map(|v| v.iter().copied())\n     }\n }\n \n@@ -515,9 +519,9 @@ fn iterate_inherent_methods(\n         None => return false,\n     };\n     for krate in def_crates {\n-        let impls = db.impls_in_crate(krate);\n+        let impls = db.inherent_impls_in_crate(krate);\n \n-        for impl_def in impls.lookup_impl_defs(&self_ty.value) {\n+        for &impl_def in impls.for_self_ty(&self_ty.value) {\n             for &item in db.impl_data(impl_def).items.iter() {\n                 if !is_valid_candidate(db, name, receiver_ty, item, self_ty) {\n                     continue;"}, {"sha": "c97b81d57923676f4f245b420babe82767552517", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -77,8 +77,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // Note: Since we're using impls_for_trait, only impls where the trait\n         // can be resolved should ever reach Chalk. `impl_datum` relies on that\n         // and will panic if the trait can't be resolved.\n-        let in_deps = self.db.impls_from_deps(self.krate);\n-        let in_self = self.db.impls_in_crate(self.krate);\n+        let in_deps = self.db.trait_impls_in_deps(self.krate);\n+        let in_self = self.db.trait_impls_in_crate(self.krate);\n         let impl_maps = [in_deps, in_self];\n \n         let id_to_chalk = |id: hir_def::ImplId| Impl::ImplDef(id).to_chalk(self.db);\n@@ -87,14 +87,12 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             Some(fp) => impl_maps\n                 .iter()\n                 .flat_map(|crate_impl_defs| {\n-                    crate_impl_defs.lookup_impl_defs_for_trait_and_ty(trait_, fp).map(id_to_chalk)\n+                    crate_impl_defs.for_trait_and_self_ty(trait_, fp).map(id_to_chalk)\n                 })\n                 .collect(),\n             None => impl_maps\n                 .iter()\n-                .flat_map(|crate_impl_defs| {\n-                    crate_impl_defs.lookup_impl_defs_for_trait(trait_).map(id_to_chalk)\n-                })\n+                .flat_map(|crate_impl_defs| crate_impl_defs.for_trait(trait_).map(id_to_chalk))\n                 .collect(),\n         };\n "}, {"sha": "9acc960fc250fc44825b40ab05bcd6d78282c974", "filename": "crates/ra_ide/src/goto_implementation.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -219,6 +219,10 @@ impl T for &Foo {}\n   #[derive(Copy)]\n //^^^^^^^^^^^^^^^\n struct Foo<|>;\n+\n+mod marker {\n+    trait Copy {}\n+}\n \"#,\n         );\n     }"}, {"sha": "dbe6eacc5995611eee86acd1111779de493cf15f", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bde542a39fe63298a31b838e59705797ed8a2cf/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=6bde542a39fe63298a31b838e59705797ed8a2cf", "patch": "@@ -243,8 +243,9 @@ impl RootDatabase {\n             hir::db::GenericPredicatesForParamQuery\n             hir::db::GenericPredicatesQuery\n             hir::db::GenericDefaultsQuery\n-            hir::db::ImplsInCrateQuery\n-            hir::db::ImplsFromDepsQuery\n+            hir::db::InherentImplsInCrateQuery\n+            hir::db::TraitImplsInCrateQuery\n+            hir::db::TraitImplsInDepsQuery\n             hir::db::InternTypeCtorQuery\n             hir::db::InternTypeParamIdQuery\n             hir::db::InternChalkImplQuery"}]}