{"sha": "817dda7df0164669487568fbcd33acb4ef512bc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxN2RkYTdkZjAxNjQ2Njk0ODc1NjhmYmNkMzNhY2I0ZWY1MTJiYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T07:22:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T07:22:15Z"}, "message": "Auto merge of #56649 - davidtwco:issue-46589, r=pnkfelix\n\nMIR borrowck doesn't accept the example of iterating and updating a mutable reference\n\nFixes #46589.\n\nr? @pnkfelix or @nikomatsakis", "tree": {"sha": "26f02ea51e21bfc84ef024bb11ade19fc13a1799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26f02ea51e21bfc84ef024bb11ade19fc13a1799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/817dda7df0164669487568fbcd33acb4ef512bc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/817dda7df0164669487568fbcd33acb4ef512bc2", "html_url": "https://github.com/rust-lang/rust/commit/817dda7df0164669487568fbcd33acb4ef512bc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/817dda7df0164669487568fbcd33acb4ef512bc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42247f949fe2ce64d688f1585a2dbbc66720406", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42247f949fe2ce64d688f1585a2dbbc66720406", "html_url": "https://github.com/rust-lang/rust/commit/e42247f949fe2ce64d688f1585a2dbbc66720406"}, {"sha": "7b628e18a323505c175415013bcd854f38d0216e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b628e18a323505c175415013bcd854f38d0216e", "html_url": "https://github.com/rust-lang/rust/commit/7b628e18a323505c175415013bcd854f38d0216e"}], "stats": {"total": 484, "additions": 300, "deletions": 184}, "files": [{"sha": "8a58cb056807446cfa61fdfae0b3892722d22470", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -33,19 +33,19 @@ use std::rc::Rc;\n \n // (forced to be `pub` due to its use as an associated type below.)\n crate struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n-    pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n+    borrows: FlowAtLocation<'tcx, Borrows<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n \n     /// Polonius Output\n     pub polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n }\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     crate fn new(\n-        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n-        uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<'tcx, Borrows<'b, 'gcx, 'tcx>>,\n+        uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n         polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     ) -> Self {\n         Flows {"}, {"sha": "6a2b6165f60293baaba1b4350d3754b073aaec84", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -63,7 +63,7 @@ mod move_errors;\n mod mutability_errors;\n mod path_utils;\n crate mod place_ext;\n-mod places_conflict;\n+crate mod places_conflict;\n mod prefixes;\n mod used_muts;\n \n@@ -1369,7 +1369,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             place,\n             borrow.kind,\n             root_place,\n-            sd\n+            sd,\n+            places_conflict::PlaceConflictBias::Overlap,\n         ) {\n             debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n             // FIXME: should be talking about the region lifetime instead"}, {"sha": "1e3a27c8fe5b99ede0ace1899e9628e9237e2b28", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -85,7 +85,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n     errors_buffer: &mut Vec<Diagnostic>,"}, {"sha": "7b216d8e587ccd185d983fa3a72f01c02d6be59f", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -39,7 +39,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     location_table: &LocationTable,\n ) {"}, {"sha": "1fbde2ae59dee5fb794060a414f3b821b9a07985", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -46,7 +46,7 @@ pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     liveness_map: &NllLivenessMap,\n     location_table: &LocationTable,\n@@ -99,7 +99,7 @@ where\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n-    flow_inits: &'me mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n+    flow_inits: &'me mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n \n     /// Index indicating where each variable is assigned, used, or\n     /// dropped."}, {"sha": "9ae82b06766f27d9f701e1d06c53809fa923fc59", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -123,7 +123,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n ) -> MirTypeckResults<'tcx> {"}, {"sha": "5e17afc3d3cdc94dc1c299d83be2efc27e4a70dd", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -68,6 +68,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n             borrowed.kind,\n             place,\n             access,\n+            places_conflict::PlaceConflictBias::Overlap,\n         ) {\n             debug!(\n                 \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\","}, {"sha": "7ebd69c63abf57a6ef85bf1fe76b403d05936206", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -17,17 +17,55 @@ use rustc::mir::{Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n+/// When checking if a place conflicts with another place, this enum is used to influence decisions\n+/// where a place might be equal or disjoint with another place, such as if `a[i] == a[j]`.\n+/// `PlaceConflictBias::Overlap` would bias toward assuming that `i` might equal `j` and that these\n+/// places overlap. `PlaceConflictBias::NoOverlap` assumes that for the purposes of the predicate\n+/// being run in the calling context, the conservative choice is to assume the compared indices\n+/// are disjoint (and therefore, do not overlap).\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+crate enum PlaceConflictBias {\n+    Overlap,\n+    NoOverlap,\n+}\n+\n+/// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n+/// This is used to check for places conflicting outside of the borrow checking code (such as in\n+/// dataflow).\n+crate fn places_conflict<'gcx, 'tcx>(\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    borrow_place: &Place<'tcx>,\n+    access_place: &Place<'tcx>,\n+    bias: PlaceConflictBias,\n+) -> bool {\n+    borrow_conflicts_with_place(\n+        tcx,\n+        mir,\n+        borrow_place,\n+        BorrowKind::Mut { allow_two_phase_borrow: true },\n+        access_place,\n+        AccessDepth::Deep,\n+        bias,\n+    )\n+}\n+\n+/// Checks whether the `borrow_place` conflicts with the `access_place` given a borrow kind and\n+/// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n+/// array indices, for example) should be interpreted - this depends on what the caller wants in\n+/// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: &Place<'tcx>,\n     access: AccessDepth,\n+    bias: PlaceConflictBias,\n ) -> bool {\n     debug!(\n-        \"borrow_conflicts_with_place({:?},{:?},{:?})\",\n-        borrow_place, access_place, access\n+        \"borrow_conflicts_with_place({:?}, {:?}, {:?}, {:?})\",\n+        borrow_place, access_place, access, bias,\n     );\n \n     // This Local/Local case is handled by the more general code below, but\n@@ -46,7 +84,8 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n                 borrow_components,\n                 borrow_kind,\n                 access_components,\n-                access\n+                access,\n+                bias,\n             )\n         })\n     })\n@@ -59,6 +98,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n     borrow_kind: BorrowKind,\n     mut access_components: PlaceComponentsIter<'_, 'tcx>,\n     access: AccessDepth,\n+    bias: PlaceConflictBias,\n ) -> bool {\n     // The borrowck rules for proving disjointness are applied from the \"root\" of the\n     // borrow forwards, iterating over \"similar\" projections in lockstep until\n@@ -121,7 +161,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 // check whether the components being borrowed vs\n                 // accessed are disjoint (as in the second example,\n                 // but not the first).\n-                match place_element_conflict(tcx, mir, borrow_c, access_c) {\n+                match place_element_conflict(tcx, mir, borrow_c, access_c, bias) {\n                     Overlap::Arbitrary => {\n                         // We have encountered different fields of potentially\n                         // the same union - the borrow now partially overlaps.\n@@ -190,7 +230,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         bug!(\"Tracking borrow behind shared reference.\");\n                     }\n                     (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n-                        // Values behind a mutatble reference are not access either by Dropping a\n+                        // Values behind a mutable reference are not access either by dropping a\n                         // value, or by StorageDead\n                         debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n                         return false;\n@@ -328,6 +368,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     mir: &Mir<'tcx>,\n     elem1: &Place<'tcx>,\n     elem2: &Place<'tcx>,\n+    bias: PlaceConflictBias,\n ) -> Overlap {\n     match (elem1, elem2) {\n         (Place::Local(l1), Place::Local(l2)) => {\n@@ -445,10 +486,20 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n                 | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n                     // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n-                    // (if the indexes differ) or equal (if they are the same), so this\n-                    // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n-                    Overlap::EqualOrDisjoint\n+                    // (if the indexes differ) or equal (if they are the same).\n+                    match bias {\n+                        PlaceConflictBias::Overlap => {\n+                            // If we are biased towards overlapping, then this is the recursive\n+                            // case that gives \"equal *or* disjoint\" its meaning.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n+                            Overlap::EqualOrDisjoint\n+                        }\n+                        PlaceConflictBias::NoOverlap => {\n+                            // If we are biased towards no overlapping, then this is disjoint.\n+                            debug!(\"place_element_conflict: DISJOINT-ARRAY-INDEX\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n                 }\n                 (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n                     ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })"}, {"sha": "69f6fbb6c80774580a8bb253b72f680d2e371f6a", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -70,19 +70,19 @@ pub trait FlowsAtLocation {\n /// (e.g., via `reconstruct_statement_effect` and\n /// `reconstruct_terminator_effect`; don't forget to call\n /// `apply_local_effect`).\n-pub struct FlowAtLocation<BD>\n+pub struct FlowAtLocation<'tcx, BD>\n where\n-    BD: BitDenotation,\n+    BD: BitDenotation<'tcx>,\n {\n-    base_results: DataflowResults<BD>,\n+    base_results: DataflowResults<'tcx, BD>,\n     curr_state: BitSet<BD::Idx>,\n     stmt_gen: HybridBitSet<BD::Idx>,\n     stmt_kill: HybridBitSet<BD::Idx>,\n }\n \n-impl<BD> FlowAtLocation<BD>\n+impl<'tcx, BD> FlowAtLocation<'tcx, BD>\n where\n-    BD: BitDenotation,\n+    BD: BitDenotation<'tcx>,\n {\n     /// Iterate over each bit set in the current state.\n     pub fn each_state_bit<F>(&self, f: F)\n@@ -102,7 +102,7 @@ where\n         self.stmt_gen.iter().for_each(f)\n     }\n \n-    pub fn new(results: DataflowResults<BD>) -> Self {\n+    pub fn new(results: DataflowResults<'tcx, BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n         let curr_state = BitSet::new_empty(bits_per_block);\n         let stmt_gen = HybridBitSet::new_empty(bits_per_block);\n@@ -143,8 +143,8 @@ where\n     }\n }\n \n-impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n-    where BD: BitDenotation\n+impl<'tcx, BD> FlowsAtLocation for FlowAtLocation<'tcx, BD>\n+    where BD: BitDenotation<'tcx>\n {\n     fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n         self.curr_state.overwrite(self.base_results.sets().on_entry_set_for(bb.index()));\n@@ -213,9 +213,9 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n }\n \n \n-impl<'tcx, T> FlowAtLocation<T>\n+impl<'tcx, T> FlowAtLocation<'tcx, T>\n where\n-    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n+    T: HasMoveData<'tcx> + BitDenotation<'tcx, Idx = MovePathIndex>,\n {\n     pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n         // We process `mpi` before the loop below, for two reasons:"}, {"sha": "45d59b5fb9df12a2dc509e308d8a28744958b143", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -25,19 +25,19 @@ use super::DataflowBuilder;\n use super::DebugFormatted;\n \n pub trait MirWithFlowState<'tcx> {\n-    type BD: BitDenotation;\n+    type BD: BitDenotation<'tcx>;\n     fn node_id(&self) -> NodeId;\n     fn mir(&self) -> &Mir<'tcx>;\n-    fn flow_state(&self) -> &DataflowState<Self::BD>;\n+    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n }\n \n impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n-    where BD: BitDenotation\n+    where BD: BitDenotation<'tcx>\n {\n     type BD = BD;\n     fn node_id(&self) -> NodeId { self.node_id }\n     fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n-    fn flow_state(&self) -> &DataflowState<Self::BD> { &self.flow_state.flow_state }\n+    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> { &self.flow_state.flow_state }\n }\n \n struct Graph<'a, 'tcx, MWF:'a, P> where\n@@ -53,8 +53,8 @@ pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n     path: &Path,\n     render_idx: P)\n     -> io::Result<()>\n-    where BD: BitDenotation,\n-          P: Fn(&BD, BD::Idx) -> DebugFormatted\n+    where BD: BitDenotation<'tcx>,\n+          P: Fn(&BD, BD::Idx) -> DebugFormatted,\n {\n     let g = Graph { mbcx, phantom: PhantomData, render_idx };\n     let mut v = Vec::new();\n@@ -76,7 +76,7 @@ fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n \n impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     where MWF: MirWithFlowState<'tcx>,\n-          P: Fn(&MWF::BD, <MWF::BD as BitDenotation>::Idx) -> DebugFormatted,\n+          P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n {\n     type Node = Node;\n     type Edge = Edge;\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n \n impl<'a, 'tcx, MWF, P> Graph<'a, 'tcx, MWF, P>\n where MWF: MirWithFlowState<'tcx>,\n-      P: Fn(&MWF::BD, <MWF::BD as BitDenotation>::Idx) -> DebugFormatted,\n+      P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n {\n     /// Generate the node label\n     fn node_label_internal<W: io::Write>(&self,"}, {"sha": "374f7071ffac26ac4f53e7c66a04befd7b92aa30", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx: 'a> HaveBeenBorrowedLocals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     type Idx = Local;\n     fn name() -> &'static str { \"has_been_borrowed_locals\" }\n     fn bits_per_block(&self) -> usize {\n@@ -71,11 +71,13 @@ impl<'a, 'tcx> BitDenotation for HaveBeenBorrowedLocals<'a, 'tcx> {\n         }.visit_terminator(loc.block, self.mir[loc.block].terminator(), loc);\n     }\n \n-    fn propagate_call_return(&self,\n-                             _in_out: &mut BitSet<Local>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n         // Nothing to do when a call returns successfully\n     }\n }"}, {"sha": "f6732b0a0b0c9dd6821a13e91571d84c507b6871", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 58, "deletions": 38, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -11,7 +11,6 @@\n use borrow_check::borrow_set::{BorrowSet, BorrowData};\n use borrow_check::place_ext::PlaceExt;\n \n-use rustc;\n use rustc::mir::{self, Location, Place, Mir};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n@@ -24,6 +23,7 @@ use dataflow::{BitDenotation, BlockSets, InitialFlow};\n pub use dataflow::indexes::BorrowIndex;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::places_conflict;\n \n use std::rc::Rc;\n \n@@ -191,17 +191,55 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<BorrowIndex>,\n-                             local: &rustc::mir::Local)\n-    {\n-        if let Some(borrow_indexes) = self.borrow_set.local_map.get(local) {\n-            sets.kill_all(borrow_indexes);\n+    /// Kill any borrows that conflict with `place`.\n+    fn kill_borrows_on_place(\n+        &self,\n+        sets: &mut BlockSets<BorrowIndex>,\n+        place: &Place<'tcx>\n+    ) {\n+        debug!(\"kill_borrows_on_place: place={:?}\", place);\n+        // Handle the `Place::Local(..)` case first and exit early.\n+        if let Place::Local(local) = place {\n+            if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n+                debug!(\"kill_borrows_on_place: borrow_indices={:?}\", borrow_indices);\n+                sets.kill_all(borrow_indices);\n+                return;\n+            }\n+        }\n+\n+        // Otherwise, look at all borrows that are live and if they conflict with the assignment\n+        // into our place then we can kill them.\n+        let mut borrows = sets.on_entry.clone();\n+        let _ = borrows.union(sets.gen_set);\n+        for borrow_index in borrows.iter() {\n+            let borrow_data = &self.borrows()[borrow_index];\n+            debug!(\n+                \"kill_borrows_on_place: borrow_index={:?} borrow_data={:?}\",\n+                borrow_index, borrow_data,\n+            );\n+\n+            // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n+            // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+            // will be assured that two places being compared definitely denotes the same sets of\n+            // locations.\n+            if places_conflict::places_conflict(\n+                self.tcx,\n+                self.mir,\n+                place,\n+                &borrow_data.borrowed_place,\n+                places_conflict::PlaceConflictBias::NoOverlap,\n+            ) {\n+                debug!(\n+                    \"kill_borrows_on_place: (kill) borrow_index={:?} borrow_data={:?}\",\n+                    borrow_index, borrow_data,\n+                );\n+                sets.kill(borrow_index);\n+            }\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n     type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n@@ -222,7 +260,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn statement_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n-        debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+        debug!(\"Borrows::statement_effect: sets={:?} location={:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n@@ -231,20 +269,12 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n+        debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n         match stmt.kind {\n             mir::StatementKind::Assign(ref lhs, ref rhs) => {\n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                if let Place::Local(ref local) = *lhs {\n-                    // FIXME: Handle the case in which we're assigning over\n-                    // a projection (`foo.bar`).\n-                    self.kill_borrows_on_local(sets, local);\n-                }\n-\n-                // NOTE: if/when the Assign case is revised to inspect\n-                // the assigned_place here, make sure to also\n-                // re-consider the current implementations of the\n-                // propagate_call_return method.\n+                self.kill_borrows_on_place(sets, lhs);\n \n                 if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n@@ -279,19 +309,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_local(sets, &local)\n+                self.kill_borrows_on_place(sets, &Place::Local(local));\n             }\n \n             mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {\n                 for (output, kind) in outputs.iter().zip(&asm.outputs) {\n                     if !kind.is_indirect && !kind.is_rw {\n-                        // Make sure there are no remaining borrows for direct\n-                        // output variables.\n-                        if let Place::Local(ref local) = *output {\n-                            // FIXME: Handle the case in which we're assigning over\n-                            // a projection (`foo.bar`).\n-                            self.kill_borrows_on_local(sets, local);\n-                        }\n+                        self.kill_borrows_on_place(sets, output);\n                     }\n                 }\n             }\n@@ -316,16 +340,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n \n     fn terminator_effect(&self, _: &mut BlockSets<BorrowIndex>, _: Location) {}\n \n-    fn propagate_call_return(&self,\n-                             _in_out: &mut BitSet<BorrowIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n-        // there are no effects on borrows from method call return...\n-        //\n-        // ... but if overwriting a place can affect flow state, then\n-        // latter is not true; see NOTE on Assign case in\n-        // statement_effect_on_borrows.\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<BorrowIndex>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n     }\n }\n \n@@ -342,4 +363,3 @@ impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n         false // bottom = nothing is reserved or activated yet\n     }\n }\n-"}, {"sha": "99e1eab82690c825e5812012e4828a28f29209d5", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -331,11 +331,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n         )\n     }\n \n-    fn propagate_call_return(&self,\n-                             in_out: &mut BitSet<MovePathIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<MovePathIndex>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -344,7 +346,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -387,11 +389,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n         )\n     }\n \n-    fn propagate_call_return(&self,\n-                             in_out: &mut BitSet<MovePathIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<MovePathIndex>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -400,7 +404,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -441,11 +445,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n         )\n     }\n \n-    fn propagate_call_return(&self,\n-                             in_out: &mut BitSet<MovePathIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<MovePathIndex>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n         on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n@@ -454,7 +460,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tc\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -530,11 +536,13 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n         );\n     }\n \n-    fn propagate_call_return(&self,\n-                             in_out: &mut BitSet<InitIndex>,\n-                             call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<InitIndex>,\n+        call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n         let move_data = self.move_data();\n         let bits_per_block = self.bits_per_block();\n         let init_loc_map = &move_data.init_loc_map;"}, {"sha": "caf3d3f7ab6c8d15d4dfcb24e3ad5d888cdb9ab1", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx: 'a> MaybeStorageLive<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n+impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     type Idx = Local;\n     fn name() -> &'static str { \"maybe_storage_live\" }\n     fn bits_per_block(&self) -> usize {\n@@ -58,11 +58,13 @@ impl<'a, 'tcx> BitDenotation for MaybeStorageLive<'a, 'tcx> {\n         // Terminators have no effect\n     }\n \n-    fn propagate_call_return(&self,\n-                             _in_out: &mut BitSet<Local>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n         // Nothing to do when a call returns successfully\n     }\n }"}, {"sha": "efdf0c1efcb171e54fc6deeb8a1b4a9abf489d13", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -44,7 +44,9 @@ pub mod move_paths;\n \n pub(crate) use self::move_paths::indexes;\n \n-pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n+pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD>\n+where\n+    BD: BitDenotation<'tcx>\n {\n     node_id: ast::NodeId,\n     flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n@@ -71,7 +73,7 @@ impl fmt::Debug for DebugFormatted {\n     }\n }\n \n-pub(crate) trait Dataflow<BD: BitDenotation> {\n+pub(crate) trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n     /// Sets up and runs the dataflow problem, using `p` to render results if\n     /// implementation so chooses.\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n@@ -87,7 +89,9 @@ pub(crate) trait Dataflow<BD: BitDenotation> {\n     fn propagate(&mut self);\n }\n \n-impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n+impl<'a, 'tcx: 'a, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>\n {\n     fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> DebugFormatted {\n         self.flow_state.build_sets();\n@@ -127,21 +131,21 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                  dead_unwinds: &BitSet<BasicBlock>,\n                                                  bd: BD,\n                                                  p: P)\n-                                                 -> DataflowResults<BD>\n-    where BD: BitDenotation + InitialFlow,\n+                                                 -> DataflowResults<'tcx, BD>\n+    where BD: BitDenotation<'tcx> + InitialFlow,\n           P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n     let flow_state = DataflowAnalysis::new(mir, dead_unwinds, bd);\n     flow_state.run(tcx, node_id, attributes, p)\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     pub(crate) fn run<P>(self,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          node_id: ast::NodeId,\n                          attributes: &[ast::Attribute],\n-                         p: P) -> DataflowResults<BD>\n+                         p: P) -> DataflowResults<'tcx, BD>\n         where P: Fn(&BD, BD::Idx) -> DebugFormatted\n     {\n         let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n@@ -173,12 +177,12 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n     }\n }\n \n-struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n+struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation<'tcx>\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n+impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     fn propagate(&mut self) {\n         let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n@@ -228,7 +232,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n     }\n }\n \n-impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation\n+impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n         let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n@@ -259,7 +263,7 @@ fn dataflow_path(context: &str, path: &str) -> PathBuf {\n     path\n }\n \n-impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n+impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n {\n     fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n         where P: Fn(&BD, BD::Idx) -> DebugFormatted\n@@ -347,10 +351,10 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn mir(&self) -> &'a Mir<'tcx>;\n }\n \n-pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n-                                                  analysis: &T,\n-                                                  result: &DataflowResults<T>,\n-                                                  mir: &Mir<'tcx>)\n+pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n+                                                        analysis: &T,\n+                                                        result: &DataflowResults<'tcx, T>,\n+                                                        mir: &Mir<'tcx>)\n     -> BitSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n@@ -381,25 +385,25 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n     gen_set.to_dense()\n }\n \n-pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation\n+pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n {\n-    flow_state: DataflowState<O>,\n+    flow_state: DataflowState<'tcx, O>,\n     dead_unwinds: &'a BitSet<mir::BasicBlock>,\n     mir: &'a Mir<'tcx>,\n }\n \n-impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation\n+impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n {\n-    pub fn results(self) -> DataflowResults<O> {\n+    pub fn results(self) -> DataflowResults<'tcx, O> {\n         DataflowResults(self.flow_state)\n     }\n \n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n \n-pub struct DataflowResults<O>(pub(crate) DataflowState<O>) where O: BitDenotation;\n+pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>) where O: BitDenotation<'tcx>;\n \n-impl<O: BitDenotation> DataflowResults<O> {\n+impl<'tcx, O: BitDenotation<'tcx>> DataflowResults<'tcx, O> {\n     pub fn sets(&self) -> &AllSets<O::Idx> {\n         &self.0.sets\n     }\n@@ -411,7 +415,7 @@ impl<O: BitDenotation> DataflowResults<O> {\n \n /// State of a dataflow analysis; couples a collection of bit sets\n /// with operator used to initialize and merge bits during analysis.\n-pub struct DataflowState<O: BitDenotation>\n+pub struct DataflowState<'tcx, O: BitDenotation<'tcx>>\n {\n     /// All the sets for the analysis. (Factored into its\n     /// own structure so that we can borrow it mutably\n@@ -422,7 +426,7 @@ pub struct DataflowState<O: BitDenotation>\n     pub(crate) operator: O,\n }\n \n-impl<O: BitDenotation> DataflowState<O> {\n+impl<'tcx, O: BitDenotation<'tcx>> DataflowState<'tcx, O> {\n     pub(crate) fn interpret_set<'c, P>(&self,\n                                        o: &'c O,\n                                        set: &BitSet<O::Idx>,\n@@ -561,7 +565,7 @@ pub trait InitialFlow {\n     fn bottom_value() -> bool;\n }\n \n-pub trait BitDenotation: BitSetOperator {\n+pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n@@ -687,14 +691,16 @@ pub trait BitDenotation: BitSetOperator {\n     /// be better to represent this as an additional gen- and\n     /// kill-sets associated with each edge coming out of the basic\n     /// block.\n-    fn propagate_call_return(&self,\n-                             in_out: &mut BitSet<Self::Idx>,\n-                             call_bb: mir::BasicBlock,\n-                             dest_bb: mir::BasicBlock,\n-                             dest_place: &mir::Place);\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<Self::Idx>,\n+        call_bb: mir::BasicBlock,\n+        dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    );\n }\n \n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n+impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n {\n     pub fn new(mir: &'a Mir<'tcx>,\n                dead_unwinds: &'a BitSet<mir::BasicBlock>,\n@@ -726,8 +732,7 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     }\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n-{\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx> {\n     /// Propagates the bits of `in_out` into all the successors of `bb`,\n     /// using bitwise operator denoted by `self.operator`.\n     ///\n@@ -744,7 +749,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n     fn propagate_bits_into_graph_successors_of(\n         &mut self,\n         in_out: &mut BitSet<D::Idx>,\n-        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData),\n+        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData<'tcx>),\n         dirty_list: &mut WorkQueue<mir::BasicBlock>)\n     {\n         match bb_data.terminator().kind {"}, {"sha": "caae5c8553ea78651f0474984470a24a9e3085bc", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -303,8 +303,8 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n-    flow_uninits:  DataflowResults<MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_uninits:  DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "0507d0dfdfa813b22d3ecfecbc99dd2c4b4eb2f2", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -95,8 +95,8 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 mir: &Mir<'tcx>,\n                                                 id: ast::NodeId,\n                                                 _attributes: &[ast::Attribute],\n-                                                results: &DataflowResults<O>)\n-    where O: BitDenotation<Idx=MovePathIndex> + HasMoveData<'tcx>\n+                                                results: &DataflowResults<'tcx, O>)\n+    where O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n {\n     debug!(\"sanity_check_via_rustc_peek id: {:?}\", id);\n     // FIXME: this is not DRY. Figure out way to abstract this and\n@@ -110,9 +110,9 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &Mir<'tcx>,\n-                           results: &DataflowResults<O>,\n+                           results: &DataflowResults<'tcx, O>,\n                            bb: mir::BasicBlock) where\n-    O: BitDenotation<Idx=MovePathIndex> + HasMoveData<'tcx>\n+    O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n {\n     let move_data = results.0.operator.move_data();\n     let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = mir[bb];"}, {"sha": "82e73651f4310357f34c52ec959262a43fad2666", "filename": "src/test/ui/nll/issue-46589.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46589.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get_self(&mut self) -> Option<&mut Self> {\n+        Some(self)\n+    }\n+\n+    fn new_self(&mut self) -> &mut Self {\n+        self\n+    }\n+\n+    fn trigger_bug(&mut self) {\n+        let other = &mut (&mut *self);\n+\n+        *other = match (*other).get_self() {\n+            Some(s) => s,\n+            None => (*other).new_self()\n+            //~^ ERROR cannot borrow `**other` as mutable more than once at a time [E0499]\n+        };\n+\n+        let c = other;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6df2983f4652ee59f7e8384505f0d13d0c5b9c27", "filename": "src/test/ui/nll/issue-46589.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46589.stderr?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -0,0 +1,15 @@\n+error[E0499]: cannot borrow `**other` as mutable more than once at a time\n+  --> $DIR/issue-46589.rs:29:21\n+   |\n+LL |         *other = match (*other).get_self() {\n+   |                        -------- first mutable borrow occurs here\n+LL |             Some(s) => s,\n+LL |             None => (*other).new_self()\n+   |                     ^^^^^^^^\n+   |                     |\n+   |                     second mutable borrow occurs here\n+   |                     first borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "320d80438b06781a69cb9c1ca18a2adedbf8bdaa", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -27,10 +27,8 @@ fn nll_fail() {\n     //~| ERROR (Mir) [E0506]\n     data.0 = 'f';\n     //~^ ERROR (Ast) [E0506]\n-    //~| ERROR (Mir) [E0506]\n     data.0 = 'g';\n     //~^ ERROR (Ast) [E0506]\n-    //~| ERROR (Mir) [E0506]\n     capitalize(c);\n }\n "}, {"sha": "3ba3fa15a5387672c06010f3ef6fbb6ca71e6668", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.stderr", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/817dda7df0164669487568fbcd33acb4ef512bc2/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr?ref=817dda7df0164669487568fbcd33acb4ef512bc2", "patch": "@@ -17,7 +17,7 @@ LL |     data.0 = 'f';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:31:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:30:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -26,7 +26,7 @@ LL |     data.0 = 'g';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:41:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:39:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -35,7 +35,7 @@ LL |     data.0 = 'e';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:43:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:41:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -44,7 +44,7 @@ LL |     data.0 = 'f';\n    |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n \n error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:45:5\n+  --> $DIR/loan_ends_mid_block_pair.rs:43:5\n    |\n LL |     let c = &mut data.0;\n    |                  ------ borrow of `data.0` occurs here\n@@ -64,30 +64,6 @@ LL |     data.0 = 'e';\n LL |     capitalize(c);\n    |                - borrow later used here\n \n-error[E0506]: cannot assign to `data.0` because it is borrowed (Mir)\n-  --> $DIR/loan_ends_mid_block_pair.rs:28:5\n-   |\n-LL |     let c = &mut data.0;\n-   |             ----------- borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'f';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-...\n-LL |     capitalize(c);\n-   |                - borrow later used here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Mir)\n-  --> $DIR/loan_ends_mid_block_pair.rs:31:5\n-   |\n-LL |     let c = &mut data.0;\n-   |             ----------- borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'g';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-...\n-LL |     capitalize(c);\n-   |                - borrow later used here\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0506`."}]}