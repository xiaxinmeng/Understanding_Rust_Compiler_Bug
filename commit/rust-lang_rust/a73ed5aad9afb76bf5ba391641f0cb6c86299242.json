{"sha": "a73ed5aad9afb76bf5ba391641f0cb6c86299242", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3M2VkNWFhZDlhZmI3NmJmNWJhMzkxNjQxZjBjYjZjODYyOTkyNDI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-23T23:49:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T23:49:39Z"}, "message": "Rollup merge of #69981 - oli-obk:const_blocks, r=eddyb\n\nEvaluate repeat expression lengths as late as possible\n\nFixes #68567\n\nr? @varkor", "tree": {"sha": "0f476a4e04c898a692b7742084fa80660a05fd7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f476a4e04c898a692b7742084fa80660a05fd7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a73ed5aad9afb76bf5ba391641f0cb6c86299242", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeUsUCRBK7hj4Ov3rIwAAdHIIAFc9agF7DIUCxFBzfJbL2ZNF\nvs9TLbZzWzwFjS5y/mRHUHe5tjD3ieQ+VKMb5OPo4wRkwnvziyuzJHMx36Sq5V0/\nI0AWpqJg/7z3CHJ14zrUKjkjd1IW8r9FgR3/4Ye4VSfxj7dLCx9Bces3jpbUhpbZ\nBMAJDLaGXodJx4fO1acJGmvAzbl2boSA+wBmvY3WBTx5vU5j56Of9b5NiLfHKINT\nfyHOcntiX1n2g3Kk2D8VwqCbILwI1P/ikX52UhVi2w2Dvk3c53VoWmWFw/9o1DrG\nP0aAwwRbjoMxnrW4j5ouknJpS021igesJjkc6NmYSC5Nv32kLXwxl8aisP2jWwM=\n=Im9e\n-----END PGP SIGNATURE-----\n", "payload": "tree 0f476a4e04c898a692b7742084fa80660a05fd7a\nparent ee9094869c85d336f67de8f328e34944f06f1ebe\nparent 9b1893f310d185478a0980a7367d5fbc9affcbcc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585007379 +0100\ncommitter GitHub <noreply@github.com> 1585007379 +0100\n\nRollup merge of #69981 - oli-obk:const_blocks, r=eddyb\n\nEvaluate repeat expression lengths as late as possible\n\nFixes #68567\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a73ed5aad9afb76bf5ba391641f0cb6c86299242", "html_url": "https://github.com/rust-lang/rust/commit/a73ed5aad9afb76bf5ba391641f0cb6c86299242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a73ed5aad9afb76bf5ba391641f0cb6c86299242/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee9094869c85d336f67de8f328e34944f06f1ebe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9094869c85d336f67de8f328e34944f06f1ebe", "html_url": "https://github.com/rust-lang/rust/commit/ee9094869c85d336f67de8f328e34944f06f1ebe"}, {"sha": "9b1893f310d185478a0980a7367d5fbc9affcbcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1893f310d185478a0980a7367d5fbc9affcbcc", "html_url": "https://github.com/rust-lang/rust/commit/9b1893f310d185478a0980a7367d5fbc9affcbcc"}], "stats": {"total": 1222, "additions": 629, "deletions": 593}, "files": [{"sha": "827526ff4bac1d790887e29389425925c492055d", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -156,7 +156,7 @@ pub struct LitToConstInput<'tcx> {\n pub enum LitToConstError {\n     /// The literal's inferred type did not match the expected `ty` in the input.\n     /// This is used for graceful error handling (`delay_span_bug`) in\n-    /// type checking (`AstConv::ast_const_to_const`).\n+    /// type checking (`Const::from_anon_const`).\n     TypeError,\n     UnparseableFloat,\n     Reported,"}, {"sha": "1e47317cf1ace3580021a808a23286682f21185c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 332, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -45,6 +45,7 @@ pub mod mono;\n mod query;\n pub mod tcx;\n pub mod traversal;\n+mod type_foldable;\n pub mod visit;\n \n /// Types for locals\n@@ -2046,7 +2047,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, u64),\n+    Repeat(Operand<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n@@ -2174,7 +2175,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n         match *self {\n             Use(ref place) => write!(fmt, \"{:?}\", place),\n-            Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n+            Repeat(ref a, ref b) => {\n+                write!(fmt, \"[{:?}; \", a)?;\n+                pretty_print_const(b, fmt, false)?;\n+                write!(fmt, \"]\")\n+            }\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n             Cast(ref kind, ref place, ref ty) => {\n                 write!(fmt, \"{:?} as {:?} ({:?})\", place, ty, kind)\n@@ -2542,18 +2547,26 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use crate::ty::print::PrettyPrinter;\n         write!(fmt, \"const \")?;\n-        ty::tls::with(|tcx| {\n-            let literal = tcx.lift(&self.literal).unwrap();\n-            let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n-            cx.print_alloc_ids = true;\n-            cx.pretty_print_const(literal, true)?;\n-            Ok(())\n-        })\n+        pretty_print_const(self.literal, fmt, true)\n     }\n }\n \n+fn pretty_print_const(\n+    c: &ty::Const<'tcx>,\n+    fmt: &mut Formatter<'_>,\n+    print_types: bool,\n+) -> fmt::Result {\n+    use crate::ty::print::PrettyPrinter;\n+    ty::tls::with(|tcx| {\n+        let literal = tcx.lift(&c).unwrap();\n+        let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n+        cx.print_alloc_ids = true;\n+        cx.pretty_print_const(literal, print_types)?;\n+        Ok(())\n+    })\n+}\n+\n impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n     type Node = BasicBlock;\n }\n@@ -2651,325 +2664,3 @@ impl Location {\n         }\n     }\n }\n-\n-/*\n- * `TypeFoldable` implementations for MIR types\n-*/\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    BlockTailInfo,\n-    MirPhase,\n-    SourceInfo,\n-    FakeReadCause,\n-    RetagKind,\n-    SourceScope,\n-    SourceScopeData,\n-    SourceScopeLocalData,\n-    UserTypeAnnotationIndex,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::TerminatorKind::*;\n-\n-        let kind = match self.kind {\n-            Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n-                discr: discr.fold_with(folder),\n-                switch_ty: switch_ty.fold_with(folder),\n-                values: values.clone(),\n-                targets: targets.clone(),\n-            },\n-            Drop { ref location, target, unwind } => {\n-                Drop { location: location.fold_with(folder), target, unwind }\n-            }\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n-                location: location.fold_with(folder),\n-                value: value.fold_with(folder),\n-                target,\n-                unwind,\n-            },\n-            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n-                value: value.fold_with(folder),\n-                resume,\n-                resume_arg: resume_arg.fold_with(folder),\n-                drop,\n-            },\n-            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n-                let dest =\n-                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n-\n-                Call {\n-                    func: func.fold_with(folder),\n-                    args: args.fold_with(folder),\n-                    destination: dest,\n-                    cleanup,\n-                    from_hir_call,\n-                }\n-            }\n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use AssertKind::*;\n-                let msg = match msg {\n-                    BoundsCheck { ref len, ref index } => {\n-                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n-                    }\n-                    Overflow(_)\n-                    | OverflowNeg\n-                    | DivisionByZero\n-                    | RemainderByZero\n-                    | ResumedAfterReturn(_)\n-                    | ResumedAfterPanic(_) => msg.clone(),\n-                };\n-                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n-            }\n-            GeneratorDrop => GeneratorDrop,\n-            Resume => Resume,\n-            Abort => Abort,\n-            Return => Return,\n-            Unreachable => Unreachable,\n-            FalseEdges { real_target, imaginary_target } => {\n-                FalseEdges { real_target, imaginary_target }\n-            }\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-        };\n-        Terminator { source_info: self.source_info, kind }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::TerminatorKind::*;\n-\n-        match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n-            }\n-            Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, .. } => {\n-                location.visit_with(visitor) || value.visit_with(visitor)\n-            }\n-            Yield { ref value, .. } => value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n-                let dest = if let Some((ref loc, _)) = *destination {\n-                    loc.visit_with(visitor)\n-                } else {\n-                    false\n-                };\n-                dest || func.visit_with(visitor) || args.visit_with(visitor)\n-            }\n-            Assert { ref cond, ref msg, .. } => {\n-                if cond.visit_with(visitor) {\n-                    use AssertKind::*;\n-                    match msg {\n-                        BoundsCheck { ref len, ref index } => {\n-                            len.visit_with(visitor) || index.visit_with(visitor)\n-                        }\n-                        Overflow(_)\n-                        | OverflowNeg\n-                        | DivisionByZero\n-                        | RemainderByZero\n-                        | ResumedAfterReturn(_)\n-                        | ResumedAfterPanic(_) => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-            Goto { .. }\n-            | Resume\n-            | Abort\n-            | Return\n-            | GeneratorDrop\n-            | Unreachable\n-            | FalseEdges { .. }\n-            | FalseUnwind { .. } => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n-        folder.tcx().intern_place_elems(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n-            Ref(region, bk, ref place) => {\n-                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n-            }\n-            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(ref place) => Len(place.fold_with(folder)),\n-            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n-            BinaryOp(op, ref rhs, ref lhs) => {\n-                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n-                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n-            Aggregate(ref kind, ref fields) => {\n-                let kind = box match **kind {\n-                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n-                    AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                        def,\n-                        v,\n-                        substs.fold_with(folder),\n-                        user_ty.fold_with(folder),\n-                        n,\n-                    ),\n-                    AggregateKind::Closure(id, substs) => {\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n-                    }\n-                    AggregateKind::Generator(id, substs, movablity) => {\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n-                    }\n-                };\n-                Aggregate(kind, fields.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => op.visit_with(visitor),\n-            Repeat(ref op, _) => op.visit_with(visitor),\n-            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n-            AddressOf(_, ref place) => place.visit_with(visitor),\n-            Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n-            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n-                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n-            }\n-            UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref place) => place.visit_with(visitor),\n-            NullaryOp(_, ty) => ty.visit_with(visitor),\n-            Aggregate(ref kind, ref fields) => {\n-                (match **kind {\n-                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n-                    AggregateKind::Tuple => false,\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n-                    }\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n-                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n-                }) || fields.visit_with(visitor)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match *self {\n-            Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n-            Index(v) => Index(v.fold_with(folder)),\n-            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n-            ConstantIndex { offset, min_length, from_end } => {\n-                ConstantIndex { offset, min_length, from_end }\n-            }\n-            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        }\n-    }\n-\n-    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match self {\n-            Field(_, ty) => ty.visit_with(visitor),\n-            Index(v) => v.visit_with(visitor),\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        self.clone()\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Constant {\n-            span: self.span,\n-            user_ty: self.user_ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder),\n-        }\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.literal.visit_with(visitor)\n-    }\n-}"}, {"sha": "feb663192671254004096cff7d5212f5099d80e8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -149,7 +149,9 @@ impl<'tcx> Rvalue<'tcx> {\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Repeat(ref operand, count) => tcx.mk_array(operand.ty(local_decls, tcx), count),\n+            Rvalue::Repeat(ref operand, count) => {\n+                tcx.mk_ty(ty::Array(operand.ty(local_decls, tcx), count))\n+            }\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg, ty::TypeAndMut { ty: place_ty, mutbl: bk.to_mutbl_lossy() })"}, {"sha": "9520f081b6bfbb28bc40f4e99428c3ab09ab21d7", "filename": "src/librustc/mir/type_foldable.rs", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftype_foldable.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -0,0 +1,322 @@\n+//! `TypeFoldable` implementations for MIR types\n+\n+use super::*;\n+use crate::ty;\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    BlockTailInfo,\n+    MirPhase,\n+    SourceInfo,\n+    FakeReadCause,\n+    RetagKind,\n+    SourceScope,\n+    SourceScopeData,\n+    SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::TerminatorKind::*;\n+\n+        let kind = match self.kind {\n+            Goto { target } => Goto { target },\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+                discr: discr.fold_with(folder),\n+                switch_ty: switch_ty.fold_with(folder),\n+                values: values.clone(),\n+                targets: targets.clone(),\n+            },\n+            Drop { ref location, target, unwind } => {\n+                Drop { location: location.fold_with(folder), target, unwind }\n+            }\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n+                location: location.fold_with(folder),\n+                value: value.fold_with(folder),\n+                target,\n+                unwind,\n+            },\n+            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n+                value: value.fold_with(folder),\n+                resume,\n+                resume_arg: resume_arg.fold_with(folder),\n+                drop,\n+            },\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+                let dest =\n+                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+\n+                Call {\n+                    func: func.fold_with(folder),\n+                    args: args.fold_with(folder),\n+                    destination: dest,\n+                    cleanup,\n+                    from_hir_call,\n+                }\n+            }\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                use AssertKind::*;\n+                let msg = match msg {\n+                    BoundsCheck { ref len, ref index } => {\n+                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n+                    }\n+                    Overflow(_)\n+                    | OverflowNeg\n+                    | DivisionByZero\n+                    | RemainderByZero\n+                    | ResumedAfterReturn(_)\n+                    | ResumedAfterPanic(_) => msg.clone(),\n+                };\n+                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n+            }\n+            GeneratorDrop => GeneratorDrop,\n+            Resume => Resume,\n+            Abort => Abort,\n+            Return => Return,\n+            Unreachable => Unreachable,\n+            FalseEdges { real_target, imaginary_target } => {\n+                FalseEdges { real_target, imaginary_target }\n+            }\n+            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n+        };\n+        Terminator { source_info: self.source_info, kind }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::TerminatorKind::*;\n+\n+        match self.kind {\n+            SwitchInt { ref discr, switch_ty, .. } => {\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+            }\n+            Drop { ref location, .. } => location.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, .. } => {\n+                location.visit_with(visitor) || value.visit_with(visitor)\n+            }\n+            Yield { ref value, .. } => value.visit_with(visitor),\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let dest = if let Some((ref loc, _)) = *destination {\n+                    loc.visit_with(visitor)\n+                } else {\n+                    false\n+                };\n+                dest || func.visit_with(visitor) || args.visit_with(visitor)\n+            }\n+            Assert { ref cond, ref msg, .. } => {\n+                if cond.visit_with(visitor) {\n+                    use AssertKind::*;\n+                    match msg {\n+                        BoundsCheck { ref len, ref index } => {\n+                            len.visit_with(visitor) || index.visit_with(visitor)\n+                        }\n+                        Overflow(_)\n+                        | OverflowNeg\n+                        | DivisionByZero\n+                        | RemainderByZero\n+                        | ResumedAfterReturn(_)\n+                        | ResumedAfterPanic(_) => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            Goto { .. }\n+            | Resume\n+            | Abort\n+            | Return\n+            | GeneratorDrop\n+            | Unreachable\n+            | FalseEdges { .. }\n+            | FalseUnwind { .. } => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n+        folder.tcx().intern_place_elems(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => Use(op.fold_with(folder)),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Ref(region, bk, ref place) => {\n+                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n+            }\n+            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n+            Len(ref place) => Len(place.fold_with(folder)),\n+            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+            BinaryOp(op, ref rhs, ref lhs) => {\n+                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n+                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n+            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n+            Aggregate(ref kind, ref fields) => {\n+                let kind = box match **kind {\n+                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n+                    AggregateKind::Tuple => AggregateKind::Tuple,\n+                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                        def,\n+                        v,\n+                        substs.fold_with(folder),\n+                        user_ty.fold_with(folder),\n+                        n,\n+                    ),\n+                    AggregateKind::Closure(id, substs) => {\n+                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                    }\n+                    AggregateKind::Generator(id, substs, movablity) => {\n+                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n+                    }\n+                };\n+                Aggregate(kind, fields.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => op.visit_with(visitor),\n+            Repeat(ref op, _) => op.visit_with(visitor),\n+            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            AddressOf(_, ref place) => place.visit_with(visitor),\n+            Len(ref place) => place.visit_with(visitor),\n+            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n+            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n+                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n+            }\n+            UnaryOp(_, ref val) => val.visit_with(visitor),\n+            Discriminant(ref place) => place.visit_with(visitor),\n+            NullaryOp(_, ty) => ty.visit_with(visitor),\n+            Aggregate(ref kind, ref fields) => {\n+                (match **kind {\n+                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n+                    AggregateKind::Tuple => false,\n+                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n+                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n+                    }\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n+                }) || fields.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n+            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n+            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n+            Operand::Constant(ref c) => c.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match *self {\n+            Deref => Deref,\n+            Field(f, ty) => Field(f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n+            ConstantIndex { offset, min_length, from_end } => {\n+                ConstantIndex { offset, min_length, from_end }\n+            }\n+            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n+        }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Field {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        self.clone()\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Constant {\n+            span: self.span,\n+            user_ty: self.user_ty.fold_with(folder),\n+            literal: self.literal.fold_with(folder),\n+        }\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.literal.visit_with(visitor)\n+    }\n+}"}, {"sha": "10c5431e2fc1e99eca86caf4b3a41f783c07f524", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -8,7 +8,7 @@ use self::TyKind::*;\n use crate::infer::canonical::Canonical;\n use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::Scalar;\n+use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n@@ -20,7 +20,7 @@ use polonius_engine::Atom;\n use rustc_ast::ast::{self, Ident};\n use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Symbol};\n@@ -2275,17 +2275,92 @@ pub struct Const<'tcx> {\n static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n+    /// Literals and const generic parameters are eagerly converted to a constant, everything else\n+    /// becomes `Unevaluated`.\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n+        debug!(\"Const::from_anon_const(id={:?})\", def_id);\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_anon_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+\n+        let ty = tcx.type_of(def_id.to_def_id());\n+\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(lit_input) = lit_input {\n+            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n+            // mir.\n+            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n+                return c;\n+            } else {\n+                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n+            }\n+        }\n+\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n+        let val = match expr.kind {\n+            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n+                // Find the name and index of the const parameter by indexing the generics of\n+                // the parent item and construct a `ParamConst`.\n+                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n+                let generics = tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n+                let name = tcx.hir().name(hir_id);\n+                ty::ConstKind::Param(ty::ParamConst::new(index, name))\n+            }\n+            _ => ty::ConstKind::Unevaluated(\n+                def_id.to_def_id(),\n+                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                None,\n+            ),\n+        };\n+\n+        tcx.mk_const(ty::Const { val, ty })\n+    }\n+\n     #[inline]\n+    /// Interns the given value as a constant.\n     pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n     }\n \n     #[inline]\n+    /// Interns the given scalar as a constant.\n     pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n+    /// Creates a constant with the given integer value and interns it.\n     pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n         let size = tcx\n             .layout_of(ty)\n@@ -2295,21 +2370,27 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]\n+    /// Creates an interned bool constant.\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n+    /// Creates an interned usize constant.\n     pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n+    /// Attempts to evaluate the given constant to bits. Can fail to evaluate in the presence of\n+    /// generics (or erroneous code) or if the value can't be represented as bits (e.g. because it\n+    /// contains const generic parameters or pointers).\n     pub fn try_eval_bits(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -2323,6 +2404,8 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n+    /// unevaluated constant.\n     pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n         let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs, promoted| {\n             let param_env_and_substs = param_env.with_reveal_all().and(substs);\n@@ -2379,12 +2462,14 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n         self.try_eval_bits(tcx, param_env, ty)\n             .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n     }\n \n     #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid `usize`.\n     pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n         self.eval_bits(tcx, param_env, tcx.types.usize) as u64\n     }"}, {"sha": "880bce7fde48787bae133261cedd815c411cfbc0", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -106,6 +106,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n \n+                let count =\n+                    self.monomorphize(&count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n+\n                 bx.write_operand_repeatedly(cg_elem, count, dest)\n             }\n "}, {"sha": "f94160cc08a19ee4027a020cedb87e632952184a", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1986,7 +1986,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Repeat(operand, len) => {\n-                if *len > 1 {\n+                // If the length cannot be evaluated we must assume that the length can be larger\n+                // than 1.\n+                // If the length is larger than 1, the repeat expression will need to copy the\n+                // element, so we require the `Copy` trait.\n+                if len.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n                     if let Operand::Move(_) = operand {\n                         // While this is located in `nll::typeck` this error is not an NLL error, it's\n                         // a required check to make sure that repeated elements implement `Copy`."}, {"sha": "9f93b817e38d8a555d69b6cb07ed08c62c421abc", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -3,7 +3,7 @@ use crate::hair::cx::to_ref::ToRef;\n use crate::hair::cx::Cx;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::*;\n-use rustc::mir::interpret::{ErrorHandled, Scalar};\n+use rustc::mir::interpret::Scalar;\n use rustc::mir::BorrowKind;\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -406,34 +406,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n-            let span = cx.tcx.def_span(def_id);\n-            let count = match cx.tcx.const_eval_resolve(\n-                ty::ParamEnv::reveal_all(),\n-                def_id,\n-                substs,\n-                None,\n-                Some(span),\n-            ) {\n-                Ok(cv) => {\n-                    if let Some(count) = cv.try_to_bits_for_ty(\n-                        cx.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        cx.tcx.types.usize,\n-                    ) {\n-                        count as u64\n-                    } else {\n-                        bug!(\"repeat count constant value can't be converted to usize\");\n-                    }\n-                }\n-                Err(ErrorHandled::Reported) => 0,\n-                Err(ErrorHandled::TooGeneric) => {\n-                    let span = cx.tcx.def_span(def_id);\n-                    cx.tcx.sess.span_err(span, \"array lengths can't depend on generic parameters\");\n-                    0\n-                }\n-            };\n+            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id).expect_local();\n+            let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n         }"}, {"sha": "77042240acf32fde0a82136cdf6c2a2f1c937abb", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -229,7 +229,7 @@ crate enum ExprKind<'tcx> {\n     },\n     Repeat {\n         value: ExprRef<'tcx>,\n-        count: u64,\n+        count: &'tcx Const<'tcx>,\n     },\n     Array {\n         fields: Vec<ExprRef<'tcx>>,"}, {"sha": "46db43a650fb9decd7d7b482e078920eda522285", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -22,7 +22,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::print;\n-use rustc_hir::{Constness, ExprKind, GenericArg, GenericArgs};\n+use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -39,8 +39,6 @@ use std::collections::BTreeSet;\n use std::iter;\n use std::slice;\n \n-use rustc::mir::interpret::LitToConstInput;\n-\n #[derive(Debug)]\n pub struct PathSeg(pub DefId, pub usize);\n \n@@ -782,7 +780,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.ast_const_to_const(&ct.value, tcx.type_of(param.def_id)).into()\n+                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id).expect_local();\n+                    ty::Const::from_anon_const(tcx, ct_def_id).into()\n                 }\n                 _ => unreachable!(),\n             },\n@@ -2775,7 +2774,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length = self.ast_const_to_const(length, tcx.types.usize);\n+                let length_def_id = tcx.hir().local_def_id(length.hir_id).expect_local();\n+                let length = ty::Const::from_anon_const(tcx, length_def_id);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n@@ -2807,75 +2807,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         result_ty\n     }\n \n-    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, expr: &hir::Expr<'_>) -> Option<DefId> {\n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n-        match &expr.kind {\n-            ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n-                Res::Def(DefKind::ConstParam, did) => Some(did),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn ast_const_to_const(\n-        &self,\n-        ast_const: &hir::AnonConst,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.hir_id, ast_const);\n-\n-        let tcx = self.tcx();\n-        let def_id = tcx.hir().local_def_id(ast_const.hir_id);\n-\n-        let expr = &tcx.hir().body(ast_const.body).value;\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n-                return c;\n-            } else {\n-                tcx.sess.delay_span_bug(expr.span, \"ast_const_to_const: couldn't lit_to_const\");\n-            }\n-        }\n-\n-        let kind = if let Some(def_id) = self.const_param_def_id(expr) {\n-            // Find the name and index of the const parameter by indexing the generics of the\n-            // parent item and construct a `ParamConst`.\n-            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            let item_id = tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = tcx.hir().local_def_id(item_id);\n-            let generics = tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n-            let name = tcx.hir().name(hir_id);\n-            ty::ConstKind::Param(ty::ParamConst::new(index, name))\n-        } else {\n-            ty::ConstKind::Unevaluated(def_id, InternalSubsts::identity_for_item(tcx, def_id), None)\n-        };\n-        tcx.mk_const(ty::Const { val: kind, ty })\n-    }\n-\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,"}, {"sha": "dffed9a836c216a5c5bcbbbd764ad57f7a66fb5d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -18,7 +18,6 @@ use crate::type_error_struct;\n use crate::util::common::ErrorReported;\n \n use rustc::middle::lang_items;\n-use rustc::mir::interpret::ErrorHandled;\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::Ty;\n@@ -1008,13 +1007,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         _expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let count_def_id = tcx.hir().local_def_id(count.hir_id);\n-        let count = if self.const_param_def_id(count).is_some() {\n-            Ok(self.to_const(count, tcx.type_of(count_def_id)))\n-        } else {\n-            tcx.const_eval_poly(count_def_id)\n-                .map(|val| ty::Const::from_value(tcx, val, tcx.type_of(count_def_id)))\n-        };\n+        let count = self.to_const(count);\n \n         let uty = match expected {\n             ExpectHasType(uty) => match uty.kind {\n@@ -1042,17 +1035,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if element_ty.references_error() {\n             return tcx.types.err;\n         }\n-        match count {\n-            Ok(count) => tcx.mk_ty(ty::Array(t, count)),\n-            Err(ErrorHandled::TooGeneric) => {\n-                self.tcx.sess.span_err(\n-                    tcx.def_span(count_def_id),\n-                    \"array lengths can't depend on generic parameters\",\n-                );\n-                tcx.types.err\n-            }\n-            Err(ErrorHandled::Reported) => tcx.types.err,\n-        }\n+\n+        tcx.mk_ty(ty::Array(t, count))\n     }\n \n     fn check_expr_tuple("}, {"sha": "d340d6ff5c27174576aa5eaa771c76b983b7da45", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 }\n                 (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => self.to_ty(ty).into(),\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                    self.to_const(&ct.value).into()\n                 }\n                 _ => unreachable!(),\n             },"}, {"sha": "2786e9087ea4ceeddbd9bd443f0c8d6da8361f70", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -3279,13 +3279,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, hir_c: &hir::AnonConst) -> Option<DefId> {\n-        AstConv::const_param_def_id(self, &self.tcx.hir().body(hir_c.body).value)\n-    }\n-\n-    pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        AstConv::ast_const_to_const(self, ast_c, ty)\n+    pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n+        let c = self.tcx.hir().local_def_id(ast_c.hir_id).expect_local();\n+        ty::Const::from_anon_const(self.tcx, c)\n     }\n \n     // If the type given by the user has free regions, save it for later, since\n@@ -5512,7 +5508,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.to_ty(ty).into()\n                     }\n                     (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                        self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                        self.to_const(&ct.value).into()\n                     }\n                     _ => unreachable!(),\n                 },"}, {"sha": "3a022230b39a782c3eff49a0844b8b47324ce2f5", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -7,10 +7,5 @@ fn main() {\n     //~^ ERROR `while` is not allowed in a `const`\n     //~| WARN denote infinite loops with\n     [(); { for _ in 0usize.. {}; 0}];\n-    //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR calls in constants are limited to constant functions\n-    //~| ERROR `for` is not allowed in a `const`\n-    //~| ERROR references in constants may only refer to immutable values\n-    //~| ERROR evaluation of constant value failed\n-    //~| ERROR constant contains unimplemented expression type\n+    //~^ ERROR `for` is not allowed in a `const`\n }"}, {"sha": "634638e1335b327576797cf90a7a99f672d203f6", "filename": "src/test/ui/closures/issue-52437.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     //~^ ERROR: invalid label name `'static`\n     //~| ERROR: `loop` is not allowed in a `const`\n     //~| ERROR: type annotations needed\n+    //~| ERROR mismatched types\n }"}, {"sha": "acb59c7b02d1b584c0da3fa2acfed9e95913c3ea", "filename": "src/test/ui/closures/issue-52437.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -19,7 +19,15 @@ error[E0282]: type annotations needed\n LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n    |                              ^ consider giving this closure parameter a type\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52437.rs:2:5\n+   |\n+LL | fn main() {\n+   |           - expected `()` because of default return type\n+LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found array `[(); _]`\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0282, E0658.\n+Some errors have detailed explanations: E0282, E0308, E0658.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "165d3e1c2e60169af4f1b669ae0c63a6646005f4", "filename": "src/test/ui/const-generics/issues/issue-61336-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,9 +1,10 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n+// build-pass\n+\n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "d48d8ff689462b330d554f55734754998b1b903d", "filename": "src/test/ui/const-generics/issues/issue-61336-1.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -6,11 +6,3 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-1.rs:5:9\n-   |\n-LL |     [x; N]\n-   |         ^\n-\n-error: aborting due to previous error\n-"}, {"sha": "c5bf6b6ce94a8a4ae4ab532663bb070c94bf494e", "filename": "src/test/ui/const-generics/issues/issue-61336-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -2,13 +2,12 @@\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n-    [x; {N}]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    [x; { N }]\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n-    [x; {N}]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    [x; { N }]\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n }\n \n fn main() {"}, {"sha": "9ced427b93c6589046893e785b9887ef8639d2ca", "filename": "src/test/ui/const-generics/issues/issue-61336-2.stderr", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -6,17 +6,19 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-2.rs:5:9\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336-2.rs:9:5\n    |\n-LL |     [x; {N}]\n-   |         ^^^\n-\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-2.rs:10:9\n+LL |     [x; { N }]\n+   |     ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+help: consider restricting this type parameter with `T: std::marker::Copy`\n+  --> $DIR/issue-61336-2.rs:8:6\n    |\n-LL |     [x; {N}]\n-   |         ^^^\n+LL | fn g<T, const N: usize>(x: T) -> [T; N] {\n+   |      ^\n+   = note: the `Copy` trait is required because the repeated element will be copied\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7e84e62d8be421f9e33f44b4b8a7af1407a616b4", "filename": "src/test/ui/const-generics/issues/issue-61336.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -3,12 +3,11 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n }\n \n fn main() {"}, {"sha": "ace7955fbdd77ffd1b0d9f24940a65e767152e9f", "filename": "src/test/ui/const-generics/issues/issue-61336.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -6,17 +6,19 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336.rs:5:9\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336.rs:9:5\n    |\n LL |     [x; N]\n-   |         ^\n-\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336.rs:10:9\n+   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-LL |     [x; N]\n-   |         ^\n+help: consider restricting this type parameter with `T: std::marker::Copy`\n+  --> $DIR/issue-61336.rs:8:6\n+   |\n+LL | fn g<T, const N: usize>(x: T) -> [T; N] {\n+   |      ^\n+   = note: the `Copy` trait is required because the repeated element will be copied\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "14b1190df0f995caf09f4d72513d15ef56484d93", "filename": "src/test/ui/const-generics/issues/issue-62456.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,9 +1,10 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n+// build-pass\n+\n fn foo<const N: usize>() {\n     let _ = [0u64; N + 1];\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {}"}, {"sha": "47dd3c01fa9e003f57c36b1e4c9d132fe75aaf59", "filename": "src/test/ui/const-generics/issues/issue-62456.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -6,11 +6,3 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-62456.rs:5:20\n-   |\n-LL |     let _ = [0u64; N + 1];\n-   |                    ^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "cd3cfaac3b95b81f8ad2fdb22f160718dc26574b", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -16,7 +16,7 @@ struct ArrayHolder<const X: usize>([u32; X]);\n impl<const X: usize> ArrayHolder<{ X }> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n-        //~^ ERROR: array lengths can't depend on generic parameters\n+        //~^ ERROR: mismatched types\n     }\n }\n "}, {"sha": "4482389bbdd4954c88abca5ff4774f3050247f88", "filename": "src/test/ui/const-generics/issues/issue-62504.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,8 +1,12 @@\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-62504.rs:18:25\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62504.rs:18:21\n    |\n LL |         ArrayHolder([0; Self::SIZE])\n-   |                         ^^^^^^^^^^\n+   |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n+   |\n+   = note: expected array `[u32; _]`\n+              found array `[u32; _]`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3d657b0947b18f28a0eab91ec3d6f3bdefbd48ba", "filename": "src/test/ui/const-generics/issues/issue-67739.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,5 +1,7 @@\n // Regression test for #67739\n \n+// check-pass\n+\n #![allow(incomplete_features)]\n #![feature(const_generics)]\n \n@@ -10,7 +12,6 @@ pub trait Trait {\n \n     fn associated_size(&self) -> usize {\n         [0u8; mem::size_of::<Self::Associated>()];\n-        //~^ ERROR: array lengths can't depend on generic parameters\n         0\n     }\n }"}, {"sha": "a31b556c086f8301a3f476670300907c2fe608df", "filename": "src/test/ui/const-generics/issues/issue-67739.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee9094869c85d336f67de8f328e34944f06f1ebe/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee9094869c85d336f67de8f328e34944f06f1ebe/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr?ref=ee9094869c85d336f67de8f328e34944f06f1ebe", "patch": "@@ -1,8 +0,0 @@\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-67739.rs:12:15\n-   |\n-LL |         [0u8; mem::size_of::<Self::Associated>()];\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "3ae55ebdbaf357c211dcced4d6658820afef99da", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -19,6 +19,7 @@ const A_I8_I\n     : [u32; (i8::MAX as usize) + 1]\n     = [0; (i8::MAX + 1) as usize];\n //~^ ERROR evaluation of constant value failed\n+//~| ERROR mismatched types\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "94b7c12fc1a8b138763a7d8602fe91eea7d2875b", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -4,6 +4,16 @@ error[E0080]: evaluation of constant value failed\n LL |     = [0; (i8::MAX + 1) as usize];\n    |           ^^^^^^^^^^^^^ attempt to add with overflow\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/const-eval-overflow-3.rs:20:7\n+   |\n+LL |     = [0; (i8::MAX + 1) as usize];\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `128usize`, found `(i8::MAX + 1) as usize`\n+   |\n+   = note: expected array `[u32; 128]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0080`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "e7b88e00febaa3a94230171974667ee02d6c2e5e", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -18,6 +18,7 @@ const A_I8_I\n     = [0; (i8::MAX + 1u8) as usize];\n //~^ ERROR mismatched types\n //~| ERROR cannot add `u8` to `i8`\n+//~| ERROR mismatched types\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "aebe4feef8d5f7931ff932b18c879d635e50bd2d", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -12,7 +12,16 @@ LL |     = [0; (i8::MAX + 1u8) as usize];\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `i8`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/const-eval-overflow-3b.rs:18:7\n+   |\n+LL |     = [0; (i8::MAX + 1u8) as usize];\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `128usize`, found `(i8::MAX + 1u8) as usize`\n+   |\n+   = note: expected array `[u32; 128]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0277, E0308.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "df4cc8e3026778177bb0098fdad8c05a4d9a4098", "filename": "src/test/ui/consts/const-eval/issue-52442.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,6 +1,4 @@\n fn main() {\n     [();  { &loop { break } as *const _ as usize } ];\n-    //~^ ERROR casting pointers to integers in constants is unstable\n-    //~| ERROR `loop` is not allowed in a `const`\n-    //~| ERROR evaluation of constant value failed\n+    //~^ ERROR `loop` is not allowed in a `const`\n }"}, {"sha": "0ea974f1f66662e85aaafbbf8347ae493cced1fb", "filename": "src/test/ui/consts/const-eval/issue-52442.stderr", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -7,22 +7,6 @@ LL |     [();  { &loop { break } as *const _ as usize } ];\n    = note: see issue #52000 <https://github.com/rust-lang/rust/issues/52000> for more information\n    = help: add `#![feature(const_loop)]` to the crate attributes to enable\n \n-error[E0658]: casting pointers to integers in constants is unstable\n-  --> $DIR/issue-52442.rs:2:13\n-   |\n-LL |     [();  { &loop { break } as *const _ as usize } ];\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n-   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52442.rs:2:13\n-   |\n-LL |     [();  { &loop { break } as *const _ as usize } ];\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0080, E0658.\n-For more information about an error, try `rustc --explain E0080`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "5cfe36f57e6478e915b75934496aca77ab257d26", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     // Make sure match uses the usual pointer comparison code path -- i.e., it should complain\n     // that pointer comparison is disallowed, not that parts of a pointer are accessed as raw\n     // bytes.\n-    let _: [u8; 0] = [4; {\n+    let _: [u8; 0] = [4; { //~ ERROR mismatched types\n         match &1 as *const i32 as usize {\n             //~^ ERROR casting pointers to integers in constants\n             //~| ERROR `match` is not allowed in a `const`"}, {"sha": "7c4da5e7d86cab11cf94175b6a0d0c1d2b00bab9", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.stderr", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -28,7 +28,30 @@ error[E0080]: evaluation of constant value failed\n LL |         match &1 as *const i32 as usize {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/match-test-ptr-null.rs:5:22\n+   |\n+LL |       let _: [u8; 0] = [4; {\n+   |  ____________-------___^\n+   | |            |\n+   | |            expected due to this\n+LL | |         match &1 as *const i32 as usize {\n+LL | |\n+LL | |\n+...  |\n+LL | |         }\n+LL | |     }];\n+   | |______^ expected `0usize`, found `{\n+        match &1 as *const i32 as usize {\n+            0 => 42,\n+            n => n,\n+        }\n+    }`\n+   |\n+   = note: expected array `[u8; 0]`\n+              found array `[u8; _]`\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0080, E0658.\n+Some errors have detailed explanations: E0080, E0308, E0658.\n For more information about an error, try `rustc --explain E0080`."}, {"sha": "ded79458e637f12167d27608a15c1ea7e83d5ce0", "filename": "src/test/ui/consts/issue-52432.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -6,5 +6,4 @@ fn main() {\n     //~| ERROR: type annotations needed\n     [(); &(static || {}) as *const _ as usize];\n     //~^ ERROR: closures cannot be static\n-    //~| ERROR: evaluation of constant value failed\n }"}, {"sha": "d25c11138f4003288adef7229b8792047d968f3e", "filename": "src/test/ui/consts/issue-52432.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -16,13 +16,7 @@ error[E0282]: type annotations needed\n LL |     [(); &(static |x| {}) as *const _ as usize];\n    |                    ^ consider giving this closure parameter a type\n \n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52432.rs:7:10\n-   |\n-LL |     [(); &(static || {}) as *const _ as usize];\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0080, E0282, E0697.\n-For more information about an error, try `rustc --explain E0080`.\n+Some errors have detailed explanations: E0282, E0697.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "f0d5fea8e023925e7b4f47cc6ea55cd0da2570e5", "filename": "src/test/ui/consts/issue-69310-array-size-lit-wrong-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -3,7 +3,7 @@\n // we call the query `lit_to_const(input);`.\n // However, the literal `input.lit` would not be of the type expected by `input.ty`.\n // As a result, we immediately called `bug!(...)` instead of bubbling up the problem\n-// so that it could be handled by the caller of `lit_to_const` (`ast_const_to_const`).\n+// so that it could be handled by the caller of `lit_to_const` (`from_anon_const`).\n \n fn main() {}\n "}, {"sha": "7e4d4dbe44610a7f0a9d45d428f9cf1e850cac34", "filename": "src/test/ui/consts/too_generic_eval_ice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -7,6 +7,7 @@ impl<A, B> Foo<A, B> {\n         [5; Self::HOST_SIZE] == [6; 0] //~ ERROR no associated item named `HOST_SIZE`\n         //~^ the size for values of type `A` cannot be known\n         //~| the size for values of type `B` cannot be known\n+        //~| binary operation `==` cannot be applied to type `[{integer}; _]`\n     }\n }\n "}, {"sha": "ffa28225b79c65ca7250af558a61e8ae118fcfd2", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -41,7 +41,15 @@ LL |         [5; Self::HOST_SIZE] == [6; 0]\n    = help: the trait `std::marker::Sized` is not implemented for `B`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n-error: aborting due to 3 previous errors\n+error[E0369]: binary operation `==` cannot be applied to type `[{integer}; _]`\n+  --> $DIR/too_generic_eval_ice.rs:7:30\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |         -------------------- ^^ ------ [{integer}; 0]\n+   |         |\n+   |         [{integer}; _]\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0277, E0599.\n+Some errors have detailed explanations: E0277, E0369, E0599.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "ec0275b2d6c1274f89d2506e8f264888af1ac3e5", "filename": "src/test/ui/issues/issue-39559-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -17,4 +17,5 @@ fn main() {\n         = [0; Dim3::dim()];\n         //~^ ERROR E0015\n         //~| ERROR E0080\n+        //~| ERROR mismatched types\n }"}, {"sha": "7cbf63c2da0a96336162f1ea61b1e54f624f34fa", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -22,7 +22,19 @@ error[E0080]: evaluation of constant value failed\n LL |         = [0; Dim3::dim()];\n    |               ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n \n-error: aborting due to 4 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-39559-2.rs:17:11\n+   |\n+LL |     let array: [usize; Dim3::dim()]\n+   |                -------------------- expected due to this\n+...\n+LL |         = [0; Dim3::dim()];\n+   |           ^^^^^^^^^^^^^^^^ expected `Dim3::dim()`, found `Dim3::dim()`\n+   |\n+   = note: expected array `[usize; _]`\n+              found array `[usize; _]`\n+\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0015, E0080.\n+Some errors have detailed explanations: E0015, E0080, E0308.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "2688049fcc9ffa357d5c23a1efddc87e2668f600", "filename": "src/test/ui/issues/issue-52060.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -4,5 +4,6 @@ static A: &'static [u32] = &[1];\n static B: [u32; 1] = [0; A.len()];\n //~^ ERROR [E0013]\n //~| ERROR evaluation of constant value failed\n+//~| ERROR mismatched types\n \n fn main() {}"}, {"sha": "e076e183937f2539b016b1142151057094b38462", "filename": "src/test/ui/issues/issue-52060.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -12,7 +12,16 @@ error[E0080]: evaluation of constant value failed\n LL | static B: [u32; 1] = [0; A.len()];\n    |                          ^ constant accesses static\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52060.rs:4:22\n+   |\n+LL | static B: [u32; 1] = [0; A.len()];\n+   |                      ^^^^^^^^^^^^ expected `1usize`, found `A.len()`\n+   |\n+   = note: expected array `[u32; 1]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0013, E0080.\n+Some errors have detailed explanations: E0013, E0080, E0308.\n For more information about an error, try `rustc --explain E0013`."}, {"sha": "2c5257ce063cb525897cd2c19a1b4380f1d0c37d", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -19,5 +19,4 @@ impl TraitB for B { //~ ERROR not all trait items implemented, missing: `MyA`\n \n fn main() {\n     let _ = [0; B::VALUE];\n-    //~^ ERROR array lengths can't depend on generic parameters\n }"}, {"sha": "8ae0f8b804c93e822b6b5f97fa81105cb3215dcc", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -13,13 +13,7 @@ LL |     type MyA: TraitA;\n LL | impl TraitB for B {\n    | ^^^^^^^^^^^^^^^^^ missing `MyA` in implementation\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-69602-type-err-during-codegen-ice.rs:21:17\n-   |\n-LL |     let _ = [0; B::VALUE];\n-   |                 ^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0046, E0437.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "4a2d1d9f921cb97985e5d5c348bff30253696799", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -28,6 +28,12 @@ error[E0308]: mismatched types\n LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:28:17\n+   |\n+LL |     let g = [0; G { g: () }];\n+   |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n+\n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:19:17\n    |\n@@ -50,12 +56,6 @@ help: you can convert an `isize` to `usize` and panic if the converted value wou\n LL |     let f = [0_usize; (-1_isize).try_into().unwrap()];\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:28:17\n-   |\n-LL |     let g = [0; G { g: () }];\n-   |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n-\n error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0308, E0435."}, {"sha": "708d72a2df756e1681429cf66c23d2cae9315de1", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -24,6 +24,7 @@ fn i<const N: usize>() {\n     static a: [u8; N] = [0; N];\n     //~^ ERROR can't use generic parameters from outer function\n     //~^^ ERROR can't use generic parameters from outer function\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "97c60c72298372cc250e4fa0721c84a7f6e496cd", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -48,6 +48,16 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:25\n+   |\n+LL |     static a: [u8; N] = [0; N];\n+   |                         ^^^^^^ expected `N`, found `N`\n+   |\n+   = note: expected array `[u8; _]`\n+              found array `[u8; _]`\n+\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0401`.\n+Some errors have detailed explanations: E0308, E0401.\n+For more information about an error, try `rustc --explain E0308`."}]}