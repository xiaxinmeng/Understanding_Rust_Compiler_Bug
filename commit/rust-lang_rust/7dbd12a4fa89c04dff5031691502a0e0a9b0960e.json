{"sha": "7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYmQxMmE0ZmE4OWMwNGRmZjUwMzE2OTE1MDJhMGUwYTliMDk2MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T17:41:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-07T17:41:35Z"}, "message": "auto merge of #11353 : alexcrichton/rust/improve-logging, r=brson\n\nThis will allow capturing of common things like logging messages, stdout prints\r\n(using stdio println), and failure messages (printed to stderr).  Any new prints\r\nadded to libstd should be funneled through these task handles to allow capture\r\nas well.\r\n\r\nAdditionally, this commit redirects logging back through a `Logger` trait so the\r\nlog level can be usefully consumed by an arbitrary logger.\r\n\r\nThis commit also introduces methods to set the task-local stdout handles:\r\n\r\n* std::io::stdio::set_stdout\r\n* std::io::stdio::set_stderr\r\n* std::io::logging::set_logger\r\n\r\nThese methods all return the previous logger just in case it needs to be used\r\nfor inspection.\r\n\r\nI plan on using this infrastructure for extra::test soon, but we don't quite\r\nhave the primitives that I'd like to use for it, so it doesn't migrate\r\nextra::test at this time.\r\n\r\nCloses #6369", "tree": {"sha": "d93f0a2206857e7922eeb1636b0858c262297c50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d93f0a2206857e7922eeb1636b0858c262297c50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "html_url": "https://github.com/rust-lang/rust/commit/7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3912a8779e7140f973da15956d54697d3912e0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3912a8779e7140f973da15956d54697d3912e0a2", "html_url": "https://github.com/rust-lang/rust/commit/3912a8779e7140f973da15956d54697d3912e0a2"}, {"sha": "ac2a24ecc9df66279a7b6df478593b34e1d2449f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2a24ecc9df66279a7b6df478593b34e1d2449f", "html_url": "https://github.com/rust-lang/rust/commit/ac2a24ecc9df66279a7b6df478593b34e1d2449f"}], "stats": {"total": 486, "additions": 328, "deletions": 158}, "files": [{"sha": "62c9ad12535fc998797d5626e4db8c1feba88c46", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -118,13 +118,17 @@ impl GreenTask {\n                      f: proc()) -> ~GreenTask {\n         let TaskOpts {\n             watched: _watched,\n-            notify_chan, name, stack_size\n+            notify_chan, name, stack_size,\n+            stderr, stdout, logger,\n         } = opts;\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n         {\n             let task = green.task.get_mut_ref();\n             task.name = name;\n+            task.logger = logger;\n+            task.stderr = stderr;\n+            task.stdout = stdout;\n             match notify_chan {\n                 Some(chan) => {\n                     let on_exit = proc(task_result) { chan.send(task_result) };"}, {"sha": "9b6a26291a1c3b7ddf2686b7420f1323b56b182c", "filename": "src/libnative/task.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -55,11 +55,15 @@ pub fn spawn(f: proc()) {\n pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n     let TaskOpts {\n         watched: _watched,\n-        notify_chan, name, stack_size\n+        notify_chan, name, stack_size,\n+        logger, stderr, stdout,\n     } = opts;\n \n     let mut task = ~Task::new();\n     task.name = name;\n+    task.logger = logger;\n+    task.stderr = stderr;\n+    task.stdout = stdout;\n     match notify_chan {\n         Some(chan) => {\n             let on_exit = proc(task_result) { chan.send(task_result) };"}, {"sha": "396e892520c0b11d675f0a65d4a73ed4c98771d6", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 105, "deletions": 27, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -32,8 +32,12 @@ use io::{Reader, Writer, io_error, IoError, OtherIoError,\n          standard_error, EndOfFile};\n use libc;\n use option::{Option, Some, None};\n+use prelude::drop;\n use result::{Ok, Err};\n+use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n+use rt::task::Task;\n+use util;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -101,6 +105,44 @@ pub fn stderr() -> StdWriter {\n     src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n+fn reset_helper(w: ~Writer,\n+                f: |&mut Task, ~Writer| -> Option<~Writer>) -> Option<~Writer> {\n+    let mut t = Local::borrow(None::<Task>);\n+    // Be sure to flush any pending output from the writer\n+    match f(t.get(), w) {\n+        Some(mut w) => {\n+            drop(t);\n+            w.flush();\n+            Some(w)\n+        }\n+        None => None\n+    }\n+}\n+\n+/// Resets the task-local stdout handle to the specified writer\n+///\n+/// This will replace the current task's stdout handle, returning the old\n+/// handle. All future calls to `print` and friends will emit their output to\n+/// this specified handle.\n+///\n+/// Note that this does not need to be called for all new tasks; the default\n+/// output handle is to the process's stdout stream.\n+pub fn set_stdout(stdout: ~Writer) -> Option<~Writer> {\n+    reset_helper(stdout, |t, w| util::replace(&mut t.stdout, Some(w)))\n+}\n+\n+/// Resets the task-local stderr handle to the specified writer\n+///\n+/// This will replace the current task's stderr handle, returning the old\n+/// handle. Currently, the stderr handle is used for printing failure messages\n+/// during task failure.\n+///\n+/// Note that this does not need to be called for all new tasks; the default\n+/// output handle is to the process's stderr stream.\n+pub fn set_stderr(stderr: ~Writer) -> Option<~Writer> {\n+    reset_helper(stderr, |t, w| util::replace(&mut t.stderr, Some(w)))\n+}\n+\n // Helper to access the local task's stdout handle\n //\n // Note that this is not a safe function to expose because you can create an\n@@ -112,38 +154,49 @@ pub fn stderr() -> StdWriter {\n //      })\n //  })\n fn with_task_stdout(f: |&mut Writer|) {\n-    use rt::local::Local;\n-    use rt::task::Task;\n-\n-    unsafe {\n-        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n-        match task {\n-            Some(task) => {\n-                match (*task).stdout_handle {\n-                    Some(ref mut handle) => f(*handle),\n-                    None => {\n-                        let handle = ~LineBufferedWriter::new(stdout());\n-                        let mut handle = handle as ~Writer;\n-                        f(handle);\n-                        (*task).stdout_handle = Some(handle);\n-                    }\n-                }\n+    let task: Option<~Task> = Local::try_take();\n+    match task {\n+        Some(mut task) => {\n+            // Printing may run arbitrary code, so ensure that the task is in\n+            // TLS to allow all std services. Note that this means a print while\n+            // printing won't use the task's normal stdout handle, but this is\n+            // necessary to ensure safety (no aliasing).\n+            let mut my_stdout = task.stdout.take();\n+            Local::put(task);\n+\n+            if my_stdout.is_none() {\n+                my_stdout = Some(~LineBufferedWriter::new(stdout()) as ~Writer);\n             }\n+            f(*my_stdout.get_mut_ref());\n+\n+            // Note that we need to be careful when putting the stdout handle\n+            // back into the task. If the handle was set to `Some` while\n+            // printing, then we can run aribitrary code when destroying the\n+            // previous handle. This means that the local task needs to be in\n+            // TLS while we do this.\n+            //\n+            // To protect against this, we do a little dance in which we\n+            // temporarily take the task, swap the handles, put the task in TLS,\n+            // and only then drop the previous handle.\n+            let mut t = Local::borrow(None::<Task>);\n+            let prev = util::replace(&mut t.get().stdout, my_stdout);\n+            drop(t);\n+            drop(prev);\n+        }\n \n-            None => {\n-                struct Stdout;\n-                impl Writer for Stdout {\n-                    fn write(&mut self, data: &[u8]) {\n-                        unsafe {\n-                            libc::write(libc::STDOUT_FILENO,\n-                                        data.as_ptr() as *libc::c_void,\n-                                        data.len() as libc::size_t);\n-                        }\n+        None => {\n+            struct Stdout;\n+            impl Writer for Stdout {\n+                fn write(&mut self, data: &[u8]) {\n+                    unsafe {\n+                        libc::write(libc::STDOUT_FILENO,\n+                                    data.as_ptr() as *libc::c_void,\n+                                    data.len() as libc::size_t);\n                     }\n                 }\n-                let mut io = Stdout;\n-                f(&mut io as &mut Writer);\n             }\n+            let mut io = Stdout;\n+            f(&mut io as &mut Writer);\n         }\n     }\n }\n@@ -313,4 +366,29 @@ mod tests {\n         stdout();\n         stderr();\n     })\n+\n+    iotest!(fn capture_stdout() {\n+        use io::comm_adapters::{PortReader, ChanWriter};\n+\n+        let (p, c) = Chan::new();\n+        let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+        do spawn {\n+            set_stdout(~w as ~Writer);\n+            println!(\"hello!\");\n+        }\n+        assert_eq!(r.read_to_str(), ~\"hello!\\n\");\n+    })\n+\n+    iotest!(fn capture_stderr() {\n+        use io::comm_adapters::{PortReader, ChanWriter};\n+\n+        let (p, c) = Chan::new();\n+        let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+        do spawn {\n+            set_stderr(~w as ~Writer);\n+            fail!(\"my special message\");\n+        }\n+        let s = r.read_to_str();\n+        assert!(s.contains(\"my special message\"));\n+    })\n }"}, {"sha": "d10b873c5b55e2a9cf1a40c15d2a11c7820ec05f", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -96,10 +96,15 @@ start, print out all modules registered for logging, and then exit.\n */\n \n use fmt;\n-use option::*;\n+use io::buffered::LineBufferedWriter;\n+use io;\n+use io::Writer;\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use prelude::drop;\n use rt::local::Local;\n-use rt::logging::{Logger, StdErrLogger};\n use rt::task::Task;\n+use util;\n \n /// Debug log level\n pub static DEBUG: u32 = 4;\n@@ -110,24 +115,65 @@ pub static WARN: u32 = 2;\n /// Error log level\n pub static ERROR: u32 = 1;\n \n+/// A trait used to represent an interface to a task-local logger. Each task\n+/// can have its own custom logger which can respond to logging messages\n+/// however it likes.\n+pub trait Logger {\n+    /// Logs a single message described by the `args` structure. The level is\n+    /// provided in case you want to do things like color the message, etc.\n+    fn log(&mut self, level: u32, args: &fmt::Arguments);\n+}\n+\n+struct DefaultLogger {\n+    handle: LineBufferedWriter<io::stdio::StdWriter>,\n+}\n+\n+impl Logger for DefaultLogger {\n+    // by default, just ignore the level\n+    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n+        fmt::writeln(&mut self.handle, args);\n+    }\n+}\n+\n+impl Drop for DefaultLogger {\n+    fn drop(&mut self) {\n+        self.handle.flush();\n+    }\n+}\n+\n /// This function is called directly by the compiler when using the logging\n /// macros. This function does not take into account whether the log level\n /// specified is active or not, it will always log something if this method is\n /// called.\n ///\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n-pub fn log(_level: u32, args: &fmt::Arguments) {\n+pub fn log(level: u32, args: &fmt::Arguments) {\n+    // See io::stdio::with_task_stdout for why there's a few dances here. The\n+    // gist of it is that arbitrary code can run during logging (and set an\n+    // arbitrary logging handle into the task) so we need to be careful that the\n+    // local task is in TLS while we're running arbitrary code.\n     let mut logger = {\n         let mut task = Local::borrow(None::<Task>);\n         task.get().logger.take()\n     };\n \n     if logger.is_none() {\n-        logger = Some(StdErrLogger::new());\n+        logger = Some(~DefaultLogger {\n+            handle: LineBufferedWriter::new(io::stderr()),\n+        } as ~Logger);\n     }\n-    logger.get_mut_ref().log(args);\n+    logger.get_mut_ref().log(level, args);\n+\n+    let mut task = Local::borrow(None::<Task>);\n+    let prev = util::replace(&mut task.get().logger, logger);\n+    drop(task);\n+    drop(prev);\n+}\n \n+/// Replaces the task-local logger with the specified logger, returning the old\n+/// logger.\n+pub fn set_logger(logger: ~Logger) -> Option<~Logger> {\n     let mut task = Local::borrow(None::<Task>);\n-    task.get().logger = logger;\n+    util::replace(&mut task.get().logger, Some(logger))\n }"}, {"sha": "586d26a24e3ee45e0a474599b27707692e92a0dd", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use fmt;\n use from_str::from_str;\n use libc::exit;\n use option::{Some, None, Option};\n-use io;\n-use io::stdio::StdWriter;\n-use io::buffered::LineBufferedWriter;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n use vec::{ImmutableVector, MutableTotalOrdVector};\n@@ -168,28 +164,6 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     }\n }\n \n-pub trait Logger {\n-    fn log(&mut self, args: &fmt::Arguments);\n-}\n-\n-/// This logger emits output to the stderr of the process, and contains a lazily\n-/// initialized event-loop driven handle to the stream.\n-pub struct StdErrLogger {\n-    priv handle: LineBufferedWriter<StdWriter>,\n-}\n-\n-impl StdErrLogger {\n-    pub fn new() -> StdErrLogger {\n-        StdErrLogger { handle: LineBufferedWriter::new(io::stderr()) }\n-    }\n-}\n-\n-impl Logger for StdErrLogger {\n-    fn log(&mut self, args: &fmt::Arguments) {\n-        fmt::writeln(&mut self.handle as &mut io::Writer, args);\n-    }\n-}\n-\n /// Configure logging by traversing the crate map and setting the\n /// per-module global logging flags based on the logging spec\n pub fn init() {"}, {"sha": "2d9105d6766183059241ff3b3ca619ba65b5b12b", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -20,6 +20,7 @@ use cleanup;\n use io::Writer;\n use iter::{Iterator, Take};\n use local_data;\n+use logging::Logger;\n use ops::Drop;\n use option::{Option, Some, None};\n use prelude::drop;\n@@ -29,7 +30,6 @@ use rt::borrowck::BorrowRecord;\n use rt::borrowck;\n use rt::local::Local;\n use rt::local_heap::LocalHeap;\n-use rt::logging::StdErrLogger;\n use rt::rtio::LocalIo;\n use rt::unwind::Unwinder;\n use send_str::SendStr;\n@@ -55,8 +55,9 @@ pub struct Task {\n     // Dynamic borrowck debugging info\n     borrow_list: Option<~[BorrowRecord]>,\n \n-    logger: Option<StdErrLogger>,\n-    stdout_handle: Option<~Writer>,\n+    logger: Option<~Logger>,\n+    stdout: Option<~Writer>,\n+    stderr: Option<~Writer>,\n \n     priv imp: Option<~Runtime>,\n }\n@@ -94,7 +95,8 @@ impl Task {\n             name: None,\n             borrow_list: None,\n             logger: None,\n-            stdout_handle: None,\n+            stdout: None,\n+            stderr: None,\n             imp: None,\n         }\n     }\n@@ -123,13 +125,21 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n-                fn flush(w: Option<~Writer>) {\n-                    match w {\n-                        Some(mut w) => { w.flush(); }\n-                        None => {}\n-                    }\n+                fn close_outputs() {\n+                    let mut task = Local::borrow(None::<Task>);\n+                    let logger = task.get().logger.take();\n+                    let stderr = task.get().stderr.take();\n+                    let stdout = task.get().stdout.take();\n+                    drop(task);\n+                    drop(logger); // loggers are responsible for flushing\n+                    match stdout { Some(mut w) => w.flush(), None => {} }\n+                    match stderr { Some(mut w) => w.flush(), None => {} }\n                 }\n \n+                // First, flush/destroy the user stdout/logger because these\n+                // destructors can run arbitrary code.\n+                close_outputs();\n+\n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n                 // FIXME #8302: Dear diary. I'm so tired and confused.\n@@ -161,16 +171,12 @@ impl Task {\n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }\n \n-                // Finally flush and destroy any output handles which the task\n-                // owns. There are no boxes here, and no user destructors should\n-                // run after this any more.\n-                let mut task = Local::borrow(None::<Task>);\n-                let stdout = task.get().stdout_handle.take();\n-                let logger = task.get().logger.take();\n-                drop(task);\n-\n-                flush(stdout);\n-                drop(logger);\n+                // Finally, just in case user dtors printed/logged during TLS\n+                // cleanup and annihilation, re-destroy stdout and the logger.\n+                // Note that these will have been initialized with a\n+                // runtime-provided type which we have control over what the\n+                // destructor does.\n+                close_outputs();\n             })\n         };\n "}, {"sha": "cb5360200d50a16f35545f05bd2a96ed066b5a28", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -61,12 +61,14 @@ use cast;\n use kinds::Send;\n use libc::{c_void, c_char, size_t};\n use option::{Some, None, Option};\n+use prelude::drop;\n use result::{Err, Ok};\n use rt::local::Local;\n use rt::task::Task;\n use str::Str;\n use task::TaskResult;\n use unstable::intrinsics;\n+use util;\n \n use uw = self::libunwind;\n \n@@ -385,58 +387,90 @@ pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n \n /// This is the entry point of unwinding for fail!() and assert!().\n pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n-    unsafe {\n-        let task: *mut Task;\n-        // Note that this should be the only allocation performed in this block.\n-        // Currently this means that fail!() on OOM will invoke this code path,\n-        // but then again we're not really ready for failing on OOM anyway. If\n-        // we do start doing this, then we should propagate this allocation to\n-        // be performed in the parent of this task instead of the task that's\n-        // failing.\n-        let msg = ~msg as ~Any;\n+    // Note that this should be the only allocation performed in this block.\n+    // Currently this means that fail!() on OOM will invoke this code path,\n+    // but then again we're not really ready for failing on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this task instead of the task that's\n+    // failing.\n+    let msg = ~msg as ~Any;\n+\n+    let mut task;\n+    {\n+        let msg_s = match msg.as_ref::<&'static str>() {\n+            Some(s) => *s,\n+            None => match msg.as_ref::<~str>() {\n+                Some(s) => s.as_slice(),\n+                None => \"~Any\",\n+            }\n+        };\n+\n+        // It is assumed that all reasonable rust code will have a local task at\n+        // all times. This means that this `try_take` will succeed almost all of\n+        // the time. There are border cases, however, when the runtime has\n+        // *almost* set up the local task, but hasn't quite gotten there yet. In\n+        // order to get some better diagnostics, we print on failure and\n+        // immediately abort the whole process if there is no local task\n+        // available.\n+        let opt_task: Option<~Task> = Local::try_take();\n+        task = match opt_task {\n+            Some(t) => t,\n+            None => {\n+                rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n+                unsafe { intrinsics::abort() }\n+            }\n+        };\n \n+        // See comments in io::stdio::with_task_stdout as to why we have to be\n+        // careful when using an arbitrary I/O handle from the task. We\n+        // essentially need to dance to make sure when a task is in TLS when\n+        // running user code.\n+        let name = task.name.take();\n         {\n-            let msg_s = match msg.as_ref::<&'static str>() {\n-                Some(s) => *s,\n-                None => match msg.as_ref::<~str>() {\n-                    Some(s) => s.as_slice(),\n-                    None => \"~Any\",\n+            let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+            match task.stderr.take() {\n+                Some(mut stderr) => {\n+                    Local::put(task);\n+                    format_args!(|args| ::fmt::writeln(stderr, args),\n+                                 \"task '{}' failed at '{}', {}:{}\",\n+                                 n, msg_s, file, line);\n+                    task = Local::take();\n+\n+                    match util::replace(&mut task.stderr, Some(stderr)) {\n+                        Some(prev) => {\n+                            Local::put(task);\n+                            drop(prev);\n+                            task = Local::take();\n+                        }\n+                        None => {}\n+                    }\n                 }\n-            };\n-\n-            // It is assumed that all reasonable rust code will have a local\n-            // task at all times. This means that this `try_unsafe_borrow` will\n-            // succeed almost all of the time. There are border cases, however,\n-            // when the runtime has *almost* set up the local task, but hasn't\n-            // quite gotten there yet. In order to get some better diagnostics,\n-            // we print on failure and immediately abort the whole process if\n-            // there is no local task available.\n-            match Local::try_unsafe_borrow() {\n-                Some(t) => {\n-                    task = t;\n-                    let n = (*task).name.as_ref()\n-                                   .map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n+                None => {\n                     rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n                              file, line);\n                 }\n-                None => {\n-                    rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n-                    intrinsics::abort();\n-                }\n-            }\n-\n-            if (*task).unwinder.unwinding {\n-                // If a task fails while it's already unwinding then we\n-                // have limited options. Currently our preference is to\n-                // just abort. In the future we may consider resuming\n-                // unwinding or otherwise exiting the task cleanly.\n-                rterrln!(\"task failed during unwinding (double-failure - total drag!)\")\n-                rterrln!(\"rust must abort now. so sorry.\");\n-                intrinsics::abort();\n             }\n         }\n+        task.name = name;\n+\n+        if task.unwinder.unwinding {\n+            // If a task fails while it's already unwinding then we\n+            // have limited options. Currently our preference is to\n+            // just abort. In the future we may consider resuming\n+            // unwinding or otherwise exiting the task cleanly.\n+            rterrln!(\"task failed during unwinding (double-failure - total drag!)\")\n+            rterrln!(\"rust must abort now. so sorry.\");\n+            unsafe { intrinsics::abort() }\n+        }\n+    }\n \n+    // The unwinder won't actually use the task at all, so we put the task back\n+    // into TLS right before we invoke the unwinder, but this means we need an\n+    // unsafe reference back to the unwinder once it's in TLS.\n+    Local::put(task);\n+    unsafe {\n+        let task: *mut Task = Local::unsafe_borrow();\n         (*task).unwinder.begin_unwind(msg);\n     }\n }"}, {"sha": "900b6d49cc66c1326431bf3ded3be096c4f81ed0", "filename": "src/libstd/task.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -55,7 +55,9 @@\n \n use any::Any;\n use comm::{Chan, Port};\n+use io::Writer;\n use kinds::Send;\n+use logging::Logger;\n use option::{None, Some, Option};\n use result::{Result, Ok, Err};\n use rt::local::Local;\n@@ -103,7 +105,10 @@ pub struct TaskOpts {\n     watched: bool,\n     notify_chan: Option<Chan<TaskResult>>,\n     name: Option<SendStr>,\n-    stack_size: Option<uint>\n+    stack_size: Option<uint>,\n+    logger: Option<~Logger>,\n+    stdout: Option<~Writer>,\n+    stderr: Option<~Writer>,\n }\n \n /**\n@@ -138,22 +143,6 @@ pub fn task() -> TaskBuilder {\n }\n \n impl TaskBuilder {\n-    fn consume(mut self) -> TaskBuilder {\n-        let gen_body = self.gen_body.take();\n-        let notify_chan = self.opts.notify_chan.take();\n-        let name = self.opts.name.take();\n-        TaskBuilder {\n-            opts: TaskOpts {\n-                watched: self.opts.watched,\n-                notify_chan: notify_chan,\n-                name: name,\n-                stack_size: self.opts.stack_size\n-            },\n-            gen_body: gen_body,\n-            can_not_copy: None,\n-        }\n-    }\n-\n     /// Cause the parent task to collect the child's exit status (and that of\n     /// all transitively-watched grandchildren) before reporting its own.\n     pub fn watched(&mut self) {\n@@ -250,26 +239,12 @@ impl TaskBuilder {\n      */\n     pub fn spawn(mut self, f: proc()) {\n         let gen_body = self.gen_body.take();\n-        let notify_chan = self.opts.notify_chan.take();\n-        let name = self.opts.name.take();\n-        let x = self.consume();\n-        let opts = TaskOpts {\n-            watched: x.opts.watched,\n-            notify_chan: notify_chan,\n-            name: name,\n-            stack_size: x.opts.stack_size\n-        };\n         let f = match gen_body {\n-            Some(gen) => {\n-                gen(f)\n-            }\n-            None => {\n-                f\n-            }\n+            Some(gen) => gen(f),\n+            None => f\n         };\n-\n         let t: ~Task = Local::take();\n-        t.spawn_sibling(opts, f);\n+        t.spawn_sibling(self.opts, f);\n     }\n \n     /**\n@@ -316,7 +291,10 @@ impl TaskOpts {\n             watched: true,\n             notify_chan: None,\n             name: None,\n-            stack_size: None\n+            stack_size: None,\n+            logger: None,\n+            stdout: None,\n+            stderr: None,\n         }\n     }\n }"}, {"sha": "f5230416041338202b4041a44efe8a4ef836df87", "filename": "src/test/run-pass/capturing-logging.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dbd12a4fa89c04dff5031691502a0e0a9b0960e/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=7dbd12a4fa89c04dff5031691502a0e0a9b0960e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+// exec-env:RUST_LOG=info\n+\n+#[no_uv];\n+extern mod native;\n+\n+use std::fmt;\n+use std::io::comm_adapters::{PortReader, ChanWriter};\n+use std::logging::{set_logger, Logger};\n+\n+struct MyWriter(ChanWriter);\n+\n+impl Logger for MyWriter {\n+    fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n+        let MyWriter(ref mut inner) = *self;\n+        fmt::writeln(inner as &mut Writer, args);\n+    }\n+}\n+\n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    do native::start(argc, argv) {\n+        main();\n+    }\n+}\n+\n+fn main() {\n+    let (p, c) = Chan::new();\n+    let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+    do spawn {\n+        set_logger(~MyWriter(w) as ~Logger);\n+        debug!(\"debug\");\n+        info!(\"info\");\n+    }\n+    assert_eq!(r.read_to_str(), ~\"info\\n\");\n+}"}]}