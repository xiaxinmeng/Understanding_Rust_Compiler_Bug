{"sha": "92425496e525855fd772f771a35456a4b66c071f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNDI1NDk2ZTUyNTg1NWZkNzcyZjc3MWEzNTQ1NmE0YjY2YzA3MWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-08T14:13:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-08T14:19:27Z"}, "message": "Fix the actual bug for #20232: when creating the cmt for the implicit\nderef that is associated with an overloaded index, we should not\nconsult the method lookup table. This deref is *always* a deref of an\n`&T` and hence is never overloaded (and is also not present in the\ntables; it has no \"id\" or other associated key).", "tree": {"sha": "1b44322b3fcfb254d8b32f8b6af160a6247635c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b44322b3fcfb254d8b32f8b6af160a6247635c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92425496e525855fd772f771a35456a4b66c071f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92425496e525855fd772f771a35456a4b66c071f", "html_url": "https://github.com/rust-lang/rust/commit/92425496e525855fd772f771a35456a4b66c071f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92425496e525855fd772f771a35456a4b66c071f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2387651f7d5e57ce73d5193f6dbfe75ae1e288c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2387651f7d5e57ce73d5193f6dbfe75ae1e288c8", "html_url": "https://github.com/rust-lang/rust/commit/2387651f7d5e57ce73d5193f6dbfe75ae1e288c8"}], "stats": {"total": 33, "additions": 23, "deletions": 10}, "files": [{"sha": "51ec75284326c4f76f9b790ef99b19cc654b76a4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/92425496e525855fd772f771a35456a4b66c071f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92425496e525855fd772f771a35456a4b66c071f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=92425496e525855fd772f771a35456a4b66c071f", "patch": "@@ -460,7 +460,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n-            cmt = try!(self.cat_deref(expr, cmt, deref, false));\n+            cmt = try!(self.cat_deref(expr, cmt, deref));\n         }\n         return Ok(cmt);\n     }\n@@ -472,7 +472,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n             let base_cmt = try!(self.cat_expr(&**e_base));\n-            self.cat_deref(expr, base_cmt, 0, false)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n@@ -496,10 +496,23 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n                     let ret_ty = self.overloaded_method_return_ty(method_ty);\n-                    self.cat_deref(expr,\n-                                   self.cat_rvalue_node(expr.id(),\n-                                                        expr.span(),\n-                                                        ret_ty), 1, true)\n+\n+                    // The index method always returns an `&T`, so\n+                    // dereference it to find the result type.\n+                    let elem_ty = match ret_ty.sty {\n+                        ty::ty_rptr(_, mt) => mt.ty,\n+                        _ => {\n+                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {}?\",\n+                                   ret_ty.repr(self.tcx()));\n+                            return Err(());\n+                        }\n+                    };\n+\n+                    // The call to index() returns a `&T` value, which\n+                    // is an rvalue. That is what we will be\n+                    // dereferencing.\n+                    let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n+                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, true)\n                 }\n                 None => {\n                     self.cat_index(expr, try!(self.cat_expr(&**base)))\n@@ -844,8 +857,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint,\n-                             implicit: bool)\n+                             deref_cnt: uint)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n@@ -873,7 +885,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, implicit),\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty,\n+                                              /* implicit: */ false),\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -1243,7 +1256,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatRegion since that information is already contained\n             // in the type.\n-            let subcmt = try!(self.cat_deref(pat, cmt, 0, false));\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n "}]}