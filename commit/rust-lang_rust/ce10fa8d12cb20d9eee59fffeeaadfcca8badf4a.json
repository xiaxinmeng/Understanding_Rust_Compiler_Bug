{"sha": "ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMTBmYThkMTJjYjIwZDllZWU1OWZmZmVlYWFkZmNjYThiYWRmNGE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T06:38:27Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-11T21:39:16Z"}, "message": "syntax: rename TypeMethod to MethodSig and use it in MethDecl.", "tree": {"sha": "c39add1b10d1a2f80d727c3f6db839760a525b97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c39add1b10d1a2f80d727c3f6db839760a525b97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "html_url": "https://github.com/rust-lang/rust/commit/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f98b1763140e4c9b0f122bde2f5cbd24227554a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f98b1763140e4c9b0f122bde2f5cbd24227554a2", "html_url": "https://github.com/rust-lang/rust/commit/f98b1763140e4c9b0f122bde2f5cbd24227554a2"}], "stats": {"total": 804, "additions": 291, "deletions": 513}, "files": [{"sha": "eb41a26fa770177e232d0fd0c44887710b5e7fea", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -838,7 +838,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n-            encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n+            encode_method_argument_names(rbml_w, &ast_method.pe_sig().decl);\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n-                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n+                    encode_method_argument_names(rbml_w, &*m.pe_sig().decl);\n                 }\n \n                 ast::TypeTraitItem(..) => {"}, {"sha": "02f2908a9e6d564a13b83d600cbd70901f90f776", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::Unsafety::Unsafe),\n             visit::FkMethod(_, method) =>\n-                (true, method.pe_unsafety() == ast::Unsafety::Unsafe),\n+                (true, method.pe_sig().unsafety == ast::Unsafety::Unsafe),\n             _ => (false, false),\n         };\n "}, {"sha": "823acdc169120b139c719bc13ab1d8779dde256e", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -841,19 +841,19 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         ast::ItemFn(ref fn_decl, pur, _, ref gen, _) => {\n-                            Some((&**fn_decl, gen, pur, item.ident, None, item.span))\n+                            Some((fn_decl, gen, pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n                 }\n                 ast_map::NodeImplItem(item) => {\n                     match item.node {\n                         ast::MethodImplItem(ref m) => {\n-                            Some((m.pe_fn_decl(),\n-                                  m.pe_generics(),\n-                                  m.pe_unsafety(),\n+                            Some((&m.pe_sig().decl,\n+                                  &m.pe_sig().generics,\n+                                  m.pe_sig().unsafety,\n                                   item.ident,\n-                                  Some(&m.pe_explicit_self().node),\n+                                  Some(&m.pe_sig().explicit_self.node),\n                                   item.span))\n                         }\n                         ast::TypeImplItem(_) => None,\n@@ -862,11 +862,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 ast_map::NodeTraitItem(item) => {\n                     match item.node {\n                         ast::ProvidedMethod(ref m) => {\n-                            Some((m.pe_fn_decl(),\n-                                  m.pe_generics(),\n-                                  m.pe_unsafety(),\n+                            Some((&m.pe_sig().decl,\n+                                  &m.pe_sig().generics,\n+                                  m.pe_sig().unsafety,\n                                   item.ident,\n-                                  Some(&m.pe_explicit_self().node),\n+                                  Some(&m.pe_sig().explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None\n@@ -1732,7 +1732,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n             ast_map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(&m.pe_generics().lifetimes);\n+                        taken.push_all(&m.pe_sig().generics.lifetimes);\n                         Some(ii.id)\n                     }\n                     ast::TypeImplItem(_) => None,"}, {"sha": "75e9c60698ba31295ffcf58c0de8e54e30e84cc1", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -57,7 +57,7 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_item: &ast::ImplItem,\n                            impl_src: ast::DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n-        generics_require_inlining(method.pe_generics()) {\n+        generics_require_inlining(&method.pe_sig().generics) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match impl_item.node {\n                     ast::MethodImplItem(ref method) => {\n-                        if generics_require_inlining(method.pe_generics()) ||\n+                        if generics_require_inlining(&method.pe_sig().generics) ||\n                                 attr::requests_inline(&impl_item.attrs) {\n                             true\n                         } else {"}, {"sha": "32d52bcbf74eed379d4f5f721b2558a33d8c8185", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 })\n             }\n             visit::FkMethod(_, m) => {\n-                self.visit_early_late(subst::FnSpace, m.pe_generics(), |this| {\n+                self.visit_early_late(subst::FnSpace, &m.pe_sig().generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }"}, {"sha": "687b4cb8723dff94841e4033c1e497298edd74e1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -46,7 +46,7 @@ use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast, ast_map};\n-use syntax::ast_util::{self, is_shift_binop, local_def};\n+use syntax::ast_util::{self, is_shift_binop, local_def, PostExpansionMethod};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n@@ -1319,7 +1319,7 @@ impl LintPass for UnsafeCode {\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n             visit::FkMethod(_, m) => {\n-                if let ast::MethDecl(_, _, _, ast::Unsafety::Unsafe, _, _) = *m {\n+                if m.pe_sig().unsafety == ast::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n             },"}, {"sha": "9b069962de40922a42e3ef56c9735d8673f0d564", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                         match impl_item.node {\n                             ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n-                                    match method.pe_explicit_self().node {\n+                                    match method.pe_sig().explicit_self.node {\n                                         ast::SelfStatic => public_ty,\n                                         _ => true,\n                                     } && impl_item.vis == ast::Public;\n@@ -1355,7 +1355,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     for impl_item in impl_items {\n                         match impl_item.node {\n                             ast::MethodImplItem(ref method) => {\n-                                if method.pe_explicit_self().node ==\n+                                if method.pe_sig().explicit_self.node ==\n                                         ast::SelfStatic &&\n                                         self.exported_items\n                                             .contains(&impl_item.id) {"}, {"sha": "296a9794f1cea90f8779dc39ab38f15ce442aa64", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -243,8 +243,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 ItemRibKind\n             }\n             visit::FkMethod(_, method) => {\n-                self.visit_generics(method.pe_generics());\n-                self.visit_explicit_self(method.pe_explicit_self());\n+                self.visit_generics(&method.pe_sig().generics);\n+                self.visit_explicit_self(&method.pe_sig().explicit_self);\n                 MethodRibKind\n             }\n             visit::FkFnBlock(..) => ClosureRibKind(node_id)\n@@ -2814,13 +2814,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // FIXME #4951: Do we need a node ID here?\n \n                         let type_parameters = match trait_item.node {\n-                            ast::RequiredMethod(ref ty_m) => {\n-                                HasTypeParameters(&ty_m.generics,\n+                            ast::RequiredMethod(ref sig) => {\n+                                HasTypeParameters(&sig.generics,\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n                             ast::ProvidedMethod(ref m) => {\n-                                HasTypeParameters(m.pe_generics(),\n+                                HasTypeParameters(&m.pe_sig().generics,\n                                                   FnSpace,\n                                                   MethodRibKind)\n                             }\n@@ -3075,7 +3075,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // We also need a new scope for the method-\n                                 // specific type parameters.\n                                 let type_parameters =\n-                                    HasTypeParameters(method.pe_generics(),\n+                                    HasTypeParameters(&method.pe_sig().generics,\n                                                       FnSpace,\n                                                       MethodRibKind);\n                                 this.with_type_parameter_rib(type_parameters, |this| {\n@@ -3956,11 +3956,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let explicit_self = match this.ast_map.get(did.node) {\n                     ast_map::NodeTraitItem(trait_item) => match trait_item.node {\n                         ast::RequiredMethod(ref m) => &m.explicit_self,\n-                        ast::ProvidedMethod(ref m) => m.pe_explicit_self(),\n+                        ast::ProvidedMethod(ref m) => &m.pe_sig().explicit_self,\n                         _ => return false\n                     },\n                     ast_map::NodeImplItem(impl_item) => match impl_item.node {\n-                        ast::MethodImplItem(ref m) => m.pe_explicit_self(),\n+                        ast::MethodImplItem(ref m) => &m.pe_sig().explicit_self,\n                         _ => return false\n                     },\n                     _ => return false"}, {"sha": "2b1def22ed9ab9e051873f7d832d1431096713e1", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -382,21 +382,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             decl_id,\n                             scope_id);\n \n-        self.process_formals(&method.pe_fn_decl().inputs, qualname);\n+        self.process_formals(&method.pe_sig().decl.inputs, qualname);\n \n         // walk arg and return types\n-        for arg in &method.pe_fn_decl().inputs {\n+        for arg in &method.pe_sig().decl.inputs {\n             self.visit_ty(&*arg.ty);\n         }\n \n-        if let ast::Return(ref ret_ty) = method.pe_fn_decl().output {\n+        if let ast::Return(ref ret_ty) = method.pe_sig().decl.output {\n             self.visit_ty(&**ret_ty);\n         }\n \n         // walk the fn body\n         self.nest(id, |v| v.visit_block(&*method.pe_body()));\n \n-        self.process_generic_params(method.pe_generics(),\n+        self.process_generic_params(&method.pe_sig().generics,\n                                     span,\n                                     qualname,\n                                     id);"}, {"sha": "11495c7e6a37a8f41b9bcc6ec4f5e7840fc42e4f", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -1292,7 +1292,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match item.node {\n                 ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, &**fn_decl, generics, &**top_level_block, item.span, true)\n+                    (item.ident, fn_decl, generics, &**top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -1308,8 +1308,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     }\n \n                     (impl_item.ident,\n-                     method.pe_fn_decl(),\n-                     method.pe_generics(),\n+                     &method.pe_sig().decl,\n+                     &method.pe_sig().generics,\n                      method.pe_body(),\n                      impl_item.span,\n                      true)\n@@ -1326,7 +1326,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(&name[..]);\n-                    (name, &**fn_decl,\n+                    (name, fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n                         &empty_generics,\n@@ -1347,8 +1347,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     }\n \n                     (trait_item.ident,\n-                     method.pe_fn_decl(),\n-                     method.pe_generics(),\n+                     &method.pe_sig().decl,\n+                     &method.pe_sig().generics,\n                      method.pe_body(),\n                      trait_item.span,\n                      true)"}, {"sha": "eacc40edcc662b459763244da3821ad9faae9c43", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -149,11 +149,11 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             if let ast::MethodImplItem(ref mth) = impl_item.node {\n                 let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n-                        mth.pe_generics().ty_params.is_empty() {\n+                        mth.pe_sig().generics.ty_params.is_empty() {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     let llfn = get_item_val(ccx, impl_item.id);\n                     trans_fn(ccx,\n-                            &*mth.pe_fn_decl(),\n+                            &*mth.pe_sig().decl,\n                             &*mth.pe_body(),\n                             llfn,\n                             empty_substs,"}, {"sha": "8df086fd232a5d96ad22206c862dde8c3a4f9c1d", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -80,13 +80,13 @@ pub fn trans_impl(ccx: &CrateContext,\n     for impl_item in impl_items {\n         match impl_item.node {\n             ast::MethodImplItem(ref method) => {\n-                if method.pe_generics().ty_params.len() == 0 {\n+                if method.pe_sig().generics.ty_params.len() == 0 {\n                     let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, impl_item.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                         trans_fn(ccx,\n-                                 method.pe_fn_decl(),\n+                                 &method.pe_sig().decl,\n                                  method.pe_body(),\n                                  llfn,\n                                  empty_substs,"}, {"sha": "80271a72c6859b0f25cdb06c287418da59668d90", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -223,7 +223,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     let needs_body = setup_lldecl(d, &impl_item.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n-                                 mth.pe_fn_decl(),\n+                                 &mth.pe_sig().decl,\n                                  mth.pe_body(),\n                                  d,\n                                  psubsts,\n@@ -243,7 +243,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, &trait_item.attrs);\n                     if needs_body {\n-                        trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n+                        trans_fn(ccx, &mth.pe_sig().decl, mth.pe_body(), d,\n                                  psubsts, trait_item.id, &[]);\n                     }\n                     d"}, {"sha": "28e7027b2124a2e2135e7d0b4007851de08b46ff", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -1442,22 +1442,19 @@ struct SelfInfo<'a, 'tcx> {\n }\n \n pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n-                          unsafety: ast::Unsafety,\n-                          untransformed_self_ty: Ty<'tcx>,\n-                          explicit_self: &ast::ExplicitSelf,\n-                          decl: &ast::FnDecl,\n-                          abi: abi::Abi)\n+                          sig: &ast::MethodSig,\n+                          untransformed_self_ty: Ty<'tcx>)\n                           -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n-        explicit_self: explicit_self,\n+        explicit_self: &sig.explicit_self,\n     });\n     let (bare_fn_ty, optional_explicit_self_category) =\n         ty_of_method_or_bare_fn(this,\n-                                unsafety,\n-                                abi,\n+                                sig.unsafety,\n+                                sig.abi,\n                                 self_info,\n-                                decl);\n+                                &sig.decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n "}, {"sha": "470e1d54c7f7745ee22cc204adf335948146d06d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -867,7 +867,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n-                  &*method.pe_fn_decl(),\n+                  &*method.pe_sig().decl,\n                   &*method.pe_body(),\n                   id,\n                   span,"}, {"sha": "a2ca228b11a9418c292f6d4f0bc34486c0f9edee", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 121, "deletions": 288, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -621,152 +621,52 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                   trait_id: ast::NodeId,\n-                                   trait_def: &ty::TraitDef<'tcx>,\n-                                   trait_predicates: &ty::GenericPredicates<'tcx>) {\n-    let tcx = ccx.tcx;\n-    if let ast_map::NodeItem(item) = tcx.map.get(trait_id) {\n-        if let ast::ItemTrait(_, _, _, ref trait_items) = item.node {\n-            // For each method, construct a suitable ty::Method and\n-            // store it into the `tcx.impl_or_trait_items` table:\n-            for trait_item in trait_items {\n-                match trait_item.node {\n-                    ast::RequiredMethod(_) |\n-                    ast::ProvidedMethod(_) => {\n-                        let ty_method = Rc::new(match trait_item.node {\n-                            ast::RequiredMethod(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &trait_predicates,\n-                                    trait_item.id,\n-                                    trait_item.ident,\n-                                    &m.explicit_self,\n-                                    m.abi,\n-                                    &m.generics,\n-                                    &m.unsafety,\n-                                    &*m.decl)\n-                            }\n-                            ast::ProvidedMethod(ref m) => {\n-                                ty_method_of_trait_method(\n-                                    ccx,\n-                                    trait_id,\n-                                    &trait_def.generics,\n-                                    &trait_predicates,\n-                                    trait_item.id,\n-                                    trait_item.ident,\n-                                    m.pe_explicit_self(),\n-                                    m.pe_abi(),\n-                                    m.pe_generics(),\n-                                    &m.pe_unsafety(),\n-                                    &*m.pe_fn_decl())\n-                            }\n-                            ast::TypeTraitItem(..) => unreachable!()\n-                        });\n-\n-                        debug!(\"ty_method_of_trait_method yielded {} for method {} of trait {}\",\n-                               ty_method.repr(ccx.tcx),\n-                               trait_item.repr(ccx.tcx),\n-                               local_def(trait_id).repr(ccx.tcx));\n-\n-                        make_method_ty(ccx, &*ty_method);\n-\n-                        tcx.impl_or_trait_items\n-                            .borrow_mut()\n-                            .insert(ty_method.def_id, ty::MethodTraitItem(ty_method));\n-                    }\n-                    ast::TypeTraitItem(..) => {\n-                        let trait_did = local_def(trait_id);\n-                        let associated_type = ty::AssociatedType {\n-                            name: trait_item.ident.name,\n-                            vis: ast::Public,\n-                            def_id: local_def(trait_item.id),\n-                            container: TraitContainer(trait_did),\n-                        };\n-\n-                        let trait_item = ty::TypeTraitItem(Rc::new(associated_type));\n-                        tcx.impl_or_trait_items\n-                            .borrow_mut()\n-                            .insert(associated_type.def_id, trait_item);\n-                    }\n-                }\n-            }\n-\n-            // Add an entry mapping\n-            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n-                let def_id = local_def(trait_item.id);\n-                match trait_item.node {\n-                    ast::RequiredMethod(_) |\n-                    ast::ProvidedMethod(_) => {\n-                        ty::MethodTraitItemId(def_id)\n-                    }\n-                    ast::TypeTraitItem(..) => {\n-                        ty::TypeTraitItemId(def_id)\n-                    }\n-                }\n-            }).collect());\n+fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                            container: ImplOrTraitItemContainer,\n+                            sig: &ast::MethodSig,\n+                            id: ast::NodeId,\n+                            ident: ast::Ident,\n+                            vis: ast::Visibility,\n+                            untransformed_rcvr_ty: Ty<'tcx>,\n+                            rcvr_ty_generics: &ty::Generics<'tcx>,\n+                            rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n+    let ty_generics = ty_generics_for_fn(ccx, &sig.generics, rcvr_ty_generics);\n+\n+    let ty_generic_predicates =\n+        ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n+\n+    let (fty, explicit_self_category) =\n+        astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                              sig, untransformed_rcvr_ty);\n+\n+    let def_id = local_def(id);\n+    let ty_method = ty::Method::new(ident.name,\n+                                    ty_generics,\n+                                    ty_generic_predicates,\n+                                    fty,\n+                                    explicit_self_category,\n+                                    vis,\n+                                    def_id,\n+                                    container,\n+                                    None);\n+\n+    let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n+                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n+    debug!(\"method {} (id {}) has type {}\",\n+            ident.repr(ccx.tcx), id, fty.repr(ccx.tcx));\n+    ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n+        generics: ty_method.generics.clone(),\n+        ty: fty\n+    });\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, ty_method.predicates.clone());\n \n-            let trait_def_id = local_def(trait_id);\n-            tcx.trait_item_def_ids.borrow_mut().insert(trait_def_id, trait_item_def_ids);\n-        }\n-    }\n+    write_ty_to_tcx(ccx.tcx, id, fty);\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n-        ccx.tcx.tcache.borrow_mut().insert(\n-            m.def_id,\n-            TypeScheme {\n-                generics: m.generics.clone(),\n-                ty: ty::mk_bare_fn(ccx.tcx, Some(m.def_id), ccx.tcx.mk_bare_fn(m.fty.clone()))\n-            });\n-        ccx.tcx.predicates.borrow_mut().insert(\n-            m.def_id,\n-            m.predicates.clone());\n-    }\n+    debug!(\"writing method type: def_id={:?} mty={}\",\n+            def_id, ty_method.repr(ccx.tcx));\n \n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                           trait_id: ast::NodeId,\n-                                           trait_generics: &ty::Generics<'tcx>,\n-                                           trait_bounds: &ty::GenericPredicates<'tcx>,\n-                                           m_id: ast::NodeId,\n-                                           m_ident: ast::Ident,\n-                                           m_explicit_self: &ast::ExplicitSelf,\n-                                           m_abi: abi::Abi,\n-                                           m_generics: &ast::Generics,\n-                                           m_unsafety: &ast::Unsafety,\n-                                           m_decl: &ast::FnDecl)\n-                                           -> ty::Method<'tcx>\n-    {\n-        let ty_generics =\n-            ty_generics_for_fn(ccx, m_generics, trait_generics);\n-\n-        let ty_generic_predicates =\n-            ty_generic_predicates_for_fn(ccx, m_generics, trait_bounds);\n-\n-        let (fty, explicit_self_category) = {\n-            let trait_self_ty = ty::mk_self_type(ccx.tcx);\n-            astconv::ty_of_method(&ccx.icx(&(trait_bounds, m_generics)),\n-                                  *m_unsafety,\n-                                  trait_self_ty,\n-                                  m_explicit_self,\n-                                  m_decl,\n-                                  m_abi)\n-        };\n-\n-        ty::Method::new(\n-            m_ident.name,\n-            ty_generics,\n-            ty_generic_predicates,\n-            fty,\n-            explicit_self_category,\n-            // assume public, because this is only invoked on trait methods\n-            ast::Public,\n-            local_def(m_id),\n-            TraitContainer(local_def(trait_id)),\n-            None\n-        )\n-    }\n+    ccx.tcx.impl_or_trait_items.borrow_mut().insert(def_id,\n+        ty::MethodTraitItem(Rc::new(ty_method)));\n }\n \n fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -809,30 +709,28 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                     trait_def: &ty::TraitDef<'tcx>,\n+                                     container: ImplOrTraitItemContainer,\n                                      ident: ast::Ident,\n-                                     id: ast::NodeId)\n+                                     id: ast::NodeId,\n+                                     vis: ast::Visibility)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: ident.name,\n-        vis: ast::Public,\n+        vis: vis,\n         def_id: local_def(id),\n-        container: TraitContainer(trait_def.trait_ref.def_id),\n+        container: container\n     });\n-    ccx.tcx\n-       .impl_or_trait_items\n-       .borrow_mut()\n-       .insert(associated_type.def_id, ty::TypeTraitItem(associated_type));\n+    ccx.tcx.impl_or_trait_items.borrow_mut()\n+       .insert(local_def(id), ty::TypeTraitItem(associated_type));\n }\n \n fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n                                  methods: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n-                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n-                                 rcvr_visibility: ast::Visibility)\n-    where I: Iterator<Item=(&'i ast::Method, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n+                                 rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n+    where I: Iterator<Item=(&'i ast::MethodSig, ast::NodeId, ast::Ident, ast::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -841,87 +739,20 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n-    for (m, id, ident, vis, span) in methods {\n+    for (sig, id, ident, vis, span) in methods {\n         if !seen_methods.insert(ident.name) {\n-            span_err!(tcx.sess, span, E0201, \"duplicate method in trait impl\");\n+            span_err!(tcx.sess, span, E0201, \"duplicate method\");\n         }\n \n-        let m_def_id = local_def(id);\n-\n-        let mty = Rc::new(ty_of_method(ccx,\n-                                       container,\n-                                       m,\n-                                       id,\n-                                       ident,\n-                                       vis,\n-                                       untransformed_rcvr_ty,\n-                                       rcvr_ty_generics,\n-                                       rcvr_ty_predicates,\n-                                       rcvr_visibility));\n-        let fty = ty::mk_bare_fn(tcx, Some(m_def_id), tcx.mk_bare_fn(mty.fty.clone()));\n-        debug!(\"method {} (id {}) has type {}\",\n-                ident.repr(tcx),\n-                id,\n-                fty.repr(tcx));\n-        tcx.tcache.borrow_mut().insert(\n-            m_def_id,\n-            TypeScheme {\n-                generics: mty.generics.clone(),\n-                ty: fty\n-            });\n-        tcx.predicates.borrow_mut().insert(m_def_id, mty.predicates.clone());\n-\n-        write_ty_to_tcx(tcx, id, fty);\n-\n-        debug!(\"writing method type: def_id={:?} mty={}\",\n-               mty.def_id, mty.repr(ccx.tcx));\n-\n-        tcx.impl_or_trait_items\n-           .borrow_mut()\n-           .insert(mty.def_id, ty::MethodTraitItem(mty));\n-    }\n-\n-    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                              container: ImplOrTraitItemContainer,\n-                              m: &ast::Method,\n-                              id: ast::NodeId,\n-                              ident: ast::Ident,\n-                              vis: ast::Visibility,\n-                              untransformed_rcvr_ty: Ty<'tcx>,\n-                              rcvr_ty_generics: &ty::Generics<'tcx>,\n-                              rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n-                              rcvr_visibility: ast::Visibility)\n-                              -> ty::Method<'tcx>\n-    {\n-        let m_ty_generics =\n-            ty_generics_for_fn(ccx, m.pe_generics(), rcvr_ty_generics);\n-\n-        let m_ty_generic_predicates =\n-            ty_generic_predicates_for_fn(ccx, m.pe_generics(), rcvr_ty_predicates);\n-\n-        let (fty, explicit_self_category) =\n-            astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, m.pe_generics())),\n-                                  m.pe_unsafety(),\n-                                  untransformed_rcvr_ty,\n-                                  m.pe_explicit_self(),\n-                                  &*m.pe_fn_decl(),\n-                                  m.pe_abi());\n-\n-        // if the method specifies a visibility, use that, otherwise\n-        // inherit the visibility from the impl (so `foo` in `pub impl\n-        // { fn foo(); }` is public, but private in `priv impl { fn\n-        // foo(); }`).\n-        let method_vis = vis.inherit_from(rcvr_visibility);\n-\n-        ty::Method::new(ident.name,\n-                        m_ty_generics,\n-                        m_ty_generic_predicates,\n-                        fty,\n-                        explicit_self_category,\n-                        method_vis,\n-                        local_def(id),\n-                        container,\n-                        None)\n+        convert_method(ccx,\n+                       container,\n+                       sig,\n+                       id,\n+                       ident,\n+                       vis,\n+                       untransformed_rcvr_ty,\n+                       rcvr_ty_generics,\n+                       rcvr_ty_predicates);\n     }\n }\n \n@@ -1013,6 +844,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n+            // Convert all the associated types.\n             for impl_item in impl_items {\n                 match impl_item.node {\n                     ast::MethodImplItem(_) => {}\n@@ -1022,6 +854,9 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n+                        convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                                                impl_item.ident, impl_item.id, impl_item.vis);\n+\n                         let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n                         tcx.tcache.borrow_mut().insert(local_def(impl_item.id),\n                                                        TypeScheme {\n@@ -1031,25 +866,19 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                         tcx.predicates.borrow_mut().insert(local_def(impl_item.id),\n                                                            ty::GenericPredicates::empty());\n                         write_ty_to_tcx(tcx, impl_item.id, typ);\n-\n-                        let associated_type = Rc::new(ty::AssociatedType {\n-                            name: impl_item.ident.name,\n-                            vis: impl_item.vis,\n-                            def_id: local_def(impl_item.id),\n-                            container: ty::ImplContainer(local_def(it.id)),\n-                        });\n-                        tcx.impl_or_trait_items\n-                           .borrow_mut()\n-                           .insert(local_def(impl_item.id),\n-                                   ty::TypeTraitItem(associated_type));\n                     }\n                 }\n             }\n \n             let methods = impl_items.iter().filter_map(|ii| {\n                 match ii.node {\n                     ast::MethodImplItem(ref m) => {\n-                        Some((m, ii.id, ii.ident, ii.vis, ii.span))\n+                        // if the method specifies a visibility, use that, otherwise\n+                        // inherit the visibility from the impl (so `foo` in `pub impl\n+                        // { fn foo(); }` is public, but private in `priv impl { fn\n+                        // foo(); }`).\n+                        let method_vis = ii.vis.inherit_from(parent_visibility);\n+                        Some((m.pe_sig(), ii.id, ii.ident, method_vis, ii.span))\n                     }\n                     ast::TypeImplItem(_) => None\n                 }\n@@ -1059,8 +888,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                             methods,\n                             selfty,\n                             &ty_generics,\n-                            &ty_predicates,\n-                            parent_visibility);\n+                            &ty_predicates);\n \n             for impl_item in impl_items {\n                 match impl_item.node {\n@@ -1070,7 +898,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                                &BindingRscope::new(),\n                                                ccx.method_ty(impl_item.id),\n                                                selfty,\n-                                               method.pe_explicit_self(),\n+                                               &method.pe_sig().explicit_self,\n                                                body_id);\n                     }\n                     ast::TypeImplItem(_) => {}\n@@ -1095,63 +923,68 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n-            let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n+            let trait_predicates = ty::lookup_predicates(tcx, local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n-            let methods = trait_items.iter().filter_map(|ti| {\n-                match ti.node {\n-                    ast::ProvidedMethod(ref m) => {\n-                        Some((m, ti.id, ti.ident, ast::Inherited, ti.span))\n-                    }\n+            // Convert all the associated types.\n+            for trait_item in trait_items {\n+                match trait_item.node {\n                     ast::RequiredMethod(_) |\n-                    ast::TypeTraitItem(..) => None,\n+                    ast::ProvidedMethod(_) => {}\n+                    ast::TypeTraitItem(..) => {\n+                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                                                trait_item.ident, trait_item.id, ast::Public);\n+                    }\n                 }\n+            };\n+\n+            let methods = trait_items.iter().filter_map(|ti| {\n+                let sig = match ti.node {\n+                    ast::RequiredMethod(ref sig) => sig,\n+                    ast::ProvidedMethod(ref m) => m.pe_sig(),\n+                    ast::TypeTraitItem(..) => return None,\n+                };\n+                Some((sig, ti.id, ti.ident, ast::Inherited, ti.span))\n             });\n-            // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n+\n+            // Run convert_methods on the trait methods.\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n                             methods,\n-                            untransformed_rcvr_ty,\n+                            ty::mk_self_type(tcx),\n                             &trait_def.generics,\n-                            &trait_predicates,\n-                            it.vis);\n-\n-            // We need to do this *after* converting methods, since\n-            // convert_methods produces a tcache entry that is wrong for\n-            // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n+                            &trait_predicates);\n \n-            // This must be done after `collect_trait_methods` so that\n-            // we have a method type stored for every method.\n-            for trait_item in trait_items {\n-                let self_type = ty::mk_self_type(tcx);\n+            // Add an entry mapping\n+            let trait_item_def_ids = Rc::new(trait_items.iter().map(|trait_item| {\n+                let def_id = local_def(trait_item.id);\n                 match trait_item.node {\n-                    ast::RequiredMethod(ref type_method) => {\n-                        let rscope = BindingRscope::new();\n-                        check_method_self_type(ccx,\n-                                               &rscope,\n-                                               ccx.method_ty(trait_item.id),\n-                                               self_type,\n-                                               &type_method.explicit_self,\n-                                               it.id)\n-                    }\n-                    ast::ProvidedMethod(ref method) => {\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               ccx.method_ty(trait_item.id),\n-                                               self_type,\n-                                               method.pe_explicit_self(),\n-                                               it.id)\n+                    ast::RequiredMethod(_) |\n+                    ast::ProvidedMethod(_) => {\n+                        ty::MethodTraitItemId(def_id)\n                     }\n                     ast::TypeTraitItem(..) => {\n-                        convert_associated_type(ccx,\n-                                                &*trait_def,\n-                                                trait_item.ident,\n-                                                trait_item.id);\n+                        ty::TypeTraitItemId(def_id)\n                     }\n                 }\n+            }).collect());\n+            tcx.trait_item_def_ids.borrow_mut().insert(local_def(it.id), trait_item_def_ids);\n+\n+            // This must be done after `collect_trait_methods` so that\n+            // we have a method type stored for every method.\n+            for trait_item in trait_items {\n+                let sig = match trait_item.node {\n+                    ast::RequiredMethod(ref sig) => sig,\n+                    ast::ProvidedMethod(ref method) => method.pe_sig(),\n+                    ast::TypeTraitItem(..) => continue\n+                };\n+                check_method_self_type(ccx,\n+                                       &BindingRscope::new(),\n+                                       ccx.method_ty(trait_item.id),\n+                                       ty::mk_self_type(tcx),\n+                                       &sig.explicit_self,\n+                                       it.id)\n             }\n         },\n         ast::ItemStruct(ref struct_def, _) => {"}, {"sha": "05139bf1eab9199ed013d50c33d4fefad9cfb2ca", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -951,24 +951,24 @@ pub struct Method {\n \n impl Clean<Method> for ast::Method {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let all_inputs = &self.pe_fn_decl().inputs;\n-        let inputs = match self.pe_explicit_self().node {\n+        let all_inputs = &self.pe_sig().decl.inputs;\n+        let inputs = match self.pe_sig().explicit_self.node {\n             ast::SelfStatic => &**all_inputs,\n             _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n                 values: inputs.clean(cx),\n             },\n-            output: self.pe_fn_decl().output.clean(cx),\n+            output: self.pe_sig().decl.output.clean(cx),\n             attrs: Vec::new()\n         };\n         Method {\n-            generics: self.pe_generics().clean(cx),\n-            self_: self.pe_explicit_self().node.clean(cx),\n-            unsafety: self.pe_unsafety().clone(),\n+            generics: self.pe_sig().generics.clean(cx),\n+            self_: self.pe_sig().explicit_self.node.clean(cx),\n+            unsafety: self.pe_sig().unsafety.clone(),\n             decl: decl,\n-            abi: self.pe_abi()\n+            abi: self.pe_sig().abi\n         }\n     }\n }\n@@ -982,7 +982,7 @@ pub struct TyMethod {\n     pub abi: abi::Abi\n }\n \n-impl Clean<TyMethod> for ast::TypeMethod {\n+impl Clean<TyMethod> for ast::MethodSig {\n     fn clean(&self, cx: &DocContext) -> TyMethod {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => &*self.decl.inputs,"}, {"sha": "0a08b0b12072fbd949469d773783bc3cd524d430", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -1058,10 +1058,10 @@ pub struct TypeField {\n     pub span: Span,\n }\n \n-/// Represents a required method in a trait declaration,\n-/// one without a default implementation\n+/// Represents a method's signature in a trait declaration,\n+/// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeMethod {\n+pub struct MethodSig {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n@@ -1084,7 +1084,7 @@ pub struct TraitItem {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem_ {\n-    RequiredMethod(TypeMethod),\n+    RequiredMethod(MethodSig),\n     ProvidedMethod(Method),\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n@@ -1419,12 +1419,7 @@ pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Method {\n     /// Represents a method declaration\n-    MethDecl(Generics,\n-             Abi,\n-             ExplicitSelf,\n-             Unsafety,\n-             P<FnDecl>,\n-             P<Block>),\n+    MethDecl(MethodSig, P<Block>),\n     /// Represents a macro in method position\n     MethMac(Mac),\n }"}, {"sha": "345ccf902cd8a42db8b27891e76e19481a9fd3e1", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -162,7 +162,7 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn decl(self) -> &'a FnDecl {\n         self.handle(|i: ItemFnParts<'a>|  &*i.decl,\n-                    |_, _, m: &'a ast::Method, _|  m.pe_fn_decl(),\n+                    |_, _, m: &'a ast::Method, _|  &m.pe_sig().decl,\n                     |c: ClosureParts<'a>| c.decl)\n     }\n "}, {"sha": "91ddc8beec81c9b79e7336f912e8eb57a9e3b0f1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::Abi;\n use ast::*;\n use ast;\n use ast_util;\n@@ -461,7 +460,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n                 self.visit_generics_helper(generics)\n             }\n             visit::FkMethod(_, m) => {\n-                self.visit_generics_helper(m.pe_generics())\n+                self.visit_generics_helper(&m.pe_sig().generics)\n             }\n             visit::FkFnBlock => {}\n         }\n@@ -653,11 +652,7 @@ pub fn lit_is_str(lit: &Lit) -> bool {\n /// not a macro invocation. This check is guaranteed to succeed, assuming\n /// that the invocations are indeed gone.\n pub trait PostExpansionMethod {\n-    fn pe_generics<'a>(&'a self) -> &'a ast::Generics;\n-    fn pe_abi(&self) -> Abi;\n-    fn pe_explicit_self<'a>(&'a self) -> &'a ast::ExplicitSelf;\n-    fn pe_unsafety(&self) -> ast::Unsafety;\n-    fn pe_fn_decl<'a>(&'a self) -> &'a ast::FnDecl;\n+    fn pe_sig<'a>(&'a self) -> &'a ast::MethodSig;\n     fn pe_body<'a>(&'a self) -> &'a ast::Block;\n }\n \n@@ -676,18 +671,8 @@ macro_rules! mf_method{\n \n \n impl PostExpansionMethod for Method {\n-    mf_method! {\n-        pe_generics,&'a ast::Generics,\n-        MethDecl(ref generics,_,_,_,_,_),generics\n-    }\n-    mf_method! { pe_abi,Abi,MethDecl(_,abi,_,_,_,_),abi }\n-    mf_method! {\n-        pe_explicit_self,&'a ast::ExplicitSelf,\n-        MethDecl(_,_,ref explicit_self,_,_,_),explicit_self\n-    }\n-    mf_method! { pe_unsafety,ast::Unsafety,MethDecl(_,_,_,unsafety,_,_),unsafety }\n-    mf_method! { pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,ref decl,_),&**decl }\n-    mf_method! { pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,ref body),&**body }\n+    mf_method! { pe_sig, &'a ast::MethodSig,MethDecl(ref sig, _), sig }\n+    mf_method! { pe_body, &'a ast::Block,MethDecl(_, ref body), body }\n }\n \n #[cfg(test)]"}, {"sha": "d4b0f7d1dcb8582ff1822662a51f05bdcf14100e", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -724,13 +724,13 @@ impl<'a> MethodDef<'a> {\n             span: trait_.span,\n             vis: ast::Inherited,\n             ident: method_ident,\n-            node: ast::MethodImplItem(\n-                ast::MethDecl(fn_generics,\n-                              abi,\n-                              explicit_self,\n-                              ast::Unsafety::Normal,\n-                              fn_decl,\n-                              body_block))\n+            node: ast::MethodImplItem(ast::MethDecl(ast::MethodSig {\n+                generics: fn_generics,\n+                abi: abi,\n+                explicit_self: explicit_self,\n+                unsafety: ast::Unsafety::Normal,\n+                decl: fn_decl\n+            }, body_block))\n         })\n     }\n "}, {"sha": "fa0b747f45b992205729eb5ca56d88a29a734f82", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -1393,15 +1393,16 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n \n     fn fold_method(&mut self, m: ast::Method) -> ast::Method {\n         match m {\n-            ast::MethDecl(generics, abi, explicit_self, fn_style, decl, body) => {\n+            ast::MethDecl(sig, body) => {\n                 let (rewritten_fn_decl, rewritten_body)\n-                    = expand_and_rename_fn_decl_and_block(decl, body, self);\n-                ast::MethDecl(self.fold_generics(generics),\n-                              abi,\n-                              self.fold_explicit_self(explicit_self),\n-                              fn_style,\n-                              rewritten_fn_decl,\n-                              rewritten_body)\n+                    = expand_and_rename_fn_decl_and_block(sig.decl, body, self);\n+                ast::MethDecl(ast::MethodSig {\n+                    generics: self.fold_generics(sig.generics),\n+                    abi: sig.abi,\n+                    explicit_self: self.fold_explicit_self(sig.explicit_self),\n+                    unsafety: sig.unsafety,\n+                    decl: rewritten_fn_decl\n+                }, rewritten_body)\n             }\n             ast::MethMac(mac) => ast::MethMac(mac)\n         }"}, {"sha": "d7982ef839969dae6fbb5fc294c422a97a9ccafe", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -977,15 +977,7 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n-            RequiredMethod(TypeMethod { unsafety, abi, decl, generics, explicit_self }) => {\n-                RequiredMethod(TypeMethod {\n-                    unsafety: unsafety,\n-                    abi: abi,\n-                    decl: folder.fold_fn_decl(decl),\n-                    generics: folder.fold_generics(generics),\n-                    explicit_self: folder.fold_explicit_self(explicit_self)\n-                })\n-            }\n+            RequiredMethod(sig) => RequiredMethod(noop_fold_method_sig(sig, folder)),\n             ProvidedMethod(m) => ProvidedMethod(folder.fold_method(m)),\n             TypeTraitItem(bounds, default) => {\n                 TypeTraitItem(folder.fold_bounds(bounds),\n@@ -1110,23 +1102,24 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) ->\n // Default fold over a method.\n pub fn noop_fold_method<T: Folder>(method: Method, folder: &mut T) -> Method {\n     match method {\n-        MethDecl(generics,\n-                 abi,\n-                 explicit_self,\n-                 unsafety,\n-                 decl,\n-                 body) => {\n-            MethDecl(folder.fold_generics(generics),\n-                     abi,\n-                     folder.fold_explicit_self(explicit_self),\n-                     unsafety,\n-                     folder.fold_fn_decl(decl),\n+        MethDecl(sig, body) => {\n+            MethDecl(noop_fold_method_sig(sig, folder),\n                      folder.fold_block(body))\n         },\n         MethMac(mac) => MethMac(folder.fold_mac(mac))\n     }\n }\n \n+pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n+    MethodSig {\n+        generics: folder.fold_generics(sig.generics),\n+        abi: sig.abi,\n+        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n+        unsafety: sig.unsafety,\n+        decl: folder.fold_fn_decl(sig.decl)\n+    }\n+}\n+\n pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     p.map(|Pat {id, node, span}| Pat {\n         id: folder.new_id(id),"}, {"sha": "2e77bd6df1886f4d7334bb15bda874a5f3399291", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -51,8 +51,7 @@ use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n-use ast::{TyFixedLengthVec, TyBareFn};\n-use ast::{TyTypeof, TyInfer, TypeMethod};\n+use ast::{TyFixedLengthVec, TyBareFn, TyTypeof, TyInfer};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem};\n@@ -1341,31 +1340,27 @@ impl<'a> Parser<'a> {\n                 });\n \n                 p.parse_where_clause(&mut generics);\n+                let sig = ast::MethodSig {\n+                    unsafety: style,\n+                    decl: d,\n+                    generics: generics,\n+                    abi: abi,\n+                    explicit_self: explicit_self,\n+                };\n \n                 let hi = p.last_span.hi;\n                 let node = match p.token {\n                   token::Semi => {\n                     p.bump();\n                     debug!(\"parse_trait_methods(): parsing required method\");\n-                    RequiredMethod(TypeMethod {\n-                        unsafety: style,\n-                        decl: d,\n-                        generics: generics,\n-                        abi: abi,\n-                        explicit_self: explicit_self,\n-                    })\n+                    RequiredMethod(sig)\n                   }\n                   token::OpenDelim(token::Brace) => {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     attrs.push_all(&inner_attrs[..]);\n-                    ProvidedMethod(ast::MethDecl(generics,\n-                                                 abi,\n-                                                 explicit_self,\n-                                                 style,\n-                                                 d,\n-                                                 body))\n+                    ProvidedMethod(ast::MethDecl(sig, body))\n                   }\n \n                   _ => {\n@@ -4758,13 +4753,13 @@ impl<'a> Parser<'a> {\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n                 new_attrs.push_all(&inner_attrs[..]);\n-                (ast::MethDecl(generics,\n-                               abi,\n-                               explicit_self,\n-                               unsafety,\n-                               decl,\n-                               body),\n-                 body_span.hi, new_attrs, ident)\n+                (ast::MethDecl(ast::MethodSig {\n+                    generics: generics,\n+                    abi: abi,\n+                    explicit_self: explicit_self,\n+                    unsafety: unsafety,\n+                    decl: decl\n+                 }, body), body_span.hi, new_attrs, ident)\n             }\n         };\n         P(ImplItem {"}, {"sha": "20c8df4299304b02e542d8399e464149bd5ff12e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 43, "deletions": 64, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -375,8 +375,9 @@ pub fn fun_to_string(decl: &ast::FnDecl, unsafety: ast::Unsafety, name: ast::Ide\n                   opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> String {\n     $to_string(|s| {\n-        try!(s.print_fn(decl, Some(unsafety), abi::Rust,\n-                        name, generics, opt_explicit_self, ast::Inherited));\n+        try!(s.head(\"\"));\n+        try!(s.print_fn(decl, unsafety, abi::Rust, Some(name),\n+                        generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -759,8 +760,10 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&item.attrs));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n-                try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n-                                   None, item.vis));\n+                try!(self.head(\"\"));\n+                try!(self.print_fn(&**decl, ast::Unsafety::Normal,\n+                                   abi::Rust, Some(item.ident),\n+                                   generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n                 self.end() // end the outer fn box\n@@ -861,11 +864,12 @@ impl<'a> State<'a> {\n                 try!(self.end()); // end the outer cbox\n             }\n             ast::ItemFn(ref decl, unsafety, abi, ref typarams, ref body) => {\n+                try!(self.head(\"\"));\n                 try!(self.print_fn(\n-                    &**decl,\n-                    Some(unsafety),\n+                    decl,\n+                    unsafety,\n                     abi,\n-                    item.ident,\n+                    Some(item.ident),\n                     typarams,\n                     None,\n                     item.vis\n@@ -1227,17 +1231,18 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ty_method(&mut self,\n-                           ident: ast::Ident,\n-                           m: &ast::TypeMethod)\n-                           -> io::Result<()> {\n-        try!(self.print_ty_fn(m.abi,\n-                              m.unsafety,\n-                              &*m.decl,\n-                              Some(ident),\n-                              &m.generics,\n-                              Some(&m.explicit_self.node)));\n-        word(&mut self.s, \";\")\n+    pub fn print_method_sig(&mut self,\n+                            ident: ast::Ident,\n+                            m: &ast::MethodSig,\n+                            vis: ast::Visibility)\n+                            -> io::Result<()> {\n+        self.print_fn(&m.decl,\n+                      m.unsafety,\n+                      m.abi,\n+                      Some(ident),\n+                      &m.generics,\n+                      Some(&m.explicit_self.node),\n+                      vis)\n     }\n \n     pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n@@ -1246,8 +1251,9 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n-            ast::RequiredMethod(ref ty_m) => {\n-                self.print_ty_method(ti.ident, ty_m)\n+            ast::RequiredMethod(ref sig) => {\n+                try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n+                word(&mut self.s, \";\")\n             }\n             ast::ProvidedMethod(ref m) => {\n                 self.print_method(ti.ident, &ti.attrs, ast::Inherited, m)\n@@ -1280,20 +1286,10 @@ impl<'a> State<'a> {\n                         meth: &ast::Method)\n                         -> io::Result<()> {\n         match *meth {\n-            ast::MethDecl(ref generics,\n-                          abi,\n-                          ref explicit_self,\n-                          unsafety,\n-                          ref decl,\n-                          ref body) => {\n-                try!(self.print_fn(&**decl,\n-                                   Some(unsafety),\n-                                   abi,\n-                                   ident,\n-                                   generics,\n-                                   Some(&explicit_self.node),\n-                                   vis));\n-                try!(word(&mut self.s, \" \"));\n+            ast::MethDecl(ref sig, ref body) => {\n+                try!(self.head(\"\"));\n+                try!(self.print_method_sig(ident, sig, vis));\n+                try!(self.nbsp());\n                 self.print_block_with_attrs(&**body, attrs)\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n@@ -2328,16 +2324,18 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    unsafety: Option<ast::Unsafety>,\n+                    unsafety: ast::Unsafety,\n                     abi: abi::Abi,\n-                    name: ast::Ident,\n+                    name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> io::Result<()> {\n-        try!(self.head(\"\"));\n         try!(self.print_fn_header_info(unsafety, abi, vis));\n-        try!(self.nbsp());\n-        try!(self.print_ident(name));\n+\n+        if let Some(name) = name {\n+            try!(self.nbsp());\n+            try!(self.print_ident(name));\n+        }\n         try!(self.print_generics(generics));\n         try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n         self.print_where_clause(generics)\n@@ -2704,25 +2702,14 @@ impl<'a> State<'a> {\n                        abi: abi::Abi,\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n-                       id: Option<ast::Ident>,\n+                       name: Option<ast::Ident>,\n                        generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n-        try!(self.print_fn_header_info(Some(unsafety), abi, ast::Inherited));\n-\n-        match id {\n-            Some(id) => {\n-                try!(word(&mut self.s, \" \"));\n-                try!(self.print_ident(id));\n-            }\n-            _ => ()\n-        }\n-\n-        try!(self.print_generics(generics));\n-        try!(zerobreak(&mut self.s));\n-        try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n-        try!(self.print_where_clause(generics));\n+        try!(self.print_fn(decl, unsafety, abi, name,\n+                           generics, opt_explicit_self,\n+                           ast::Inherited));\n         self.end()\n     }\n \n@@ -2944,14 +2931,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_unsafety(&mut self,\n-                            opt_unsafety: Option<ast::Unsafety>) -> io::Result<()> {\n-        match opt_unsafety {\n-            Some(unsafety) => self.print_unsafety(unsafety),\n-            None => Ok(())\n-        }\n-    }\n-\n     pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<abi::Abi>)\n         -> io::Result<()> {\n@@ -2977,11 +2956,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                opt_unsafety: Option<ast::Unsafety>,\n+                                unsafety: ast::Unsafety,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n-        try!(self.print_opt_unsafety(opt_unsafety));\n+        try!(self.print_unsafety(unsafety));\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));"}, {"sha": "4375e17ce0be95bb448ced3b2eebbc01b3008365", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -602,11 +602,11 @@ fn walk_method_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n                                           span: Span,\n                                           method: &'v Method) {\n     match *method {\n-        MethDecl(_, _, _, _, ref decl, ref body) => {\n+        MethDecl(ref sig, ref body) => {\n             visitor.visit_ident(span, ident);\n             visitor.visit_fn(FkMethod(ident, method),\n-                             &**decl,\n-                             &**body,\n+                             &sig.decl,\n+                             body,\n                              span,\n                              id);\n         },\n@@ -627,9 +627,9 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n         }\n         FkMethod(_, method) => {\n             match *method {\n-                MethDecl(ref generics, _, ref explicit_self, _, _, _) => {\n-                    visitor.visit_generics(generics);\n-                    visitor.visit_explicit_self(explicit_self);\n+                MethDecl(ref sig, _) => {\n+                    visitor.visit_generics(&sig.generics);\n+                    visitor.visit_explicit_self(&sig.explicit_self);\n                 }\n                 MethMac(ref mac) => visitor.visit_mac(mac)\n             }\n@@ -646,10 +646,10 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n         visitor.visit_attribute(attr);\n     }\n     match trait_item.node {\n-        RequiredMethod(ref method_type) => {\n-            visitor.visit_explicit_self(&method_type.explicit_self);\n-            visitor.visit_generics(&method_type.generics);\n-            walk_fn_decl(visitor, &method_type.decl);\n+        RequiredMethod(ref sig) => {\n+            visitor.visit_explicit_self(&sig.explicit_self);\n+            visitor.visit_generics(&sig.generics);\n+            walk_fn_decl(visitor, &sig.decl);\n         }\n         ProvidedMethod(ref method) => {\n             walk_method_helper(visitor,"}, {"sha": "3b4def8c5086954ff69b1ee9973c3981d4067c26", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate method in trait impl\n+    fn orange(&self){}   //~ ERROR error: duplicate method\n }\n \n fn main() {}"}, {"sha": "553436607d159ca79a940c3bcb6da3ebb64a4b92", "filename": "src/test/compile-fail/issue-4265.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4265.rs?ref=ce10fa8d12cb20d9eee59fffeeaadfcca8badf4a", "patch": "@@ -17,7 +17,7 @@ impl Foo {\n         Foo { baz: 0 }.bar();\n     }\n \n-    fn bar() { //~ ERROR duplicate method in trait impl\n+    fn bar() { //~ ERROR duplicate method\n     }\n }\n "}]}