{"sha": "881249aa463db43e41e4d5f98d6f71f2970f8965", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MTI0OWFhNDYzZGI0M2U0MWU0ZDVmOThkNmY3MWYyOTcwZjg5NjU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-12T22:23:16Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-20T00:02:53Z"}, "message": "use the FulfillmentContext and InferCtxt more correctly", "tree": {"sha": "459cedb680753e9735642c8d52af53367c9c5355", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/459cedb680753e9735642c8d52af53367c9c5355"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/881249aa463db43e41e4d5f98d6f71f2970f8965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/881249aa463db43e41e4d5f98d6f71f2970f8965", "html_url": "https://github.com/rust-lang/rust/commit/881249aa463db43e41e4d5f98d6f71f2970f8965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/881249aa463db43e41e4d5f98d6f71f2970f8965/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61963ab08a447e62ea3c8f4da35da541f1885b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61963ab08a447e62ea3c8f4da35da541f1885b6", "html_url": "https://github.com/rust-lang/rust/commit/a61963ab08a447e62ea3c8f4da35da541f1885b6"}], "stats": {"total": 194, "additions": 117, "deletions": 77}, "files": [{"sha": "82bd2caaac196d392aba52508893320936c469dd", "filename": "src/librustc/mir/mir_map.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -12,16 +12,22 @@ use util::nodemap::NodeMap;\n use mir::repr::Mir;\n use mir::transform::MirPass;\n use middle::ty;\n+use middle::infer;\n \n pub struct MirMap<'tcx> {\n     pub map: NodeMap<Mir<'tcx>>,\n }\n \n impl<'tcx> MirMap<'tcx> {\n     pub fn run_passes(&mut self, passes: &mut [Box<MirPass>], tcx: &ty::ctxt<'tcx>) {\n-        for (_, ref mut mir) in &mut self.map {\n+        if passes.is_empty() { return; }\n+\n+        for (&id, mir) in &mut self.map {\n+            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+\n             for pass in &mut *passes {\n-                pass.run_on_mir(mir, tcx)\n+                pass.run_on_mir(mir, &infcx)\n             }\n         }\n     }"}, {"sha": "cc417f5a99ea6f93f1824bad0904d2c018f17a79", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use mir::repr::Mir;\n-use middle::ty::ctxt;\n+use middle::infer::InferCtxt;\n \n pub trait MirPass {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ctxt<'tcx>);\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>);\n }"}, {"sha": "70c3354012135513a716f3f91f65b354f4a9cf9b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -149,11 +149,11 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mut mir) => {\n-                clear_dead_blocks::ClearDeadBlocks::new().run_on_mir(&mut mir, self.tcx);\n-                type_check::TypeckMir::new(&infcx).run_on_mir(&mut mir, self.tcx);\n-                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, self.tcx);\n+                clear_dead_blocks::ClearDeadBlocks::new().run_on_mir(&mut mir, &infcx);\n+                type_check::TypeckMir::new().run_on_mir(&mut mir, &infcx);\n+                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, &infcx);\n                 if self.tcx.sess.opts.mir_opt_level > 0 {\n-                    simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, self.tcx);\n+                    simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, &infcx);\n                 }\n                 let meta_item_list = self.attr\n                                          .iter()"}, {"sha": "2c08b6b0b81b867224f7519b831235233ee68973", "filename": "src/librustc_mir/transform/clear_dead_blocks.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclear_dead_blocks.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -15,7 +15,7 @@\n //! This pass does not renumber or remove the blocks, to have the\n //! MIR better match the source.\n \n-use rustc::middle::ty;\n+use rustc::middle::infer;\n use rustc::mir::repr::*;\n use rustc::mir::transform::MirPass;\n \n@@ -56,7 +56,8 @@ impl ClearDeadBlocks {\n }\n \n impl MirPass for ClearDeadBlocks {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, _tcx: &ty::ctxt<'tcx>) {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>)\n+    {\n         self.clear_dead_blocks(mir);\n     }\n }"}, {"sha": "a82d1fc53991f5855aac1b98eff04be8063651d7", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -16,18 +16,13 @@ use rustc::middle::ty;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::mir_map::MirMap;\n-use rustc::mir::transform::MirPass;\n \n pub fn erase_regions<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &mut MirMap<'tcx>) {\n-    let mut eraser = EraseRegions;\n-\n     for (_, mir) in &mut mir_map.map {\n-        eraser.run_on_mir(mir, tcx);\n+        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }\n \n-pub struct EraseRegions;\n-\n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n@@ -58,12 +53,6 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl MirPass for EraseRegions {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n-    }\n-}\n-\n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n         self.erase_regions_return_ty(&mut mir.return_ty);"}, {"sha": "e2c93bd4e8751cd87b721b0b9fd2296edf5dae99", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -11,7 +11,7 @@\n //! This pass removes the unwind branch of all the terminators when the no-landing-pads option is\n //! specified.\n \n-use rustc::middle::ty;\n+use rustc::middle::infer;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::MirPass;\n@@ -41,8 +41,9 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl MirPass for NoLandingPads {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n-        if tcx.sess.no_landing_pads() {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>,\n+                            infcx: &infer::InferCtxt<'a, 'tcx>) {\n+        if infcx.tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }\n     }"}, {"sha": "16d12324202f33c8f1bbf05e346cad613caa615a", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::const_eval::ConstVal;\n+use rustc::middle::infer;\n use rustc::mir::repr::*;\n use transform::util;\n use rustc::mir::transform::MirPass;\n@@ -119,7 +120,7 @@ impl SimplifyCfg {\n }\n \n impl MirPass for SimplifyCfg {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &::rustc::middle::ty::ctxt<'tcx>) {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &infer::InferCtxt<'a, 'tcx>) {\n         let mut changed = true;\n         while changed {\n             changed = self.simplify_branches(mir);"}, {"sha": "4e94c76c7e85dba94ea619b9085db2333bc7c6c3", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 91, "deletions": 46, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -11,7 +11,7 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n-use rustc::middle::infer;\n+use rustc::middle::infer::{self, InferCtxt};\n use rustc::middle::traits;\n use rustc::middle::ty::{self, Ty};\n use rustc::middle::ty::fold::TypeFoldable;\n@@ -35,7 +35,7 @@ macro_rules! span_mirbug {\n macro_rules! span_mirbug_and_err {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         {\n-            $context.tcx().sess.span_bug(\n+            $context.tcx().sess.span_warn(\n                 $context.last_span,\n                 &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n             );\n@@ -50,14 +50,14 @@ enum FieldAccessError {\n \n /// Verifies that MIR types are sane to not crash further\n /// checks.\n-struct TypeVerifier<'a, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n+    cx: &'a mut TypeChecker<'b, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n     errors_reported: bool\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'tcx> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n         if *span != DUMMY_SP {\n             self.last_span = *span;\n@@ -100,18 +100,22 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n-    fn new(infcx: &'a infer::InferCtxt<'a, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n-            infcx: infcx,\n+            cx: cx,\n             mir: mir,\n             last_span: mir.span,\n             errors_reported: false\n         }\n     }\n \n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n-        self.infcx.tcx\n+        self.cx.infcx.tcx\n+    }\n+\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.cx.infcx\n     }\n \n     fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -163,6 +167,7 @@ impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n+        let span = self.last_span;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n@@ -227,7 +232,7 @@ impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n                 let fty = self.sanitize_type(lvalue, fty);\n                 match self.field_ty(lvalue, base, field) {\n                     Ok(ty) => {\n-                        if let Err(terr) = infer::can_mk_subty(self.infcx, ty, fty) {\n+                        if let Err(terr) = self.cx.mk_eqty(span, ty, fty) {\n                             span_mirbug!(\n                                 self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n                                 ty, fty, terr);\n@@ -282,14 +287,15 @@ impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n-            Ok(self.normalize(parent, field.ty(tcx, substs)))\n+            Ok(self.normalize(field.ty(tcx, substs)))\n         } else {\n             Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n         }\n     }\n \n-    fn normalize(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let mut selcx = traits::SelectionContext::new(&self.infcx);\n+    fn normalize(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx();\n+        let mut selcx = traits::SelectionContext::new(infcx);\n         let cause = traits::ObligationCause::misc(self.last_span, 0);\n         let traits::Normalized { value: ty, obligations } =\n             traits::normalize(&mut selcx, cause, &ty);\n@@ -298,33 +304,44 @@ impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n                ty,\n                obligations);\n \n-        let mut fulfill_cx = self.infcx.fulfillment_cx.borrow_mut();\n+        let mut fulfill_cx = &mut self.cx.fulfillment_cx;\n         for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&self.infcx, obligation);\n+            fulfill_cx.register_predicate_obligation(infcx, obligation);\n         }\n \n-        match infer::drain_fulfillment_cx(&self.infcx, &mut fulfill_cx, &ty) {\n-            Ok(ty) => ty,\n-            Err(e) => {\n-                span_mirbug_and_err!(self, parent, \"trait fulfillment failed: {:?}\", e)\n-            }\n-        }\n+        ty\n     }\n }\n \n-pub struct TypeckMir<'a, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+pub struct TypeChecker<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span\n }\n \n-impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n-    pub fn new(infcx: &'a infer::InferCtxt<'a, 'tcx>) -> Self {\n-        TypeckMir {\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        TypeChecker {\n             infcx: infcx,\n+            fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP\n         }\n     }\n \n+    fn mk_subty(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+                -> infer::UnitResult<'tcx>\n+    {\n+        infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n+                        sup, sub)\n+    }\n+\n+    fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+                -> infer::UnitResult<'tcx>\n+    {\n+        infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n+                       a, b)\n+    }\n+\n     fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -337,7 +354,7 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n                 let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n                 let rv_ty = mir.rvalue_ty(tcx, rv);\n                 if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = infer::can_mk_subty(self.infcx, rv_ty, lv_ty) {\n+                    if let Err(terr) = self.mk_subty(self.last_span, rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n@@ -358,7 +375,10 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n             Terminator::Goto { .. } |\n             Terminator::Resume |\n             Terminator::Return |\n-            Terminator::Drop { .. } => {}\n+            Terminator::Drop { .. } => {\n+                // no checks needed for these\n+            }\n+\n             Terminator::If { ref cond, .. } => {\n                 let cond_ty = mir.operand_ty(tcx, cond);\n                 match cond_ty.sty {\n@@ -370,15 +390,23 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n             }\n             Terminator::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n-                if let Err(terr) = infer::can_mk_subty(self.infcx, discr_ty, switch_ty) {\n+                if let Err(terr) = self.mk_subty(self.last_span, discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n+                if !switch_ty.is_integral() && !switch_ty.is_char() &&\n+                    !switch_ty.is_bool()\n+                {\n+                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\",switch_ty);\n+                }\n+                // FIXME: check the values\n             }\n-            Terminator::Switch { ref discr, adt_def, .. } => {\n+            Terminator::Switch { ref discr, adt_def, ref targets } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n                 match discr_ty.sty {\n-                    ty::TyEnum(def, _) if def == adt_def => {},\n+                    ty::TyEnum(def, _)\n+                        if def == adt_def && adt_def.variants.len() == targets.len()\n+                        => {},\n                     _ => {\n                         span_mirbug!(self, term, \"bad Switch ({:?} on {:?})\",\n                                      adt_def, discr_ty);\n@@ -419,7 +447,7 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n             }\n             (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n                 let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n-                if let Err(terr) = infer::can_mk_subty(self.infcx, ty, dest_ty) {\n+                if let Err(terr) = self.mk_subty(self.last_span, ty, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, ty, terr);\n@@ -445,7 +473,7 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n-            if let Err(terr) = infer::can_mk_subty(self.infcx, op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.mk_subty(self.last_span, op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -500,7 +528,7 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = infer::can_mk_subty(self.infcx, arg_ty, pointee_ty) {\n+        if let Err(terr) = self.mk_subty(self.last_span, arg_ty, pointee_ty) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }\n@@ -522,28 +550,45 @@ impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn verify_obligations(&mut self, mir: &Mir<'tcx>) {\n+        self.last_span = mir.span;\n+        if let Err(e) = self.fulfillment_cx.select_all_or_error(self.infcx) {\n+            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\",\n+                         e);\n+        }\n+    }\n }\n \n-impl<'a, 'tcx> MirPass for TypeckMir<'a, 'tcx> {\n-    fn run_on_mir<'tcx_>(&mut self,\n-                         mir: &mut Mir<'tcx_>,\n-                         _tcx: &ty::ctxt<'tcx_>) {\n-        // FIXME: pass param_env to run_on_mir\n-        let mir: &mut Mir<'tcx> = unsafe { ::std::mem::transmute(mir) };\n+pub struct TypeckMir;\n \n-        if self.tcx().sess.err_count() > 0 {\n+impl TypeckMir {\n+    pub fn new() -> Self {\n+        TypeckMir\n+    }\n+}\n+\n+impl MirPass for TypeckMir {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n+    {\n+        if infcx.tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n \n-        let mut type_verifier = TypeVerifier::new(self.infcx, mir);\n-        type_verifier.visit_mir(mir);\n+        let mut checker = TypeChecker::new(infcx);\n \n-        if type_verifier.errors_reported {\n-            return;\n+        {\n+            let mut verifier = TypeVerifier::new(&mut checker, mir);\n+            verifier.visit_mir(mir);\n+            if verifier.errors_reported {\n+                // don't do further checks to avoid ICEs\n+                return;\n+            }\n         }\n \n-        self.typeck_mir(mir);\n+        checker.typeck_mir(mir);\n+        checker.verify_obligations(mir);\n     }\n }"}, {"sha": "16ef965e0dbd5421262e3ff8d7802349c6d3227a", "filename": "src/test/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/881249aa463db43e41e4d5f98d6f71f2970f8965/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fdummy_mir_pass.rs?ref=881249aa463db43e41e4d5f98d6f71f2970f8965", "patch": "@@ -21,17 +21,14 @@ extern crate syntax;\n use rustc::mir::transform::MirPass;\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n-use rustc::middle::ty;\n+use rustc::middle::infer::InferCtxt;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n use rustc_plugin::Registry;\n-use rustc_front::hir;\n-use syntax::attr;\n \n struct Pass;\n \n impl MirPass for Pass {\n-    fn run_on_mir<'tcx>(&mut self, mir: &mut Mir<'tcx>, tcx: &ty::ctxt<'tcx>) {\n+    fn run_on_mir<'a, 'tcx>(&mut self, mir: &mut Mir<'tcx>, _: &InferCtxt<'a, 'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}]}