{"sha": "0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "node_id": "C_kwDOAAsO6NoAKDBiNWQ2YWU1ZGJiYmU2YjA1YTg1YmRjY2NjOGFlZGJiOTZmZWVkZjQ", "commit": {"author": {"name": "mejrs", "email": "", "date": "2023-01-05T02:39:07Z"}, "committer": {"name": "mejrs", "email": "", "date": "2023-01-05T02:39:07Z"}, "message": "Improve fluent error messages", "tree": {"sha": "b1a108e309761ac420c638d3be37b3a7856a22ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1a108e309761ac420c638d3be37b3a7856a22ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "html_url": "https://github.com/rust-lang/rust/commit/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/comments", "author": {}, "committer": {}, "parents": [{"sha": "3b1c8a94a4e8a6ba8bc7b39cc3580db9e5b72295", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1c8a94a4e8a6ba8bc7b39cc3580db9e5b72295", "html_url": "https://github.com/rust-lang/rust/commit/3b1c8a94a4e8a6ba8bc7b39cc3580db9e5b72295"}], "stats": {"total": 247, "additions": 180, "deletions": 67}, "files": [{"sha": "e1c8dcd3bd39658dcf0099fb74e1825410efdd8d", "filename": "compiler/rustc_errors/src/error.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ferror.rs?ref=0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "patch": "@@ -0,0 +1,134 @@\n+use rustc_error_messages::{\n+    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n+    FluentArgs, FluentError,\n+};\n+use std::borrow::Cow;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum TranslateError<'args> {\n+    One {\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        kind: TranslateErrorKind<'args>,\n+    },\n+    Two {\n+        primary: Box<TranslateError<'args>>,\n+        fallback: Box<TranslateError<'args>>,\n+    },\n+}\n+\n+impl<'args> TranslateError<'args> {\n+    pub fn message(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::MessageMissing }\n+    }\n+    pub fn primary(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::PrimaryBundleMissing }\n+    }\n+    pub fn attribute(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        attr: &'args str,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::AttributeMissing { attr } }\n+    }\n+    pub fn value(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::ValueMissing }\n+    }\n+\n+    pub fn fluent(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        errs: Vec<FluentError>,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::Fluent { errs } }\n+    }\n+\n+    pub fn and(self, fallback: TranslateError<'args>) -> TranslateError<'args> {\n+        Self::Two { primary: Box::new(self), fallback: Box::new(fallback) }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum TranslateErrorKind<'args> {\n+    MessageMissing,\n+    PrimaryBundleMissing,\n+    AttributeMissing { attr: &'args str },\n+    ValueMissing,\n+    Fluent { errs: Vec<FluentError> },\n+}\n+\n+impl fmt::Display for TranslateError<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use TranslateErrorKind::*;\n+\n+        match self {\n+            Self::One { id, args, kind } => {\n+                writeln!(f, \"\\nfailed while formatting fluent string `{id}`: \")?;\n+                match kind {\n+                    MessageMissing => writeln!(f, \"message was missing\")?,\n+                    PrimaryBundleMissing => writeln!(f, \"the primary bundle was missing\")?,\n+                    AttributeMissing { attr } => writeln!(f, \"the attribute `{attr}` was missing\")?,\n+                    ValueMissing => writeln!(f, \"the value was missing\")?,\n+                    Fluent { errs } => {\n+                        for err in errs {\n+                            match err {\n+                                FluentError::ResolverError(ResolverError::Reference(\n+                                    ReferenceKind::Message { id, .. }\n+                                    | ReferenceKind::Variable { id, .. },\n+                                )) => {\n+                                    if args.iter().any(|(arg_id, _)| arg_id == id) {\n+                                        writeln!(\n+                                            f,\n+                                            \"argument `{id}` exists but was not referenced correctly\"\n+                                        )?;\n+                                        writeln!(f, \"help: try using `{{${id}}}` instead\")?;\n+                                    } else {\n+                                        writeln!(\n+                                            f,\n+                                            \"the fluent string has an argument `{id}` that was not found.\"\n+                                        )?;\n+                                        let vars: Vec<&str> =\n+                                            args.iter().map(|(a, _v)| a).collect();\n+                                        match &*vars {\n+                                            [] => writeln!(f, \"help: no arguments are available\")?,\n+                                            [one] => writeln!(\n+                                                f,\n+                                                \"help: the argument `{one}` is available\"\n+                                            )?,\n+                                            [first, middle @ .., last] => {\n+                                                write!(f, \"help: the arguments `{first}`\")?;\n+                                                for a in middle {\n+                                                    write!(f, \", `{a}`\")?;\n+                                                }\n+                                                writeln!(f, \" and `{last}` are available\")?;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                _ => writeln!(f, \"{err}\")?,\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            // If someone cares about primary bundles, they'll probably notice it's missing\n+            // regardless or will be using `debug_assertions`\n+            // so we skip the arm below this one to avoid confusing the regular user.\n+            Self::Two { primary: box Self::One { kind: PrimaryBundleMissing, .. }, fallback } => {\n+                fmt::Display::fmt(fallback, f)?;\n+            }\n+            Self::Two { primary, fallback } => {\n+                writeln!(\n+                    f,\n+                    \"first, fluent formatting using the primary bundle failed:\\n {primary}\\n \\\n+                    while attempting to recover by using the fallback bundle instead, another error occurred:\\n{fallback}\"\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Error for TranslateError<'_> {}"}, {"sha": "6f411c5174a0425f30f981713b3ad0b49199aade", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "patch": "@@ -11,6 +11,10 @@\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(rustc_attrs)]\n+#![feature(yeet_expr)]\n+#![feature(try_blocks)]\n+#![feature(box_patterns)]\n+#![feature(error_reporter)]\n #![allow(incomplete_features)]\n \n #[macro_use]\n@@ -55,6 +59,7 @@ mod diagnostic;\n mod diagnostic_builder;\n mod diagnostic_impls;\n pub mod emitter;\n+pub mod error;\n pub mod json;\n mod lock;\n pub mod registry;"}, {"sha": "26c86cdaf4567d2f8ad8aec1fcc201bb0a8d92a5", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 41, "deletions": 67, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=0b5d6ae5dbbbe6b05a85bdcccc8aedbb96feedf4", "patch": "@@ -1,11 +1,10 @@\n+use crate::error::TranslateError;\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::{\n-    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n-    FluentArgs, FluentError,\n-};\n+use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n+use std::error::Report;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n@@ -63,75 +62,50 @@ pub trait Translate {\n             }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n+        let translate_with_bundle =\n+            |bundle: &'a FluentBundle| -> Result<Cow<'_, str>, TranslateError<'_>> {\n+                let message = bundle\n+                    .get_message(identifier)\n+                    .ok_or(TranslateError::message(identifier, args))?;\n+                let value = match attr {\n+                    Some(attr) => message\n+                        .get_attribute(attr)\n+                        .ok_or(TranslateError::attribute(identifier, args, attr))?\n+                        .value(),\n+                    None => message.value().ok_or(TranslateError::value(identifier, args))?,\n+                };\n+                debug!(?message, ?value);\n \n-        let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(identifier)?;\n-            let value = match attr {\n-                Some(attr) => message.get_attribute(attr)?.value(),\n-                None => message.value()?,\n+                let mut errs = vec![];\n+                let translated = bundle.format_pattern(value, Some(args), &mut errs);\n+                debug!(?translated, ?errs);\n+                if errs.is_empty() {\n+                    Ok(translated)\n+                } else {\n+                    Err(TranslateError::fluent(identifier, args, errs))\n+                }\n             };\n-            debug!(?message, ?value);\n-\n-            let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(args), &mut errs);\n-            debug!(?translated, ?errs);\n-            Some((translated, errs))\n-        };\n \n-        self.fluent_bundle()\n-            .and_then(|bundle| translate_with_bundle(bundle))\n-            // If `translate_with_bundle` returns `None` with the primary bundle, this is likely\n-            // just that the primary bundle doesn't contain the message being translated, so\n-            // proceed to the fallback bundle.\n-            //\n-            // However, when errors are produced from translation, then that means the translation\n-            // is broken (e.g. `{$foo}` exists in a translation but `foo` isn't provided).\n-            //\n-            // In debug builds, assert so that compiler devs can spot the broken translation and\n-            // fix it..\n-            .inspect(|(_, errs)| {\n-                debug_assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n-            })\n-            // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n-            // just hide it and try with the fallback bundle.\n-            .filter(|(_, errs)| errs.is_empty())\n-            .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n-            .map(|(translated, errs)| {\n-                // Always bail out for errors with the fallback bundle.\n+        let ret: Result<Cow<'_, str>, TranslateError<'_>> = try {\n+            match self.fluent_bundle().map(|b| translate_with_bundle(b)) {\n+                // The primary bundle was present and translation succeeded\n+                Some(Ok(t)) => t,\n \n-                let mut help_messages = vec![];\n+                // Always yeet out for errors on debug\n+                Some(Err(primary)) if cfg!(debug_assertions) => do yeet primary,\n \n-                if !errs.is_empty() {\n-                    for error in &errs {\n-                        match error {\n-                            FluentError::ResolverError(ResolverError::Reference(\n-                                ReferenceKind::Message { id, .. },\n-                            )) if args.iter().any(|(arg_id, _)| arg_id == id) => {\n-                                help_messages.push(format!(\"Argument `{id}` exists but was not referenced correctly. Try using `{{${id}}}` instead\"));\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n+                // If `translate_with_bundle` returns `Err` with the primary bundle, this is likely\n+                // just that the primary bundle doesn't contain the message being translated or\n+                // something else went wrong) so proceed to the fallback bundle.\n+                Some(Err(primary)) => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| primary.and(fallback))?,\n \n-                    panic!(\n-                        \"Encountered errors while formatting message for `{identifier}`\\n\\\n-                        help: {}\\n\\\n-                        attr: `{attr:?}`\\n\\\n-                        args: `{args:?}`\\n\\\n-                        errors: `{errs:?}`\",\n-                        help_messages.join(\"\\nhelp: \")\n-                    );\n-                }\n-\n-                translated\n-            })\n+                // The primary bundle is missing, proceed to the fallback bundle\n+                None => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| TranslateError::primary(identifier, args).and(fallback))?,\n+            }\n+        };\n+        ret.map_err(Report::new)\n             .expect(\"failed to find message in primary or fallback fluent bundles\")\n     }\n }"}]}