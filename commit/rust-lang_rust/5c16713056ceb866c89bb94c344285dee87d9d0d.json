{"sha": "5c16713056ceb866c89bb94c344285dee87d9d0d", "node_id": "C_kwDOAAsO6NoAKDVjMTY3MTMwNTZjZWI4NjZjODliYjk0YzM0NDI4NWRlZTg3ZDlkMGQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T02:01:03Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-27T02:19:56Z"}, "message": "remove support for untagged pointers\n\ngood riddance!", "tree": {"sha": "f577492be5ee0e055fb889d021f67f843b62fea4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f577492be5ee0e055fb889d021f67f843b62fea4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c16713056ceb866c89bb94c344285dee87d9d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c16713056ceb866c89bb94c344285dee87d9d0d", "html_url": "https://github.com/rust-lang/rust/commit/5c16713056ceb866c89bb94c344285dee87d9d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c16713056ceb866c89bb94c344285dee87d9d0d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "294ef15adbf6b4778a8eb638b31a48744914ec0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/294ef15adbf6b4778a8eb638b31a48744914ec0a", "html_url": "https://github.com/rust-lang/rust/commit/294ef15adbf6b4778a8eb638b31a48744914ec0a"}], "stats": {"total": 291, "additions": 74, "deletions": 217}, "files": [{"sha": "a56b4bc6d1b4e62c39442a8d8187694245220c95", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -409,7 +409,7 @@ fn main() {\n                         err\n                     ),\n             };\n-            for id in ids.into_iter().map(miri::PtrId::new) {\n+            for id in ids.into_iter().map(miri::SbTag::new) {\n                 if let Some(id) = id {\n                     miri_config.tracked_pointer_tags.insert(id);\n                 } else {"}, {"sha": "8176e51338a5a47237b39cdd6774f8148d06d2cb", "filename": "src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -178,24 +178,6 @@ pub fn report_error<'tcx, 'mir>(\n                                 helps.push((Some(*protection_span), \"this protector is live for this call\".to_string()));\n                             }\n                         }\n-                        Some(TagHistory::Untagged{ recently_created, recently_invalidated, matching_created, protected }) => {\n-                            if let Some((range, span)) = recently_created {\n-                                let msg = format!(\"tag was most recently created at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((range, span)) = recently_invalidated {\n-                                let msg = format!(\"tag was later invalidated at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((range, span)) = matching_created {\n-                                let msg = format!(\"this tag was also created here at offsets {}\", HexRange(*range));\n-                                helps.push((Some(*span), msg));\n-                            }\n-                            if let Some((protecting_tag, protecting_tag_span, protection_span)) = protected {\n-                                helps.push((Some(*protecting_tag_span), format!(\"{:?} was protected due to a tag which was created here\", protecting_tag)));\n-                                helps.push((Some(*protection_span), \"this protector is live for this call\".to_string()));\n-                            }\n-                        }\n                         None => {}\n                     }\n                     helps"}, {"sha": "12f1f52c78a334243be9a0f35c0e2c456708cf2d", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -96,7 +96,7 @@ pub struct MiriConfig {\n     /// The seed to use when non-determinism or randomness are required (e.g. ptr-to-int cast, `getrandom()`).\n     pub seed: Option<u64>,\n     /// The stacked borrows pointer ids to report about\n-    pub tracked_pointer_tags: HashSet<PtrId>,\n+    pub tracked_pointer_tags: HashSet<SbTag>,\n     /// The stacked borrows call IDs to report about\n     pub tracked_call_ids: HashSet<CallId>,\n     /// The allocation ids to report about."}, {"sha": "1633667fcad8932762fb109652d03adc9b619088", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -89,7 +89,7 @@ pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, SbTagExtra,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, SbTagExtra,\n     Stack, Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};"}, {"sha": "5b184754589756e5bb8cafba3ef5c4fec9417380", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -140,8 +140,9 @@ pub enum Tag {\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Pointer<Tag>, 24);\n+// FIXME: this would with in 24bytes but layout optimizations are not smart enough\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-// static_assert_size!(Pointer<Option<Tag>>, 24);\n+//static_assert_size!(Pointer<Option<Tag>>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ScalarMaybeUninit<Tag>, 32);\n \n@@ -680,9 +681,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_tag(ptr.provenance)\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance)\n         } else {\n-            SbTag::Untagged\n+            // Value does not matter, SB is disabled\n+            SbTag::default()\n         };\n         Pointer::new(\n             Tag::Concrete { alloc_id: ptr.provenance, sb: sb_tag },"}, {"sha": "e79116a28ecfe7c431f5e6389ea26141c38ed848", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 52, "deletions": 113, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -23,42 +23,29 @@ use crate::*;\n pub mod diagnostics;\n use diagnostics::{AllocHistory, TagHistory};\n \n-pub type PtrId = NonZeroU64;\n pub type CallId = NonZeroU64;\n+\n // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n pub type AllocExtra = RefCell<Stacks>;\n \n /// Tracking pointer provenance\n-#[derive(Copy, Clone, Hash, Eq)]\n-pub enum SbTag {\n-    Tagged(PtrId),\n-    Untagged,\n-}\n+#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct SbTag(NonZeroU64);\n \n impl SbTag {\n-    fn as_u64(self) -> u64 {\n-        match self {\n-            SbTag::Tagged(id) => id.get(),\n-            SbTag::Untagged => 0,\n-        }\n+    pub fn new(i: u64) -> Option<Self> {\n+        NonZeroU64::new(i).map(SbTag)\n     }\n-}\n \n-impl PartialEq for SbTag {\n-    fn eq(&self, other: &Self) -> bool {\n-        // The codegen for the derived Partialeq is bad here and includes a branch.\n-        // Since this code is extremely hot, this is optimized here.\n-        // https://github.com/rust-lang/rust/issues/49892\n-        self.as_u64() == other.as_u64()\n+    // The default to be used when SB is disabled\n+    pub fn default() -> Self {\n+        Self::new(1).unwrap()\n     }\n }\n \n impl fmt::Debug for SbTag {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SbTag::Tagged(id) => write!(f, \"<{}>\", id),\n-            SbTag::Untagged => write!(f, \"<untagged>\"),\n-        }\n+        write!(f, \"<{}>\", self.0)\n     }\n }\n \n@@ -73,7 +60,7 @@ pub enum SbTagExtra {\n impl fmt::Debug for SbTagExtra {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            SbTagExtra::Concrete(tag) => write!(f, \"{tag:?}\"),\n+            SbTagExtra::Concrete(pid) => write!(f, \"{pid:?}\"),\n             SbTagExtra::Wildcard => write!(f, \"<wildcard>\"),\n         }\n     }\n@@ -82,7 +69,7 @@ impl fmt::Debug for SbTagExtra {\n impl SbTagExtra {\n     fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n         match self {\n-            SbTagExtra::Concrete(tag) => f(tag),\n+            SbTagExtra::Concrete(pid) => f(pid),\n             SbTagExtra::Wildcard => None,\n         }\n     }\n@@ -130,15 +117,15 @@ pub struct Stack {\n     /// Used *mostly* as a stack; never empty.\n     /// Invariants:\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n-    /// * Except for `Untagged`, no tag occurs in the stack more than once.\n+    /// * No tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n     /// If this is `Some(id)`, then the actual current stack is unknown. This can happen when\n     /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n-    /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n-    /// `Untagged` or strictly less than `id`.\n+    /// the top of the stack, and below it are arbitrarily many items whose `tag` is strictly less\n+    /// than `id`.\n     /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n     /// we never have the unknown-to-known boundary in an SRW group.\n-    unknown_bottom: Option<PtrId>,\n+    unknown_bottom: Option<SbTag>,\n }\n \n /// Extra per-allocation state.\n@@ -156,21 +143,19 @@ pub struct Stacks {\n #[derive(Debug)]\n pub struct GlobalStateInner {\n     /// Next unused pointer ID (tag).\n-    next_ptr_id: PtrId,\n+    next_ptr_tag: SbTag,\n     /// Table storing the \"base\" tag for each allocation.\n     /// The base tag is the one used for the initial pointer.\n     /// We need this in a separate table to handle cyclic statics.\n-    base_ptr_ids: FxHashMap<AllocId, SbTag>,\n+    base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n     /// Those call IDs corresponding to functions that are still running.\n     active_calls: FxHashSet<CallId>,\n     /// The pointer ids to trace\n-    tracked_pointer_tags: HashSet<PtrId>,\n+    tracked_pointer_tags: HashSet<SbTag>,\n     /// The call ids to trace\n     tracked_call_ids: HashSet<CallId>,\n-    /// Whether to track raw pointers.\n-    tag_raw: bool,\n }\n \n /// We need interior mutable access to the global state.\n@@ -219,24 +204,23 @@ impl fmt::Display for RefKind {\n \n /// Utilities for initialization and ID generation\n impl GlobalStateInner {\n-    pub fn new(tracked_pointer_tags: HashSet<PtrId>, tracked_call_ids: HashSet<CallId>) -> Self {\n+    pub fn new(tracked_pointer_tags: HashSet<SbTag>, tracked_call_ids: HashSet<CallId>) -> Self {\n         GlobalStateInner {\n-            next_ptr_id: NonZeroU64::new(1).unwrap(),\n-            base_ptr_ids: FxHashMap::default(),\n+            next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n+            base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n-            tag_raw: true,\n         }\n     }\n \n-    fn new_ptr(&mut self) -> PtrId {\n-        let id = self.next_ptr_id;\n+    fn new_ptr(&mut self) -> SbTag {\n+        let id = self.next_ptr_tag;\n         if self.tracked_pointer_tags.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(id));\n+            register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(id.0));\n         }\n-        self.next_ptr_id = NonZeroU64::new(id.get() + 1).unwrap();\n+        self.next_ptr_tag = SbTag(NonZeroU64::new(id.0.get() + 1).unwrap());\n         id\n     }\n \n@@ -259,22 +243,14 @@ impl GlobalStateInner {\n         self.active_calls.contains(&id)\n     }\n \n-    pub fn base_tag(&mut self, id: AllocId) -> SbTag {\n-        self.base_ptr_ids.get(&id).copied().unwrap_or_else(|| {\n-            let tag = SbTag::Tagged(self.new_ptr());\n+    pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n+        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n+            let tag = self.new_ptr();\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n-            self.base_ptr_ids.try_insert(id, tag).unwrap();\n+            self.base_ptr_tags.try_insert(id, tag).unwrap();\n             tag\n         })\n     }\n-\n-    pub fn base_tag_untagged(&mut self, id: AllocId) -> SbTag {\n-        trace!(\"New allocation {:?} has no base tag (untagged)\", id);\n-        let tag = SbTag::Untagged;\n-        // This must only be done on new allocations.\n-        self.base_ptr_ids.try_insert(id, tag).unwrap();\n-        tag\n-    }\n }\n \n /// Error reporting\n@@ -364,10 +340,7 @@ impl<'tcx> Stack {\n \n         // Couldn't find it in the stack; but if there is an unknown bottom it might be there.\n         let found = self.unknown_bottom.is_some_and(|&unknown_limit| {\n-            match tag {\n-                SbTag::Tagged(tag_id) => tag_id < unknown_limit, // unknown_limit is an upper bound for what can be in the unknown bottom.\n-                SbTag::Untagged => true,                         // yeah whatever\n-            }\n+            tag.0 < unknown_limit.0 // unknown_limit is an upper bound for what can be in the unknown bottom.\n         });\n         if found { Ok(None) } else { Err(()) }\n     }\n@@ -408,23 +381,22 @@ impl<'tcx> Stack {\n     /// Within `provoking_access, the `AllocRange` refers the entire operation, and\n     /// the `Size` refers to the specific location in the `AllocRange` that we are\n     /// currently checking.\n-    fn check_protector(\n+    fn item_popped(\n         item: &Item,\n         provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n-        if let SbTag::Tagged(id) = item.tag {\n-            if global.tracked_pointer_tags.contains(&id) {\n-                register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                    *item,\n-                    provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n-                ));\n-            }\n+        if global.tracked_pointer_tags.contains(&item.tag) {\n+            register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                *item,\n+                provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n+            ));\n         }\n+\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some((tag, alloc_range, offset, _access)) = provoking_access {\n+                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n                     Err(err_sb_ub(\n                         format!(\n                             \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n@@ -434,8 +406,6 @@ impl<'tcx> Stack {\n                         tag.and_then(|tag| {\n                             alloc_history.get_logs_relevant_to(\n                                 tag,\n-                                alloc_range,\n-                                offset,\n                                 Some(item.tag),\n                             )\n                         }),\n@@ -491,7 +461,7 @@ impl<'tcx> Stack {\n             };\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(\n+                Stack::item_popped(\n                     &item,\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n@@ -520,7 +490,7 @@ impl<'tcx> Stack {\n \n                 if item.perm == Permission::Unique {\n                     trace!(\"access: disabling item {:?}\", item);\n-                    Stack::check_protector(\n+                    Stack::item_popped(\n                         item,\n                         Some((tag, alloc_range, offset, access)),\n                         global,\n@@ -540,21 +510,19 @@ impl<'tcx> Stack {\n             for item in &self.borrows {\n                 // Skip disabled items, they cannot be matched anyway.\n                 if !matches!(item.perm, Permission::Disabled) {\n-                    if let SbTag::Tagged(tag) = item.tag {\n-                        // We are looking for a strict upper bound, so add 1 to this tag.\n-                        max = cmp::max(tag.checked_add(1).unwrap(), max);\n-                    }\n+                    // We are looking for a strict upper bound, so add 1 to this tag.\n+                    max = cmp::max(item.tag.0.checked_add(1).unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom {\n-                max = cmp::max(unk, max);\n+                max = cmp::max(unk.0, max);\n             }\n             // Use `max` as new strict upper bound for everything.\n             trace!(\n                 \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n             );\n             self.borrows.clear();\n-            self.unknown_bottom = Some(max);\n+            self.unknown_bottom = Some(SbTag(max));\n         }\n \n         // Done.\n@@ -566,7 +534,7 @@ impl<'tcx> Stack {\n     fn dealloc(\n         &mut self,\n         tag: SbTagExtra,\n-        (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n+        (alloc_id, _alloc_range, _offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n@@ -578,13 +546,13 @@ impl<'tcx> Stack {\n                 tag, alloc_id,\n                 ),\n                 None,\n-                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None)),\n+                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, None)),\n             )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n-            Stack::check_protector(&item, None, global, alloc_history)?;\n+            Stack::item_popped(&item, None, global, alloc_history)?;\n         }\n         Ok(())\n     }\n@@ -632,7 +600,7 @@ impl<'tcx> Stack {\n                 // (for all we know, it might join an SRW group inside the unknown).\n                 trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n                 self.borrows.clear();\n-                self.unknown_bottom = Some(global.next_ptr_id);\n+                self.unknown_bottom = Some(global.next_ptr_tag);\n                 return Ok(());\n             };\n \n@@ -726,30 +694,9 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_tag(id), Permission::Unique),\n-            // `Global` memory can be referenced by global pointers from `tcx`.\n-            // Thus we call `global_base_ptr` such that the global pointers get the same tag\n-            // as what we use here.\n-            // `ExternStatic` is used for extern statics, so the same reasoning applies.\n-            // The others are various forms of machine-managed special global memory, and we can get\n-            // away with precise tracking there.\n-            // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n-            MemoryKind::CallerLocation\n-            | MemoryKind::Machine(\n-                MiriMemoryKind::Global\n-                | MiriMemoryKind::ExternStatic\n-                | MiriMemoryKind::Tls\n-                | MiriMemoryKind::Runtime\n-                | MiriMemoryKind::Machine,\n-            ) => (extra.base_tag(id), Permission::SharedReadWrite),\n-            // Heap allocations we only track precisely when raw pointers are tagged, for now.\n-            MemoryKind::Machine(\n-                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap,\n-            ) => {\n-                let tag =\n-                    if extra.tag_raw { extra.base_tag(id) } else { extra.base_tag_untagged(id) };\n-                (tag, Permission::SharedReadWrite)\n-            }\n+            MemoryKind::Stack => (extra.base_ptr_tag(id), Permission::Unique),\n+            // Everything else is shared by default.\n+            _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n         };\n         let mut stacks = Stacks::new(size, perm, base_tag);\n         stacks.history.log_creation(\n@@ -1039,15 +986,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Compute new borrow.\n-        let new_tag = {\n-            let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-            match kind {\n-                // Give up tracking for raw pointers.\n-                RefKind::Raw { .. } if !mem_extra.tag_raw => SbTag::Untagged,\n-                // All other pointers are properly tracked.\n-                _ => SbTag::Tagged(mem_extra.new_ptr()),\n-            }\n-        };\n+        let new_tag = this.machine.stacked_borrows.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n         let alloc_id = this.reborrow(&place, size, kind, new_tag, protect)?;"}, {"sha": "0a7edcdc89c12bc0114eda2cbc22df02ad2cc576", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 80, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c16713056ceb866c89bb94c344285dee87d9d0d/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=5c16713056ceb866c89bb94c344285dee87d9d0d", "patch": "@@ -32,7 +32,6 @@ struct Protection {\n \n #[derive(Clone, Debug)]\n struct Event {\n-    time: usize,\n     parent: Option<SbTag>,\n     tag: SbTag,\n     range: AllocRange,\n@@ -46,12 +45,6 @@ pub enum TagHistory {\n         invalidated: Option<(AllocRange, SpanData)>,\n         protected: Option<(SbTag, SpanData, SpanData)>,\n     },\n-    Untagged {\n-        recently_created: Option<(AllocRange, SpanData)>,\n-        recently_invalidated: Option<(AllocRange, SpanData)>,\n-        matching_created: Option<(AllocRange, SpanData)>,\n-        protected: Option<(SbTag, SpanData, SpanData)>,\n-    },\n }\n \n impl AllocHistory {\n@@ -72,7 +65,7 @@ impl AllocHistory {\n         current_span: &mut CurrentSpan<'_, '_, '_>,\n     ) {\n         let span = current_span.get();\n-        self.creations.push(Event { parent, tag, range, span, time: self.current_time });\n+        self.creations.push(Event { parent, tag, range, span });\n         self.current_time += 1;\n     }\n \n@@ -83,7 +76,7 @@ impl AllocHistory {\n         current_span: &mut CurrentSpan<'_, '_, '_>,\n     ) {\n         let span = current_span.get();\n-        self.invalidations.push(Event { parent: None, tag, range, span, time: self.current_time });\n+        self.invalidations.push(Event { parent: None, tag, range, span });\n         self.current_time += 1;\n     }\n \n@@ -101,8 +94,6 @@ impl AllocHistory {\n     pub fn get_logs_relevant_to(\n         &self,\n         tag: SbTag,\n-        alloc_range: AllocRange,\n-        offset: Size,\n         protector_tag: Option<SbTag>,\n     ) -> Option<TagHistory> {\n         let protected = protector_tag\n@@ -125,74 +116,17 @@ impl AllocHistory {\n                 })\n             });\n \n-        if let SbTag::Tagged(_) = tag {\n-            let get_matching = |events: &[Event]| {\n-                events.iter().rev().find_map(|event| {\n-                    if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n-                })\n-            };\n-            Some(TagHistory::Tagged {\n-                tag,\n-                created: get_matching(&self.creations)?,\n-                invalidated: get_matching(&self.invalidations),\n-                protected,\n-            })\n-        } else {\n-            let mut created_time = 0;\n-            // Find the most recently created tag that satsfies this offset\n-            let recently_created = self.creations.iter().rev().find_map(|event| {\n-                if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n-                    created_time = event.time;\n-                    Some((event.range, event.span.data()))\n-                } else {\n-                    None\n-                }\n-            });\n-\n-            // Find a different recently created tag that satisfies this whole operation, predates\n-            // the recently created tag, and has a different span.\n-            // We're trying to make a guess at which span the user wanted to provide the tag that\n-            // they're using.\n-            let matching_created = recently_created.and_then(|(_created_range, created_span)| {\n-                self.creations.iter().rev().find_map(|event| {\n-                    if event.tag == tag\n-                        && alloc_range.start >= event.range.start\n-                        && alloc_range.end() <= event.range.end()\n-                        && event.span.data() != created_span\n-                        && event.time != created_time\n-                    {\n-                        Some((event.range, event.span.data()))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            });\n-\n-            // Find the most recent invalidation of this tag which post-dates the creation\n-            let recently_invalidated = recently_created.and_then(|_| {\n-                self.invalidations\n-                    .iter()\n-                    .rev()\n-                    .take_while(|event| event.time > created_time)\n-                    .find_map(|event| {\n-                        if event.tag == tag\n-                            && offset >= event.range.start\n-                            && offset < event.range.end()\n-                        {\n-                            Some((event.range, event.span.data()))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-            });\n-\n-            Some(TagHistory::Untagged {\n-                recently_created,\n-                matching_created,\n-                recently_invalidated,\n-                protected,\n+        let get_matching = |events: &[Event]| {\n+            events.iter().rev().find_map(|event| {\n+                if event.tag == tag { Some((event.range, event.span.data())) } else { None }\n             })\n-        }\n+        };\n+        Some(TagHistory::Tagged {\n+            tag,\n+            created: get_matching(&self.creations)?,\n+            invalidated: get_matching(&self.invalidations),\n+            protected,\n+        })\n     }\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n@@ -215,7 +149,7 @@ impl AllocHistory {\n             format!(\"{}{}\", action, error_cause(stack, derived_from)),\n             Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n             derived_from.and_then(|derived_from| {\n-                self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None)\n+                self.get_logs_relevant_to(derived_from, None)\n             }),\n         )\n     }\n@@ -238,7 +172,7 @@ impl AllocHistory {\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, tag)),\n             Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            tag.and_then(|tag| self.get_logs_relevant_to(tag, alloc_range, error_offset, None)),\n+            tag.and_then(|tag| self.get_logs_relevant_to(tag, None)),\n         )\n     }\n }"}]}