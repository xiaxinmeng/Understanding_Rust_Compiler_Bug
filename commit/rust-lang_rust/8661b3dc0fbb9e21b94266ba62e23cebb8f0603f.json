{"sha": "8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NjFiM2RjMGZiYjllMjFiOTQyNjZiYTYyZTIzY2ViYjhmMDYwM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-07T14:08:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-07T14:08:38Z"}, "message": "Auto merge of #21971 - pnkfelix:fsk-restrict-fixdsz-array-moves, r=nikomatsakis\n\nRevised version of PR #21930.\r\n\r\nRestrictions on moves into and out-from fixed-length arrays.\r\n\r\n(There was only one use of this \"feature\" in the compiler source.)\r\n\r\nNote 1: the change to the error message in tests/compile-fail/borrowck-use-in-index-lvalue.rs, where we now report that *w is uninitialized (rather than w), was unintended fallout from the implementation strategy used here. The change appears harmless to me, but I welcome advice on how to bring back the old message, which was slightly cleaner (i.e. less unintelligible) since that the syntactic form *w does not actually appear in the source text.\r\n\r\nNote 2: the move out-from restriction to only apply to expr[i], and not destructuring bind (e.g. f([a, b, c]: Array) { ... }) since the latter is compatible with nonzeroing drop, AFAICT.\r\n\r\n[breaking-change]", "tree": {"sha": "7b140bc2081a78ce5de68e6dc57ff3b8ced62fb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b140bc2081a78ce5de68e6dc57ff3b8ced62fb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "html_url": "https://github.com/rust-lang/rust/commit/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80627cd3cc4099b76cb2fb26ebe2f2f8a6c2335e", "url": "https://api.github.com/repos/rust-lang/rust/commits/80627cd3cc4099b76cb2fb26ebe2f2f8a6c2335e", "html_url": "https://github.com/rust-lang/rust/commit/80627cd3cc4099b76cb2fb26ebe2f2f8a6c2335e"}, {"sha": "4583272bf5054e84c4c59ba3b9334a52cfcf5208", "url": "https://api.github.com/repos/rust-lang/rust/commits/4583272bf5054e84c4c59ba3b9334a52cfcf5208", "html_url": "https://github.com/rust-lang/rust/commit/4583272bf5054e84c4c59ba3b9334a52cfcf5208"}], "stats": {"total": 384, "additions": 276, "deletions": 108}, "files": [{"sha": "58492c817fd0b7ba000882a9a9aa64942dd6ab46", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -128,7 +128,7 @@ pub enum PointerKind {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n-    InteriorElement(ElementKind),\n+    InteriorElement(InteriorOffsetKind, ElementKind),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -137,6 +137,12 @@ pub enum FieldName {\n     PositionalField(uint)\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum InteriorOffsetKind {\n+    Index,            // e.g. `array_expr[index_expr]`\n+    Pattern,          // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum ElementKind {\n     VecElement,\n@@ -196,10 +202,12 @@ pub enum deref_kind {\n     deref_interior(InteriorKind),\n }\n \n+type DerefKindContext = Option<InteriorOffsetKind>;\n+\n // Categorizes a derefable type.  Note that we include vectors and strings as\n // derefable (we model an index as the combination of a deref and then a\n // pointer adjustment).\n-pub fn deref_kind(t: Ty) -> McResult<deref_kind> {\n+fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n     match t.sty {\n         ty::ty_uniq(_) => {\n             Ok(deref_ptr(Unique))\n@@ -220,7 +228,12 @@ pub fn deref_kind(t: Ty) -> McResult<deref_kind> {\n         }\n \n         ty::ty_vec(_, _) | ty::ty_str => {\n-            Ok(deref_interior(InteriorElement(element_kind(t))))\n+            // no deref of indexed content without supplying InteriorOffsetKind\n+            if let Some(context) = context {\n+                Ok(deref_interior(InteriorElement(context, element_kind(t))))\n+            } else {\n+                Err(())\n+            }\n         }\n \n         _ => Err(()),\n@@ -455,7 +468,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                autoderefs,\n                cmt.repr(self.tcx()));\n         for deref in 1..autoderefs + 1 {\n-            cmt = try!(self.cat_deref(expr, cmt, deref));\n+            cmt = try!(self.cat_deref(expr, cmt, deref, None));\n         }\n         return Ok(cmt);\n     }\n@@ -467,7 +480,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, ref e_base) => {\n             let base_cmt = try!(self.cat_expr(&**e_base));\n-            self.cat_deref(expr, base_cmt, 0)\n+            self.cat_deref(expr, base_cmt, 0, None)\n           }\n \n           ast::ExprField(ref base, f_name) => {\n@@ -486,6 +499,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n+            let context = InteriorOffsetKind::Index;\n             match self.typer.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n@@ -507,10 +521,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     // is an rvalue. That is what we will be\n                     // dereferencing.\n                     let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, true)\n+                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n                 }\n                 None => {\n-                    self.cat_index(expr, try!(self.cat_expr(&**base)))\n+                    self.cat_index(expr, try!(self.cat_expr(&**base)), context)\n                 }\n             }\n           }\n@@ -854,7 +868,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint)\n+                             deref_cnt: uint,\n+                             deref_context: DerefKindContext)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => ty::AutoObject,\n@@ -882,7 +897,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty,\n+            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt,\n+                                              mt.ty,\n+                                              deref_context,\n                                               /* implicit: */ false),\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n@@ -897,10 +914,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     base_cmt: cmt<'tcx>,\n                                     deref_cnt: uint,\n                                     deref_ty: Ty<'tcx>,\n+                                    deref_context: DerefKindContext,\n                                     implicit: bool)\n                                     -> McResult<cmt<'tcx>>\n     {\n-        let (m, cat) = match try!(deref_kind(base_cmt.ty)) {\n+        let (m, cat) = match try!(deref_kind(base_cmt.ty, deref_context)) {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n                     match ptr {\n@@ -932,7 +950,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 mut base_cmt: cmt<'tcx>)\n+                                 mut base_cmt: cmt<'tcx>,\n+                                 context: InteriorOffsetKind)\n                                  -> McResult<cmt<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n@@ -974,18 +993,21 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty));\n+        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty,\n+                           m, context, element_ty));\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,\n                                        vec_ty: Ty<'tcx>,\n                                        mutbl: MutabilityCategory,\n+                                       context: InteriorOffsetKind,\n                                        element_ty: Ty<'tcx>) -> cmt<'tcx>\n         {\n+            let interior_elem = InteriorElement(context, element_kind(vec_ty));\n             Rc::new(cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n+                cat:cat_interior(of_cmt, interior_elem),\n                 mutbl:mutbl,\n                 ty:element_ty,\n                 note: NoteNone\n@@ -997,10 +1019,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     // underlying vec.\n     fn deref_vec<N:ast_node>(&self,\n                              elt: &N,\n-                             base_cmt: cmt<'tcx>)\n+                             base_cmt: cmt<'tcx>,\n+                             context: InteriorOffsetKind)\n                              -> McResult<cmt<'tcx>>\n     {\n-        match try!(deref_kind(base_cmt.ty)) {\n+        match try!(deref_kind(base_cmt.ty, Some(context))) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n@@ -1041,7 +1064,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n-        let cmt_slice = try!(self.cat_index(slice_pat, try!(self.deref_vec(slice_pat, vec_cmt))));\n+        let context = InteriorOffsetKind::Pattern;\n+        let cmt_vec = try!(self.deref_vec(slice_pat, vec_cmt, context));\n+        let cmt_slice = try!(self.cat_index(slice_pat, cmt_vec, context));\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n@@ -1253,12 +1278,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatRegion since that information is already contained\n             // in the type.\n-            let subcmt = try!(self.cat_deref(pat, cmt, 0));\n+            let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n               try!(self.cat_pattern_(subcmt, &**subpat, op));\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n-              let elt_cmt = try!(self.cat_index(pat, try!(self.deref_vec(pat, cmt))));\n+              let context = InteriorOffsetKind::Pattern;\n+              let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n+              let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n               for before_pat in before {\n                   try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n               }\n@@ -1455,10 +1482,18 @@ impl<'tcx> cmt_<'tcx> {\n             cat_interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            cat_interior(_, InteriorElement(VecElement)) |\n-            cat_interior(_, InteriorElement(OtherElement)) => {\n+            cat_interior(_, InteriorElement(InteriorOffsetKind::Index,\n+                                            VecElement)) |\n+            cat_interior(_, InteriorElement(InteriorOffsetKind::Index,\n+                                            OtherElement)) => {\n                 \"indexed content\".to_string()\n             }\n+            cat_interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n+                                            VecElement)) |\n+            cat_interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n+                                            OtherElement)) => {\n+                \"pattern-bound indexed content\".to_string()\n+            }\n             cat_upvar(ref var) => {\n                 var.user_string(tcx)\n             }\n@@ -1546,7 +1581,7 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n                 token::get_name(fld).to_string()\n             }\n             InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(_) => \"[]\".to_string(),\n+            InteriorElement(..) => \"[]\".to_string(),\n         }\n     }\n }"}, {"sha": "91f1121deaab17e4486c8475a0cb30f6c119dc99", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -19,6 +19,7 @@\n use self::UseError::*;\n \n use borrowck::*;\n+use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::region;\n@@ -743,15 +744,16 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n-            LpExtend(ref lp_base, _, LpInterior(_)) => {\n+            LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 // assigning to `P.f` is ok if assigning to `P` is ok\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n+            LpExtend(ref lp_base, _, LpInterior(InteriorElement(..))) |\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // assigning to `(*P)` requires that `P` be initialized\n-                self.check_if_path_is_moved(id, span,\n-                                            use_kind, lp_base);\n+                // assigning to `P[i]` requires `P` is initialized\n+                // assigning to `(*P)` requires `P` is initialized\n+                self.check_if_path_is_moved(id, span, use_kind, lp_base);\n             }\n         }\n     }"}, {"sha": "bee1ada28e31465dafee3e741f02b7c3a58e72a4", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -14,6 +14,7 @@\n \n use self::Fragment::*;\n \n+use borrowck::InteriorKind::{InteriorField, InteriorElement};\n use borrowck::{LoanPath};\n use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n@@ -300,20 +301,24 @@ fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n         LpExtend(_, _, LpDeref(mc::Implicit(..)))    |\n         LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) => {}\n \n-        // FIXME(pnkfelix): LV[j] should be tracked, at least in the\n+        // FIXME (pnkfelix): LV[j] should be tracked, at least in the\n         // sense of we will track the remaining drop obligation of the\n         // rest of the array.\n         //\n-        // LV[j] is not tracked precisely\n-        LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {\n+        // Well, either that or LV[j] should be made illegal.\n+        // But even then, we will need to deal with destructuring\n+        // bind.\n+        //\n+        // Anyway, for now: LV[j] is not tracked precisely\n+        LpExtend(_, _, LpInterior(InteriorElement(..))) => {\n             let mp = this.move_path(tcx, lp.clone());\n             gathered_fragments.push(AllButOneFrom(mp));\n         }\n \n         // field access LV.x and tuple access LV#k are the cases\n         // we are interested in\n         LpExtend(ref loan_parent, mc,\n-                 LpInterior(mc::InteriorField(ref field_name))) => {\n+                 LpInterior(InteriorField(ref field_name))) => {\n             let enum_variant_info = match loan_parent.kind {\n                 LpDowncast(ref loan_parent_2, variant_def_id) =>\n                     Some((variant_def_id, loan_parent_2.clone())),\n@@ -452,7 +457,7 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n         LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,\n     };\n \n-    let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));\n+    let loan_path_elem = LpInterior(InteriorField(new_field_name));\n     let new_lp_type = match new_field_name {\n         mc::NamedField(ast_name) =>\n             ty::named_element_ty(tcx, parent.to_type(), ast_name, opt_variant_did),"}, {"sha": "da53e9fac11875e6974092c8e9c4b73605f31f99", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -16,6 +16,8 @@ use borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use borrowck::move_data::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Typer;\n+use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::Repr;\n use std::rc::Rc;\n@@ -156,6 +158,7 @@ pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              mode);\n }\n \n+// (keep in sync with move_error::report_cannot_move_out_of )\n fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                                cmt: &mc::cmt<'tcx>)\n                                                -> Option<mc::cmt<'tcx>> {\n@@ -174,7 +177,8 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         }\n \n         mc::cat_downcast(ref b, _) |\n-        mc::cat_interior(ref b, _) => {\n+        mc::cat_interior(ref b, mc::InteriorField(_)) |\n+        mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n                     if ty::has_dtor(bccx.tcx, did) {\n@@ -189,6 +193,11 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n+        mc::cat_interior(_, mc::InteriorElement(Kind::Index, _)) => {\n+            // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n+            Some(cmt.clone())\n+        }\n+\n         mc::cat_deref(ref b, _, mc::Unique) => {\n             check_and_get_illegal_move_origin(bccx, b)\n         }"}, {"sha": "b00973c82bd97d83586df77c79069aff58e72788", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -10,6 +10,8 @@\n \n use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::mem_categorization::Typer;\n+use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::UserString;\n use std::cell::RefCell;\n@@ -110,6 +112,7 @@ fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n     }\n }\n \n+// (keep in sync with gather_moves::check_and_get_illegal_move_origin )\n fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_from: mc::cmt<'tcx>) {\n     match move_from.cat {\n@@ -121,8 +124,18 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                   move_from.descriptive_string(bccx.tcx))[]);\n         }\n \n+        mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n+            let expr = bccx.tcx.map.expect_expr(move_from.id);\n+            if let ast::ExprIndex(..) = expr.node {\n+                bccx.span_err(move_from.span,\n+                              &format!(\"cannot move out of type `{}`, \\\n+                                        a non-copy fixed-size array\",\n+                                       b.ty.user_string(bccx.tcx))[]);\n+            }\n+        }\n+\n         mc::cat_downcast(ref b, _) |\n-        mc::cat_interior(ref b, _) => {\n+        mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::ty_struct(did, _) |\n                 ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {"}, {"sha": "7078b2b5f1797c5ccd2d98c26ed0ba014445ce28", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -19,6 +19,8 @@ use rustc::middle::ty;\n use rustc::util::ppaux::Repr;\n use syntax::codemap::Span;\n \n+use borrowck::ToInteriorKind;\n+\n use std::rc::Rc;\n \n #[derive(Debug)]\n@@ -96,7 +98,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // the memory, so no additional restrictions are\n                 // needed.\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, &cmt, LpInterior(i))\n+                self.extend(result, &cmt, LpInterior(i.cleaned()))\n             }\n \n             mc::cat_static_item(..) => {"}, {"sha": "0bad55948822f96ff01a55eb645ff889d4fabe8b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -18,6 +18,8 @@ pub use self::bckerr_code::*;\n pub use self::AliasableViolationKind::*;\n pub use self::MovedValueUseKind::*;\n \n+use self::InteriorKind::*;\n+\n use rustc::middle::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n@@ -314,10 +316,30 @@ impl<'tcx> LoanPath<'tcx> {\n //     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n static DOWNCAST_PRINTED_OPERATOR : &'static str = \" as \";\n \n+// A local, \"cleaned\" version of `mc::InteriorKind` that drops\n+// information that is not relevant to loan-path analysis. (In\n+// particular, the distinction between how precisely a array-element\n+// is tracked is irrelevant here.)\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum InteriorKind {\n+    InteriorField(mc::FieldName),\n+    InteriorElement(mc::ElementKind),\n+}\n+\n+trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n+impl ToInteriorKind for mc::InteriorKind {\n+    fn cleaned(self) -> InteriorKind {\n+        match self {\n+            mc::InteriorField(name) => InteriorField(name),\n+            mc::InteriorElement(_, elem_kind) => InteriorElement(elem_kind),\n+        }\n+    }\n+}\n+\n #[derive(Copy, PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n-    LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n+    LpInterior(InteriorKind),    // `LV.f` in doc.rs\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n@@ -446,7 +468,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n \n         mc::cat_interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik)))\n+                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik.cleaned())))\n             })\n         }\n \n@@ -918,7 +940,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n \n-            LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n+            LpExtend(ref lp_base, _, LpInterior(InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n@@ -932,7 +954,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n+            LpExtend(ref lp_base, _, LpInterior(InteriorElement(..))) => {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n@@ -1006,6 +1028,17 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for InteriorKind {\n+    fn repr(&self, _tcx: &ty::ctxt<'tcx>) -> String {\n+        match *self {\n+            InteriorField(mc::NamedField(fld)) =>\n+                format!(\"{}\", token::get_name(fld)),\n+            InteriorField(mc::PositionalField(i)) => format!(\"#{}\", i),\n+            InteriorElement(..) => \"[]\".to_string(),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for Loan<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Loan_{}({}, {:?}, {:?}-{:?}, {})\","}, {"sha": "6607b5cac9c1dde95227d1c0600576770fdb8440", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty;\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n use rustc::util::ppaux::Repr;\n@@ -193,9 +192,13 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n-        LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {\n-            // Paths involving element accesses do not refer to a unique\n+        LpExtend(_, _, LpInterior(InteriorKind::InteriorElement(..))) => {\n+            // Paths involving element accesses a[i] do not refer to a unique\n             // location, as there is no accurate tracking of the indices.\n+            //\n+            // (Paths involving element accesses via slice pattern bindings\n+            // can in principle be tracked precisely, but that is future\n+            // work. For now, continue claiming that they are imprecise.)\n             false\n         }\n         LpDowncast(ref lp_base, _) |"}, {"sha": "71259ff5d9ade3032007ce1f02b5409c0a43cddd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -924,13 +924,13 @@ impl TokenTree {\n                 let v = [TtToken(sp, token::Dollar),\n                          TtToken(sp, token::Ident(token::str_to_ident(var.as_str()),\n                                                   token::Plain))];\n-                v[index]\n+                v[index].clone()\n             }\n             (&TtToken(sp, token::MatchNt(name, kind, name_st, kind_st)), _) => {\n                 let v = [TtToken(sp, token::SubstNt(name, name_st)),\n                          TtToken(sp, token::Colon),\n                          TtToken(sp, token::Ident(kind, kind_st))];\n-                v[index]\n+                v[index].clone()\n             }\n             (&TtSequence(_, ref seq), _) => {\n                 seq.tts[index].clone()"}, {"sha": "7291bcd2ce1264fb984e5eb9723729ce420d2967", "filename": "src/test/compile-fail/borrowck-use-in-index-lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-use-in-index-lvalue.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -10,10 +10,10 @@\n \n fn test() {\n     let w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `w`\n+    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n \n     let mut w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `w`\n+    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n }\n \n fn main() { test(); }"}, {"sha": "242a38440034ccaca016addea210f249a000de09", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -14,6 +14,8 @@ fn main() {\n         [1, 2, tail..] => tail,\n         _ => unreachable!()\n     };\n-    a[0] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed\n+    println!(\"t[0]: {}\", t[0]);\n+    a[2] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed\n+    println!(\"t[0]: {}\", t[0]);\n     t[0];\n }"}, {"sha": "426d5fa29a02000aa657a87354dde4af4339e028", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -33,15 +33,6 @@ pub fn test_move_array_into_recv(a: [D; 3], recv: &mut [D; 3]) {\n     *recv = a;\n }\n \n-#[rustc_move_fragments]\n-pub fn test_extract_array_elem(a: [D; 3], i: usize) -> D {\n-    //~^ ERROR                 parent_of_fragments: `$(local a)`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    //~| ERROR                     moved_leaf_path: `$(local a).[]`\n-    //~| ERROR                    unmoved_fragment: `$(allbutone $(local a).[])`\n-    a[i]\n-}\n-\n #[rustc_move_fragments]\n pub fn test_overwrite_array_elem(mut a: [D; 3], i: usize, d: D) {\n     //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n@@ -53,48 +44,4 @@ pub fn test_overwrite_array_elem(mut a: [D; 3], i: usize, d: D) {\n     a[i] = d;\n }\n \n-// FIXME (pnkfelix): Both test_move_array_then_overwrite_elem1 and\n-// test_move_array_then_overwrite_elem2 illustrate a behavior that\n-// we need to make illegal if we want to get rid of drop-flags.\n-// See RFC PR 320 for more discussion.\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_then_overwrite_elem1(mut a: [D; 3], i: usize, recv: &mut [D; 3], d: D) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n-    //~| ERROR                 parent_of_fragments: `$(local recv)`\n-    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    //~| ERROR                  assigned_leaf_path: `$(local d)`\n-    //~| ERROR                     moved_leaf_path: `$(local d)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n-    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n-\n-    // This test covers the case where the array contents have been all moved away, but\n-    // we still need to deal with new initializing writes into the array.\n-    *recv = a;\n-    a[i] = d;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_then_overwrite_elem2(mut a: [D; 3], i: usize, j: usize,\n-                                            recv: &mut [D; 3], d1: D, d2: D) {\n-    //~^^ ERROR                parent_of_fragments: `$(local mut a)`\n-    //~| ERROR                 parent_of_fragments: `$(local recv)`\n-    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    //~| ERROR                  assigned_leaf_path: `$(local j)`\n-    //~| ERROR                  assigned_leaf_path: `$(local d1)`\n-    //~| ERROR                  assigned_leaf_path: `$(local d2)`\n-    //~| ERROR                     moved_leaf_path: `$(local d1)`\n-    //~| ERROR                     moved_leaf_path: `$(local d2)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n-    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n-\n-    // This test covers the case where the array contents have been all moved away, but\n-    // we still need to deal with new initializing writes into the array.\n-    *recv = a;\n-    a[i] = d1;\n-    a[j] = d2;\n-}\n-\n pub fn main() { }"}, {"sha": "61ccb694fd212cae61b83de9d8e5e20982b9bf23", "filename": "src/test/compile-fail/move-into-dead-array-1.rs", "status": "renamed", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-1.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax)]\n+// Ensure that we cannot move into an uninitialized fixed-size array.\n \n-fn f() {\n-    let mut a = [box 0, box 1];\n-    drop(a[0]);\n-    a[1] = box 2;\n-    drop(a[0]); //~ ERROR use of moved value: `a[..]`\n-}\n+struct D { _x: u8 }\n+\n+fn d() -> D { D { _x: 0 } }\n \n fn main() {\n-    f();\n+    foo(1);\n+    foo(3);\n }\n \n+fn foo(i: usize) {\n+    let mut a: [D; 4];\n+    a[i] = d();        //~ ERROR use of possibly uninitialized variable: `a`\n+}", "previous_filename": "src/test/compile-fail/borrowck-array-double-move.rs"}, {"sha": "d484837c00136951b5273ab8a9ff74ac1b063887", "filename": "src/test/compile-fail/move-into-dead-array-2.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-into-dead-array-2.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that we cannot move into an uninitialized fixed-size array.\n+\n+struct D { _x: u8 }\n+\n+fn d() -> D { D { _x: 0 } }\n+\n+fn main() {\n+    foo([d(), d(), d(), d()], 1);\n+    foo([d(), d(), d(), d()], 3);\n+}\n+\n+fn foo(mut a: [D; 4], i: usize) {\n+    drop(a);\n+    a[i] = d(); //~ ERROR use of moved value: `a`\n+}"}, {"sha": "148dec0282331113da88852f9128bc67b5d0182a", "filename": "src/test/compile-fail/move-out-of-array-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that we cannot move out of a fixed-size array (especially\n+// when the element type has a destructor).\n+\n+\n+struct D { _x: u8 }\n+\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+fn main() {\n+    fn d() -> D { D { _x: 0 } }\n+\n+    let _d1 = foo([d(), d(), d(), d()], 1);\n+    let _d3 = foo([d(), d(), d(), d()], 3);\n+}\n+\n+fn foo(a: [D; 4], i: usize) -> D {\n+    a[i] //~ ERROR cannot move out of type `[D; 4]`\n+}"}, {"sha": "2b57c1ea0da693bfc6b77587cc3be19fa70f756b", "filename": "src/test/run-pass/copy-out-of-array-1.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcopy-out-of-array-1.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that we can copy out of a fixed-size array.\n+//\n+// (Compare with compile-fail/move-out-of-array-1.rs)\n+\n+struct C { _x: u8 }\n+\n+impl Copy for C { }\n+\n+fn main() {\n+    fn d() -> C { C { _x: 0 } }\n+\n+    let _d1 = foo([d(), d(), d(), d()], 1);\n+    let _d3 = foo([d(), d(), d(), d()], 3);\n+}\n+\n+fn foo(a: [C; 4], i: usize) -> C {\n+    a[i]\n+}"}, {"sha": "43271162c18125b0f4d7b3e27e393639c941bb99", "filename": "src/test/run-pass/destructure-array-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Frun-pass%2Fdestructure-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8661b3dc0fbb9e21b94266ba62e23cebb8f0603f/src%2Ftest%2Frun-pass%2Fdestructure-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdestructure-array-1.rs?ref=8661b3dc0fbb9e21b94266ba62e23cebb8f0603f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that we can do a destructuring bind of a fixed-size array,\n+// even when the element type has a destructor.\n+\n+struct D { x: u8 }\n+\n+impl Drop for D { fn drop(&mut self) { } }\n+\n+fn main() {\n+    fn d(x: u8) -> D { D { x: x } }\n+\n+    let d1 = foo([d(1), d(2), d(3), d(4)], 1);\n+    let d3 = foo([d(5), d(6), d(7), d(8)], 3);\n+    assert_eq!(d1.x, 2);\n+    assert_eq!(d3.x, 8);\n+}\n+\n+fn foo([a, b, c, d]: [D; 4], i: usize) -> D {\n+    match i {\n+        0 => a,\n+        1 => b,\n+        2 => c,\n+        3 => d,\n+        _ => panic!(\"unmatched\"),\n+    }\n+}"}]}