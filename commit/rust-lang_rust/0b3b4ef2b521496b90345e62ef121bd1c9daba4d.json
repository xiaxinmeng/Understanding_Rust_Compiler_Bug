{"sha": "0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "node_id": "C_kwDOAAsO6NoAKDBiM2I0ZWYyYjUyMTQ5NmI5MDM0NWU2MmVmMTIxYmQxYzlkYWJhNGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-26T17:47:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-26T17:47:04Z"}, "message": "Rollup merge of #98428 - davidtwco:translation-derive-typed-identifiers, r=oli-obk\n\nmacros: use typed identifiers in diag and subdiag derive\n\nUsing typed identifiers instead of strings with the Fluent identifiers in the diagnostic and subdiagnostic derives - this enables the diagnostic derive to benefit from the compile-time validation that comes with typed identifiers, namely that use of a non-existent Fluent identifier will not compile.\n\nr? `````@oli-obk`````", "tree": {"sha": "78a191d2a8e95b804dcf645d8cdbdf9932bffe68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78a191d2a8e95b804dcf645d8cdbdf9932bffe68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiuJuYCRBK7hj4Ov3rIwAAgaIIAK0kj5ggPQKgzizse4mhPlbs\n0nFOPOfu63Ti1sVIdePF6RnstGk+WmXq5UvkNRI2mV2nE5TBUguJva/VcUTXUNme\nd30mFXurUYp0h9ey2YKd9D4dgCzUGr3pKnS97b+SD710cSV9WeUe2b+FkjyDJK2G\nmiezHmwimnd1bBfOMZC1eHpmlKrmJS88/+dzm9gcZtJ3QP3U4RI3IO5NQTEMWkKJ\nM5z4HnPsKAtEyOwy2Df2OLhfTdkQmp61k8t3ZSVPMWnDZkpikIsrJhMo2BIcN+g0\nq28DU/rceEPsg1akcIc0V3PNQObTU6ZA4YPfZSGPCcLr1cz723X/Pt9jYgJlOCQ=\n=O0he\n-----END PGP SIGNATURE-----\n", "payload": "tree 78a191d2a8e95b804dcf645d8cdbdf9932bffe68\nparent df26fdf3e1667e7ea2e442bb554aa9632677c862\nparent dc90d1d987d74af4950caca0f9b16d7fdf21b6af\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656265624 +0200\ncommitter GitHub <noreply@github.com> 1656265624 +0200\n\nRollup merge of #98428 - davidtwco:translation-derive-typed-identifiers, r=oli-obk\n\nmacros: use typed identifiers in diag and subdiag derive\n\nUsing typed identifiers instead of strings with the Fluent identifiers in the diagnostic and subdiagnostic derives - this enables the diagnostic derive to benefit from the compile-time validation that comes with typed identifiers, namely that use of a non-existent Fluent identifier will not compile.\n\nr? `````@oli-obk`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "html_url": "https://github.com/rust-lang/rust/commit/0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df26fdf3e1667e7ea2e442bb554aa9632677c862", "url": "https://api.github.com/repos/rust-lang/rust/commits/df26fdf3e1667e7ea2e442bb554aa9632677c862", "html_url": "https://github.com/rust-lang/rust/commit/df26fdf3e1667e7ea2e442bb554aa9632677c862"}, {"sha": "dc90d1d987d74af4950caca0f9b16d7fdf21b6af", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc90d1d987d74af4950caca0f9b16d7fdf21b6af", "html_url": "https://github.com/rust-lang/rust/commit/dc90d1d987d74af4950caca0f9b16d7fdf21b6af"}], "stats": {"total": 1640, "additions": 971, "deletions": 669}, "files": [{"sha": "aa355150b4f816f1913f7277a625f51f084ae255", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -36,15 +36,15 @@ pub fn expand_cfg(\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"builtin-macros-requires-cfg-pattern\")]\n+#[error(builtin_macros::requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"builtin-macros-expected-one-cfg-pattern\")]\n+#[error(builtin_macros::expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]\n     span: Span,"}, {"sha": "4a42d52f71004c851b27f04b98b0dc5ce83db328", "filename": "compiler/rustc_error_messages/locales/en-US/builtin_macros.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fbuiltin_macros.ftl?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -1,5 +1,5 @@\n-builtin-macros-requires-cfg-pattern =\n+builtin_macros-requires-cfg-pattern =\n     macro requires a cfg-pattern as an argument\n     .label = cfg-pattern required\n \n-builtin-macros-expected-one-cfg-pattern = expected 1 cfg-pattern\n+builtin_macros-expected-one-cfg-pattern = expected 1 cfg-pattern"}, {"sha": "673e160cc1e74d589ce19aa110f647b92e22c590", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -258,18 +258,6 @@ pub enum SubdiagnosticMessage {\n     FluentAttr(FluentId),\n }\n \n-impl SubdiagnosticMessage {\n-    /// Create a `SubdiagnosticMessage` for the provided Fluent attribute.\n-    pub fn attr(id: impl Into<FluentId>) -> Self {\n-        SubdiagnosticMessage::FluentAttr(id.into())\n-    }\n-\n-    /// Create a `SubdiagnosticMessage` for the provided Fluent identifier.\n-    pub fn message(id: impl Into<FluentId>) -> Self {\n-        SubdiagnosticMessage::FluentIdentifier(id.into())\n-    }\n-}\n-\n /// `From` impl that enables existing diagnostic calls to functions which now take\n /// `impl Into<SubdiagnosticMessage>` to continue to work as before.\n impl<S: Into<String>> From<S> for SubdiagnosticMessage {\n@@ -332,11 +320,6 @@ impl DiagnosticMessage {\n             _ => panic!(\"expected non-translatable diagnostic message\"),\n         }\n     }\n-\n-    /// Create a `DiagnosticMessage` for the provided Fluent identifier.\n-    pub fn new(id: impl Into<FluentId>) -> Self {\n-        DiagnosticMessage::FluentIdentifier(id.into(), None)\n-    }\n }\n \n /// `From` impl that enables existing diagnostic calls to functions which now take\n@@ -347,6 +330,27 @@ impl<S: Into<String>> From<S> for DiagnosticMessage {\n     }\n }\n \n+/// Translating *into* a subdiagnostic message from a diagnostic message is a little strange - but\n+/// the subdiagnostic functions (e.g. `span_label`) take a `SubdiagnosticMessage` and the\n+/// subdiagnostic derive refers to typed identifiers that are `DiagnosticMessage`s, so need to be\n+/// able to convert between these, as much as they'll be converted back into `DiagnosticMessage`\n+/// using `with_subdiagnostic_message` eventually. Don't use this other than for the derive.\n+impl Into<SubdiagnosticMessage> for DiagnosticMessage {\n+    fn into(self) -> SubdiagnosticMessage {\n+        match self {\n+            DiagnosticMessage::Str(s) => SubdiagnosticMessage::Str(s),\n+            DiagnosticMessage::FluentIdentifier(id, None) => {\n+                SubdiagnosticMessage::FluentIdentifier(id)\n+            }\n+            // There isn't really a sensible behaviour for this because it loses information but\n+            // this is the most sensible of the behaviours.\n+            DiagnosticMessage::FluentIdentifier(_, Some(attr)) => {\n+                SubdiagnosticMessage::FluentAttr(attr)\n+            }\n+        }\n+    }\n+}\n+\n /// A span together with some additional data.\n #[derive(Clone, Debug)]\n pub struct SpanLabel {"}, {"sha": "d0c8652718969a91e88c485683c168e1f279747c", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 284, "deletions": 176, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -12,7 +12,9 @@ use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type};\n+use syn::{\n+    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+};\n use synstructure::{BindingInfo, Structure};\n \n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n@@ -118,23 +120,23 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                         return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some((kind, _)), None) => {\n-                        span_err(span, \"`slug` not specified\")\n-                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                        span_err(span, \"diagnostic slug not specified\")\n+                            .help(&format!(\n+                                \"specify the slug as the first argument to the attribute, such as \\\n+                                 `#[{}(typeck::example_error)]`\",\n+                                kind.descr()\n+                            ))\n                             .emit();\n                         return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n                         quote! {\n-                            let mut #diag = #sess.struct_err(\n-                                rustc_errors::DiagnosticMessage::new(#slug),\n-                            );\n+                            let mut #diag = #sess.struct_err(rustc_errors::fluent::#slug);\n                         }\n                     }\n                     (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n                         quote! {\n-                            let mut #diag = #sess.struct_warn(\n-                                rustc_errors::DiagnosticMessage::new(#slug),\n-                            );\n+                            let mut #diag = #sess.struct_warn(rustc_errors::fluent::#slug);\n                         }\n                     }\n                 };\n@@ -226,7 +228,7 @@ struct SessionDiagnosticDeriveBuilder {\n     kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n     /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n     /// has the actual diagnostic message.\n-    slug: Option<(String, proc_macro::Span)>,\n+    slug: Option<(Path, proc_macro::Span)>,\n     /// Error codes are a optional part of the struct attribute - this is only set to detect\n     /// multiple specifications.\n     code: Option<(String, proc_macro::Span)>,\n@@ -240,79 +242,104 @@ impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n \n impl SessionDiagnosticDeriveBuilder {\n     /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n-    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n+    /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n     fn generate_structure_code(\n         &mut self,\n         attr: &Attribute,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n         let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n-            let diag = &self.diag;\n-            let id = match meta {\n-                Meta::Path(..) => quote! { #name },\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    quote! { #s }\n-                }\n-                _ => unreachable!(),\n-            };\n-            let fn_name = proc_macro2::Ident::new(name, attr.span());\n-\n-            return Ok(quote! {\n-                #diag.#fn_name(rustc_errors::SubdiagnosticMessage::attr(#id));\n-            });\n-        }\n+        let is_help_or_note = matches!(name, \"help\" | \"note\");\n \n         let nested = match meta {\n+            // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n+            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n             Meta::List(MetaList { ref nested, .. }) => nested,\n+            // Subdiagnostics without spans can be applied to the type too, and these are just\n+            // paths: `#[help]` and `#[note]`\n+            Meta::Path(_) if is_help_or_note => {\n+                let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n+            }\n             _ => throw_invalid_attr!(attr, &meta),\n         };\n \n-        let kind = match name {\n-            \"error\" => SessionDiagnosticKind::Error,\n-            \"warning\" => SessionDiagnosticKind::Warn,\n+        // Check the kind before doing any further processing so that there aren't misleading\n+        // \"no kind specified\" errors if there are failures later.\n+        match name {\n+            \"error\" => self.kind.set_once((SessionDiagnosticKind::Error, span)),\n+            \"warning\" => self.kind.set_once((SessionDiagnosticKind::Warn, span)),\n+            \"help\" | \"note\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `error` and `warning` are valid attributes\")\n+                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n             }),\n-        };\n-        self.kind.set_once((kind, span));\n+        }\n+\n+        // First nested element should always be the path, e.g. `#[error(typeck::invalid)]` or\n+        // `#[help(typeck::another_help)]`.\n+        let mut nested_iter = nested.into_iter();\n+        if let Some(nested_attr) = nested_iter.next() {\n+            // Report an error if there are any other list items after the path.\n+            if is_help_or_note && nested_iter.next().is_some() {\n+                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n+                });\n+            }\n \n+            match nested_attr {\n+                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n+                    let fn_name = proc_macro2::Ident::new(name, attr.span());\n+                    return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n+                }\n+                NestedMeta::Meta(Meta::Path(path)) => {\n+                    self.slug.set_once((path.clone(), span));\n+                }\n+                NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                    if !is_help_or_note\n+                        && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n+                {\n+                    // don't error for valid follow-up attributes\n+                }\n+                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n+                }),\n+            };\n+        }\n+\n+        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n         let mut tokens = Vec::new();\n-        for nested_attr in nested {\n+        for nested_attr in nested_iter {\n             let meta = match nested_attr {\n                 syn::NestedMeta::Meta(meta) => meta,\n                 _ => throw_invalid_nested_attr!(attr, &nested_attr),\n             };\n \n             let path = meta.path();\n             let nested_name = path.segments.last().unwrap().ident.to_string();\n-            match &meta {\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    let span = s.span().unwrap();\n-                    match nested_name.as_str() {\n-                        \"slug\" => {\n-                            self.slug.set_once((s.value(), span));\n-                        }\n-                        \"code\" => {\n-                            self.code.set_once((s.value(), span));\n-                            let (diag, code) = (&self.diag, &self.code.as_ref().map(|(v, _)| v));\n-                            tokens.push(quote! {\n-                                #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n-                            });\n-                        }\n-                        _ => invalid_nested_attr(attr, &nested_attr)\n-                            .help(\"only `slug` and `code` are valid nested attributes\")\n-                            .emit(),\n+            // Struct attributes are only allowed to be applied once, and the diagnostic\n+            // changes will be set in the initialisation code.\n+            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n+                let span = s.span().unwrap();\n+                match nested_name.as_str() {\n+                    \"code\" => {\n+                        self.code.set_once((s.value(), span));\n+                        let code = &self.code.as_ref().map(|(v, _)| v);\n+                        tokens.push(quote! {\n+                            #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                        });\n                     }\n+                    _ => invalid_nested_attr(attr, &nested_attr)\n+                        .help(\"only `code` is a valid nested attributes following the slug\")\n+                        .emit(),\n                 }\n-                _ => invalid_nested_attr(attr, &nested_attr).emit(),\n+            } else {\n+                invalid_nested_attr(attr, &nested_attr).emit()\n             }\n         }\n \n@@ -382,142 +409,215 @@ impl SessionDiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n         binding: TokenStream,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n+            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_path(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n         let diag = &self.diag;\n \n+        let meta = attr.parse_meta()?;\n+\n         let ident = &attr.path.segments.last().unwrap().ident;\n         let name = ident.to_string();\n         let name = name.as_str();\n+        match name {\n+            \"skip_arg\" => {\n+                // Don't need to do anything - by virtue of the attribute existing, the\n+                // `set_arg` call will not be generated.\n+                Ok(quote! {})\n+            }\n+            \"primary_span\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(quote! {\n+                    #diag.set_span(#binding);\n+                })\n+            }\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n+            }\n+            \"note\" | \"help\" => {\n+                let path = match name {\n+                    \"note\" => parse_quote! { _subdiag::note },\n+                    \"help\" => parse_quote! { _subdiag::help },\n+                    _ => unreachable!(),\n+                };\n+                if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n+                } else if type_is_unit(&info.ty) {\n+                    Ok(self.add_subdiagnostic(ident, path))\n+                } else {\n+                    report_type_error(attr, \"`Span` or `()`\")?;\n+                }\n+            }\n+            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n+                     are valid field attributes\",\n+                )\n+            }),\n+        }\n+    }\n \n+    fn generate_inner_field_code_list(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        binding: TokenStream,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    Ok(quote! {})\n-                }\n-                \"primary_span\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(quote! {\n-                        #diag.set_span(#binding);\n-                    })\n-                }\n-                \"label\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n-                }\n-                \"note\" | \"help\" => {\n-                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                        Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n-                    } else if type_is_unit(&info.ty) {\n-                        Ok(self.add_subdiagnostic(ident, name))\n-                    } else {\n-                        report_type_error(attr, \"`Span` or `()`\")?;\n-                    }\n-                }\n-                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n-                _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag\n-                        .help(\"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\")\n-                }),\n-            },\n-            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n-                \"label\" => {\n-                    report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n-                }\n-                \"note\" | \"help\" => {\n-                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                        Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n-                    } else if type_is_unit(&info.ty) {\n-                        Ok(self.add_subdiagnostic(ident, &s.value()))\n-                    } else {\n-                        report_type_error(attr, \"`Span` or `()`\")?;\n-                    }\n-                }\n-                _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n-                }),\n-            },\n-            Meta::List(MetaList { ref path, ref nested, .. }) => {\n-                let name = path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_ref();\n-\n-                match name {\n-                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n-                    | \"suggestion_verbose\" => (),\n-                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag\n-                            .help(\"only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\")\n-                    }),\n-                };\n+        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n \n-                let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_ref();\n+        match name {\n+            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n+                return self.generate_inner_field_code_suggestion(attr, info);\n+            }\n+            \"label\" | \"help\" | \"note\" => (),\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\n+                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n+                     valid field attributes\",\n+                )\n+            }),\n+        }\n \n-                let mut msg = None;\n-                let mut code = None;\n+        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n+        // path, e.g. `#[label(typeck::label)]`.\n+        let mut nested_iter = nested.into_iter();\n+        let msg = match nested_iter.next() {\n+            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n+            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            None => throw_invalid_attr!(attr, &meta),\n+        };\n \n-                for nested_attr in nested {\n-                    let meta = match nested_attr {\n-                        syn::NestedMeta::Meta(ref meta) => meta,\n-                        syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n-                    };\n+        // None of these attributes should have anything following the slug.\n+        if nested_iter.next().is_some() {\n+            throw_invalid_attr!(attr, &meta);\n+        }\n \n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-                    match meta {\n-                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                            let span = meta.span().unwrap();\n-                            match nested_name {\n-                                \"message\" => {\n-                                    msg = Some(s.value());\n-                                }\n-                                \"code\" => {\n-                                    let formatted_str = self.build_format(&s.value(), s.span());\n-                                    code = Some(formatted_str);\n+        match name {\n+            \"label\" => {\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n+                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n+            }\n+            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n+            \"note\" | \"help\" => {\n+                report_type_error(attr, \"`Span` or `()`\")?;\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn generate_inner_field_code_suggestion(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+\n+        let mut meta = attr.parse_meta()?;\n+        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n+\n+        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+        let mut msg = None;\n+        let mut code = None;\n+\n+        let mut nested_iter = nested.into_iter().peekable();\n+        if let Some(nested_attr) = nested_iter.peek() {\n+            if let NestedMeta::Meta(Meta::Path(path)) = nested_attr {\n+                msg = Some(path.clone());\n+            }\n+        };\n+        // Move the iterator forward if a path was found (don't otherwise so that\n+        // code/applicability can be found or an error emitted).\n+        if msg.is_some() {\n+            let _ = nested_iter.next();\n+        }\n+\n+        for nested_attr in nested_iter {\n+            let meta = match nested_attr {\n+                syn::NestedMeta::Meta(ref meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n+            };\n+\n+            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+            let nested_name = nested_name.as_str();\n+            match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    let span = meta.span().unwrap();\n+                    match nested_name {\n+                        \"code\" => {\n+                            let formatted_str = self.build_format(&s.value(), s.span());\n+                            code = Some(formatted_str);\n+                        }\n+                        \"applicability\" => {\n+                            applicability = match applicability {\n+                                Some(v) => {\n+                                    span_err(\n+                                        span,\n+                                        \"applicability cannot be set in both the field and \\\n+                                         attribute\",\n+                                    )\n+                                    .emit();\n+                                    Some(v)\n                                 }\n-                                \"applicability\" => {\n-                                    applicability = match applicability {\n-                                        Some(v) => {\n-                                            span_err(\n-                                                span,\n-                                                \"applicability cannot be set in both the field and attribute\"\n-                                            ).emit();\n-                                            Some(v)\n-                                        }\n-                                        None => match Applicability::from_str(&s.value()) {\n-                                            Ok(v) => Some(quote! { #v }),\n-                                            Err(()) => {\n-                                                span_err(span, \"invalid applicability\").emit();\n-                                                None\n-                                            }\n-                                        },\n+                                None => match Applicability::from_str(&s.value()) {\n+                                    Ok(v) => Some(quote! { #v }),\n+                                    Err(()) => {\n+                                        span_err(span, \"invalid applicability\").emit();\n+                                        None\n                                     }\n-                                }\n-                                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                    diag.help(\n-                                        \"only `message`, `code` and `applicability` are valid field attributes\",\n-                                    )\n-                                }),\n+                                },\n                             }\n                         }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\n+                                \"only `message`, `code` and `applicability` are valid field \\\n+                                 attributes\",\n+                            )\n+                        }),\n                     }\n                 }\n+                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                    if matches!(meta, Meta::Path(_)) {\n+                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                    } else {\n+                        diag\n+                    }\n+                }),\n+            }\n+        }\n \n-                let applicability = applicability\n-                    .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+        let applicability =\n+            applicability.unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n \n-                let method = format_ident!(\"span_{}\", name);\n+        let name = path.segments.last().unwrap().ident.to_string();\n+        let method = format_ident!(\"span_{}\", name);\n \n-                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n-                let msg = quote! { rustc_errors::SubdiagnosticMessage::attr(#msg) };\n-                let code = code.unwrap_or_else(|| quote! { String::new() });\n+        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n+        let msg = quote! { rustc_errors::fluent::#msg };\n+        let code = code.unwrap_or_else(|| quote! { String::new() });\n \n-                Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n+        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n     }\n \n     /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n@@ -526,24 +626,24 @@ impl SessionDiagnosticDeriveBuilder {\n         &self,\n         field_binding: TokenStream,\n         kind: &Ident,\n-        fluent_attr_identifier: &str,\n+        fluent_attr_identifier: Path,\n     ) -> TokenStream {\n         let diag = &self.diag;\n         let fn_name = format_ident!(\"span_{}\", kind);\n         quote! {\n             #diag.#fn_name(\n                 #field_binding,\n-                rustc_errors::SubdiagnosticMessage::attr(#fluent_attr_identifier)\n+                rustc_errors::fluent::#fluent_attr_identifier\n             );\n         }\n     }\n \n     /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n     /// and `fluent_attr_identifier`.\n-    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: &str) -> TokenStream {\n+    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: Path) -> TokenStream {\n         let diag = &self.diag;\n         quote! {\n-            #diag.#kind(rustc_errors::SubdiagnosticMessage::attr(#fluent_attr_identifier));\n+            #diag.#kind(rustc_errors::fluent::#fluent_attr_identifier);\n         }\n     }\n \n@@ -569,7 +669,8 @@ impl SessionDiagnosticDeriveBuilder {\n                         } else {\n                             throw_span_err!(\n                                 info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one `Span`\"\n                             );\n                         }\n                     } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n@@ -578,7 +679,8 @@ impl SessionDiagnosticDeriveBuilder {\n                         } else {\n                             throw_span_err!(\n                                 info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                                \"type of field annotated with `#[suggestion(...)]` contains more \\\n+                                 than one Applicability\"\n                             );\n                         }\n                     }\n@@ -595,12 +697,18 @@ impl SessionDiagnosticDeriveBuilder {\n                 }\n \n                 throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                    diag.help(\n+                        \"`#[suggestion(...)]` on a tuple field must be applied to fields of type \\\n+                         `(Span, Applicability)`\",\n+                    )\n                 });\n             }\n             // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n             _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n-                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+                diag.help(\n+                    \"`#[suggestion(...)]` should be applied to fields of type `Span` or \\\n+                     `(Span, Applicability)`\",\n+                )\n             }),\n         }\n     }"}, {"sha": "d088402abc6da21db0ac3bc62f6c078802d73d91", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -39,6 +39,19 @@ pub(crate) fn _throw_err(\n     SessionDiagnosticDeriveError::ErrorHandled\n }\n \n+/// Helper function for printing `syn::Path` - doesn't handle arguments in paths and these are\n+/// unlikely to come up much in use of the macro.\n+fn path_to_string(path: &syn::Path) -> String {\n+    let mut out = String::new();\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i > 0 || path.leading_colon.is_some() {\n+            out.push_str(\"::\");\n+        }\n+        out.push_str(&segment.ident.to_string());\n+    }\n+    out\n+}\n+\n /// Returns an error diagnostic on span `span` with msg `msg`.\n pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n     Diagnostic::spanned(span, Level::Error, msg)\n@@ -61,15 +74,13 @@ pub(crate) use throw_span_err;\n /// Returns an error diagnostic for an invalid attribute.\n pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n     let span = attr.span().unwrap();\n-    let name = attr.path.segments.last().unwrap().ident.to_string();\n-    let name = name.as_str();\n-\n+    let path = path_to_string(&attr.path);\n     match meta {\n-        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", name)),\n+        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", path)),\n         Meta::NameValue(_) => {\n-            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", name))\n+            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", path))\n         }\n-        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", name)),\n+        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", path)),\n     }\n }\n \n@@ -101,18 +112,16 @@ pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diag\n     };\n \n     let span = meta.span().unwrap();\n-    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-    let nested_name = nested_name.as_str();\n+    let path = path_to_string(meta.path());\n     match meta {\n-        Meta::NameValue(..) => span_err(\n-            span,\n-            &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, nested_name),\n-        ),\n+        Meta::NameValue(..) => {\n+            span_err(span, &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, path))\n+        }\n         Meta::Path(..) => {\n-            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, nested_name))\n+            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, path))\n         }\n         Meta::List(..) => {\n-            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, nested_name))\n+            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, path))\n         }\n     }\n }"}, {"sha": "2317186e65502d522809b84fd629b6db50610a3f", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -254,6 +254,17 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             ];\n \n             #generated\n+\n+            pub mod _subdiag {\n+                pub const note: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                pub const help: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                pub const label: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n+                pub const suggestion: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"suggestion\"));\n+            }\n         }\n     }\n     .into()"}, {"sha": "2eee4bfb5dd45bce0a254ce43cb15668b59183a4", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -22,14 +22,14 @@ use synstructure::Structure;\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(SessionDiagnostic)]\n-/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n+/// #[error(borrowck::move_out_of_borrow, code = \"E0505\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n ///     #[primary_span]\n ///     #[label]\n ///     pub span: Span,\n-///     #[label = \"first-borrow-label\"]\n+///     #[label(borrowck::first_borrow_label)]\n ///     pub first_borrow_span: Span,\n ///     #[suggestion(code = \"{name}.clone()\")]\n ///     pub clone_sugg: Option<(Span, Applicability)>\n@@ -72,12 +72,12 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```ignore (rust)\n /// #[derive(SessionSubdiagnostic)]\n /// pub enum ExpectedIdentifierLabel<'tcx> {\n-///     #[label(slug = \"parser-expected-identifier\")]\n+///     #[label(parser::expected_identifier)]\n ///     WithoutFound {\n ///         #[primary_span]\n ///         span: Span,\n ///     }\n-///     #[label(slug = \"parser-expected-identifier-found\")]\n+///     #[label(parser::expected_identifier_found)]\n ///     WithFound {\n ///         #[primary_span]\n ///         span: Span,\n@@ -86,7 +86,7 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// }\n ///\n /// #[derive(SessionSubdiagnostic)]\n-/// #[suggestion_verbose(slug = \"parser-raw-identifier\")]\n+/// #[suggestion_verbose(parser::raw_identifier)]\n /// pub struct RawIdentifierSuggestion<'tcx> {\n ///     #[primary_span]\n ///     span: Span,"}, {"sha": "eab954a9c1bf9c886577b3b63b1d627a29ed8ab7", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 72, "deletions": 12, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -13,7 +13,7 @@ use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::fmt;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Meta, MetaList, MetaNameValue};\n+use syn::{parse_quote, spanned::Spanned, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// Which kind of suggestion is being created?\n@@ -194,8 +194,8 @@ struct SessionSubdiagnosticDeriveBuilder<'a> {\n     kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n \n     /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n-    /// `#[kind(slug = \"...\")]` attribute on the type or variant.\n-    slug: Option<(String, proc_macro::Span)>,\n+    /// `#[kind(slug)]` attribute on the type or variant.\n+    slug: Option<(Path, proc_macro::Span)>,\n     /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n     /// attribute on the type or variant.\n     code: Option<(TokenStream, proc_macro::Span)>,\n@@ -224,9 +224,34 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n             let meta = attr.parse_meta()?;\n             let kind = match meta {\n                 Meta::List(MetaList { ref nested, .. }) => {\n-                    for nested_attr in nested {\n+                    let mut nested_iter = nested.into_iter();\n+                    if let Some(nested_attr) = nested_iter.next() {\n+                        match nested_attr {\n+                            NestedMeta::Meta(Meta::Path(path)) => {\n+                                self.slug.set_once((path.clone(), span));\n+                            }\n+                            NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                                if matches!(\n+                                    meta.path().segments.last().unwrap().ident.to_string().as_str(),\n+                                    \"code\" | \"applicability\"\n+                                ) =>\n+                            {\n+                                // don't error for valid follow-up attributes\n+                            }\n+                            nested_attr => {\n+                                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                    diag.help(\n+                                        \"first argument of the attribute should be the diagnostic \\\n+                                         slug\",\n+                                    )\n+                                })\n+                            }\n+                        };\n+                    }\n+\n+                    for nested_attr in nested_iter {\n                         let meta = match nested_attr {\n-                            syn::NestedMeta::Meta(ref meta) => meta,\n+                            NestedMeta::Meta(ref meta) => meta,\n                             _ => throw_invalid_nested_attr!(attr, &nested_attr),\n                         };\n \n@@ -241,7 +266,6 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n                                         let formatted_str = self.build_format(&s.value(), s.span());\n                                         self.code.set_once((formatted_str, span));\n                                     }\n-                                    \"slug\" => self.slug.set_once((s.value(), span)),\n                                     \"applicability\" => {\n                                         let value = match Applicability::from_str(&s.value()) {\n                                             Ok(v) => v,\n@@ -253,11 +277,23 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n                                         self.applicability.set_once((quote! { #value }, span));\n                                     }\n                                     _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                        diag.help(\"only `code`, `slug` and `applicability` are valid nested attributes\")\n+                                        diag.help(\n+                                            \"only `code` and `applicability` are valid nested \\\n+                                             attributes\",\n+                                        )\n                                     }),\n                                 }\n                             }\n-                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                            _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                if matches!(meta, Meta::Path(_)) {\n+                                    diag.help(\n+                                        \"a diagnostic slug must be the first argument to the \\\n+                                         attribute\",\n+                                    )\n+                                } else {\n+                                    diag\n+                                }\n+                            }),\n                         }\n                     }\n \n@@ -281,10 +317,27 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n                 );\n             }\n \n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.applicability.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n+                        name\n+                    )\n+                );\n+            }\n+\n             if self.slug.is_none() {\n                 throw_span_err!(\n                     span,\n-                    &format!(\"`slug` must be set in a `#[{}(...)]` attribute\", name)\n+                    &format!(\n+                        \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n+                        name\n+                    )\n                 );\n             }\n \n@@ -335,7 +388,10 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n                         return Ok(quote! {});\n                     }\n                     _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                        diag.help(\"only `primary_span`, `applicability` and `skip_arg` are valid field attributes\")\n+                        diag.help(\n+                            \"only `primary_span`, `applicability` and `skip_arg` are valid field \\\n+                             attributes\",\n+                        )\n                     }),\n                 },\n                 _ => throw_invalid_attr!(attr, &meta),\n@@ -375,7 +431,11 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n         }\n \n         // Missing slug errors will already have been reported.\n-        let slug = self.slug.as_ref().map(|(slug, _)| &**slug).unwrap_or(\"missing-slug\");\n+        let slug = self\n+            .slug\n+            .as_ref()\n+            .map(|(slug, _)| slug.clone())\n+            .unwrap_or_else(|| parse_quote! { you::need::to::specify::a::slug });\n         let code = match self.code.as_ref() {\n             Some((code, _)) => Some(quote! { #code }),\n             None if is_suggestion => {\n@@ -397,7 +457,7 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n \n         let diag = &self.diag;\n         let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n-        let message = quote! { rustc_errors::SubdiagnosticMessage::message(#slug) };\n+        let message = quote! { rustc_errors::fluent::#slug };\n         let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n             if let Some(span) = span_field {\n                 quote! { #diag.#name(#span, #message, #code, #applicability); }"}, {"sha": "58d5d43cfbfa83ff4e32cb38f294a9dfaa9ae149", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -244,7 +244,7 @@ impl MultiSugg {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-maybe-report-ambiguous-plus\")]\n+#[error(parser::maybe_report_ambiguous_plus)]\n struct AmbiguousPlus {\n     pub sum_ty: String,\n     #[primary_span]\n@@ -253,7 +253,7 @@ struct AmbiguousPlus {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0178\", slug = \"parser-maybe-recover-from-bad-type-plus\")]\n+#[error(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n struct BadTypePlus {\n     pub ty: String,\n     #[primary_span]\n@@ -265,7 +265,7 @@ struct BadTypePlus {\n #[derive(SessionSubdiagnostic)]\n pub enum BadTypePlusSub {\n     #[suggestion(\n-        slug = \"parser-add-paren\",\n+        parser::add_paren,\n         code = \"{sum_with_parens}\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -274,20 +274,20 @@ pub enum BadTypePlusSub {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(slug = \"parser-forgot-paren\")]\n+    #[label(parser::forgot_paren)]\n     ForgotParen {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(slug = \"parser-expect-path\")]\n+    #[label(parser::expect_path)]\n     ExpectPath {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-maybe-recover-from-bad-qpath-stage-2\")]\n+#[error(parser::maybe_recover_from_bad_qpath_stage_2)]\n struct BadQPathStage2 {\n     #[primary_span]\n     #[suggestion(applicability = \"maybe-incorrect\")]\n@@ -296,7 +296,7 @@ struct BadQPathStage2 {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-semicolon\")]\n+#[error(parser::incorrect_semicolon)]\n struct IncorrectSemicolon<'a> {\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\")]\n@@ -307,26 +307,26 @@ struct IncorrectSemicolon<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-use-of-await\")]\n+#[error(parser::incorrect_use_of_await)]\n struct IncorrectUseOfAwait {\n     #[primary_span]\n-    #[suggestion(message = \"parentheses-suggestion\", applicability = \"machine-applicable\")]\n+    #[suggestion(parser::parentheses_suggestion, applicability = \"machine-applicable\")]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-incorrect-use-of-await\")]\n+#[error(parser::incorrect_use_of_await)]\n struct IncorrectAwait {\n     #[primary_span]\n     span: Span,\n-    #[suggestion(message = \"postfix-suggestion\", code = \"{expr}.await{question_mark}\")]\n+    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n     sugg_span: (Span, Applicability),\n     expr: String,\n     question_mark: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-in-in-typo\")]\n+#[error(parser::in_in_typo)]\n struct InInTypo {\n     #[primary_span]\n     span: Span,"}, {"sha": "4cdec615d8290352067207817dc8dd95ddff0823", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -6,18 +6,18 @@ use rustc_session::{parse::ParseSess, SessionDiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0062\", slug = \"typeck-field-multiply-specified-in-initializer\")]\n+#[error(typeck::field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-use-label\"]\n+    #[label(typeck::previous_use_label)]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0092\", slug = \"typeck-unrecognized-atomic-operation\")]\n+#[error(typeck::unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n     #[primary_span]\n     #[label]\n@@ -26,7 +26,7 @@ pub struct UnrecognizedAtomicOperation<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0094\", slug = \"typeck-wrong-number-of-generic-arguments-to-intrinsic\")]\n+#[error(typeck::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n     #[primary_span]\n     #[label]\n@@ -37,7 +37,7 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0093\", slug = \"typeck-unrecognized-intrinsic-function\")]\n+#[error(typeck::unrecognized_intrinsic_function, code = \"E0093\")]\n pub struct UnrecognizedIntrinsicFunction {\n     #[primary_span]\n     #[label]\n@@ -46,92 +46,92 @@ pub struct UnrecognizedIntrinsicFunction {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\n+#[error(typeck::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"generics-label\"]\n+    #[label(typeck::generics_label)]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0120\", slug = \"typeck-drop-impl-on-wrong-item\")]\n+#[error(typeck::drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0124\", slug = \"typeck-field-already-declared\")]\n+#[error(typeck::field_already_declared, code = \"E0124\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-decl-label\"]\n+    #[label(typeck::previous_decl_label)]\n     pub prev_span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0184\", slug = \"typeck-copy-impl-on-type-with-dtor\")]\n+#[error(typeck::copy_impl_on_type_with_dtor, code = \"E0184\")]\n pub struct CopyImplOnTypeWithDtor {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0203\", slug = \"typeck-multiple-relaxed-default-bounds\")]\n+#[error(typeck::multiple_relaxed_default_bounds, code = \"E0203\")]\n pub struct MultipleRelaxedDefaultBounds {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0206\", slug = \"typeck-copy-impl-on-non-adt\")]\n+#[error(typeck::copy_impl_on_non_adt, code = \"E0206\")]\n pub struct CopyImplOnNonAdt {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0224\", slug = \"typeck-trait-object-declared-with-no-traits\")]\n+#[error(typeck::trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label = \"alias-span\"]\n+    #[label(typeck::alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0227\", slug = \"typeck-ambiguous-lifetime-bound\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0227\")]\n pub struct AmbiguousLifetimeBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0229\", slug = \"typeck-assoc-type-binding-not-allowed\")]\n+#[error(typeck::assoc_type_binding_not_allowed, code = \"E0229\")]\n pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0436\", slug = \"typeck-functional-record-update-on-non-struct\")]\n+#[error(typeck::functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0516\", slug = \"typeck-typeof-reserved-keyword-used\")]\n+#[error(typeck::typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -142,52 +142,52 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0572\", slug = \"typeck-return-stmt-outside-of-fn-body\")]\n+#[error(typeck::return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n-    #[label = \"encl-body-label\"]\n+    #[label(typeck::encl_body_label)]\n     pub encl_body_span: Option<Span>,\n-    #[label = \"encl-fn-label\"]\n+    #[label(typeck::encl_fn_label)]\n     pub encl_fn_span: Option<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0627\", slug = \"typeck-yield-expr-outside-of-generator\")]\n+#[error(typeck::yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0639\", slug = \"typeck-struct-expr-non-exhaustive\")]\n+#[error(typeck::struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0699\", slug = \"typeck-method-call-on-unknown-type\")]\n+#[error(typeck::method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0719\", slug = \"typeck-value-of-associated-struct-already-specified\")]\n+#[error(typeck::value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label = \"previous-bound-label\"]\n+    #[label(typeck::previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0745\", slug = \"typeck-address-of-temporary-taken\")]\n+#[error(typeck::address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -197,7 +197,7 @@ pub struct AddressOfTemporaryTaken {\n #[derive(SessionSubdiagnostic)]\n pub enum AddReturnTypeSuggestion<'tcx> {\n     #[suggestion(\n-        slug = \"typeck-add-return-type-add\",\n+        typeck::add_return_type_add,\n         code = \"-> {found} \",\n         applicability = \"machine-applicable\"\n     )]\n@@ -207,7 +207,7 @@ pub enum AddReturnTypeSuggestion<'tcx> {\n         found: Ty<'tcx>,\n     },\n     #[suggestion(\n-        slug = \"typeck-add-return-type-missing-here\",\n+        typeck::add_return_type_missing_here,\n         code = \"-> _ \",\n         applicability = \"has-placeholders\"\n     )]\n@@ -219,12 +219,12 @@ pub enum AddReturnTypeSuggestion<'tcx> {\n \n #[derive(SessionSubdiagnostic)]\n pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(slug = \"typeck-expected-default-return-type\")]\n+    #[label(typeck::expected_default_return_type)]\n     Unit {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(slug = \"typeck-expected-return-type\")]\n+    #[label(typeck::expected_return_type)]\n     Other {\n         #[primary_span]\n         span: Span,\n@@ -233,7 +233,7 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"typeck-unconstrained-opaque-type\")]\n+#[error(typeck::unconstrained_opaque_type)]\n #[note]\n pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n@@ -301,7 +301,7 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0183\", slug = \"typeck-manual-implementation\")]\n+#[error(typeck::manual_implementation, code = \"E0183\")]\n #[help]\n pub struct ManualImplementation {\n     #[primary_span]\n@@ -311,7 +311,7 @@ pub struct ManualImplementation {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"typeck-substs-on-overridden-impl\")]\n+#[error(typeck::substs_on_overridden_impl)]\n pub struct SubstsOnOverriddenImpl {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "d6f63d44ba6a87d7398205dfc51773f32dd6c826", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -16,14 +16,14 @@ use rustc_session::{parse::ParseSess, SessionDiagnostic};\n use rustc_span::Span;\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"parser-expect-path\")]\n+#[error(parser::expect_path)]\n struct DeriveSessionDiagnostic {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[note(slug = \"note\")]\n+#[note(parser::add_paren)]\n struct Note {\n     #[primary_span]\n     span: Span,"}, {"sha": "7bec1897fa53e56fd637ba4e8d9682dcb515d4d6", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 137, "deletions": 104, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -26,29 +26,29 @@ use rustc_errors::Applicability;\n extern crate rustc_session;\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"hello-world\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct Hello {}\n \n #[derive(SessionDiagnostic)]\n-#[warning(code = \"E0123\", slug = \"hello-world\")]\n+#[warning(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct HelloWarn {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n //~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n enum SessionDiagnosticOnEnum {\n     Foo,\n     Bar,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[error = \"E0123\"]\n //~^ ERROR `#[error = ...]` is not a valid attribute\n struct WrongStructAttrStyle {}\n \n #[derive(SessionDiagnostic)]\n-#[nonsense(code = \"E0123\", slug = \"foo\")]\n+#[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n //~^ ERROR `#[nonsense(...)]` is not a valid attribute\n //~^^ ERROR diagnostic kind not specified\n //~^^^ ERROR cannot find attribute `nonsense` in this scope\n@@ -57,84 +57,93 @@ struct InvalidStructAttr {}\n #[derive(SessionDiagnostic)]\n #[error(\"E0123\")]\n //~^ ERROR `#[error(\"...\")]` is not a valid attribute\n-//~^^ ERROR `slug` not specified\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidLitNestedAttr {}\n \n #[derive(SessionDiagnostic)]\n-#[error(nonsense, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense)]` is not a valid attribute\n+#[error(nonsense, code = \"E0123\")]\n+//~^ ERROR cannot find value `nonsense` in module `rustc_errors::fluent`\n struct InvalidNestedStructAttr {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense(...))]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr1 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr2 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n+//~^^ ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr3 {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(slug = ...)]` is not a valid attribute\n+struct InvalidNestedStructAttr4 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct WrongPlaceField {\n     #[suggestion = \"bar\"]\n     //~^ ERROR `#[suggestion = ...]` is not a valid attribute\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[error(code = \"E0456\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n //~^^^ ERROR specified multiple times\n struct ErrorSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[warning(code = \"E0293\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n //~^^^ ERROR specified multiple times\n struct WarnSpecifiedAfterError {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n //~^ ERROR specified multiple times\n struct CodeSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-//~^ ERROR specified multiple times\n+#[error(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+//~^ ERROR `#[error(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n struct SlugSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n struct KindNotProvided {} //~ ERROR diagnostic kind not specified\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\")] //~ ERROR `slug` not specified\n+#[error(code = \"E0456\")]\n+//~^ ERROR diagnostic slug not specified\n struct SlugNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound)]\n struct CodeNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n     foo: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct InvalidPathFieldAttr {\n     #[nonsense]\n     //~^ ERROR `#[nonsense]` is not a valid attribute\n@@ -143,183 +152,183 @@ struct InvalidPathFieldAttr {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithField {\n     name: String,\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n-    #[label = \"bar\"]\n-    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+    #[label(typeck::label)]\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n     name: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNonexistentField {\n-    #[suggestion(message = \"bar\", code = \"{name}\")]\n+    #[suggestion(typeck::suggestion, code = \"{name}\")]\n     //~^ ERROR `name` doesn't refer to a field on this type\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR invalid format string: expected `'}'`\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorMissingClosingBrace {\n-    #[suggestion(message = \"bar\", code = \"{name\")]\n+    #[suggestion(typeck::suggestion, code = \"{name\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR invalid format string: unmatched `}`\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorMissingOpeningBrace {\n-    #[suggestion(message = \"bar\", code = \"name}\")]\n+    #[suggestion(typeck::suggestion, code = \"name}\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnSpan {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnNonSpan {\n-    #[label = \"bar\"]\n-    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+    #[label(typeck::label)]\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n     id: u32,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct Suggest {\n-    #[suggestion(message = \"bar\", code = \"This is the suggested code\")]\n-    #[suggestion_short(message = \"qux\", code = \"This is the suggested code\")]\n-    #[suggestion_hidden(message = \"foobar\", code = \"This is the suggested code\")]\n-    #[suggestion_verbose(message = \"fooqux\", code = \"This is the suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_short(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_hidden(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_verbose(typeck::suggestion, code = \"This is the suggested code\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutCode {\n-    #[suggestion(message = \"bar\")]\n+    #[suggestion(typeck::suggestion)]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutMsg {\n     #[suggestion(code = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithTypesSwapped {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithSpanOnly {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n     suggestion: (Span, Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n-    #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n     suggestion: (Applicability, Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct WrongKindOfAnnotation {\n-    #[label(\"bar\")]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    #[label = \"bar\"]\n+    //~^ ERROR `#[label = ...]` is not a valid attribute\n     z: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct OptionsInErrors {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     label: Option<Span>,\n-    #[suggestion(message = \"bar\")]\n+    #[suggestion(typeck::suggestion)]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n     #[primary_span]\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n-    #[label = \"qux\"]\n+    #[label(typeck::label)]\n     other_span: Span,\n-    #[suggestion(message = \"bar\", code = \"{name}.clone()\")]\n+    #[suggestion(typeck::suggestion, code = \"{name}.clone()\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithLifetime<'a> {\n-    #[label = \"bar\"]\n+    #[label(typeck::label)]\n     span: Span,\n     name: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithDefaultLabelAttr<'a> {\n     #[label]\n     span: Span,\n@@ -328,15 +337,15 @@ struct ErrorWithDefaultLabelAttr<'a> {\n \n #[derive(SessionDiagnostic)]\n //~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ArgFieldWithoutSkip {\n     #[primary_span]\n     span: Span,\n     other: Hello,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ArgFieldWithSkip {\n     #[primary_span]\n     span: Span,\n@@ -347,156 +356,180 @@ struct ArgFieldWithSkip {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedNote {\n     #[note]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedNoteCustom {\n-    #[note = \"bar\"]\n+    #[note(typeck::note)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[note]\n struct ErrorWithNote {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[note = \"bar\"]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[note(typeck::note)]\n struct ErrorWithNoteCustom {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedHelp {\n     #[help]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithSpannedHelpCustom {\n-    #[help = \"bar\"]\n+    #[help(typeck::help)]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n #[help]\n struct ErrorWithHelp {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n-#[help = \"bar\"]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[help(typeck::help)]\n struct ErrorWithHelpCustom {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n #[help]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithHelpWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[help = \"bar\"]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[help(typeck::help)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithHelpCustomWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n #[note]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNoteWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[note = \"bar\"]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[note(typeck::note)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithNoteCustomWrongOrder {\n     val: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ApplicabilityInBoth {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     //~^ ERROR applicability cannot be set in both the field and attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct InvalidApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n     //~^ ERROR invalid applicability\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ValidApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct NoApplicability {\n-    #[suggestion(message = \"bar\", code = \"...\")]\n+    #[suggestion(typeck::suggestion, code = \"...\")]\n     suggestion: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[note(slug = \"note\")]\n+#[note(parser::add_paren)]\n struct Note;\n \n #[derive(SessionDiagnostic)]\n-#[error(slug = \"subdiagnostic\")]\n+#[error(typeck::ambiguous_lifetime_bound)]\n struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct VecField {\n     #[primary_span]\n     #[label]\n     spans: Vec<Span>,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct UnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: (),\n-    #[help = \"a\"]\n+    #[help(typeck::help)]\n     bar: (),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct OptUnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: Option<()>,\n-    #[help = \"a\"]\n+    #[help(typeck::help)]\n     bar: Option<()>,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingPath {\n+    #[label(typeck::label, foo)]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingNameValue {\n+    #[label(typeck::label, foo = \"...\")]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct LabelWithTrailingList {\n+    #[label(typeck::label, foo(\"...\"))]\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    span: Span,\n+}"}, {"sha": "0d9690e1f5a998437943d7715c784956bd8fa2f0", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 172, "deletions": 115, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -1,7 +1,7 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n   --> $DIR/diagnostic-derive.rs:37:1\n    |\n-LL | / #[error(code = \"E0123\", slug = \"foo\")]\n+LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n LL | | enum SessionDiagnosticOnEnum {\n LL | |     Foo,\n@@ -18,15 +18,15 @@ LL | #[error = \"E0123\"]\n error: `#[nonsense(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:51:1\n    |\n-LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: only `error` and `warning` are valid attributes\n+   = help: only `error`, `warning`, `help` and `note` are valid attributes\n \n error: diagnostic kind not specified\n   --> $DIR/diagnostic-derive.rs:51:1\n    |\n-LL | / #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | / #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n@@ -40,8 +40,10 @@ error: `#[error(\"...\")]` is not a valid attribute\n    |\n LL | #[error(\"E0123\")]\n    |         ^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `slug` not specified\n+error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:58:1\n    |\n LL | / #[error(\"E0123\")]\n@@ -50,183 +52,215 @@ LL | |\n LL | | struct InvalidLitNestedAttr {}\n    | |______________________________^\n    |\n-   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n-\n-error: `#[error(nonsense)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:64:9\n-   |\n-LL | #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n-   |         ^^^^^^^^\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense(...))]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:69:9\n    |\n LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:69:1\n+   |\n+LL | / #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr1 {}\n+   | |__________________________________^\n+   |\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:74:9\n+  --> $DIR/diagnostic-derive.rs:75:9\n    |\n LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^^\n    |\n-   = help: only `slug` and `code` are valid nested attributes\n+   = help: first argument of the attribute should be the diagnostic slug\n+\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:75:1\n+   |\n+LL | / #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr2 {}\n+   | |__________________________________^\n+   |\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:79:9\n+  --> $DIR/diagnostic-derive.rs:81:9\n    |\n LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:86:5\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:81:1\n    |\n-LL |     #[suggestion = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+LL | / #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidNestedStructAttr3 {}\n+   | |__________________________________^\n    |\n-   = help: only `label`, `note` and `help` are valid field attributes\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n-error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:1\n+error: `#[error(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:87:59\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n+   |                                                           ^^^^^^^^^^^^\n    |\n-note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:1\n+   = help: only `code` is a valid nested attributes following the slug\n+\n+error: `#[suggestion = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:94:5\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:16\n+  --> $DIR/diagnostic-derive.rs:101:1\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:16\n+  --> $DIR/diagnostic-derive.rs:100:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:93:32\n+  --> $DIR/diagnostic-derive.rs:101:1\n    |\n-LL | #[error(code = \"E0456\", slug = \"bar\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:92:32\n+  --> $DIR/diagnostic-derive.rs:100:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:1\n+  --> $DIR/diagnostic-derive.rs:101:50\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   |                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:1\n+  --> $DIR/diagnostic-derive.rs:100:50\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:18\n+  --> $DIR/diagnostic-derive.rs:109:1\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   |                  ^^^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:16\n+  --> $DIR/diagnostic-derive.rs:108:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:34\n+  --> $DIR/diagnostic-derive.rs:109:1\n    |\n-LL | #[warning(code = \"E0293\", slug = \"bar\")]\n-   |                                  ^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:32\n+  --> $DIR/diagnostic-derive.rs:108:1\n    |\n-LL | #[error(code = \"E0123\", slug = \"foo\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:108:32\n+  --> $DIR/diagnostic-derive.rs:109:52\n    |\n-LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n-   |                                ^^^^^^^\n+LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n+   |                                                    ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:16\n+  --> $DIR/diagnostic-derive.rs:108:50\n    |\n-LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n-   |                ^^^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+   |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:113:46\n+  --> $DIR/diagnostic-derive.rs:116:66\n    |\n-LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-   |                                              ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n+   |                                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:113:32\n+  --> $DIR/diagnostic-derive.rs:116:50\n    |\n-LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n-   |                                ^^^^^\n+LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n+   |                                                  ^^^^^^^\n+\n+error: `#[error(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:121:43\n+   |\n+LL | #[error(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic kind not specified\n-  --> $DIR/diagnostic-derive.rs:118:1\n+  --> $DIR/diagnostic-derive.rs:126:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use the `#[error(...)]` attribute to create an error\n \n-error: `slug` not specified\n-  --> $DIR/diagnostic-derive.rs:121:1\n+error: diagnostic slug not specified\n+  --> $DIR/diagnostic-derive.rs:129:1\n    |\n LL | / #[error(code = \"E0456\")]\n+LL | |\n LL | | struct SlugNotProvided {}\n    | |_________________________^\n    |\n-   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n+   = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:131:5\n+  --> $DIR/diagnostic-derive.rs:140:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:139:5\n+  --> $DIR/diagnostic-derive.rs:148:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n-error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:156:5\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/diagnostic-derive.rs:165:5\n    |\n-LL |     #[label = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:164:42\n+  --> $DIR/diagnostic-derive.rs:173:45\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"{name}\")]\n-   |                                          ^^^^^^^^\n+LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n+   |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:169:16\n+  --> $DIR/diagnostic-derive.rs:178:16\n    |\n LL | #[derive(SessionDiagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -237,96 +271,118 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:179:15\n+  --> $DIR/diagnostic-derive.rs:188:15\n    |\n LL | #[derive(SessionDiagnostic)]\n    |               ^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:199:5\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/diagnostic-derive.rs:208:5\n    |\n-LL |     #[label = \"bar\"]\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:224:18\n+  --> $DIR/diagnostic-derive.rs:233:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:232:18\n+  --> $DIR/diagnostic-derive.rs:241:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:254:5\n+  --> $DIR/diagnostic-derive.rs:263:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: Applicability,\n    | |_____________________________^\n    |\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/diagnostic-derive.rs:269:5\n+  --> $DIR/diagnostic-derive.rs:278:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/diagnostic-derive.rs:277:5\n+  --> $DIR/diagnostic-derive.rs:286:5\n    |\n-LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n+LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:285:5\n-   |\n-LL |     #[label(\"bar\")]\n-   |     ^^^^^^^^^^^^^^^\n+error: `#[label = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:294:5\n    |\n-   = help: only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\n+LL |     #[label = \"bar\"]\n+   |     ^^^^^^^^^^^^^^^^\n \n error: applicability cannot be set in both the field and attribute\n-  --> $DIR/diagnostic-derive.rs:436:49\n+  --> $DIR/diagnostic-derive.rs:445:52\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:444:49\n+  --> $DIR/diagnostic-derive.rs:453:52\n+   |\n+LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n+   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:516:5\n+   |\n+LL |     #[label(typeck::label, foo)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:524:5\n+   |\n+LL |     #[label(typeck::label, foo = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:532:5\n    |\n-LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(typeck::label, foo(\"...\"))]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:51:3\n    |\n-LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:139:7\n+  --> $DIR/diagnostic-derive.rs:148:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n+error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n+  --> $DIR/diagnostic-derive.rs:64:9\n+   |\n+LL | #[error(nonsense, code = \"E0123\")]\n+   |         ^^^^^^^^ not found in `rustc_errors::fluent`\n+\n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:329:10\n+  --> $DIR/diagnostic-derive.rs:338:10\n    |\n LL | #[derive(SessionDiagnostic)]\n    |          ^^^^^^^^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -345,6 +401,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 39 previous errors\n+error: aborting due to 46 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0425.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "6f4b6105b3e49314b8965abb3b887b7884cbc1b9", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 84, "deletions": 75, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -20,7 +20,7 @@ use rustc_span::Span;\n use rustc_macros::SessionSubdiagnostic;\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-a\")]\n+#[label(parser::add_paren)]\n struct A {\n     #[primary_span]\n     span: Span,\n@@ -29,13 +29,13 @@ struct A {\n \n #[derive(SessionSubdiagnostic)]\n enum B {\n-    #[label(slug = \"label-b-a\")]\n+    #[label(parser::add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n         var: String,\n     },\n-    #[label(slug = \"label-b-b\")]\n+    #[label(parser::add_paren)]\n     B {\n         #[primary_span]\n         span: Span,\n@@ -44,7 +44,7 @@ enum B {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-c\")]\n+#[label(parser::add_paren)]\n //~^ ERROR label without `#[primary_span]` field\n struct C {\n     var: String,\n@@ -116,7 +116,8 @@ struct K {\n \n #[derive(SessionSubdiagnostic)]\n #[label(slug)]\n-//~^ ERROR `#[label(slug)]` is not a valid attribute\n+//~^ ERROR cannot find value `slug` in module `rustc_errors::fluent`\n+//~^^ NOTE not found in `rustc_errors::fluent`\n struct L {\n     #[primary_span]\n     span: Span,\n@@ -125,28 +126,37 @@ struct L {\n \n #[derive(SessionSubdiagnostic)]\n #[label()]\n-//~^ ERROR `slug` must be set in a `#[label(...)]` attribute\n+//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n struct M {\n     #[primary_span]\n     span: Span,\n     var: String,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(code = \"...\")]\n+#[label(parser::add_paren, code = \"...\")]\n //~^ ERROR `code` is not a valid nested attribute of a `label` attribute\n struct N {\n     #[primary_span]\n     span: Span,\n     var: String,\n }\n \n+#[derive(SessionSubdiagnostic)]\n+#[label(parser::add_paren, applicability = \"machine-applicable\")]\n+//~^ ERROR `applicability` is not a valid nested attribute of a `label` attribute\n+struct O {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n #[derive(SessionSubdiagnostic)]\n #[foo]\n //~^ ERROR cannot find attribute `foo` in this scope\n //~^^ ERROR unsupported type attribute for subdiagnostic enum\n-enum O {\n-    #[label(slug = \"...\")]\n+enum P {\n+    #[label(parser::add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -155,7 +165,7 @@ enum O {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum P {\n+enum Q {\n     #[bar]\n //~^ ERROR `#[bar]` is not a valid attribute\n //~^^ ERROR cannot find attribute `bar` in this scope\n@@ -167,7 +177,7 @@ enum P {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum Q {\n+enum R {\n     #[bar = \"...\"]\n //~^ ERROR `#[bar = ...]` is not a valid attribute\n //~^^ ERROR cannot find attribute `bar` in this scope\n@@ -179,7 +189,7 @@ enum Q {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum R {\n+enum S {\n     #[bar = 4]\n //~^ ERROR `#[bar = ...]` is not a valid attribute\n //~^^ ERROR cannot find attribute `bar` in this scope\n@@ -191,7 +201,7 @@ enum R {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum S {\n+enum T {\n     #[bar(\"...\")]\n //~^ ERROR `#[bar(\"...\")]` is not a valid attribute\n //~^^ ERROR cannot find attribute `bar` in this scope\n@@ -203,9 +213,9 @@ enum S {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum T {\n+enum U {\n     #[label(code = \"...\")]\n-//~^ ERROR `code` is not a valid nested attribute of a `label`\n+//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -214,8 +224,8 @@ enum T {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum U {\n-    #[label(slug = \"label-u\")]\n+enum V {\n+    #[label(parser::add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -230,17 +240,17 @@ enum U {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"...\")]\n+#[label(parser::add_paren)]\n //~^ ERROR label without `#[primary_span]` field\n-struct V {\n+struct W {\n     #[primary_span]\n     //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n     span: String,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"...\")]\n-struct W {\n+#[label(parser::add_paren)]\n+struct X {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n@@ -249,8 +259,8 @@ struct W {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"...\")]\n-struct X {\n+#[label(parser::add_paren)]\n+struct Y {\n     #[primary_span]\n     span: Span,\n     #[bar]\n@@ -260,8 +270,8 @@ struct X {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"...\")]\n-struct Y {\n+#[label(parser::add_paren)]\n+struct Z {\n     #[primary_span]\n     span: Span,\n     #[bar = \"...\"]\n@@ -271,8 +281,8 @@ struct Y {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"...\")]\n-struct Z {\n+#[label(parser::add_paren)]\n+struct AA {\n     #[primary_span]\n     span: Span,\n     #[bar(\"...\")]\n@@ -282,45 +292,44 @@ struct Z {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-aa\")]\n-struct AA {\n+#[label(parser::add_paren)]\n+struct AB {\n     #[primary_span]\n     span: Span,\n     #[skip_arg]\n     z: Z\n }\n \n #[derive(SessionSubdiagnostic)]\n-union AB {\n+union AC {\n //~^ ERROR unexpected unsupported untagged union\n     span: u32,\n     b: u64\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-ac-1\")]\n+#[label(parser::add_paren)]\n //~^ NOTE previously specified here\n //~^^ NOTE previously specified here\n-#[label(slug = \"label-ac-2\")]\n+#[label(parser::add_paren)]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n-struct AC {\n+struct AD {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n-//~^ ERROR specified multiple times\n-//~^^ NOTE previously specified here\n-struct AD {\n+#[label(parser::add_paren, parser::add_paren)]\n+//~^ ERROR `#[label(parser::add_paren)]` is not a valid attribute\n+struct AE {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[label(slug = \"label-ad-1\")]\n-struct AE {\n+#[label(parser::add_paren)]\n+struct AF {\n     #[primary_span]\n //~^ NOTE previously specified here\n     span_a: Span,\n@@ -330,15 +339,15 @@ struct AE {\n }\n \n #[derive(SessionSubdiagnostic)]\n-struct AF {\n+struct AG {\n //~^ ERROR subdiagnostic kind not specified\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"suggestion-af\", code = \"...\")]\n-struct AG {\n+#[suggestion(parser::add_paren, code = \"...\")]\n+struct AH {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n@@ -347,16 +356,16 @@ struct AG {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum AH {\n-    #[suggestion(slug = \"suggestion-ag-a\", code = \"...\")]\n+enum AI {\n+    #[suggestion(parser::add_paren, code = \"...\")]\n     A {\n         #[primary_span]\n         span: Span,\n         #[applicability]\n         applicability: Applicability,\n         var: String,\n     },\n-    #[suggestion(slug = \"suggestion-ag-b\", code = \"...\")]\n+    #[suggestion(parser::add_paren, code = \"...\")]\n     B {\n         #[primary_span]\n         span: Span,\n@@ -367,19 +376,19 @@ enum AH {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+#[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n //~^ ERROR specified multiple times\n //~^^ NOTE previously specified here\n-struct AI {\n+struct AJ {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n     applicability: Applicability,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code = \"...\")]\n-struct AJ {\n+#[suggestion(parser::add_paren, code = \"...\")]\n+struct AK {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n@@ -391,9 +400,9 @@ struct AJ {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code = \"...\")]\n+#[suggestion(parser::add_paren, code = \"...\")]\n //~^ ERROR suggestion without `applicability`\n-struct AK {\n+struct AL {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n@@ -402,61 +411,61 @@ struct AK {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code = \"...\")]\n+#[suggestion(parser::add_paren, code = \"...\")]\n //~^ ERROR suggestion without `applicability`\n-struct AL {\n+struct AM {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\")]\n+#[suggestion(parser::add_paren)]\n //~^ ERROR suggestion without `code = \"...\"`\n-struct AM {\n+struct AN {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n     applicability: Applicability,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n+#[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n //~^ ERROR invalid applicability\n-struct AN {\n+struct AO {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[help(slug = \"label-am\")]\n-struct AO {\n+#[help(parser::add_paren)]\n+struct AP {\n     var: String\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[note(slug = \"label-an\")]\n-struct AP;\n+#[note(parser::add_paren)]\n+struct AQ;\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code = \"...\")]\n+#[suggestion(parser::add_paren, code = \"...\")]\n //~^ ERROR suggestion without `applicability`\n //~^^ ERROR suggestion without `#[primary_span]` field\n-struct AQ {\n+struct AR {\n     var: String,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code =\"...\", applicability = \"machine-applicable\")]\n-struct AR {\n+#[suggestion(parser::add_paren, code =\"...\", applicability = \"machine-applicable\")]\n+struct AS {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[label]\n //~^ ERROR unsupported type attribute for subdiagnostic enum\n-enum AS {\n-    #[label(slug = \"...\")]\n+enum AT {\n+    #[label(parser::add_paren)]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -465,24 +474,24 @@ enum AS {\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n-struct AT {\n+#[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+struct AU {\n     #[primary_span]\n     span: Span,\n     var: String,\n }\n \n #[derive(SessionSubdiagnostic)]\n-#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+#[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n //~^ ERROR `var` doesn't refer to a field on this type\n-struct AU {\n+struct AV {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum AV {\n-    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+enum AW {\n+    #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n     A {\n         #[primary_span]\n         span: Span,\n@@ -491,8 +500,8 @@ enum AV {\n }\n \n #[derive(SessionSubdiagnostic)]\n-enum AW {\n-    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+enum AX {\n+    #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n //~^ ERROR `var` doesn't refer to a field on this type\n     A {\n         #[primary_span]"}, {"sha": "f833bd210f7f59880965347f1bb358c597100646", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 109, "deletions": 98, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b3b4ef2b521496b90345e62ef121bd1c9daba4d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=0b3b4ef2b521496b90345e62ef121bd1c9daba4d", "patch": "@@ -1,7 +1,7 @@\n error: label without `#[primary_span]` field\n   --> $DIR/subdiagnostic-derive.rs:47:1\n    |\n-LL | / #[label(slug = \"label-c\")]\n+LL | / #[label(parser::add_paren)]\n LL | |\n LL | | struct C {\n LL | |     var: String,\n@@ -32,304 +32,308 @@ error: `#[label(bug = ...)]` is not a valid attribute\n LL | #[label(bug = \"...\")]\n    |         ^^^^^^^^^^^\n    |\n-   = help: only `code`, `slug` and `applicability` are valid nested attributes\n+   = help: first argument of the attribute should be the diagnostic slug\n \n error: `#[label(\"...\")]` is not a valid attribute\n   --> $DIR/subdiagnostic-derive.rs:91:9\n    |\n LL | #[label(\"...\")]\n    |         ^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n error: `#[label(slug = ...)]` is not a valid attribute\n   --> $DIR/subdiagnostic-derive.rs:100:9\n    |\n LL | #[label(slug = 4)]\n    |         ^^^^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n error: `#[label(slug(...))]` is not a valid attribute\n   --> $DIR/subdiagnostic-derive.rs:109:9\n    |\n LL | #[label(slug(\"...\"))]\n    |         ^^^^^^^^^^^\n-\n-error: `#[label(slug)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:118:9\n    |\n-LL | #[label(slug)]\n-   |         ^^^^\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `slug` must be set in a `#[label(...)]` attribute\n-  --> $DIR/subdiagnostic-derive.rs:127:1\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:128:1\n    |\n LL | #[label()]\n    | ^^^^^^^^^^\n \n error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:136:1\n+  --> $DIR/subdiagnostic-derive.rs:137:1\n+   |\n+LL | #[label(parser::add_paren, code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `applicability` is not a valid nested attribute of a `label` attribute\n+  --> $DIR/subdiagnostic-derive.rs:146:1\n    |\n-LL | #[label(code = \"...\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:145:1\n+  --> $DIR/subdiagnostic-derive.rs:155:1\n    |\n LL | #[foo]\n    | ^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:159:5\n+  --> $DIR/subdiagnostic-derive.rs:169:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:171:5\n+  --> $DIR/subdiagnostic-derive.rs:181:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:183:5\n+  --> $DIR/subdiagnostic-derive.rs:193:5\n    |\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n error: `#[bar(\"...\")]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:195:11\n+  --> $DIR/subdiagnostic-derive.rs:205:11\n    |\n LL |     #[bar(\"...\")]\n    |           ^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n-error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:207:5\n+error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:217:5\n    |\n LL |     #[label(code = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:224:5\n+  --> $DIR/subdiagnostic-derive.rs:234:5\n    |\n LL |     B {\n    |     ^\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/subdiagnostic-derive.rs:236:5\n+  --> $DIR/subdiagnostic-derive.rs:246:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: label without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:233:1\n+  --> $DIR/subdiagnostic-derive.rs:243:1\n    |\n-LL | / #[label(slug = \"...\")]\n+LL | / #[label(parser::add_paren)]\n LL | |\n-LL | | struct V {\n+LL | | struct W {\n LL | |     #[primary_span]\n LL | |\n LL | |     span: String,\n LL | | }\n    | |_^\n \n error: `#[applicability]` is only valid on suggestions\n-  --> $DIR/subdiagnostic-derive.rs:246:5\n+  --> $DIR/subdiagnostic-derive.rs:256:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `#[bar]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:256:5\n+  --> $DIR/subdiagnostic-derive.rs:266:5\n    |\n LL |     #[bar]\n    |     ^^^^^^\n    |\n    = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: `#[bar = ...]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:267:5\n+  --> $DIR/subdiagnostic-derive.rs:277:5\n    |\n LL |     #[bar = \"...\"]\n    |     ^^^^^^^^^^^^^^\n \n error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:278:5\n+  --> $DIR/subdiagnostic-derive.rs:288:5\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n \n error: unexpected unsupported untagged union\n-  --> $DIR/subdiagnostic-derive.rs:294:1\n+  --> $DIR/subdiagnostic-derive.rs:304:1\n    |\n-LL | / union AB {\n+LL | / union AC {\n LL | |\n LL | |     span: u32,\n LL | |     b: u64\n LL | | }\n    | |_^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:304:9\n+  --> $DIR/subdiagnostic-derive.rs:314:1\n    |\n-LL | #[label(slug = \"label-ac-2\")]\n-   |         ^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:301:9\n+  --> $DIR/subdiagnostic-derive.rs:311:1\n    |\n-LL | #[label(slug = \"label-ac-1\")]\n-   |         ^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:304:1\n+  --> $DIR/subdiagnostic-derive.rs:314:1\n    |\n-LL | #[label(slug = \"label-ac-2\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:301:1\n+  --> $DIR/subdiagnostic-derive.rs:311:1\n    |\n-LL | #[label(slug = \"label-ac-1\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:313:30\n+error: `#[label(parser::add_paren)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:323:28\n    |\n-LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n-   |                              ^^^^^^^^^^^^^^^^^^^\n+LL | #[label(parser::add_paren, parser::add_paren)]\n+   |                            ^^^^^^^^^^^^^^^^^\n    |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:313:9\n-   |\n-LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n-   |         ^^^^^^^^^^^^^^^^^^^\n+   = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:327:5\n+  --> $DIR/subdiagnostic-derive.rs:336:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:324:5\n+  --> $DIR/subdiagnostic-derive.rs:333:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:333:8\n+  --> $DIR/subdiagnostic-derive.rs:342:8\n    |\n-LL | struct AF {\n+LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:370:42\n+  --> $DIR/subdiagnostic-derive.rs:379:47\n    |\n-LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n-   |                                          ^^^^^^^^^^^^\n+LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n+   |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:370:28\n+  --> $DIR/subdiagnostic-derive.rs:379:33\n    |\n-LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n-   |                            ^^^^^^^^^^^^\n+LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n+   |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:388:5\n+  --> $DIR/subdiagnostic-derive.rs:397:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:385:5\n+  --> $DIR/subdiagnostic-derive.rs:394:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:399:5\n+  --> $DIR/subdiagnostic-derive.rs:408:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:394:1\n+  --> $DIR/subdiagnostic-derive.rs:403:1\n    |\n-LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AK {\n+LL | | struct AL {\n LL | |     #[primary_span]\n ...  |\n LL | |     applicability: Span,\n LL | | }\n    | |_^\n \n error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:405:1\n+  --> $DIR/subdiagnostic-derive.rs:414:1\n    |\n-LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AL {\n+LL | | struct AM {\n LL | |     #[primary_span]\n LL | |     span: Span,\n LL | | }\n    | |_^\n \n error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:413:1\n+  --> $DIR/subdiagnostic-derive.rs:422:1\n    |\n-LL | / #[suggestion(slug = \"...\")]\n+LL | / #[suggestion(parser::add_paren)]\n LL | |\n-LL | | struct AM {\n+LL | | struct AN {\n LL | |     #[primary_span]\n ...  |\n LL | |     applicability: Applicability,\n LL | | }\n    | |_^\n \n error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:423:41\n+  --> $DIR/subdiagnostic-derive.rs:432:46\n    |\n-LL | #[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:441:1\n+  --> $DIR/subdiagnostic-derive.rs:450:1\n    |\n-LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n LL | |\n-LL | | struct AQ {\n+LL | | struct AR {\n LL | |     var: String,\n LL | | }\n    | |_^\n \n error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:441:1\n+  --> $DIR/subdiagnostic-derive.rs:450:1\n    |\n-LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n LL | |\n-LL | | struct AQ {\n+LL | | struct AR {\n LL | |     var: String,\n LL | | }\n    | |_^\n \n error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:456:1\n+  --> $DIR/subdiagnostic-derive.rs:465:1\n    |\n LL | #[label]\n    | ^^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:476:34\n+  --> $DIR/subdiagnostic-derive.rs:485:39\n    |\n-LL | #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                  ^^^^^^^\n+LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                       ^^^^^^^\n \n error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:495:38\n+  --> $DIR/subdiagnostic-derive.rs:504:43\n    |\n-LL |     #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                      ^^^^^^^\n+LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -338,52 +342,59 @@ LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `foo` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:145:3\n+  --> $DIR/subdiagnostic-derive.rs:155:3\n    |\n LL | #[foo]\n    |   ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:159:7\n+  --> $DIR/subdiagnostic-derive.rs:169:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:171:7\n+  --> $DIR/subdiagnostic-derive.rs:181:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:183:7\n+  --> $DIR/subdiagnostic-derive.rs:193:7\n    |\n LL |     #[bar = 4]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:195:7\n+  --> $DIR/subdiagnostic-derive.rs:205:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:256:7\n+  --> $DIR/subdiagnostic-derive.rs:266:7\n    |\n LL |     #[bar]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:267:7\n+  --> $DIR/subdiagnostic-derive.rs:277:7\n    |\n LL |     #[bar = \"...\"]\n    |       ^^^\n \n error: cannot find attribute `bar` in this scope\n-  --> $DIR/subdiagnostic-derive.rs:278:7\n+  --> $DIR/subdiagnostic-derive.rs:288:7\n    |\n LL |     #[bar(\"...\")]\n    |       ^^^\n \n-error: aborting due to 51 previous errors\n+error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n+  --> $DIR/subdiagnostic-derive.rs:118:9\n+   |\n+LL | #[label(slug)]\n+   |         ^^^^ not found in `rustc_errors::fluent`\n+\n+error: aborting due to 52 previous errors\n \n+For more information about this error, try `rustc --explain E0425`."}]}