{"sha": "171fe82efc2ab420e3fe2e9ad5a44db093a751f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MWZlODJlZmMyYWI0MjBlM2ZlMmU5YWQ1YTQ0ZGIwOTNhNzUxZjE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-16T23:53:51Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-16T23:53:51Z"}, "message": "Filter and test predicates using `normalize_and_test_predicates` for const-prop\n\nFixes #68264\n\nPreviously, I attempted to use\n`substitute_normalize_and_test_predicates` to detect unsatisfiable\nbounds. Unfortunately, since const-prop runs in a generic environment\n(we don't have any of the function's generic parameters substituted),\nthis could lead to cycle errors when attempting to normalize predicates.\n\nThis check is replaced with a more precise check. We now only call\n`normalize_and_test_predicates` on predicates that have the possibility\nof being proved unsatisfiable - that is, predicates that don't depend\non anything local to the function (e.g. generic parameters). This\nensures that we don't hit cycle errors when we normalize said\npredicates, while still ensuring that we detect unsatisfiable\npredicates.", "tree": {"sha": "b3c6d68a30ee2409ef2d88ead5ec9ca78e20a660", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3c6d68a30ee2409ef2d88ead5ec9ca78e20a660"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/171fe82efc2ab420e3fe2e9ad5a44db093a751f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl4g+GMACgkQtAh+UQ6Y\nsWRt/A//XLDsaOmiJhqJsL7LqifZreO9am57LTOD1mBvigM9Mo9D8DVag5Gc0YB6\n2517NWJgUZor9hM0kBeAlqjOEPmQwdoP8X7Lh9WeQaTVrOdo7FKWX8gF95tk1FxK\nOh2JwNYY2+qAVwZ1Zc4pFLMGYnYiL9qMTe3/6f55HiJzguhUnRzPmAOxl18h2dnY\nDMH/2TbIu0I6vxF7gPhDwjzKC1VrN1G2pIy89Lwgpd0jBxL17XhW1JiayUP4pEmy\nEHOMcOjRK6UKaAzK7BjGSrMh9alyjWXtoXqi6ul4OOFKX7FwbND1Tom0oQLgJAKk\n4oWvub/B0HQmA1nuLiF4/zMIKuACZUYvPhoflyBojh/MenxP1HNYlSXSMieV981s\nfpejy5gQzIIHYXiJoFQ5YPBkDMTt6cbvctSmkZft+gAYC+1Mx+5uaZnoegGt4CYH\nmlD1bIoOrCUbvqfgUa0d911Q4V4HpK4dW8S5UFoipXZSCt8jFd/EyYuePJsUCyf4\nv7m/ITL2nEK/jQ9gyAG8Xi0DxCpcU08zC44NT5TTZlhwHPi+DKNBQ1SlJjQqbBwO\n2IlsM/VnWtqyad8ok/2AUfG++wgEWprKjgN0Dm5fK6yb4K6dElzxP59BGKIdfofY\nz2mgWOeF2XTkWyIg9k1Uxq85HlJU5n75wV5Q7dgVhD9HYDWqlyg=\n=D5uQ\n-----END PGP SIGNATURE-----", "payload": "tree b3c6d68a30ee2409ef2d88ead5ec9ca78e20a660\nparent d088d8a2c1bd706c458d36eac941949169514d86\nauthor Aaron Hill <aa1ronham@gmail.com> 1579218831 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1579218831 -0500\n\nFilter and test predicates using `normalize_and_test_predicates` for const-prop\n\nFixes #68264\n\nPreviously, I attempted to use\n`substitute_normalize_and_test_predicates` to detect unsatisfiable\nbounds. Unfortunately, since const-prop runs in a generic environment\n(we don't have any of the function's generic parameters substituted),\nthis could lead to cycle errors when attempting to normalize predicates.\n\nThis check is replaced with a more precise check. We now only call\n`normalize_and_test_predicates` on predicates that have the possibility\nof being proved unsatisfiable - that is, predicates that don't depend\non anything local to the function (e.g. generic parameters). This\nensures that we don't hit cycle errors when we normalize said\npredicates, while still ensuring that we detect unsatisfiable\npredicates.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/171fe82efc2ab420e3fe2e9ad5a44db093a751f1", "html_url": "https://github.com/rust-lang/rust/commit/171fe82efc2ab420e3fe2e9ad5a44db093a751f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/171fe82efc2ab420e3fe2e9ad5a44db093a751f1/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d088d8a2c1bd706c458d36eac941949169514d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/d088d8a2c1bd706c458d36eac941949169514d86", "html_url": "https://github.com/rust-lang/rust/commit/d088d8a2c1bd706c458d36eac941949169514d86"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "badca1056940434c56634e3d75946c5a621e99fe", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/171fe82efc2ab420e3fe2e9ad5a44db093a751f1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/171fe82efc2ab420e3fe2e9ad5a44db093a751f1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=171fe82efc2ab420e3fe2e9ad5a44db093a751f1", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::{\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n-use rustc::traits::TraitQueryMode;\n+use rustc::traits;\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n@@ -90,28 +90,28 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // If there are unsatisfiable where clauses, then all bets are\n         // off, and we just give up.\n         //\n-        // Note that we use TraitQueryMode::Canonical here, which causes\n-        // us to treat overflow like any other error. This is because we\n-        // are \"speculatively\" evaluating this item with the default substs.\n-        // While this usually succeeds, it may fail with tricky impls\n-        // (e.g. the typenum crate). Const-propagation is fundamentally\n-        // \"best-effort\", and does not affect correctness in any way.\n-        // Therefore, it's perfectly fine to just \"give up\" if we're\n-        // unable to check the bounds with the default substs.\n+        // We manually filter the predicates, skipping anything that's not\n+        // \"global\". We are in a potentially generic context\n+        // (e.g. we are evaluating a function without substituging generic\n+        // parameters, so this filtering serves two purposes:\n         //\n-        // False negatives (failing to run const-prop on something when we actually\n-        // could) are fine. However, false positives (running const-prop on\n-        // an item with unsatisfiable bounds) can lead to us generating invalid\n-        // MIR.\n-        if !tcx.substitute_normalize_and_test_predicates((\n-            source.def_id(),\n-            InternalSubsts::identity_for_item(tcx, source.def_id()),\n-            TraitQueryMode::Canonical,\n-        )) {\n-            trace!(\n-                \"ConstProp skipped for item with unsatisfiable predicates: {:?}\",\n-                source.def_id()\n-            );\n+        // 1. We skip evaluating any predicates that we would\n+        // never be able prove are unsatisfiable (e.g. `<T as Foo>`\n+        // 2. We avoid trying to normalize predicates involving generic\n+        // parameters (e.g. `<T as Foo>::MyItem`). This can confuse\n+        // the normalization code (leading to cycle errors), since\n+        // it's usually never invoked in this way.\n+        let predicates = tcx\n+            .predicates_of(source.def_id())\n+            .predicates\n+            .iter()\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None })\n+            .collect();\n+        if !traits::normalize_and_test_predicates(\n+            tcx,\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n+        ) {\n+            trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", source.def_id());\n             return;\n         }\n "}]}