{"sha": "3910ea5cbfd5228377ff3299f0bac52c2abb9f3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MTBlYTVjYmZkNTIyODM3N2ZmMzI5OWYwYmFjNTJjMmFiYjlmM2M=", "commit": {"author": {"name": "okaneco", "email": "47607823+okaneco@users.noreply.github.com", "date": "2020-06-16T14:44:56Z"}, "committer": {"name": "okaneco", "email": "47607823+okaneco@users.noreply.github.com", "date": "2020-06-16T14:44:56Z"}, "message": "Fix typos in docs/dev/README.md\nSmall grammar and spelling changes", "tree": {"sha": "35700c59d6c36b4c027a02f8afe9a253ad2042e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35700c59d6c36b4c027a02f8afe9a253ad2042e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c", "html_url": "https://github.com/rust-lang/rust/commit/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c/comments", "author": {"login": "okaneco", "id": 47607823, "node_id": "MDQ6VXNlcjQ3NjA3ODIz", "avatar_url": "https://avatars.githubusercontent.com/u/47607823?v=4", "gravatar_id": "", "url": "https://api.github.com/users/okaneco", "html_url": "https://github.com/okaneco", "followers_url": "https://api.github.com/users/okaneco/followers", "following_url": "https://api.github.com/users/okaneco/following{/other_user}", "gists_url": "https://api.github.com/users/okaneco/gists{/gist_id}", "starred_url": "https://api.github.com/users/okaneco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/okaneco/subscriptions", "organizations_url": "https://api.github.com/users/okaneco/orgs", "repos_url": "https://api.github.com/users/okaneco/repos", "events_url": "https://api.github.com/users/okaneco/events{/privacy}", "received_events_url": "https://api.github.com/users/okaneco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "okaneco", "id": 47607823, "node_id": "MDQ6VXNlcjQ3NjA3ODIz", "avatar_url": "https://avatars.githubusercontent.com/u/47607823?v=4", "gravatar_id": "", "url": "https://api.github.com/users/okaneco", "html_url": "https://github.com/okaneco", "followers_url": "https://api.github.com/users/okaneco/followers", "following_url": "https://api.github.com/users/okaneco/following{/other_user}", "gists_url": "https://api.github.com/users/okaneco/gists{/gist_id}", "starred_url": "https://api.github.com/users/okaneco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/okaneco/subscriptions", "organizations_url": "https://api.github.com/users/okaneco/orgs", "repos_url": "https://api.github.com/users/okaneco/repos", "events_url": "https://api.github.com/users/okaneco/events{/privacy}", "received_events_url": "https://api.github.com/users/okaneco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b2175878da09feeb0eafc6287eb939e837e14dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2175878da09feeb0eafc6287eb939e837e14dc", "html_url": "https://github.com/rust-lang/rust/commit/6b2175878da09feeb0eafc6287eb939e837e14dc"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "1b63d8223620591f7e4e1b6bd6c0d31903aec032", "filename": "docs/dev/README.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3910ea5cbfd5228377ff3299f0bac52c2abb9f3c/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=3910ea5cbfd5228377ff3299f0bac52c2abb9f3c", "patch": "@@ -1,6 +1,6 @@\n # Contributing Quick Start\n \n-Rust Analyzer is just a usual rust project, which is organized as a Cargo\n+Rust Analyzer is an ordinary Rust project, which is organized as a Cargo\n workspace, builds on stable and doesn't depend on C libraries. So, just\n \n ```\n@@ -65,31 +65,31 @@ directory).\n \n # Launching rust-analyzer\n \n-Debugging language server can be tricky: LSP is rather chatty, so driving it\n+Debugging the language server can be tricky: LSP is rather chatty, so driving it\n from the command line is not really feasible, driving it via VS Code requires\n interacting with two processes.\n \n For this reason, the best way to see how rust-analyzer works is to find a\n relevant test and execute it (VS Code includes an action for running a single\n test).\n \n-However, launching a VS Code instance with locally build language server is\n+However, launching a VS Code instance with a locally built language server is\n possible. There's **\"Run Extension (Debug Build)\"** launch configuration for this.\n \n In general, I use one of the following workflows for fixing bugs and\n implementing features.\n \n If the problem concerns only internal parts of rust-analyzer (i.e. I don't need\n-to touch `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n+to touch the `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and\n then just do printf-driven development/debugging. As a sanity check after I'm\n done, I use `cargo xtask install --server` and **Reload Window** action in VS\n Code to sanity check that the thing works as I expect.\n \n If the problem concerns only the VS Code extension, I use **Run Installed Extension**\n launch configuration from `launch.json`. Notably, this uses the usual\n-`rust-analyzer` binary from `PATH`. For this it is important to have the following\n-in `setting.json` file:\n+`rust-analyzer` binary from `PATH`. For this, it is important to have the following\n+in your `settings.json` file:\n ```json\n {\n     \"rust-analyzer.serverPath\": \"rust-analyzer\"\n@@ -107,7 +107,7 @@ things up, sometimes I open a temporary hello-world project which has\n `\"rust-analyzer.withSysroot\": false` in `.code/settings.json`. This flag causes\n rust-analyzer to skip loading the sysroot, which greatly reduces the amount of\n things rust-analyzer needs to do, and makes printf's more useful. Note that you\n-should only use `eprint!` family of macros for debugging: stdout is used for LSP\n+should only use the `eprint!` family of macros for debugging: stdout is used for LSP\n communication, and `print!` would break it.\n \n If I need to fix something simultaneously in the server and in the client, I\n@@ -119,20 +119,20 @@ performance optimizations, or for bug minimization.\n \n # Code Style & Review Process\n \n-Our approach to \"clean code\" is two fold:\n+Our approach to \"clean code\" is two-fold:\n \n * We generally don't block PRs on style changes.\n * At the same time, all code in rust-analyzer is constantly refactored.\n \n-It is explicitly OK for reviewer to flag only some nits in the PR, and than send a follow up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n-Sending small cleanup PRs (like rename a single local variable) is encouraged.\n+It is explicitly OK for a reviewer to flag only some nits in the PR, and then send a follow-up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n+Sending small cleanup PRs (like renaming a single local variable) is encouraged.\n \n ## Scale of Changes\n \n Everyone knows that it's better to send small & focused pull requests.\n The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n \n-The main thing too keep an eye on is the boundaries between various components.\n+The main things to keep an eye on are the boundaries between various components.\n There are three kinds of changes:\n \n 1. Internals of a single component are changed.\n@@ -144,20 +144,20 @@ There are three kinds of changes:\n    A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n \n 3. A new dependency between components is introduced.\n-   Specifically, you add a `pub use` reexport from another crate or you add a new line to `[dependencies]` section of `Cargo.toml`.\n+   Specifically, you add a `pub use` reexport from another crate or you add a new line to the `[dependencies]` section of `Cargo.toml`.\n    A good example here would be adding reference search capability to the assists crates.\n \n For the first group, the change is generally merged as long as:\n \n * it works for the happy case,\n * it has tests,\n-* it doesn't panic for unhappy case.\n+* it doesn't panic for the unhappy case.\n \n For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n The new API needs to be right (or at least easy to change later).\n The actual implementation doesn't matter that much.\n It's very important to minimize the amount of changed lines of code for changes of the second kind.\n-Often, you start doing change of the first kind, only to realise that you need to elevate to a change of the second kind.\n+Often, you start doing a change of the first kind, only to realise that you need to elevate to a change of the second kind.\n In this case, we'll probably ask you to split API changes into a separate PR.\n \n Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n@@ -239,7 +239,7 @@ struct Foo {\n ## Variable Naming\n \n We generally use boring and long names for local variables ([yay code completion](https://github.com/rust-analyzer/rust-analyzer/pull/4162#discussion_r417130973)).\n-The default name is lowercased named of the type: `global_state: GlobalState`.\n+The default name is a lowercased name of the type: `global_state: GlobalState`.\n Avoid ad-hoc acronyms and contractions, but use the ones that exist consistently (`db`, `ctx`, `acc`).\n The default name for \"result of the function\" local variable is `res`.\n \n@@ -265,8 +265,8 @@ fn frobnicate(walrus: Option<Walrus>) {\n \n ## Premature Pessimization\n \n-While we don't specifically optimize code yet, avoid writing the code which is slower than it needs to be.\n-Don't allocate a `Vec` were an iterator would do, don't allocate strings needlessly.\n+While we don't specifically optimize code yet, avoid writing code which is slower than it needs to be.\n+Don't allocate a `Vec` where an iterator would do, don't allocate strings needlessly.\n \n ```rust\n // Good\n@@ -305,7 +305,7 @@ always obvious from the low-level code.\n ## Incomplete syntax trees\n \n Syntax trees are by design incomplete and do not enforce well-formedness.\n-If ast method returns an `Option`, it *can* be `None` at runtime, even if this is forbidden by the grammar.\n+If an AST method returns an `Option`, it *can* be `None` at runtime, even if this is forbidden by the grammar.\n \n ## LSP independence\n \n@@ -333,7 +333,7 @@ The results are 100% Rust specific though.\n \n ## Parser Tests\n \n-Test for parser (`ra_parser`) live in `ra_syntax` crate (see `test_data` direcotory).\n+Tests for the parser (`ra_parser`) live in the `ra_syntax` crate (see `test_data` directory).\n There are two kinds of tests:\n \n * Manually written test cases in `parser/ok` and `parser/err`\n@@ -374,7 +374,7 @@ To log all communication between the server and the client, there are two choice\n   [@DJMcNab](https://github.com/DJMcNab) for setting this awesome infra up!\n \n \n-There's also two VS Code commands which might be of interest:\n+There are also two VS Code commands which might be of interest:\n \n * `Rust Analyzer: Status` shows some memory-usage statistics. To take full\n   advantage of it, you need to compile rust-analyzer with jemalloc support:"}]}