{"sha": "ec5a028adac360537c8f37a669eda522bd8c9b6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNWEwMjhhZGFjMzYwNTM3YzhmMzdhNjY5ZWRhNTIyYmQ4YzliNmI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T11:46:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:55Z"}, "message": "std: convert str::char_at* to methods.", "tree": {"sha": "20682eb106db7becc93c952cac36c955dbbc77b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20682eb106db7becc93c952cac36c955dbbc77b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec5a028adac360537c8f37a669eda522bd8c9b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a028adac360537c8f37a669eda522bd8c9b6b", "html_url": "https://github.com/rust-lang/rust/commit/ec5a028adac360537c8f37a669eda522bd8c9b6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec5a028adac360537c8f37a669eda522bd8c9b6b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f632f466148c7e5571393bb2a24cd628703a60fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f632f466148c7e5571393bb2a24cd628703a60fa", "html_url": "https://github.com/rust-lang/rust/commit/f632f466148c7e5571393bb2a24cd628703a60fa"}], "stats": {"total": 298, "additions": 146, "deletions": 152}, "files": [{"sha": "c9e44a79160349940c74716f98cba727eca34671", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -429,7 +429,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let range = str::char_range_at(haystack, *idx);\n+    let range = haystack.char_range_at(*idx);\n     if range.ch != needle {\n         return false;\n     }\n@@ -440,7 +440,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n-        let range = str::char_range_at(haystack, i);\n+        let range = haystack.char_range_at(i);\n         if range.ch < '0' || '9' < range.ch {\n             break;\n         }\n@@ -460,7 +460,7 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n         if haystack_i >= haystack.len() {\n             return false;\n         }\n-        let range = str::char_range_at(haystack, haystack_i);\n+        let range = haystack.char_range_at(haystack_i);\n         haystack_i = range.next;\n         if !scan_char(needle, range.ch, &mut needle_i) {\n             return false;"}, {"sha": "76e921f02f9e6185e160aafee6a0089018ccdd9f", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -112,7 +112,7 @@ pub struct Opt {\n \n fn mkname(nm: &str) -> Name {\n   if nm.len() == 1u {\n-      Short(str::char_at(nm, 0u))\n+      Short(nm.char_at(0u))\n   } else {\n       Long(nm.to_owned())\n   }\n@@ -261,7 +261,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut last_valid_opt_id = None;\n                 names = ~[];\n                 while j < curlen {\n-                    let range = str::char_range_at(cur, j);\n+                    let range = cur.char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -565,11 +565,11 @@ pub mod groups {\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,0) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,0) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur: occur}],\n \n-           (1,_) => ~[Opt {name: Short(str::char_at(short_name, 0)),\n+           (1,_) => ~[Opt {name: Short(short_name.char_at(0)),\n                            hasarg: hasarg,\n                            occur:  occur},\n                       Opt {name:   Long((long_name)),"}, {"sha": "80d80fa0ade3e8f3d76c702d3337618df1579aa2", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -1132,7 +1132,7 @@ pub mod node {\n     pub fn char_at(mut node: @Node, mut pos: uint) -> char {\n         loop {\n             match *node {\n-              Leaf(x) => return str::char_at(*x.content, pos),\n+              Leaf(x) => return x.content.char_at(pos),\n               Concat(Concat {left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n@@ -1257,8 +1257,7 @@ pub mod node {\n                     return None\n                 } else {\n                     let range =\n-                        str::char_range_at(*aleaf.content,\n-                                     (*it).leaf_byte_pos + aleaf.byte_offset);\n+                        aleaf.content.char_range_at((*it).leaf_byte_pos + aleaf.byte_offset);\n                     let ch = range.ch;\n                     let next = range.next;\n                     (*it).leaf_byte_pos = next - aleaf.byte_offset;\n@@ -1345,7 +1344,7 @@ mod tests {\n                     equal = false;\n                 } break; }\n               Some(c) => {\n-                let range = str::char_range_at(*sample, string_iter);\n+                let range = sample.char_range_at(string_iter);\n                 string_iter = range.next;\n                 if range.ch != c { equal = false; break; }\n               }"}, {"sha": "caaa2994405e01b984c3eca0eb7194bed2de06da", "filename": "src/libextra/time.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -296,7 +296,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut i = 0u;\n         while i < digits {\n-            let range = str::char_range_at(ss, pos);\n+            let range = ss.char_range_at(pos);\n             pos = range.next;\n \n             match range.ch {\n@@ -323,7 +323,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     }\n \n     fn parse_char(s: &str, pos: uint, c: char) -> Result<uint, ~str> {\n-        let range = str::char_range_at(s, pos);\n+        let range = s.char_range_at(pos);\n \n         if c == range.ch {\n             Ok(range.next)\n@@ -600,7 +600,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n                 let mut pos = pos;\n                 let len = s.len();\n                 while pos < len {\n-                    let range = str::char_range_at(s, pos);\n+                    let range = s.char_range_at(pos);\n                     pos = range.next;\n                     if range.ch == ' ' { break; }\n                 }\n@@ -609,7 +609,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'z' => {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n \n             if range.ch == '+' || range.ch == '-' {\n                 match match_digits(s, range.next, 4u, false) {\n@@ -655,7 +655,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         let mut result = Err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n-            let range = str::char_range_at(s, pos);\n+            let range = s.char_range_at(pos);\n             let ch = range.ch;\n             let next = range.next;\n "}, {"sha": "92147bf4e0f7237ed2a4cb163148fd70c1cae610", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -842,7 +842,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: @ast::item) {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n         let ident = ident.trim_chars(&['_']);\n-        char::is_uppercase(str::char_at(ident, 0)) &&\n+        char::is_uppercase(ident.char_at(0)) &&\n             !ident.contains_char('_')\n     }\n "}, {"sha": "7f3af79e27c767b2c23a6e07e6b225e5045e8412", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -672,7 +672,7 @@ impl<T:Reader> ReaderUtil for T {\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n-                // See str::char_at\n+                // See str::StrSlice::char_at\n                 val += ((b0 << ((w + 1) as u8)) as uint)\n                     << (w - 1) * 6 - w - 1u;\n                 chars.push(val as char);"}, {"sha": "25d9a63b479ec67a607d913682c67df784924171", "filename": "src/libstd/str.rs", "status": "modified", "additions": 125, "deletions": 130, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -370,7 +370,7 @@ Section: Adding to and removing from a string\n pub fn pop_char(s: &mut ~str) -> char {\n     let end = s.len();\n     assert!(end > 0u);\n-    let CharRange {ch, next} = char_range_at_reverse(*s, end);\n+    let CharRange {ch, next} = s.char_range_at_reverse(end);\n     unsafe { raw::set_len(s, next); }\n     return ch;\n }\n@@ -383,7 +383,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n-    let CharRange {ch, next} = char_range_at(*s, 0u);\n+    let CharRange {ch, next} = s.char_range_at(0u);\n     *s = unsafe { raw::slice_bytes_owned(*s, next, s.len()) };\n     return ch;\n }\n@@ -399,7 +399,7 @@ pub fn shift_char(s: &mut ~str) -> char {\n  */\n #[inline]\n pub fn slice_shift_char<'a>(s: &'a str) -> (char, &'a str) {\n-    let CharRange {ch, next} = char_range_at(s, 0u);\n+    let CharRange {ch, next} = s.char_range_at(0u);\n     let next_s = unsafe { raw::slice_bytes(s, next, s.len()) };\n     return (ch, next_s);\n }\n@@ -532,7 +532,7 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Se\n             }\n         } else {\n             while self.position < l && self.count > 0 {\n-                let CharRange {ch, next} = char_range_at(self.string, self.position);\n+                let CharRange {ch, next} = self.string.char_range_at(self.position);\n \n                 if self.sep.matches(ch) {\n                     let slice = unsafe { raw::slice_bytes(self.string, start, self.position) };\n@@ -1198,7 +1198,7 @@ pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert!(is_char_boundary(s, end));\n     let mut (i, len) = (start, 0u);\n     while i < end {\n-        let next = char_range_at(s, i).next;\n+        let next = s.char_range_at(i).next;\n         len += 1u;\n         i = next;\n     }\n@@ -1213,7 +1213,7 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     let l = s.len();\n     while cnt > 0u {\n         assert!(end < l);\n-        let next = char_range_at(s, end).next;\n+        let next = s.char_range_at(end).next;\n         cnt -= 1u;\n         end = next;\n     }\n@@ -1233,130 +1233,12 @@ pub fn utf8_char_width(b: u8) -> uint {\n     return 6u;\n }\n \n-/**\n- * Returns false if the index points into the middle of a multi-byte\n- * character sequence.\n- */\n-pub fn is_char_boundary(s: &str, index: uint) -> bool {\n-    if index == s.len() { return true; }\n-    let b = s[index];\n-    return b < 128u8 || b >= 192u8;\n-}\n-\n-/**\n- * Pluck a character out of a string and return the index of the next\n- * character.\n- *\n- * This function can be used to iterate over the unicode characters of a\n- * string.\n- *\n- * # Example\n- *\n- * ~~~ {.rust}\n- * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n- * let i = 0u;\n- * while i < s.len() {\n- *     let CharRange {ch, next} = str::char_range_at(s, i);\n- *     std::io::println(fmt!(\"%u: %c\",i,ch));\n- *     i = next;\n- * }\n- * ~~~\n- *\n- * # Example output\n- *\n- * ~~~\n- * 0: \u4e2d\n- * 3: \u534e\n- * 6: V\n- * 7: i\n- * 8: \u1ec7\n- * 11: t\n- * 12:\n- * 13: N\n- * 14: a\n- * 15: m\n- * ~~~\n- *\n- * # Arguments\n- *\n- * * s - The string\n- * * i - The byte offset of the char to extract\n- *\n- * # Return value\n- *\n- * A record {ch: char, next: uint} containing the char value and the byte\n- * index of the next unicode character.\n- *\n- * # Failure\n- *\n- * If `i` is greater than or equal to the length of the string.\n- * If `i` is not the index of the beginning of a valid UTF-8 character.\n- */\n-pub fn char_range_at(s: &str, i: uint) -> CharRange {\n-    let b0 = s[i];\n-    let w = utf8_char_width(b0);\n-    assert!((w != 0u));\n-    if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n-    let mut val = 0u;\n-    let end = i + w;\n-    let mut i = i + 1u;\n-    while i < end {\n-        let byte = s[i];\n-        assert_eq!(byte & 192u8, tag_cont_u8);\n-        val <<= 6u;\n-        val += (byte & 63u8) as uint;\n-        i += 1u;\n-    }\n-    // Clunky way to get the right bits from the first byte. Uses two shifts,\n-    // the first to clip off the marker bits at the left of the byte, and then\n-    // a second (as uint) to get it to the right position.\n-    val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n-    return CharRange {ch: val as char, next: i};\n-}\n-\n-/// Plucks the character starting at the `i`th byte of a string\n-pub fn char_at(s: &str, i: uint) -> char {\n-    return char_range_at(s, i).ch;\n-}\n-\n #[allow(missing_doc)]\n pub struct CharRange {\n     ch: char,\n     next: uint\n }\n \n-/**\n- * Given a byte position and a str, return the previous char and its position.\n- *\n- * This function can be used to iterate over a unicode string in reverse.\n- *\n- * Returns 0 for next index if called on start index 0.\n- */\n-pub fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n-    let mut prev = start;\n-\n-    // while there is a previous byte == 10......\n-    while prev > 0u && ss[prev - 1u] & 192u8 == tag_cont_u8 {\n-        prev -= 1u;\n-    }\n-\n-    // now refer to the initial byte of previous char\n-    if prev > 0u {\n-        prev -= 1u;\n-    } else {\n-        prev = 0u;\n-    }\n-\n-\n-    let ch = char_at(ss, prev);\n-    return CharRange {ch:ch, next:prev};\n-}\n-\n-/// Plucks the character ending at the `i`th byte of a string\n-pub fn char_at_reverse(s: &str, i: uint) -> char {\n-    char_range_at_reverse(s, i).ch\n-}\n-\n // UTF-8 tags and ranges\n static tag_cont_u8: u8 = 128u8;\n static tag_cont: uint = 128u;\n@@ -1776,7 +1658,10 @@ pub trait StrSlice<'self> {\n     fn trim_right_chars(&self, chars_to_trim: &[char]) -> &'self str;\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n+    fn is_char_boundary(s: &str, index: uint) -> bool;\n+    fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n     fn char_at_reverse(&self, i: uint) -> char;\n     fn to_bytes(&self) -> ~[u8];\n \n@@ -1967,7 +1852,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         match self.rfind(|c| !char::is_whitespace(c)) {\n             None => \"\",\n             Some(last) => {\n-                let next = char_range_at(*self, last).next;\n+                let next = self.char_range_at(last).next;\n                 unsafe { raw::slice_bytes(*self, 0u, next) }\n             }\n         }\n@@ -2019,8 +1904,8 @@ impl<'self> StrSlice<'self> for &'self str {\n         match self.rfind(|c| !chars_to_trim.contains(&c)) {\n             None => \"\",\n             Some(last) => {\n-                let next = char_range_at(self, last).next;\n-                unsafe { raw::slice_bytes(self, 0u, next) }\n+                let next = self.char_range_at(last).next;\n+                unsafe { raw::slice_bytes(*self, 0u, next) }\n             }\n         }\n     }\n@@ -2037,12 +1922,122 @@ impl<'self> StrSlice<'self> for &'self str {\n         unsafe { ::cast::transmute(v) }\n     }\n \n+    /**\n+     * Returns false if the index points into the middle of a multi-byte\n+     * character sequence.\n+     */\n+    fn is_char_boundary(&self, index: uint) -> bool {\n+        if index == self.len() { return true; }\n+        let b = self[index];\n+        return b < 128u8 || b >= 192u8;\n+    }\n+\n+    /**\n+     * Pluck a character out of a string and return the index of the next\n+     * character.\n+     *\n+     * This function can be used to iterate over the unicode characters of a\n+     * string.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+     * let i = 0u;\n+     * while i < s.len() {\n+     *     let CharRange {ch, next} = s.char_range_at(i);\n+     *     std::io::println(fmt!(\"%u: %c\",i,ch));\n+     *     i = next;\n+     * }\n+     * ~~~\n+     *\n+     * # Example output\n+     *\n+     * ~~~\n+     * 0: \u4e2d\n+     * 3: \u534e\n+     * 6: V\n+     * 7: i\n+     * 8: \u1ec7\n+     * 11: t\n+     * 12:\n+     * 13: N\n+     * 14: a\n+     * 15: m\n+     * ~~~\n+     *\n+     * # Arguments\n+     *\n+     * * s - The string\n+     * * i - The byte offset of the char to extract\n+     *\n+     * # Return value\n+     *\n+     * A record {ch: char, next: uint} containing the char value and the byte\n+     * index of the next unicode character.\n+     *\n+     * # Failure\n+     *\n+     * If `i` is greater than or equal to the length of the string.\n+     * If `i` is not the index of the beginning of a valid UTF-8 character.\n+     */\n+    fn char_range_at(&self, i: uint) -> CharRange {\n+        let b0 = self[i];\n+        let w = utf8_char_width(b0);\n+        assert!((w != 0u));\n+        if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n+        let mut val = 0u;\n+        let end = i + w;\n+        let mut i = i + 1u;\n+        while i < end {\n+            let byte = self[i];\n+            assert_eq!(byte & 192u8, tag_cont_u8);\n+            val <<= 6u;\n+            val += (byte & 63u8) as uint;\n+            i += 1u;\n+        }\n+        // Clunky way to get the right bits from the first byte. Uses two shifts,\n+        // the first to clip off the marker bits at the left of the byte, and then\n+        // a second (as uint) to get it to the right position.\n+        val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n+        return CharRange {ch: val as char, next: i};\n+    }\n+\n+    /// Plucks the character starting at the `i`th byte of a string\n     #[inline]\n-    fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n+    fn char_at(&self, i: uint) -> char { self.char_range_at(i).ch }\n+\n+    /**\n+     * Given a byte position and a str, return the previous char and its position.\n+     *\n+     * This function can be used to iterate over a unicode string in reverse.\n+     *\n+     * Returns 0 for next index if called on start index 0.\n+     */\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+        let mut prev = start;\n+\n+        // while there is a previous byte == 10......\n+        while prev > 0u && self[prev - 1u] & 192u8 == tag_cont_u8 {\n+            prev -= 1u;\n+        }\n+\n+        // now refer to the initial byte of previous char\n+        if prev > 0u {\n+            prev -= 1u;\n+        } else {\n+            prev = 0u;\n+        }\n+\n+\n+        let ch = self.char_at(prev);\n+        return CharRange {ch:ch, next:prev};\n+    }\n \n+    /// Plucks the character ending at the `i`th byte of a string\n     #[inline]\n     fn char_at_reverse(&self, i: uint) -> char {\n-        char_at_reverse(*self, i)\n+        self.char_range_at_reverse(i).ch\n     }\n \n     fn to_bytes(&self) -> ~[u8] { to_bytes(*self) }\n@@ -3182,7 +3177,7 @@ mod tests {\n \n     #[test]\n     fn test_char_range_at_reverse_underflow() {\n-        assert_eq!(char_range_at_reverse(\"abc\", 0).next, 0);\n+        assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n     }\n \n     #[test]"}, {"sha": "5f9bc4ca6f61054581e4addf8654eb9aa714e543", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -180,7 +180,7 @@ pub fn bump(rdr: &mut StringReader) {\n     if current_byte_offset < (*rdr.src).len() {\n         assert!(rdr.curr != -1 as char);\n         let last_char = rdr.curr;\n-        let next = str::char_range_at(*rdr.src, current_byte_offset);\n+        let next = rdr.src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos = rdr.pos + BytePos(byte_offset_diff);\n         rdr.curr = next.ch;\n@@ -204,7 +204,7 @@ pub fn is_eof(rdr: @mut StringReader) -> bool {\n pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos).to_uint();\n     if offset < (*rdr.src).len() {\n-        return str::char_at(*rdr.src, offset);\n+        return rdr.src.char_at(offset);\n     } else { return -1 as char; }\n }\n "}, {"sha": "b7ce617fe50443e3bd76a76c4316cd3794d39d6b", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec5a028adac360537c8f37a669eda522bd8c9b6b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=ec5a028adac360537c8f37a669eda522bd8c9b6b", "patch": "@@ -22,8 +22,8 @@ pub fn main() {\n     assert!(str::char_len(s) == 4u);\n     assert!(str::to_chars(s).len() == 4u);\n     assert!(str::from_chars(str::to_chars(s)) == s);\n-    assert!(str::char_at(s, 0u) == 'e');\n-    assert!(str::char_at(s, 1u) == '\u00e9');\n+    assert!(s.char_at(0u) == 'e');\n+    assert!(s.char_at(1u) == '\u00e9');\n \n     assert!((str::is_utf8(str::to_bytes(s))));\n     assert!((!str::is_utf8(~[0x80_u8])));"}]}