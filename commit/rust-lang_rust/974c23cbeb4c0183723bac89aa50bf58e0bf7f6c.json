{"sha": "974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NGMyM2NiZWI0YzAxODM3MjNiYWM4OWFhNTBiZjU4ZTBiZjdmNmM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-18T07:11:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:14Z"}, "message": "removed hello world and added uv_async_*", "tree": {"sha": "b49f2763f9bde2a47445f6a4c5d4d0d6634ad963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b49f2763f9bde2a47445f6a4c5d4d0d6634ad963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "html_url": "https://github.com/rust-lang/rust/commit/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffad8d7f0cc4917f46757f5a431f6207238bf59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffad8d7f0cc4917f46757f5a431f6207238bf59b", "html_url": "https://github.com/rust-lang/rust/commit/ffad8d7f0cc4917f46757f5a431f6207238bf59b"}], "stats": {"total": 196, "additions": 154, "deletions": 42}, "files": [{"sha": "8a61df37982baa4e2218b1f6ed1e94ea640bdd88", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 117, "deletions": 39, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "patch": "@@ -2,20 +2,25 @@\n \n // UV2\n enum uv_operation {\n-    op_hw()\n+    op_async_init([u8])\n }\n \n+type uv_async = {\n+    id: [u8],\n+    loop: uv_loop\n+};\n+\n enum uv_msg {\n     // requests from library users\n     msg_run(comm::chan<bool>),\n     msg_run_in_bg(),\n     msg_loop_delete(),\n-    msg_async_init([u8], fn~()),\n+    msg_async_init(fn~(uv_async), fn~(uv_async)),\n     msg_async_send([u8]),\n-    msg_hw(),\n \n     // dispatches from libuv\n-    uv_hw()\n+    uv_async_init([u8], *ctypes::void),\n+    uv_async_send([u8])\n }\n \n type uv_loop_data = {\n@@ -25,10 +30,6 @@ type uv_loop_data = {\n \n type uv_loop = comm::chan<uv_msg>;\n \n-enum uv_handle {\n-    handle([u8], *ctypes::void)\n-}\n-\n #[nolink]\n native mod rustrt {\n     fn rust_uvtmp_create_thread() -> thread;\n@@ -66,10 +67,14 @@ native mod rustrt {\n     fn rust_uvtmp_uv_bind_op_cb(loop: *ctypes::void, cb: *u8) -> *ctypes::void;\n     fn rust_uvtmp_uv_run(loop_handle: *ctypes::void);\n     fn rust_uvtmp_uv_async_send(handle: *ctypes::void);\n+    fn rust_uvtmp_uv_async_init(\n+        loop_handle: *ctypes::void,\n+        cb: *u8,\n+        id: *u8) -> *ctypes::void;\n }\n \n mod uv {\n-    export loop_new, run, run_in_bg, hw;\n+    export loop_new, run, run_in_bg, async_init, async_send;\n \n     // public functions\n     fn loop_new() -> uv_loop unsafe {\n@@ -78,7 +83,9 @@ mod uv {\n         let ret_recv_chan: comm::chan<uv_loop> =\n             comm::chan(ret_recv_port);\n \n-        task::spawn_sched(3u) {||\n+        let num_threads = 4u; // would be cool to tie this to\n+                              // the number of logical procs\n+        task::spawn_sched(num_threads) {||\n             // our beloved uv_loop_t ptr\n             let loop_handle = rustrt::\n                 rust_uvtmp_uv_loop_new();\n@@ -115,12 +122,17 @@ mod uv {\n                                           // to libuv, this will be\n                                           // in the process_operation\n                                           // crust fn\n-            let async_handle = rustrt::rust_uvtmp_uv_bind_op_cb(\n+            let op_handle = rustrt::rust_uvtmp_uv_bind_op_cb(\n                 loop_handle,\n                 process_operation);\n \n             // all state goes here\n-            let handles: map::map<[u8], uv_handle> =\n+            let handles: map::map<[u8], *ctypes::void> =\n+                map::new_bytes_hash();\n+            let async_cbs: map::map<[u8], fn~(uv_async)> =\n+                map::new_bytes_hash();\n+            let async_init_after_cbs: map::map<[u8],\n+                                               fn~(uv_async)> =\n                 map::new_bytes_hash();\n \n             // the main loop that this task blocks on.\n@@ -143,36 +155,51 @@ mod uv {\n                         comm::send(end_chan, true);\n                     };\n                   }\n+                  \n                   msg_run_in_bg {\n                     task::spawn_sched(1u) {||\n                         // this call blocks\n                         rustrt::rust_uvtmp_uv_run(loop_handle);\n                     };\n                   }\n-                  msg_hw() {\n-                    comm::send(operation_chan, op_hw);\n-                    io::println(\"CALLING ASYNC_SEND FOR HW\");\n-                    rustrt::rust_uvtmp_uv_async_send(async_handle);\n-                  }\n-                  uv_hw() {\n-                    io::println(\"HELLO WORLD!!!\");\n-                  }\n-\n-                  ////// STUBS ///////\n-                  msg_loop_delete {\n-                    // delete the event loop's c ptr\n-                    // this will of course stop any\n-                    // further processing\n-                  }\n-                  msg_async_init(id, callback) {\n+                  \n+                  msg_async_init(callback, after_cb) {\n                     // create a new async handle\n                     // with the id as the handle's\n                     // data and save the callback for\n                     // invocation on msg_async_send\n+                    let id = gen_handle_id();\n+                    async_cbs.insert(id, callback);\n+                    async_init_after_cbs.insert(id, after_cb);\n+                    let op = op_async_init(id);\n+                    comm::send(operation_chan, op);\n+                    rustrt::rust_uvtmp_uv_async_send(op_handle);\n+                    io::println(\"MSG_ASYNC_INIT\");\n                   }\n+                  uv_async_init(id, async_handle) {\n+                    // libuv created a handle, which is\n+                    // passed back to us. save it and\n+                    // then invoke the supplied callback\n+                    // for after completion\n+                    handles.insert(id, async_handle);\n+                    let after_cb = async_init_after_cbs.get(id);\n+                    async_init_after_cbs.remove(id);\n+                    task::spawn {||\n+                        let async: uv_async = {\n+                            id: id,\n+                            loop: rust_loop_chan\n+                        };\n+                        after_cb(async);\n+                    };\n+                  }\n+\n                   msg_async_send(id) {\n-                    // get the callback matching the\n-                    // supplied id and invoke it\n+                    let async_handle = handles.get(id);\n+                    rustrt::rust_uvtmp_uv_async_send(async_handle);\n+                  }\n+                  uv_async_send(id) {\n+                    let async_cb = async_cbs.get(id);\n+                    async_cb({id: id, loop: rust_loop_chan});\n                   }\n \n                   _ { fail \"unknown form of uv_msg received\"; }\n@@ -193,37 +220,88 @@ mod uv {\n         comm::send(loop, msg_run_in_bg);\n     }\n \n-    fn hw(loop: uv_loop) {\n-        comm::send(loop, msg_hw);\n+    fn async_init (\n+        loop: uv_loop,\n+        async_cb: fn~(uv_async),\n+        after_cb: fn~(uv_async)) {\n+        let msg = msg_async_init(async_cb, after_cb);\n+        comm::send(loop, msg);\n+    }\n+\n+    fn async_send(async: uv_async) {\n+        comm::send(async.loop, msg_async_send(async.id));\n     }\n \n     // internal functions\n+    fn gen_handle_id() -> [u8] {\n+        ret rand::mk_rng().gen_bytes(16u);\n+    }\n+    fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n+        ret vec::unsafe::from_buf(buf, 16u); \n+    }\n+\n+    fn get_loop_chan_from(data: *uv_loop_data)\n+            -> comm::chan<uv_msg> unsafe {\n+        ret (*data).rust_loop_chan;\n+    }\n \n     // crust\n-    crust fn process_operation(data: *uv_loop_data) unsafe {\n+    crust fn process_operation(\n+            loop: *ctypes::void,\n+            data: *uv_loop_data) unsafe {\n         io::println(\"IN PROCESS_OPERATION\");\n         let op_port = (*data).operation_port;\n-        let loop_chan = (*data).rust_loop_chan;\n+        let loop_chan = get_loop_chan_from(data);\n         let op_pending = comm::peek(op_port);\n         while(op_pending) {\n             io::println(\"OPERATION PENDING!\");\n             alt comm::recv(op_port) {\n-              op_hw() {\n-                io::println(\"GOT OP_HW IN CRUST\");\n-                comm::send(loop_chan, uv_hw);\n+              op_async_init(id) {\n+                io::println(\"OP_ASYNC_INIT\");\n+                let id_ptr = vec::unsafe::to_ptr(id);\n+                let async_handle = rustrt::rust_uvtmp_uv_async_init(\n+                    loop,\n+                    process_async_send,\n+                    id_ptr);\n+                comm::send(loop_chan, uv_async_init(\n+                    id,\n+                    async_handle));\n               }\n+              \n               _ { fail \"unknown form of uv_operation received\"; }\n             }\n             op_pending = comm::peek(op_port);\n         }\n         io::println(\"NO MORE OPERATIONS PENDING!\");\n     }\n+\n+    crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n+            unsafe {\n+        let handle_id = get_handle_id_from(id_buf);\n+        let loop_chan = get_loop_chan_from(data);\n+        comm::send(loop_chan, uv_async_send(handle_id));\n+    }\n+\n+    \n+}\n+\n+#[test]\n+fn test_uvtmp_uv_new_loop_no_handles() {\n+    let test_loop = uv::loop_new();\n+    uv::run(test_loop); // this should return immediately\n+                        // since there aren't any handles..\n }\n \n #[test]\n-fn uvtmp_uv_test_hello_world() {\n+fn test_uvtmp_uv_simple_async() {\n     let test_loop = uv::loop_new();\n-    uv::hw(test_loop);\n+    let cb: fn~(uv_async) = fn~(h: uv_async) {\n+        io::println(\"HELLO FROM ASYNC CALLBACK!\");\n+    };\n+    uv::async_init(test_loop, cb) {|new_async|\n+        io::println(\"NEW_ASYNC CREATED!\");\n+        uv::async_send(new_async);\n+    };\n     uv::run(test_loop);\n }\n "}, {"sha": "18a30fb64042c4c85ffcb4755fa7ad4fb47f7801", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "patch": "@@ -57,6 +57,9 @@ struct timer_start_data {\n \n // UVTMP REWORK\n \n+typedef void (*async_op_cb)(uv_loop_t* loop, void* data);\n+typedef void (*rust_async_cb)(uint8_t* id_buf, void* loop_data);\n+\n static void*\n current_kernel_malloc(size_t size, const char* tag) {\n   return rust_task_thread::get_task()->malloc(size, tag);\n@@ -68,6 +71,11 @@ current_kernel_free(void* ptr) {\n   rust_task_thread::get_task()->free(ptr);\n }\n */\n+#define RUST_UV_HANDLE_LEN 16\n+struct async_data {\n+\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n+\trust_async_cb cb;\n+};\n \n extern \"C\" void*\n rust_uvtmp_uv_loop_new() {\n@@ -79,11 +87,11 @@ rust_uvtmp_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-typedef void (*async_op_cb)(void* data);\n-void native_async_op_cb(uv_async_t* handle, int status) {\n+static void\n+native_async_op_cb(uv_async_t* handle, int status) {\n     async_op_cb cb = (async_op_cb)handle->data;\n \tvoid* loop_data = handle->loop->data;\n-\tcb(loop_data);\n+\tcb(handle->loop, loop_data);\n }\n \n extern \"C\" void*\n@@ -92,6 +100,8 @@ rust_uvtmp_uv_bind_op_cb(uv_loop_t* loop, async_op_cb cb) {\n \t\tsizeof(uv_async_t),\n \t\t\"uv_async_t\");\n \tuv_async_init(loop, async, native_async_op_cb);\n+\t// decrement the ref count, so that our async bind\n+\t// does count towards keeping the loop alive\n \tasync->data = (void*)cb;\n \treturn async;\n }\n@@ -105,6 +115,30 @@ rust_uvtmp_uv_async_send(uv_async_t* handle) {\n     uv_async_send(handle);\n }\n \n+static void\n+native_async_cb(uv_async_t* handle, int status) {\n+\tasync_data* handle_data = (async_data*)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\thandle_data->cb(handle_data->id_buf, loop_data);\n+}\n+\n+extern \"C\" void*\n+rust_uvtmp_uv_async_init(uv_loop_t* loop, rust_async_cb cb,\n+\t\t\t\t\t\t uint8_t* buf) {\n+    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\t\tsizeof(uv_async_t),\n+\t\t\"uv_async_t\");\n+\tuv_async_init(loop, async, native_async_cb);\n+\tasync_data* data = (async_data*)current_kernel_malloc(\n+\t\tsizeof(async_data),\n+\t\t\"async_data\");\n+\tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n+\tdata->cb = cb;\n+\tasync->data = data;\n+\n+\treturn async;\n+}\n+\n // UVTMP REWORK\n \n // FIXME: Copied from rust_builtins.cpp. Could bitrot easily"}]}