{"sha": "83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "node_id": "C_kwDOAAsO6NoAKDgzYjE1YmZlMWMxNWYzMjViYzE4NmViZmUzNjkxYjcyOWVkNTlmMmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T16:59:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-28T16:59:56Z"}, "message": "Auto merge of #92352 - matthiaskrgr:rollup-19fbq7u, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #92076 (Ignore other `PredicateKind`s in rustdoc auto trait finder)\n - #92219 (Remove VCVARS_BAT)\n - #92238 (Add a test suite for stringify macro)\n - #92330 (Add myself to .mailmap)\n - #92333 (Tighten span when suggesting lifetime on path)\n - #92335 (Document units for `std::column`)\n - #92344 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7cf204daa88c54395af84a97f3fc902934e91aa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cf204daa88c54395af84a97f3fc902934e91aa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "html_url": "https://github.com/rust-lang/rust/commit/83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "442248d6bcc00693922941eb5a9f241e0e9da2c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/442248d6bcc00693922941eb5a9f241e0e9da2c0", "html_url": "https://github.com/rust-lang/rust/commit/442248d6bcc00693922941eb5a9f241e0e9da2c0"}, {"sha": "11c71d24aae79cad195b8b7e3f22fc8fd5a80926", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c71d24aae79cad195b8b7e3f22fc8fd5a80926", "html_url": "https://github.com/rust-lang/rust/commit/11c71d24aae79cad195b8b7e3f22fc8fd5a80926"}], "stats": {"total": 1004, "additions": 993, "deletions": 11}, "files": [{"sha": "67deb3d97794222b76c59e78ef8d4f2386843870", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -355,7 +355,6 @@ jobs:\n             env:\n               SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n-              VCVARS_BAT: vcvars64.bat\n             os: windows-latest-xl\n           - name: x86_64-msvc-tools\n             env:"}, {"sha": "9366ef383fc6d823f0a8a2090925a5de8b53c952", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -296,6 +296,7 @@ Ulrik Sverdrup <bluss@users.noreply.github.com> Ulrik Sverdrup <root@localhost>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>\n Vitali Haravy <HumaneProgrammer@gmail.com> Vitali Haravy <humaneprogrammer@gmail.com>\n+Wesley Wiser <wwiser@gmail.com> <wesleywiser@microsoft.com>\n whitequark <whitequark@whitequark.org>\n William Ting <io@williamting.com> <william.h.ting@gmail.com>\n Xuefeng Wu <benewu@gmail.com> Xuefeng Wu <xfwu@thoughtworks.com>"}, {"sha": "46928a1846540f13859f74c2f6df5ce4023dd67b", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -277,7 +277,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n             let elided_lifetime_span = if generic_args.span.is_empty() {\n                 // If there are no brackets, use the identifier span.\n-                path_span\n+                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n+                // originating from macros, since the segment's span might be from a macro arg.\n+                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n             } else if generic_args.is_empty() {\n                 // If there are brackets, but not generic arguments, then use the opening bracket\n                 generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))"}, {"sha": "4cd1b34bedc95a55f5fc30a9f07a89dadadd92d9", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -2115,10 +2115,13 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                 let spans_suggs: Vec<_> = formatters\n                     .into_iter()\n                     .zip(spans_with_counts.iter())\n-                    .filter_map(|(fmt, (span, _))| {\n-                        if let Some(formatter) = fmt { Some((formatter, span)) } else { None }\n+                    .filter_map(|(formatter, (span, _))| {\n+                        if let Some(formatter) = formatter {\n+                            Some((*span, formatter(name)))\n+                        } else {\n+                            None\n+                        }\n                     })\n-                    .map(|(formatter, span)| (*span, formatter(name)))\n                     .collect();\n                 if spans_suggs.is_empty() {\n                     // If all the spans come from macros, we cannot extract snippets and then"}, {"sha": "05d2a373dc6390977b0659d2037b0d34b8450d6c", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -839,7 +839,17 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         _ => return false,\n                     }\n                 }\n-                _ => panic!(\"Unexpected predicate {:?} {:?}\", ty, predicate),\n+                // There's not really much we can do with these predicates -\n+                // we start out with a `ParamEnv` with no inference variables,\n+                // and these don't correspond to adding any new bounds to\n+                // the `ParamEnv`.\n+                ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n             };\n         }\n         true"}, {"sha": "d9389892c0cd6b18fe7c96696f064be4e44e0396", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -1065,6 +1065,18 @@ pub(crate) mod builtin {\n     /// let current_col = column!();\n     /// println!(\"defined on column: {}\", current_col);\n     /// ```\n+    ///\n+    /// `column!` counts Unicode code points, not bytes or graphemes. As a result, the first two\n+    /// invocations return the same value, but the third does not.\n+    ///\n+    /// ```\n+    /// let a = (\"foobar\", column!()).1;\n+    /// let b = (\"\u4eba\u4e4b\u521d\u6027\u672c\u5584\", column!()).1;\n+    /// let c = (\"f\u0305o\u0305o\u0305b\u0305a\u0305r\u0305\", column!()).1; // Uses combining overline (U+0305)\n+    ///\n+    /// assert_eq!(a, b);\n+    /// assert_ne!(b, c);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]"}, {"sha": "ac5d5822bfbd53d23cf34877e1343c6210c6b131", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -548,7 +548,6 @@ jobs:\n             env:\n               SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n-              VCVARS_BAT: vcvars64.bat\n             <<: *job-windows-xl\n \n           - name: x86_64-msvc-tools"}, {"sha": "800f03302ed38adfde8daaca51530f81eb79e2d9", "filename": "src/test/ui/in-band-lifetimes/missing-lifetime-in-alias.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -0,0 +1,34 @@\n+#![feature(generic_associated_types)]\n+#![allow(unused)]\n+\n+trait Trait<'a> {\n+    type Foo;\n+\n+    type Bar<'b>\n+    //~^ NOTE associated type defined here, with 1 lifetime parameter\n+    //~| NOTE\n+    where\n+        Self: 'b;\n+}\n+\n+struct Impl<'a>(&'a ());\n+\n+impl<'a> Trait<'a> for Impl<'a> {\n+    type Foo = &'a ();\n+    type Bar<'b> = &'b ();\n+}\n+\n+type A<'a> = Impl<'a>;\n+\n+type B<'a> = <A<'a> as Trait>::Foo;\n+//~^ ERROR missing lifetime specifier\n+//~| NOTE expected named lifetime parameter\n+\n+type C<'a, 'b> = <A<'a> as Trait>::Bar;\n+//~^ ERROR missing lifetime specifier\n+//~| ERROR missing generics for associated type\n+//~| NOTE expected named lifetime parameter\n+//~| NOTE these named lifetimes are available to use\n+//~| NOTE expected 1 lifetime argument\n+\n+fn main() {}"}, {"sha": "f1b951fc82632475c215cffc36871dca54e0571c", "filename": "src/test/ui/in-band-lifetimes/missing-lifetime-in-alias.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmissing-lifetime-in-alias.stderr?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -0,0 +1,43 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-alias.rs:23:24\n+   |\n+LL | type B<'a> = <A<'a> as Trait>::Foo;\n+   |                        ^^^^^ expected named lifetime parameter\n+   |\n+help: consider using the `'a` lifetime\n+   |\n+LL | type B<'a> = <A<'a> as Trait<'a>>::Foo;\n+   |                        ~~~~~~~~~\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/missing-lifetime-in-alias.rs:27:28\n+   |\n+LL | type C<'a, 'b> = <A<'a> as Trait>::Bar;\n+   |                            ^^^^^ expected named lifetime parameter\n+   |\n+note: these named lifetimes are available to use\n+  --> $DIR/missing-lifetime-in-alias.rs:27:8\n+   |\n+LL | type C<'a, 'b> = <A<'a> as Trait>::Bar;\n+   |        ^^  ^^\n+\n+error[E0107]: missing generics for associated type `Trait::Bar`\n+  --> $DIR/missing-lifetime-in-alias.rs:27:36\n+   |\n+LL | type C<'a, 'b> = <A<'a> as Trait>::Bar;\n+   |                                    ^^^ expected 1 lifetime argument\n+   |\n+note: associated type defined here, with 1 lifetime parameter: `'b`\n+  --> $DIR/missing-lifetime-in-alias.rs:7:10\n+   |\n+LL |     type Bar<'b>\n+   |          ^^^ --\n+help: add missing lifetime argument\n+   |\n+LL | type C<'a, 'b> = <A<'a> as Trait>::Bar<'a>;\n+   |                                    ~~~~~~~\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0106, E0107.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "a692d6af703ea6104c2281f42d68cc5e4928b647", "filename": "src/test/ui/lint/reasons.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Flint%2Freasons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons.stderr?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -1,8 +1,8 @@\n warning: hidden lifetime parameters in types are deprecated\n-  --> $DIR/reasons.rs:20:29\n+  --> $DIR/reasons.rs:20:34\n    |\n LL |     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-   |                             ^^^^^^^^^^^^^^ expected named lifetime parameter\n+   |                                  ^^^^^^^^^ expected named lifetime parameter\n    |\n    = note: explicit anonymous lifetimes aid reasoning about ownership\n note: the lint level is defined here\n@@ -13,7 +13,7 @@ LL | #![warn(elided_lifetimes_in_paths,\n help: consider using the `'_` lifetime\n    |\n LL |     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-   |                             ~~~~~~~~~~~~~~~~~~\n+   |                                  ~~~~~~~~~~~~~\n \n warning: variable `Social_exchange_psychology` should have a snake case name\n   --> $DIR/reasons.rs:30:9"}, {"sha": "fcf6a9278d8fe35e785937cc89bc737b8ba88565", "filename": "src/test/ui/macros/stringify.rs", "status": "added", "additions": 879, "deletions": 0, "changes": 879, "blob_url": "https://github.com/rust-lang/rust/blob/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83b15bfe1c15f325bc186ebfe3691b729ed59f2b/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -0,0 +1,879 @@\n+// run-pass\n+// edition:2021\n+// compile-flags: --test\n+\n+#![feature(async_closure)]\n+#![feature(const_trait_impl)]\n+#![feature(generators)]\n+#![feature(half_open_range_patterns)]\n+#![feature(more_qualified_paths)]\n+#![feature(raw_ref_op)]\n+#![deny(unused_macros)]\n+\n+macro_rules! stringify_block {\n+    ($block:block) => {\n+        stringify!($block)\n+    };\n+}\n+\n+macro_rules! stringify_expr {\n+    ($expr:expr) => {\n+        stringify!($expr)\n+    };\n+}\n+\n+macro_rules! stringify_item {\n+    ($item:item) => {\n+        stringify!($item)\n+    };\n+}\n+\n+macro_rules! stringify_meta {\n+    ($meta:meta) => {\n+        stringify!($meta)\n+    };\n+}\n+\n+macro_rules! stringify_pat {\n+    ($pat:pat) => {\n+        stringify!($pat)\n+    };\n+}\n+\n+macro_rules! stringify_path {\n+    ($path:path) => {\n+        stringify!($path)\n+    };\n+}\n+\n+macro_rules! stringify_stmt {\n+    ($stmt:stmt) => {\n+        stringify!($stmt)\n+    };\n+}\n+\n+macro_rules! stringify_ty {\n+    ($ty:ty) => {\n+        stringify!($ty)\n+    };\n+}\n+\n+macro_rules! stringify_vis {\n+    ($vis:vis) => {\n+        stringify!($vis)\n+    };\n+}\n+\n+#[test]\n+fn test_block() {\n+    assert_eq!(stringify_block!({}), \"{}\");\n+    assert_eq!(stringify_block!({ true }), \"{ true }\");\n+    assert_eq!(stringify_block!({ return }), \"{ return }\");\n+    assert_eq!(\n+        stringify_block!({\n+            return;\n+        }),\n+        \"{ return; }\",\n+    );\n+    assert_eq!(\n+        stringify_block!({\n+            let _;\n+            true\n+        }),\n+        \"{ let _; true }\",\n+    );\n+}\n+\n+#[test]\n+fn test_expr() {\n+    // ExprKind::Box\n+    assert_eq!(stringify_expr!(box expr), \"box expr\");\n+\n+    // ExprKind::Array\n+    assert_eq!(stringify_expr!([]), \"[]\");\n+    assert_eq!(stringify_expr!([true]), \"[true]\");\n+    assert_eq!(stringify_expr!([true,]), \"[true]\");\n+    assert_eq!(stringify_expr!([true, true]), \"[true, true]\");\n+\n+    // ExprKind::Call\n+    assert_eq!(stringify_expr!(f()), \"f()\");\n+    assert_eq!(stringify_expr!(f::<u8>()), \"f::<u8>()\");\n+    assert_eq!(stringify_expr!(f::<1>()), \"f::<1>()\");\n+    assert_eq!(stringify_expr!(f::<'a, u8, 1>()), \"f::<'a, u8, 1>()\");\n+    assert_eq!(stringify_expr!(f(true)), \"f(true)\");\n+    assert_eq!(stringify_expr!(f(true,)), \"f(true)\");\n+    assert_eq!(stringify_expr!(()()), \"()()\");\n+\n+    // ExprKind::MethodCall\n+    assert_eq!(stringify_expr!(x.f()), \"x.f()\");\n+    assert_eq!(stringify_expr!(x.f::<u8>()), \"x.f::<u8>()\");\n+\n+    // ExprKind::Tup\n+    assert_eq!(stringify_expr!(()), \"()\");\n+    assert_eq!(stringify_expr!((true,)), \"(true,)\");\n+    assert_eq!(stringify_expr!((true, false)), \"(true, false)\");\n+    assert_eq!(stringify_expr!((true, false,)), \"(true, false)\");\n+\n+    // ExprKind::Binary\n+    assert_eq!(stringify_expr!(true || false), \"true || false\");\n+    assert_eq!(stringify_expr!(true || false && false), \"true || false && false\");\n+\n+    // ExprKind::Unary\n+    assert_eq!(stringify_expr!(*expr), \"*expr\");\n+    assert_eq!(stringify_expr!(!expr), \"!expr\");\n+    assert_eq!(stringify_expr!(-expr), \"-expr\");\n+\n+    // ExprKind::Lit\n+    assert_eq!(stringify_expr!('x'), \"'x'\");\n+    assert_eq!(stringify_expr!(1_000_i8), \"1_000_i8\");\n+    assert_eq!(stringify_expr!(1.00000000000000001), \"1.00000000000000001\");\n+\n+    // ExprKind::Cast\n+    assert_eq!(stringify_expr!(expr as T), \"expr as T\");\n+    assert_eq!(stringify_expr!(expr as T<u8>), \"expr as T<u8>\");\n+\n+    // ExprKind::Type\n+    assert_eq!(stringify_expr!(expr: T), \"expr: T\");\n+    assert_eq!(stringify_expr!(expr: T<u8>), \"expr: T<u8>\");\n+\n+    // ExprKind::If\n+    assert_eq!(stringify_expr!(if true {}), \"if true {}\");\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else {\n+        }),\n+        \"if true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if let true = true {\n+        } else {\n+        }),\n+        \"if let true = true {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        }),\n+        \"if true {} else if false {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+        } else if false {\n+        } else {\n+        }),\n+        \"if true {} else if false {} else {}\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(if true {\n+            return;\n+        } else if false {\n+            0\n+        } else {\n+            0\n+        }),\n+        \"if true { return; } else if false { 0 } else { 0 }\",\n+    );\n+\n+    // ExprKind::While\n+    assert_eq!(stringify_expr!(while true {}), \"while true {}\");\n+    assert_eq!(stringify_expr!('a: while true {}), \"'a: while true {}\");\n+    assert_eq!(stringify_expr!(while let true = true {}), \"while let true = true {}\");\n+\n+    // ExprKind::ForLoop\n+    assert_eq!(stringify_expr!(for _ in x {}), \"for _ in x {}\");\n+    assert_eq!(stringify_expr!('a: for _ in x {}), \"'a: for _ in x {}\");\n+\n+    // ExprKind::Loop\n+    assert_eq!(stringify_expr!(loop {}), \"loop {}\");\n+    assert_eq!(stringify_expr!('a: loop {}), \"'a: loop {}\");\n+\n+    // ExprKind::Match\n+    assert_eq!(stringify_expr!(match self {}), \"match self {}\");\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+        }),\n+        \"match self { Ok => 1, }\",\n+    );\n+    assert_eq!(\n+        stringify_expr!(match self {\n+            Ok => 1,\n+            Err => 0,\n+        }),\n+        \"match self { Ok => 1, Err => 0, }\",\n+    );\n+\n+    // ExprKind::Closure\n+    assert_eq!(stringify_expr!(|| {}), \"|| {}\");\n+    assert_eq!(stringify_expr!(|x| {}), \"|x| {}\");\n+    assert_eq!(stringify_expr!(|x: u8| {}), \"|x: u8| {}\");\n+    assert_eq!(stringify_expr!(|| ()), \"|| ()\");\n+    assert_eq!(stringify_expr!(move || self), \"move || self\");\n+    assert_eq!(stringify_expr!(async || self), \"async || self\");\n+    assert_eq!(stringify_expr!(async move || self), \"async move || self\");\n+    assert_eq!(stringify_expr!(static || self), \"static || self\");\n+    assert_eq!(stringify_expr!(static move || self), \"static move || self\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async || self),\n+        \"static async || self\",\n+    );\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5149\n+    assert_eq!(\n+        stringify_expr!(static async move || self),\n+        \"static async move || self\",\n+    );\n+    assert_eq!(stringify_expr!(|| -> u8 { self }), \"|| -> u8 { self }\");\n+    assert_eq!(stringify_expr!(1 + || {}), \"1 + (|| {})\"); // ??\n+\n+    // ExprKind::Block\n+    assert_eq!(stringify_expr!({}), \"{}\");\n+    assert_eq!(stringify_expr!(unsafe {}), \"unsafe {}\");\n+    assert_eq!(stringify_expr!('a: {}), \"'a: {}\");\n+    assert_eq!(\n+        stringify_expr!(\n+            #[attr]\n+            {}\n+        ),\n+        \"#[attr] { }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_expr!(\n+            {\n+                #![attr]\n+            }\n+        ),\n+        \"{\\n\\\n+        \\x20   #![attr]\\n\\\n+        }\",\n+    );\n+\n+    // ExprKind::Async\n+    assert_eq!(stringify_expr!(async {}), \"async {}\");\n+    assert_eq!(stringify_expr!(async move {}), \"async move {}\");\n+\n+    // ExprKind::Await\n+    assert_eq!(stringify_expr!(expr.await), \"expr.await\");\n+\n+    // ExprKind::TryBlock\n+    assert_eq!(stringify_expr!(try {}), \"try  {}\"); // FIXME\n+\n+    // ExprKind::Assign\n+    assert_eq!(stringify_expr!(expr = true), \"expr = true\");\n+\n+    // ExprKind::AssignOp\n+    assert_eq!(stringify_expr!(expr += true), \"expr += true\");\n+\n+    // ExprKind::Field\n+    assert_eq!(stringify_expr!(expr.field), \"expr.field\");\n+    assert_eq!(stringify_expr!(expr.0), \"expr.0\");\n+\n+    // ExprKind::Index\n+    assert_eq!(stringify_expr!(expr[true]), \"expr[true]\");\n+\n+    // ExprKind::Range\n+    assert_eq!(stringify_expr!(..), \"..\");\n+    assert_eq!(stringify_expr!(..hi), \"..hi\");\n+    assert_eq!(stringify_expr!(lo..), \"lo..\");\n+    assert_eq!(stringify_expr!(lo..hi), \"lo..hi\");\n+    assert_eq!(stringify_expr!(..=hi), \"..=hi\");\n+    assert_eq!(stringify_expr!(lo..=hi), \"lo..=hi\");\n+    assert_eq!(stringify_expr!(-2..=-1), \"-2..=-1\");\n+\n+    // ExprKind::Path\n+    assert_eq!(stringify_expr!(thing), \"thing\");\n+    assert_eq!(stringify_expr!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_expr!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_expr!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_expr!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_expr!(<Self as T>::thing), \"<Self as T>::thing\");\n+    assert_eq!(stringify_expr!(Self::<'static>), \"Self::<'static>\");\n+\n+    // ExprKind::AddrOf\n+    assert_eq!(stringify_expr!(&expr), \"&expr\");\n+    assert_eq!(stringify_expr!(&mut expr), \"&mut expr\");\n+    assert_eq!(stringify_expr!(&raw const expr), \"&raw const expr\");\n+    assert_eq!(stringify_expr!(&raw mut expr), \"&raw mut expr\");\n+\n+    // ExprKind::Break\n+    assert_eq!(stringify_expr!(break), \"break\");\n+    assert_eq!(stringify_expr!(break 'a), \"break 'a\");\n+    assert_eq!(stringify_expr!(break true), \"break true\");\n+    assert_eq!(stringify_expr!(break 'a true), \"break 'a true\");\n+\n+    // ExprKind::Continue\n+    assert_eq!(stringify_expr!(continue), \"continue\");\n+    assert_eq!(stringify_expr!(continue 'a), \"continue 'a\");\n+\n+    // ExprKind::Ret\n+    assert_eq!(stringify_expr!(return), \"return\");\n+    assert_eq!(stringify_expr!(return true), \"return true\");\n+\n+    // ExprKind::MacCall\n+    assert_eq!(stringify_expr!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_expr!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_expr!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ExprKind::Struct\n+    assert_eq!(stringify_expr!(Struct {}), \"Struct{}\"); // FIXME\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(stringify_expr!(<Struct as Trait>::Type {}), \"<Struct as Trait>::Type{}\");\n+    assert_eq!(stringify_expr!(Struct { .. }), \"Struct{..}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { ..base }), \"Struct{..base}\"); // FIXME\n+    assert_eq!(stringify_expr!(Struct { x }), \"Struct{x,}\");\n+    assert_eq!(stringify_expr!(Struct { x, .. }), \"Struct{x, ..}\");\n+    assert_eq!(stringify_expr!(Struct { x, ..base }), \"Struct{x, ..base}\");\n+    assert_eq!(stringify_expr!(Struct { x: true }), \"Struct{x: true,}\");\n+    assert_eq!(stringify_expr!(Struct { x: true, .. }), \"Struct{x: true, ..}\");\n+    assert_eq!(stringify_expr!(Struct { x: true, ..base }), \"Struct{x: true, ..base}\");\n+\n+    // ExprKind::Repeat\n+    assert_eq!(stringify_expr!([(); 0]), \"[(); 0]\");\n+\n+    // ExprKind::Paren\n+    assert_eq!(stringify_expr!((expr)), \"(expr)\");\n+\n+    // ExprKind::Try\n+    assert_eq!(stringify_expr!(expr?), \"expr?\");\n+\n+    // ExprKind::Yield\n+    assert_eq!(stringify_expr!(yield), \"yield\");\n+    assert_eq!(stringify_expr!(yield true), \"yield true\");\n+}\n+\n+#[test]\n+fn test_item() {\n+    // ItemKind::ExternCrate\n+    assert_eq!(\n+        stringify_item!(\n+            extern crate std;\n+        ),\n+        \"extern crate std;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern crate self as std;\n+        ),\n+        \"pub extern crate self as std;\",\n+    );\n+\n+    // ItemKind::Use\n+    assert_eq!(\n+        stringify_item!(\n+            pub use crate::{a, b::c};\n+        ),\n+        \"pub use crate::{a, b::c};\",\n+    );\n+\n+    // ItemKind::Static\n+    assert_eq!(\n+        stringify_item!(\n+            pub static S: () = {};\n+        ),\n+        \"pub static S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: () = {};\n+        ),\n+        \"static mut S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static S: ();\n+        ),\n+        \"static S: () ;\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            static mut S: ();\n+        ),\n+        \"static mut S: () ;\",\n+    );\n+\n+    // ItemKind::Const\n+    assert_eq!(\n+        stringify_item!(\n+            pub const S: () = {};\n+        ),\n+        \"pub const S: () = {};\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            const S: ();\n+        ),\n+        \"const S: () ;\", // FIXME\n+    );\n+\n+    // ItemKind::Fn\n+    assert_eq!(\n+        stringify_item!(\n+            pub default const async unsafe extern \"C\" fn f() {}\n+        ),\n+        \"pub default const async unsafe extern \\\"C\\\" fn f() {}\",\n+    );\n+\n+    // ItemKind::Mod\n+    assert_eq!(\n+        stringify_item!(\n+            pub mod m;\n+        ),\n+        \"pub mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            mod m {}\n+        ),\n+        \"mod m {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m;\n+        ),\n+        \"unsafe mod m;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe mod m {}\n+        ),\n+        \"unsafe mod m {}\",\n+    );\n+\n+    // ItemKind::ForeignMod\n+    assert_eq!(\n+        stringify_item!(\n+            extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub extern \"C\" {}\n+        ),\n+        \"extern \\\"C\\\" {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            unsafe extern \"C++\" {}\n+        ),\n+        \"unsafe extern \\\"C++\\\" {}\",\n+    );\n+\n+    // ItemKind::TyAlias\n+    #[rustfmt::skip]\n+    assert_eq!(\n+        stringify_item!(\n+            pub default type Type<'a>: Bound\n+            where\n+                Self: 'a,\n+            = T;\n+        ),\n+        \"pub default type Type<'a>: Bound where Self: 'a = T;\",\n+    );\n+\n+    // ItemKind::Enum\n+    assert_eq!(\n+        stringify_item!(\n+            pub enum Void {}\n+        ),\n+        \"pub enum Void {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Empty {\n+                Unit,\n+                Tuple(),\n+                Struct {},\n+            }\n+        ),\n+        \"enum Empty { Unit, Tuple(), Struct {}, }\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            enum Enum<T>\n+            where\n+                T: 'a,\n+            {\n+                Unit,\n+                Tuple(T),\n+                Struct { t: T },\n+            }\n+        ),\n+        \"enum Enum<T> where T: 'a {\\n\\\n+        \\x20   Unit,\\n\\\n+        \\x20   Tuple(T),\\n\\\n+        \\x20   Struct {\\n\\\n+        \\x20       t: T,\\n\\\n+        \\x20   },\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Struct\n+    assert_eq!(\n+        stringify_item!(\n+            pub struct Unit;\n+        ),\n+        \"pub struct Unit;\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple();\n+        ),\n+        \"struct Tuple();\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Tuple(T);\n+        ),\n+        \"struct Tuple(T);\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct {}\n+        ),\n+        \"struct Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            struct Struct<T>\n+            where\n+                T: 'a,\n+            {\n+                t: T,\n+            }\n+        ),\n+        \"struct Struct<T> where T: 'a {\\n\\\n+        \\x20   t: T,\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Union\n+    assert_eq!(\n+        stringify_item!(\n+            pub union Union {}\n+        ),\n+        \"pub union Union {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            union Union<T> where T: 'a {\n+                t: T,\n+            }\n+        ),\n+        \"union Union<T> where T: 'a {\\n\\\n+        \\x20   t: T,\\n\\\n+        }\",\n+    );\n+\n+    // ItemKind::Trait\n+    assert_eq!(\n+        stringify_item!(\n+            pub unsafe auto trait Send {}\n+        ),\n+        \"pub unsafe auto trait Send {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            trait Trait<'a>: Sized\n+            where\n+                Self: 'a,\n+            {\n+            }\n+        ),\n+        \"trait Trait<'a>: Sized where Self: 'a {}\",\n+    );\n+\n+    // ItemKind::TraitAlias\n+    assert_eq!(\n+        stringify_item!(\n+            pub trait Trait<T> = Sized where T: 'a;\n+        ),\n+        \"\", // FIXME\n+    );\n+\n+    // ItemKind::Impl\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Struct {}\n+        ),\n+        \"pub impl Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl<T> Struct<T> {}\n+        ),\n+        \"impl <T> Struct<T> {}\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub impl Trait for Struct {}\n+        ),\n+        \"pub impl Trait for Struct {}\",\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            impl ~const Struct {}\n+        ),\n+        \"impl Struct {}\", // FIXME\n+    );\n+\n+    // ItemKind::MacCall\n+    assert_eq!(stringify_item!(mac!(...);), \"mac!(...);\");\n+    assert_eq!(stringify_item!(mac![...];), \"mac![...];\");\n+    assert_eq!(stringify_item!(mac! { ... }), \"mac! { ... }\");\n+\n+    // ItemKind::MacroDef\n+    assert_eq!(\n+        stringify_item!(\n+            macro_rules! stringify {\n+                () => {};\n+            }\n+        ),\n+        \"macro_rules! stringify { () => {} ; }\", // FIXME\n+    );\n+    assert_eq!(\n+        stringify_item!(\n+            pub macro stringify() {}\n+        ),\n+        \"pub macro stringify { () => {} }\",\n+    );\n+}\n+\n+#[test]\n+fn test_meta() {\n+    assert_eq!(stringify_meta!(k), \"k\");\n+    assert_eq!(stringify_meta!(k = \"v\"), \"k = \\\"v\\\"\");\n+    assert_eq!(stringify_meta!(list(k1, k2 = \"v\")), \"list(k1, k2 = \\\"v\\\")\");\n+    assert_eq!(stringify_meta!(serde::k), \"serde::k\");\n+}\n+\n+#[test]\n+fn test_pat() {\n+    // PatKind::Wild\n+    assert_eq!(stringify_pat!(_), \"_\");\n+\n+    // PatKind::Ident\n+    assert_eq!(stringify_pat!(_x), \"_x\");\n+    assert_eq!(stringify_pat!(ref _x), \"ref _x\");\n+    assert_eq!(stringify_pat!(mut _x), \"mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x), \"ref mut _x\");\n+    assert_eq!(stringify_pat!(ref mut _x @ _), \"ref mut _x @ _\");\n+\n+    // PatKind::Struct\n+    assert_eq!(stringify_pat!(Struct {}), \"Struct {  }\"); // FIXME\n+    assert_eq!(stringify_pat!(Struct::<u8> {}), \"Struct::<u8> {  }\");\n+    assert_eq!(stringify_pat!(Struct::<'static> {}), \"Struct::<'static> {  }\");\n+    assert_eq!(stringify_pat!(Struct { x }), \"Struct { x }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x }), \"Struct { x: _x }\");\n+    assert_eq!(stringify_pat!(Struct { .. }), \"Struct { .. }\");\n+    assert_eq!(stringify_pat!(Struct { x, .. }), \"Struct { x, .. }\");\n+    assert_eq!(stringify_pat!(Struct { x: _x, .. }), \"Struct { x: _x, .. }\");\n+    #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5151\n+    assert_eq!(\n+        stringify_pat!(<Struct as Trait>::Type {}),\n+        \"<Struct as Trait>::Type {  }\",\n+    );\n+\n+    // PatKind::TupleStruct\n+    assert_eq!(stringify_pat!(Tuple()), \"Tuple()\");\n+    assert_eq!(stringify_pat!(Tuple::<u8>()), \"Tuple::<u8>()\");\n+    assert_eq!(stringify_pat!(Tuple::<'static>()), \"Tuple::<'static>()\");\n+    assert_eq!(stringify_pat!(Tuple(x)), \"Tuple(x)\");\n+    assert_eq!(stringify_pat!(Tuple(..)), \"Tuple(..)\");\n+    assert_eq!(stringify_pat!(Tuple(x, ..)), \"Tuple(x, ..)\");\n+    assert_eq!(stringify_pat!(<Struct as Trait>::Type()), \"<Struct as Trait>::Type()\");\n+\n+    // PatKind::Or\n+    assert_eq!(stringify_pat!(true | false), \"true | false\");\n+    assert_eq!(stringify_pat!(| true), \"true\");\n+    assert_eq!(stringify_pat!(|true| false), \"true | false\");\n+\n+    // PatKind::Path\n+    assert_eq!(stringify_pat!(crate::Path), \"crate::Path\");\n+    assert_eq!(stringify_pat!(Path::<u8>), \"Path::<u8>\");\n+    assert_eq!(stringify_pat!(Path::<'static>), \"Path::<'static>\");\n+    assert_eq!(stringify_pat!(<Struct as Trait>::Type), \"<Struct as Trait>::Type\");\n+\n+    // PatKind::Tuple\n+    assert_eq!(stringify_pat!(()), \"()\");\n+    assert_eq!(stringify_pat!((true,)), \"(true,)\");\n+    assert_eq!(stringify_pat!((true, false)), \"(true, false)\");\n+\n+    // PatKind::Box\n+    assert_eq!(stringify_pat!(box pat), \"box pat\");\n+\n+    // PatKind::Ref\n+    assert_eq!(stringify_pat!(&pat), \"&pat\");\n+    assert_eq!(stringify_pat!(&mut pat), \"&mut pat\");\n+\n+    // PatKind::Lit\n+    assert_eq!(stringify_pat!(1_000_i8), \"1_000_i8\");\n+\n+    // PatKind::Range\n+    assert_eq!(stringify_pat!(..1), \"..1\");\n+    assert_eq!(stringify_pat!(0..), \"0 ..\"); // FIXME\n+    assert_eq!(stringify_pat!(0..1), \"0 ..1\");\n+    assert_eq!(stringify_pat!(0..=1), \"0 ..=1\");\n+    assert_eq!(stringify_pat!(-2..=-1), \"-2 ..=-1\");\n+\n+    // PatKind::Slice\n+    assert_eq!(stringify_pat!([]), \"[]\");\n+    assert_eq!(stringify_pat!([true]), \"[true]\");\n+    assert_eq!(stringify_pat!([true,]), \"[true]\");\n+    assert_eq!(stringify_pat!([true, false]), \"[true, false]\");\n+\n+    // PatKind::Rest\n+    assert_eq!(stringify_pat!(..), \"..\");\n+\n+    // PatKind::Paren\n+    assert_eq!(stringify_pat!((pat)), \"(pat)\");\n+\n+    // PatKind::MacCall\n+    assert_eq!(stringify_pat!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_pat!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_pat!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_path() {\n+    assert_eq!(stringify_path!(thing), \"thing\");\n+    assert_eq!(stringify_path!(m::thing), \"m::thing\");\n+    assert_eq!(stringify_path!(self::thing), \"self::thing\");\n+    assert_eq!(stringify_path!(crate::thing), \"crate::thing\");\n+    assert_eq!(stringify_path!(Self::thing), \"Self::thing\");\n+    assert_eq!(stringify_path!(Self<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self::<'static>), \"Self<'static>\");\n+    assert_eq!(stringify_path!(Self()), \"Self()\");\n+    assert_eq!(stringify_path!(Self() -> ()), \"Self() -> ()\");\n+}\n+\n+#[test]\n+fn test_stmt() {\n+    // StmtKind::Local\n+    assert_eq!(stringify_stmt!(let _), \"let _;\");\n+    assert_eq!(stringify_stmt!(let x = true), \"let x = true;\");\n+    assert_eq!(stringify_stmt!(let x: bool = true), \"let x: bool = true;\");\n+\n+    // StmtKind::Item\n+    assert_eq!(\n+        stringify_stmt!(\n+            struct S;\n+        ),\n+        \"struct S;\",\n+    );\n+\n+    // StmtKind::Expr\n+    assert_eq!(stringify_stmt!(loop {}), \"loop {}\");\n+\n+    // StmtKind::Semi\n+    assert_eq!(stringify_stmt!(1 + 1), \"1 + 1;\");\n+\n+    // StmtKind::Empty\n+    assert_eq!(stringify_stmt!(;), \";\");\n+\n+    // StmtKind::MacCall\n+    assert_eq!(stringify_stmt!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_stmt!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_stmt!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_ty() {\n+    // TyKind::Slice\n+    assert_eq!(stringify_ty!([T]), \"[T]\");\n+\n+    // TyKind::Array\n+    assert_eq!(stringify_ty!([T; 0]), \"[T; 0]\");\n+\n+    // TyKind::Ptr\n+    assert_eq!(stringify_ty!(*const T), \"*const T\");\n+    assert_eq!(stringify_ty!(*mut T), \"*mut T\");\n+\n+    // TyKind::Rptr\n+    assert_eq!(stringify_ty!(&T), \"&T\");\n+    assert_eq!(stringify_ty!(&mut T), \"&mut T\");\n+    assert_eq!(stringify_ty!(&'a T), \"&'a T\");\n+    assert_eq!(stringify_ty!(&'a mut T), \"&'a mut T\");\n+\n+    // TyKind::BareFn\n+    assert_eq!(stringify_ty!(fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(fn() -> ()), \"fn() -> ()\");\n+    assert_eq!(stringify_ty!(fn(u8)), \"fn(u8)\");\n+    assert_eq!(stringify_ty!(fn(x: u8)), \"fn(x: u8)\");\n+    #[rustfmt::skip]\n+    assert_eq!(stringify_ty!(for<> fn()), \"fn()\");\n+    assert_eq!(stringify_ty!(for<'a> fn()), \"for<'a>fn()\"); // FIXME\n+\n+    // TyKind::Never\n+    assert_eq!(stringify_ty!(!), \"!\");\n+\n+    // TyKind::Tup\n+    assert_eq!(stringify_ty!(()), \"()\");\n+    assert_eq!(stringify_ty!((T,)), \"(T,)\");\n+    assert_eq!(stringify_ty!((T, U)), \"(T, U)\");\n+\n+    // TyKind::Path\n+    assert_eq!(stringify_ty!(T), \"T\");\n+    assert_eq!(stringify_ty!(Ref<'a>), \"Ref<'a>\");\n+    assert_eq!(stringify_ty!(PhantomData<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(PhantomData::<T>), \"PhantomData<T>\");\n+    assert_eq!(stringify_ty!(Fn() -> !), \"Fn() -> !\");\n+    assert_eq!(stringify_ty!(Fn(u8) -> !), \"Fn(u8) -> !\");\n+    assert_eq!(stringify_ty!(<Struct as Trait>::Type), \"<Struct as Trait>::Type\");\n+\n+    // TyKind::TraitObject\n+    assert_eq!(stringify_ty!(dyn Send), \"dyn Send\");\n+    assert_eq!(stringify_ty!(dyn Send + 'a), \"dyn Send + 'a\");\n+    assert_eq!(stringify_ty!(dyn 'a + Send), \"dyn 'a + Send\");\n+    assert_eq!(stringify_ty!(dyn ?Sized), \"dyn ?Sized\");\n+    assert_eq!(stringify_ty!(dyn ~const Clone), \"dyn Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(dyn for<'a> Send), \"dyn for<'a> Send\");\n+\n+    // TyKind::ImplTrait\n+    assert_eq!(stringify_ty!(impl Send), \"impl Send\");\n+    assert_eq!(stringify_ty!(impl Send + 'a), \"impl Send + 'a\");\n+    assert_eq!(stringify_ty!(impl 'a + Send), \"impl 'a + Send\");\n+    assert_eq!(stringify_ty!(impl ?Sized), \"impl ?Sized\");\n+    assert_eq!(stringify_ty!(impl ~const Clone), \"impl Clone\"); // FIXME\n+    assert_eq!(stringify_ty!(impl for<'a> Send), \"impl for<'a> Send\");\n+\n+    // TyKind::Paren\n+    assert_eq!(stringify_ty!((T)), \"(T)\");\n+\n+    // TyKind::Infer\n+    assert_eq!(stringify_ty!(_), \"_\");\n+\n+    // TyKind::MacCall\n+    assert_eq!(stringify_ty!(mac!(...)), \"mac!(...)\");\n+    assert_eq!(stringify_ty!(mac![...]), \"mac![...]\");\n+    assert_eq!(stringify_ty!(mac! { ... }), \"mac! { ... }\");\n+}\n+\n+#[test]\n+fn test_vis() {\n+    // VisibilityKind::Public\n+    assert_eq!(stringify_vis!(pub), \"pub \");\n+\n+    // VisibilityKind::Crate\n+    assert_eq!(stringify_vis!(crate), \"crate \");\n+\n+    // VisibilityKind::Restricted\n+    assert_eq!(stringify_vis!(pub(self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in self)), \"pub(self) \");\n+    assert_eq!(stringify_vis!(pub(in super)), \"pub(super) \");\n+    assert_eq!(stringify_vis!(pub(in path::to)), \"pub(in path::to) \");\n+    assert_eq!(stringify_vis!(pub(in ::path::to)), \"pub(in ::path::to) \");\n+    assert_eq!(stringify_vis!(pub(in self::path::to)), \"pub(in self::path::to) \");\n+    assert_eq!(stringify_vis!(pub(in super::path::to)), \"pub(in super::path::to) \");\n+\n+    // VisibilityKind::Inherited\n+    // Directly calling `stringify_vis!()` does not work.\n+    macro_rules! stringify_inherited_vis {\n+        ($vis:vis struct) => {\n+            stringify_vis!($vis)\n+        };\n+    }\n+    assert_eq!(stringify_inherited_vis!(struct), \"\");\n+}"}, {"sha": "68319187d63707fa36d7c215ed0e444e87d9652a", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=83b15bfe1c15f325bc186ebfe3691b729ed59f2b", "patch": "@@ -1 +1 @@\n-Subproject commit 0add6e95e58633fde2fff0bccaf6c7d71ebc130f\n+Subproject commit 68319187d63707fa36d7c215ed0e444e87d9652a"}]}