{"sha": "2b51384a2d6973b307ca126551fbe838cf7384d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNTEzODRhMmQ2OTczYjMwN2NhMTI2NTUxZmJlODM4Y2Y3Mzg0ZDA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-03T01:21:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-03T01:21:22Z"}, "message": "Rollup merge of #41705 - Mark-Simulacrum:remove-grammar, r=nikomatsakis\n\nRemove ANTLR grammar\n\nI *think* that nothing in-tree references this, but I may be wrong. If anyone thinks of anything, please let me know and I'll work on removing.\n\nFixes #15677.", "tree": {"sha": "f70e1f636aea8751ade9f6b5b4646601246d28e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f70e1f636aea8751ade9f6b5b4646601246d28e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b51384a2d6973b307ca126551fbe838cf7384d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b51384a2d6973b307ca126551fbe838cf7384d0", "html_url": "https://github.com/rust-lang/rust/commit/2b51384a2d6973b307ca126551fbe838cf7384d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b51384a2d6973b307ca126551fbe838cf7384d0/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4761639e83309060c2542aca68a619d0c938c3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4761639e83309060c2542aca68a619d0c938c3f", "html_url": "https://github.com/rust-lang/rust/commit/a4761639e83309060c2542aca68a619d0c938c3f"}, {"sha": "c3781e620084b2e2eba7e8a31b8248410ddca347", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3781e620084b2e2eba7e8a31b8248410ddca347", "html_url": "https://github.com/rust-lang/rust/commit/c3781e620084b2e2eba7e8a31b8248410ddca347"}], "stats": {"total": 4221, "additions": 0, "deletions": 4221}, "files": [{"sha": "e77db28967e336b9474caad94b3276cd4508d970", "filename": "src/grammar/.gitignore", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,4 +0,0 @@\n-verify\n-*.class\n-*.java\n-*.tokens"}, {"sha": "83808108ff8325900f506e66c67677f8aeea960f", "filename": "src/grammar/README.md", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FREADME.md?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,33 +0,0 @@\n-# Reference grammar.\n-\n-Uses [antlr4](http://www.antlr.org/) and a custom Rust tool to compare\n-ASTs/token streams generated. You can use the `make check-lexer` target to\n-run all of the available tests.\n-\n-The build of the rust part is included with `make tidy` and can be run with `make check-build-lexer-verifier`.\n-\n-# Manual build\n-\n-To use manually, assuming antlr4 is installed at `/usr/share/java/antlr-complete.jar`:\n-\n-```\n-antlr4 RustLexer.g4\n-javac -classpath /usr/share/java/antlr-complete.jar *.java\n-rustc -O verify.rs\n-for file in ../*/**.rs; do\n-    echo $file;\n-    grun RustLexer tokens -tokens < \"$file\" | ./verify \"$file\" RustLexer.tokens || break\n-done\n-```\n-\n-Note that the `../*/**.rs` glob will match every `*.rs` file in the above\n-directory and all of its recursive children. This is a Zsh extension.\n-\n-\n-## Cleanup\n-\n-To cleanup you can use a command like this:\n-\n-```bash\n-rm -f verify *.class *.java *.tokens\n-```"}, {"sha": "a63fc59e50b07145a92b4a0ef9aac1d511dd8478", "filename": "src/grammar/RustLexer.g4", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,197 +0,0 @@\n-lexer grammar RustLexer;\n-\n-@lexer::members {\n-  public boolean is_at(int pos) {\n-    return _input.index() == pos;\n-  }\n-}\n-\n-\n-tokens {\n-    EQ, LT, LE, EQEQ, NE, GE, GT, ANDAND, OROR, NOT, TILDE, PLUS,\n-    MINUS, STAR, SLASH, PERCENT, CARET, AND, OR, SHL, SHR, BINOP,\n-    BINOPEQ, LARROW, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n-    MOD_SEP, RARROW, FAT_ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET,\n-    LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR, LIT_BYTE,\n-    LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BYTE_STR,\n-    LIT_BYTE_STR_RAW, QUESTION, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n-    COMMENT, SHEBANG, UTF8_BOM\n-}\n-\n-import xidstart , xidcontinue;\n-\n-\n-/* Expression-operator symbols */\n-\n-EQ      : '=' ;\n-LT      : '<' ;\n-LE      : '<=' ;\n-EQEQ    : '==' ;\n-NE      : '!=' ;\n-GE      : '>=' ;\n-GT      : '>' ;\n-ANDAND  : '&&' ;\n-OROR    : '||' ;\n-NOT     : '!' ;\n-TILDE   : '~' ;\n-PLUS    : '+' ;\n-MINUS   : '-' ;\n-STAR    : '*' ;\n-SLASH   : '/' ;\n-PERCENT : '%' ;\n-CARET   : '^' ;\n-AND     : '&' ;\n-OR      : '|' ;\n-SHL     : '<<' ;\n-SHR     : '>>' ;\n-LARROW  : '<-' ;\n-\n-BINOP\n-    : PLUS\n-    | SLASH\n-    | MINUS\n-    | STAR\n-    | PERCENT\n-    | CARET\n-    | AND\n-    | OR\n-    | SHL\n-    | SHR\n-    | LARROW\n-    ;\n-\n-BINOPEQ : BINOP EQ ;\n-\n-/* \"Structural symbols\" */\n-\n-AT         : '@' ;\n-DOT        : '.' ;\n-DOTDOT     : '..' ;\n-DOTDOTDOT  : '...' ;\n-COMMA      : ',' ;\n-SEMI       : ';' ;\n-COLON      : ':' ;\n-MOD_SEP    : '::' ;\n-RARROW     : '->' ;\n-FAT_ARROW  : '=>' ;\n-LPAREN     : '(' ;\n-RPAREN     : ')' ;\n-LBRACKET   : '[' ;\n-RBRACKET   : ']' ;\n-LBRACE     : '{' ;\n-RBRACE     : '}' ;\n-POUND      : '#';\n-DOLLAR     : '$' ;\n-UNDERSCORE : '_' ;\n-\n-// Literals\n-\n-fragment HEXIT\n-  : [0-9a-fA-F]\n-  ;\n-\n-fragment CHAR_ESCAPE\n-  : [nrt\\\\'\"0]\n-  | [xX] HEXIT HEXIT\n-  | 'u' HEXIT HEXIT HEXIT HEXIT\n-  | 'U' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT\n-  | 'u{' HEXIT '}'\n-  | 'u{' HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT HEXIT '}'\n-  | 'u{' HEXIT HEXIT HEXIT HEXIT HEXIT HEXIT '}'\n-  ;\n-\n-fragment SUFFIX\n-  : IDENT\n-  ;\n-\n-fragment INTEGER_SUFFIX\n-  : { _input.LA(1) != 'e' && _input.LA(1) != 'E' }? SUFFIX\n-  ;\n-\n-LIT_CHAR\n-  : '\\'' ( '\\\\' CHAR_ESCAPE\n-         | ~[\\\\'\\n\\t\\r]\n-         | '\\ud800' .. '\\udbff' '\\udc00' .. '\\udfff'\n-         )\n-    '\\'' SUFFIX?\n-  ;\n-\n-LIT_BYTE\n-  : 'b\\'' ( '\\\\' ( [xX] HEXIT HEXIT\n-                 | [nrt\\\\'\"0] )\n-          | ~[\\\\'\\n\\t\\r] '\\udc00'..'\\udfff'?\n-          )\n-    '\\'' SUFFIX?\n-  ;\n-\n-LIT_INTEGER\n-\n-  : [0-9][0-9_]* INTEGER_SUFFIX?\n-  | '0b' [01_]+ INTEGER_SUFFIX?\n-  | '0o' [0-7_]+ INTEGER_SUFFIX?\n-  | '0x' [0-9a-fA-F_]+ INTEGER_SUFFIX?\n-  ;\n-\n-LIT_FLOAT\n-  : [0-9][0-9_]* ('.' {\n-        /* dot followed by another dot is a range, not a float */\n-        _input.LA(1) != '.' &&\n-        /* dot followed by an identifier is an integer with a function call, not a float */\n-        _input.LA(1) != '_' &&\n-        !(_input.LA(1) >= 'a' && _input.LA(1) <= 'z') &&\n-        !(_input.LA(1) >= 'A' && _input.LA(1) <= 'Z')\n-  }? | ('.' [0-9][0-9_]*)? ([eE] [-+]? [0-9][0-9_]*)? SUFFIX?)\n-  ;\n-\n-LIT_STR\n-  : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"' SUFFIX?\n-  ;\n-\n-LIT_BYTE_STR : 'b' LIT_STR ;\n-LIT_BYTE_STR_RAW : 'b' LIT_STR_RAW ;\n-\n-/* this is a bit messy */\n-\n-fragment LIT_STR_RAW_INNER\n-  : '\"' .*? '\"'\n-  | LIT_STR_RAW_INNER2\n-  ;\n-\n-fragment LIT_STR_RAW_INNER2\n-  : POUND LIT_STR_RAW_INNER POUND\n-  ;\n-\n-LIT_STR_RAW\n-  : 'r' LIT_STR_RAW_INNER SUFFIX?\n-  ;\n-\n-\n-QUESTION : '?';\n-\n-IDENT : XID_Start XID_Continue* ;\n-\n-fragment QUESTION_IDENTIFIER : QUESTION? IDENT;\n-\n-LIFETIME : '\\'' IDENT ;\n-\n-WHITESPACE : [ \\r\\n\\t]+ ;\n-\n-UNDOC_COMMENT     : '////' ~[\\n]* -> type(COMMENT) ;\n-YESDOC_COMMENT    : '///' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n-OUTER_DOC_COMMENT : '//!' ~[\\r\\n]* -> type(DOC_COMMENT) ;\n-LINE_COMMENT      : '//' ( ~[/\\n] ~[\\n]* )? -> type(COMMENT) ;\n-\n-DOC_BLOCK_COMMENT\n-  : ('/**' ~[*] | '/*!') (DOC_BLOCK_COMMENT | .)*? '*/' -> type(DOC_COMMENT)\n-  ;\n-\n-BLOCK_COMMENT : '/*' (BLOCK_COMMENT | .)*? '*/' -> type(COMMENT) ;\n-\n-/* these appear at the beginning of a file */\n-\n-SHEBANG : '#!' { is_at(2) && _input.LA(1) != '[' }? ~[\\r\\n]* -> type(SHEBANG) ;\n-\n-UTF8_BOM : '\\ufeff' { is_at(1) }? -> skip ;"}, {"sha": "70a8f6fca2e5c68c8fe6e043a2f76e4658e19b93", "filename": "src/grammar/check.sh", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fcheck.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fcheck.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fcheck.sh?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,52 +0,0 @@\n-#!/bin/sh\n-\n-# ignore-license\n-\n-# Run the reference lexer against libsyntax and compare the tokens and spans.\n-# If \"// ignore-lexer-test\" is present in the file, it will be ignored.\n-\n-\n-# Argument $1 is the file to check, $2 is the classpath to use, $3 is the path\n-# to the grun binary, $4 is the path to the verify binary, $5 is the path to\n-# RustLexer.tokens\n-if [ \"${VERBOSE}\" == \"1\" ]; then\n-    set -x\n-fi\n-\n-passed=0\n-failed=0\n-skipped=0\n-\n-check() {\n-    grep --silent \"// ignore-lexer-test\" \"$1\";\n-\n-    # if it is *not* found...\n-    if [ $? -eq 1 ]; then\n-        cd $2 # This `cd` is so java will pick up RustLexer.class. I could not\n-        # figure out how to wrangle the CLASSPATH, just adding build/grammar\n-        # did not seem to have any effect.\n-        if $3 RustLexer tokens -tokens < $1 | $4 $1 $5; then\n-            echo \"pass: $1\"\n-            passed=`expr $passed + 1`\n-        else\n-            echo \"fail: $1\"\n-            failed=`expr $failed + 1`\n-        fi\n-    else\n-        echo \"skip: $1\"\n-        skipped=`expr $skipped + 1`\n-    fi\n-}\n-\n-for file in $(find $1 -iname '*.rs' ! -path '*/test/compile-fail*'); do\n-    check \"$file\" $2 $3 $4 $5\n-done\n-\n-printf \"\\ntest result: \"\n-\n-if [ $failed -eq 0 ]; then\n-    printf \"ok. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n-else\n-    printf \"failed. $passed passed; $failed failed; $skipped skipped\\n\\n\"\n-    exit 1\n-fi"}, {"sha": "77737c99496f34757127d29e0040da0ff7f4fa56", "filename": "src/grammar/lexer.l", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,343 +0,0 @@\n-%{\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <ctype.h>\n-\n-static int num_hashes;\n-static int end_hashes;\n-static int saw_non_hash;\n-\n-%}\n-\n-%option stack\n-%option yylineno\n-\n-%x str\n-%x rawstr\n-%x rawstr_esc_begin\n-%x rawstr_esc_body\n-%x rawstr_esc_end\n-%x byte\n-%x bytestr\n-%x rawbytestr\n-%x rawbytestr_nohash\n-%x pound\n-%x shebang_or_attr\n-%x ltorchar\n-%x linecomment\n-%x doc_line\n-%x blockcomment\n-%x doc_block\n-%x suffix\n-\n-ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n-\n-%%\n-\n-<suffix>{ident}            { BEGIN(INITIAL); }\n-<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n-\n-[ \\n\\t\\r]             { }\n-\n-\\xef\\xbb\\xbf {\n-  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n-  if (yyget_lineno() != 1) {\n-    return -1;\n-  }\n-}\n-\n-\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n-<doc_line>\\n          { BEGIN(INITIAL);\n-                        yyleng--;\n-                        yytext[yyleng] = 0;\n-                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-                      }\n-<doc_line>[^\\n]*      { yymore(); }\n-\n-\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n-<linecomment>\\n       { BEGIN(INITIAL); }\n-<linecomment>[^\\n]*   { }\n-\n-\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n-<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n-<doc_block>\\*\\/       {\n-    yy_pop_state();\n-    if (yy_top_state() == doc_block) {\n-        yymore();\n-    } else {\n-        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n-    }\n-}\n-<doc_block>(.|\\n)     { yymore(); }\n-\n-\\/\\*                  { yy_push_state(blockcomment); }\n-<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n-<blockcomment>\\*\\/    { yy_pop_state(); }\n-<blockcomment>(.|\\n)   { }\n-\n-_        { return UNDERSCORE; }\n-as       { return AS; }\n-box      { return BOX; }\n-break    { return BREAK; }\n-const    { return CONST; }\n-continue { return CONTINUE; }\n-crate    { return CRATE; }\n-else     { return ELSE; }\n-enum     { return ENUM; }\n-extern   { return EXTERN; }\n-false    { return FALSE; }\n-fn       { return FN; }\n-for      { return FOR; }\n-if       { return IF; }\n-impl     { return IMPL; }\n-in       { return IN; }\n-let      { return LET; }\n-loop     { return LOOP; }\n-match    { return MATCH; }\n-mod      { return MOD; }\n-move     { return MOVE; }\n-mut      { return MUT; }\n-priv     { return PRIV; }\n-proc     { return PROC; }\n-pub      { return PUB; }\n-ref      { return REF; }\n-return   { return RETURN; }\n-self     { return SELF; }\n-static   { return STATIC; }\n-struct   { return STRUCT; }\n-trait    { return TRAIT; }\n-true     { return TRUE; }\n-type     { return TYPE; }\n-typeof   { return TYPEOF; }\n-unsafe   { return UNSAFE; }\n-use      { return USE; }\n-where    { return WHERE; }\n-while    { return WHILE; }\n-\n-{ident}  { return IDENT; }\n-\n-0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n-0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n-0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n-[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n-\n-[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n-[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n-\n-;      { return ';'; }\n-,      { return ','; }\n-\\.\\.\\. { return DOTDOTDOT; }\n-\\.\\.   { return DOTDOT; }\n-\\.     { return '.'; }\n-\\(     { return '('; }\n-\\)     { return ')'; }\n-\\{     { return '{'; }\n-\\}     { return '}'; }\n-\\[     { return '['; }\n-\\]     { return ']'; }\n-@      { return '@'; }\n-#      { BEGIN(pound); yymore(); }\n-<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n-<shebang_or_attr>\\[ {\n-  BEGIN(INITIAL);\n-  yyless(2);\n-  return SHEBANG;\n-}\n-<shebang_or_attr>[^\\[\\n]*\\n {\n-  // Since the \\n was eaten as part of the token, yylineno will have\n-  // been incremented to the value 2 if the shebang was on the first\n-  // line. This yyless undoes that, setting yylineno back to 1.\n-  yyless(yyleng - 1);\n-  if (yyget_lineno() == 1) {\n-    BEGIN(INITIAL);\n-    return SHEBANG_LINE;\n-  } else {\n-    BEGIN(INITIAL);\n-    yyless(2);\n-    return SHEBANG;\n-  }\n-}\n-<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n-\n-\\~     { return '~'; }\n-::     { return MOD_SEP; }\n-:      { return ':'; }\n-\\$     { return '$'; }\n-\\?     { return '?'; }\n-\n-==    { return EQEQ; }\n-=>    { return FAT_ARROW; }\n-=     { return '='; }\n-\\!=   { return NE; }\n-\\!    { return '!'; }\n-\\<=   { return LE; }\n-\\<\\<  { return SHL; }\n-\\<\\<= { return SHLEQ; }\n-\\<    { return '<'; }\n-\\>=   { return GE; }\n-\\>\\>  { return SHR; }\n-\\>\\>= { return SHREQ; }\n-\\>    { return '>'; }\n-\n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n-\n-b\\x22              { BEGIN(bytestr); yymore(); }\n-<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n-\n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n-\n-br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n-<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n-<rawbytestr_nohash>(.|\\n)   { yymore(); }\n-<rawbytestr_nohash><<EOF>>  { return -1; }\n-\n-br/# {\n-    BEGIN(rawbytestr);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-<rawbytestr># {\n-    if (!saw_non_hash) {\n-        num_hashes++;\n-    } else if (end_hashes != 0) {\n-        end_hashes++;\n-        if (end_hashes == num_hashes) {\n-            BEGIN(INITIAL);\n-            return LIT_BYTE_STR_RAW;\n-        }\n-    }\n-    yymore();\n-}\n-<rawbytestr>\\x22# {\n-    end_hashes = 1;\n-    if (end_hashes == num_hashes) {\n-        BEGIN(INITIAL);\n-        return LIT_BYTE_STR_RAW;\n-    }\n-    yymore();\n-}\n-<rawbytestr>(.|\\n) {\n-    if (!saw_non_hash) {\n-        saw_non_hash = 1;\n-    }\n-    if (end_hashes != 0) {\n-        end_hashes = 0;\n-    }\n-    yymore();\n-}\n-<rawbytestr><<EOF>> { return -1; }\n-\n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n-\n-r\\x22           { BEGIN(rawstr); yymore(); }\n-<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n-<rawstr>(.|\\n)  { yymore(); }\n-<rawstr><<EOF>> { return -1; }\n-\n-r/#             {\n-    BEGIN(rawstr_esc_begin);\n-    yymore();\n-    num_hashes = 0;\n-    saw_non_hash = 0;\n-    end_hashes = 0;\n-}\n-\n-<rawstr_esc_begin># {\n-    num_hashes++;\n-    yymore();\n-}\n-<rawstr_esc_begin>\\x22 {\n-    BEGIN(rawstr_esc_body);\n-    yymore();\n-}\n-<rawstr_esc_begin>(.|\\n) { return -1; }\n-\n-<rawstr_esc_body>\\x22/# {\n-  BEGIN(rawstr_esc_end);\n-  yymore();\n- }\n-<rawstr_esc_body>(.|\\n) {\n-  yymore();\n- }\n-\n-<rawstr_esc_end># {\n-  end_hashes++;\n-  if (end_hashes == num_hashes) {\n-    BEGIN(INITIAL);\n-    return LIT_STR_RAW;\n-  }\n-  yymore();\n- }\n-<rawstr_esc_end>[^#] {\n-  end_hashes = 0;\n-  BEGIN(rawstr_esc_body);\n-  yymore();\n- }\n-\n-<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n-\n-\\x22                     { BEGIN(str); yymore(); }\n-<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n-\n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n-\n-\\<-  { return LARROW; }\n--\\>  { return RARROW; }\n--    { return '-'; }\n--=   { return MINUSEQ; }\n-&&   { return ANDAND; }\n-&    { return '&'; }\n-&=   { return ANDEQ; }\n-\\|\\| { return OROR; }\n-\\|   { return '|'; }\n-\\|=  { return OREQ; }\n-\\+   { return '+'; }\n-\\+=  { return PLUSEQ; }\n-\\*   { return '*'; }\n-\\*=  { return STAREQ; }\n-\\/   { return '/'; }\n-\\/=  { return SLASHEQ; }\n-\\^   { return '^'; }\n-\\^=  { return CARETEQ; }\n-%    { return '%'; }\n-%=   { return PERCENTEQ; }\n-\n-<<EOF>> { return 0; }\n-\n-%%"}, {"sha": "db88a1f2999aa56a8fdac9d26472e20c3b9c824f", "filename": "src/grammar/parser-lalr-main.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,203 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern int yylex();\n-extern int rsparse();\n-\n-#define PUSHBACK_LEN 4\n-\n-static char pushback[PUSHBACK_LEN];\n-static int verbose;\n-\n-void print(const char* format, ...) {\n-  va_list args;\n-  va_start(args, format);\n-  if (verbose) {\n-    vprintf(format, args);\n-  }\n-  va_end(args);\n-}\n-\n-// If there is a non-null char at the head of the pushback queue,\n-// dequeue it and shift the rest of the queue forwards. Otherwise,\n-// return the token from calling yylex.\n-int rslex() {\n-  if (pushback[0] == '\\0') {\n-    return yylex();\n-  } else {\n-    char c = pushback[0];\n-    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n-    pushback[PUSHBACK_LEN - 1] = '\\0';\n-    return c;\n-  }\n-}\n-\n-// Note: this does nothing if the pushback queue is full. As long as\n-// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n-// in an action, this shouldn't be a problem.\n-void push_back(char c) {\n-  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n-    if (pushback[i] == '\\0') {\n-      pushback[i] = c;\n-      break;\n-    }\n-  }\n-}\n-\n-extern int rsdebug;\n-\n-struct node {\n-  struct node *next;\n-  struct node *prev;\n-  int own_string;\n-  char const *name;\n-  int n_elems;\n-  struct node *elems[];\n-};\n-\n-struct node *nodes = NULL;\n-int n_nodes;\n-\n-struct node *mk_node(char const *name, int n, ...) {\n-  va_list ap;\n-  int i = 0;\n-  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n-  struct node *nn, *nd = (struct node *)malloc(sz);\n-\n-  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n-\n-  nd->own_string = 0;\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  if (nodes) {\n-    nodes->prev = nd;\n-  }\n-  nodes = nd;\n-\n-  nd->name = name;\n-  nd->n_elems = n;\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[i++] = nn;\n-  }\n-  va_end(ap);\n-  n_nodes++;\n-  return nd;\n-}\n-\n-struct node *mk_atom(char *name) {\n-  struct node *nd = mk_node((char const *)strdup(name), 0);\n-  nd->own_string = 1;\n-  return nd;\n-}\n-\n-struct node *mk_none() {\n-  return mk_atom(\"<none>\");\n-}\n-\n-struct node *ext_node(struct node *nd, int n, ...) {\n-  va_list ap;\n-  int i = 0, c = nd->n_elems + n;\n-  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n-  struct node *nn;\n-\n-  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n-        nd->n_elems, c, nd->name, nd);\n-\n-  if (nd->next) {\n-    nd->next->prev = nd->prev;\n-  }\n-  if (nd->prev) {\n-    nd->prev->next = nd->next;\n-  }\n-  nd = realloc(nd, sz);\n-  nd->prev = NULL;\n-  nd->next = nodes;\n-  nodes->prev = nd;\n-  nodes = nd;\n-\n-  print(\" ==> %p\\n\", nd);\n-\n-  va_start(ap, n);\n-  while (i < n) {\n-    nn = va_arg(ap, struct node *);\n-    print(\"#   arg[%d]: %p\\n\", i, nn);\n-    print(\"#            (%s ...)\\n\", nn->name);\n-    nd->elems[nd->n_elems++] = nn;\n-    ++i;\n-  }\n-  va_end(ap);\n-  return nd;\n-}\n-\n-int const indent_step = 4;\n-\n-void print_indent(int depth) {\n-  while (depth) {\n-    if (depth-- % indent_step == 0) {\n-      print(\"|\");\n-    } else {\n-      print(\" \");\n-    }\n-  }\n-}\n-\n-void print_node(struct node *n, int depth) {\n-  int i = 0;\n-  print_indent(depth);\n-  if (n->n_elems == 0) {\n-    print(\"%s\\n\", n->name);\n-  } else {\n-    print(\"(%s\\n\", n->name);\n-    for (i = 0; i < n->n_elems; ++i) {\n-      print_node(n->elems[i], depth + indent_step);\n-    }\n-    print_indent(depth);\n-    print(\")\\n\");\n-  }\n-}\n-\n-int main(int argc, char **argv) {\n-  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n-    verbose = 1;\n-  } else {\n-    verbose = 0;\n-  }\n-  int ret = 0;\n-  struct node *tmp;\n-  memset(pushback, '\\0', PUSHBACK_LEN);\n-  ret = rsparse();\n-  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n-  if (nodes) {\n-    print_node(nodes, 0);\n-  }\n-  while (nodes) {\n-    tmp = nodes;\n-    nodes = tmp->next;\n-    if (tmp->own_string) {\n-      free((void*)tmp->name);\n-    }\n-    free(tmp);\n-  }\n-  return ret;\n-}\n-\n-void rserror(char const *s) {\n-  fprintf(stderr, \"%s\\n\", s);\n-}"}, {"sha": "c9fcdf7647b9cfa79e42164ca858d728a7685dd7", "filename": "src/grammar/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1945, "changes": 1945, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,1945 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-%{\n-#define YYERROR_VERBOSE\n-#define YYSTYPE struct node *\n-struct node;\n-extern int yylex();\n-extern void yyerror(char const *s);\n-extern struct node *mk_node(char const *name, int n, ...);\n-extern struct node *mk_atom(char *text);\n-extern struct node *mk_none();\n-extern struct node *ext_node(struct node *nd, int n, ...);\n-extern void push_back(char c);\n-extern char *yytext;\n-%}\n-%debug\n-\n-%token SHL\n-%token SHR\n-%token LE\n-%token EQEQ\n-%token NE\n-%token GE\n-%token ANDAND\n-%token OROR\n-%token SHLEQ\n-%token SHREQ\n-%token MINUSEQ\n-%token ANDEQ\n-%token OREQ\n-%token PLUSEQ\n-%token STAREQ\n-%token SLASHEQ\n-%token CARETEQ\n-%token PERCENTEQ\n-%token DOTDOT\n-%token DOTDOTDOT\n-%token MOD_SEP\n-%token RARROW\n-%token LARROW\n-%token FAT_ARROW\n-%token LIT_BYTE\n-%token LIT_CHAR\n-%token LIT_INTEGER\n-%token LIT_FLOAT\n-%token LIT_STR\n-%token LIT_STR_RAW\n-%token LIT_BYTE_STR\n-%token LIT_BYTE_STR_RAW\n-%token IDENT\n-%token UNDERSCORE\n-%token LIFETIME\n-\n-// keywords\n-%token SELF\n-%token STATIC\n-%token AS\n-%token BREAK\n-%token CRATE\n-%token ELSE\n-%token ENUM\n-%token EXTERN\n-%token FALSE\n-%token FN\n-%token FOR\n-%token IF\n-%token IMPL\n-%token IN\n-%token LET\n-%token LOOP\n-%token MATCH\n-%token MOD\n-%token MOVE\n-%token MUT\n-%token PRIV\n-%token PUB\n-%token REF\n-%token RETURN\n-%token STRUCT\n-%token TRUE\n-%token TRAIT\n-%token TYPE\n-%token UNSAFE\n-%token DEFAULT\n-%token USE\n-%token WHILE\n-%token CONTINUE\n-%token PROC\n-%token BOX\n-%token CONST\n-%token WHERE\n-%token TYPEOF\n-%token INNER_DOC_COMMENT\n-%token OUTER_DOC_COMMENT\n-\n-%token SHEBANG\n-%token SHEBANG_LINE\n-%token STATIC_LIFETIME\n-\n- /*\n-   Quoting from the Bison manual:\n-\n-   \"Finally, the resolution of conflicts works by comparing the precedence\n-   of the rule being considered with that of the lookahead token. If the\n-   token's precedence is higher, the choice is to shift. If the rule's\n-   precedence is higher, the choice is to reduce. If they have equal\n-   precedence, the choice is made based on the associativity of that\n-   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n-   Bison) says how each conflict was resolved\"\n- */\n-\n-// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n-// all potential ambiguities are scrutinized and eliminated manually.\n-%expect 0\n-\n-// fake-precedence symbol to cause '|' bars in lambda context to parse\n-// at low precedence, permit things like |x| foo = bar, where '=' is\n-// otherwise lower-precedence than '|'. Also used for proc() to cause\n-// things like proc() a + b to parse as proc() { a + b }.\n-%precedence LAMBDA\n-\n-%precedence SELF\n-\n-// MUT should be lower precedence than IDENT so that in the pat rule,\n-// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n-%precedence MUT\n-\n-// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n-// trying to decide if we've got a struct-construction expr (esp. in\n-// contexts like 'if foo { .')\n-//\n-// IDENT also needs to be lower precedence than '<' so that '<' in\n-// 'foo:bar . <' is shifted (in a trait reference occurring in a\n-// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n-%precedence IDENT\n-\n-// A couple fake-precedence symbols to use in rules associated with +\n-// and < in trailing type contexts. These come up when you have a type\n-// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n-// has to be shifted so the parser keeps trying to parse a type, even\n-// though it might well consider reducing the type \"bar\" and then\n-// going on to \"<\" as a subsequent binop. The \"+\" case is with\n-// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n-%precedence SHIFTPLUS\n-\n-%precedence MOD_SEP\n-%precedence RARROW ':'\n-\n-// In where clauses, \"for\" should have greater precedence when used as\n-// a higher ranked constraint than when used as the beginning of a\n-// for_in_type (which is a ty)\n-%precedence FORTYPE\n-%precedence FOR\n-\n-// Binops & unops, and their precedences\n-%precedence BOX\n-%precedence BOXPLACE\n-%nonassoc DOTDOT\n-\n-// RETURN needs to be lower-precedence than tokens that start\n-// prefix_exprs\n-%precedence RETURN\n-\n-%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n-%right LARROW\n-%left OROR\n-%left ANDAND\n-%left EQEQ NE\n-%left '<' '>' LE GE\n-%left '|'\n-%left '^'\n-%left '&'\n-%left SHL SHR\n-%left '+' '-'\n-%precedence AS\n-%left '*' '/' '%'\n-%precedence '!'\n-\n-%precedence '{' '[' '(' '.'\n-\n-%precedence RANGE\n-\n-%start crate\n-\n-%%\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 1: Items and attributes\n-////////////////////////////////////////////////////////////////////////\n-\n-crate\n-: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n-| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n-;\n-\n-maybe_shebang\n-: SHEBANG_LINE\n-| %empty\n-;\n-\n-maybe_inner_attrs\n-: inner_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-inner_attrs\n-: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n-| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-inner_attr\n-: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n-| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n-;\n-\n-maybe_outer_attrs\n-: outer_attrs\n-| %empty                   { $$ = mk_none(); }\n-;\n-\n-outer_attrs\n-: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n-| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-outer_attr\n-: '#' '[' meta_item ']'    { $$ = $3; }\n-| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n-;\n-\n-meta_item\n-: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n-| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n-| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n-;\n-\n-meta_seq\n-: %empty                   { $$ = mk_none(); }\n-| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n-| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_mod_items\n-: mod_items\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-mod_items\n-: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n-| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-attrs_and_vis\n-: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n-;\n-\n-mod_item\n-: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n-;\n-\n-// items that can appear outside of a fn block\n-item\n-: stmt_item\n-| item_macro\n-;\n-\n-// items that can appear in \"stmts\"\n-stmt_item\n-: item_static\n-| item_const\n-| item_type\n-| block_item\n-| view_item\n-;\n-\n-item_static\n-: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n-| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n-;\n-\n-item_const\n-: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n-;\n-\n-item_macro\n-: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n-;\n-\n-view_item\n-: use_item\n-| extern_fn_item\n-| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n-| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n-;\n-\n-extern_fn_item\n-: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n-;\n-\n-use_item\n-: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n-;\n-\n-view_path\n-: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n-| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n-|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n-|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n-| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n-|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n-|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n-| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n-;\n-\n-block_item\n-: item_fn\n-| item_unsafe_fn\n-| item_mod\n-| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n-| item_struct\n-| item_enum\n-| item_trait\n-| item_impl\n-;\n-\n-maybe_ty_ascription\n-: ':' ty_sum { $$ = $2; }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_init_expr\n-: '=' expr { $$ = $2; }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-// structs\n-item_struct\n-: STRUCT ident generic_params maybe_where_clause struct_decl_args\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n-}\n-| STRUCT ident generic_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n-}\n-;\n-\n-struct_decl_args\n-: '{' struct_decl_fields '}'                  { $$ = $2; }\n-| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n-;\n-\n-struct_tuple_args\n-: '(' struct_tuple_fields ')'                 { $$ = $2; }\n-| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n-;\n-\n-struct_decl_fields\n-: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n-| %empty                                      { $$ = mk_none(); }\n-;\n-\n-struct_decl_field\n-: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n-;\n-\n-struct_tuple_fields\n-: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n-| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-struct_tuple_field\n-: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n-;\n-\n-// enums\n-item_enum\n-: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n-| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n-;\n-\n-enum_defs\n-: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n-| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n-| %empty                 { $$ = mk_none(); }\n-;\n-\n-enum_def\n-: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n-;\n-\n-enum_args\n-: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n-| %empty                         { $$ = mk_none(); }\n-;\n-\n-item_mod\n-: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n-| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n-| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n-;\n-\n-item_foreign_mod\n-: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n-| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n-;\n-\n-maybe_abi\n-: str\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_foreign_items\n-: foreign_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-foreign_items\n-: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n-| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n-;\n-\n-foreign_item\n-: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n-| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n-;\n-\n-item_foreign_static\n-: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n-;\n-\n-item_foreign_fn\n-: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n-;\n-\n-fn_decl_allow_variadic\n-: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params_allow_variadic\n-: '(' ')'                      { $$ = mk_none(); }\n-| '(' params ')'               { $$ = $2; }\n-| '(' params ',' ')'           { $$ = $2; }\n-| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n-;\n-\n-visibility\n-: PUB      { $$ = mk_atom(\"Public\"); }\n-| %empty   { $$ = mk_atom(\"Inherited\"); }\n-;\n-\n-idents_or_self\n-: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n-| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ident_or_self\n-: ident\n-| SELF  { $$ = mk_atom(yytext); }\n-;\n-\n-item_type\n-: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n-;\n-\n-for_sized\n-: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n-| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n-| %empty        { $$ = mk_none(); }\n-;\n-\n-item_trait\n-: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n-{\n-  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n-}\n-;\n-\n-maybe_trait_items\n-: trait_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-trait_items\n-: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n-| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n-;\n-\n-trait_item\n-: trait_const\n-| trait_type\n-| trait_method\n-;\n-\n-trait_const\n-: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_const_default\n-: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n-| %empty   { $$ = mk_none(); }\n-;\n-\n-trait_type\n-: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n-;\n-\n-maybe_unsafe\n-: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_default_maybe_unsafe\n-: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n-| DEFAULT        { $$ = mk_atom(\"Default\"); }\n-|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n-| %empty { $$ = mk_none(); }\n-\n-trait_method\n-: type_method { $$ = mk_node(\"Required\", 1, $1); }\n-| method      { $$ = mk_node(\"Provided\", 1, $1); }\n-;\n-\n-type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n-{\n-  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n-}\n-;\n-\n-method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n-}\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n-}\n-;\n-\n-// There are two forms of impl:\n-//\n-// impl (<...>)? TY { ... }\n-// impl (<...>)? TRAIT for TY { ... }\n-//\n-// Unfortunately since TY can begin with '<' itself -- as part of a\n-// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n-// should we reduce one of the early rules of TY (such as maybe_once)\n-// or shall we continue shifting into the generic_params list for the\n-// impl?\n-//\n-// The production parser disambiguates a different case here by\n-// permitting / requiring the user to provide parens around types when\n-// they are ambiguous with traits. We do the same here, regrettably,\n-// by splitting ty into ty and ty_prim.\n-item_impl\n-: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n-{\n-  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n-}\n-| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n-{\n-  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n-}\n-;\n-\n-maybe_impl_items\n-: impl_items\n-| %empty { $$ = mk_none(); }\n-;\n-\n-impl_items\n-: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n-| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n-;\n-\n-impl_item\n-: impl_method\n-| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n-| impl_const\n-| impl_type\n-;\n-\n-impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n-;\n-\n-impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n-;\n-\n-item_fn\n-: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n-}\n-;\n-\n-item_unsafe_fn\n-: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n-}\n-| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n-{\n-  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n-}\n-;\n-\n-fn_decl\n-: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self\n-: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_decl_with_self_allow_anon_params\n-: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n-;\n-\n-fn_params\n-: '(' maybe_params ')'  { $$ = $2; }\n-;\n-\n-fn_anon_params\n-: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n-| '(' ')'                                            { $$ = mk_none(); }\n-;\n-\n-fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n-| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n-| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n-| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n-;\n-\n-maybe_params\n-: params\n-| params ','\n-| %empty  { $$ = mk_none(); }\n-;\n-\n-params\n-: param                { $$ = mk_node(\"Args\", 1, $1); }\n-| params ',' param     { $$ = ext_node($1, 1, $3); }\n-;\n-\n-param\n-: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-;\n-\n-inferrable_params\n-: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n-| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-inferrable_param\n-: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n-;\n-\n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n-maybe_comma_params\n-: ','            { $$ = mk_none(); }\n-| ',' params     { $$ = $2; }\n-| ',' params ',' { $$ = $2; }\n-| %empty         { $$ = mk_none(); }\n-;\n-\n-maybe_comma_anon_params\n-: ','                 { $$ = mk_none(); }\n-| ',' anon_params     { $$ = $2; }\n-| ',' anon_params ',' { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-maybe_anon_params\n-: anon_params\n-| anon_params ','\n-| %empty      { $$ = mk_none(); }\n-;\n-\n-anon_params\n-: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n-| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// anon means it's allowed to be anonymous (type-only), but it can\n-// still have a name\n-anon_param\n-: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n-| ty\n-;\n-\n-anon_params_allow_variadic_tail\n-: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n-| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n-| %empty                                         { $$ = mk_none(); }\n-;\n-\n-named_arg\n-: ident\n-| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n-| '&' ident         { $$ = $2; }\n-| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n-| ANDAND ident      { $$ = $2; }\n-| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n-| MUT ident         { $$ = $2; }\n-;\n-\n-ret_ty\n-: RARROW '!'         { $$ = mk_none(); }\n-| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n-| %prec IDENT %empty { $$ = mk_none(); }\n-;\n-\n-generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n-| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n-| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n-| %empty                              { $$ = mk_none(); }\n-;\n-\n-maybe_where_clause\n-: %empty                              { $$ = mk_none(); }\n-| where_clause\n-;\n-\n-where_clause\n-: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n-| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n-;\n-\n-where_predicates\n-: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n-| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n-;\n-\n-where_predicate\n-: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n-;\n-\n-maybe_for_lifetimes\n-: FOR '<' lifetimes '>' { $$ = mk_none(); }\n-| %prec FORTYPE %empty  { $$ = mk_none(); }\n-\n-ty_params\n-: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n-| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with no type parameters; e.g. `foo::bar::Baz`\n-//\n-// These show up in 'use' view-items, because these are processed\n-// without respect to types.\n-path_no_types_allowed\n-: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n-| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n-| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n-| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters, with no double colons\n-// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n-//\n-// These show up in \"trait references\", the components of\n-// type-parameter bounds lists, as well as in the prefix of the\n-// path_generic_args_and_bounds rule, which is the full form of a\n-// named typed expression.\n-//\n-// They do not have (nor need) an extra '::' before '<' because\n-// unlike in expr context, there are no \"less-than\" type exprs to\n-// be ambiguous with.\n-path_generic_args_without_colons\n-: %prec IDENT\n-  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n-| %prec IDENT\n-  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n-| %prec IDENT\n-  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n-| %prec IDENT\n-  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n-;\n-\n-generic_args\n-: '<' generic_values '>'   { $$ = $2; }\n-| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n-| '<' generic_values GE    { push_back('='); $$ = $2; }\n-| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-// If generic_args starts with \"<<\", the first arg must be a\n-// TyQualifiedPath because that's the only type that can start with a\n-// '<'. This rule parses that as the first ty_sum and then continues\n-// with the rest of generic_values.\n-| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n-| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n-;\n-\n-generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n-;\n-\n-maybe_ty_sums_and_or_bindings\n-: ty_sums\n-| ty_sums ','\n-| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n-| bindings\n-| bindings ','\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_bindings\n-: ',' bindings { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 2: Patterns\n-////////////////////////////////////////////////////////////////////////\n-\n-pat\n-: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n-| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n-| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n-| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n-| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n-| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n-| lit_or_path\n-| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n-| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n-| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n-| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n-| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n-|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n-| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n-| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-;\n-\n-pats_or\n-: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n-| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding_mode\n-: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n-| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n-| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n-;\n-\n-lit_or_path\n-: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n-| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n-| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n-;\n-\n-pat_field\n-:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n-|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n-| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n-| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n-|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n-| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n-;\n-\n-pat_fields\n-: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n-| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_struct\n-: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n-| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n-| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n-;\n-\n-pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-pat_vec\n-: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n-|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n-|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n-;\n-\n-pat_vec_elts\n-: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n-| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 3: Types\n-////////////////////////////////////////////////////////////////////////\n-\n-ty\n-: ty_prim\n-| ty_closure\n-| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n-| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n-| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n-;\n-\n-ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n-| ty_bare_fn\n-| ty_proc\n-| for_in_type\n-;\n-\n-ty_bare_fn\n-:                         FN ty_fn_decl { $$ = $2; }\n-| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n-|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n-| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n-;\n-\n-ty_fn_decl\n-: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n-;\n-\n-ty_closure\n-: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n-|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n-| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n-|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n-;\n-\n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n-for_in_type\n-: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n-;\n-\n-for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n-| trait_ref\n-| ty_closure\n-;\n-\n-maybe_mut\n-: MUT              { $$ = mk_atom(\"MutMutable\"); }\n-| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-maybe_mut_or_const\n-: MUT    { $$ = mk_atom(\"MutMutable\"); }\n-| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n-| %empty { $$ = mk_atom(\"MutImmutable\"); }\n-;\n-\n-ty_qualified_path_and_generic_values\n-: ty_qualified_path maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n-}\n-| ty_qualified_path ',' ty_sums maybe_bindings\n-{\n-  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n-}\n-;\n-\n-ty_qualified_path\n-: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n-;\n-\n-maybe_ty_sums\n-: ty_sums\n-| ty_sums ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-ty_sums\n-: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n-| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n-;\n-\n-ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n-;\n-\n-ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n-;\n-\n-maybe_ty_param_bounds\n-: ':' ty_param_bounds { $$ = $2; }\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-ty_param_bounds\n-: boundseq\n-| %empty { $$ = mk_none(); }\n-;\n-\n-boundseq\n-: polybound\n-| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-polybound\n-: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n-| bound\n-| '?' bound { $$ = $2; }\n-;\n-\n-bindings\n-: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n-| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n-;\n-\n-binding\n-: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n-;\n-\n-ty_param\n-: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n-| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n-;\n-\n-maybe_bounds\n-: %prec SHIFTPLUS\n-  ':' bounds             { $$ = $2; }\n-| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n-;\n-\n-bounds\n-: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n-| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n-;\n-\n-bound\n-: lifetime\n-| trait_ref\n-;\n-\n-maybe_ltbounds\n-: %prec SHIFTPLUS\n-  ':' ltbounds       { $$ = $2; }\n-| %empty             { $$ = mk_none(); }\n-;\n-\n-ltbounds\n-: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n-| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n-;\n-\n-maybe_ty_default\n-: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n-| %empty     { $$ = mk_none(); }\n-;\n-\n-maybe_lifetimes\n-: lifetimes\n-| lifetimes ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-lifetimes\n-: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n-| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n-;\n-\n-lifetime_and_bounds\n-: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n-| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-lifetime\n-: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n-| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n-;\n-\n-trait_ref\n-: %prec IDENT path_generic_args_without_colons\n-| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 4: Blocks, statements, and expressions\n-////////////////////////////////////////////////////////////////////////\n-\n-inner_attrs_and_block\n-: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n-;\n-\n-block\n-: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n-;\n-\n-maybe_stmts\n-: stmts\n-| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n-| nonblock_expr\n-| %empty              { $$ = mk_none(); }\n-;\n-\n-// There are two sub-grammars within a \"stmts: exprs\" derivation\n-// depending on whether each stmt-expr is a block-expr form; this is to\n-// handle the \"semicolon rule\" for stmt sequencing that permits\n-// writing\n-//\n-//     if foo { bar } 10\n-//\n-// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n-// stmt). Unfortunately by permitting juxtaposition of exprs in\n-// sequence like that, the non-block expr grammar has to have a\n-// second limited sub-grammar that excludes the prefix exprs that\n-// are ambiguous with binops. That is to say:\n-//\n-//     {10} - 1\n-//\n-// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n-// is to say, two statements rather than one, at least according to\n-// the mainline rust parser.\n-//\n-// So we wind up with a 3-way split in exprs that occur in stmt lists:\n-// block, nonblock-prefix, and nonblock-nonprefix.\n-//\n-// In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n-\n-stmts\n-: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n-| stmts stmt     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-stmt\n-: let\n-|                 stmt_item\n-|             PUB stmt_item { $$ = $2; }\n-| outer_attrs     stmt_item { $$ = $2; }\n-| outer_attrs PUB stmt_item { $$ = $3; }\n-| full_block_expr\n-| block\n-| nonblock_expr ';'\n-| ';'                   { $$ = mk_none(); }\n-;\n-\n-maybe_exprs\n-: exprs\n-| exprs ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-maybe_expr\n-: expr\n-| %empty { $$ = mk_none(); }\n-;\n-\n-exprs\n-: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n-| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n-;\n-\n-path_expr\n-: path_generic_args_with_colons\n-| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n-| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n-;\n-\n-// A path with a lifetime and type parameters with double colons before\n-// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n-//\n-// These show up in expr context, in order to disambiguate from \"less-than\"\n-// expressions.\n-path_generic_args_with_colons\n-: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n-| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n-| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n-;\n-\n-// the braces-delimited macro is a block_expr so it doesn't appear here\n-macro_expr\n-: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n-;\n-\n-nonblock_expr\n-: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| nonblock_prefix_expr\n-;\n-\n-expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-expr_nostruct\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr_nostruct\n-;\n-\n-nonblock_prefix_expr_nostruct\n-: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr_nostruct\n-| MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n-;\n-\n-nonblock_prefix_expr\n-: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n-| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n-| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n-| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n-| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n-| lambda_expr\n-| MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n-;\n-\n-expr_qualified_path\n-: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n-}\n-| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n-{\n-  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n-}\n-\n-maybe_qpath_params\n-: MOD_SEP generic_args { $$ = $2; }\n-| %empty               { $$ = mk_none(); }\n-;\n-\n-maybe_as_trait_ref\n-: AS trait_ref { $$ = $2; }\n-| %empty       { $$ = mk_none(); }\n-;\n-\n-lambda_expr\n-: %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n-| %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n-;\n-\n-lambda_expr_nostruct\n-: %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n-| %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n-;\n-\n-proc_expr\n-: %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n-;\n-\n-proc_expr_nostruct\n-: %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n-| %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n-;\n-\n-vec_expr\n-: maybe_exprs\n-| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n-;\n-\n-struct_expr_fields\n-: field_inits\n-| field_inits ','\n-| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n-;\n-\n-maybe_field_inits\n-: field_inits\n-| field_inits ','\n-| %empty { $$ = mk_none(); }\n-;\n-\n-field_inits\n-: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n-| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n-;\n-\n-field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n-;\n-\n-default_field_init\n-: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n-;\n-\n-block_expr\n-: expr_match\n-| expr_if\n-| expr_if_let\n-| expr_while\n-| expr_while_let\n-| expr_loop\n-| expr_for\n-| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n-| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n-;\n-\n-full_block_expr\n-: block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-;\n-\n-expr_match\n-: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n-| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n-| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n-| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n-;\n-\n-match_clauses\n-: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n-| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n-;\n-\n-match_clause\n-: nonblock_match_clause ','\n-| block_match_clause\n-| block_match_clause ','\n-;\n-\n-nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-;\n-\n-block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-;\n-\n-maybe_guard\n-: IF expr_nostruct           { $$ = $2; }\n-| %empty                     { $$ = mk_none(); }\n-;\n-\n-expr_if\n-: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n-| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n-;\n-\n-expr_if_let\n-: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n-| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n-;\n-\n-block_or_if\n-: block\n-| expr_if\n-| expr_if_let\n-;\n-\n-expr_while\n-: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n-;\n-\n-expr_while_let\n-: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n-;\n-\n-expr_loop\n-: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n-;\n-\n-expr_for\n-: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n-;\n-\n-maybe_label\n-: lifetime ':'\n-| %empty { $$ = mk_none(); }\n-;\n-\n-let\n-: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n-;\n-\n-////////////////////////////////////////////////////////////////////////\n-// Part 5: Macros and misc. rules\n-////////////////////////////////////////////////////////////////////////\n-\n-lit\n-: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n-| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n-| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n-| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n-| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n-| str\n-;\n-\n-str\n-: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n-| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n-| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n-| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n-;\n-\n-maybe_ident\n-: %empty { $$ = mk_none(); }\n-| ident\n-;\n-\n-ident\n-: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n-;\n-\n-unpaired_token\n-: SHL                        { $$ = mk_atom(yytext); }\n-| SHR                        { $$ = mk_atom(yytext); }\n-| LE                         { $$ = mk_atom(yytext); }\n-| EQEQ                       { $$ = mk_atom(yytext); }\n-| NE                         { $$ = mk_atom(yytext); }\n-| GE                         { $$ = mk_atom(yytext); }\n-| ANDAND                     { $$ = mk_atom(yytext); }\n-| OROR                       { $$ = mk_atom(yytext); }\n-| LARROW                     { $$ = mk_atom(yytext); }\n-| SHLEQ                      { $$ = mk_atom(yytext); }\n-| SHREQ                      { $$ = mk_atom(yytext); }\n-| MINUSEQ                    { $$ = mk_atom(yytext); }\n-| ANDEQ                      { $$ = mk_atom(yytext); }\n-| OREQ                       { $$ = mk_atom(yytext); }\n-| PLUSEQ                     { $$ = mk_atom(yytext); }\n-| STAREQ                     { $$ = mk_atom(yytext); }\n-| SLASHEQ                    { $$ = mk_atom(yytext); }\n-| CARETEQ                    { $$ = mk_atom(yytext); }\n-| PERCENTEQ                  { $$ = mk_atom(yytext); }\n-| DOTDOT                     { $$ = mk_atom(yytext); }\n-| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n-| MOD_SEP                    { $$ = mk_atom(yytext); }\n-| RARROW                     { $$ = mk_atom(yytext); }\n-| FAT_ARROW                  { $$ = mk_atom(yytext); }\n-| LIT_BYTE                   { $$ = mk_atom(yytext); }\n-| LIT_CHAR                   { $$ = mk_atom(yytext); }\n-| LIT_INTEGER                { $$ = mk_atom(yytext); }\n-| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n-| LIT_STR                    { $$ = mk_atom(yytext); }\n-| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n-| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n-| IDENT                      { $$ = mk_atom(yytext); }\n-| UNDERSCORE                 { $$ = mk_atom(yytext); }\n-| LIFETIME                   { $$ = mk_atom(yytext); }\n-| SELF                       { $$ = mk_atom(yytext); }\n-| STATIC                     { $$ = mk_atom(yytext); }\n-| AS                         { $$ = mk_atom(yytext); }\n-| BREAK                      { $$ = mk_atom(yytext); }\n-| CRATE                      { $$ = mk_atom(yytext); }\n-| ELSE                       { $$ = mk_atom(yytext); }\n-| ENUM                       { $$ = mk_atom(yytext); }\n-| EXTERN                     { $$ = mk_atom(yytext); }\n-| FALSE                      { $$ = mk_atom(yytext); }\n-| FN                         { $$ = mk_atom(yytext); }\n-| FOR                        { $$ = mk_atom(yytext); }\n-| IF                         { $$ = mk_atom(yytext); }\n-| IMPL                       { $$ = mk_atom(yytext); }\n-| IN                         { $$ = mk_atom(yytext); }\n-| LET                        { $$ = mk_atom(yytext); }\n-| LOOP                       { $$ = mk_atom(yytext); }\n-| MATCH                      { $$ = mk_atom(yytext); }\n-| MOD                        { $$ = mk_atom(yytext); }\n-| MOVE                       { $$ = mk_atom(yytext); }\n-| MUT                        { $$ = mk_atom(yytext); }\n-| PRIV                       { $$ = mk_atom(yytext); }\n-| PUB                        { $$ = mk_atom(yytext); }\n-| REF                        { $$ = mk_atom(yytext); }\n-| RETURN                     { $$ = mk_atom(yytext); }\n-| STRUCT                     { $$ = mk_atom(yytext); }\n-| TRUE                       { $$ = mk_atom(yytext); }\n-| TRAIT                      { $$ = mk_atom(yytext); }\n-| TYPE                       { $$ = mk_atom(yytext); }\n-| UNSAFE                     { $$ = mk_atom(yytext); }\n-| USE                        { $$ = mk_atom(yytext); }\n-| WHILE                      { $$ = mk_atom(yytext); }\n-| CONTINUE                   { $$ = mk_atom(yytext); }\n-| PROC                       { $$ = mk_atom(yytext); }\n-| BOX                        { $$ = mk_atom(yytext); }\n-| CONST                      { $$ = mk_atom(yytext); }\n-| WHERE                      { $$ = mk_atom(yytext); }\n-| TYPEOF                     { $$ = mk_atom(yytext); }\n-| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n-| SHEBANG                    { $$ = mk_atom(yytext); }\n-| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n-| ';'                        { $$ = mk_atom(yytext); }\n-| ','                        { $$ = mk_atom(yytext); }\n-| '.'                        { $$ = mk_atom(yytext); }\n-| '@'                        { $$ = mk_atom(yytext); }\n-| '#'                        { $$ = mk_atom(yytext); }\n-| '~'                        { $$ = mk_atom(yytext); }\n-| ':'                        { $$ = mk_atom(yytext); }\n-| '$'                        { $$ = mk_atom(yytext); }\n-| '='                        { $$ = mk_atom(yytext); }\n-| '?'                        { $$ = mk_atom(yytext); }\n-| '!'                        { $$ = mk_atom(yytext); }\n-| '<'                        { $$ = mk_atom(yytext); }\n-| '>'                        { $$ = mk_atom(yytext); }\n-| '-'                        { $$ = mk_atom(yytext); }\n-| '&'                        { $$ = mk_atom(yytext); }\n-| '|'                        { $$ = mk_atom(yytext); }\n-| '+'                        { $$ = mk_atom(yytext); }\n-| '*'                        { $$ = mk_atom(yytext); }\n-| '/'                        { $$ = mk_atom(yytext); }\n-| '^'                        { $$ = mk_atom(yytext); }\n-| '%'                        { $$ = mk_atom(yytext); }\n-;\n-\n-token_trees\n-: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n-| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n-;\n-\n-token_tree\n-: delimited_token_trees\n-| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n-;\n-\n-delimited_token_trees\n-: parens_delimited_token_trees\n-| braces_delimited_token_trees\n-| brackets_delimited_token_trees\n-;\n-\n-parens_delimited_token_trees\n-: '(' token_trees ')'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n-}\n-;\n-\n-braces_delimited_token_trees\n-: '{' token_trees '}'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n-}\n-;\n-\n-brackets_delimited_token_trees\n-: '[' token_trees ']'\n-{\n-  $$ = mk_node(\"TTDelim\", 3,\n-               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n-               $2,\n-               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n-}\n-;\n\\ No newline at end of file"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,64 +0,0 @@\n-Rust's lexical grammar is not context-free. Raw string literals are the source\n-of the problem. Informally, a raw string literal is an `r`, followed by `N`\n-hashes (where N can be zero), a quote, any characters, then a quote followed\n-by `N` hashes. Critically, once inside the first pair of quotes,\n-another quote cannot be followed by `N` consecutive hashes. e.g.\n-`r###\"\"###\"###` is invalid.\n-\n-This grammar describes this as best possible:\n-\n-    R -> 'r' S\n-    S -> '\"' B '\"'\n-    S -> '#' S '#'\n-    B -> . B\n-    B -> \u03b5\n-\n-Where `.` represents any character, and `\u03b5` the empty string. Consider the\n-string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n-accepted as one by the above grammar, using the derivation:\n-\n-    R : #\"\"#\"#\n-    S : \"\"#\"\n-    S : \"#\n-    B : #\n-    B : \u03b5\n-\n-(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n-string.) The difficulty arises from the fact that it is fundamentally\n-context-sensitive. In particular, the context needed is the number of hashes.\n-\n-To prove that Rust's string literals are not context-free, we will use\n-the fact that context-free languages are closed under intersection with\n-regular languages, and the\n-[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n-\n-Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n-context-free, then their intersection with `R`, `R'`, should also be context-free.\n-Therefore, to prove that raw string literals are not context-free,\n-it is sufficient to prove that `R'` is not context-free.\n-\n-The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n-\n-Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n-the pumping lemma applies. Consider the following string `s` in `R'`:\n-\n-`r#^p\"\"#^{p-1}\"#^p`\n-\n-e.g. for `p = 2`: `s = r##\"\"#\"##`\n-\n-Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n-`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n-\n-Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n-in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n-Consequently, of the three sequences of hashes, `v` and `x` combined\n-can only pump two of them.\n-If we ever choose the central sequence of hashes, then one of the outer sequences\n-will not grow when we pump, leading to an imbalance between the outer sequences.\n-Therefore, we must pump both outer sequences of hashes. However,\n-there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n-be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n-context-free.\n-\n-Since `R'` is not context-free, it follows that the Rust's raw string literals\n-must not be context-free."}, {"sha": "37be41b935f84b4e1434ba9f76d8aa8b25ed4c98", "filename": "src/grammar/testparser.py", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,76 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# ignore-tidy-linelength\n-\n-import sys\n-\n-import os\n-import subprocess\n-import argparse\n-\n-# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n-\n-# Parsers should read from stdin and return exit status 0 for a\n-# successful parse, and nonzero for an unsuccessful parse\n-\n-parser = argparse.ArgumentParser()\n-parser.add_argument('-p', '--parser', nargs='+')\n-parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n-args = parser.parse_args(sys.argv[1:])\n-\n-total = 0\n-ok = {}\n-bad = {}\n-for parser in args.parser:\n-    ok[parser] = 0\n-    bad[parser] = []\n-devnull = open(os.devnull, 'w')\n-print(\"\\n\")\n-\n-for base, dirs, files in os.walk(args.source_dir[0]):\n-    for f in filter(lambda p: p.endswith('.rs'), files):\n-        p = os.path.join(base, f)\n-        parse_fail = 'parse-fail' in p\n-        if sys.version_info.major == 3:\n-            lines = open(p, encoding='utf-8').readlines()\n-        else:\n-            lines = open(p).readlines()\n-        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n-            continue\n-        total += 1\n-        for parser in args.parser:\n-            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n-                if parse_fail:\n-                    bad[parser].append(p)\n-                else:\n-                    ok[parser] += 1\n-            else:\n-                if parse_fail:\n-                    ok[parser] += 1\n-                else:\n-                    bad[parser].append(p)\n-        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n-        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n-                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n-\n-devnull.close()\n-\n-print(\"\\n\")\n-\n-for parser in args.parser:\n-    filename = os.path.basename(parser) + '.bad'\n-    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n-    with open(filename, \"w\") as f:\n-        for p in bad[parser]:\n-            f.write(p)\n-            f.write(\"\\n\")"}, {"sha": "081bd05025967e76940f075c1c490c6ccdf2bfa7", "filename": "src/grammar/tokens.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Token {\n-  SHL = 257, // Parser generators reserve 0-256 for char literals\n-  SHR,\n-  LE,\n-  EQEQ,\n-  NE,\n-  GE,\n-  ANDAND,\n-  OROR,\n-  SHLEQ,\n-  SHREQ,\n-  MINUSEQ,\n-  ANDEQ,\n-  OREQ,\n-  PLUSEQ,\n-  STAREQ,\n-  SLASHEQ,\n-  CARETEQ,\n-  PERCENTEQ,\n-  DOTDOT,\n-  DOTDOTDOT,\n-  MOD_SEP,\n-  RARROW,\n-  FAT_ARROW,\n-  LIT_BYTE,\n-  LIT_CHAR,\n-  LIT_INTEGER,\n-  LIT_FLOAT,\n-  LIT_STR,\n-  LIT_STR_RAW,\n-  LIT_BYTE_STR,\n-  LIT_BYTE_STR_RAW,\n-  IDENT,\n-  UNDERSCORE,\n-  LIFETIME,\n-\n-  // keywords\n-  SELF,\n-  STATIC,\n-  AS,\n-  BREAK,\n-  CRATE,\n-  ELSE,\n-  ENUM,\n-  EXTERN,\n-  FALSE,\n-  FN,\n-  FOR,\n-  IF,\n-  IMPL,\n-  IN,\n-  LET,\n-  LOOP,\n-  MATCH,\n-  MOD,\n-  MOVE,\n-  MUT,\n-  PRIV,\n-  PUB,\n-  REF,\n-  RETURN,\n-  STRUCT,\n-  TRUE,\n-  TRAIT,\n-  TYPE,\n-  UNSAFE,\n-  USE,\n-  WHILE,\n-  CONTINUE,\n-  PROC,\n-  BOX,\n-  CONST,\n-  WHERE,\n-  TYPEOF,\n-  INNER_DOC_COMMENT,\n-  OUTER_DOC_COMMENT,\n-\n-  SHEBANG,\n-  SHEBANG_LINE,\n-  STATIC_LIFETIME\n-};"}, {"sha": "3ac043f7aa9bc13568c73c482ce5484a3a09f745", "filename": "src/grammar/verify.rs", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,361 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(plugin, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-\n-#[macro_use]\n-extern crate log;\n-\n-use std::collections::HashMap;\n-use std::env;\n-use std::fs::File;\n-use std::io::{BufRead, Read};\n-use std::path::Path;\n-\n-use syntax::parse::lexer;\n-use rustc::dep_graph::DepGraph;\n-use rustc::session::{self, config};\n-use rustc::middle::cstore::DummyCrateStore;\n-\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax::codemap;\n-use syntax::parse::token::{self, BinOpToken, DelimToken, Lit, Token};\n-use syntax::parse::lexer::TokenAndSpan;\n-use syntax_pos::Pos;\n-\n-use syntax::symbol::{Symbol, keywords};\n-\n-fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n-    fn id() -> token::Token {\n-        Token::Ident(ast::Ident::with_empty_ctxt(keywords::Invalid.name()))\n-    }\n-\n-    let mut res = HashMap::new();\n-\n-    res.insert(\"-1\".to_string(), Token::Eof);\n-\n-    for line in file.split('\\n') {\n-        let eq = match line.trim().rfind('=') {\n-            Some(val) => val,\n-            None => continue\n-        };\n-\n-        let val = &line[..eq];\n-        let num = &line[eq + 1..];\n-\n-        let tok = match val {\n-            \"SHR\"               => Token::BinOp(BinOpToken::Shr),\n-            \"DOLLAR\"            => Token::Dollar,\n-            \"LT\"                => Token::Lt,\n-            \"STAR\"              => Token::BinOp(BinOpToken::Star),\n-            \"FLOAT_SUFFIX\"      => id(),\n-            \"INT_SUFFIX\"        => id(),\n-            \"SHL\"               => Token::BinOp(BinOpToken::Shl),\n-            \"LBRACE\"            => Token::OpenDelim(DelimToken::Brace),\n-            \"RARROW\"            => Token::RArrow,\n-            \"LIT_STR\"           => Token::Literal(Lit::Str_(keywords::Invalid.name()), None),\n-            \"DOTDOT\"            => Token::DotDot,\n-            \"MOD_SEP\"           => Token::ModSep,\n-            \"DOTDOTDOT\"         => Token::DotDotDot,\n-            \"NOT\"               => Token::Not,\n-            \"AND\"               => Token::BinOp(BinOpToken::And),\n-            \"LPAREN\"            => Token::OpenDelim(DelimToken::Paren),\n-            \"ANDAND\"            => Token::AndAnd,\n-            \"AT\"                => Token::At,\n-            \"LBRACKET\"          => Token::OpenDelim(DelimToken::Bracket),\n-            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(keywords::Invalid.name(), 0), None),\n-            \"RPAREN\"            => Token::CloseDelim(DelimToken::Paren),\n-            \"SLASH\"             => Token::BinOp(BinOpToken::Slash),\n-            \"COMMA\"             => Token::Comma,\n-            \"LIFETIME\"          => Token::Lifetime(\n-                                            ast::Ident::with_empty_ctxt(keywords::Invalid.name())),\n-            \"CARET\"             => Token::BinOp(BinOpToken::Caret),\n-            \"TILDE\"             => Token::Tilde,\n-            \"IDENT\"             => id(),\n-            \"PLUS\"              => Token::BinOp(BinOpToken::Plus),\n-            \"LIT_CHAR\"          => Token::Literal(Lit::Char(keywords::Invalid.name()), None),\n-            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(keywords::Invalid.name()), None),\n-            \"EQ\"                => Token::Eq,\n-            \"RBRACKET\"          => Token::CloseDelim(DelimToken::Bracket),\n-            \"COMMENT\"           => Token::Comment,\n-            \"DOC_COMMENT\"       => Token::DocComment(keywords::Invalid.name()),\n-            \"DOT\"               => Token::Dot,\n-            \"EQEQ\"              => Token::EqEq,\n-            \"NE\"                => Token::Ne,\n-            \"GE\"                => Token::Ge,\n-            \"PERCENT\"           => Token::BinOp(BinOpToken::Percent),\n-            \"RBRACE\"            => Token::CloseDelim(DelimToken::Brace),\n-            \"BINOP\"             => Token::BinOp(BinOpToken::Plus),\n-            \"POUND\"             => Token::Pound,\n-            \"OROR\"              => Token::OrOr,\n-            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(keywords::Invalid.name()), None),\n-            \"BINOPEQ\"           => Token::BinOpEq(BinOpToken::Plus),\n-            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(keywords::Invalid.name()), None),\n-            \"WHITESPACE\"        => Token::Whitespace,\n-            \"UNDERSCORE\"        => Token::Underscore,\n-            \"MINUS\"             => Token::BinOp(BinOpToken::Minus),\n-            \"SEMI\"              => Token::Semi,\n-            \"COLON\"             => Token::Colon,\n-            \"FAT_ARROW\"         => Token::FatArrow,\n-            \"OR\"                => Token::BinOp(BinOpToken::Or),\n-            \"GT\"                => Token::Gt,\n-            \"LE\"                => Token::Le,\n-            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(keywords::Invalid.name()), None),\n-            \"LIT_BINARY_RAW\"    => Token::Literal(\n-                                            Lit::ByteStrRaw(keywords::Invalid.name(), 0), None),\n-            \"QUESTION\"          => Token::Question,\n-            \"SHEBANG\"           => Token::Shebang(keywords::Invalid.name()),\n-            _                   => continue,\n-        };\n-\n-        res.insert(num.to_string(), tok);\n-    }\n-\n-    debug!(\"Token map: {:?}\", res);\n-    res\n-}\n-\n-fn str_to_binop(s: &str) -> token::BinOpToken {\n-    match s {\n-        \"+\"     => BinOpToken::Plus,\n-        \"/\"     => BinOpToken::Slash,\n-        \"-\"     => BinOpToken::Minus,\n-        \"*\"     => BinOpToken::Star,\n-        \"%\"     => BinOpToken::Percent,\n-        \"^\"     => BinOpToken::Caret,\n-        \"&\"     => BinOpToken::And,\n-        \"|\"     => BinOpToken::Or,\n-        \"<<\"    => BinOpToken::Shl,\n-        \">>\"    => BinOpToken::Shr,\n-        _       => panic!(\"Bad binop str `{}`\", s),\n-    }\n-}\n-\n-/// Assuming a string/byte string literal, strip out the leading/trailing\n-/// hashes and surrounding quotes/raw/byte prefix.\n-fn fix(mut lit: &str) -> ast::Name {\n-    let prefix: Vec<char> = lit.chars().take(2).collect();\n-    if prefix[0] == 'r' {\n-        if prefix[1] == 'b' {\n-            lit = &lit[2..]\n-        } else {\n-            lit = &lit[1..];\n-        }\n-    } else if prefix[0] == 'b' {\n-        lit = &lit[1..];\n-    }\n-\n-    let leading_hashes = count(lit);\n-\n-    // +1/-1 to adjust for single quotes\n-    Symbol::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n-}\n-\n-/// Assuming a char/byte literal, strip the 'b' prefix and the single quotes.\n-fn fixchar(mut lit: &str) -> ast::Name {\n-    let prefix = lit.chars().next().unwrap();\n-    if prefix == 'b' {\n-        lit = &lit[1..];\n-    }\n-\n-    Symbol::intern(&lit[1..lit.len() - 1])\n-}\n-\n-fn count(lit: &str) -> usize {\n-    lit.chars().take_while(|c| *c == '#').count()\n-}\n-\n-fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_pairs_pos: &[usize],\n-                     has_bom: bool)\n-                     -> TokenAndSpan {\n-    // old regex:\n-    // \\[@(?P<seq>\\d+),(?P<start>\\d+):(?P<end>\\d+)='(?P<content>.+?)',<(?P<toknum>-?\\d+)>,\\d+:\\d+]\n-    let start = s.find(\"[@\").unwrap();\n-    let comma = start + s[start..].find(\",\").unwrap();\n-    let colon = comma + s[comma..].find(\":\").unwrap();\n-    let content_start = colon + s[colon..].find(\"='\").unwrap();\n-    // Use rfind instead of find, because we don't want to stop at the content\n-    let content_end = content_start + s[content_start..].rfind(\"',<\").unwrap();\n-    let toknum_end = content_end + s[content_end..].find(\">,\").unwrap();\n-\n-    let start = &s[comma + 1 .. colon];\n-    let end = &s[colon + 1 .. content_start];\n-    let content = &s[content_start + 2 .. content_end];\n-    let toknum = &s[content_end + 3 .. toknum_end];\n-\n-    let not_found = format!(\"didn't find token {:?} in the map\", toknum);\n-    let proto_tok = tokens.get(toknum).expect(&not_found);\n-\n-    let nm = Symbol::intern(content);\n-\n-    debug!(\"What we got: content (`{}`), proto: {:?}\", content, proto_tok);\n-\n-    let real_tok = match *proto_tok {\n-        Token::BinOp(..)           => Token::BinOp(str_to_binop(content)),\n-        Token::BinOpEq(..)         => Token::BinOpEq(str_to_binop(&content[..content.len() - 1])),\n-        Token::Literal(Lit::Str_(..), n)      => Token::Literal(Lit::Str_(fix(content)), n),\n-        Token::Literal(Lit::StrRaw(..), n)    => Token::Literal(Lit::StrRaw(fix(content),\n-                                                                             count(content)), n),\n-        Token::Literal(Lit::Char(..), n)      => Token::Literal(Lit::Char(fixchar(content)), n),\n-        Token::Literal(Lit::Byte(..), n)      => Token::Literal(Lit::Byte(fixchar(content)), n),\n-        Token::DocComment(..)      => Token::DocComment(nm),\n-        Token::Literal(Lit::Integer(..), n)   => Token::Literal(Lit::Integer(nm), n),\n-        Token::Literal(Lit::Float(..), n)     => Token::Literal(Lit::Float(nm), n),\n-        Token::Literal(Lit::ByteStr(..), n)    => Token::Literal(Lit::ByteStr(nm), n),\n-        Token::Literal(Lit::ByteStrRaw(..), n) => Token::Literal(Lit::ByteStrRaw(fix(content),\n-                                                                                count(content)), n),\n-        Token::Ident(..)           => Token::Ident(ast::Ident::with_empty_ctxt(nm)),\n-        Token::Lifetime(..)        => Token::Lifetime(ast::Ident::with_empty_ctxt(nm)),\n-        ref t => t.clone()\n-    };\n-\n-    let start_offset = if real_tok == Token::Eof {\n-        1\n-    } else {\n-        0\n-    };\n-\n-    let offset = if has_bom { 1 } else { 0 };\n-\n-    let mut lo = start.parse::<u32>().unwrap() - start_offset - offset;\n-    let mut hi = end.parse::<u32>().unwrap() + 1 - offset;\n-\n-    // Adjust the span: For each surrogate pair already encountered, subtract one position.\n-    lo -= surrogate_pairs_pos.binary_search(&(lo as usize)).unwrap_or_else(|x| x) as u32;\n-    hi -= surrogate_pairs_pos.binary_search(&(hi as usize)).unwrap_or_else(|x| x) as u32;\n-\n-    let sp = syntax_pos::Span {\n-        lo: syntax_pos::BytePos(lo),\n-        hi: syntax_pos::BytePos(hi),\n-        expn_id: syntax_pos::NO_EXPANSION\n-    };\n-\n-    TokenAndSpan {\n-        tok: real_tok,\n-        sp: sp\n-    }\n-}\n-\n-fn tok_cmp(a: &token::Token, b: &token::Token) -> bool {\n-    match a {\n-        &Token::Ident(id) => match b {\n-                &Token::Ident(id2) => id == id2,\n-                _ => false\n-        },\n-        _ => a == b\n-    }\n-}\n-\n-fn span_cmp(antlr_sp: codemap::Span, rust_sp: codemap::Span, cm: &codemap::CodeMap) -> bool {\n-    antlr_sp.expn_id == rust_sp.expn_id &&\n-        antlr_sp.lo.to_usize() == cm.bytepos_to_file_charpos(rust_sp.lo).to_usize() &&\n-        antlr_sp.hi.to_usize() == cm.bytepos_to_file_charpos(rust_sp.hi).to_usize()\n-}\n-\n-fn main() {\n-    fn next(r: &mut lexer::StringReader) -> TokenAndSpan {\n-        use syntax::parse::lexer::Reader;\n-        r.next_token()\n-    }\n-\n-    let mut args = env::args().skip(1);\n-    let filename = args.next().unwrap();\n-    if filename.find(\"parse-fail\").is_some() {\n-        return;\n-    }\n-\n-    // Rust's lexer\n-    let mut code = String::new();\n-    File::open(&Path::new(&filename)).unwrap().read_to_string(&mut code).unwrap();\n-\n-    let surrogate_pairs_pos: Vec<usize> = code.chars().enumerate()\n-                                                     .filter(|&(_, c)| c as usize > 0xFFFF)\n-                                                     .map(|(n, _)| n)\n-                                                     .enumerate()\n-                                                     .map(|(x, n)| x + n)\n-                                                     .collect();\n-\n-    let has_bom = code.starts_with(\"\\u{feff}\");\n-\n-    debug!(\"Pairs: {:?}\", surrogate_pairs_pos);\n-\n-    let options = config::basic_options();\n-    let session = session::build_session(options, &DepGraph::new(false), None,\n-                                         syntax::errors::registry::Registry::new(&[]),\n-                                         Rc::new(DummyCrateStore));\n-    let filemap = session.parse_sess.codemap()\n-                         .new_filemap(\"<n/a>\".to_string(), code);\n-    let mut lexer = lexer::StringReader::new(session.diagnostic(), filemap);\n-    let cm = session.codemap();\n-\n-    // ANTLR\n-    let mut token_file = File::open(&Path::new(&args.next().unwrap())).unwrap();\n-    let mut token_list = String::new();\n-    token_file.read_to_string(&mut token_list).unwrap();\n-    let token_map = parse_token_list(&token_list);\n-\n-    let stdin = std::io::stdin();\n-    let lock = stdin.lock();\n-    let lines = lock.lines();\n-    let antlr_tokens = lines.map(|l| parse_antlr_token(l.unwrap().trim(),\n-                                                       &token_map,\n-                                                       &surrogate_pairs_pos,\n-                                                       has_bom));\n-\n-    for antlr_tok in antlr_tokens {\n-        let rustc_tok = next(&mut lexer);\n-        if rustc_tok.tok == Token::Eof && antlr_tok.tok == Token::Eof {\n-            continue\n-        }\n-\n-        assert!(span_cmp(antlr_tok.sp, rustc_tok.sp, cm), \"{:?} and {:?} have different spans\",\n-                rustc_tok,\n-                antlr_tok);\n-\n-        macro_rules! matches {\n-            ( $($x:pat),+ ) => (\n-                match rustc_tok.tok {\n-                    $($x => match antlr_tok.tok {\n-                        $x => {\n-                            if !tok_cmp(&rustc_tok.tok, &antlr_tok.tok) {\n-                                // FIXME #15677: needs more robust escaping in\n-                                // antlr\n-                                warn!(\"Different names for {:?} and {:?}\", rustc_tok, antlr_tok);\n-                            }\n-                        }\n-                        _ => panic!(\"{:?} is not {:?}\", antlr_tok, rustc_tok)\n-                    },)*\n-                    ref c => assert!(c == &antlr_tok.tok, \"{:?} is not {:?}\", antlr_tok, rustc_tok)\n-                }\n-            )\n-        }\n-\n-        matches!(\n-            Token::Literal(Lit::Byte(..), _),\n-            Token::Literal(Lit::Char(..), _),\n-            Token::Literal(Lit::Integer(..), _),\n-            Token::Literal(Lit::Float(..), _),\n-            Token::Literal(Lit::Str_(..), _),\n-            Token::Literal(Lit::StrRaw(..), _),\n-            Token::Literal(Lit::ByteStr(..), _),\n-            Token::Literal(Lit::ByteStrRaw(..), _),\n-            Token::Ident(..),\n-            Token::Lifetime(..),\n-            Token::Interpolated(..),\n-            Token::DocComment(..),\n-            Token::Shebang(..)\n-        );\n-    }\n-}"}, {"sha": "f3a1a3b40f99a382f17d8246b0f03c96eb7f49c3", "filename": "src/grammar/xidcontinue.g4", "status": "removed", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fxidcontinue.g4", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fxidcontinue.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fxidcontinue.g4?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,473 +0,0 @@\n-lexer grammar Xidcontinue;\n-\n-fragment XID_Continue:\n-      '\\u0030' .. '\\u0039'\n-    | '\\u0041' .. '\\u005a'\n-    | '\\u005f'\n-    | '\\u0061' .. '\\u007a'\n-    | '\\u00aa'\n-    | '\\u00b5'\n-    | '\\u00b7'\n-    | '\\u00ba'\n-    | '\\u00c0' .. '\\u00d6'\n-    | '\\u00d8' .. '\\u00f6'\n-    | '\\u00f8' .. '\\u0236'\n-    | '\\u0250' .. '\\u02c1'\n-    | '\\u02c6' .. '\\u02d1'\n-    | '\\u02e0' .. '\\u02e4'\n-    | '\\u02ee'\n-    | '\\u0300' .. '\\u0357'\n-    | '\\u035d' .. '\\u036f'\n-    | '\\u0386'\n-    | '\\u0388' .. '\\u038a'\n-    | '\\u038c'\n-    | '\\u038e' .. '\\u03a1'\n-    | '\\u03a3' .. '\\u03ce'\n-    | '\\u03d0' .. '\\u03f5'\n-    | '\\u03f7' .. '\\u03fb'\n-    | '\\u0400' .. '\\u0481'\n-    | '\\u0483' .. '\\u0486'\n-    | '\\u048a' .. '\\u04ce'\n-    | '\\u04d0' .. '\\u04f5'\n-    | '\\u04f8' .. '\\u04f9'\n-    | '\\u0500' .. '\\u050f'\n-    | '\\u0531' .. '\\u0556'\n-    | '\\u0559'\n-    | '\\u0561' .. '\\u0587'\n-    | '\\u0591' .. '\\u05a1'\n-    | '\\u05a3' .. '\\u05b9'\n-    | '\\u05bb' .. '\\u05bd'\n-    | '\\u05bf'\n-    | '\\u05c1' .. '\\u05c2'\n-    | '\\u05c4'\n-    | '\\u05d0' .. '\\u05ea'\n-    | '\\u05f0' .. '\\u05f2'\n-    | '\\u0610' .. '\\u0615'\n-    | '\\u0621' .. '\\u063a'\n-    | '\\u0640' .. '\\u0658'\n-    | '\\u0660' .. '\\u0669'\n-    | '\\u066e' .. '\\u06d3'\n-    | '\\u06d5' .. '\\u06dc'\n-    | '\\u06df' .. '\\u06e8'\n-    | '\\u06ea' .. '\\u06fc'\n-    | '\\u06ff'\n-    | '\\u0710' .. '\\u074a'\n-    | '\\u074d' .. '\\u074f'\n-    | '\\u0780' .. '\\u07b1'\n-    | '\\u0901' .. '\\u0939'\n-    | '\\u093c' .. '\\u094d'\n-    | '\\u0950' .. '\\u0954'\n-    | '\\u0958' .. '\\u0963'\n-    | '\\u0966' .. '\\u096f'\n-    | '\\u0981' .. '\\u0983'\n-    | '\\u0985' .. '\\u098c'\n-    | '\\u098f' .. '\\u0990'\n-    | '\\u0993' .. '\\u09a8'\n-    | '\\u09aa' .. '\\u09b0'\n-    | '\\u09b2'\n-    | '\\u09b6' .. '\\u09b9'\n-    | '\\u09bc' .. '\\u09c4'\n-    | '\\u09c7' .. '\\u09c8'\n-    | '\\u09cb' .. '\\u09cd'\n-    | '\\u09d7'\n-    | '\\u09dc' .. '\\u09dd'\n-    | '\\u09df' .. '\\u09e3'\n-    | '\\u09e6' .. '\\u09f1'\n-    | '\\u0a01' .. '\\u0a03'\n-    | '\\u0a05' .. '\\u0a0a'\n-    | '\\u0a0f' .. '\\u0a10'\n-    | '\\u0a13' .. '\\u0a28'\n-    | '\\u0a2a' .. '\\u0a30'\n-    | '\\u0a32' .. '\\u0a33'\n-    | '\\u0a35' .. '\\u0a36'\n-    | '\\u0a38' .. '\\u0a39'\n-    | '\\u0a3c'\n-    | '\\u0a3e' .. '\\u0a42'\n-    | '\\u0a47' .. '\\u0a48'\n-    | '\\u0a4b' .. '\\u0a4d'\n-    | '\\u0a59' .. '\\u0a5c'\n-    | '\\u0a5e'\n-    | '\\u0a66' .. '\\u0a74'\n-    | '\\u0a81' .. '\\u0a83'\n-    | '\\u0a85' .. '\\u0a8d'\n-    | '\\u0a8f' .. '\\u0a91'\n-    | '\\u0a93' .. '\\u0aa8'\n-    | '\\u0aaa' .. '\\u0ab0'\n-    | '\\u0ab2' .. '\\u0ab3'\n-    | '\\u0ab5' .. '\\u0ab9'\n-    | '\\u0abc' .. '\\u0ac5'\n-    | '\\u0ac7' .. '\\u0ac9'\n-    | '\\u0acb' .. '\\u0acd'\n-    | '\\u0ad0'\n-    | '\\u0ae0' .. '\\u0ae3'\n-    | '\\u0ae6' .. '\\u0aef'\n-    | '\\u0b01' .. '\\u0b03'\n-    | '\\u0b05' .. '\\u0b0c'\n-    | '\\u0b0f' .. '\\u0b10'\n-    | '\\u0b13' .. '\\u0b28'\n-    | '\\u0b2a' .. '\\u0b30'\n-    | '\\u0b32' .. '\\u0b33'\n-    | '\\u0b35' .. '\\u0b39'\n-    | '\\u0b3c' .. '\\u0b43'\n-    | '\\u0b47' .. '\\u0b48'\n-    | '\\u0b4b' .. '\\u0b4d'\n-    | '\\u0b56' .. '\\u0b57'\n-    | '\\u0b5c' .. '\\u0b5d'\n-    | '\\u0b5f' .. '\\u0b61'\n-    | '\\u0b66' .. '\\u0b6f'\n-    | '\\u0b71'\n-    | '\\u0b82' .. '\\u0b83'\n-    | '\\u0b85' .. '\\u0b8a'\n-    | '\\u0b8e' .. '\\u0b90'\n-    | '\\u0b92' .. '\\u0b95'\n-    | '\\u0b99' .. '\\u0b9a'\n-    | '\\u0b9c'\n-    | '\\u0b9e' .. '\\u0b9f'\n-    | '\\u0ba3' .. '\\u0ba4'\n-    | '\\u0ba8' .. '\\u0baa'\n-    | '\\u0bae' .. '\\u0bb5'\n-    | '\\u0bb7' .. '\\u0bb9'\n-    | '\\u0bbe' .. '\\u0bc2'\n-    | '\\u0bc6' .. '\\u0bc8'\n-    | '\\u0bca' .. '\\u0bcd'\n-    | '\\u0bd7'\n-    | '\\u0be7' .. '\\u0bef'\n-    | '\\u0c01' .. '\\u0c03'\n-    | '\\u0c05' .. '\\u0c0c'\n-    | '\\u0c0e' .. '\\u0c10'\n-    | '\\u0c12' .. '\\u0c28'\n-    | '\\u0c2a' .. '\\u0c33'\n-    | '\\u0c35' .. '\\u0c39'\n-    | '\\u0c3e' .. '\\u0c44'\n-    | '\\u0c46' .. '\\u0c48'\n-    | '\\u0c4a' .. '\\u0c4d'\n-    | '\\u0c55' .. '\\u0c56'\n-    | '\\u0c60' .. '\\u0c61'\n-    | '\\u0c66' .. '\\u0c6f'\n-    | '\\u0c82' .. '\\u0c83'\n-    | '\\u0c85' .. '\\u0c8c'\n-    | '\\u0c8e' .. '\\u0c90'\n-    | '\\u0c92' .. '\\u0ca8'\n-    | '\\u0caa' .. '\\u0cb3'\n-    | '\\u0cb5' .. '\\u0cb9'\n-    | '\\u0cbc' .. '\\u0cc4'\n-    | '\\u0cc6' .. '\\u0cc8'\n-    | '\\u0cca' .. '\\u0ccd'\n-    | '\\u0cd5' .. '\\u0cd6'\n-    | '\\u0cde'\n-    | '\\u0ce0' .. '\\u0ce1'\n-    | '\\u0ce6' .. '\\u0cef'\n-    | '\\u0d02' .. '\\u0d03'\n-    | '\\u0d05' .. '\\u0d0c'\n-    | '\\u0d0e' .. '\\u0d10'\n-    | '\\u0d12' .. '\\u0d28'\n-    | '\\u0d2a' .. '\\u0d39'\n-    | '\\u0d3e' .. '\\u0d43'\n-    | '\\u0d46' .. '\\u0d48'\n-    | '\\u0d4a' .. '\\u0d4d'\n-    | '\\u0d57'\n-    | '\\u0d60' .. '\\u0d61'\n-    | '\\u0d66' .. '\\u0d6f'\n-    | '\\u0d82' .. '\\u0d83'\n-    | '\\u0d85' .. '\\u0d96'\n-    | '\\u0d9a' .. '\\u0db1'\n-    | '\\u0db3' .. '\\u0dbb'\n-    | '\\u0dbd'\n-    | '\\u0dc0' .. '\\u0dc6'\n-    | '\\u0dca'\n-    | '\\u0dcf' .. '\\u0dd4'\n-    | '\\u0dd6'\n-    | '\\u0dd8' .. '\\u0ddf'\n-    | '\\u0df2' .. '\\u0df3'\n-    | '\\u0e01' .. '\\u0e3a'\n-    | '\\u0e40' .. '\\u0e4e'\n-    | '\\u0e50' .. '\\u0e59'\n-    | '\\u0e81' .. '\\u0e82'\n-    | '\\u0e84'\n-    | '\\u0e87' .. '\\u0e88'\n-    | '\\u0e8a'\n-    | '\\u0e8d'\n-    | '\\u0e94' .. '\\u0e97'\n-    | '\\u0e99' .. '\\u0e9f'\n-    | '\\u0ea1' .. '\\u0ea3'\n-    | '\\u0ea5'\n-    | '\\u0ea7'\n-    | '\\u0eaa' .. '\\u0eab'\n-    | '\\u0ead' .. '\\u0eb9'\n-    | '\\u0ebb' .. '\\u0ebd'\n-    | '\\u0ec0' .. '\\u0ec4'\n-    | '\\u0ec6'\n-    | '\\u0ec8' .. '\\u0ecd'\n-    | '\\u0ed0' .. '\\u0ed9'\n-    | '\\u0edc' .. '\\u0edd'\n-    | '\\u0f00'\n-    | '\\u0f18' .. '\\u0f19'\n-    | '\\u0f20' .. '\\u0f29'\n-    | '\\u0f35'\n-    | '\\u0f37'\n-    | '\\u0f39'\n-    | '\\u0f3e' .. '\\u0f47'\n-    | '\\u0f49' .. '\\u0f6a'\n-    | '\\u0f71' .. '\\u0f84'\n-    | '\\u0f86' .. '\\u0f8b'\n-    | '\\u0f90' .. '\\u0f97'\n-    | '\\u0f99' .. '\\u0fbc'\n-    | '\\u0fc6'\n-    | '\\u1000' .. '\\u1021'\n-    | '\\u1023' .. '\\u1027'\n-    | '\\u1029' .. '\\u102a'\n-    | '\\u102c' .. '\\u1032'\n-    | '\\u1036' .. '\\u1039'\n-    | '\\u1040' .. '\\u1049'\n-    | '\\u1050' .. '\\u1059'\n-    | '\\u10a0' .. '\\u10c5'\n-    | '\\u10d0' .. '\\u10f8'\n-    | '\\u1100' .. '\\u1159'\n-    | '\\u115f' .. '\\u11a2'\n-    | '\\u11a8' .. '\\u11f9'\n-    | '\\u1200' .. '\\u1206'\n-    | '\\u1208' .. '\\u1246'\n-    | '\\u1248'\n-    | '\\u124a' .. '\\u124d'\n-    | '\\u1250' .. '\\u1256'\n-    | '\\u1258'\n-    | '\\u125a' .. '\\u125d'\n-    | '\\u1260' .. '\\u1286'\n-    | '\\u1288'\n-    | '\\u128a' .. '\\u128d'\n-    | '\\u1290' .. '\\u12ae'\n-    | '\\u12b0'\n-    | '\\u12b2' .. '\\u12b5'\n-    | '\\u12b8' .. '\\u12be'\n-    | '\\u12c0'\n-    | '\\u12c2' .. '\\u12c5'\n-    | '\\u12c8' .. '\\u12ce'\n-    | '\\u12d0' .. '\\u12d6'\n-    | '\\u12d8' .. '\\u12ee'\n-    | '\\u12f0' .. '\\u130e'\n-    | '\\u1310'\n-    | '\\u1312' .. '\\u1315'\n-    | '\\u1318' .. '\\u131e'\n-    | '\\u1320' .. '\\u1346'\n-    | '\\u1348' .. '\\u135a'\n-    | '\\u1369' .. '\\u1371'\n-    | '\\u13a0' .. '\\u13f4'\n-    | '\\u1401' .. '\\u166c'\n-    | '\\u166f' .. '\\u1676'\n-    | '\\u1681' .. '\\u169a'\n-    | '\\u16a0' .. '\\u16ea'\n-    | '\\u16ee' .. '\\u16f0'\n-    | '\\u1700' .. '\\u170c'\n-    | '\\u170e' .. '\\u1714'\n-    | '\\u1720' .. '\\u1734'\n-    | '\\u1740' .. '\\u1753'\n-    | '\\u1760' .. '\\u176c'\n-    | '\\u176e' .. '\\u1770'\n-    | '\\u1772' .. '\\u1773'\n-    | '\\u1780' .. '\\u17b3'\n-    | '\\u17b6' .. '\\u17d3'\n-    | '\\u17d7'\n-    | '\\u17dc' .. '\\u17dd'\n-    | '\\u17e0' .. '\\u17e9'\n-    | '\\u180b' .. '\\u180d'\n-    | '\\u1810' .. '\\u1819'\n-    | '\\u1820' .. '\\u1877'\n-    | '\\u1880' .. '\\u18a9'\n-    | '\\u1900' .. '\\u191c'\n-    | '\\u1920' .. '\\u192b'\n-    | '\\u1930' .. '\\u193b'\n-    | '\\u1946' .. '\\u196d'\n-    | '\\u1970' .. '\\u1974'\n-    | '\\u1d00' .. '\\u1d6b'\n-    | '\\u1e00' .. '\\u1e9b'\n-    | '\\u1ea0' .. '\\u1ef9'\n-    | '\\u1f00' .. '\\u1f15'\n-    | '\\u1f18' .. '\\u1f1d'\n-    | '\\u1f20' .. '\\u1f45'\n-    | '\\u1f48' .. '\\u1f4d'\n-    | '\\u1f50' .. '\\u1f57'\n-    | '\\u1f59'\n-    | '\\u1f5b'\n-    | '\\u1f5d'\n-    | '\\u1f5f' .. '\\u1f7d'\n-    | '\\u1f80' .. '\\u1fb4'\n-    | '\\u1fb6' .. '\\u1fbc'\n-    | '\\u1fbe'\n-    | '\\u1fc2' .. '\\u1fc4'\n-    | '\\u1fc6' .. '\\u1fcc'\n-    | '\\u1fd0' .. '\\u1fd3'\n-    | '\\u1fd6' .. '\\u1fdb'\n-    | '\\u1fe0' .. '\\u1fec'\n-    | '\\u1ff2' .. '\\u1ff4'\n-    | '\\u1ff6' .. '\\u1ffc'\n-    | '\\u203f' .. '\\u2040'\n-    | '\\u2054'\n-    | '\\u2071'\n-    | '\\u207f'\n-    | '\\u20d0' .. '\\u20dc'\n-    | '\\u20e1'\n-    | '\\u20e5' .. '\\u20ea'\n-    | '\\u2102'\n-    | '\\u2107'\n-    | '\\u210a' .. '\\u2113'\n-    | '\\u2115'\n-    | '\\u2118' .. '\\u211d'\n-    | '\\u2124'\n-    | '\\u2126'\n-    | '\\u2128'\n-    | '\\u212a' .. '\\u2131'\n-    | '\\u2133' .. '\\u2139'\n-    | '\\u213d' .. '\\u213f'\n-    | '\\u2145' .. '\\u2149'\n-    | '\\u2160' .. '\\u2183'\n-    | '\\u3005' .. '\\u3007'\n-    | '\\u3021' .. '\\u302f'\n-    | '\\u3031' .. '\\u3035'\n-    | '\\u3038' .. '\\u303c'\n-    | '\\u3041' .. '\\u3096'\n-    | '\\u3099' .. '\\u309a'\n-    | '\\u309d' .. '\\u309f'\n-    | '\\u30a1' .. '\\u30ff'\n-    | '\\u3105' .. '\\u312c'\n-    | '\\u3131' .. '\\u318e'\n-    | '\\u31a0' .. '\\u31b7'\n-    | '\\u31f0' .. '\\u31ff'\n-    | '\\u3400' .. '\\u4db5'\n-    | '\\u4e00' .. '\\u9fa5'\n-    | '\\ua000' .. '\\ua48c'\n-    | '\\uac00' .. '\\ud7a3'\n-    | '\\uf900' .. '\\ufa2d'\n-    | '\\ufa30' .. '\\ufa6a'\n-    | '\\ufb00' .. '\\ufb06'\n-    | '\\ufb13' .. '\\ufb17'\n-    | '\\ufb1d' .. '\\ufb28'\n-    | '\\ufb2a' .. '\\ufb36'\n-    | '\\ufb38' .. '\\ufb3c'\n-    | '\\ufb3e'\n-    | '\\ufb40' .. '\\ufb41'\n-    | '\\ufb43' .. '\\ufb44'\n-    | '\\ufb46' .. '\\ufbb1'\n-    | '\\ufbd3' .. '\\ufc5d'\n-    | '\\ufc64' .. '\\ufd3d'\n-    | '\\ufd50' .. '\\ufd8f'\n-    | '\\ufd92' .. '\\ufdc7'\n-    | '\\ufdf0' .. '\\ufdf9'\n-    | '\\ufe00' .. '\\ufe0f'\n-    | '\\ufe20' .. '\\ufe23'\n-    | '\\ufe33' .. '\\ufe34'\n-    | '\\ufe4d' .. '\\ufe4f'\n-    | '\\ufe71'\n-    | '\\ufe73'\n-    | '\\ufe77'\n-    | '\\ufe79'\n-    | '\\ufe7b'\n-    | '\\ufe7d'\n-    | '\\ufe7f' .. '\\ufefc'\n-    | '\\uff10' .. '\\uff19'\n-    | '\\uff21' .. '\\uff3a'\n-    | '\\uff3f'\n-    | '\\uff41' .. '\\uff5a'\n-    | '\\uff65' .. '\\uffbe'\n-    | '\\uffc2' .. '\\uffc7'\n-    | '\\uffca' .. '\\uffcf'\n-    | '\\uffd2' .. '\\uffd7'\n-    | '\\uffda' .. '\\uffdc'\n-    | '\\ud800' '\\udc00' .. '\\udc0a'\n-    | '\\ud800' '\\udc0d' .. '\\udc25'\n-    | '\\ud800' '\\udc28' .. '\\udc39'\n-    | '\\ud800' '\\udc3c' .. '\\udc3c'\n-    | '\\ud800' '\\udc3f' .. '\\udc4c'\n-    | '\\ud800' '\\udc50' .. '\\udc5c'\n-    | '\\ud800' '\\udc80' .. '\\udcf9'\n-    | '\\ud800' '\\udf00' .. '\\udf1d'\n-    | '\\ud800' '\\udf30' .. '\\udf49'\n-    | '\\ud800' '\\udf80' .. '\\udf9c'\n-    | '\\ud801' '\\ue000' .. '\\ue09c'\n-    | '\\ud801' '\\ue0a0' .. '\\ue0a8'\n-    | '\\ud802' '\\ue400' .. '\\ue404'\n-    | '\\ud802' '\\u0808'\n-    | '\\ud802' '\\ue40a' .. '\\ue434'\n-    | '\\ud802' '\\ue437' .. '\\ue437'\n-    | '\\ud802' '\\u083c'\n-    | '\\ud802' '\\u083f'\n-    | '\\ud834' '\\uad65' .. '\\uad68'\n-    | '\\ud834' '\\uad6d' .. '\\uad71'\n-    | '\\ud834' '\\uad7b' .. '\\uad81'\n-    | '\\ud834' '\\uad85' .. '\\uad8a'\n-    | '\\ud834' '\\uadaa' .. '\\uadac'\n-    | '\\ud835' '\\ub000' .. '\\ub053'\n-    | '\\ud835' '\\ub056' .. '\\ub09b'\n-    | '\\ud835' '\\ub09e' .. '\\ub09e'\n-    | '\\ud835' '\\ud4a2'\n-    | '\\ud835' '\\ub0a5' .. '\\ub0a5'\n-    | '\\ud835' '\\ub0a9' .. '\\ub0ab'\n-    | '\\ud835' '\\ub0ae' .. '\\ub0b8'\n-    | '\\ud835' '\\ud4bb'\n-    | '\\ud835' '\\ub0bd' .. '\\ub0c2'\n-    | '\\ud835' '\\ub0c5' .. '\\ub104'\n-    | '\\ud835' '\\ub107' .. '\\ub109'\n-    | '\\ud835' '\\ub10d' .. '\\ub113'\n-    | '\\ud835' '\\ub116' .. '\\ub11b'\n-    | '\\ud835' '\\ub11e' .. '\\ub138'\n-    | '\\ud835' '\\ub13b' .. '\\ub13d'\n-    | '\\ud835' '\\ub140' .. '\\ub143'\n-    | '\\ud835' '\\ud546'\n-    | '\\ud835' '\\ub14a' .. '\\ub14f'\n-    | '\\ud835' '\\ub152' .. '\\ub2a2'\n-    | '\\ud835' '\\ub2a8' .. '\\ub2bf'\n-    | '\\ud835' '\\ub2c2' .. '\\ub2d9'\n-    | '\\ud835' '\\ub2dc' .. '\\ub2f9'\n-    | '\\ud835' '\\ub2fc' .. '\\ub313'\n-    | '\\ud835' '\\ub316' .. '\\ub333'\n-    | '\\ud835' '\\ub336' .. '\\ub34d'\n-    | '\\ud835' '\\ub350' .. '\\ub36d'\n-    | '\\ud835' '\\ub370' .. '\\ub387'\n-    | '\\ud835' '\\ub38a' .. '\\ub3a7'\n-    | '\\ud835' '\\ub3aa' .. '\\ub3c1'\n-    | '\\ud835' '\\ub3c4' .. '\\ub3c8'\n-    | '\\ud835' '\\ub3ce' .. '\\ub3fe'\n-    | '\\ud840' '\\udc00' .. '\\udffe'\n-    | '\\ud841' '\\ue000' .. '\\ue3fe'\n-    | '\\ud842' '\\ue400' .. '\\ue7fe'\n-    | '\\ud843' '\\ue800' .. '\\uebfe'\n-    | '\\ud844' '\\uec00' .. '\\ueffe'\n-    | '\\ud845' '\\uf000' .. '\\uf3fe'\n-    | '\\ud846' '\\uf400' .. '\\uf7fe'\n-    | '\\ud847' '\\uf800' .. '\\ufbfe'\n-    | '\\ud848' '\\ufc00' .. '\\ufffe'\n-    | '\\ud849' '\\u0000' .. '\\u03fe'\n-    | '\\ud84a' '\\u0400' .. '\\u07fe'\n-    | '\\ud84b' '\\u0800' .. '\\u0bfe'\n-    | '\\ud84c' '\\u0c00' .. '\\u0ffe'\n-    | '\\ud84d' '\\u1000' .. '\\u13fe'\n-    | '\\ud84e' '\\u1400' .. '\\u17fe'\n-    | '\\ud84f' '\\u1800' .. '\\u1bfe'\n-    | '\\ud850' '\\u1c00' .. '\\u1ffe'\n-    | '\\ud851' '\\u2000' .. '\\u23fe'\n-    | '\\ud852' '\\u2400' .. '\\u27fe'\n-    | '\\ud853' '\\u2800' .. '\\u2bfe'\n-    | '\\ud854' '\\u2c00' .. '\\u2ffe'\n-    | '\\ud855' '\\u3000' .. '\\u33fe'\n-    | '\\ud856' '\\u3400' .. '\\u37fe'\n-    | '\\ud857' '\\u3800' .. '\\u3bfe'\n-    | '\\ud858' '\\u3c00' .. '\\u3ffe'\n-    | '\\ud859' '\\u4000' .. '\\u43fe'\n-    | '\\ud85a' '\\u4400' .. '\\u47fe'\n-    | '\\ud85b' '\\u4800' .. '\\u4bfe'\n-    | '\\ud85c' '\\u4c00' .. '\\u4ffe'\n-    | '\\ud85d' '\\u5000' .. '\\u53fe'\n-    | '\\ud85e' '\\u5400' .. '\\u57fe'\n-    | '\\ud85f' '\\u5800' .. '\\u5bfe'\n-    | '\\ud860' '\\u5c00' .. '\\u5ffe'\n-    | '\\ud861' '\\u6000' .. '\\u63fe'\n-    | '\\ud862' '\\u6400' .. '\\u67fe'\n-    | '\\ud863' '\\u6800' .. '\\u6bfe'\n-    | '\\ud864' '\\u6c00' .. '\\u6ffe'\n-    | '\\ud865' '\\u7000' .. '\\u73fe'\n-    | '\\ud866' '\\u7400' .. '\\u77fe'\n-    | '\\ud867' '\\u7800' .. '\\u7bfe'\n-    | '\\ud868' '\\u7c00' .. '\\u7ffe'\n-    | '\\ud869' '\\u8000' .. '\\u82d5'\n-    | '\\ud87e' '\\ud400' .. '\\ud61c'\n-    | '\\udb40' '\\udd00' .. '\\uddee'\n-    ;"}, {"sha": "53fb50f4584d2d65eee0b77d8f9f090cc47abeed", "filename": "src/grammar/xidstart.g4", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fxidstart.g4", "raw_url": "https://github.com/rust-lang/rust/raw/a4761639e83309060c2542aca68a619d0c938c3f/src%2Fgrammar%2Fxidstart.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fxidstart.g4?ref=a4761639e83309060c2542aca68a619d0c938c3f", "patch": "@@ -1,379 +0,0 @@\n-lexer grammar Xidstart;\n-\n-fragment XID_Start :\n-      '\\u0041' .. '\\u005a'\n-    | '_'\n-    | '\\u0061' .. '\\u007a'\n-    | '\\u00aa'\n-    | '\\u00b5'\n-    | '\\u00ba'\n-    | '\\u00c0' .. '\\u00d6'\n-    | '\\u00d8' .. '\\u00f6'\n-    | '\\u00f8' .. '\\u0236'\n-    | '\\u0250' .. '\\u02c1'\n-    | '\\u02c6' .. '\\u02d1'\n-    | '\\u02e0' .. '\\u02e4'\n-    | '\\u02ee'\n-    | '\\u0386'\n-    | '\\u0388' .. '\\u038a'\n-    | '\\u038c'\n-    | '\\u038e' .. '\\u03a1'\n-    | '\\u03a3' .. '\\u03ce'\n-    | '\\u03d0' .. '\\u03f5'\n-    | '\\u03f7' .. '\\u03fb'\n-    | '\\u0400' .. '\\u0481'\n-    | '\\u048a' .. '\\u04ce'\n-    | '\\u04d0' .. '\\u04f5'\n-    | '\\u04f8' .. '\\u04f9'\n-    | '\\u0500' .. '\\u050f'\n-    | '\\u0531' .. '\\u0556'\n-    | '\\u0559'\n-    | '\\u0561' .. '\\u0587'\n-    | '\\u05d0' .. '\\u05ea'\n-    | '\\u05f0' .. '\\u05f2'\n-    | '\\u0621' .. '\\u063a'\n-    | '\\u0640' .. '\\u064a'\n-    | '\\u066e' .. '\\u066f'\n-    | '\\u0671' .. '\\u06d3'\n-    | '\\u06d5'\n-    | '\\u06e5' .. '\\u06e6'\n-    | '\\u06ee' .. '\\u06ef'\n-    | '\\u06fa' .. '\\u06fc'\n-    | '\\u06ff'\n-    | '\\u0710'\n-    | '\\u0712' .. '\\u072f'\n-    | '\\u074d' .. '\\u074f'\n-    | '\\u0780' .. '\\u07a5'\n-    | '\\u07b1'\n-    | '\\u0904' .. '\\u0939'\n-    | '\\u093d'\n-    | '\\u0950'\n-    | '\\u0958' .. '\\u0961'\n-    | '\\u0985' .. '\\u098c'\n-    | '\\u098f' .. '\\u0990'\n-    | '\\u0993' .. '\\u09a8'\n-    | '\\u09aa' .. '\\u09b0'\n-    | '\\u09b2'\n-    | '\\u09b6' .. '\\u09b9'\n-    | '\\u09bd'\n-    | '\\u09dc' .. '\\u09dd'\n-    | '\\u09df' .. '\\u09e1'\n-    | '\\u09f0' .. '\\u09f1'\n-    | '\\u0a05' .. '\\u0a0a'\n-    | '\\u0a0f' .. '\\u0a10'\n-    | '\\u0a13' .. '\\u0a28'\n-    | '\\u0a2a' .. '\\u0a30'\n-    | '\\u0a32' .. '\\u0a33'\n-    | '\\u0a35' .. '\\u0a36'\n-    | '\\u0a38' .. '\\u0a39'\n-    | '\\u0a59' .. '\\u0a5c'\n-    | '\\u0a5e'\n-    | '\\u0a72' .. '\\u0a74'\n-    | '\\u0a85' .. '\\u0a8d'\n-    | '\\u0a8f' .. '\\u0a91'\n-    | '\\u0a93' .. '\\u0aa8'\n-    | '\\u0aaa' .. '\\u0ab0'\n-    | '\\u0ab2' .. '\\u0ab3'\n-    | '\\u0ab5' .. '\\u0ab9'\n-    | '\\u0abd'\n-    | '\\u0ad0'\n-    | '\\u0ae0' .. '\\u0ae1'\n-    | '\\u0b05' .. '\\u0b0c'\n-    | '\\u0b0f' .. '\\u0b10'\n-    | '\\u0b13' .. '\\u0b28'\n-    | '\\u0b2a' .. '\\u0b30'\n-    | '\\u0b32' .. '\\u0b33'\n-    | '\\u0b35' .. '\\u0b39'\n-    | '\\u0b3d'\n-    | '\\u0b5c' .. '\\u0b5d'\n-    | '\\u0b5f' .. '\\u0b61'\n-    | '\\u0b71'\n-    | '\\u0b83'\n-    | '\\u0b85' .. '\\u0b8a'\n-    | '\\u0b8e' .. '\\u0b90'\n-    | '\\u0b92' .. '\\u0b95'\n-    | '\\u0b99' .. '\\u0b9a'\n-    | '\\u0b9c'\n-    | '\\u0b9e' .. '\\u0b9f'\n-    | '\\u0ba3' .. '\\u0ba4'\n-    | '\\u0ba8' .. '\\u0baa'\n-    | '\\u0bae' .. '\\u0bb5'\n-    | '\\u0bb7' .. '\\u0bb9'\n-    | '\\u0c05' .. '\\u0c0c'\n-    | '\\u0c0e' .. '\\u0c10'\n-    | '\\u0c12' .. '\\u0c28'\n-    | '\\u0c2a' .. '\\u0c33'\n-    | '\\u0c35' .. '\\u0c39'\n-    | '\\u0c60' .. '\\u0c61'\n-    | '\\u0c85' .. '\\u0c8c'\n-    | '\\u0c8e' .. '\\u0c90'\n-    | '\\u0c92' .. '\\u0ca8'\n-    | '\\u0caa' .. '\\u0cb3'\n-    | '\\u0cb5' .. '\\u0cb9'\n-    | '\\u0cbd'\n-    | '\\u0cde'\n-    | '\\u0ce0' .. '\\u0ce1'\n-    | '\\u0d05' .. '\\u0d0c'\n-    | '\\u0d0e' .. '\\u0d10'\n-    | '\\u0d12' .. '\\u0d28'\n-    | '\\u0d2a' .. '\\u0d39'\n-    | '\\u0d60' .. '\\u0d61'\n-    | '\\u0d85' .. '\\u0d96'\n-    | '\\u0d9a' .. '\\u0db1'\n-    | '\\u0db3' .. '\\u0dbb'\n-    | '\\u0dbd'\n-    | '\\u0dc0' .. '\\u0dc6'\n-    | '\\u0e01' .. '\\u0e30'\n-    | '\\u0e32'\n-    | '\\u0e40' .. '\\u0e46'\n-    | '\\u0e81' .. '\\u0e82'\n-    | '\\u0e84'\n-    | '\\u0e87' .. '\\u0e88'\n-    | '\\u0e8a'\n-    | '\\u0e8d'\n-    | '\\u0e94' .. '\\u0e97'\n-    | '\\u0e99' .. '\\u0e9f'\n-    | '\\u0ea1' .. '\\u0ea3'\n-    | '\\u0ea5'\n-    | '\\u0ea7'\n-    | '\\u0eaa' .. '\\u0eab'\n-    | '\\u0ead' .. '\\u0eb0'\n-    | '\\u0eb2'\n-    | '\\u0ebd'\n-    | '\\u0ec0' .. '\\u0ec4'\n-    | '\\u0ec6'\n-    | '\\u0edc' .. '\\u0edd'\n-    | '\\u0f00'\n-    | '\\u0f40' .. '\\u0f47'\n-    | '\\u0f49' .. '\\u0f6a'\n-    | '\\u0f88' .. '\\u0f8b'\n-    | '\\u1000' .. '\\u1021'\n-    | '\\u1023' .. '\\u1027'\n-    | '\\u1029' .. '\\u102a'\n-    | '\\u1050' .. '\\u1055'\n-    | '\\u10a0' .. '\\u10c5'\n-    | '\\u10d0' .. '\\u10f8'\n-    | '\\u1100' .. '\\u1159'\n-    | '\\u115f' .. '\\u11a2'\n-    | '\\u11a8' .. '\\u11f9'\n-    | '\\u1200' .. '\\u1206'\n-    | '\\u1208' .. '\\u1246'\n-    | '\\u1248'\n-    | '\\u124a' .. '\\u124d'\n-    | '\\u1250' .. '\\u1256'\n-    | '\\u1258'\n-    | '\\u125a' .. '\\u125d'\n-    | '\\u1260' .. '\\u1286'\n-    | '\\u1288'\n-    | '\\u128a' .. '\\u128d'\n-    | '\\u1290' .. '\\u12ae'\n-    | '\\u12b0'\n-    | '\\u12b2' .. '\\u12b5'\n-    | '\\u12b8' .. '\\u12be'\n-    | '\\u12c0'\n-    | '\\u12c2' .. '\\u12c5'\n-    | '\\u12c8' .. '\\u12ce'\n-    | '\\u12d0' .. '\\u12d6'\n-    | '\\u12d8' .. '\\u12ee'\n-    | '\\u12f0' .. '\\u130e'\n-    | '\\u1310'\n-    | '\\u1312' .. '\\u1315'\n-    | '\\u1318' .. '\\u131e'\n-    | '\\u1320' .. '\\u1346'\n-    | '\\u1348' .. '\\u135a'\n-    | '\\u13a0' .. '\\u13f4'\n-    | '\\u1401' .. '\\u166c'\n-    | '\\u166f' .. '\\u1676'\n-    | '\\u1681' .. '\\u169a'\n-    | '\\u16a0' .. '\\u16ea'\n-    | '\\u16ee' .. '\\u16f0'\n-    | '\\u1700' .. '\\u170c'\n-    | '\\u170e' .. '\\u1711'\n-    | '\\u1720' .. '\\u1731'\n-    | '\\u1740' .. '\\u1751'\n-    | '\\u1760' .. '\\u176c'\n-    | '\\u176e' .. '\\u1770'\n-    | '\\u1780' .. '\\u17b3'\n-    | '\\u17d7'\n-    | '\\u17dc'\n-    | '\\u1820' .. '\\u1877'\n-    | '\\u1880' .. '\\u18a8'\n-    | '\\u1900' .. '\\u191c'\n-    | '\\u1950' .. '\\u196d'\n-    | '\\u1970' .. '\\u1974'\n-    | '\\u1d00' .. '\\u1d6b'\n-    | '\\u1e00' .. '\\u1e9b'\n-    | '\\u1ea0' .. '\\u1ef9'\n-    | '\\u1f00' .. '\\u1f15'\n-    | '\\u1f18' .. '\\u1f1d'\n-    | '\\u1f20' .. '\\u1f45'\n-    | '\\u1f48' .. '\\u1f4d'\n-    | '\\u1f50' .. '\\u1f57'\n-    | '\\u1f59'\n-    | '\\u1f5b'\n-    | '\\u1f5d'\n-    | '\\u1f5f' .. '\\u1f7d'\n-    | '\\u1f80' .. '\\u1fb4'\n-    | '\\u1fb6' .. '\\u1fbc'\n-    | '\\u1fbe'\n-    | '\\u1fc2' .. '\\u1fc4'\n-    | '\\u1fc6' .. '\\u1fcc'\n-    | '\\u1fd0' .. '\\u1fd3'\n-    | '\\u1fd6' .. '\\u1fdb'\n-    | '\\u1fe0' .. '\\u1fec'\n-    | '\\u1ff2' .. '\\u1ff4'\n-    | '\\u1ff6' .. '\\u1ffc'\n-    | '\\u2071'\n-    | '\\u207f'\n-    | '\\u2102'\n-    | '\\u2107'\n-    | '\\u210a' .. '\\u2113'\n-    | '\\u2115'\n-    | '\\u2118' .. '\\u211d'\n-    | '\\u2124'\n-    | '\\u2126'\n-    | '\\u2128'\n-    | '\\u212a' .. '\\u2131'\n-    | '\\u2133' .. '\\u2139'\n-    | '\\u213d' .. '\\u213f'\n-    | '\\u2145' .. '\\u2149'\n-    | '\\u2160' .. '\\u2183'\n-    | '\\u3005' .. '\\u3007'\n-    | '\\u3021' .. '\\u3029'\n-    | '\\u3031' .. '\\u3035'\n-    | '\\u3038' .. '\\u303c'\n-    | '\\u3041' .. '\\u3096'\n-    | '\\u309d' .. '\\u309f'\n-    | '\\u30a1' .. '\\u30fa'\n-    | '\\u30fc' .. '\\u30ff'\n-    | '\\u3105' .. '\\u312c'\n-    | '\\u3131' .. '\\u318e'\n-    | '\\u31a0' .. '\\u31b7'\n-    | '\\u31f0' .. '\\u31ff'\n-    | '\\u3400' .. '\\u4db5'\n-    | '\\u4e00' .. '\\u9fa5'\n-    | '\\ua000' .. '\\ua48c'\n-    | '\\uac00' .. '\\ud7a3'\n-    | '\\uf900' .. '\\ufa2d'\n-    | '\\ufa30' .. '\\ufa6a'\n-    | '\\ufb00' .. '\\ufb06'\n-    | '\\ufb13' .. '\\ufb17'\n-    | '\\ufb1d'\n-    | '\\ufb1f' .. '\\ufb28'\n-    | '\\ufb2a' .. '\\ufb36'\n-    | '\\ufb38' .. '\\ufb3c'\n-    | '\\ufb3e'\n-    | '\\ufb40' .. '\\ufb41'\n-    | '\\ufb43' .. '\\ufb44'\n-    | '\\ufb46' .. '\\ufbb1'\n-    | '\\ufbd3' .. '\\ufc5d'\n-    | '\\ufc64' .. '\\ufd3d'\n-    | '\\ufd50' .. '\\ufd8f'\n-    | '\\ufd92' .. '\\ufdc7'\n-    | '\\ufdf0' .. '\\ufdf9'\n-    | '\\ufe71'\n-    | '\\ufe73'\n-    | '\\ufe77'\n-    | '\\ufe79'\n-    | '\\ufe7b'\n-    | '\\ufe7d'\n-    | '\\ufe7f' .. '\\ufefc'\n-    | '\\uff21' .. '\\uff3a'\n-    | '\\uff41' .. '\\uff5a'\n-    | '\\uff66' .. '\\uff9d'\n-    | '\\uffa0' .. '\\uffbe'\n-    | '\\uffc2' .. '\\uffc7'\n-    | '\\uffca' .. '\\uffcf'\n-    | '\\uffd2' .. '\\uffd7'\n-    | '\\uffda' .. '\\uffdc'\n-    | '\\ud800' '\\udc00' .. '\\udc0a'\n-    | '\\ud800' '\\udc0d' .. '\\udc25'\n-    | '\\ud800' '\\udc28' .. '\\udc39'\n-    | '\\ud800' '\\udc3c' .. '\\udc3c'\n-    | '\\ud800' '\\udc3f' .. '\\udc4c'\n-    | '\\ud800' '\\udc50' .. '\\udc5c'\n-    | '\\ud800' '\\udc80' .. '\\udcf9'\n-    | '\\ud800' '\\udf00' .. '\\udf1d'\n-    | '\\ud800' '\\udf30' .. '\\udf49'\n-    | '\\ud800' '\\udf80' .. '\\udf9c'\n-    | '\\ud801' '\\ue000' .. '\\ue09c'\n-    | '\\ud802' '\\ue400' .. '\\ue404'\n-    | '\\ud802' '\\u0808'\n-    | '\\ud802' '\\ue40a' .. '\\ue434'\n-    | '\\ud802' '\\ue437' .. '\\ue437'\n-    | '\\ud802' '\\u083c'\n-    | '\\ud802' '\\u083f'\n-    | '\\ud835' '\\ub000' .. '\\ub053'\n-    | '\\ud835' '\\ub056' .. '\\ub09b'\n-    | '\\ud835' '\\ub09e' .. '\\ub09e'\n-    | '\\ud835' '\\ud4a2'\n-    | '\\ud835' '\\ub0a5' .. '\\ub0a5'\n-    | '\\ud835' '\\ub0a9' .. '\\ub0ab'\n-    | '\\ud835' '\\ub0ae' .. '\\ub0b8'\n-    | '\\ud835' '\\ud4bb'\n-    | '\\ud835' '\\ub0bd' .. '\\ub0c2'\n-    | '\\ud835' '\\ub0c5' .. '\\ub104'\n-    | '\\ud835' '\\ub107' .. '\\ub109'\n-    | '\\ud835' '\\ub10d' .. '\\ub113'\n-    | '\\ud835' '\\ub116' .. '\\ub11b'\n-    | '\\ud835' '\\ub11e' .. '\\ub138'\n-    | '\\ud835' '\\ub13b' .. '\\ub13d'\n-    | '\\ud835' '\\ub140' .. '\\ub143'\n-    | '\\ud835' '\\ud546'\n-    | '\\ud835' '\\ub14a' .. '\\ub14f'\n-    | '\\ud835' '\\ub152' .. '\\ub2a2'\n-    | '\\ud835' '\\ub2a8' .. '\\ub2bf'\n-    | '\\ud835' '\\ub2c2' .. '\\ub2d9'\n-    | '\\ud835' '\\ub2dc' .. '\\ub2f9'\n-    | '\\ud835' '\\ub2fc' .. '\\ub313'\n-    | '\\ud835' '\\ub316' .. '\\ub333'\n-    | '\\ud835' '\\ub336' .. '\\ub34d'\n-    | '\\ud835' '\\ub350' .. '\\ub36d'\n-    | '\\ud835' '\\ub370' .. '\\ub387'\n-    | '\\ud835' '\\ub38a' .. '\\ub3a7'\n-    | '\\ud835' '\\ub3aa' .. '\\ub3c1'\n-    | '\\ud835' '\\ub3c4' .. '\\ub3c8'\n-    | '\\ud840' '\\udc00' .. '\\udffe'\n-    | '\\ud841' '\\ue000' .. '\\ue3fe'\n-    | '\\ud842' '\\ue400' .. '\\ue7fe'\n-    | '\\ud843' '\\ue800' .. '\\uebfe'\n-    | '\\ud844' '\\uec00' .. '\\ueffe'\n-    | '\\ud845' '\\uf000' .. '\\uf3fe'\n-    | '\\ud846' '\\uf400' .. '\\uf7fe'\n-    | '\\ud847' '\\uf800' .. '\\ufbfe'\n-    | '\\ud848' '\\ufc00' .. '\\ufffe'\n-    | '\\ud849' '\\u0000' .. '\\u03fe'\n-    | '\\ud84a' '\\u0400' .. '\\u07fe'\n-    | '\\ud84b' '\\u0800' .. '\\u0bfe'\n-    | '\\ud84c' '\\u0c00' .. '\\u0ffe'\n-    | '\\ud84d' '\\u1000' .. '\\u13fe'\n-    | '\\ud84e' '\\u1400' .. '\\u17fe'\n-    | '\\ud84f' '\\u1800' .. '\\u1bfe'\n-    | '\\ud850' '\\u1c00' .. '\\u1ffe'\n-    | '\\ud851' '\\u2000' .. '\\u23fe'\n-    | '\\ud852' '\\u2400' .. '\\u27fe'\n-    | '\\ud853' '\\u2800' .. '\\u2bfe'\n-    | '\\ud854' '\\u2c00' .. '\\u2ffe'\n-    | '\\ud855' '\\u3000' .. '\\u33fe'\n-    | '\\ud856' '\\u3400' .. '\\u37fe'\n-    | '\\ud857' '\\u3800' .. '\\u3bfe'\n-    | '\\ud858' '\\u3c00' .. '\\u3ffe'\n-    | '\\ud859' '\\u4000' .. '\\u43fe'\n-    | '\\ud85a' '\\u4400' .. '\\u47fe'\n-    | '\\ud85b' '\\u4800' .. '\\u4bfe'\n-    | '\\ud85c' '\\u4c00' .. '\\u4ffe'\n-    | '\\ud85d' '\\u5000' .. '\\u53fe'\n-    | '\\ud85e' '\\u5400' .. '\\u57fe'\n-    | '\\ud85f' '\\u5800' .. '\\u5bfe'\n-    | '\\ud860' '\\u5c00' .. '\\u5ffe'\n-    | '\\ud861' '\\u6000' .. '\\u63fe'\n-    | '\\ud862' '\\u6400' .. '\\u67fe'\n-    | '\\ud863' '\\u6800' .. '\\u6bfe'\n-    | '\\ud864' '\\u6c00' .. '\\u6ffe'\n-    | '\\ud865' '\\u7000' .. '\\u73fe'\n-    | '\\ud866' '\\u7400' .. '\\u77fe'\n-    | '\\ud867' '\\u7800' .. '\\u7bfe'\n-    | '\\ud868' '\\u7c00' .. '\\u7ffe'\n-    | '\\ud869' '\\u8000' .. '\\u82d5'\n-    | '\\ud87e' '\\ud400' .. '\\ud61c'\n-    ;"}]}