{"sha": "5e6d7871c656145a5530b653882a3ce26f40c163", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNmQ3ODcxYzY1NjE0NWE1NTMwYjY1Mzg4MmEzY2UyNmY0MGMxNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T21:18:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-13T21:18:38Z"}, "message": "auto merge of #4840 : jbclements/rust/add-json-enum-encoding, r=catamorphism\n\nr?\r\n\r\nI added code to the JSON encoder to support the serialization of enums.  Before this, the JSON serializer only handled Option, and encoded None as 'null'. Following this change, all enums are encoded as arrays containing the enum name followed by the encoded fields. This appears consistent with the unstated invariant that the resulting output can be mapped back to the input *if* there's a decoder around that knows the types that were in existence when the serialization occurred.\r\n\r\nAlso, added test cases.", "tree": {"sha": "b1e167790741751fe1823d39c5c36a3e08bafdf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1e167790741751fe1823d39c5c36a3e08bafdf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e6d7871c656145a5530b653882a3ce26f40c163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6d7871c656145a5530b653882a3ce26f40c163", "html_url": "https://github.com/rust-lang/rust/commit/5e6d7871c656145a5530b653882a3ce26f40c163", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e6d7871c656145a5530b653882a3ce26f40c163/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7393fde763484ec504399667c1808dc8c5a3559f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7393fde763484ec504399667c1808dc8c5a3559f", "html_url": "https://github.com/rust-lang/rust/commit/7393fde763484ec504399667c1808dc8c5a3559f"}, {"sha": "9df11ae83f8bfc06bc9bd1dc2132e344bc1ed0c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9df11ae83f8bfc06bc9bd1dc2132e344bc1ed0c7", "html_url": "https://github.com/rust-lang/rust/commit/9df11ae83f8bfc06bc9bd1dc2132e344bc1ed0c7"}], "stats": {"total": 288, "additions": 269, "deletions": 19}, "files": [{"sha": "d5ad2f7fce735c62089f0af830458aeaf4d276bd", "filename": "src/libstd/json.rs", "status": "modified", "additions": 107, "deletions": 8, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5e6d7871c656145a5530b653882a3ce26f40c163/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6d7871c656145a5530b653882a3ce26f40c163/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=5e6d7871c656145a5530b653882a3ce26f40c163", "patch": "@@ -121,26 +121,57 @@ pub impl Encoder: serialize::Encoder {\n     fn emit_owned(&self, f: fn()) { f() }\n     fn emit_managed(&self, f: fn()) { f() }\n \n-    fn emit_enum(&self, name: &str, f: fn()) {\n-        if name != \"option\" { die!(~\"only supports option enum\") }\n+    fn emit_enum(&self, _name: &str, f: fn()) {\n         f()\n     }\n-    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n-        if id == 0 {\n-            self.emit_nil();\n+\n+    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: fn()) {\n+        // encoding of enums is special-cased for Option. Specifically:\n+        // Some(34) => 34\n+        // None => null\n+\n+        // other enums are encoded as vectors:\n+        // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n+\n+        // the default expansion for enums is more verbose than I'd like;\n+        // specifically, the inner pair of brackets seems superfluous,\n+        // BUT the design of the enumeration framework and the requirements\n+        // of the special-case for Option mean that a first argument must\n+        // be encoded \"naked\"--with no commas--and that the option name\n+        // can't be followed by just a comma, because there might not\n+        // be any elements in the tuple.\n+\n+        // FIXME #4872: this would be more precise and less frightening\n+        // with fully-qualified option names. To get that information,\n+        // we'd have to change the expansion of auto-encode to pass\n+        // those along.\n+\n+        if (name == ~\"Some\") {\n+            f();\n+        } else if (name == ~\"None\") {\n+            self.wr.write_str(~\"null\");\n         } else {\n-            f()\n+            self.wr.write_char('[');\n+            self.wr.write_str(escape_str(name));\n+            self.wr.write_char(',');\n+            self.wr.write_char('[');\n+            f();\n+            self.wr.write_char(']');\n+            self.wr.write_char(']');\n         }\n     }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) {\n-        f()\n+\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+        if (idx != 0) {self.wr.write_char(',');}\n+        f();\n     }\n \n     fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n         self.wr.write_char('[');\n         f();\n         self.wr.write_char(']');\n     }\n+\n     fn emit_owned_vec(&self, len: uint, f: fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n@@ -1180,6 +1211,8 @@ mod tests {\n \n     use core::result;\n     use core::hashmap::linear::LinearMap;\n+    use core::cmp;\n+\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n         let mut d = ~LinearMap::new();\n@@ -1247,6 +1280,72 @@ mod tests {\n         assert a == b;\n     }\n \n+    // two fns copied from libsyntax/util/testing.rs.\n+    // Should they be in their own crate?\n+    pub pure fn check_equal_ptr<T : cmp::Eq> (given : &T, expected: &T) {\n+        if !((given == expected) && (expected == given )) {\n+            die!(fmt!(\"given %?, expected %?\",given,expected));\n+        }\n+    }\n+\n+    pub pure fn check_equal<T : cmp::Eq> (given : T, expected: T) {\n+        if !((given == expected) && (expected == given )) {\n+            die!(fmt!(\"given %?, expected %?\",given,expected));\n+        }\n+    }\n+\n+    // testing both auto_encode's calling patterns\n+    // and json... not sure where to put these tests.\n+    #[test]\n+    fn test_write_enum () {\n+        let bw = @io::BytesWriter {bytes: dvec::DVec(), pos: 0};\n+        let bww : @io::Writer = (bw as @io::Writer);\n+        let encoder = (@Encoder(bww) as @serialize::Encoder);\n+        do encoder.emit_enum(~\"animal\") {\n+            do encoder.emit_enum_variant (~\"frog\",37,1242) {\n+                // name of frog:\n+                do encoder.emit_enum_variant_arg (0) {\n+                    encoder.emit_owned_str(~\"Henry\")\n+                }\n+                // mass of frog in grams:\n+                do encoder.emit_enum_variant_arg (1) {\n+                    encoder.emit_int(349);\n+                }\n+            }\n+        }\n+        check_equal(str::from_bytes(bw.bytes.data),\n+                    ~\"[\\\"frog\\\",[\\\"Henry\\\",349]]\");\n+    }\n+\n+    #[test]\n+    fn test_write_some () {\n+        let bw = @io::BytesWriter {bytes: dvec::DVec(), pos: 0};\n+        let bww : @io::Writer = (bw as @io::Writer);\n+        let encoder = (@Encoder(bww) as @serialize::Encoder);\n+        do encoder.emit_enum(~\"Option\") {\n+            do encoder.emit_enum_variant (~\"Some\",37,1242) {\n+                do encoder.emit_enum_variant_arg (0) {\n+                    encoder.emit_owned_str(~\"jodhpurs\")\n+                }\n+            }\n+        }\n+        check_equal(str::from_bytes(bw.bytes.data),\n+                    ~\"\\\"jodhpurs\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_none () {\n+        let bw = @io::BytesWriter {bytes: dvec::DVec(), pos: 0};\n+        let bww : @io::Writer = (bw as @io::Writer);\n+        let encoder = (@Encoder(bww) as @serialize::Encoder);\n+        do encoder.emit_enum(~\"Option\") {\n+            do encoder.emit_enum_variant (~\"None\",37,1242) {\n+            }\n+        }\n+        check_equal(str::from_bytes(bw.bytes.data),\n+                    ~\"null\");\n+    }\n+\n     #[test]\n     fn test_trailing_characters() {\n         assert from_str(~\"nulla\") =="}, {"sha": "acbe4d7fa23ef2d5d80ae39ac9758804328e18af", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 162, "deletions": 11, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/5e6d7871c656145a5530b653882a3ce26f40c163/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e6d7871c656145a5530b653882a3ce26f40c163/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=5e6d7871c656145a5530b653882a3ce26f40c163", "patch": "@@ -23,23 +23,23 @@ For example, a type like:\n \n would generate two implementations like:\n \n-    impl<S: Encoder> node_id: Encodable<S> {\n-        fn encode(s: &S) {\n-            do s.emit_struct(\"Node\", 1) {\n-                s.emit_field(\"id\", 0, || s.emit_uint(self))\n-            }\n+impl<S: std::serialize::Encoder> Node: Encodable<S> {\n+    fn encode(&self, s: &S) {\n+        do s.emit_struct(\"Node\", 1) {\n+            s.emit_field(\"id\", 0, || s.emit_uint(self.id))\n         }\n     }\n+}\n \n-    impl<D: Decoder> node_id: Decodable {\n-        static fn decode(d: &D) -> Node {\n-            do d.read_struct(\"Node\", 1) {\n-                Node {\n-                    id: d.read_field(~\"x\", 0, || decode(d))\n-                }\n+impl<D: Decoder> node_id: Decodable {\n+    static fn decode(d: &D) -> Node {\n+        do d.read_struct(\"Node\", 1) {\n+            Node {\n+                id: d.read_field(~\"x\", 0, || decode(d))\n             }\n         }\n     }\n+}\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n@@ -1150,3 +1150,154 @@ fn mk_enum_deser_body(\n         ]\n     )\n }\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use std::serialize::Encodable;\n+    use std::serialize::Encoder;\n+    use core::dvec::*;\n+    use util::testing::*;\n+    use core::io;\n+    use core::str;\n+    use core::option::Option;\n+    use core::option::Some;\n+    use core::option::None;\n+    use std;\n+\n+    // just adding the ones I want to test, for now:\n+    #[deriving_eq]\n+    pub enum call {\n+        CallToEmitEnum(~str),\n+        CallToEmitEnumVariant(~str, uint, uint),\n+        CallToEmitEnumVariantArg(uint),\n+        CallToEmitUint(uint),\n+        CallToEmitNil,\n+        // all of the ones I was too lazy to handle:\n+        CallToOther\n+    }\n+    // using a mutable field rather than changing the\n+    // type of self in every method of every encoder everywhere.\n+    pub struct TestEncoder {mut call_log : ~[call]}\n+\n+    pub impl TestEncoder {\n+        // these self's should be &mut self's, as well....\n+        fn add_to_log (&self, c : call) {\n+            self.call_log.push(copy c);\n+        }\n+        fn add_unknown_to_log (&self) {\n+            self.add_to_log (CallToOther)\n+        }\n+    }\n+\n+    pub impl Encoder for TestEncoder {\n+        fn emit_nil(&self) { self.add_to_log(CallToEmitNil) }\n+\n+        fn emit_uint(&self, +v: uint) {self.add_to_log(CallToEmitUint(v)); }\n+        fn emit_u64(&self, +_v: u64) { self.add_unknown_to_log(); }\n+        fn emit_u32(&self, +_v: u32) { self.add_unknown_to_log(); }\n+        fn emit_u16(&self, +_v: u16) { self.add_unknown_to_log(); }\n+        fn emit_u8(&self, +_v: u8)   { self.add_unknown_to_log(); }\n+\n+        fn emit_int(&self, +_v: int) { self.add_unknown_to_log(); }\n+        fn emit_i64(&self, +_v: i64) { self.add_unknown_to_log(); }\n+        fn emit_i32(&self, +_v: i32) { self.add_unknown_to_log(); }\n+        fn emit_i16(&self, +_v: i16) { self.add_unknown_to_log(); }\n+        fn emit_i8(&self, +_v: i8)   { self.add_unknown_to_log(); }\n+\n+        fn emit_bool(&self, +_v: bool) { self.add_unknown_to_log(); }\n+\n+        fn emit_f64(&self, +_v: f64) { self.add_unknown_to_log(); }\n+        fn emit_f32(&self, +_v: f32) { self.add_unknown_to_log(); }\n+        fn emit_float(&self, +_v: float) { self.add_unknown_to_log(); }\n+\n+        fn emit_char(&self, +_v: char) { self.add_unknown_to_log(); }\n+\n+        fn emit_borrowed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n+        fn emit_owned_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n+        fn emit_managed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n+\n+        fn emit_borrowed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_owned(&self, f: fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_managed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n+\n+        fn emit_enum(&self, name: &str, f: fn()) {\n+            self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n+\n+        fn emit_enum_variant(&self, name: &str, +id: uint,\n+                             +cnt: uint, f: fn()) {\n+            self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n+            f();\n+        }\n+\n+        fn emit_enum_variant_arg(&self, +idx: uint, f: fn()) {\n+            self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n+        }\n+\n+        fn emit_borrowed_vec(&self, +_len: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n+        fn emit_owned_vec(&self, +_len: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_managed_vec(&self, +_len: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_vec_elt(&self, +_idx: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n+        fn emit_rec(&self, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_struct(&self, _name: &str, +_len: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_field(&self, _name: &str, +_idx: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n+        fn emit_tup(&self, +_len: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_tup_elt(&self, +_idx: uint, f: fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+    }\n+\n+\n+    #[auto_decode]\n+    #[auto_encode]\n+    struct Node {id: uint}\n+\n+    fn to_call_log (val: Encodable<TestEncoder>) -> ~[call] {\n+        let mut te = TestEncoder {call_log: ~[]};\n+        val.encode(&te);\n+        te.call_log\n+    }\n+/*\n+    #[test] fn encode_test () {\n+        check_equal (to_call_log(Node{id:34}\n+                                 as Encodable::<std::json::Encoder>),\n+                     ~[CallToEnum (~\"Node\"),\n+                       CallToEnumVariant]);\n+    }\n+*/\n+    #[auto_encode]\n+    enum Written {\n+        Book(uint,uint),\n+        Magazine(~str)\n+    }\n+\n+    #[test] fn encode_enum_test () {\n+        check_equal (to_call_log(Book(34,44)\n+                                 as Encodable::<TestEncoder>),\n+                     ~[CallToEmitEnum (~\"Written\"),\n+                       CallToEmitEnumVariant (~\"Book\",0,2),\n+                       CallToEmitEnumVariantArg (0),\n+                       CallToEmitUint (34),\n+                       CallToEmitEnumVariantArg (1),\n+                       CallToEmitUint (44)]);\n+        }\n+}"}]}