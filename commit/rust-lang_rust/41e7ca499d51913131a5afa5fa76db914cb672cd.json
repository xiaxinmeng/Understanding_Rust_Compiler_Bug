{"sha": "41e7ca499d51913131a5afa5fa76db914cb672cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZTdjYTQ5OWQ1MTkxMzEzMWE1YWZhNWZhNzZkYjkxNGNiNjcyY2Q=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-25T23:03:15Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Inline `specialize_one_pattern`", "tree": {"sha": "3f97b781ac70b82feb406e33125628ca8886b1ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f97b781ac70b82feb406e33125628ca8886b1ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e7ca499d51913131a5afa5fa76db914cb672cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e7ca499d51913131a5afa5fa76db914cb672cd", "html_url": "https://github.com/rust-lang/rust/commit/41e7ca499d51913131a5afa5fa76db914cb672cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e7ca499d51913131a5afa5fa76db914cb672cd/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c511955a9ff89089bff313cd8a87a6e62e2783f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c511955a9ff89089bff313cd8a87a6e62e2783f5", "html_url": "https://github.com/rust-lang/rust/commit/c511955a9ff89089bff313cd8a87a6e62e2783f5"}], "stats": {"total": 90, "additions": 39, "deletions": 51}, "files": [{"sha": "d3602dac9e854b70d11a236fc07d91d32325a585", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/41e7ca499d51913131a5afa5fa76db914cb672cd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e7ca499d51913131a5afa5fa76db914cb672cd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=41e7ca499d51913131a5afa5fa76db914cb672cd", "patch": "@@ -407,20 +407,51 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    ///\n+    /// This is the main specialization step. It expands the pattern\n+    /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n+    /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+    /// Returns `None` if the pattern does not have the given constructor.\n+    ///\n+    /// OTOH, slice patterns with a subslice pattern (tail @ ..) can be expanded into multiple\n+    /// different patterns.\n+    /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+    /// fields filled with wild patterns.\n+    ///\n+    /// This is roughly the inverse of `Constructor::apply`.\n     fn specialize_constructor(\n         &self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n-        constructor: &Constructor<'tcx>,\n+        ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n         is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_fields = specialize_one_pattern(\n-            cx,\n+        // We return `None` if `ctor` is not covered by `self.head()`. If `ctor` is known to be\n+        // derived from `self.head()`, or if `self.head()` is a wildcard, then we don't need to\n+        // check; otherwise, we compute the constructor of `self.head()` and check for constructor\n+        // inclusion.\n+        // Note that this shortcut is also necessary for correctness: a pattern should always be\n+        // specializable with its own constructor, even in cases where we refuse to inspect values like\n+        // opaque constants.\n+        if !self.head().is_wildcard() && !is_my_head_ctor {\n+            // `unwrap` is safe because `pat` is not a wildcard.\n+            let head_ctor = pat_constructor(cx.tcx, cx.param_env, self.head()).unwrap();\n+            if !ctor.is_covered_by(cx, &head_ctor, self.head().ty) {\n+                return None;\n+            }\n+        }\n+        let new_fields = ctor_wild_subpatterns.replace_with_pattern_arguments(self.head());\n+\n+        debug!(\n+            \"specialize_constructor({:#?}, {:#?}, {:#?}) = {:#?}\",\n             self.head(),\n-            constructor,\n+            ctor,\n             ctor_wild_subpatterns,\n-            is_my_head_ctor,\n-        )?;\n+            new_fields\n+        );\n+\n+        // We pop the head pattern and push the new fields extracted from the arguments of\n+        // `self.head()`.\n         Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n@@ -971,7 +1002,7 @@ impl Slice {\n /// the constructor. See also `Fields`.\n ///\n /// `pat_constructor` retrieves the constructor corresponding to a pattern.\n-/// `specialize_one_pattern` returns the list of fields corresponding to a pattern, given a\n+/// `specialize_constructor` returns the list of fields corresponding to a pattern, given a\n /// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n /// `Fields`.\n #[derive(Clone, Debug, PartialEq)]\n@@ -1195,7 +1226,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n     /// must have as many elements as this constructor's arity.\n     ///\n-    /// This is roughly the inverse of `specialize_one_pattern`.\n+    /// This is roughly the inverse of `specialize_constructor`.\n     ///\n     /// Examples:\n     /// `self`: `Constructor::Single`\n@@ -2607,46 +2638,3 @@ fn pat_constructor<'tcx>(\n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     }\n }\n-\n-/// This is the main specialization step. It expands the pattern\n-/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n-/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n-/// Returns `None` if the pattern does not have the given constructor.\n-///\n-/// OTOH, slice patterns with a subslice pattern (tail @ ..) can be expanded into multiple\n-/// different patterns.\n-/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n-/// fields filled with wild patterns.\n-///\n-/// This is roughly the inverse of `Constructor::apply`.\n-fn specialize_one_pattern<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    pat: &'p Pat<'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n-) -> Option<Fields<'p, 'tcx>> {\n-    if pat.is_wildcard() {\n-        return Some(ctor_wild_subpatterns.clone());\n-    }\n-\n-    // We return `None` if `ctor` is not covered by `pat`. If `ctor` is known to be derived from\n-    // `pat` then we don't need to check; otherwise, we compute the constructor of `pat` and check\n-    // for constructor inclusion.\n-    // Note that this shortcut is also necessary for correctness: a pattern should always be\n-    // specializable with its own constructor, even in cases where we refuse to inspect values like\n-    // opaque constants.\n-    if !is_its_own_ctor {\n-        // `unwrap` is safe because `pat` is not a wildcard.\n-        let pat_ctor = pat_constructor(cx.tcx, cx.param_env, pat).unwrap();\n-        if !ctor.is_covered_by(cx, &pat_ctor, pat.ty) {\n-            return None;\n-        }\n-    }\n-\n-    let fields = ctor_wild_subpatterns.replace_with_pattern_arguments(pat);\n-\n-    debug!(\"specialize({:#?}, {:#?}, {:#?}) = {:#?}\", pat, ctor, ctor_wild_subpatterns, fields);\n-\n-    Some(fields)\n-}"}]}