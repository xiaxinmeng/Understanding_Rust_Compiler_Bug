{"sha": "c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZmE4NzY0ZWZhNTNlZjJjNjM4M2RkZWRmOTBlZTk4MDRhMDJjNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T06:56:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T06:56:23Z"}, "message": "auto merge of #15982 : alexcrichton/rust/rustdoc-fixes, r=brson\n\nSadly there's still a lot of open issues, but this tackles some of the more pressing ones. Each commit has its own description along with the issues it closes.", "tree": {"sha": "ae0bf25823cc8e9b812d594ea27c5bc2525d2108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae0bf25823cc8e9b812d594ea27c5bc2525d2108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "html_url": "https://github.com/rust-lang/rust/commit/c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34a6a8fc59343fca718a4d7d908012d1fdc83a80", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a6a8fc59343fca718a4d7d908012d1fdc83a80", "html_url": "https://github.com/rust-lang/rust/commit/34a6a8fc59343fca718a4d7d908012d1fdc83a80"}, {"sha": "98f48630fc511c66b830571b028ebebe3911fa6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f48630fc511c66b830571b028ebebe3911fa6f", "html_url": "https://github.com/rust-lang/rust/commit/98f48630fc511c66b830571b028ebebe3911fa6f"}], "stats": {"total": 241, "additions": 158, "deletions": 83}, "files": [{"sha": "2ed32b3388f17b2932283c4f1c181ff405664df9", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -26,6 +26,7 @@ use iter::Iterator;         // NOTE(stage0): Remove after snapshot.\n use option::{Some, None};   // NOTE(stage0): Remove after snapshot.\n \n /// A type that represents a specific radix\n+#[doc(hidden)]\n trait GenericRadix {\n     /// The number of digits.\n     fn base(&self) -> u8;"}, {"sha": "2f7d766c28fa87c1e086f91fe52d02e278cdb83d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -18,6 +18,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n use rustc::middle::ty;\n+use rustc::middle::subst;\n use rustc::middle::stability;\n \n use core;\n@@ -38,7 +39,8 @@ use super::Clean;\n ///\n /// The returned value is `None` if the `id` could not be inlined, and `Some`\n /// of a vector of items if it was successfully expanded.\n-pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n+pub fn try_inline(id: ast::NodeId, into: Option<ast::Ident>)\n+                  -> Option<Vec<clean::Item>> {\n     let cx = ::ctxtkey.get().unwrap();\n     let tcx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n@@ -50,7 +52,17 @@ pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n     };\n     let did = def.def_id();\n     if ast_util::is_local(did) { return None }\n-    try_inline_def(&**cx, tcx, def)\n+    try_inline_def(&**cx, tcx, def).map(|vec| {\n+        vec.move_iter().map(|mut item| {\n+            match into {\n+                Some(into) if item.name.is_some() => {\n+                    item.name = Some(into.clean());\n+                }\n+                _ => {}\n+            }\n+            item\n+        }).collect()\n+    })\n }\n \n fn try_inline_def(cx: &core::DocContext,\n@@ -163,7 +175,7 @@ pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n     });\n \n     clean::Trait {\n-        generics: def.generics.clean(),\n+        generics: (&def.generics, subst::TypeSpace).clean(),\n         methods: methods.collect(),\n         parents: parents.collect()\n     }\n@@ -178,7 +190,7 @@ fn build_external_function(tcx: &ty::ctxt,\n             ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n             _ => fail!(\"bad function\"),\n         },\n-        generics: t.generics.clean(),\n+        generics: (&t.generics, subst::FnSpace).clean(),\n         fn_style: style,\n     }\n }\n@@ -196,7 +208,7 @@ fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: t.generics.clean(),\n+        generics: (&t.generics, subst::TypeSpace).clean(),\n         fields: fields.iter().map(|f| f.clean()).collect(),\n         fields_stripped: false,\n     }\n@@ -207,7 +219,7 @@ fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     match ty::get(t.ty).sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: t.generics.clean(),\n+                generics: (&t.generics, subst::TypeSpace).clean(),\n                 variants_stripped: false,\n                 variants: ty::enum_variants(tcx, edid).clean(),\n             })\n@@ -217,7 +229,7 @@ fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(),\n-        generics: t.generics.clean(),\n+        generics: (&t.generics, subst::TypeSpace).clean(),\n     })\n }\n \n@@ -278,6 +290,17 @@ fn build_impl(cx: &core::DocContext,\n     }\n \n     let associated_trait = csearch::get_impl_trait(tcx, did);\n+    // If this is an impl for a #[doc(hidden)] trait, be sure to not inline it.\n+    match associated_trait {\n+        Some(ref t) => {\n+            let trait_attrs = load_attrs(tcx, t.def_id);\n+            if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n+                return None\n+            }\n+        }\n+        None => {}\n+    }\n+\n     let attrs = load_attrs(tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n     let methods = csearch::get_impl_methods(&tcx.sess.cstore,\n@@ -302,7 +325,7 @@ fn build_impl(cx: &core::DocContext,\n         };\n         Some(item)\n     }).collect();\n-    Some(clean::Item {\n+    return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             derived: clean::detect_derived(attrs.as_slice()),\n             trait_: associated_trait.clean().map(|bound| {\n@@ -312,7 +335,7 @@ fn build_impl(cx: &core::DocContext,\n                 }\n             }),\n             for_: ty.ty.clean(),\n-            generics: ty.generics.clean(),\n+            generics: (&ty.generics, subst::TypeSpace).clean(),\n             methods: methods,\n         }),\n         source: clean::Span::empty(),\n@@ -321,33 +344,53 @@ fn build_impl(cx: &core::DocContext,\n         visibility: Some(ast::Inherited),\n         stability: stability::lookup(tcx, did).clean(),\n         def_id: did,\n-    })\n+    });\n+\n+    fn is_doc_hidden(a: &clean::Attribute) -> bool {\n+        match *a {\n+            clean::List(ref name, ref inner) if name.as_slice() == \"doc\" => {\n+                inner.iter().any(|a| {\n+                    match *a {\n+                        clean::Word(ref s) => s.as_slice() == \"hidden\",\n+                        _ => false,\n+                    }\n+                })\n+            }\n+            _ => false\n+        }\n+    }\n }\n \n fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n                 did: ast::DefId) -> clean::Module {\n     let mut items = Vec::new();\n+    fill_in(cx, tcx, did, &mut items);\n+    return clean::Module {\n+        items: items,\n+        is_crate: false,\n+    };\n \n     // FIXME: this doesn't handle reexports inside the module itself.\n     //        Should they be handled?\n-    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n-        if vis != ast::Public { return }\n-        match def {\n-            decoder::DlDef(def) => {\n-                match try_inline_def(cx, tcx, def) {\n-                    Some(i) => items.extend(i.move_iter()),\n-                    None => {}\n+    fn fill_in(cx: &core::DocContext, tcx: &ty::ctxt, did: ast::DefId,\n+               items: &mut Vec<clean::Item>) {\n+        csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, vis| {\n+            match def {\n+                decoder::DlDef(def::DefForeignMod(did)) => {\n+                    fill_in(cx, tcx, did, items);\n                 }\n+                decoder::DlDef(def) if vis == ast::Public => {\n+                    match try_inline_def(cx, tcx, def) {\n+                        Some(i) => items.extend(i.move_iter()),\n+                        None => {}\n+                    }\n+                }\n+                decoder::DlDef(..) => {}\n+                // All impls were inlined above\n+                decoder::DlImpl(..) => {}\n+                decoder::DlField => fail!(\"unimplemented field\"),\n             }\n-            // All impls were inlined above\n-            decoder::DlImpl(..) => {}\n-            decoder::DlField => fail!(\"unimplemented field\"),\n-        }\n-    });\n-\n-    clean::Module {\n-        items: items,\n-        is_crate: false,\n+        });\n     }\n }\n "}, {"sha": "953b736f38b435375febc999fd4775ec1a5dadb8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 53, "deletions": 42, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -653,35 +653,12 @@ impl Clean<Generics> for ast::Generics {\n     }\n }\n \n-impl Clean<Generics> for ty::Generics {\n+impl<'a> Clean<Generics> for (&'a ty::Generics, subst::ParamSpace) {\n     fn clean(&self) -> Generics {\n-        // In the type space, generics can come in one of multiple\n-        // namespaces.  This means that e.g. for fn items the type\n-        // parameters will live in FnSpace, but for types the\n-        // parameters will live in TypeSpace (trait definitions also\n-        // define a parameter in SelfSpace). *Method* definitions are\n-        // the one exception: they combine the TypeSpace parameters\n-        // from the enclosing impl/trait with their own FnSpace\n-        // parameters.\n-        //\n-        // In general, when we clean, we are trying to produce the\n-        // \"user-facing\" generics. Hence we select the most specific\n-        // namespace that is occupied, ignoring SelfSpace because it\n-        // is implicit.\n-\n-        let space = {\n-            if !self.types.is_empty_in(subst::FnSpace) ||\n-                !self.regions.is_empty_in(subst::FnSpace)\n-            {\n-                subst::FnSpace\n-            } else {\n-                subst::TypeSpace\n-            }\n-        };\n-\n+        let (me, space) = *self;\n         Generics {\n-            type_params: Vec::from_slice(self.types.get_slice(space)).clean(),\n-            lifetimes: Vec::from_slice(self.regions.get_slice(space)).clean(),\n+            type_params: Vec::from_slice(me.types.get_slice(space)).clean(),\n+            lifetimes: Vec::from_slice(me.regions.get_slice(space)).clean(),\n         }\n     }\n }\n@@ -770,7 +747,6 @@ pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfOwned,\n     SelfExplicit(Type),\n }\n \n@@ -994,28 +970,27 @@ impl Clean<Item> for ty::Method {\n     fn clean(&self) -> Item {\n         let cx = get_cx();\n         let (self_, sig) = match self.explicit_self {\n-            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n+            ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(),\n+                                               self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n                     inputs: Vec::from_slice(self.fty.sig.inputs.slice_from(1)),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {\n+                    ty::ByValueExplicitSelfCategory => SelfValue,\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n                         match ty::get(self.fty.sig.inputs[0]).sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(), mt.mutbl.clean())\n                             }\n-                            _ => {\n-                                // FIXME(pcwalton): This is wrong.\n-                                SelfStatic\n-                            }\n+                            _ => unreachable!(),\n                         }\n                     }\n-                    _ => {\n-                        // FIXME(pcwalton): This is wrong.\n-                        SelfStatic\n+                    ty::ByBoxExplicitSelfCategory => {\n+                        SelfExplicit(self.fty.sig.inputs[0].clean())\n                     }\n+                    ty::StaticExplicitSelfCategory => unreachable!(),\n                 };\n                 (s, sig)\n             }\n@@ -1030,7 +1005,7 @@ impl Clean<Item> for ty::Method {\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n-                generics: self.generics.clean(),\n+                generics: (&self.generics, subst::FnSpace).clean(),\n                 self_: self_,\n                 decl: (self.def_id, &sig).clean(),\n             })\n@@ -1236,8 +1211,18 @@ impl Clean<Type> for ty::t {\n             ty::ty_float(ast::TyF32) => Primitive(F32),\n             ty::ty_float(ast::TyF64) => Primitive(F64),\n             ty::ty_str => Primitive(Str),\n-            ty::ty_box(t) => Managed(box t.clean()),\n-            ty::ty_uniq(t) => Unique(box t.clean()),\n+            ty::ty_box(t) => {\n+                let gc_did = get_cx().tcx_opt().and_then(|tcx| {\n+                    tcx.lang_items.gc()\n+                });\n+                lang_struct(gc_did, t, \"Gc\", Managed)\n+            }\n+            ty::ty_uniq(t) => {\n+                let box_did = get_cx().tcx_opt().and_then(|tcx| {\n+                    tcx.lang_items.owned_box()\n+                });\n+                lang_struct(box_did, t, \"Box\", Unique)\n+            }\n             ty::ty_vec(mt, None) => Vector(box mt.ty.clean()),\n             ty::ty_vec(mt, Some(i)) => FixedVector(box mt.ty.clean(),\n                                                    format!(\"{}\", i)),\n@@ -1778,7 +1763,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                         // to keep any non-inlineable reexports so they can be\n                         // listed in the documentation.\n                         let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(path.node.id()) {\n+                            match inline::try_inline(path.node.id(), None) {\n                                 Some(items) => {\n                                     ret.extend(items.move_iter()); false\n                                 }\n@@ -1793,8 +1778,8 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                             ret.push(convert(&ast::ViewItemUse(box(GC) path)));\n                         }\n                     }\n-                    ast::ViewPathSimple(_, _, id) => {\n-                        match inline::try_inline(id) {\n+                    ast::ViewPathSimple(ident, _, id) => {\n+                        match inline::try_inline(id, Some(ident)) {\n                             Some(items) => ret.extend(items.move_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n@@ -2117,3 +2102,29 @@ impl Clean<Stability> for attr::Stability {\n         }\n     }\n }\n+\n+fn lang_struct(did: Option<ast::DefId>, t: ty::t, name: &str,\n+               fallback: fn(Box<Type>) -> Type) -> Type {\n+    let did = match did {\n+        Some(did) => did,\n+        None => return fallback(box t.clean()),\n+    };\n+    let fqn = csearch::get_item_path(get_cx().tcx(), did);\n+    let fqn: Vec<String> = fqn.move_iter().map(|i| {\n+        i.to_string()\n+    }).collect();\n+    get_cx().external_paths.borrow_mut().get_mut_ref()\n+                           .insert(did, (fqn, TypeStruct));\n+    ResolvedPath {\n+        typarams: None,\n+        did: did,\n+        path: Path {\n+            global: false,\n+            segments: vec![PathSegment {\n+                name: name.to_string(),\n+                lifetimes: vec![],\n+                types: vec![t.clean()],\n+            }],\n+        },\n+    }\n+}"}, {"sha": "032189dca4877323f6c6a9d6c79982192e3a1eec", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -80,7 +80,8 @@ pub struct CrateAnalysis {\n pub type Externs = HashMap<String, Vec<String>>;\n \n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs)\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>,\n+                       externs: Externs, triple: Option<String>)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n@@ -99,6 +100,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>, ext\n         crate_types: vec!(driver::config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),\n         externs: externs,\n+        target_triple: triple.unwrap_or(driver::driver::host_triple().to_string()),\n         ..rustc::driver::config::basic_options().clone()\n     };\n \n@@ -151,9 +153,10 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>, ext\n     })\n }\n \n-pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs, path: &Path)\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs,\n+                path: &Path, triple: Option<String>)\n                 -> (clean::Crate, CrateAnalysis) {\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs);\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs, triple);\n     let ctxt = box(GC) ctxt;\n     super::ctxtkey.replace(Some(ctxt));\n "}, {"sha": "c6d6843db5fb32d029f1a82b359831a32f06de62", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -444,8 +444,6 @@ impl fmt::Show for clean::Type {\n                                format!(\"[{}, ..{}]\", **t, *s).as_slice())\n             }\n             clean::Bottom => f.write(\"!\".as_bytes()),\n-            clean::Unique(ref t) => write!(f, \"Box<{}>\", **t),\n-            clean::Managed(ref t) => write!(f, \"Gc<{}>\", **t),\n             clean::RawPointer(m, ref t) => {\n                 write!(f, \"*{}{}\", RawMutableSpace(m), **t)\n             }\n@@ -456,6 +454,9 @@ impl fmt::Show for clean::Type {\n                 };\n                 write!(f, \"&amp;{}{}{}\", lt, MutableSpace(mutability), **ty)\n             }\n+            clean::Unique(..) | clean::Managed(..) => {\n+                fail!(\"should have been cleaned\")\n+            }\n         }\n     }\n }\n@@ -491,7 +492,6 @@ impl<'a> fmt::Show for Method<'a> {\n         match *selfty {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n-            clean::SelfOwned => args.push_str(\"self: Box<Self>\"),\n             clean::SelfBorrowed(Some(ref lt), mtbl) => {\n                 args.push_str(format!(\"&amp;{} {}self\", *lt,\n                                       MutableSpace(mtbl)).as_slice());"}, {"sha": "1869031dab3c2eca35df3e355089634ee1d3ef4b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -357,8 +357,8 @@\n                 }, 20);\n             });\n \n-            $(document).off('keypress.searchnav');\n-            $(document).on('keypress.searchnav', function(e) {\n+            $(document).off('keydown.searchnav');\n+            $(document).on('keydown.searchnav', function(e) {\n                 var $active = $results.filter('.highlighted');\n \n                 if (e.which === 38) { // up"}, {"sha": "a89b76572875efba87edec77401683653a17b175", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -117,6 +117,7 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n         optflag(\"\", \"test\", \"run code examples as tests\"),\n         optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n                  \"ARGS\"),\n+        optopt(\"\", \"target\", \"target triple to document\", \"TRIPLE\"),\n         optmulti(\"\", \"markdown-css\", \"CSS files to include via <link> in a rendered Markdown file\",\n                  \"FILES\"),\n         optmulti(\"\", \"html-in-header\",\n@@ -321,6 +322,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n                                  .map(|s| Path::new(s.as_slice()))\n                                  .collect();\n     let cfgs = matches.opt_strs(\"cfg\");\n+    let triple = matches.opt_str(\"target\");\n \n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n@@ -329,7 +331,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         core::run_core(libs.move_iter().collect(),\n                        cfgs,\n                        externs,\n-                       &cr)\n+                       &cr,\n+                       triple)\n     }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n     info!(\"finished with rustc\");\n     analysiskey.replace(Some(analysis));"}, {"sha": "d28069da6ba06e5acaf86e4f1a9e7d6e38d096f1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0fa8764efa53ef2c6383ddedf90ee9804a02c68/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c0fa8764efa53ef2c6383ddedf90ee9804a02c68", "patch": "@@ -192,13 +192,16 @@ impl<'a> RustdocVisitor<'a> {\n                        om: &mut Module,\n                        please_inline: bool) -> Option<Gc<ast::ViewPath>> {\n         match path.node {\n-            ast::ViewPathSimple(_, _, id) => {\n-                if self.resolve_id(id, false, om, please_inline) { return None }\n+            ast::ViewPathSimple(dst, _, id) => {\n+                if self.resolve_id(id, Some(dst), false, om, please_inline) {\n+                    return None\n+                }\n             }\n             ast::ViewPathList(ref p, ref paths, ref b) => {\n                 let mut mine = Vec::new();\n                 for path in paths.iter() {\n-                    if !self.resolve_id(path.node.id(), false, om, please_inline) {\n+                    if !self.resolve_id(path.node.id(), None, false, om,\n+                                        please_inline) {\n                         mine.push(path.clone());\n                     }\n                 }\n@@ -212,14 +215,16 @@ impl<'a> RustdocVisitor<'a> {\n \n             // these are feature gated anyway\n             ast::ViewPathGlob(_, id) => {\n-                if self.resolve_id(id, true, om, please_inline) { return None }\n+                if self.resolve_id(id, None, true, om, please_inline) {\n+                    return None\n+                }\n             }\n         }\n         return Some(path);\n     }\n \n-    fn resolve_id(&mut self, id: ast::NodeId, glob: bool,\n-                  om: &mut Module, please_inline: bool) -> bool {\n+    fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n+                  glob: bool, om: &mut Module, please_inline: bool) -> bool {\n         let tcx = match self.cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return false\n@@ -235,6 +240,15 @@ impl<'a> RustdocVisitor<'a> {\n \n         match tcx.map.get(def.node) {\n             ast_map::NodeItem(it) => {\n+                let it = match renamed {\n+                    Some(ident) => {\n+                        box(GC) ast::Item {\n+                            ident: ident,\n+                            ..(*it).clone()\n+                        }\n+                    }\n+                    None => it,\n+                };\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {"}]}