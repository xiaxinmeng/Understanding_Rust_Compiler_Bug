{"sha": "a06da98f2187d0b71317492b635cd2f43a2fc64b", "node_id": "C_kwDOAAsO6NoAKGEwNmRhOThmMjE4N2QwYjcxMzE3NDkyYjYzNWNkMmY0M2EyZmM2NGI", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-16T08:24:50Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-08-16T08:24:50Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "019e6112a9986dfe2a8011c62f54dac6855cb6c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/019e6112a9986dfe2a8011c62f54dac6855cb6c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a06da98f2187d0b71317492b635cd2f43a2fc64b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a06da98f2187d0b71317492b635cd2f43a2fc64b", "html_url": "https://github.com/rust-lang/rust/commit/a06da98f2187d0b71317492b635cd2f43a2fc64b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a06da98f2187d0b71317492b635cd2f43a2fc64b/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8556e6620e4866526b3cea767ad8c20ae877a569", "url": "https://api.github.com/repos/rust-lang/rust/commits/8556e6620e4866526b3cea767ad8c20ae877a569", "html_url": "https://github.com/rust-lang/rust/commit/8556e6620e4866526b3cea767ad8c20ae877a569"}, {"sha": "b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860", "html_url": "https://github.com/rust-lang/rust/commit/b6d59f2bb4fae0ba4f74e2c967b5e2f777f8c860"}], "stats": {"total": 10882, "additions": 5774, "deletions": 5108}, "files": [{"sha": "a70252fa65a5d41dc9a26355ca5849c32a59474b", "filename": "src/tools/rust-analyzer/.github/workflows/ci.yaml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -101,7 +101,7 @@ jobs:\n     - name: Install Nodejs\n       uses: actions/setup-node@v1\n       with:\n-        node-version: 14.x\n+        node-version: 16.x\n \n     - name: Install xvfb\n       if: matrix.os == 'ubuntu-latest'"}, {"sha": "3c36c4fb84a2b28e6c2798103f576f7f51f55d23", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -68,7 +68,7 @@ jobs:\n       - name: Install Node.js\n         uses: actions/setup-node@v1\n         with:\n-          node-version: 14.x\n+          node-version: 16.x\n \n       - name: Update apt repositories\n         if: matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'arm-unknown-linux-gnueabihf'\n@@ -133,7 +133,7 @@ jobs:\n     container:\n       image: rust:alpine\n       volumes:\n-        - /usr/local/cargo/registry\n+        - /usr/local/cargo/registry:/usr/local/cargo/registry\n \n     steps:\n       - name: Install dependencies\n@@ -176,7 +176,7 @@ jobs:\n       - name: Install Nodejs\n         uses: actions/setup-node@v1\n         with:\n-          node-version: 14.x\n+          node-version: 16.x\n \n       - run: echo \"TAG=$(date --iso -u)\" >> $GITHUB_ENV\n         if: github.ref == 'refs/heads/release'\n@@ -253,9 +253,9 @@ jobs:\n       - name: Publish Extension (Code Marketplace, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix --pre-release\n+        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n \n       - name: Publish Extension (OpenVSX, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix --pre-release\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix"}, {"sha": "1e21214ffc4bcfdf3029c92fda1508bd92e1a7ce", "filename": "src/tools/rust-analyzer/.vscode/launch.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -78,7 +78,7 @@\n       \"request\": \"launch\",\n       \"runtimeExecutable\": \"${execPath}\",\n       \"args\": [\n-        \"--disable-extension\", \"matklad.rust-analyzer\",\n+        \"--disable-extension\", \"rust-lang.rust-analyzer\",\n         \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n       ],\n       \"outFiles\": ["}, {"sha": "7c6796d70bdc0e5c0a9f3077279707e8cbf182e3", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -710,6 +710,7 @@ dependencies = [\n  \"ide-db\",\n  \"itertools\",\n  \"profile\",\n+ \"serde_json\",\n  \"sourcegen\",\n  \"stdx\",\n  \"syntax\","}, {"sha": "9580ce8007c76a2224f5f2ba90a2acfbc6680d11", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -6,7 +6,7 @@\n //! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n //! actual IO is done and lowered to input.\n \n-use std::{fmt, iter::FromIterator, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n+use std::{fmt, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n \n use cfg::CfgOptions;\n use rustc_hash::{FxHashMap, FxHashSet};"}, {"sha": "4f626105a53d60f727cfd02e71b66ea95e7450ae", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -295,13 +295,13 @@ fn test_concat_expand() {\n #[rustc_builtin_macro]\n macro_rules! concat {}\n \n-fn main() { concat!(\"foo\", \"r\", 0, r#\"bar\"#, \"\\n\", false); }\n+fn main() { concat!(\"foo\", \"r\", 0, r#\"bar\"#, \"\\n\", false, '\"', '\\0'); }\n \"##,\n         expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! concat {}\n \n-fn main() { \"foor0bar\\nfalse\"; }\n+fn main() { \"foor0bar\\nfalse\\\"\\u{0}\"; }\n \"##]],\n     );\n }"}, {"sha": "457e43925c635367f615391ffc04cb06e99df9d9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -885,7 +885,7 @@ macro_rules! m {\n     ($t:ty) => ( fn bar() -> $ t {} )\n }\n \n-fn bar() -> & 'a Baz<u8> {}\n+fn bar() -> &'a Baz<u8> {}\n \n fn bar() -> extern \"Rust\"fn() -> Ret {}\n \"#]],\n@@ -1578,7 +1578,7 @@ macro_rules !register_methods {\n             ($$($val: expr), *) = > {\n                 struct Foo;\n                 impl Foo {\n-                    $(fn $method()-> & 'static[u32] {\n+                    $(fn $method()-> &'static[u32] {\n                         &[$$($$val), *]\n                     }\n                     )*\n@@ -1591,21 +1591,21 @@ macro_rules !implement_methods {\n     ($($val: expr), *) = > {\n         struct Foo;\n         impl Foo {\n-            fn alpha()-> & 'static[u32] {\n+            fn alpha()-> &'static[u32] {\n                 &[$($val), *]\n             }\n-            fn beta()-> & 'static[u32] {\n+            fn beta()-> &'static[u32] {\n                 &[$($val), *]\n             }\n         }\n     }\n }\n struct Foo;\n impl Foo {\n-    fn alpha() -> & 'static[u32] {\n+    fn alpha() -> &'static[u32] {\n         &[1, 2, 3]\n     }\n-    fn beta() -> & 'static[u32] {\n+    fn beta() -> &'static[u32] {\n         &[1, 2, 3]\n     }\n }"}, {"sha": "d2505e7cafe53657ba29f6d0c140d442ee0f9799", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -166,7 +166,7 @@ macro_rules! int_base {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")] impl fmt::Binary for isize {\n-    fn fmt(&self , f: &mut fmt::Formatter< '_>) -> fmt::Result {\n+    fn fmt(&self , f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         Binary.fmt_int(*self as usize, f)\n     }\n }\n@@ -724,7 +724,7 @@ macro_rules! delegate_impl {\n         }\n     }\n }\n-impl <> Data for & 'amut G where G: Data {}\n+impl <> Data for &'amut G where G: Data {}\n \"##]],\n     );\n }"}, {"sha": "b8d2ca687c9e0ef201948ae804217ee01306472b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -78,7 +78,7 @@ m!(static bar: &'static str = \"hello\";);\n macro_rules! m {\n     ($($t:tt)*) => { $($t)*}\n }\n-static bar: & 'static str = \"hello\";\n+static bar: &'static str = \"hello\";\n \"#]],\n     );\n }"}, {"sha": "029821e5e87f696ab6e57430dc497327c010a7d6", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -87,7 +87,7 @@ fn foo() { bar.; blub }\n fn foo() { bar.; blub }\n \n fn foo() {\n-    bar. ;\n+    bar.;\n     blub\n }\"##]],\n     );"}, {"sha": "99f7f1b549e2c91f0c09e3af97a6be772f0c1b61", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -73,10 +73,12 @@ impl ModDir {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None if file_id.is_include_macro(db.upcast()) => {\n+                let name = name.unescaped();\n                 candidate_files.push(format!(\"{}.rs\", name));\n                 candidate_files.push(format!(\"{}/mod.rs\", name));\n             }\n             None => {\n+                let name = name.unescaped();\n                 candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n                 candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n             }"}, {"sha": "3fa585574deec5076c4ca53f0afd3be52747310e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -132,9 +132,9 @@ pub struct Bar;\n         expect![[r#\"\n             crate\n             Bar: t v\n-            async: t\n+            r#async: t\n \n-            crate::async\n+            crate::r#async\n             Bar: t v\n         \"#]],\n     );"}, {"sha": "8befa7f7da7279e112671a53a47b95716a50a76a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -251,9 +251,13 @@ fn format_args_expand(\n     }\n     for arg in &mut args {\n         // Remove `key =`.\n-        if matches!(arg.token_trees.get(1), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=' && p.spacing != tt::Spacing::Joint)\n+        if matches!(arg.token_trees.get(1), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n         {\n-            arg.token_trees.drain(..2);\n+            // but not with `==`\n+            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=' )\n+            {\n+                arg.token_trees.drain(..2);\n+            }\n         }\n     }\n     let _format_string = args.remove(0);\n@@ -357,6 +361,12 @@ fn unquote_str(lit: &tt::Literal) -> Option<String> {\n     token.value().map(|it| it.into_owned())\n }\n \n+fn unquote_char(lit: &tt::Literal) -> Option<char> {\n+    let lit = ast::make::tokens::literal(&lit.to_string());\n+    let token = ast::Char::cast(lit)?;\n+    token.value()\n+}\n+\n fn unquote_byte_string(lit: &tt::Literal) -> Option<Vec<u8>> {\n     let lit = ast::make::tokens::literal(&lit.to_string());\n     let token = ast::ByteString::cast(lit)?;\n@@ -408,8 +418,12 @@ fn concat_expand(\n                 // concat works with string and char literals, so remove any quotes.\n                 // It also works with integer, float and boolean literals, so just use the rest\n                 // as-is.\n-                let component = unquote_str(it).unwrap_or_else(|| it.text.to_string());\n-                text.push_str(&component);\n+                if let Some(c) = unquote_char(it) {\n+                    text.push(c);\n+                } else {\n+                    let component = unquote_str(it).unwrap_or_else(|| it.text.to_string());\n+                    text.push_str(&component);\n+                }\n             }\n             // handle boolean literals\n             tt::TokenTree::Leaf(tt::Leaf::Ident(id))"}, {"sha": "893e6fe4b82408da9ef765eabfc3b90c9bca641e", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 181, "deletions": 9, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -67,7 +67,6 @@ pub(crate) fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n             preorder.skip_subtree();\n             continue;\n         }\n-\n         // In some other situations, we can fix things by just appending some tokens.\n         let end_range = TextRange::empty(node.text_range().end());\n         match_ast! {\n@@ -194,7 +193,75 @@ pub(crate) fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n                     }\n                 },\n                 // FIXME: foo::\n-                // FIXME: for, match etc.\n+                ast::MatchExpr(it) => {\n+                    if it.expr().is_none() {\n+                        let match_token = match it.match_token() {\n+                            Some(t) => t,\n+                            None => continue\n+                        };\n+                        append.insert(match_token.into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::IDENT,\n+                                text: \"__ra_fixup\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID\n+                            },\n+                        ]);\n+                    }\n+                    if it.match_arm_list().is_none() {\n+                        // No match arms\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n+                ast::ForExpr(it) => {\n+                    let for_token = match it.for_token() {\n+                        Some(token) => token,\n+                        None => continue\n+                    };\n+\n+                    let [pat, in_token, iter] = [\n+                        (SyntaxKind::UNDERSCORE, \"_\"),\n+                        (SyntaxKind::IN_KW, \"in\"),\n+                        (SyntaxKind::IDENT, \"__ra_fixup\")\n+                    ].map(|(kind, text)| SyntheticToken { kind, text: text.into(), range: end_range, id: EMPTY_ID});\n+\n+                    if it.pat().is_none() && it.in_token().is_none() && it.iterable().is_none() {\n+                        append.insert(for_token.into(), vec![pat, in_token, iter]);\n+                    // does something funky -- see test case for_no_pat\n+                    } else if it.pat().is_none() {\n+                        append.insert(for_token.into(), vec![pat]);\n+                    }\n+\n+                    if it.loop_body().is_none() {\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n                 _ => (),\n             }\n         }\n@@ -287,6 +354,111 @@ mod tests {\n         assert_eq!(tt.to_string(), original_as_tt.to_string());\n     }\n \n+    #[test]\n+    fn just_for_token() {\n+        check(\n+            r#\"\n+fn foo() {\n+    for\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {for _ in __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn for_no_iter_pattern() {\n+        check(\n+            r#\"\n+fn foo() {\n+    for {}\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {for _ in __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn for_no_body() {\n+        check(\n+            r#\"\n+fn foo() {\n+    for bar in qux\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {for bar in qux {}}\n+\"#]],\n+        )\n+    }\n+\n+    // FIXME: https://github.com/rust-lang/rust-analyzer/pull/12937#discussion_r937633695\n+    #[test]\n+    fn for_no_pat() {\n+        check(\n+            r#\"\n+fn foo() {\n+    for in qux {\n+\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {__ra_fixup}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn match_no_expr_no_arms() {\n+        check(\n+            r#\"\n+fn foo() {\n+    match\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {match __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn match_expr_no_arms() {\n+        check(\n+            r#\"\n+fn foo() {\n+    match x {\n+\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {match x {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn match_no_expr() {\n+        check(\n+            r#\"\n+fn foo() {\n+    match {\n+        _ => {}\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {match __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n     #[test]\n     fn incomplete_field_expr_1() {\n         check(\n@@ -296,7 +468,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a . __ra_fixup}\n+fn foo () {a .__ra_fixup}\n \"#]],\n         )\n     }\n@@ -306,11 +478,11 @@ fn foo () {a . __ra_fixup}\n         check(\n             r#\"\n fn foo() {\n-    a. ;\n+    a.;\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a . __ra_fixup ;}\n+fn foo () {a .__ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -320,12 +492,12 @@ fn foo () {a . __ra_fixup ;}\n         check(\n             r#\"\n fn foo() {\n-    a. ;\n+    a.;\n     bar();\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a . __ra_fixup ; bar () ;}\n+fn foo () {a .__ra_fixup ; bar () ;}\n \"#]],\n         )\n     }\n@@ -353,7 +525,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {let x = a . __ra_fixup ;}\n+fn foo () {let x = a .__ra_fixup ;}\n \"#]],\n         )\n     }\n@@ -369,7 +541,7 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-fn foo () {a . b ; bar () ;}\n+fn foo () {a .b ; bar () ;}\n \"#]],\n         )\n     }"}, {"sha": "d0f73ec8208c60e52b2a38de539257b3321d98c9", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -22,7 +22,7 @@ pub struct ModPath {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct EscapedModPath<'a>(&'a ModPath);\n+pub struct UnescapedModPath<'a>(&'a ModPath);\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n@@ -102,8 +102,8 @@ impl ModPath {\n         }\n     }\n \n-    pub fn escaped(&self) -> EscapedModPath<'_> {\n-        EscapedModPath(self)\n+    pub fn unescaped(&self) -> UnescapedModPath<'_> {\n+        UnescapedModPath(self)\n     }\n \n     fn _fmt(&self, f: &mut fmt::Formatter<'_>, escaped: bool) -> fmt::Result {\n@@ -134,9 +134,9 @@ impl ModPath {\n             }\n             first_segment = false;\n             if escaped {\n-                segment.escaped().fmt(f)?\n-            } else {\n                 segment.fmt(f)?\n+            } else {\n+                segment.unescaped().fmt(f)?\n             };\n         }\n         Ok(())\n@@ -145,13 +145,13 @@ impl ModPath {\n \n impl Display for ModPath {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self._fmt(f, false)\n+        self._fmt(f, true)\n     }\n }\n \n-impl<'a> Display for EscapedModPath<'a> {\n+impl<'a> Display for UnescapedModPath<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0._fmt(f, true)\n+        self.0._fmt(f, false)\n     }\n }\n "}, {"sha": "87c663eec8e81c2deea72c1c6e41c49c55f383cf", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -7,12 +7,16 @@ use syntax::{ast, SmolStr, SyntaxKind};\n /// `Name` is a wrapper around string, which is used in hir for both references\n /// and declarations. In theory, names should also carry hygiene info, but we are\n /// not there yet!\n+///\n+/// Note that `Name` holds and prints escaped name i.e. prefixed with \"r#\" when it\n+/// is a raw identifier. Use [`unescaped()`][Name::unescaped] when you need the\n+/// name without \"r#\".\n #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub struct Name(Repr);\n \n-/// `EscapedName` will add a prefix \"r#\" to the wrapped `Name` when it is a raw identifier\n+/// Wrapper of `Name` to print the name without \"r#\" even when it is a raw identifier.\n #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct EscapedName<'a>(&'a Name);\n+pub struct UnescapedName<'a>(&'a Name);\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n enum Repr {\n@@ -34,37 +38,26 @@ fn is_raw_identifier(name: &str) -> bool {\n     is_keyword && !matches!(name, \"self\" | \"crate\" | \"super\" | \"Self\")\n }\n \n-impl<'a> fmt::Display for EscapedName<'a> {\n+impl<'a> fmt::Display for UnescapedName<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.0 .0 {\n             Repr::Text(text) => {\n-                if is_raw_identifier(text) {\n-                    write!(f, \"r#{}\", &text)\n-                } else {\n-                    fmt::Display::fmt(&text, f)\n-                }\n+                let text = text.strip_prefix(\"r#\").unwrap_or(text);\n+                fmt::Display::fmt(&text, f)\n             }\n             Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n         }\n     }\n }\n \n-impl<'a> EscapedName<'a> {\n-    pub fn is_escaped(&self) -> bool {\n-        match &self.0 .0 {\n-            Repr::Text(it) => is_raw_identifier(&it),\n-            Repr::TupleField(_) => false,\n-        }\n-    }\n-\n-    /// Returns the textual representation of this name as a [`SmolStr`].\n-    /// Prefer using this over [`ToString::to_string`] if possible as this conversion is cheaper in\n-    /// the general case.\n+impl<'a> UnescapedName<'a> {\n+    /// Returns the textual representation of this name as a [`SmolStr`]. Prefer using this over\n+    /// [`ToString::to_string`] if possible as this conversion is cheaper in the general case.\n     pub fn to_smol_str(&self) -> SmolStr {\n         match &self.0 .0 {\n             Repr::Text(it) => {\n-                if is_raw_identifier(&it) {\n-                    SmolStr::from_iter([\"r#\", &it])\n+                if let Some(stripped) = it.strip_prefix(\"r#\") {\n+                    SmolStr::new(stripped)\n                 } else {\n                     it.clone()\n                 }\n@@ -97,9 +90,11 @@ impl Name {\n \n     /// Resolve a name from the text of token.\n     fn resolve(raw_text: &str) -> Name {\n+        // When `raw_text` starts with \"r#\" but the name does not coincide with any\n+        // keyword, we never need the prefix so we strip it.\n         match raw_text.strip_prefix(\"r#\") {\n-            Some(text) => Name::new_text(SmolStr::new(text)),\n-            None => Name::new_text(raw_text.into()),\n+            Some(text) if !is_raw_identifier(text) => Name::new_text(SmolStr::new(text)),\n+            _ => Name::new_text(raw_text.into()),\n         }\n     }\n \n@@ -142,8 +137,15 @@ impl Name {\n         }\n     }\n \n-    pub fn escaped(&self) -> EscapedName<'_> {\n-        EscapedName(self)\n+    pub fn unescaped(&self) -> UnescapedName<'_> {\n+        UnescapedName(self)\n+    }\n+\n+    pub fn is_escaped(&self) -> bool {\n+        match &self.0 {\n+            Repr::Text(it) => it.starts_with(\"r#\"),\n+            Repr::TupleField(_) => false,\n+        }\n     }\n }\n "}, {"sha": "e839e97bf02d88f86091ca1baeac843bcdd595c7", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -196,8 +196,8 @@ impl_to_to_tokentrees! {\n     tt::Literal => self { self };\n     tt::Ident => self { self };\n     tt::Punct => self { self };\n-    &str => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_debug()).into(), id: tt::TokenId::unspecified()}};\n-    String => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_debug()).into(), id: tt::TokenId::unspecified()}}\n+    &str => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}};\n+    String => self { tt::Literal{text: format!(\"\\\"{}\\\"\", self.escape_default()).into(), id: tt::TokenId::unspecified()}}\n }\n \n #[cfg(test)]"}, {"sha": "6ecb6e6fd173e30e9273d82c792485b3bb7d506f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -2,7 +2,6 @@\n \n use std::{\n     collections::HashMap,\n-    convert::TryInto,\n     fmt::{Display, Write},\n };\n "}, {"sha": "53259d66dec640f91e023674a94e2e8e2e3dedc8", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -14,8 +14,9 @@ use crate::{\n     consteval::intern_const_scalar,\n     infer::{BindingMode, Expectation, InferenceContext, TypeMismatch},\n     lower::lower_to_chalk_mutability,\n-    static_lifetime, ConcreteConst, ConstValue, Interner, Substitution, Ty, TyBuilder, TyExt,\n-    TyKind,\n+    primitive::UintTy,\n+    static_lifetime, ConcreteConst, ConstValue, Interner, Scalar, Substitution, Ty, TyBuilder,\n+    TyExt, TyKind,\n };\n \n use super::PatLike;\n@@ -294,7 +295,29 @@ impl<'a> InferenceContext<'a> {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n-            Pat::Lit(expr) => self.infer_expr(*expr, &Expectation::has_type(expected.clone())),\n+            &Pat::Lit(expr) => {\n+                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n+                let mut pat_ty = None;\n+\n+                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+                    if let Some((inner, ..)) = expected.as_reference() {\n+                        let inner = self.resolve_ty_shallow(inner);\n+                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n+                                .intern(Interner);\n+                            self.write_expr_ty(expr, ty.clone());\n+                            pat_ty = Some(ty);\n+                        }\n+                    }\n+                }\n+\n+                pat_ty.unwrap_or_else(|| {\n+                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+                })\n+            }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let (inner_ty, alloc_ty) = match expected.as_adt() {\n@@ -343,7 +366,9 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         // FIXME: ConstBlock/Path/Lit might actually evaluate to ref, but inference is unimplemented.\n         Pat::Path(..) => true,\n         Pat::ConstBlock(..) => true,\n-        Pat::Lit(expr) => !matches!(body[*expr], Expr::Literal(Literal::String(..))),\n+        Pat::Lit(expr) => {\n+            !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n+        }\n         Pat::Bind {\n             mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n             subpat: Some(subpat),"}, {"sha": "94efe7bc11a8be577ee80081540ed8123683c558", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -315,6 +315,51 @@ fn infer_pattern_match_string_literal() {\n     );\n }\n \n+#[test]\n+fn infer_pattern_match_byte_string_literal() {\n+    check_infer_with_mismatches(\n+        r#\"\n+        //- minicore: index\n+        struct S;\n+        impl<T, const N: usize> core::ops::Index<S> for [T; N] {\n+            type Output = [u8];\n+            fn index(&self, index: core::ops::RangeFull) -> &Self::Output {\n+                loop {}\n+            }\n+        }\n+        fn test(v: [u8; 3]) {\n+            if let b\"foo\" = &v[S] {}\n+            if let b\"foo\" = &v {}\n+        }\n+        \"#,\n+        expect![[r#\"\n+            105..109 'self': &[T; N]\n+            111..116 'index': {unknown}\n+            157..180 '{     ...     }': &[u8]\n+            167..174 'loop {}': !\n+            172..174 '{}': ()\n+            191..192 'v': [u8; 3]\n+            203..261 '{     ...v {} }': ()\n+            209..233 'if let...[S] {}': ()\n+            212..230 'let b\"... &v[S]': bool\n+            216..222 'b\"foo\"': &[u8]\n+            216..222 'b\"foo\"': &[u8]\n+            225..230 '&v[S]': &[u8]\n+            226..227 'v': [u8; 3]\n+            226..230 'v[S]': [u8]\n+            228..229 'S': S\n+            231..233 '{}': ()\n+            238..259 'if let... &v {}': ()\n+            241..256 'let b\"foo\" = &v': bool\n+            245..251 'b\"foo\"': &[u8; 3]\n+            245..251 'b\"foo\"': &[u8; 3]\n+            254..256 '&v': &[u8; 3]\n+            255..256 'v': [u8; 3]\n+            257..259 '{}': ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn infer_pattern_match_or() {\n     check_infer_with_mismatches("}, {"sha": "50374f4b3fe47ebdd8e6907c26430a013b185687", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -14,6 +14,7 @@ use crate::{MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n+        #[derive(Debug)]\n         pub enum AnyDiagnostic {$(\n             $diag(Box<$diag>),\n         )*}"}, {"sha": "ae2896e19329913cb3e57567fa2f8ccee4dc69cc", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -368,6 +368,7 @@ impl SourceAnalyzer {\n         let local = if field.name_ref().is_some() {\n             None\n         } else {\n+            // Shorthand syntax, resolve to the local\n             let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n                 Some(ValueNs::LocalBinding(pat_id)) => {"}, {"sha": "8c7670e0cb71aecb545c41d827e4a3f39d0385c9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/assist_context.rs", "status": "modified", "additions": 10, "deletions": 147, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,28 +1,20 @@\n //! See [`AssistContext`].\n \n-use std::mem;\n-\n use hir::Semantics;\n-use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId, FileRange},\n-    SnippetCap,\n-};\n-use ide_db::{\n-    label::Label,\n-    source_change::{FileSystemEdit, SourceChange},\n-    RootDatabase,\n-};\n+use ide_db::base_db::{FileId, FileRange};\n+use ide_db::{label::Label, RootDatabase};\n use syntax::{\n     algo::{self, find_node_at_offset, find_node_at_range},\n-    AstNode, AstToken, Direction, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxNodePtr,\n-    SyntaxToken, TextRange, TextSize, TokenAtOffset,\n+    AstNode, AstToken, Direction, SourceFile, SyntaxElement, SyntaxKind, SyntaxToken, TextRange,\n+    TextSize, TokenAtOffset,\n };\n-use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     assist_config::AssistConfig, Assist, AssistId, AssistKind, AssistResolveStrategy, GroupLabel,\n };\n \n+pub(crate) use ide_db::source_change::{SourceChangeBuilder, TreeMutator};\n+\n /// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n /// Assists use a somewhat over-engineered approach, given the current needs.\n@@ -163,7 +155,7 @@ impl Assists {\n         id: AssistId,\n         label: impl Into<String>,\n         target: TextRange,\n-        f: impl FnOnce(&mut AssistBuilder),\n+        f: impl FnOnce(&mut SourceChangeBuilder),\n     ) -> Option<()> {\n         let mut f = Some(f);\n         self.add_impl(None, id, label.into(), target, &mut |it| f.take().unwrap()(it))\n@@ -175,7 +167,7 @@ impl Assists {\n         id: AssistId,\n         label: impl Into<String>,\n         target: TextRange,\n-        f: impl FnOnce(&mut AssistBuilder),\n+        f: impl FnOnce(&mut SourceChangeBuilder),\n     ) -> Option<()> {\n         let mut f = Some(f);\n         self.add_impl(Some(group), id, label.into(), target, &mut |it| f.take().unwrap()(it))\n@@ -187,15 +179,15 @@ impl Assists {\n         id: AssistId,\n         label: String,\n         target: TextRange,\n-        f: &mut dyn FnMut(&mut AssistBuilder),\n+        f: &mut dyn FnMut(&mut SourceChangeBuilder),\n     ) -> Option<()> {\n         if !self.is_allowed(&id) {\n             return None;\n         }\n \n         let mut trigger_signature_help = false;\n         let source_change = if self.resolve.should_resolve(&id) {\n-            let mut builder = AssistBuilder::new(self.file);\n+            let mut builder = SourceChangeBuilder::new(self.file);\n             f(&mut builder);\n             trigger_signature_help = builder.trigger_signature_help;\n             Some(builder.finish())\n@@ -216,132 +208,3 @@ impl Assists {\n         }\n     }\n }\n-\n-pub(crate) struct AssistBuilder {\n-    edit: TextEditBuilder,\n-    file_id: FileId,\n-    source_change: SourceChange,\n-    trigger_signature_help: bool,\n-\n-    /// Maps the original, immutable `SyntaxNode` to a `clone_for_update` twin.\n-    mutated_tree: Option<TreeMutator>,\n-}\n-\n-pub(crate) struct TreeMutator {\n-    immutable: SyntaxNode,\n-    mutable_clone: SyntaxNode,\n-}\n-\n-impl TreeMutator {\n-    pub(crate) fn new(immutable: &SyntaxNode) -> TreeMutator {\n-        let immutable = immutable.ancestors().last().unwrap();\n-        let mutable_clone = immutable.clone_for_update();\n-        TreeMutator { immutable, mutable_clone }\n-    }\n-\n-    pub(crate) fn make_mut<N: AstNode>(&self, node: &N) -> N {\n-        N::cast(self.make_syntax_mut(node.syntax())).unwrap()\n-    }\n-\n-    pub(crate) fn make_syntax_mut(&self, node: &SyntaxNode) -> SyntaxNode {\n-        let ptr = SyntaxNodePtr::new(node);\n-        ptr.to_node(&self.mutable_clone)\n-    }\n-}\n-\n-impl AssistBuilder {\n-    pub(crate) fn new(file_id: FileId) -> AssistBuilder {\n-        AssistBuilder {\n-            edit: TextEdit::builder(),\n-            file_id,\n-            source_change: SourceChange::default(),\n-            trigger_signature_help: false,\n-            mutated_tree: None,\n-        }\n-    }\n-\n-    pub(crate) fn edit_file(&mut self, file_id: FileId) {\n-        self.commit();\n-        self.file_id = file_id;\n-    }\n-\n-    fn commit(&mut self) {\n-        if let Some(tm) = self.mutated_tree.take() {\n-            algo::diff(&tm.immutable, &tm.mutable_clone).into_text_edit(&mut self.edit)\n-        }\n-\n-        let edit = mem::take(&mut self.edit).finish();\n-        if !edit.is_empty() {\n-            self.source_change.insert_source_edit(self.file_id, edit);\n-        }\n-    }\n-\n-    pub(crate) fn make_mut<N: AstNode>(&mut self, node: N) -> N {\n-        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(node.syntax())).make_mut(&node)\n-    }\n-    /// Returns a copy of the `node`, suitable for mutation.\n-    ///\n-    /// Syntax trees in rust-analyzer are typically immutable, and mutating\n-    /// operations panic at runtime. However, it is possible to make a copy of\n-    /// the tree and mutate the copy freely. Mutation is based on interior\n-    /// mutability, and different nodes in the same tree see the same mutations.\n-    ///\n-    /// The typical pattern for an assist is to find specific nodes in the read\n-    /// phase, and then get their mutable couterparts using `make_mut` in the\n-    /// mutable state.\n-    pub(crate) fn make_syntax_mut(&mut self, node: SyntaxNode) -> SyntaxNode {\n-        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(&node)).make_syntax_mut(&node)\n-    }\n-\n-    /// Remove specified `range` of text.\n-    pub(crate) fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-    /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n-    }\n-    /// Append specified `snippet` at the given `offset`\n-    pub(crate) fn insert_snippet(\n-        &mut self,\n-        _cap: SnippetCap,\n-        offset: TextSize,\n-        snippet: impl Into<String>,\n-    ) {\n-        self.source_change.is_snippet = true;\n-        self.insert(offset, snippet);\n-    }\n-    /// Replaces specified `range` of text with a given string.\n-    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n-        self.edit.replace(range, replace_with.into())\n-    }\n-    /// Replaces specified `range` of text with a given `snippet`.\n-    pub(crate) fn replace_snippet(\n-        &mut self,\n-        _cap: SnippetCap,\n-        range: TextRange,\n-        snippet: impl Into<String>,\n-    ) {\n-        self.source_change.is_snippet = true;\n-        self.replace(range, snippet);\n-    }\n-    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n-    }\n-    pub(crate) fn create_file(&mut self, dst: AnchoredPathBuf, content: impl Into<String>) {\n-        let file_system_edit = FileSystemEdit::CreateFile { dst, initial_contents: content.into() };\n-        self.source_change.push_file_system_edit(file_system_edit);\n-    }\n-    pub(crate) fn move_file(&mut self, src: FileId, dst: AnchoredPathBuf) {\n-        let file_system_edit = FileSystemEdit::MoveFile { src, dst };\n-        self.source_change.push_file_system_edit(file_system_edit);\n-    }\n-    pub(crate) fn trigger_signature_help(&mut self) {\n-        self.trigger_signature_help = true;\n-    }\n-\n-    fn finish(mut self) -> SourceChange {\n-        self.commit();\n-        mem::take(&mut self.source_change)\n-    }\n-}"}, {"sha": "62cf5ab4f37a187546e5359ffc71d7e0a9e09713", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -944,7 +944,7 @@ foo!();\n struct Foo(usize);\n \n impl FooB for Foo {\n-    $0fn foo< 'lt>(& 'lt self){}\n+    $0fn foo<'lt>(&'lt self){}\n }\n \"#,\n         )"}, {"sha": "d8f522708460e06622d63ae8b6bcb9d92775c7b5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -5,7 +5,7 @@ use syntax::{\n     match_ast, SyntaxNode,\n };\n \n-use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: convert_tuple_struct_to_named_struct\n //\n@@ -80,7 +80,7 @@ pub(crate) fn convert_tuple_struct_to_named_struct(\n \n fn edit_struct_def(\n     ctx: &AssistContext<'_>,\n-    edit: &mut AssistBuilder,\n+    edit: &mut SourceChangeBuilder,\n     strukt: &Either<ast::Struct, ast::Variant>,\n     tuple_fields: ast::TupleFieldList,\n     names: Vec<ast::Name>,\n@@ -122,7 +122,7 @@ fn edit_struct_def(\n \n fn edit_struct_references(\n     ctx: &AssistContext<'_>,\n-    edit: &mut AssistBuilder,\n+    edit: &mut SourceChangeBuilder,\n     strukt: Either<hir::Struct, hir::Variant>,\n     names: &[ast::Name],\n ) {\n@@ -132,7 +132,7 @@ fn edit_struct_references(\n     };\n     let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n \n-    let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n+    let edit_node = |edit: &mut SourceChangeBuilder, node: SyntaxNode| -> Option<()> {\n         match_ast! {\n             match node {\n                 ast::TupleStructPat(tuple_struct_pat) => {\n@@ -203,7 +203,7 @@ fn edit_struct_references(\n \n fn edit_field_references(\n     ctx: &AssistContext<'_>,\n-    edit: &mut AssistBuilder,\n+    edit: &mut SourceChangeBuilder,\n     fields: impl Iterator<Item = ast::TupleField>,\n     names: &[ast::Name],\n ) {"}, {"sha": "dc581ff3bd2c7a85adcfcd4451c8b8a0ed20af57", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n     TextRange,\n };\n \n-use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n+use crate::assist_context::{AssistContext, Assists, SourceChangeBuilder};\n \n // Assist: destructure_tuple_binding\n //\n@@ -151,7 +151,7 @@ struct TupleData {\n }\n fn edit_tuple_assignment(\n     ctx: &AssistContext<'_>,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     data: &TupleData,\n     in_sub_pattern: bool,\n ) {\n@@ -195,7 +195,7 @@ fn edit_tuple_assignment(\n \n fn edit_tuple_usages(\n     data: &TupleData,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     ctx: &AssistContext<'_>,\n     in_sub_pattern: bool,\n ) {\n@@ -211,7 +211,7 @@ fn edit_tuple_usages(\n }\n fn edit_tuple_usage(\n     ctx: &AssistContext<'_>,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     usage: &FileReference,\n     data: &TupleData,\n     in_sub_pattern: bool,\n@@ -239,7 +239,7 @@ fn edit_tuple_usage(\n \n fn edit_tuple_field_usage(\n     ctx: &AssistContext<'_>,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     data: &TupleData,\n     index: TupleIndex,\n ) {"}, {"sha": "dfb5652126467ee974ca77dc60820836d796f6f0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -20,7 +20,7 @@ use syntax::{\n     SyntaxNode, T,\n };\n \n-use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: extract_struct_from_enum_variant\n //\n@@ -374,7 +374,7 @@ fn apply_references(\n \n fn process_references(\n     ctx: &AssistContext<'_>,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     visited_modules: &mut FxHashSet<Module>,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,"}, {"sha": "b484635121eb230039fc12e8658d8f690170b0d9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n };\n \n use crate::{\n-    assist_context::{AssistBuilder, AssistContext, Assists},\n+    assist_context::{AssistContext, Assists, SourceChangeBuilder},\n     utils::generate_trait_impl_text,\n     AssistId, AssistKind,\n };\n@@ -120,7 +120,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n }\n \n fn generate_edit(\n-    edit: &mut AssistBuilder,\n+    edit: &mut SourceChangeBuilder,\n     strukt: ast::Struct,\n     field_type_syntax: &SyntaxNode,\n     field_name: impl Display,"}, {"sha": "2fc754e3e50d1b81f1376fe2167aed17282218b4", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -5,7 +5,7 @@ use syntax::{\n     AstNode, TextRange,\n };\n \n-use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n static ASSIST_NAME: &str = \"introduce_named_lifetime\";\n static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n@@ -140,7 +140,7 @@ enum NeedsLifetime {\n }\n \n impl NeedsLifetime {\n-    fn make_mut(self, builder: &mut AssistBuilder) -> Self {\n+    fn make_mut(self, builder: &mut SourceChangeBuilder) -> Self {\n         match self {\n             Self::SelfParam(it) => Self::SelfParam(builder.make_mut(it)),\n             Self::RefType(it) => Self::RefType(builder.make_mut(it)),"}, {"sha": "bd2e8fbe3896606f63a0b7eb8062c93c6d96aa33", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -8,7 +8,8 @@ use syntax::{\n use SyntaxKind::WHITESPACE;\n \n use crate::{\n-    assist_context::AssistBuilder, utils::next_prev, AssistContext, AssistId, AssistKind, Assists,\n+    assist_context::SourceChangeBuilder, utils::next_prev, AssistContext, AssistId, AssistKind,\n+    Assists,\n };\n \n // Assist: remove_unused_param\n@@ -88,7 +89,7 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n fn process_usages(\n     ctx: &AssistContext<'_>,\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     file_id: FileId,\n     references: Vec<FileReference>,\n     arg_to_remove: usize,"}, {"sha": "d139f78a6f36bc9ba5ab2b3941c7133e85b8e080", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n };\n \n use crate::{\n-    assist_context::{AssistBuilder, AssistContext, Assists},\n+    assist_context::{AssistContext, Assists, SourceChangeBuilder},\n     utils::{\n         add_trait_assoc_items_to_impl, filter_assoc_items, gen_trait_fn_body,\n         generate_trait_impl_text, render_snippet, Cursor, DefaultMethods,\n@@ -224,7 +224,7 @@ fn impl_def_from_trait(\n }\n \n fn update_attribute(\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     old_derives: &[ast::Path],\n     old_tree: &ast::TokenTree,\n     old_trait_path: &ast::Path,"}, {"sha": "103e3259fa2ef9f047d4cf7431b08a519e877b9e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -20,7 +20,7 @@ use syntax::{\n     SyntaxNode, TextRange, TextSize, T,\n };\n \n-use crate::assist_context::{AssistBuilder, AssistContext};\n+use crate::assist_context::{AssistContext, SourceChangeBuilder};\n \n pub(crate) mod suggest_name;\n mod gen_trait_fn_body;\n@@ -484,7 +484,7 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n }\n \n pub(crate) fn add_method_to_adt(\n-    builder: &mut AssistBuilder,\n+    builder: &mut SourceChangeBuilder,\n     adt: &ast::Adt,\n     impl_def: Option<ast::Impl>,\n     method: &str,"}, {"sha": "55c3e28392a4d8c0bc8acbe182b8644d33ccce22", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -617,7 +617,6 @@ pub(super) fn complete_name_ref(\n \n                     dot::complete_undotted_self(acc, ctx, path_ctx, expr_ctx);\n                     item_list::complete_item_list_in_expr(acc, ctx, path_ctx, expr_ctx);\n-                    record::complete_record_expr_func_update(acc, ctx, path_ctx, expr_ctx);\n                     snippet::complete_expr_snippet(acc, ctx, path_ctx, expr_ctx);\n                 }\n                 PathKind::Type { location } => {"}, {"sha": "4d66af9e8d5b8b0933b785d685d55114caf91bfe", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,8 +1,10 @@\n //! Completion of names from the current scope in expression position.\n \n use hir::ScopeDef;\n+use syntax::ast;\n \n use crate::{\n+    completions::record::add_default_update,\n     context::{ExprCtx, PathCompletionCtx, Qualified},\n     CompletionContext, Completions,\n };\n@@ -219,60 +221,78 @@ pub(crate) fn complete_expr_path(\n                 _ => (),\n             });\n \n-            if is_func_update.is_none() {\n-                let mut add_keyword =\n-                    |kw, snippet| acc.add_keyword_snippet_expr(ctx, incomplete_let, kw, snippet);\n+            match is_func_update {\n+                Some(record_expr) => {\n+                    let ty = ctx.sema.type_of_expr(&ast::Expr::RecordExpr(record_expr.clone()));\n \n-                if !in_block_expr {\n-                    add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n-                }\n-                add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n-                add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n-                add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n-                add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n-                if in_match_guard {\n-                    add_keyword(\"if\", \"if $0\");\n-                } else {\n-                    add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+                    match ty.as_ref().and_then(|t| t.original.as_adt()) {\n+                        Some(hir::Adt::Union(_)) => (),\n+                        _ => {\n+                            cov_mark::hit!(functional_update);\n+                            let missing_fields =\n+                                ctx.sema.record_literal_missing_fields(record_expr);\n+                            if !missing_fields.is_empty() {\n+                                add_default_update(acc, ctx, ty);\n+                            }\n+                        }\n+                    };\n                 }\n-                add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n-                add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n-                add_keyword(\"true\", \"true\");\n-                add_keyword(\"false\", \"false\");\n+                None => {\n+                    let mut add_keyword = |kw, snippet| {\n+                        acc.add_keyword_snippet_expr(ctx, incomplete_let, kw, snippet)\n+                    };\n \n-                if in_condition || in_block_expr {\n-                    add_keyword(\"let\", \"let\");\n-                }\n+                    if !in_block_expr {\n+                        add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n+                    }\n+                    add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n+                    add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n+                    add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n+                    add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n+                    if in_match_guard {\n+                        add_keyword(\"if\", \"if $0\");\n+                    } else {\n+                        add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+                    }\n+                    add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n+                    add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n+                    add_keyword(\"true\", \"true\");\n+                    add_keyword(\"false\", \"false\");\n \n-                if after_if_expr {\n-                    add_keyword(\"else\", \"else {\\n    $0\\n}\");\n-                    add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n-                }\n+                    if in_condition || in_block_expr {\n+                        add_keyword(\"let\", \"let\");\n+                    }\n \n-                if wants_mut_token {\n-                    add_keyword(\"mut\", \"mut \");\n-                }\n+                    if after_if_expr {\n+                        add_keyword(\"else\", \"else {\\n    $0\\n}\");\n+                        add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n+                    }\n \n-                if in_loop_body {\n-                    if in_block_expr {\n-                        add_keyword(\"continue\", \"continue;\");\n-                        add_keyword(\"break\", \"break;\");\n-                    } else {\n-                        add_keyword(\"continue\", \"continue\");\n-                        add_keyword(\"break\", \"break\");\n+                    if wants_mut_token {\n+                        add_keyword(\"mut\", \"mut \");\n+                    }\n+\n+                    if in_loop_body {\n+                        if in_block_expr {\n+                            add_keyword(\"continue\", \"continue;\");\n+                            add_keyword(\"break\", \"break;\");\n+                        } else {\n+                            add_keyword(\"continue\", \"continue\");\n+                            add_keyword(\"break\", \"break\");\n+                        }\n                     }\n-                }\n \n-                if let Some(ty) = innermost_ret_ty {\n-                    add_keyword(\n-                        \"return\",\n-                        match (in_block_expr, ty.is_unit()) {\n-                            (true, true) => \"return ;\",\n-                            (true, false) => \"return;\",\n-                            (false, true) => \"return $0\",\n-                            (false, false) => \"return\",\n-                        },\n-                    );\n+                    if let Some(ty) = innermost_ret_ty {\n+                        add_keyword(\n+                            \"return\",\n+                            match (in_block_expr, ty.is_unit()) {\n+                                (true, true) => \"return ;\",\n+                                (true, false) => \"return;\",\n+                                (false, true) => \"return $0\",\n+                                (false, false) => \"return\",\n+                            },\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "785db6fde1d5ad742003c733cb596f02404dec1d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -233,7 +233,8 @@ fn add_type_alias_impl(\n     type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db);\n-    let (alias_name, escaped_name) = (alias_name.to_smol_str(), alias_name.escaped().to_smol_str());\n+    let (alias_name, escaped_name) =\n+        (alias_name.unescaped().to_smol_str(), alias_name.to_smol_str());\n \n     let label = format!(\"type {} =\", alias_name);\n     let replacement = format!(\"type {} = \", escaped_name);"}, {"sha": "bfb98b9f2777fbfecaba4208c7be17a3ff7a4008", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -3,7 +3,7 @@ use ide_db::SymbolKind;\n use syntax::ast::{self, Expr};\n \n use crate::{\n-    context::{DotAccess, DotAccessKind, ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n+    context::{DotAccess, DotAccessKind, PatternContext},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n     CompletionRelevancePostfixMatch, Completions,\n };\n@@ -14,7 +14,24 @@ pub(crate) fn complete_record_pattern_fields(\n     pattern_ctx: &PatternContext,\n ) {\n     if let PatternContext { record_pat: Some(record_pat), .. } = pattern_ctx {\n-        complete_fields(acc, ctx, ctx.sema.record_pattern_missing_fields(record_pat));\n+        let ty = ctx.sema.type_of_pat(&ast::Pat::RecordPat(record_pat.clone()));\n+        let missing_fields = match ty.as_ref().and_then(|t| t.original.as_adt()) {\n+            Some(hir::Adt::Union(un)) => {\n+                // ctx.sema.record_pat_missing_fields will always return\n+                // an empty Vec on a union literal. This is normally\n+                // reasonable, but here we'd like to present the full list\n+                // of fields if the literal is empty.\n+                let were_fields_specified =\n+                    record_pat.record_pat_field_list().and_then(|fl| fl.fields().next()).is_some();\n+\n+                match were_fields_specified {\n+                    false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n+                    true => return,\n+                }\n+            }\n+            _ => ctx.sema.record_pattern_missing_fields(record_pat),\n+        };\n+        complete_fields(acc, ctx, missing_fields);\n     }\n }\n \n@@ -42,8 +59,13 @@ pub(crate) fn complete_record_expr_fields(\n         }\n         _ => {\n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-            add_default_update(acc, ctx, ty, &missing_fields);\n+\n+            if !missing_fields.is_empty() {\n+                cov_mark::hit!(functional_update_field);\n+                add_default_update(acc, ctx, ty);\n+            }\n             if dot_prefix {\n+                cov_mark::hit!(functional_update_one_dot);\n                 let mut item =\n                     CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n                 item.insert_text(\".\");\n@@ -56,41 +78,18 @@ pub(crate) fn complete_record_expr_fields(\n     complete_fields(acc, ctx, missing_fields);\n }\n \n-// FIXME: This should probably be part of complete_path_expr\n-pub(crate) fn complete_record_expr_func_update(\n-    acc: &mut Completions,\n-    ctx: &CompletionContext<'_>,\n-    path_ctx: &PathCompletionCtx,\n-    expr_ctx: &ExprCtx,\n-) {\n-    if !matches!(path_ctx.qualified, Qualified::No) {\n-        return;\n-    }\n-    if let ExprCtx { is_func_update: Some(record_expr), .. } = expr_ctx {\n-        let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n-\n-        match ty.as_ref().and_then(|t| t.original.as_adt()) {\n-            Some(hir::Adt::Union(_)) => (),\n-            _ => {\n-                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-                add_default_update(acc, ctx, ty, &missing_fields);\n-            }\n-        };\n-    }\n-}\n-\n-fn add_default_update(\n+pub(crate) fn add_default_update(\n     acc: &mut Completions,\n     ctx: &CompletionContext<'_>,\n     ty: Option<hir::TypeInfo>,\n-    missing_fields: &[(hir::Field, hir::Type)],\n ) {\n     let default_trait = ctx.famous_defs().core_default_Default();\n-    let impl_default_trait = default_trait\n+    let impls_default_trait = default_trait\n         .zip(ty.as_ref())\n         .map_or(false, |(default_trait, ty)| ty.original.impls_trait(ctx.db, default_trait, &[]));\n-    if impl_default_trait && !missing_fields.is_empty() {\n+    if impls_default_trait {\n         // FIXME: This should make use of scope_def like completions so we get all the other goodies\n+        // that is we should handle this like actually completing the default function\n         let completion_text = \"..Default::default()\";\n         let mut item = CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n         let completion_text ="}, {"sha": "759742d347237520b0de7d09410ac5b92916f5b9", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -134,6 +134,7 @@ pub(crate) struct ExprCtx {\n     pub(crate) in_condition: bool,\n     pub(crate) incomplete_let: bool,\n     pub(crate) ref_expr_parent: Option<ast::RefExpr>,\n+    /// The surrounding RecordExpression we are completing a functional update\n     pub(crate) is_func_update: Option<ast::RecordExpr>,\n     pub(crate) self_param: Option<hir::SelfParam>,\n     pub(crate) innermost_ret_ty: Option<hir::Type>,"}, {"sha": "693007ca3071a7cc2a5ee5fd205f66a62b291fd0", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -117,7 +117,7 @@ pub(crate) fn render_field(\n ) -> CompletionItem {\n     let is_deprecated = ctx.is_deprecated(field);\n     let name = field.name(ctx.db());\n-    let (name, escaped_name) = (name.to_smol_str(), name.escaped().to_smol_str());\n+    let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let mut item = CompletionItem::new(\n         SymbolKind::Field,\n         ctx.source_range(),\n@@ -283,8 +283,8 @@ fn render_resolution_path(\n \n     let name = local_name.to_smol_str();\n     let mut item = render_resolution_simple_(ctx, &local_name, import_to_add, resolution);\n-    if local_name.escaped().is_escaped() {\n-        item.insert_text(local_name.escaped().to_smol_str());\n+    if local_name.is_escaped() {\n+        item.insert_text(local_name.to_smol_str());\n     }\n     // Add `<>` for generic types\n     let type_path_no_ty_args = matches!(\n@@ -306,7 +306,7 @@ fn render_resolution_path(\n                 item.lookup_by(name.clone())\n                     .label(SmolStr::from_iter([&name, \"<\u2026>\"]))\n                     .trigger_call_info()\n-                    .insert_snippet(cap, format!(\"{}<$0>\", local_name.escaped()));\n+                    .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n             }\n         }\n     }\n@@ -342,7 +342,8 @@ fn render_resolution_simple_(\n     let ctx = ctx.import_to_add(import_to_add);\n     let kind = res_to_kind(resolution);\n \n-    let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.to_smol_str());\n+    let mut item =\n+        CompletionItem::new(kind, ctx.source_range(), local_name.unescaped().to_smol_str());\n     item.set_relevance(ctx.completion_relevance())\n         .set_documentation(scope_def_docs(db, resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));"}, {"sha": "93ea825e00427bde6a6fb4f083131b051586eebc", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/const_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn render_const(ctx: RenderContext<'_>, const_: hir::Const) -> Option\n fn render(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem> {\n     let db = ctx.db();\n     let name = const_.name(db)?;\n-    let (name, escaped_name) = (name.to_smol_str(), name.escaped().to_smol_str());\n+    let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let detail = const_.display(db).to_string();\n \n     let mut item = CompletionItem::new(SymbolKind::Const, ctx.source_range(), name.clone());"}, {"sha": "9cf64691298ebcfe74576bbbbbc844edd217d3b4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -52,10 +52,10 @@ fn render(\n \n     let (call, escaped_call) = match &func_kind {\n         FuncKind::Method(_, Some(receiver)) => (\n-            format!(\"{}.{}\", receiver, &name).into(),\n-            format!(\"{}.{}\", receiver.escaped(), name.escaped()).into(),\n+            format!(\"{}.{}\", receiver.unescaped(), name.unescaped()).into(),\n+            format!(\"{}.{}\", receiver, name).into(),\n         ),\n-        _ => (name.to_smol_str(), name.escaped().to_smol_str()),\n+        _ => (name.unescaped().to_smol_str(), name.to_smol_str()),\n     };\n     let mut item = CompletionItem::new(\n         if func.self_param(db).is_some() {\n@@ -96,7 +96,7 @@ fn render(\n     item.set_documentation(ctx.docs(func))\n         .set_deprecated(ctx.is_deprecated(func) || ctx.is_deprecated_assoc_item(func))\n         .detail(detail(db, func))\n-        .lookup_by(name.to_smol_str());\n+        .lookup_by(name.unescaped().to_smol_str());\n \n     match ctx.completion.config.snippet_cap {\n         Some(cap) => {"}, {"sha": "707dea206be577efcc7cbb455692dbe4614418bb", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -73,7 +73,7 @@ fn render(\n         None => (name.clone().into(), name.into(), false),\n     };\n     let (qualified_name, escaped_qualified_name) =\n-        (qualified_name.to_string(), qualified_name.escaped().to_string());\n+        (qualified_name.unescaped().to_string(), qualified_name.to_string());\n     let snippet_cap = ctx.snippet_cap();\n \n     let mut rendered = match kind {"}, {"sha": "eabd0bd17d65ffe4fc965f82aeb7d17eee43e4df", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -46,7 +46,7 @@ fn render(\n         ctx.source_range()\n     };\n \n-    let (name, escaped_name) = (name.to_smol_str(), name.escaped().to_smol_str());\n+    let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let docs = ctx.docs(macro_);\n     let docs_str = docs.as_ref().map(Documentation::as_str).unwrap_or_default();\n     let is_fn_like = macro_.is_fn_like(completion.db);"}, {"sha": "1c1299e33b6701951dd1646ea5de10998f88970b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -31,7 +31,7 @@ pub(crate) fn render_struct_pat(\n     }\n \n     let name = local_name.unwrap_or_else(|| strukt.name(ctx.db()));\n-    let (name, escaped_name) = (name.to_smol_str(), name.escaped().to_smol_str());\n+    let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let kind = strukt.kind(ctx.db());\n     let label = format_literal_label(name.as_str(), kind);\n     let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n@@ -53,10 +53,10 @@ pub(crate) fn render_variant_pat(\n     let (visible_fields, fields_omitted) = visible_fields(ctx.completion, &fields, variant)?;\n \n     let (name, escaped_name) = match path {\n-        Some(path) => (path.to_string().into(), path.escaped().to_string().into()),\n+        Some(path) => (path.unescaped().to_string().into(), path.to_string().into()),\n         None => {\n             let name = local_name.unwrap_or_else(|| variant.name(ctx.db()));\n-            (name.to_smol_str(), name.escaped().to_smol_str())\n+            (name.unescaped().to_smol_str(), name.to_smol_str())\n         }\n     };\n \n@@ -146,7 +146,7 @@ fn render_record_as_pat(\n             format!(\n                 \"{name} {{ {}{} }}\",\n                 fields.enumerate().format_with(\", \", |(idx, field), f| {\n-                    f(&format_args!(\"{}${}\", field.name(db).escaped(), idx + 1))\n+                    f(&format_args!(\"{}${}\", field.name(db), idx + 1))\n                 }),\n                 if fields_omitted { \", ..\" } else { \"\" },\n                 name = name\n@@ -155,7 +155,7 @@ fn render_record_as_pat(\n         None => {\n             format!(\n                 \"{name} {{ {}{} }}\",\n-                fields.map(|field| field.name(db).escaped().to_smol_str()).format(\", \"),\n+                fields.map(|field| field.name(db).to_smol_str()).format(\", \"),\n                 if fields_omitted { \", ..\" } else { \"\" },\n                 name = name\n             )"}, {"sha": "de919429f2f95e5b04f75d77aadcc3bcfa1810bd", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/type_alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -32,11 +32,11 @@ fn render(\n     let name = type_alias.name(db);\n     let (name, escaped_name) = if with_eq {\n         (\n+            SmolStr::from_iter([&name.unescaped().to_smol_str(), \" = \"]),\n             SmolStr::from_iter([&name.to_smol_str(), \" = \"]),\n-            SmolStr::from_iter([&name.escaped().to_smol_str(), \" = \"]),\n         )\n     } else {\n-        (name.to_smol_str(), name.escaped().to_smol_str())\n+        (name.unescaped().to_smol_str(), name.to_smol_str())\n     };\n     let detail = type_alias.display(db).to_string();\n "}, {"sha": "bb32330f276de7853c3290be23277007c1f9c2cd", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -21,8 +21,8 @@ pub(crate) fn render_union_literal(\n     let name = local_name.unwrap_or_else(|| un.name(ctx.db()));\n \n     let (qualified_name, escaped_qualified_name) = match path {\n-        Some(p) => (p.to_string(), p.escaped().to_string()),\n-        None => (name.to_string(), name.escaped().to_string()),\n+        Some(p) => (p.unescaped().to_string(), p.to_string()),\n+        None => (name.unescaped().to_string(), name.to_string()),\n     };\n \n     let mut item = CompletionItem::new(\n@@ -42,15 +42,15 @@ pub(crate) fn render_union_literal(\n         format!(\n             \"{} {{ ${{1|{}|}}: ${{2:()}} }}$0\",\n             escaped_qualified_name,\n-            fields.iter().map(|field| field.name(ctx.db()).escaped().to_smol_str()).format(\",\")\n+            fields.iter().map(|field| field.name(ctx.db()).to_smol_str()).format(\",\")\n         )\n     } else {\n         format!(\n             \"{} {{ {} }}\",\n             escaped_qualified_name,\n-            fields.iter().format_with(\", \", |field, f| {\n-                f(&format_args!(\"{}: ()\", field.name(ctx.db()).escaped()))\n-            })\n+            fields\n+                .iter()\n+                .format_with(\", \", |field, f| { f(&format_args!(\"{}: ()\", field.name(ctx.db()))) })\n         )\n     };\n "}, {"sha": "664845330eb8f4ab16fe74c2ba8aa1c6065525db", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -24,9 +24,9 @@ pub(crate) fn render_record_lit(\n ) -> RenderedLiteral {\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, field), f| {\n         if snippet_cap.is_some() {\n-            f(&format_args!(\"{}: ${{{}:()}}\", field.name(db).escaped(), idx + 1))\n+            f(&format_args!(\"{}: ${{{}:()}}\", field.name(db), idx + 1))\n         } else {\n-            f(&format_args!(\"{}: ()\", field.name(db).escaped()))\n+            f(&format_args!(\"{}: ()\", field.name(db)))\n         }\n     });\n "}, {"sha": "328faaa060f04a6825a658a418f111f2cd9c8858", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -103,8 +103,9 @@ fn foo(f: Struct) {\n }\n \n #[test]\n-fn functional_update() {\n-    // FIXME: This should filter out all completions that do not have the type `Foo`\n+fn in_functional_update() {\n+    cov_mark::check!(functional_update);\n+\n     check(\n         r#\"\n //- minicore:default\n@@ -116,13 +117,21 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, $0 }\n+    let foo2 = Foo { thing, ..$0 }\n }\n \"#,\n         expect![[r#\"\n             fd ..Default::default()\n-            fd foo1                 u32\n-            fd foo2                 u32\n+            fn main()               fn()\n+            lc foo                  Foo\n+            lc thing                i32\n+            md core\n+            st Foo\n+            st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n+            tt Default\n+            bt u32\n+            kw crate::\n+            kw self::\n         \"#]],\n     );\n     check(\n@@ -136,14 +145,19 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, .$0 }\n+    let foo2 = Foo { thing, ..Default::$0 }\n }\n \"#,\n         expect![[r#\"\n-            fd ..Default::default()\n-            sn ..\n+            fn default() (as Default) fn() -> Self\n         \"#]],\n     );\n+}\n+\n+#[test]\n+fn functional_update_no_dot() {\n+    cov_mark::check!(functional_update_field);\n+    // FIXME: This should filter out all completions that do not have the type `Foo`\n     check(\n         r#\"\n //- minicore:default\n@@ -155,23 +169,20 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, ..$0 }\n+    let foo2 = Foo { thing, $0 }\n }\n \"#,\n         expect![[r#\"\n             fd ..Default::default()\n-            fn main()               fn()\n-            lc foo                  Foo\n-            lc thing                i32\n-            md core\n-            st Foo\n-            st Foo {\u2026}              Foo { foo1: u32, foo2: u32 }\n-            tt Default\n-            bt u32\n-            kw crate::\n-            kw self::\n+            fd foo1                 u32\n+            fd foo2                 u32\n         \"#]],\n     );\n+}\n+\n+#[test]\n+fn functional_update_one_dot() {\n+    cov_mark::check!(functional_update_one_dot);\n     check(\n         r#\"\n //- minicore:default\n@@ -183,11 +194,12 @@ impl Default for Foo {\n fn main() {\n     let thing = 1;\n     let foo = Foo { foo1: 0, foo2: 0 };\n-    let foo2 = Foo { thing, ..Default::$0 }\n+    let foo2 = Foo { thing, .$0 }\n }\n \"#,\n         expect![[r#\"\n-            fn default() (as Default) fn() -> Self\n+            fd ..Default::default()\n+            sn ..\n         \"#]],\n     );\n }"}, {"sha": "9eaabeec7a4e7e2669e6a0d5540a3896baede122", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -4,7 +4,7 @@\n //! get a super-set of matches. Then, we we confirm each match using precise\n //! name resolution.\n \n-use std::{convert::TryInto, mem, sync::Arc};\n+use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};"}, {"sha": "21314ad74ef9387eee0e0b81d8d8bc3d4e5a10bf", "filename": "src/tools/rust-analyzer/crates/ide-db/src/source_change.rs", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -3,12 +3,15 @@\n //!\n //! It can be viewed as a dual for `Change`.\n \n-use std::{collections::hash_map::Entry, iter};\n+use std::{collections::hash_map::Entry, iter, mem};\n \n use base_db::{AnchoredPathBuf, FileId};\n use rustc_hash::FxHashMap;\n use stdx::never;\n-use text_edit::TextEdit;\n+use syntax::{algo, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n+use text_edit::{TextEdit, TextEditBuilder};\n+\n+use crate::SnippetCap;\n \n #[derive(Default, Debug, Clone)]\n pub struct SourceChange {\n@@ -81,6 +84,135 @@ impl From<FxHashMap<FileId, TextEdit>> for SourceChange {\n     }\n }\n \n+pub struct SourceChangeBuilder {\n+    pub edit: TextEditBuilder,\n+    pub file_id: FileId,\n+    pub source_change: SourceChange,\n+    pub trigger_signature_help: bool,\n+\n+    /// Maps the original, immutable `SyntaxNode` to a `clone_for_update` twin.\n+    pub mutated_tree: Option<TreeMutator>,\n+}\n+\n+pub struct TreeMutator {\n+    immutable: SyntaxNode,\n+    mutable_clone: SyntaxNode,\n+}\n+\n+impl TreeMutator {\n+    pub fn new(immutable: &SyntaxNode) -> TreeMutator {\n+        let immutable = immutable.ancestors().last().unwrap();\n+        let mutable_clone = immutable.clone_for_update();\n+        TreeMutator { immutable, mutable_clone }\n+    }\n+\n+    pub fn make_mut<N: AstNode>(&self, node: &N) -> N {\n+        N::cast(self.make_syntax_mut(node.syntax())).unwrap()\n+    }\n+\n+    pub fn make_syntax_mut(&self, node: &SyntaxNode) -> SyntaxNode {\n+        let ptr = SyntaxNodePtr::new(node);\n+        ptr.to_node(&self.mutable_clone)\n+    }\n+}\n+\n+impl SourceChangeBuilder {\n+    pub fn new(file_id: FileId) -> SourceChangeBuilder {\n+        SourceChangeBuilder {\n+            edit: TextEdit::builder(),\n+            file_id,\n+            source_change: SourceChange::default(),\n+            trigger_signature_help: false,\n+            mutated_tree: None,\n+        }\n+    }\n+\n+    pub fn edit_file(&mut self, file_id: FileId) {\n+        self.commit();\n+        self.file_id = file_id;\n+    }\n+\n+    fn commit(&mut self) {\n+        if let Some(tm) = self.mutated_tree.take() {\n+            algo::diff(&tm.immutable, &tm.mutable_clone).into_text_edit(&mut self.edit)\n+        }\n+\n+        let edit = mem::take(&mut self.edit).finish();\n+        if !edit.is_empty() {\n+            self.source_change.insert_source_edit(self.file_id, edit);\n+        }\n+    }\n+\n+    pub fn make_mut<N: AstNode>(&mut self, node: N) -> N {\n+        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(node.syntax())).make_mut(&node)\n+    }\n+    /// Returns a copy of the `node`, suitable for mutation.\n+    ///\n+    /// Syntax trees in rust-analyzer are typically immutable, and mutating\n+    /// operations panic at runtime. However, it is possible to make a copy of\n+    /// the tree and mutate the copy freely. Mutation is based on interior\n+    /// mutability, and different nodes in the same tree see the same mutations.\n+    ///\n+    /// The typical pattern for an assist is to find specific nodes in the read\n+    /// phase, and then get their mutable couterparts using `make_mut` in the\n+    /// mutable state.\n+    pub fn make_syntax_mut(&mut self, node: SyntaxNode) -> SyntaxNode {\n+        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(&node)).make_syntax_mut(&node)\n+    }\n+\n+    /// Remove specified `range` of text.\n+    pub fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    /// Append specified `text` at the given `offset`\n+    pub fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n+    }\n+    /// Append specified `snippet` at the given `offset`\n+    pub fn insert_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        offset: TextSize,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.source_change.is_snippet = true;\n+        self.insert(offset, snippet);\n+    }\n+    /// Replaces specified `range` of text with a given string.\n+    pub fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n+        self.edit.replace(range, replace_with.into())\n+    }\n+    /// Replaces specified `range` of text with a given `snippet`.\n+    pub fn replace_snippet(\n+        &mut self,\n+        _cap: SnippetCap,\n+        range: TextRange,\n+        snippet: impl Into<String>,\n+    ) {\n+        self.source_change.is_snippet = true;\n+        self.replace(range, snippet);\n+    }\n+    pub fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n+    pub fn create_file(&mut self, dst: AnchoredPathBuf, content: impl Into<String>) {\n+        let file_system_edit = FileSystemEdit::CreateFile { dst, initial_contents: content.into() };\n+        self.source_change.push_file_system_edit(file_system_edit);\n+    }\n+    pub fn move_file(&mut self, src: FileId, dst: AnchoredPathBuf) {\n+        let file_system_edit = FileSystemEdit::MoveFile { src, dst };\n+        self.source_change.push_file_system_edit(file_system_edit);\n+    }\n+    pub fn trigger_signature_help(&mut self) {\n+        self.trigger_signature_help = true;\n+    }\n+\n+    pub fn finish(mut self) -> SourceChange {\n+        self.commit();\n+        mem::take(&mut self.source_change)\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub enum FileSystemEdit {\n     CreateFile { dst: AnchoredPathBuf, initial_contents: String },"}, {"sha": "9b9e21a4ddb592d3519a6e2778e9ac6da003e257", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -15,6 +15,7 @@ itertools = \"0.10.3\"\n \n \n either = \"1.7.0\"\n+serde_json = \"1.0.82\"\n \n profile = { path = \"../profile\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "5694f33525e0114890f3ebd29e7fb16c4e65af81", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -43,7 +43,7 @@ mod tests {\n     use crate::{tests::check_diagnostics_with_config, DiagnosticsConfig};\n \n     pub(crate) fn check(ra_fixture: &str) {\n-        let config = DiagnosticsConfig::default();\n+        let config = DiagnosticsConfig::test_sample();\n         check_diagnostics_with_config(config, ra_fixture)\n     }\n "}, {"sha": "a21db5b2cec9d448535f120a1bf244db8bb3301c", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/json_is_not_rust.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fjson_is_not_rust.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -0,0 +1,310 @@\n+//! This diagnostic provides an assist for creating a struct definition from a JSON\n+//! example.\n+\n+use hir::{PathResolution, Semantics};\n+use ide_db::{\n+    base_db::FileId,\n+    helpers::mod_path_to_ast,\n+    imports::insert_use::{insert_use, ImportScope},\n+    source_change::SourceChangeBuilder,\n+    RootDatabase,\n+};\n+use itertools::Itertools;\n+use stdx::{format_to, never};\n+use syntax::{\n+    ast::{self, make},\n+    SyntaxKind, SyntaxNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsConfig, Severity};\n+\n+#[derive(Default)]\n+struct State {\n+    result: String,\n+    struct_counts: usize,\n+    has_serialize: bool,\n+    has_deserialize: bool,\n+}\n+\n+impl State {\n+    fn generate_new_name(&mut self) -> ast::Name {\n+        self.struct_counts += 1;\n+        make::name(&format!(\"Struct{}\", self.struct_counts))\n+    }\n+\n+    fn serde_derive(&self) -> String {\n+        let mut v = vec![];\n+        if self.has_serialize {\n+            v.push(\"Serialize\");\n+        }\n+        if self.has_deserialize {\n+            v.push(\"Deserialize\");\n+        }\n+        match v.as_slice() {\n+            [] => \"\".to_string(),\n+            [x] => format!(\"#[derive({x})]\\n\"),\n+            [x, y] => format!(\"#[derive({x}, {y})]\\n\"),\n+            _ => {\n+                never!();\n+                \"\".to_string()\n+            }\n+        }\n+    }\n+\n+    fn build_struct(&mut self, value: &serde_json::Map<String, serde_json::Value>) -> ast::Type {\n+        let name = self.generate_new_name();\n+        let ty = make::ty(&name.to_string());\n+        let strukt = make::struct_(\n+            None,\n+            name,\n+            None,\n+            make::record_field_list(value.iter().sorted_unstable_by_key(|x| x.0).map(\n+                |(name, value)| make::record_field(None, make::name(name), self.type_of(value)),\n+            ))\n+            .into(),\n+        );\n+        format_to!(self.result, \"{}{}\\n\", self.serde_derive(), strukt);\n+        ty\n+    }\n+\n+    fn type_of(&mut self, value: &serde_json::Value) -> ast::Type {\n+        match value {\n+            serde_json::Value::Null => make::ty_unit(),\n+            serde_json::Value::Bool(_) => make::ty(\"bool\"),\n+            serde_json::Value::Number(it) => make::ty(if it.is_i64() { \"i64\" } else { \"f64\" }),\n+            serde_json::Value::String(_) => make::ty(\"String\"),\n+            serde_json::Value::Array(it) => {\n+                let ty = match it.iter().next() {\n+                    Some(x) => self.type_of(x),\n+                    None => make::ty_placeholder(),\n+                };\n+                make::ty(&format!(\"Vec<{ty}>\"))\n+            }\n+            serde_json::Value::Object(x) => self.build_struct(x),\n+        }\n+    }\n+}\n+\n+pub(crate) fn json_in_items(\n+    sema: &Semantics<'_, RootDatabase>,\n+    acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+    config: &DiagnosticsConfig,\n+) {\n+    (|| {\n+        if node.kind() == SyntaxKind::ERROR\n+            && node.first_token().map(|x| x.kind()) == Some(SyntaxKind::L_CURLY)\n+            && node.last_token().map(|x| x.kind()) == Some(SyntaxKind::R_CURLY)\n+        {\n+            let node_string = node.to_string();\n+            if let Ok(it) = serde_json::from_str(&node_string) {\n+                if let serde_json::Value::Object(it) = it {\n+                    let import_scope = ImportScope::find_insert_use_container(node, sema)?;\n+                    let range = node.text_range();\n+                    let mut edit = TextEdit::builder();\n+                    edit.delete(range);\n+                    let mut state = State::default();\n+                    let semantics_scope = sema.scope(node)?;\n+                    let scope_resolve =\n+                        |it| semantics_scope.speculative_resolve(&make::path_from_text(it));\n+                    let scope_has = |it| scope_resolve(it).is_some();\n+                    let deserialize_resolved = scope_resolve(\"::serde::Deserialize\");\n+                    let serialize_resolved = scope_resolve(\"::serde::Serialize\");\n+                    state.has_deserialize = deserialize_resolved.is_some();\n+                    state.has_serialize = serialize_resolved.is_some();\n+                    state.build_struct(&it);\n+                    edit.insert(range.start(), state.result);\n+                    acc.push(\n+                        Diagnostic::new(\n+                            \"json-is-not-rust\",\n+                            \"JSON syntax is not valid as a Rust item\",\n+                            range,\n+                        )\n+                        .severity(Severity::WeakWarning)\n+                        .with_fixes(Some(vec![{\n+                            let mut scb = SourceChangeBuilder::new(file_id);\n+                            let scope = match import_scope.clone() {\n+                                ImportScope::File(it) => ImportScope::File(scb.make_mut(it)),\n+                                ImportScope::Module(it) => ImportScope::Module(scb.make_mut(it)),\n+                                ImportScope::Block(it) => ImportScope::Block(scb.make_mut(it)),\n+                            };\n+                            let current_module = semantics_scope.module();\n+                            if !scope_has(\"Serialize\") {\n+                                if let Some(PathResolution::Def(it)) = serialize_resolved {\n+                                    if let Some(it) = current_module.find_use_path_prefixed(\n+                                        sema.db,\n+                                        it,\n+                                        config.insert_use.prefix_kind,\n+                                    ) {\n+                                        insert_use(\n+                                            &scope,\n+                                            mod_path_to_ast(&it),\n+                                            &config.insert_use,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                            if !scope_has(\"Deserialize\") {\n+                                if let Some(PathResolution::Def(it)) = deserialize_resolved {\n+                                    if let Some(it) = current_module.find_use_path_prefixed(\n+                                        sema.db,\n+                                        it,\n+                                        config.insert_use.prefix_kind,\n+                                    ) {\n+                                        insert_use(\n+                                            &scope,\n+                                            mod_path_to_ast(&it),\n+                                            &config.insert_use,\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                            let mut sc = scb.finish();\n+                            sc.insert_source_edit(file_id, edit.finish());\n+                            fix(\"convert_json_to_struct\", \"Convert JSON to struct\", sc, range)\n+                        }])),\n+                    );\n+                }\n+            }\n+        }\n+        Some(())\n+    })();\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        tests::{check_diagnostics_with_config, check_fix, check_no_fix},\n+        DiagnosticsConfig,\n+    };\n+\n+    #[test]\n+    fn diagnostic_for_simple_case() {\n+        let mut config = DiagnosticsConfig::test_sample();\n+        config.disabled.insert(\"syntax-error\".to_string());\n+        check_diagnostics_with_config(\n+            config,\n+            r#\"\n+            { \"foo\": \"bar\" }\n+         // ^^^^^^^^^^^^^^^^ \ud83d\udca1 weak: JSON syntax is not valid as a Rust item\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn types_of_primitives() {\n+        check_fix(\n+            r#\"\n+            //- /lib.rs crate:lib deps:serde\n+            use serde::Serialize;\n+\n+            fn some_garbage() {\n+\n+            }\n+\n+            {$0\n+                \"foo\": \"bar\",\n+                \"bar\": 2.3,\n+                \"baz\": null,\n+                \"bay\": 57,\n+                \"box\": true\n+            }\n+            //- /serde.rs crate:serde\n+\n+            pub trait Serialize {\n+                fn serialize() -> u8;\n+            }\n+            \"#,\n+            r#\"\n+            use serde::Serialize;\n+\n+            fn some_garbage() {\n+\n+            }\n+\n+            #[derive(Serialize)]\n+            struct Struct1{ bar: f64, bay: i64, baz: (), r#box: bool, foo: String }\n+\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_structs() {\n+        check_fix(\n+            r#\"\n+            {$0\n+                \"foo\": \"bar\",\n+                \"bar\": {\n+                    \"kind\": \"Object\",\n+                    \"value\": {}\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            struct Struct3{  }\n+            struct Struct2{ kind: String, value: Struct3 }\n+            struct Struct1{ bar: Struct2, foo: String }\n+\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn arrays() {\n+        check_fix(\n+            r#\"\n+            //- /lib.rs crate:lib deps:serde\n+            {\n+                \"of_string\": [\"foo\", \"2\", \"x\"], $0\n+                \"of_object\": [{\n+                    \"x\": 10,\n+                    \"y\": 20\n+                }, {\n+                    \"x\": 10,\n+                    \"y\": 20\n+                }],\n+                \"nested\": [[[2]]],\n+                \"empty\": []\n+            }\n+            //- /serde.rs crate:serde\n+\n+            pub trait Serialize {\n+                fn serialize() -> u8;\n+            }\n+            pub trait Deserialize {\n+                fn deserialize() -> u8;\n+            }\n+            \"#,\n+            r#\"\n+            use serde::Serialize;\n+            use serde::Deserialize;\n+\n+            #[derive(Serialize, Deserialize)]\n+            struct Struct2{ x: i64, y: i64 }\n+            #[derive(Serialize, Deserialize)]\n+            struct Struct1{ empty: Vec<_>, nested: Vec<Vec<Vec<i64>>>, of_object: Vec<Struct2>, of_string: Vec<String> }\n+\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_emit_outside_of_item_position() {\n+        check_no_fix(\n+            r#\"\n+            fn foo() {\n+                let json = {$0\n+                    \"foo\": \"bar\",\n+                    \"bar\": {\n+                        \"kind\": \"Object\",\n+                        \"value\": {}\n+                    }\n+                };\n+            }\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "43ff4ed5a6c8637fc4f6af611e48338cf184ec33", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/macro_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -79,7 +79,7 @@ pub macro panic {\n \n     #[test]\n     fn include_macro_should_allow_empty_content() {\n-        let mut config = DiagnosticsConfig::default();\n+        let mut config = DiagnosticsConfig::test_sample();\n \n         // FIXME: This is a false-positive, the file is actually linked in via\n         // `include!` macro"}, {"sha": "a80299106bd36d2a06b4176d4e6fd5eebed4e82f", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -68,7 +68,7 @@ fn missing_record_expr_field_fixes(\n     }\n     let new_field = make::record_field(\n         None,\n-        make::name(&record_expr_field.field_name()?.text()),\n+        make::name(&record_expr_field.field_name()?.ident_token()?.text()),\n         make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n     );\n \n@@ -109,7 +109,7 @@ fn missing_record_expr_field_fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn no_such_field_diagnostics() {\n@@ -277,6 +277,20 @@ struct Foo {\n     bar: i32,\n     pub(crate) baz: bool\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_tuple_field_on_record_struct() {\n+        check_no_fix(\n+            r#\"\n+struct Struct {}\n+fn main() {\n+    Struct {\n+        0$0: 0\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "61e63ea7a93ca68b37f19e172d1a2db08ebe537c", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -50,6 +50,7 @@ mod handlers {\n     pub(crate) mod field_shorthand;\n     pub(crate) mod useless_braces;\n     pub(crate) mod unlinked_file;\n+    pub(crate) mod json_is_not_rust;\n }\n \n #[cfg(test)]\n@@ -59,6 +60,7 @@ use hir::{diagnostics::AnyDiagnostic, InFile, Semantics};\n use ide_db::{\n     assists::{Assist, AssistId, AssistKind, AssistResolveStrategy},\n     base_db::{FileId, FileRange, SourceDatabase},\n+    imports::insert_use::InsertUseConfig,\n     label::Label,\n     source_change::SourceChange,\n     FxHashSet, RootDatabase,\n@@ -139,13 +141,37 @@ impl Default for ExprFillDefaultMode {\n     }\n }\n \n-#[derive(Default, Debug, Clone)]\n+#[derive(Debug, Clone)]\n pub struct DiagnosticsConfig {\n     pub proc_macros_enabled: bool,\n     pub proc_attr_macros_enabled: bool,\n     pub disable_experimental: bool,\n     pub disabled: FxHashSet<String>,\n     pub expr_fill_default: ExprFillDefaultMode,\n+    // FIXME: We may want to include a whole `AssistConfig` here\n+    pub insert_use: InsertUseConfig,\n+}\n+\n+impl DiagnosticsConfig {\n+    pub fn test_sample() -> Self {\n+        use hir::PrefixKind;\n+        use ide_db::imports::insert_use::ImportGranularity;\n+\n+        Self {\n+            proc_macros_enabled: Default::default(),\n+            proc_attr_macros_enabled: Default::default(),\n+            disable_experimental: Default::default(),\n+            disabled: Default::default(),\n+            expr_fill_default: Default::default(),\n+            insert_use: InsertUseConfig {\n+                granularity: ImportGranularity::Preserve,\n+                enforce_granularity: false,\n+                prefix_kind: PrefixKind::Plain,\n+                group: false,\n+                skip_glob_imports: false,\n+            },\n+        }\n+    }\n }\n \n struct DiagnosticsContext<'a> {\n@@ -172,9 +198,12 @@ pub fn diagnostics(\n         }),\n     );\n \n-    for node in parse.tree().syntax().descendants() {\n+    let parse = sema.parse(file_id);\n+\n+    for node in parse.syntax().descendants() {\n         handlers::useless_braces::useless_braces(&mut res, file_id, &node);\n         handlers::field_shorthand::field_shorthand(&mut res, file_id, &node);\n+        handlers::json_is_not_rust::json_in_items(&sema, &mut res, file_id, &node, &config);\n     }\n \n     let module = sema.to_module_def(file_id);"}, {"sha": "729619cfde03f68ca15fbe666d26ce6e292f6da3", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Ftests.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -37,7 +37,7 @@ fn check_nth_fix(nth: usize, ra_fixture_before: &str, ra_fixture_after: &str) {\n     let after = trim_indent(ra_fixture_after);\n \n     let (db, file_position) = RootDatabase::with_position(ra_fixture_before);\n-    let mut conf = DiagnosticsConfig::default();\n+    let mut conf = DiagnosticsConfig::test_sample();\n     conf.expr_fill_default = ExprFillDefaultMode::Default;\n     let diagnostic =\n         super::diagnostics(&db, &conf, &AssistResolveStrategy::All, file_position.file_id)\n@@ -69,7 +69,7 @@ pub(crate) fn check_no_fix(ra_fixture: &str) {\n     let (db, file_position) = RootDatabase::with_position(ra_fixture);\n     let diagnostic = super::diagnostics(\n         &db,\n-        &DiagnosticsConfig::default(),\n+        &DiagnosticsConfig::test_sample(),\n         &AssistResolveStrategy::All,\n         file_position.file_id,\n     )\n@@ -82,7 +82,7 @@ pub(crate) fn check_expect(ra_fixture: &str, expect: Expect) {\n     let (db, file_id) = RootDatabase::with_single_file(ra_fixture);\n     let diagnostics = super::diagnostics(\n         &db,\n-        &DiagnosticsConfig::default(),\n+        &DiagnosticsConfig::test_sample(),\n         &AssistResolveStrategy::All,\n         file_id,\n     );\n@@ -91,7 +91,7 @@ pub(crate) fn check_expect(ra_fixture: &str, expect: Expect) {\n \n #[track_caller]\n pub(crate) fn check_diagnostics(ra_fixture: &str) {\n-    let mut config = DiagnosticsConfig::default();\n+    let mut config = DiagnosticsConfig::test_sample();\n     config.disabled.insert(\"inactive-code\".to_string());\n     check_diagnostics_with_config(config, ra_fixture)\n }\n@@ -127,7 +127,7 @@ pub(crate) fn check_diagnostics_with_config(config: DiagnosticsConfig, ra_fixtur\n \n #[test]\n fn test_disabled_diagnostics() {\n-    let mut config = DiagnosticsConfig::default();\n+    let mut config = DiagnosticsConfig::test_sample();\n     config.disabled.insert(\"unresolved-module\".into());\n \n     let (db, file_id) = RootDatabase::with_single_file(r#\"mod foo;\"#);\n@@ -137,7 +137,7 @@ fn test_disabled_diagnostics() {\n \n     let diagnostics = super::diagnostics(\n         &db,\n-        &DiagnosticsConfig::default(),\n+        &DiagnosticsConfig::test_sample(),\n         &AssistResolveStrategy::All,\n         file_id,\n     );"}, {"sha": "d6cd5783f05ef0cf2a90f449c65f07a5c2dba6f0", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,4 +1,4 @@\n-use std::{convert::TryInto, mem::discriminant};\n+use std::mem::discriminant;\n \n use crate::{doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo, TryToNav};\n use hir::{AsAssocItem, AssocItem, Semantics};"}, {"sha": "0181c6b8e456a1881e723ce139ef105e4f4be92a", "filename": "src/tools/rust-analyzer/crates/ide/src/runnables.rs", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -2225,4 +2225,190 @@ macro_rules! foo {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_paths_with_raw_ident() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+mod r#mod {\n+    #[test]\n+    fn r#fn() {}\n+\n+    /// ```\n+    /// ```\n+    fn r#for() {}\n+\n+    /// ```\n+    /// ```\n+    struct r#struct<r#type>(r#type);\n+\n+    /// ```\n+    /// ```\n+    impl<r#type> r#struct<r#type> {\n+        /// ```\n+        /// ```\n+        fn r#fn() {}\n+    }\n+\n+    enum r#enum {}\n+    impl r#struct<r#enum> {\n+        /// ```\n+        /// ```\n+        fn r#fn() {}\n+    }\n+\n+    trait r#trait {}\n+\n+    /// ```\n+    /// ```\n+    impl<T> r#trait for r#struct<T> {}\n+}\n+\"#,\n+            &[TestMod, Test, DocTest, DocTest, DocTest, DocTest, DocTest, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..461,\n+                            focus_range: 5..10,\n+                            name: \"r#mod\",\n+                            kind: Module,\n+                            description: \"mod r#mod\",\n+                        },\n+                        kind: TestMod {\n+                            path: \"r#mod\",\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 17..41,\n+                            focus_range: 32..36,\n+                            name: \"r#fn\",\n+                            kind: Function,\n+                        },\n+                        kind: Test {\n+                            test_id: Path(\n+                                \"r#mod::r#fn\",\n+                            ),\n+                            attr: TestAttr {\n+                                ignore: false,\n+                            },\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 47..84,\n+                            name: \"r#for\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#mod::r#for\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 90..146,\n+                            name: \"r#struct\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#mod::r#struct\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 152..266,\n+                            focus_range: 189..205,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#struct<r#type>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 216..260,\n+                            name: \"r#fn\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#mod::r#struct<r#type>::r#fn\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 323..367,\n+                            name: \"r#fn\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#mod::r#struct<r#enum>::r#fn\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 401..459,\n+                            focus_range: 445..456,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"r#struct<T>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "f4d0387440d475e23e4e7ef466cc608f3f9565de", "filename": "src/tools/rust-analyzer/crates/ide/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,4 +1,4 @@\n-use std::{fmt, iter::FromIterator, sync::Arc};\n+use std::{fmt, sync::Arc};\n \n use hir::{ExpandResult, MacroFile};\n use ide_db::base_db::{"}, {"sha": "e4c56565b92d4c6627406b0f762321aa7c89a898", "filename": "src/tools/rust-analyzer/crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -228,16 +228,7 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n             }\n \n             let spacing = match conv.peek().map(|next| next.kind(conv)) {\n-                Some(kind)\n-                    if !kind.is_trivia()\n-                        && kind.is_punct()\n-                        && kind != T!['[']\n-                        && kind != T!['{']\n-                        && kind != T!['(']\n-                        && kind != UNDERSCORE =>\n-                {\n-                    tt::Spacing::Joint\n-                }\n+                Some(kind) if !kind.is_trivia() => tt::Spacing::Joint,\n                 _ => tt::Spacing::Alone,\n             };\n             let char = match token.to_char(conv) {"}, {"sha": "dcaceade652ab654263e2f20d865e58395175abe", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -564,8 +564,10 @@ fn path_expr(p: &mut Parser<'_>, r: Restrictions) -> (CompletedMarker, BlockLike\n // test record_lit\n // fn foo() {\n //     S {};\n+//     S { x };\n //     S { x, y: 32, };\n //     S { x, y: 32, ..Default::default() };\n+//     S { x: ::default() };\n //     TupleStruct { 0: 1 };\n // }\n pub(crate) fn record_expr_field_list(p: &mut Parser<'_>) {\n@@ -582,16 +584,26 @@ pub(crate) fn record_expr_field_list(p: &mut Parser<'_>) {\n \n         match p.current() {\n             IDENT | INT_NUMBER => {\n-                // test_err record_literal_before_ellipsis_recovery\n+                // test_err record_literal_missing_ellipsis_recovery\n                 // fn main() {\n-                //     S { field ..S::default() }\n+                //     S { S::default() }\n                 // }\n-                if p.nth_at(1, T![:]) || p.nth_at(1, T![..]) {\n-                    name_ref_or_index(p);\n-                    p.expect(T![:]);\n+                if p.nth_at(1, T![::]) {\n+                    m.abandon(p);\n+                    p.expect(T![..]);\n+                    expr(p);\n+                } else {\n+                    // test_err record_literal_before_ellipsis_recovery\n+                    // fn main() {\n+                    //     S { field ..S::default() }\n+                    // }\n+                    if p.nth_at(1, T![:]) || p.nth_at(1, T![..]) {\n+                        name_ref_or_index(p);\n+                        p.expect(T![:]);\n+                    }\n+                    expr(p);\n+                    m.complete(p, RECORD_EXPR_FIELD);\n                 }\n-                expr(p);\n-                m.complete(p, RECORD_EXPR_FIELD);\n             }\n             T![.] if p.at(T![..]) => {\n                 m.abandon(p);"}, {"sha": "7e21a808da0a481af06c98aa2829ccdc7f27a17d", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -75,6 +75,16 @@ fn pattern_single_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n         //         Some(1..) => ()\n         //     }\n         //\n+        //     match () {\n+        //         S { a: 0 } => (),\n+        //         S { a: 1.. } => (),\n+        //     }\n+        //\n+        //     match () {\n+        //         [0] => (),\n+        //         [1..] => (),\n+        //     }\n+        //\n         //     match (10 as u8, 5 as u8) {\n         //         (0, _) => (),\n         //         (1.., _) => ()\n@@ -88,11 +98,27 @@ fn pattern_single_r(p: &mut Parser<'_>, recovery_set: TokenSet) {\n                 let m = lhs.precede(p);\n                 p.bump(range_op);\n \n-                // `0 .. =>` or `let 0 .. =` or `Some(0 .. )`\n-                //       ^                ^                ^\n-                if p.at(T![=]) | p.at(T![')']) | p.at(T![,]) {\n+                // testing if we're at one of the following positions:\n+                // `0 .. =>`\n+                //       ^\n+                // `let 0 .. =`\n+                //           ^\n+                // `let 0..: _ =`\n+                //         ^\n+                // (1.., _)\n+                //     ^\n+                // `Some(0 .. )`\n+                //            ^\n+                // `S { t: 0.. }`\n+                //             ^\n+                // `[0..]`\n+                //      ^\n+                if matches!(p.current(), T![=] | T![,] | T![:] | T![')'] | T!['}'] | T![']']) {\n                     // test half_open_range_pat\n-                    // fn f() { let 0 .. = 1u32; }\n+                    // fn f() {\n+                    //     let 0 .. = 1u32;\n+                    //     let 0..: _ = 1u32;\n+                    // }\n                 } else {\n                     atom_pat(p, recovery_set);\n                 }"}, {"sha": "0c5b618e6f05c37a223cd8b4ea6d085f94b3186a", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0014_record_literal_missing_ellipsis_recovery.rast", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rast?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -0,0 +1,43 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"main\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        RECORD_EXPR\n+          PATH\n+            PATH_SEGMENT\n+              NAME_REF\n+                IDENT \"S\"\n+          WHITESPACE \" \"\n+          RECORD_EXPR_FIELD_LIST\n+            L_CURLY \"{\"\n+            WHITESPACE \" \"\n+            CALL_EXPR\n+              PATH_EXPR\n+                PATH\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"S\"\n+                  COLON2 \"::\"\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"default\"\n+              ARG_LIST\n+                L_PAREN \"(\"\n+                R_PAREN \")\"\n+            WHITESPACE \" \"\n+            R_CURLY \"}\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 19: expected DOT2"}, {"sha": "1b594e8ab962cf8084cc0b5970f38133fd3e6785", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0014_record_literal_missing_ellipsis_recovery.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0014_record_literal_missing_ellipsis_recovery.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    S { S::default() }\n+}"}, {"sha": "cfef5d3f95387dc58562d7aa14c9a6c8102d3e2f", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0058_range_pat.rast", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rast?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -172,6 +172,122 @@ SOURCE_FILE\n               WHITESPACE \"\\n    \"\n               R_CURLY \"}\"\n         WHITESPACE \"\\n\\n    \"\n+        EXPR_STMT\n+          MATCH_EXPR\n+            MATCH_KW \"match\"\n+            WHITESPACE \" \"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            WHITESPACE \" \"\n+            MATCH_ARM_LIST\n+              L_CURLY \"{\"\n+              WHITESPACE \"\\n        \"\n+              MATCH_ARM\n+                RECORD_PAT\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"S\"\n+                  WHITESPACE \" \"\n+                  RECORD_PAT_FIELD_LIST\n+                    L_CURLY \"{\"\n+                    WHITESPACE \" \"\n+                    RECORD_PAT_FIELD\n+                      NAME_REF\n+                        IDENT \"a\"\n+                      COLON \":\"\n+                      WHITESPACE \" \"\n+                      LITERAL_PAT\n+                        LITERAL\n+                          INT_NUMBER \"0\"\n+                    WHITESPACE \" \"\n+                    R_CURLY \"}\"\n+                WHITESPACE \" \"\n+                FAT_ARROW \"=>\"\n+                WHITESPACE \" \"\n+                TUPLE_EXPR\n+                  L_PAREN \"(\"\n+                  R_PAREN \")\"\n+                COMMA \",\"\n+              WHITESPACE \"\\n        \"\n+              MATCH_ARM\n+                RECORD_PAT\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"S\"\n+                  WHITESPACE \" \"\n+                  RECORD_PAT_FIELD_LIST\n+                    L_CURLY \"{\"\n+                    WHITESPACE \" \"\n+                    RECORD_PAT_FIELD\n+                      NAME_REF\n+                        IDENT \"a\"\n+                      COLON \":\"\n+                      WHITESPACE \" \"\n+                      RANGE_PAT\n+                        LITERAL_PAT\n+                          LITERAL\n+                            INT_NUMBER \"1\"\n+                        DOT2 \"..\"\n+                    WHITESPACE \" \"\n+                    R_CURLY \"}\"\n+                WHITESPACE \" \"\n+                FAT_ARROW \"=>\"\n+                WHITESPACE \" \"\n+                TUPLE_EXPR\n+                  L_PAREN \"(\"\n+                  R_PAREN \")\"\n+                COMMA \",\"\n+              WHITESPACE \"\\n    \"\n+              R_CURLY \"}\"\n+        WHITESPACE \"\\n\\n    \"\n+        EXPR_STMT\n+          MATCH_EXPR\n+            MATCH_KW \"match\"\n+            WHITESPACE \" \"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            WHITESPACE \" \"\n+            MATCH_ARM_LIST\n+              L_CURLY \"{\"\n+              WHITESPACE \"\\n        \"\n+              MATCH_ARM\n+                SLICE_PAT\n+                  L_BRACK \"[\"\n+                  LITERAL_PAT\n+                    LITERAL\n+                      INT_NUMBER \"0\"\n+                  R_BRACK \"]\"\n+                WHITESPACE \" \"\n+                FAT_ARROW \"=>\"\n+                WHITESPACE \" \"\n+                TUPLE_EXPR\n+                  L_PAREN \"(\"\n+                  R_PAREN \")\"\n+                COMMA \",\"\n+              WHITESPACE \"\\n        \"\n+              MATCH_ARM\n+                SLICE_PAT\n+                  L_BRACK \"[\"\n+                  RANGE_PAT\n+                    LITERAL_PAT\n+                      LITERAL\n+                        INT_NUMBER \"1\"\n+                    DOT2 \"..\"\n+                  R_BRACK \"]\"\n+                WHITESPACE \" \"\n+                FAT_ARROW \"=>\"\n+                WHITESPACE \" \"\n+                TUPLE_EXPR\n+                  L_PAREN \"(\"\n+                  R_PAREN \")\"\n+                COMMA \",\"\n+              WHITESPACE \"\\n    \"\n+              R_CURLY \"}\"\n+        WHITESPACE \"\\n\\n    \"\n         MATCH_EXPR\n           MATCH_KW \"match\"\n           WHITESPACE \" \""}, {"sha": "2411d51096b3b0a1c65f884b8d103d9ba1f5fc54", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0058_range_pat.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0058_range_pat.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -11,6 +11,16 @@ fn main() {\n         Some(1..) => ()\n     }\n \n+    match () {\n+        S { a: 0 } => (),\n+        S { a: 1.. } => (),\n+    }\n+\n+    match () {\n+        [0] => (),\n+        [1..] => (),\n+    }\n+\n     match (10 as u8, 5 as u8) {\n         (0, _) => (),\n         (1.., _) => ()"}, {"sha": "00948c322f4c949ff757ba9711ee128074ceb8f7", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0061_record_lit.rast", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rast?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -24,6 +24,26 @@ SOURCE_FILE\n               R_CURLY \"}\"\n           SEMICOLON \";\"\n         WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          RECORD_EXPR\n+            PATH\n+              PATH_SEGMENT\n+                NAME_REF\n+                  IDENT \"S\"\n+            WHITESPACE \" \"\n+            RECORD_EXPR_FIELD_LIST\n+              L_CURLY \"{\"\n+              WHITESPACE \" \"\n+              RECORD_EXPR_FIELD\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"x\"\n+              WHITESPACE \" \"\n+              R_CURLY \"}\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n         EXPR_STMT\n           RECORD_EXPR\n             PATH\n@@ -100,6 +120,35 @@ SOURCE_FILE\n               R_CURLY \"}\"\n           SEMICOLON \";\"\n         WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          RECORD_EXPR\n+            PATH\n+              PATH_SEGMENT\n+                NAME_REF\n+                  IDENT \"S\"\n+            WHITESPACE \" \"\n+            RECORD_EXPR_FIELD_LIST\n+              L_CURLY \"{\"\n+              WHITESPACE \" \"\n+              RECORD_EXPR_FIELD\n+                NAME_REF\n+                  IDENT \"x\"\n+                COLON \":\"\n+                WHITESPACE \" \"\n+                CALL_EXPR\n+                  PATH_EXPR\n+                    PATH\n+                      PATH_SEGMENT\n+                        COLON2 \"::\"\n+                        NAME_REF\n+                          IDENT \"default\"\n+                  ARG_LIST\n+                    L_PAREN \"(\"\n+                    R_PAREN \")\"\n+              WHITESPACE \" \"\n+              R_CURLY \"}\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n         EXPR_STMT\n           RECORD_EXPR\n             PATH"}, {"sha": "86411fbb7dc050866e96bf08da1b82218d374330", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0061_record_lit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0061_record_lit.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,6 +1,8 @@\n fn foo() {\n     S {};\n+    S { x };\n     S { x, y: 32, };\n     S { x, y: 32, ..Default::default() };\n+    S { x: ::default() };\n     TupleStruct { 0: 1 };\n }"}, {"sha": "4b401b60df0cec3058cfc02ce3df34412122ade7", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0166_half_open_range_pat.rast", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rast?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -11,7 +11,7 @@ SOURCE_FILE\n     BLOCK_EXPR\n       STMT_LIST\n         L_CURLY \"{\"\n-        WHITESPACE \" \"\n+        WHITESPACE \"\\n    \"\n         LET_STMT\n           LET_KW \"let\"\n           WHITESPACE \" \"\n@@ -27,6 +27,25 @@ SOURCE_FILE\n           LITERAL\n             INT_NUMBER \"1u32\"\n           SEMICOLON \";\"\n-        WHITESPACE \" \"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          RANGE_PAT\n+            LITERAL_PAT\n+              LITERAL\n+                INT_NUMBER \"0\"\n+            DOT2 \"..\"\n+          COLON \":\"\n+          WHITESPACE \" \"\n+          INFER_TYPE\n+            UNDERSCORE \"_\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          LITERAL\n+            INT_NUMBER \"1u32\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "c9386a221a9556d18f00ff241c48b4a7e9b08575", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0166_half_open_range_pat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0166_half_open_range_pat.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1 +1,4 @@\n-fn f() { let 0 .. = 1u32; }\n+fn f() {\n+    let 0 .. = 1u32;\n+    let 0..: _ = 1u32;\n+}"}, {"sha": "268a03bb5359b607343d9cecd8daaa60291f8db1", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/msg/flat.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fmsg%2Fflat.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -35,10 +35,7 @@\n //! as we don't have bincode in Cargo.toml yet, lets stick with serde_json for\n //! the time being.\n \n-use std::{\n-    collections::{HashMap, VecDeque},\n-    convert::TryInto,\n-};\n+use std::collections::{HashMap, VecDeque};\n \n use serde::{Deserialize, Serialize};\n use tt::TokenId;"}, {"sha": "a405497f3c9b7858da927d1b5d1be5eedff0c261", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/proc_macro/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fproc_macro%2Fmod.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -157,15 +157,15 @@ impl From<TokenTree> for TokenStream {\n }\n \n /// Collects a number of token trees into a single stream.\n-impl iter::FromIterator<TokenTree> for TokenStream {\n+impl FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         trees.into_iter().map(TokenStream::from).collect()\n     }\n }\n \n /// A \"flattening\" operation on token streams, collects token trees\n /// from multiple token streams into a single stream.\n-impl iter::FromIterator<TokenStream> for TokenStream {\n+impl FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n         let mut builder = bridge::client::TokenStreamBuilder::new();\n         streams.into_iter().for_each(|stream| builder.push(stream.0));"}, {"sha": "b1e982f4779f7fde6567f3b9e5d64532e4f2ac87", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_58/ra_server.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_58%2Fra_server.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -12,7 +12,6 @@ use super::proc_macro::bridge::{self, server};\n \n use std::collections::HashMap;\n use std::hash::Hash;\n-use std::iter::FromIterator;\n use std::ops::Bound;\n use std::{ascii, vec::IntoIter};\n "}, {"sha": "7ab1f421daf897a9408c45b4334f37b1c89038f1", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -207,15 +207,15 @@ impl ConcatStreamsHelper {\n }\n \n /// Collects a number of token trees into a single stream.\n-impl iter::FromIterator<TokenTree> for TokenStream {\n+impl FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         trees.into_iter().map(TokenStream::from).collect()\n     }\n }\n \n /// A \"flattening\" operation on token streams, collects token trees\n /// from multiple token streams into a single stream.\n-impl iter::FromIterator<TokenStream> for TokenStream {\n+impl FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n         let iter = streams.into_iter();\n         let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);"}, {"sha": "ed49cc7596608edf9f4475270ca13cb98f04ad4b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_63/ra_server.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -12,7 +12,6 @@ use super::proc_macro::bridge::{self, server};\n \n use std::collections::HashMap;\n use std::hash::Hash;\n-use std::iter::FromIterator;\n use std::ops::Bound;\n use std::{ascii, vec::IntoIter};\n "}, {"sha": "9d56f0eaf888f74403e1051c3c026ab357bbff2d", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/mod.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fmod.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,105 +0,0 @@\n-//! Proc macro ABI.\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod proc_macro;\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod ra_server;\n-\n-use libloading::Library;\n-use proc_macro_api::ProcMacroKind;\n-\n-use super::PanicMessage;\n-\n-pub use ra_server::TokenStream;\n-\n-pub(crate) struct Abi {\n-    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n-}\n-\n-impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n-    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n-        Self { message: p.as_str().map(|s| s.to_string()) }\n-    }\n-}\n-\n-impl Abi {\n-    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n-            lib.get(symbol_name.as_bytes())?;\n-        Ok(Self { exported_macros: macros.to_vec() })\n-    }\n-\n-    pub fn expand(\n-        &self,\n-        macro_name: &str,\n-        macro_body: &tt::Subtree,\n-        attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n-\n-        let parsed_attributes =\n-            attributes.map_or(TokenStream::new(), |attr| TokenStream::with_subtree(attr.clone()));\n-\n-        for proc_macro in &self.exported_macros {\n-            match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive {\n-                    trait_name, client, ..\n-                } if *trait_name == macro_name => {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_attributes,\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                _ => continue,\n-            }\n-        }\n-\n-        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n-    }\n-\n-    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.exported_macros\n-            .iter()\n-            .map(|proc_macro| match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::FuncLike)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::Attr)\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "48030f8d82dcaa3671ec67631991774c36ed5098", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/buffer.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,156 +0,0 @@\n-//! Buffer management for same-process client<->server communication.\n-\n-use std::io::{self, Write};\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-use std::slice;\n-\n-#[repr(C)]\n-pub struct Buffer {\n-    data: *mut u8,\n-    len: usize,\n-    capacity: usize,\n-    reserve: extern \"C\" fn(Buffer, usize) -> Buffer,\n-    drop: extern \"C\" fn(Buffer),\n-}\n-\n-unsafe impl Sync for Buffer {}\n-unsafe impl Send for Buffer {}\n-\n-impl Default for Buffer {\n-    #[inline]\n-    fn default() -> Self {\n-        Self::from(vec![])\n-    }\n-}\n-\n-impl Deref for Buffer {\n-    type Target = [u8];\n-    #[inline]\n-    fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.data as *const u8, self.len) }\n-    }\n-}\n-\n-impl DerefMut for Buffer {\n-    #[inline]\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n-    }\n-}\n-\n-impl Buffer {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        Self::default()\n-    }\n-\n-    #[inline]\n-    pub(super) fn clear(&mut self) {\n-        self.len = 0;\n-    }\n-\n-    #[inline]\n-    pub(super) fn take(&mut self) -> Self {\n-        mem::take(self)\n-    }\n-\n-    // We have the array method separate from extending from a slice. This is\n-    // because in the case of small arrays, codegen can be more efficient\n-    // (avoiding a memmove call). With extend_from_slice, LLVM at least\n-    // currently is not able to make that optimization.\n-    #[inline]\n-    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[u8; N]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn extend_from_slice(&mut self, xs: &[u8]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn push(&mut self, v: u8) {\n-        // The code here is taken from Vec::push, and we know that reserve()\n-        // will panic if we're exceeding isize::MAX bytes and so there's no need\n-        // to check for overflow.\n-        if self.len == self.capacity {\n-            let b = self.take();\n-            *self = (b.reserve)(b, 1);\n-        }\n-        unsafe {\n-            *self.data.add(self.len) = v;\n-            self.len += 1;\n-        }\n-    }\n-}\n-\n-impl Write for Buffer {\n-    #[inline]\n-    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n-        self.extend_from_slice(xs);\n-        Ok(xs.len())\n-    }\n-\n-    #[inline]\n-    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n-        self.extend_from_slice(xs);\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl Drop for Buffer {\n-    #[inline]\n-    fn drop(&mut self) {\n-        let b = self.take();\n-        (b.drop)(b);\n-    }\n-}\n-\n-impl From<Vec<u8>> for Buffer {\n-    fn from(mut v: Vec<u8>) -> Self {\n-        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n-        mem::forget(v);\n-\n-        // This utility function is nested in here because it can *only*\n-        // be safely called on `Buffer`s created by *this* `proc_macro`.\n-        fn to_vec(b: Buffer) -> Vec<u8> {\n-            unsafe {\n-                let Buffer { data, len, capacity, .. } = b;\n-                mem::forget(b);\n-                Vec::from_raw_parts(data, len, capacity)\n-            }\n-        }\n-\n-        extern \"C\" fn reserve(b: Buffer, additional: usize) -> Buffer {\n-            let mut v = to_vec(b);\n-            v.reserve(additional);\n-            Buffer::from(v)\n-        }\n-\n-        extern \"C\" fn drop(b: Buffer) {\n-            mem::drop(to_vec(b));\n-        }\n-\n-        Buffer { data, len, capacity, reserve, drop }\n-    }\n-}"}, {"sha": "22bda8ba5a7cf026346de6feab2469d3d6525e17", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/client.rs", "status": "removed", "additions": 0, "deletions": 529, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclient.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,529 +0,0 @@\n-//! Client-side types.\n-\n-use super::*;\n-\n-use std::marker::PhantomData;\n-\n-macro_rules! define_handles {\n-    (\n-        'owned: $($oty:ident,)*\n-        'interned: $($ity:ident,)*\n-    ) => {\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub struct HandleCounters {\n-            $($oty: AtomicUsize,)*\n-            $($ity: AtomicUsize,)*\n-        }\n-\n-        impl HandleCounters {\n-            // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-            extern \"C\" fn get() -> &'static Self {\n-                static COUNTERS: HandleCounters = HandleCounters {\n-                    $($oty: AtomicUsize::new(1),)*\n-                    $($ity: AtomicUsize::new(1),)*\n-                };\n-                &COUNTERS\n-            }\n-        }\n-\n-        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub(super) struct HandleStore<S: server::Types> {\n-            $($oty: handle::OwnedStore<S::$oty>,)*\n-            $($ity: handle::InternedStore<S::$ity>,)*\n-        }\n-\n-        impl<S: server::Types> HandleStore<S> {\n-            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n-                HandleStore {\n-                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n-                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n-                }\n-            }\n-        }\n-\n-        $(\n-            #[repr(C)]\n-            pub(crate) struct $oty {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            // Forward `Drop::drop` to the inherent `drop` method.\n-            impl Drop for $oty {\n-                fn drop(&mut self) {\n-                    $oty {\n-                        handle: self.handle,\n-                        _marker: PhantomData,\n-                    }.drop();\n-                }\n-            }\n-\n-            impl<S> Encode<S> for $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    let handle = self.handle;\n-                    mem::forget(self);\n-                    handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &$oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    &s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &mut $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s mut Marked<S::$oty, $oty>\n-            {\n-                fn decode(\n-                    r: &mut Reader<'_>,\n-                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n-                ) -> Self {\n-                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$oty.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $oty {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $oty {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-\n-        $(\n-            #[repr(C)]\n-            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-            pub(crate) struct $ity {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            impl<S> Encode<S> for $ity {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$ity.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $ity {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $ity {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-    }\n-}\n-define_handles! {\n-    'owned:\n-    FreeFunctions,\n-    TokenStream,\n-    Literal,\n-    SourceFile,\n-    MultiSpan,\n-    Diagnostic,\n-\n-    'interned:\n-    Ident,\n-    Span,\n-}\n-\n-// FIXME(eddyb) generate these impls by pattern-matching on the\n-// names of methods - also could use the presence of `fn drop`\n-// to distinguish between 'owned and 'interned, above.\n-// Alternatively, special \"modes\" could be listed of types in with_api\n-// instead of pattern matching on methods, here and in server decl.\n-\n-impl Clone for TokenStream {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Literal\")\n-            // format the kind without quotes, as in `kind: Float`\n-            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n-            .field(\"symbol\", &self.symbol())\n-            // format `Some(\"...\")` on one line even in {:#?} mode\n-            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl Clone for SourceFile {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Span {\n-    pub(crate) fn def_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.def_site)\n-    }\n-\n-    pub(crate) fn call_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.call_site)\n-    }\n-\n-    pub(crate) fn mixed_site() -> Span {\n-        Bridge::with(|bridge| bridge.globals.mixed_site)\n-    }\n-}\n-\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.debug())\n-    }\n-}\n-\n-macro_rules! define_client_side {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)?) => {\n-        $(impl $name {\n-            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n-                Bridge::with(|bridge| {\n-                    let mut buf = bridge.cached_buffer.take();\n-\n-                    buf.clear();\n-                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut buf, &mut ());\n-                    reverse_encode!(buf; $($arg),*);\n-\n-                    buf = bridge.dispatch.call(buf);\n-\n-                    let r = Result::<_, PanicMessage>::decode(&mut &buf[..], &mut ());\n-\n-                    bridge.cached_buffer = buf;\n-\n-                    r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n-                })\n-            })*\n-        })*\n-    }\n-}\n-with_api!(self, self, define_client_side);\n-\n-struct Bridge<'a> {\n-    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n-    /// used for making requests.\n-    cached_buffer: Buffer,\n-\n-    /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer, Buffer>,\n-\n-    /// Provided globals for this macro expansion.\n-    globals: ExpnGlobals<Span>,\n-}\n-\n-enum BridgeState<'a> {\n-    /// No server is currently connected to this client.\n-    NotConnected,\n-\n-    /// A server is connected and available for requests.\n-    Connected(Bridge<'a>),\n-\n-    /// Access to the bridge is being exclusively acquired\n-    /// (e.g., during `BridgeState::with`).\n-    InUse,\n-}\n-\n-enum BridgeStateL {}\n-\n-impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n-    type Out = BridgeState<'a>;\n-}\n-\n-thread_local! {\n-    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n-        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n-}\n-\n-impl BridgeState<'_> {\n-    /// Take exclusive control of the thread-local\n-    /// `BridgeState`, and pass it to `f`, mutably.\n-    /// The state will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    ///\n-    /// N.B., while `f` is running, the thread-local state\n-    /// is `BridgeState::InUse`.\n-    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n-        BRIDGE_STATE.with(|state| {\n-            state.replace(BridgeState::InUse, |mut state| {\n-                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n-                f(&mut *state)\n-            })\n-        })\n-    }\n-}\n-\n-impl Bridge<'_> {\n-    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n-        BridgeState::with(|state| match state {\n-            BridgeState::NotConnected => {\n-                panic!(\"procedural macro API is used outside of a procedural macro\");\n-            }\n-            BridgeState::InUse => {\n-                panic!(\"procedural macro API is used while it's already in use\");\n-            }\n-            BridgeState::Connected(bridge) => f(bridge),\n-        })\n-    }\n-}\n-\n-pub(crate) fn is_available() -> bool {\n-    BridgeState::with(|state| match state {\n-        BridgeState::Connected(_) | BridgeState::InUse => true,\n-        BridgeState::NotConnected => false,\n-    })\n-}\n-\n-/// A client-side RPC entry-point, which may be using a different `proc_macro`\n-/// from the one used by the server, but can be invoked compatibly.\n-///\n-/// Note that the (phantom) `I` (\"input\") and `O` (\"output\") type parameters\n-/// decorate the `Client<I, O>` with the RPC \"interface\" of the entry-point, but\n-/// do not themselves participate in ABI, at all, only facilitate type-checking.\n-///\n-/// E.g. `Client<TokenStream, TokenStream>` is the common proc macro interface,\n-/// used for `#[proc_macro] fn foo(input: TokenStream) -> TokenStream`,\n-/// indicating that the RPC input and output will be serialized token streams,\n-/// and forcing the use of APIs that take/return `S::TokenStream`, server-side.\n-#[repr(C)]\n-pub struct Client<I, O> {\n-    // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-\n-    pub(super) run: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-\n-    pub(super) _marker: PhantomData<fn(I) -> O>,\n-}\n-\n-impl<I, O> Copy for Client<I, O> {}\n-impl<I, O> Clone for Client<I, O> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-fn maybe_install_panic_hook(force_show_panics: bool) {\n-    // Hide the default panic output within `proc_macro` expansions.\n-    // NB. the server can't do this because it may use a different libstd.\n-    static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n-    HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-        let prev = panic::take_hook();\n-        panic::set_hook(Box::new(move |info| {\n-            let show = BridgeState::with(|state| match state {\n-                BridgeState::NotConnected => true,\n-                BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n-            });\n-            if show {\n-                prev(info)\n-            }\n-        }));\n-    });\n-}\n-\n-/// Client-side helper for handling client panics, entering the bridge,\n-/// deserializing input and serializing output.\n-// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n-fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n-    config: BridgeConfig<'_>,\n-    f: impl FnOnce(A) -> R,\n-) -> Buffer {\n-    let BridgeConfig { input: mut buf, dispatch, force_show_panics, .. } = config;\n-\n-    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        maybe_install_panic_hook(force_show_panics);\n-\n-        let reader = &mut &buf[..];\n-        let (globals, input) = <(ExpnGlobals<Span>, A)>::decode(reader, &mut ());\n-\n-        // Put the buffer we used for input back in the `Bridge` for requests.\n-        let new_state =\n-            BridgeState::Connected(Bridge { cached_buffer: buf.take(), dispatch, globals });\n-\n-        BRIDGE_STATE.with(|state| {\n-            state.set(new_state, || {\n-                let output = f(input);\n-\n-                // Take the `cached_buffer` back out, for the output value.\n-                buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-                // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-                // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-                // having handles outside the `bridge.enter(|| ...)` scope, and\n-                // to catch panics that could happen while encoding the success.\n-                //\n-                // Note that panics should be impossible beyond this point, but\n-                // this is defensively trying to avoid any accidental panicking\n-                // reaching the `extern \"C\"` (which should `abort` but might not\n-                // at the moment, so this is also potentially preventing UB).\n-                buf.clear();\n-                Ok::<_, ()>(output).encode(&mut buf, &mut ());\n-            })\n-        })\n-    }))\n-    .map_err(PanicMessage::from)\n-    .unwrap_or_else(|e| {\n-        buf.clear();\n-        Err::<(), _>(e).encode(&mut buf, &mut ());\n-    });\n-    buf\n-}\n-\n-impl Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub const fn expand1(\n-        f: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |input| f(super::super::TokenStream(input)).0)\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl Client<(super::super::TokenStream, super::super::TokenStream), super::super::TokenStream> {\n-    pub const fn expand2(\n-        f: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |(input, input2)| {\n-                    f(super::super::TokenStream(input), super::super::TokenStream(input2)).0\n-                })\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ProcMacro {\n-    CustomDerive {\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-\n-    Attr {\n-        name: &'static str,\n-        client: Client<\n-            (super::super::TokenStream, super::super::TokenStream),\n-            super::super::TokenStream,\n-        >,\n-    },\n-\n-    Bang {\n-        name: &'static str,\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-}\n-\n-impl ProcMacro {\n-    pub fn name(&self) -> &'static str {\n-        match self {\n-            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n-            ProcMacro::Attr { name, .. } => name,\n-            ProcMacro::Bang { name, .. } => name,\n-        }\n-    }\n-\n-    pub const fn custom_derive(\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n-    }\n-\n-    pub const fn attr(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        ProcMacro::Attr { name, client: Client::expand2(expand) }\n-    }\n-\n-    pub const fn bang(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::Bang { name, client: Client::expand1(expand) }\n-    }\n-}"}, {"sha": "d371ae3cea0981a01f38cb261fc39e203b495130", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/closure.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,32 +0,0 @@\n-//! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n-\n-use std::marker::PhantomData;\n-\n-#[repr(C)]\n-pub struct Closure<'a, A, R> {\n-    call: unsafe extern \"C\" fn(*mut Env, A) -> R,\n-    env: *mut Env,\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    //\n-    // The `'a` lifetime parameter represents the lifetime of `Env`.\n-    _marker: PhantomData<*mut &'a mut ()>,\n-}\n-\n-struct Env;\n-\n-impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n-    fn from(f: &'a mut F) -> Self {\n-        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: *mut Env, arg: A) -> R {\n-            (*(env as *mut _ as *mut F))(arg)\n-        }\n-        Closure { call: call::<A, R, F>, env: f as *mut _ as *mut Env, _marker: PhantomData }\n-    }\n-}\n-\n-impl<'a, A, R> Closure<'a, A, R> {\n-    pub fn call(&mut self, arg: A) -> R {\n-        unsafe { (self.call)(self.env, arg) }\n-    }\n-}"}, {"sha": "c219a9465d39f2d091133298a697049cd0712c67", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/handle.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,89 +0,0 @@\n-//! Server-side handles and storage for per-handle data.\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::{BuildHasher, Hash};\n-use std::num::NonZeroU32;\n-use std::ops::{Index, IndexMut};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub(super) type Handle = NonZeroU32;\n-\n-/// A store that associates values of type `T` with numeric handles. A value can\n-/// be looked up using its handle.\n-pub(super) struct OwnedStore<T: 'static> {\n-    counter: &'static AtomicUsize,\n-    data: BTreeMap<Handle, T>,\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        // Ensure the handle counter isn't 0, which would panic later,\n-        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n-        assert_ne!(counter.load(Ordering::SeqCst), 0);\n-\n-        OwnedStore { counter, data: BTreeMap::new() }\n-    }\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n-        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n-        assert!(self.data.insert(handle, x).is_none());\n-        handle\n-    }\n-\n-    pub(super) fn take(&mut self, h: Handle) -> T {\n-        self.data.remove(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> Index<Handle> for OwnedStore<T> {\n-    type Output = T;\n-    fn index(&self, h: Handle) -> &T {\n-        self.data.get(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> IndexMut<Handle> for OwnedStore<T> {\n-    fn index_mut(&mut self, h: Handle) -> &mut T {\n-        self.data.get_mut(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n-// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n-#[derive(Clone)]\n-struct NonRandomState;\n-\n-impl BuildHasher for NonRandomState {\n-    type Hasher = std::collections::hash_map::DefaultHasher;\n-    #[inline]\n-    fn build_hasher(&self) -> Self::Hasher {\n-        Self::Hasher::new()\n-    }\n-}\n-\n-/// Like `OwnedStore`, but avoids storing any value more than once.\n-pub(super) struct InternedStore<T: 'static> {\n-    owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle, NonRandomState>,\n-}\n-\n-impl<T: Copy + Eq + Hash> InternedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore {\n-            owned: OwnedStore::new(counter),\n-            interner: HashMap::with_hasher(NonRandomState),\n-        }\n-    }\n-\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let owned = &mut self.owned;\n-        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n-    }\n-\n-    pub(super) fn copy(&mut self, h: Handle) -> T {\n-        self.owned[h]\n-    }\n-}"}, {"sha": "ffd440793231c21cdb1968a0860c5fe5c3da2ff9", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/mod.rs", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fmod.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,493 +0,0 @@\n-//! Internal interface for communicating between a `proc_macro` client\n-//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n-//!\n-//! Serialization (with C ABI buffers) and unique integer handles are employed\n-//! to allow safely interfacing between two copies of `proc_macro` built\n-//! (from the same source) by different compilers with potentially mismatching\n-//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n-\n-#![deny(unsafe_code)]\n-\n-pub use super::{Delimiter, Level, LineColumn, Spacing};\n-use std::fmt;\n-use std::hash::Hash;\n-use std::marker;\n-use std::mem;\n-use std::ops::Bound;\n-use std::panic;\n-use std::sync::atomic::AtomicUsize;\n-use std::sync::Once;\n-use std::thread;\n-\n-/// Higher-order macro describing the server RPC API, allowing automatic\n-/// generation of type-safe Rust APIs, both client-side and server-side.\n-///\n-/// `with_api!(MySelf, my_self, my_macro)` expands to:\n-/// ```rust,ignore (pseudo-code)\n-/// my_macro! {\n-///     // ...\n-///     Literal {\n-///         // ...\n-///         fn character(ch: char) -> MySelf::Literal;\n-///         // ...\n-///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n-///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n-///     },\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// The first two arguments serve to customize the arguments names\n-/// and argument/return types, to enable several different usecases:\n-///\n-/// If `my_self` is just `self`, then each `fn` signature can be used\n-/// as-is for a method. If it's anything else (`self_` in practice),\n-/// then the signatures don't have a special `self` argument, and\n-/// can, therefore, have a different one introduced.\n-///\n-/// If `MySelf` is just `Self`, then the types are only valid inside\n-/// a trait or a trait impl, where the trait has associated types\n-/// for each of the API types. If non-associated types are desired,\n-/// a module name (`self` in practice) can be used instead of `Self`.\n-macro_rules! with_api {\n-    ($S:ident, $self:ident, $m:ident) => {\n-        $m! {\n-            FreeFunctions {\n-                fn drop($self: $S::FreeFunctions);\n-                fn track_env_var(var: &str, value: Option<&str>);\n-                fn track_path(path: &str);\n-            },\n-            TokenStream {\n-                fn drop($self: $S::TokenStream);\n-                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n-                fn is_empty($self: &$S::TokenStream) -> bool;\n-                fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n-                fn from_str(src: &str) -> $S::TokenStream;\n-                fn to_string($self: &$S::TokenStream) -> String;\n-                fn from_token_tree(\n-                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n-                ) -> $S::TokenStream;\n-                fn concat_trees(\n-                    base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n-                ) -> $S::TokenStream;\n-                fn concat_streams(\n-                    base: Option<$S::TokenStream>,\n-                    streams: Vec<$S::TokenStream>,\n-                ) -> $S::TokenStream;\n-                fn into_trees(\n-                    $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n-            },\n-            Ident {\n-                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n-                fn span($self: $S::Ident) -> $S::Span;\n-                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n-            },\n-            Literal {\n-                fn drop($self: $S::Literal);\n-                fn clone($self: &$S::Literal) -> $S::Literal;\n-                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n-                fn to_string($self: &$S::Literal) -> String;\n-                fn debug_kind($self: &$S::Literal) -> String;\n-                fn symbol($self: &$S::Literal) -> String;\n-                fn suffix($self: &$S::Literal) -> Option<String>;\n-                fn integer(n: &str) -> $S::Literal;\n-                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n-                fn float(n: &str) -> $S::Literal;\n-                fn f32(n: &str) -> $S::Literal;\n-                fn f64(n: &str) -> $S::Literal;\n-                fn string(string: &str) -> $S::Literal;\n-                fn character(ch: char) -> $S::Literal;\n-                fn byte_string(bytes: &[u8]) -> $S::Literal;\n-                fn span($self: &$S::Literal) -> $S::Span;\n-                fn set_span($self: &mut $S::Literal, span: $S::Span);\n-                fn subspan(\n-                    $self: &$S::Literal,\n-                    start: Bound<usize>,\n-                    end: Bound<usize>,\n-                ) -> Option<$S::Span>;\n-            },\n-            SourceFile {\n-                fn drop($self: $S::SourceFile);\n-                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n-                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n-                fn path($self: &$S::SourceFile) -> String;\n-                fn is_real($self: &$S::SourceFile) -> bool;\n-            },\n-            MultiSpan {\n-                fn drop($self: $S::MultiSpan);\n-                fn new() -> $S::MultiSpan;\n-                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n-            },\n-            Diagnostic {\n-                fn drop($self: $S::Diagnostic);\n-                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n-                fn sub(\n-                    $self: &mut $S::Diagnostic,\n-                    level: Level,\n-                    msg: &str,\n-                    span: $S::MultiSpan,\n-                );\n-                fn emit($self: $S::Diagnostic);\n-            },\n-            Span {\n-                fn debug($self: $S::Span) -> String;\n-                fn source_file($self: $S::Span) -> $S::SourceFile;\n-                fn parent($self: $S::Span) -> Option<$S::Span>;\n-                fn source($self: $S::Span) -> $S::Span;\n-                fn start($self: $S::Span) -> LineColumn;\n-                fn end($self: $S::Span) -> LineColumn;\n-                fn before($self: $S::Span) -> $S::Span;\n-                fn after($self: $S::Span) -> $S::Span;\n-                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n-                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n-                fn source_text($self: $S::Span) -> Option<String>;\n-                fn save_span($self: $S::Span) -> usize;\n-                fn recover_proc_macro_span(id: usize) -> $S::Span;\n-            },\n-        }\n-    };\n-}\n-\n-// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n-// to match the ordering in `reverse_decode`.\n-macro_rules! reverse_encode {\n-    ($writer:ident;) => {};\n-    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n-        reverse_encode!($writer; $($rest),*);\n-        $first.encode(&mut $writer, &mut ());\n-    }\n-}\n-\n-// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n-// to avoid borrow conflicts from borrows started by `&mut` arguments.\n-macro_rules! reverse_decode {\n-    ($reader:ident, $s:ident;) => {};\n-    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n-        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n-        let $first = <$first_ty>::decode(&mut $reader, $s);\n-    }\n-}\n-\n-#[allow(unsafe_code)]\n-mod buffer;\n-#[forbid(unsafe_code)]\n-pub mod client;\n-#[allow(unsafe_code)]\n-mod closure;\n-#[forbid(unsafe_code)]\n-mod handle;\n-#[macro_use]\n-#[forbid(unsafe_code)]\n-mod rpc;\n-#[allow(unsafe_code)]\n-mod scoped_cell;\n-#[allow(unsafe_code)]\n-mod selfless_reify;\n-#[forbid(unsafe_code)]\n-pub mod server;\n-\n-use buffer::Buffer;\n-pub use rpc::PanicMessage;\n-use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n-\n-/// Configuration for establishing an active connection between a server and a\n-/// client.  The server creates the bridge config (`run_server` in `server.rs`),\n-/// then passes it to the client through the function pointer in the `run` field\n-/// of `client::Client`. The client constructs a local `Bridge` from the config\n-/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n-#[repr(C)]\n-pub struct BridgeConfig<'a> {\n-    /// Buffer used to pass initial input to the client.\n-    input: Buffer,\n-\n-    /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer, Buffer>,\n-\n-    /// If 'true', always invoke the default panic hook\n-    force_show_panics: bool,\n-\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    _marker: marker::PhantomData<*mut ()>,\n-}\n-\n-#[forbid(unsafe_code)]\n-#[allow(non_camel_case_types)]\n-mod api_tags {\n-    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n-\n-    macro_rules! declare_tags {\n-        ($($name:ident {\n-            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-        }),* $(,)?) => {\n-            $(\n-                pub(super) enum $name {\n-                    $($method),*\n-                }\n-                rpc_encode_decode!(enum $name { $($method),* });\n-            )*\n-\n-            pub(super) enum Method {\n-                $($name($name)),*\n-            }\n-            rpc_encode_decode!(enum Method { $($name(m)),* });\n-        }\n-    }\n-    with_api!(self, self, declare_tags);\n-}\n-\n-/// Helper to wrap associated types to allow trait impl dispatch.\n-/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n-/// can overlap, but if the impls are, instead, on types like\n-/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n-trait Mark {\n-    type Unmarked;\n-    fn mark(unmarked: Self::Unmarked) -> Self;\n-}\n-\n-/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n-trait Unmark {\n-    type Unmarked;\n-    fn unmark(self) -> Self::Unmarked;\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-struct Marked<T, M> {\n-    value: T,\n-    _marker: marker::PhantomData<M>,\n-}\n-\n-impl<T, M> Mark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        Marked { value: unmarked, _marker: marker::PhantomData }\n-    }\n-}\n-impl<T, M> Unmark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a Marked<T, M> {\n-    type Unmarked = &'a T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n-    type Unmarked = &'a mut T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &mut self.value\n-    }\n-}\n-\n-impl<T: Mark> Mark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        unmarked.into_iter().map(T::mark).collect()\n-    }\n-}\n-impl<T: Unmark> Unmark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        self.into_iter().map(T::unmark).collect()\n-    }\n-}\n-\n-macro_rules! mark_noop {\n-    ($($ty:ty),* $(,)?) => {\n-        $(\n-            impl Mark for $ty {\n-                type Unmarked = Self;\n-                fn mark(unmarked: Self::Unmarked) -> Self {\n-                    unmarked\n-                }\n-            }\n-            impl Unmark for $ty {\n-                type Unmarked = Self;\n-                fn unmark(self) -> Self::Unmarked {\n-                    self\n-                }\n-            }\n-        )*\n-    }\n-}\n-mark_noop! {\n-    (),\n-    bool,\n-    char,\n-    &'_ [u8],\n-    &'_ str,\n-    String,\n-    u8,\n-    usize,\n-    Delimiter,\n-    Level,\n-    LineColumn,\n-    Spacing,\n-}\n-\n-rpc_encode_decode!(\n-    enum Delimiter {\n-        Parenthesis,\n-        Brace,\n-        Bracket,\n-        None,\n-    }\n-);\n-rpc_encode_decode!(\n-    enum Level {\n-        Error,\n-        Warning,\n-        Note,\n-        Help,\n-    }\n-);\n-rpc_encode_decode!(struct LineColumn { line, column });\n-rpc_encode_decode!(\n-    enum Spacing {\n-        Alone,\n-        Joint,\n-    }\n-);\n-\n-macro_rules! mark_compound {\n-    (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n-        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn mark(unmarked: Self::Unmarked) -> Self {\n-                $name {\n-                    $($field: Mark::mark(unmarked.$field)),*\n-                }\n-            }\n-        }\n-        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn unmark(self) -> Self::Unmarked {\n-                $name {\n-                    $($field: Unmark::unmark(self.$field)),*\n-                }\n-            }\n-        }\n-    };\n-    (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n-        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn mark(unmarked: Self::Unmarked) -> Self {\n-                match unmarked {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Mark::mark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn unmark(self) -> Self::Unmarked {\n-                match self {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Unmark::unmark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! compound_traits {\n-    ($($t:tt)*) => {\n-        rpc_encode_decode!($($t)*);\n-        mark_compound!($($t)*);\n-    };\n-}\n-\n-compound_traits!(\n-    enum Bound<T> {\n-        Included(x),\n-        Excluded(x),\n-        Unbounded,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Option<T> {\n-        Some(t),\n-        None,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Result<T, E> {\n-        Ok(t),\n-        Err(e),\n-    }\n-);\n-\n-#[derive(Copy, Clone)]\n-pub struct DelimSpan<Span> {\n-    pub open: Span,\n-    pub close: Span,\n-    pub entire: Span,\n-}\n-\n-impl<Span: Copy> DelimSpan<Span> {\n-    pub fn from_single(span: Span) -> Self {\n-        DelimSpan { open: span, close: span, entire: span }\n-    }\n-}\n-\n-compound_traits!(struct DelimSpan<Span> { open, close, entire });\n-\n-#[derive(Clone)]\n-pub struct Group<TokenStream, Span> {\n-    pub delimiter: Delimiter,\n-    pub stream: Option<TokenStream>,\n-    pub span: DelimSpan<Span>,\n-}\n-\n-compound_traits!(struct Group<TokenStream, Span> { delimiter, stream, span });\n-\n-#[derive(Clone)]\n-pub struct Punct<Span> {\n-    pub ch: u8,\n-    pub joint: bool,\n-    pub span: Span,\n-}\n-\n-compound_traits!(struct Punct<Span> { ch, joint, span });\n-\n-#[derive(Clone)]\n-pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n-    Group(Group<TokenStream, Span>),\n-    Punct(Punct<Span>),\n-    Ident(Ident),\n-    Literal(Literal),\n-}\n-\n-compound_traits!(\n-    enum TokenTree<TokenStream, Span, Ident, Literal> {\n-        Group(tt),\n-        Punct(tt),\n-        Ident(tt),\n-        Literal(tt),\n-    }\n-);\n-\n-/// Globals provided alongside the initial inputs for a macro expansion.\n-/// Provides values such as spans which are used frequently to avoid RPC.\n-#[derive(Clone)]\n-pub struct ExpnGlobals<Span> {\n-    pub def_site: Span,\n-    pub call_site: Span,\n-    pub mixed_site: Span,\n-}\n-\n-compound_traits!(\n-    struct ExpnGlobals<Span> { def_site, call_site, mixed_site }\n-);"}, {"sha": "e9d7a46c06f6d270d66e848788e9f01fbd776e54", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/rpc.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Frpc.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,304 +0,0 @@\n-//! Serialization for client-server communication.\n-\n-use std::any::Any;\n-use std::char;\n-use std::io::Write;\n-use std::num::NonZeroU32;\n-use std::str;\n-\n-pub(super) type Writer = super::buffer::Buffer;\n-\n-pub(super) trait Encode<S>: Sized {\n-    fn encode(self, w: &mut Writer, s: &mut S);\n-}\n-\n-pub(super) type Reader<'a> = &'a [u8];\n-\n-pub(super) trait Decode<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n-}\n-\n-pub(super) trait DecodeMut<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n-}\n-\n-macro_rules! rpc_encode_decode {\n-    (le $ty:ty) => {\n-        impl<S> Encode<S> for $ty {\n-            fn encode(self, w: &mut Writer, _: &mut S) {\n-                w.extend_from_array(&self.to_le_bytes());\n-            }\n-        }\n-\n-        impl<S> DecodeMut<'_, '_, S> for $ty {\n-            fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-                const N: usize = ::std::mem::size_of::<$ty>();\n-\n-                let mut bytes = [0; N];\n-                bytes.copy_from_slice(&r[..N]);\n-                *r = &r[N..];\n-\n-                Self::from_le_bytes(bytes)\n-            }\n-        }\n-    };\n-    (struct $name:ident $(<$($T:ident),+>)? { $($field:ident),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                $(self.$field.encode(w, s);)*\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                $name {\n-                    $($field: DecodeMut::decode(r, s)),*\n-                }\n-            }\n-        }\n-    };\n-    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match self {\n-                    $($name::$variant $(($field))* => {\n-                        tag::$variant.encode(w, s);\n-                        $($field.encode(w, s);)*\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match u8::decode(r, s) {\n-                    $(tag::$variant => {\n-                        $(let $field = DecodeMut::decode(r, s);)*\n-                        $name::$variant $(($field))*\n-                    })*\n-                    _ => unreachable!(),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for () {\n-    fn encode(self, _: &mut Writer, _: &mut S) {}\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for () {\n-    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n-}\n-\n-impl<S> Encode<S> for u8 {\n-    fn encode(self, w: &mut Writer, _: &mut S) {\n-        w.push(self);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for u8 {\n-    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-        let x = r[0];\n-        *r = &r[1..];\n-        x\n-    }\n-}\n-\n-rpc_encode_decode!(le u32);\n-rpc_encode_decode!(le usize);\n-\n-impl<S> Encode<S> for bool {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u8).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for bool {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match u8::decode(r, s) {\n-            0 => false,\n-            1 => true,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for char {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u32).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for char {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        char::from_u32(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for NonZeroU32 {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.get().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        Self::new(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.0.encode(w, s);\n-        self.1.encode(w, s);\n-    }\n-}\n-\n-impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n-    for (A, B)\n-{\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n-    }\n-}\n-\n-impl<S> Encode<S> for &[u8] {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        w.write_all(self).unwrap();\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a [u8] {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let xs = &r[..len];\n-        *r = &r[len..];\n-        xs\n-    }\n-}\n-\n-impl<S> Encode<S> for &str {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_bytes().encode(w, s);\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a str {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for String {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self[..].encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for String {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        <&str>::decode(r, s).to_string()\n-    }\n-}\n-\n-impl<S, T: Encode<S>> Encode<S> for Vec<T> {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        for x in self {\n-            x.encode(w, s);\n-        }\n-    }\n-}\n-\n-impl<'a, S, T: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S> for Vec<T> {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let mut vec = Vec::with_capacity(len);\n-        for _ in 0..len {\n-            vec.push(T::decode(r, s));\n-        }\n-        vec\n-    }\n-}\n-\n-/// Simplified version of panic payloads, ignoring\n-/// types other than `&'static str` and `String`.\n-pub enum PanicMessage {\n-    StaticStr(&'static str),\n-    String(String),\n-    Unknown,\n-}\n-\n-impl From<Box<dyn Any + Send>> for PanicMessage {\n-    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n-        if let Some(s) = payload.downcast_ref::<&'static str>() {\n-            return PanicMessage::StaticStr(s);\n-        }\n-        if let Ok(s) = payload.downcast::<String>() {\n-            return PanicMessage::String(*s);\n-        }\n-        PanicMessage::Unknown\n-    }\n-}\n-\n-impl Into<Box<dyn Any + Send>> for PanicMessage {\n-    fn into(self) -> Box<dyn Any + Send> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Box::new(s),\n-            PanicMessage::String(s) => Box::new(s),\n-            PanicMessage::Unknown => {\n-                struct UnknownPanicMessage;\n-                Box::new(UnknownPanicMessage)\n-            }\n-        }\n-    }\n-}\n-\n-impl PanicMessage {\n-    pub fn as_str(&self) -> Option<&str> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Some(s),\n-            PanicMessage::String(s) => Some(s),\n-            PanicMessage::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for PanicMessage {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_str().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match Option::<String>::decode(r, s) {\n-            Some(s) => PanicMessage::String(s),\n-            None => PanicMessage::Unknown,\n-        }\n-    }\n-}"}, {"sha": "2cde1f65adf9c484ab0aee45fe6c978fda30cbb9", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/scoped_cell.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,81 +0,0 @@\n-//! `Cell` variant for (scoped) existential lifetimes.\n-\n-use std::cell::Cell;\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-\n-/// Type lambda application, with a lifetime.\n-#[allow(unused_lifetimes)]\n-pub trait ApplyL<'a> {\n-    type Out;\n-}\n-\n-/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n-pub trait LambdaL: for<'a> ApplyL<'a> {}\n-\n-impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n-\n-// HACK(eddyb) work around projection limitations with a newtype\n-// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n-pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n-\n-impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n-    type Target = <T as ApplyL<'b>>::Out;\n-    fn deref(&self) -> &Self::Target {\n-        self.0\n-    }\n-}\n-\n-impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.0\n-    }\n-}\n-\n-pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n-\n-impl<T: LambdaL> ScopedCell<T> {\n-    pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n-        ScopedCell(Cell::new(value))\n-    }\n-\n-    /// Sets the value in `self` to `replacement` while\n-    /// running `f`, which gets the old value, mutably.\n-    /// The old value will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    pub fn replace<'a, R>(\n-        &self,\n-        replacement: <T as ApplyL<'a>>::Out,\n-        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n-    ) -> R {\n-        /// Wrapper that ensures that the cell always gets filled\n-        /// (with the original state, optionally changed by `f`),\n-        /// even if `f` had panicked.\n-        struct PutBackOnDrop<'a, T: LambdaL> {\n-            cell: &'a ScopedCell<T>,\n-            value: Option<<T as ApplyL<'static>>::Out>,\n-        }\n-\n-        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n-            fn drop(&mut self) {\n-                self.cell.0.set(self.value.take().unwrap());\n-            }\n-        }\n-\n-        let mut put_back_on_drop = PutBackOnDrop {\n-            cell: self,\n-            value: Some(self.0.replace(unsafe {\n-                let erased = mem::transmute_copy(&replacement);\n-                mem::forget(replacement);\n-                erased\n-            })),\n-        };\n-\n-        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n-    }\n-\n-    /// Sets the value in `self` to `value` while running `f`.\n-    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n-        self.replace(value, |_| f())\n-    }\n-}"}, {"sha": "907ad256e4b432683671ffdb7158b71e2f774b7b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/selfless_reify.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fselfless_reify.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,84 +0,0 @@\n-//! Abstraction for creating `fn` pointers from any callable that *effectively*\n-//! has the equivalent of implementing `Default`, even if the compiler neither\n-//! provides `Default` nor allows reifying closures (i.e. creating `fn` pointers)\n-//! other than those with absolutely no captures.\n-//!\n-//! More specifically, for a closure-like type to be \"effectively `Default`\":\n-//! * it must be a ZST (zero-sized type): no information contained within, so\n-//!   that `Default`'s return value (if it were implemented) is unambiguous\n-//! * it must be `Copy`: no captured \"unique ZST tokens\" or any other similar\n-//!   types that would make duplicating values at will unsound\n-//!   * combined with the ZST requirement, this confers a kind of \"telecopy\"\n-//!     ability: similar to `Copy`, but without keeping the value around, and\n-//!     instead \"reconstructing\" it (a noop given it's a ZST) when needed\n-//! * it must be *provably* inhabited: no captured uninhabited types or any\n-//!   other types that cannot be constructed by the user of this abstraction\n-//!   * the proof is a value of the closure-like type itself, in a sense the\n-//!     \"seed\" for the \"telecopy\" process made possible by ZST + `Copy`\n-//!   * this requirement is the only reason an abstraction limited to a specific\n-//!     usecase is required: ZST + `Copy` can be checked with *at worst* a panic\n-//!     at the \"attempted `::default()` call\" time, but that doesn't guarantee\n-//!     that the value can be soundly created, and attempting to use the typical\n-//!     \"proof ZST token\" approach leads yet again to having a ZST + `Copy` type\n-//!     that is not proof of anything without a value (i.e. isomorphic to a\n-//!     newtype of the type it's trying to prove the inhabitation of)\n-//!\n-//! A more flexible (and safer) solution to the general problem could exist once\n-//! `const`-generic parameters can have type parameters in their types:\n-//!\n-//! ```rust,ignore (needs future const-generics)\n-//! extern \"C\" fn ffi_wrapper<\n-//!     A, R,\n-//!     F: Fn(A) -> R,\n-//!     const f: F, // <-- this `const`-generic is not yet allowed\n-//! >(arg: A) -> R {\n-//!     f(arg)\n-//! }\n-//! ```\n-\n-use std::mem;\n-\n-// FIXME(eddyb) this could be `trait` impls except for the `const fn` requirement.\n-macro_rules! define_reify_functions {\n-    ($(\n-        fn $name:ident $(<$($param:ident),*>)?\n-            for $(extern $abi:tt)? fn($($arg:ident: $arg_ty:ty),*) -> $ret_ty:ty;\n-    )+) => {\n-        $(pub const fn $name<\n-            $($($param,)*)?\n-            F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-        >(f: F) -> $(extern $abi)? fn($($arg_ty),*) -> $ret_ty {\n-            // FIXME(eddyb) describe the `F` type (e.g. via `type_name::<F>`) once panic\n-            // formatting becomes possible in `const fn`.\n-            assert!(mem::size_of::<F>() == 0, \"selfless_reify: closure must be zero-sized\");\n-\n-            $(extern $abi)? fn wrapper<\n-                $($($param,)*)?\n-                F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-            >($($arg: $arg_ty),*) -> $ret_ty {\n-                let f = unsafe {\n-                    // SAFETY: `F` satisfies all criteria for \"out of thin air\"\n-                    // reconstructability (see module-level doc comment).\n-                    mem::MaybeUninit::<F>::uninit().assume_init()\n-                };\n-                f($($arg),*)\n-            }\n-            let _f_proof = f;\n-            wrapper::<\n-                $($($param,)*)?\n-                F\n-            >\n-        })+\n-    }\n-}\n-\n-define_reify_functions! {\n-    fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n-\n-    // HACK(eddyb) this abstraction is used with `for<'a> fn(BridgeConfig<'a>)\n-    // -> T` but that doesn't work with just `reify_to_extern_c_fn_unary`\n-    // because of the `fn` pointer type being \"higher-ranked\" (i.e. the\n-    // `for<'a>` binder).\n-    // FIXME(eddyb) try to remove the lifetime from `BridgeConfig`, that'd help.\n-    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::BridgeConfig<'_>) -> R;\n-}"}, {"sha": "6e7a8d8c10df1a7d0111db0be50fb500b741df2d", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/bridge/server.rs", "status": "removed", "additions": 0, "deletions": 339, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fbridge%2Fserver.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,339 +0,0 @@\n-//! Server-side traits.\n-\n-use super::*;\n-\n-// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-use super::client::HandleStore;\n-\n-pub trait Types {\n-    type FreeFunctions: 'static;\n-    type TokenStream: 'static + Clone;\n-    type Ident: 'static + Copy + Eq + Hash;\n-    type Literal: 'static + Clone;\n-    type SourceFile: 'static + Clone;\n-    type MultiSpan: 'static;\n-    type Diagnostic: 'static;\n-    type Span: 'static + Copy + Eq + Hash;\n-}\n-\n-/// Declare an associated fn of one of the traits below, adding necessary\n-/// default bodies.\n-macro_rules! associated_fn {\n-    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n-        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n-\n-    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n-        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n-\n-    ($($item:tt)*) => ($($item)*;)\n-}\n-\n-macro_rules! declare_server_traits {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        $(pub trait $name: Types {\n-            $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n-        })*\n-\n-        pub trait Server: Types $(+ $name)* {\n-            fn globals(&mut self) -> ExpnGlobals<Self::Span>;\n-        }\n-    }\n-}\n-with_api!(Self, self_, declare_server_traits);\n-\n-pub(super) struct MarkedTypes<S: Types>(S);\n-\n-impl<S: Server> Server for MarkedTypes<S> {\n-    fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n-        <_>::mark(Server::globals(&mut self.0))\n-    }\n-}\n-\n-macro_rules! define_mark_types_impls {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        impl<S: Types> Types for MarkedTypes<S> {\n-            $(type $name = Marked<S::$name, client::$name>;)*\n-        }\n-\n-        $(impl<S: $name> $name for MarkedTypes<S> {\n-            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n-                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n-            })*\n-        })*\n-    }\n-}\n-with_api!(Self, self_, define_mark_types_impls);\n-\n-struct Dispatcher<S: Types> {\n-    handle_store: HandleStore<S>,\n-    server: S,\n-}\n-\n-macro_rules! define_dispatcher_impl {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n-        pub trait DispatcherTrait {\n-            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n-            $(type $name;)*\n-            fn dispatch(&mut self, buf: Buffer) -> Buffer;\n-        }\n-\n-        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n-            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n-            fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n-                let Dispatcher { handle_store, server } = self;\n-\n-                let mut reader = &buf[..];\n-                match api_tags::Method::decode(&mut reader, &mut ()) {\n-                    $(api_tags::Method::$name(m) => match m {\n-                        $(api_tags::$name::$method => {\n-                            let mut call_method = || {\n-                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n-                                $name::$method(server, $($arg),*)\n-                            };\n-                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n-                            // If client and server happen to use the same `libstd`,\n-                            // `catch_unwind` asserts that the panic counter was 0,\n-                            // even when the closure passed to it didn't panic.\n-                            let r = if thread::panicking() {\n-                                Ok(call_method())\n-                            } else {\n-                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n-                                    .map_err(PanicMessage::from)\n-                            };\n-\n-                            buf.clear();\n-                            r.encode(&mut buf, handle_store);\n-                        })*\n-                    }),*\n-                }\n-                buf\n-            }\n-        }\n-    }\n-}\n-with_api!(Self, self_, define_dispatcher_impl);\n-\n-pub trait ExecutionStrategy {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer;\n-}\n-\n-pub struct SameThread;\n-\n-impl ExecutionStrategy for SameThread {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        let mut dispatch = |buf| dispatcher.dispatch(buf);\n-\n-        run_client(BridgeConfig {\n-            input,\n-            dispatch: (&mut dispatch).into(),\n-            force_show_panics,\n-            _marker: marker::PhantomData,\n-        })\n-    }\n-}\n-\n-// NOTE(eddyb) Two implementations are provided, the second one is a bit\n-// faster but neither is anywhere near as fast as same-thread execution.\n-\n-pub struct CrossThread1;\n-\n-impl ExecutionStrategy for CrossThread1 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::mpsc::channel;\n-\n-        let (req_tx, req_rx) = channel();\n-        let (res_tx, res_rx) = channel();\n-\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |buf| {\n-                req_tx.send(buf).unwrap();\n-                res_rx.recv().unwrap()\n-            };\n-\n-            run_client(BridgeConfig {\n-                input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            })\n-        });\n-\n-        for b in req_rx {\n-            res_tx.send(dispatcher.dispatch(b)).unwrap();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-pub struct CrossThread2;\n-\n-impl ExecutionStrategy for CrossThread2 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::{Arc, Mutex};\n-\n-        enum State<T> {\n-            Req(T),\n-            Res(T),\n-        }\n-\n-        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n-\n-        let server_thread = thread::current();\n-        let state2 = state.clone();\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                *state2.lock().unwrap() = State::Req(b);\n-                server_thread.unpark();\n-                loop {\n-                    thread::park();\n-                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n-                        break b.take();\n-                    }\n-                }\n-            };\n-\n-            let r = run_client(BridgeConfig {\n-                input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            });\n-\n-            // Wake up the server so it can exit the dispatch loop.\n-            drop(state2);\n-            server_thread.unpark();\n-\n-            r\n-        });\n-\n-        // Check whether `state2` was dropped, to know when to stop.\n-        while Arc::get_mut(&mut state).is_none() {\n-            thread::park();\n-            let mut b = match &mut *state.lock().unwrap() {\n-                State::Req(b) => b.take(),\n-                _ => continue,\n-            };\n-            b = dispatcher.dispatch(b.take());\n-            *state.lock().unwrap() = State::Res(b);\n-            join_handle.thread().unpark();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-fn run_server<\n-    S: Server,\n-    I: Encode<HandleStore<MarkedTypes<S>>>,\n-    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n->(\n-    strategy: &impl ExecutionStrategy,\n-    handle_counters: &'static client::HandleCounters,\n-    server: S,\n-    input: I,\n-    run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-    force_show_panics: bool,\n-) -> Result<O, PanicMessage> {\n-    let mut dispatcher =\n-        Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n-\n-    let globals = dispatcher.server.globals();\n-\n-    let mut buf = Buffer::new();\n-    (globals, input).encode(&mut buf, &mut dispatcher.handle_store);\n-\n-    buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n-\n-    Result::decode(&mut &buf[..], &mut dispatcher.handle_store)\n-}\n-\n-impl client::Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}\n-\n-impl\n-    client::Client<\n-        (super::super::TokenStream, super::super::TokenStream),\n-        super::super::TokenStream,\n-    >\n-{\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        input2: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            (\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n-            ),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}"}, {"sha": "3fade2dc4f9ccdd4dbac7ef201b49ba8992d09a8", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/diagnostic.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fdiagnostic.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,166 +0,0 @@\n-//! lib-proc-macro diagnostic\n-//!\n-//! Copy from <https://github.com/rust-lang/rust/blob/e45d9973b2665897a768312e971b82cc62633103/src/libproc_macro/diagnostic.rs>\n-//! augmented with removing unstable features\n-\n-use super::Span;\n-\n-/// An enum representing a diagnostic level.\n-#[derive(Copy, Clone, Debug)]\n-#[non_exhaustive]\n-pub enum Level {\n-    /// An error.\n-    Error,\n-    /// A warning.\n-    Warning,\n-    /// A note.\n-    Note,\n-    /// A help message.\n-    Help,\n-}\n-\n-/// Trait implemented by types that can be converted into a set of `Span`s.\n-pub trait MultiSpan {\n-    /// Converts `self` into a `Vec<Span>`.\n-    fn into_spans(self) -> Vec<Span>;\n-}\n-\n-impl MultiSpan for Span {\n-    fn into_spans(self) -> Vec<Span> {\n-        vec![self]\n-    }\n-}\n-\n-impl MultiSpan for Vec<Span> {\n-    fn into_spans(self) -> Vec<Span> {\n-        self\n-    }\n-}\n-\n-impl<'a> MultiSpan for &'a [Span] {\n-    fn into_spans(self) -> Vec<Span> {\n-        self.to_vec()\n-    }\n-}\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-macro_rules! diagnostic_child_methods {\n-    ($spanned:ident, $regular:ident, $level:expr) => {\n-        #[doc = concat!(\"Adds a new child diagnostics message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `spans` and `message`.\")]\n-        pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n-        where\n-            S: MultiSpan,\n-            T: Into<String>,\n-        {\n-            self.children.push(Diagnostic::spanned(spans, $level, message));\n-            self\n-        }\n-\n-        #[doc = concat!(\"Adds a new child diagnostic message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `message`.\")]\n-        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n-            self.children.push(Diagnostic::new($level, message));\n-            self\n-        }\n-    };\n-}\n-\n-/// Iterator over the children diagnostics of a `Diagnostic`.\n-#[derive(Debug, Clone)]\n-pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n-\n-impl<'a> Iterator for Children<'a> {\n-    type Item = &'a Diagnostic;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.0.next()\n-    }\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-\n-    /// Creates a new diagnostic with the given `level` and `message` pointing to\n-    /// the given set of `spans`.\n-    pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n-    where\n-        S: MultiSpan,\n-        T: Into<String>,\n-    {\n-        Diagnostic { level, message: message.into(), spans: spans.into_spans(), children: vec![] }\n-    }\n-\n-    diagnostic_child_methods!(span_error, error, Level::Error);\n-    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n-    diagnostic_child_methods!(span_note, note, Level::Note);\n-    diagnostic_child_methods!(span_help, help, Level::Help);\n-\n-    /// Returns the diagnostic `level` for `self`.\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Sets the level in `self` to `level`.\n-    pub fn set_level(&mut self, level: Level) {\n-        self.level = level;\n-    }\n-\n-    /// Returns the message in `self`.\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    /// Sets the message in `self` to `message`.\n-    pub fn set_message<T: Into<String>>(&mut self, message: T) {\n-        self.message = message.into();\n-    }\n-\n-    /// Returns the `Span`s in `self`.\n-    pub fn spans(&self) -> &[Span] {\n-        &self.spans\n-    }\n-\n-    /// Sets the `Span`s in `self` to `spans`.\n-    pub fn set_spans<S: MultiSpan>(&mut self, spans: S) {\n-        self.spans = spans.into_spans();\n-    }\n-\n-    /// Returns an iterator over the children diagnostics of `self`.\n-    pub fn children(&self) -> Children<'_> {\n-        Children(self.children.iter())\n-    }\n-\n-    /// Emit the diagnostic.\n-    pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> super::bridge::client::MultiSpan {\n-            let mut multi_span = super::bridge::client::MultiSpan::new();\n-            for span in spans {\n-                multi_span.push(span.0);\n-            }\n-            multi_span\n-        }\n-\n-        let mut diag = super::bridge::client::Diagnostic::new(\n-            self.level,\n-            &self.message[..],\n-            to_internal(self.spans),\n-        );\n-        for c in self.children {\n-            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n-        }\n-        diag.emit();\n-    }\n-}"}, {"sha": "be62c73ef32b9d40bfb0b2017795964917fe5de6", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/mod.rs", "status": "removed", "additions": 0, "deletions": 1125, "changes": 1125, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fmod.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,1125 +0,0 @@\n-//! A support library for macro authors when defining new macros.\n-//!\n-//! This library, provided by the standard distribution, provides the types\n-//! consumed in the interfaces of procedurally defined macro definitions such as\n-//! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n-//! custom derive attributes`#[proc_macro_derive]`.\n-//!\n-//! See [the book] for more.\n-//!\n-//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n-\n-#[doc(hidden)]\n-pub mod bridge;\n-\n-mod diagnostic;\n-\n-pub use diagnostic::{Diagnostic, Level, MultiSpan};\n-\n-use std::cmp::Ordering;\n-use std::ops::RangeBounds;\n-use std::path::PathBuf;\n-use std::str::FromStr;\n-use std::{error, fmt, iter, mem};\n-\n-/// Determines whether proc_macro has been made accessible to the currently\n-/// running program.\n-///\n-/// The proc_macro crate is only intended for use inside the implementation of\n-/// procedural macros. All the functions in this crate panic if invoked from\n-/// outside of a procedural macro, such as from a build script or unit test or\n-/// ordinary Rust binary.\n-///\n-/// With consideration for Rust libraries that are designed to support both\n-/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n-/// non-panicking way to detect whether the infrastructure required to use the\n-/// API of proc_macro is presently available. Returns true if invoked from\n-/// inside of a procedural macro, false if invoked from any other binary.\n-pub fn is_available() -> bool {\n-    bridge::client::is_available()\n-}\n-\n-/// The main type provided by this crate, representing an abstract stream of\n-/// tokens, or, more specifically, a sequence of token trees.\n-/// The type provide interfaces for iterating over those token trees and, conversely,\n-/// collecting a number of token trees into one stream.\n-///\n-/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n-/// and `#[proc_macro_derive]` definitions.\n-#[derive(Clone)]\n-pub struct TokenStream(Option<bridge::client::TokenStream>);\n-\n-/// Error returned from `TokenStream::from_str`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct LexError;\n-\n-impl fmt::Display for LexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"cannot parse string into token stream\")\n-    }\n-}\n-\n-impl error::Error for LexError {}\n-\n-/// Error returned from `TokenStream::expand_expr`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct ExpandError;\n-\n-impl fmt::Display for ExpandError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"macro expansion failed\")\n-    }\n-}\n-\n-impl error::Error for ExpandError {}\n-\n-impl TokenStream {\n-    /// Returns an empty `TokenStream` containing no token trees.\n-    pub fn new() -> TokenStream {\n-        TokenStream(None)\n-    }\n-\n-    /// Checks if this `TokenStream` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.as_ref().map(|h| h.is_empty()).unwrap_or(true)\n-    }\n-\n-    /// Parses this `TokenStream` as an expression and attempts to expand any\n-    /// macros within it. Returns the expanded `TokenStream`.\n-    ///\n-    /// Currently only expressions expanding to literals will succeed, although\n-    /// this may be relaxed in the future.\n-    ///\n-    /// NOTE: In error conditions, `expand_expr` may leave macros unexpanded,\n-    /// report an error, failing compilation, and/or return an `Err(..)`. The\n-    /// specific behavior for any error condition, and what conditions are\n-    /// considered errors, is unspecified and may change in the future.\n-    pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n-        let stream = self.0.as_ref().ok_or(ExpandError)?;\n-        match bridge::client::TokenStream::expand_expr(stream) {\n-            Ok(stream) => Ok(TokenStream(Some(stream))),\n-            Err(_) => Err(ExpandError),\n-        }\n-    }\n-}\n-\n-/// Attempts to break the string into tokens and parse those tokens into a token stream.\n-/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-/// or characters not existing in the language.\n-/// All tokens in the parsed stream get `Span::call_site()` spans.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-/// change these errors into `LexError`s later.\n-impl FromStr for TokenStream {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        Ok(TokenStream(Some(bridge::client::TokenStream::from_str(src))))\n-    }\n-}\n-\n-/// Prints the token stream as a string that is supposed to be losslessly convertible back\n-/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-/// Prints token in a form convenient for debugging.\n-impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"TokenStream \")?;\n-        f.debug_list().entries(self.clone()).finish()\n-    }\n-}\n-\n-impl Default for TokenStream {\n-    fn default() -> Self {\n-        TokenStream::new()\n-    }\n-}\n-\n-pub use quote::{quote, quote_span};\n-\n-fn tree_to_bridge_tree(\n-    tree: TokenTree,\n-) -> bridge::TokenTree<\n-    bridge::client::TokenStream,\n-    bridge::client::Span,\n-    bridge::client::Ident,\n-    bridge::client::Literal,\n-> {\n-    match tree {\n-        TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n-        TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n-        TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n-        TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(Some(bridge::client::TokenStream::from_token_tree(tree_to_bridge_tree(tree))))\n-    }\n-}\n-\n-/// Non-generic helper for implementing `FromIterator<TokenStream>` and\n-/// `Extend<TokenStream>` with less monomorphization in calling crates.\n-struct ConcatStreamsHelper {\n-    streams: Vec<bridge::client::TokenStream>,\n-}\n-\n-impl ConcatStreamsHelper {\n-    fn new(capacity: usize) -> Self {\n-        ConcatStreamsHelper { streams: Vec::with_capacity(capacity) }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        if let Some(stream) = stream.0 {\n-            self.streams.push(stream);\n-        }\n-    }\n-\n-    fn build(mut self) -> TokenStream {\n-        if self.streams.len() <= 1 {\n-            TokenStream(self.streams.pop())\n-        } else {\n-            TokenStream(Some(bridge::client::TokenStream::concat_streams(None, self.streams)))\n-        }\n-    }\n-\n-    fn append_to(mut self, stream: &mut TokenStream) {\n-        if self.streams.is_empty() {\n-            return;\n-        }\n-        let base = stream.0.take();\n-        if base.is_none() && self.streams.len() == 1 {\n-            stream.0 = self.streams.pop();\n-        } else {\n-            stream.0 = Some(bridge::client::TokenStream::concat_streams(base, self.streams));\n-        }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl iter::FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl iter::FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let iter = streams.into_iter();\n-        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n-        iter.for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        // FIXME(eddyb) Use an optimized implementation if/when possible.\n-        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n-    }\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use super::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    #[derive(Clone)]\n-    pub struct IntoIter(\n-        std::vec::IntoIter<\n-            bridge::TokenTree<\n-                bridge::client::TokenStream,\n-                bridge::client::Span,\n-                bridge::client::Ident,\n-                bridge::client::Literal,\n-            >,\n-        >,\n-    );\n-\n-    impl Iterator for IntoIter {\n-        type Item = TokenTree;\n-\n-        fn next(&mut self) -> Option<TokenTree> {\n-            self.0.next().map(|tree| match tree {\n-                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n-                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n-                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n-                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n-            })\n-        }\n-    }\n-\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = IntoIter;\n-\n-        fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.map(|v| v.into_trees()).unwrap_or_default().into_iter())\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-mod quote;\n-\n-/// A region of source code, along with macro expansion information.\n-#[derive(Copy, Clone)]\n-pub struct Span(bridge::client::Span);\n-\n-macro_rules! diagnostic_method {\n-    ($name:ident, $level:expr) => {\n-        /// Creates a new `Diagnostic` with the given `message` at the span\n-        /// `self`.\n-        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n-            Diagnostic::spanned(self, $level, message)\n-        }\n-    };\n-}\n-\n-impl Span {\n-    /// A span that resolves at the macro definition site.\n-    pub fn def_site() -> Span {\n-        Span(bridge::client::Span::def_site())\n-    }\n-\n-    /// The span of the invocation of the current procedural macro.\n-    /// Identifiers created with this span will be resolved as if they were written\n-    /// directly at the macro call location (call-site hygiene) and other code\n-    /// at the macro call site will be able to refer to them as well.\n-    pub fn call_site() -> Span {\n-        Span(bridge::client::Span::call_site())\n-    }\n-\n-    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n-    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n-    /// call site (everything else).\n-    /// The span location is taken from the call-site.\n-    pub fn mixed_site() -> Span {\n-        Span(bridge::client::Span::mixed_site())\n-    }\n-\n-    /// The original source file into which this span points.\n-    pub fn source_file(&self) -> SourceFile {\n-        SourceFile(self.0.source_file())\n-    }\n-\n-    /// The `Span` for the tokens in the previous macro expansion from which\n-    /// `self` was generated from, if any.\n-    pub fn parent(&self) -> Option<Span> {\n-        self.0.parent().map(Span)\n-    }\n-\n-    /// The span for the origin source code that `self` was generated from. If\n-    /// this `Span` wasn't generated from other macro expansions then the return\n-    /// value is the same as `*self`.\n-    pub fn source(&self) -> Span {\n-        Span(self.0.source())\n-    }\n-\n-    /// Gets the starting line/column in the source file for this span.\n-    pub fn start(&self) -> LineColumn {\n-        self.0.start().add_1_to_column()\n-    }\n-\n-    /// Gets the ending line/column in the source file for this span.\n-    pub fn end(&self) -> LineColumn {\n-        self.0.end().add_1_to_column()\n-    }\n-\n-    /// Creates an empty span pointing to directly before this span.\n-    pub fn before(&self) -> Span {\n-        Span(self.0.before())\n-    }\n-\n-    /// Creates an empty span pointing to directly after this span.\n-    pub fn after(&self) -> Span {\n-        Span(self.0.after())\n-    }\n-\n-    /// Creates a new span encompassing `self` and `other`.\n-    ///\n-    /// Returns `None` if `self` and `other` are from different files.\n-    pub fn join(&self, other: Span) -> Option<Span> {\n-        self.0.join(other.0).map(Span)\n-    }\n-\n-    /// Creates a new span with the same line/column information as `self` but\n-    /// that resolves symbols as though it were at `other`.\n-    pub fn resolved_at(&self, other: Span) -> Span {\n-        Span(self.0.resolved_at(other.0))\n-    }\n-\n-    /// Creates a new span with the same name resolution behavior as `self` but\n-    /// with the line/column information of `other`.\n-    pub fn located_at(&self, other: Span) -> Span {\n-        other.resolved_at(*self)\n-    }\n-\n-    /// Compares to spans to see if they're equal.\n-    pub fn eq(&self, other: &Span) -> bool {\n-        self.0 == other.0\n-    }\n-\n-    /// Returns the source text behind a span. This preserves the original source\n-    /// code, including spaces and comments. It only returns a result if the span\n-    /// corresponds to real source code.\n-    ///\n-    /// Note: The observable result of a macro should only rely on the tokens and\n-    /// not on this source text. The result of this function is a best effort to\n-    /// be used for diagnostics only.\n-    pub fn source_text(&self) -> Option<String> {\n-        self.0.source_text()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn save_span(&self) -> usize {\n-        self.0.save_span()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn recover_proc_macro_span(id: usize) -> Span {\n-        Span(bridge::client::Span::recover_proc_macro_span(id))\n-    }\n-\n-    diagnostic_method!(error, Level::Error);\n-    diagnostic_method!(warning, Level::Warning);\n-    diagnostic_method!(note, Level::Note);\n-    diagnostic_method!(help, Level::Help);\n-}\n-\n-/// Prints a span in a form convenient for debugging.\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// A line-column pair representing the start or end of a `Span`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct LineColumn {\n-    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n-    pub line: usize,\n-    /// The 1-indexed column (number of bytes in UTF-8 encoding) in the source\n-    /// file on which the span starts or ends (inclusive).\n-    pub column: usize,\n-}\n-\n-impl LineColumn {\n-    fn add_1_to_column(self) -> Self {\n-        LineColumn { line: self.line, column: self.column + 1 }\n-    }\n-}\n-\n-impl Ord for LineColumn {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.line.cmp(&other.line).then(self.column.cmp(&other.column))\n-    }\n-}\n-\n-impl PartialOrd for LineColumn {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-/// The source file of a given `Span`.\n-#[derive(Clone)]\n-pub struct SourceFile(bridge::client::SourceFile);\n-\n-impl SourceFile {\n-    /// Gets the path to this source file.\n-    ///\n-    /// ### Note\n-    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n-    /// macro, this might not be an actual path on the filesystem. Use [`is_real`] to check.\n-    ///\n-    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n-    /// the command line, the path as given might not actually be valid.\n-    ///\n-    /// [`is_real`]: Self::is_real\n-    pub fn path(&self) -> PathBuf {\n-        PathBuf::from(self.0.path())\n-    }\n-\n-    /// Returns `true` if this source file is a real source file, and not generated by an external\n-    /// macro's expansion.\n-    pub fn is_real(&self) -> bool {\n-        // This is a hack until intercrate spans are implemented and we can have real source files\n-        // for spans generated in external macros.\n-        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n-        self.0.is_real()\n-    }\n-}\n-\n-impl fmt::Debug for SourceFile {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SourceFile\")\n-            .field(\"path\", &self.path())\n-            .field(\"is_real\", &self.is_real())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq for SourceFile {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.eq(&other.0)\n-    }\n-}\n-\n-impl Eq for SourceFile {}\n-\n-/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n-#[derive(Clone)]\n-pub enum TokenTree {\n-    /// A token stream surrounded by bracket delimiters.\n-    Group(Group),\n-    /// An identifier.\n-    Ident(Ident),\n-    /// A single punctuation character (`+`, `,`, `$`, etc.).\n-    Punct(Punct),\n-    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n-    Literal(Literal),\n-}\n-\n-impl TokenTree {\n-    /// Returns the span of this tree, delegating to the `span` method of\n-    /// the contained token or a delimited stream.\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TokenTree::Group(ref t) => t.span(),\n-            TokenTree::Ident(ref t) => t.span(),\n-            TokenTree::Punct(ref t) => t.span(),\n-            TokenTree::Literal(ref t) => t.span(),\n-        }\n-    }\n-\n-    /// Configures the span for *only this token*.\n-    ///\n-    /// Note that if this token is a `Group` then this method will not configure\n-    /// the span of each of the internal tokens, this will simply delegate to\n-    /// the `set_span` method of each variant.\n-    pub fn set_span(&mut self, span: Span) {\n-        match *self {\n-            TokenTree::Group(ref mut t) => t.set_span(span),\n-            TokenTree::Ident(ref mut t) => t.set_span(span),\n-            TokenTree::Punct(ref mut t) => t.set_span(span),\n-            TokenTree::Literal(ref mut t) => t.set_span(span),\n-        }\n-    }\n-}\n-\n-/// Prints token tree in a form convenient for debugging.\n-impl fmt::Debug for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Each of these has the name in the struct type in the derived debug,\n-        // so don't bother with an extra layer of indirection\n-        match *self {\n-            TokenTree::Group(ref tt) => tt.fmt(f),\n-            TokenTree::Ident(ref tt) => tt.fmt(f),\n-            TokenTree::Punct(ref tt) => tt.fmt(f),\n-            TokenTree::Literal(ref tt) => tt.fmt(f),\n-        }\n-    }\n-}\n-\n-impl From<Group> for TokenTree {\n-    fn from(g: Group) -> TokenTree {\n-        TokenTree::Group(g)\n-    }\n-}\n-\n-impl From<Ident> for TokenTree {\n-    fn from(g: Ident) -> TokenTree {\n-        TokenTree::Ident(g)\n-    }\n-}\n-\n-impl From<Punct> for TokenTree {\n-    fn from(g: Punct) -> TokenTree {\n-        TokenTree::Punct(g)\n-    }\n-}\n-\n-impl From<Literal> for TokenTree {\n-    fn from(g: Literal) -> TokenTree {\n-        TokenTree::Literal(g)\n-    }\n-}\n-\n-/// Prints the token tree as a string that is supposed to be losslessly convertible back\n-/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-/// A delimited token stream.\n-///\n-/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n-#[derive(Clone)]\n-pub struct Group(bridge::Group<bridge::client::TokenStream, bridge::client::Span>);\n-\n-/// Describes how a sequence of token trees is delimited.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Delimiter {\n-    /// `( ... )`\n-    Parenthesis,\n-    /// `{ ... }`\n-    Brace,\n-    /// `[ ... ]`\n-    Bracket,\n-    /// `\u00d8 ... \u00d8`\n-    /// An invisible delimiter, that may, for example, appear around tokens coming from a\n-    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n-    /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n-    None,\n-}\n-\n-impl Group {\n-    /// Creates a new `Group` with the given delimiter and token stream.\n-    ///\n-    /// This constructor will set the span for this group to\n-    /// `Span::call_site()`. To change the span you can use the `set_span`\n-    /// method below.\n-    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group(bridge::Group {\n-            delimiter,\n-            stream: stream.0,\n-            span: bridge::DelimSpan::from_single(Span::call_site().0),\n-        })\n-    }\n-\n-    /// Returns the delimiter of this `Group`\n-    pub fn delimiter(&self) -> Delimiter {\n-        self.0.delimiter\n-    }\n-\n-    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n-    ///\n-    /// Note that the returned token stream does not include the delimiter\n-    /// returned above.\n-    pub fn stream(&self) -> TokenStream {\n-        TokenStream(self.0.stream.clone())\n-    }\n-\n-    /// Returns the span for the delimiters of this token stream, spanning the\n-    /// entire `Group`.\n-    ///\n-    /// ```text\n-    /// pub fn span(&self) -> Span {\n-    ///            ^^^^^^^\n-    /// ```\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span.entire)\n-    }\n-\n-    /// Returns the span pointing to the opening delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_open(&self) -> Span {\n-    ///                 ^\n-    /// ```\n-    pub fn span_open(&self) -> Span {\n-        Span(self.0.span.open)\n-    }\n-\n-    /// Returns the span pointing to the closing delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_close(&self) -> Span {\n-    ///                        ^\n-    /// ```\n-    pub fn span_close(&self) -> Span {\n-        Span(self.0.span.close)\n-    }\n-\n-    /// Configures the span for this `Group`'s delimiters, but not its internal\n-    /// tokens.\n-    ///\n-    /// This method will **not** set the span of all the internal tokens spanned\n-    /// by this group, but rather it will only set the span of the delimiter\n-    /// tokens at the level of the `Group`.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.span = bridge::DelimSpan::from_single(span.0);\n-    }\n-}\n-\n-/// Prints the group as a string that should be losslessly convertible back\n-/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters.\n-impl fmt::Display for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Group\")\n-            .field(\"delimiter\", &self.delimiter())\n-            .field(\"stream\", &self.stream())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A `Punct` is a single punctuation character such as `+`, `-` or `#`.\n-///\n-/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n-/// forms of `Spacing` returned.\n-#[derive(Clone)]\n-pub struct Punct(bridge::Punct<bridge::client::Span>);\n-\n-/// Describes whether a `Punct` is followed immediately by another `Punct` ([`Spacing::Joint`]) or\n-/// by a different token or whitespace ([`Spacing::Alone`]).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Spacing {\n-    /// A `Punct` is not immediately followed by another `Punct`.\n-    /// E.g. `+` is `Alone` in `+ =`, `+ident` and `+()`.\n-    Alone,\n-    /// A `Punct` is immediately followed by another `Punct`.\n-    /// E.g. `+` is `Joint` in `+=` and `++`.\n-    ///\n-    /// Additionally, single quote `'` can join with identifiers to form lifetimes: `'ident`.\n-    Joint,\n-}\n-\n-impl Punct {\n-    /// Creates a new `Punct` from the given character and spacing.\n-    /// The `ch` argument must be a valid punctuation character permitted by the language,\n-    /// otherwise the function will panic.\n-    ///\n-    /// The returned `Punct` will have the default span of `Span::call_site()`\n-    /// which can be further configured with the `set_span` method below.\n-    pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        const LEGAL_CHARS: &[char] = &[\n-            '=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^', '&', '|', '@', '.', ',', ';',\n-            ':', '#', '$', '?', '\\'',\n-        ];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch);\n-        }\n-        Punct(bridge::Punct {\n-            ch: ch as u8,\n-            joint: spacing == Spacing::Joint,\n-            span: Span::call_site().0,\n-        })\n-    }\n-\n-    /// Returns the value of this punctuation character as `char`.\n-    pub fn as_char(&self) -> char {\n-        self.0.ch as char\n-    }\n-\n-    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n-    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n-    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n-    /// (`Alone`) so the operator has certainly ended.\n-    pub fn spacing(&self) -> Spacing {\n-        if self.0.joint {\n-            Spacing::Joint\n-        } else {\n-            Spacing::Alone\n-        }\n-    }\n-\n-    /// Returns the span for this punctuation character.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span)\n-    }\n-\n-    /// Configure the span for this punctuation character.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.span = span.0;\n-    }\n-}\n-\n-/// Prints the punctuation character as a string that should be losslessly convertible\n-/// back into the same character.\n-impl fmt::Display for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Punct\")\n-            .field(\"ch\", &self.as_char())\n-            .field(\"spacing\", &self.spacing())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq<char> for Punct {\n-    fn eq(&self, rhs: &char) -> bool {\n-        self.as_char() == *rhs\n-    }\n-}\n-\n-impl PartialEq<Punct> for char {\n-    fn eq(&self, rhs: &Punct) -> bool {\n-        *self == rhs.as_char()\n-    }\n-}\n-\n-/// An identifier (`ident`).\n-#[derive(Clone)]\n-pub struct Ident(bridge::client::Ident);\n-\n-impl Ident {\n-    /// Creates a new `Ident` with the given `string` as well as the specified\n-    /// `span`.\n-    /// The `string` argument must be a valid identifier permitted by the\n-    /// language (including keywords, e.g. `self` or `fn`). Otherwise, the function will panic.\n-    ///\n-    /// Note that `span`, currently in rustc, configures the hygiene information\n-    /// for this identifier.\n-    ///\n-    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved as if they were written\n-    /// directly at the location of the macro call, and other code at the macro call site will be\n-    /// able to refer to them as well.\n-    ///\n-    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved at the location of the\n-    /// macro definition and other code at the macro call site will not be able to refer to them.\n-    ///\n-    /// Due to the current importance of hygiene this constructor, unlike other\n-    /// tokens, requires a `Span` to be specified at construction.\n-    pub fn new(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, false))\n-    }\n-\n-    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n-    /// The `string` argument be a valid identifier permitted by the language\n-    /// (including keywords, e.g. `fn`). Keywords which are usable in path segments\n-    /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n-    pub fn new_raw(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, true))\n-    }\n-\n-    /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by [`to_string`](Self::to_string).\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n-    }\n-}\n-\n-/// Prints the identifier as a string that should be losslessly convertible\n-/// back into the same identifier.\n-impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Ident\")\n-            .field(\"ident\", &self.to_string())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n-/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n-/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n-/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n-#[derive(Clone)]\n-pub struct Literal(bridge::client::Literal);\n-\n-macro_rules! suffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new suffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1u32` where the integer\n-        /// value specified is the first part of the token and the integral is\n-        /// also suffixed at the end.\n-        /// Literals created from negative numbers might not survive round-trips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n-        }\n-    )*)\n-}\n-\n-macro_rules! unsuffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new unsuffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1` where the integer\n-        /// value specified is the first part of the token. No suffix is\n-        /// specified on this token, meaning that invocations like\n-        /// `Literal::i8_unsuffixed(1)` are equivalent to\n-        /// `Literal::u32_unsuffixed(1)`.\n-        /// Literals created from negative numbers might not survive rountrips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::integer(&n.to_string()))\n-        }\n-    )*)\n-}\n-\n-impl Literal {\n-    suffixed_int_literals! {\n-        u8_suffixed => u8,\n-        u16_suffixed => u16,\n-        u32_suffixed => u32,\n-        u64_suffixed => u64,\n-        u128_suffixed => u128,\n-        usize_suffixed => usize,\n-        i8_suffixed => i8,\n-        i16_suffixed => i16,\n-        i32_suffixed => i32,\n-        i64_suffixed => i64,\n-        i128_suffixed => i128,\n-        isize_suffixed => isize,\n-    }\n-\n-    unsuffixed_int_literals! {\n-        u8_unsuffixed => u8,\n-        u16_unsuffixed => u16,\n-        u32_unsuffixed => u32,\n-        u64_unsuffixed => u64,\n-        u128_unsuffixed => u128,\n-        usize_unsuffixed => usize,\n-        i8_unsuffixed => i8,\n-        i16_unsuffixed => i16,\n-        i32_unsuffixed => i32,\n-        i64_unsuffixed => i64,\n-        i128_unsuffixed => i128,\n-        isize_unsuffixed => isize,\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_unsuffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f32` where the value\n-    /// specified is the preceding part of the token and `f32` is the suffix of\n-    /// the token. This token will always be inferred to be an `f32` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_suffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f32(&n.to_string()))\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_unsuffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f64` where the value\n-    /// specified is the preceding part of the token and `f64` is the suffix of\n-    /// the token. This token will always be inferred to be an `f64` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_suffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f64(&n.to_string()))\n-    }\n-\n-    /// String literal.\n-    pub fn string(string: &str) -> Literal {\n-        Literal(bridge::client::Literal::string(string))\n-    }\n-\n-    /// Character literal.\n-    pub fn character(ch: char) -> Literal {\n-        Literal(bridge::client::Literal::character(ch))\n-    }\n-\n-    /// Byte string literal.\n-    pub fn byte_string(bytes: &[u8]) -> Literal {\n-        Literal(bridge::client::Literal::byte_string(bytes))\n-    }\n-\n-    /// Returns the span encompassing this literal.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span associated for this literal.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n-    }\n-\n-    /// Returns a `Span` that is a subset of `self.span()` containing only the\n-    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n-    /// span is outside the bounds of `self`.\n-    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n-    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n-    // occur elsewhere when the source text is printed.\n-    // FIXME(SergioBenitez): there is no way for the user to know what\n-    // `self.span()` actually maps to, so this method can currently only be\n-    // called blindly. For example, `to_string()` for the character 'c' returns\n-    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n-    // was 'c' or whether it was '\\u{63}'.\n-    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        self.0.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n-    }\n-}\n-\n-/// Parse a single literal from its stringified representation.\n-///\n-/// In order to parse successfully, the input string must not contain anything\n-/// but the literal token. Specifically, it must not contain whitespace or\n-/// comments in addition to the literal.\n-///\n-/// The resulting literal token will have a `Span::call_site()` span.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We\n-/// reserve the right to change these errors into `LexError`s later.\n-impl FromStr for Literal {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<Self, LexError> {\n-        match bridge::client::Literal::from_str(src) {\n-            Ok(literal) => Ok(Literal(literal)),\n-            Err(()) => Err(LexError),\n-        }\n-    }\n-}\n-\n-/// Prints the literal as a string that should be losslessly convertible\n-/// back into the same literal (except for possible rounding for floating point literals).\n-impl fmt::Display for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// Tracked access to environment variables.\n-pub mod tracked_env {\n-    use std::env::{self, VarError};\n-    use std::ffi::OsStr;\n-\n-    /// Retrieve an environment variable and add it to build dependency info.\n-    /// Build system executing the compiler will know that the variable was accessed during\n-    /// compilation, and will be able to rerun the build when the value of that variable changes.\n-    /// Besides the dependency tracking this function should be equivalent to `env::var` from the\n-    /// standard library, except that the argument must be UTF-8.\n-    pub fn var<K: AsRef<OsStr> + AsRef<str>>(key: K) -> Result<String, VarError> {\n-        let key: &str = key.as_ref();\n-        let value = env::var(key);\n-        super::bridge::client::FreeFunctions::track_env_var(key, value.as_deref().ok());\n-        value\n-    }\n-}\n-\n-/// Tracked access to additional files.\n-pub mod tracked_path {\n-\n-    /// Track a file explicitly.\n-    ///\n-    /// Commonly used for tracking asset preprocessing.\n-    pub fn path<P: AsRef<str>>(path: P) {\n-        let path: &str = path.as_ref();\n-        super::bridge::client::FreeFunctions::track_path(path);\n-    }\n-}"}, {"sha": "39309faa412133f1c3638332f1a0502cdc9f6248", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/proc_macro/quote.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fproc_macro%2Fquote.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,139 +0,0 @@\n-//! # Quasiquoter\n-//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n-\n-//! This quasiquoter uses macros 2.0 hygiene to reliably access\n-//! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n-\n-use super::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n-\n-macro_rules! quote_tt {\n-    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n-    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n-    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n-    (,) => { Punct::new(',', Spacing::Alone) };\n-    (.) => { Punct::new('.', Spacing::Alone) };\n-    (;) => { Punct::new(';', Spacing::Alone) };\n-    (!) => { Punct::new('!', Spacing::Alone) };\n-    (<) => { Punct::new('<', Spacing::Alone) };\n-    (>) => { Punct::new('>', Spacing::Alone) };\n-    (&) => { Punct::new('&', Spacing::Alone) };\n-    (=) => { Punct::new('=', Spacing::Alone) };\n-    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n-}\n-\n-macro_rules! quote_ts {\n-    ((@ $($t:tt)*)) => { $($t)* };\n-    (::) => {\n-        [\n-            TokenTree::from(Punct::new(':', Spacing::Joint)),\n-            TokenTree::from(Punct::new(':', Spacing::Alone)),\n-        ].iter()\n-            .cloned()\n-            .map(|mut x| {\n-                x.set_span(Span::def_site());\n-                x\n-            })\n-            .collect::<TokenStream>()\n-    };\n-    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n-}\n-\n-/// Simpler version of the real `quote!` macro, implemented solely\n-/// through `macro_rules`, for bootstrapping the real implementation\n-/// (see the `quote` function), which does not have access to the\n-/// real `quote!` macro due to the `proc_macro` crate not being\n-/// able to depend on itself.\n-///\n-/// Note: supported tokens are a subset of the real `quote!`, but\n-/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n-macro_rules! quote {\n-    () => { TokenStream::new() };\n-    ($($t:tt)*) => {\n-        [\n-            $(TokenStream::from(quote_ts!($t)),)*\n-        ].iter().cloned().collect::<TokenStream>()\n-    };\n-}\n-\n-/// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual implementation of the `quote!()` proc macro.\n-///\n-/// It is loaded by the compiler in `register_builtin_macros`.\n-pub fn quote(stream: TokenStream) -> TokenStream {\n-    if stream.is_empty() {\n-        return quote!(super::TokenStream::new());\n-    }\n-    let proc_macro_crate = quote!(crate);\n-    let mut after_dollar = false;\n-    let tokens = stream\n-        .into_iter()\n-        .filter_map(|tree| {\n-            if after_dollar {\n-                after_dollar = false;\n-                match tree {\n-                    TokenTree::Ident(_) => {\n-                        return Some(quote!(Into::<super::TokenStream>::into(\n-                        Clone::clone(&(@ tree))),));\n-                    }\n-                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n-                    _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n-                }\n-            } else if let TokenTree::Punct(ref tt) = tree {\n-                if tt.as_char() == '$' {\n-                    after_dollar = true;\n-                    return None;\n-                }\n-            }\n-\n-            Some(quote!(super::TokenStream::from((@ match tree {\n-                TokenTree::Punct(tt) => quote!(super::TokenTree::Punct(super::Punct::new(\n-                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n-                    (@ match tt.spacing() {\n-                        Spacing::Alone => quote!(super::Spacing::Alone),\n-                        Spacing::Joint => quote!(super::Spacing::Joint),\n-                    }),\n-                ))),\n-                TokenTree::Group(tt) => quote!(super::TokenTree::Group(super::Group::new(\n-                    (@ match tt.delimiter() {\n-                        Delimiter::Parenthesis => quote!(super::Delimiter::Parenthesis),\n-                        Delimiter::Brace => quote!(super::Delimiter::Brace),\n-                        Delimiter::Bracket => quote!(super::Delimiter::Bracket),\n-                        Delimiter::None => quote!(super::Delimiter::None),\n-                    }),\n-                    (@ quote(tt.stream())),\n-                ))),\n-                TokenTree::Ident(tt) => quote!(super::TokenTree::Ident(super::Ident::new(\n-                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n-                    (@ quote_span(proc_macro_crate.clone(), tt.span())),\n-                ))),\n-                TokenTree::Literal(tt) => quote!(super::TokenTree::Literal({\n-                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n-                        .parse::<super::TokenStream>()\n-                        .unwrap()\n-                        .into_iter();\n-                    if let (Some(super::TokenTree::Literal(mut lit)), None) =\n-                        (iter.next(), iter.next())\n-                    {\n-                        lit.set_span((@ quote_span(proc_macro_crate.clone(), tt.span())));\n-                        lit\n-                    } else {\n-                        unreachable!()\n-                    }\n-                }))\n-            })),))\n-        })\n-        .collect::<TokenStream>();\n-\n-    if after_dollar {\n-        panic!(\"unexpected trailing `$` in `quote!`\");\n-    }\n-\n-    quote!([(@ tokens)].iter().cloned().collect::<super::TokenStream>())\n-}\n-\n-/// Quote a `Span` into a `TokenStream`.\n-/// This is needed to implement a custom quoter.\n-pub fn quote_span(proc_macro_crate: TokenStream, span: Span) -> TokenStream {\n-    let id = span.save_span();\n-    quote!((@ proc_macro_crate ) ::Span::recover_proc_macro_span((@ TokenTree::from(Literal::usize_unsuffixed(id)))))\n-}"}, {"sha": "7e8e67856e9fdfe23c68b39a63a28559a3b44633", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_1_64/ra_server.rs", "status": "removed", "additions": 0, "deletions": 792, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8556e6620e4866526b3cea767ad8c20ae877a569/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_64%2Fra_server.rs?ref=8556e6620e4866526b3cea767ad8c20ae877a569", "patch": "@@ -1,792 +0,0 @@\n-//! Rustc proc-macro server implementation with tt\n-//!\n-//! Based on idea from <https://github.com/fedochet/rust-proc-macro-expander>\n-//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n-//! we could provide any TokenStream implementation.\n-//! The original idea from fedochet is using proc-macro2 as backend,\n-//! we use tt instead for better integration with RA.\n-//!\n-//! FIXME: No span and source file information is implemented yet\n-\n-use super::proc_macro::bridge::{self, server};\n-\n-use std::collections::HashMap;\n-use std::hash::Hash;\n-use std::iter::FromIterator;\n-use std::ops::Bound;\n-use std::{ascii, vec::IntoIter};\n-\n-type Group = tt::Subtree;\n-type TokenTree = tt::TokenTree;\n-type Punct = tt::Punct;\n-type Spacing = tt::Spacing;\n-type Literal = tt::Literal;\n-type Span = tt::TokenId;\n-\n-#[derive(Debug, Default, Clone)]\n-pub struct TokenStream {\n-    pub token_trees: Vec<TokenTree>,\n-}\n-\n-impl TokenStream {\n-    pub fn new() -> Self {\n-        TokenStream::default()\n-    }\n-\n-    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        if subtree.delimiter.is_some() {\n-            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n-        } else {\n-            TokenStream { token_trees: subtree.token_trees }\n-        }\n-    }\n-\n-    pub fn into_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.token_trees.is_empty()\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream { token_trees: vec![tree] }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = TokenStreamBuilder::new();\n-        streams.into_iter().for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        for item in streams {\n-            for tkn in item {\n-                match tkn {\n-                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n-                        self.token_trees.extend(subtree.token_trees);\n-                    }\n-                    _ => {\n-                        self.token_trees.push(tkn);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct SourceFile {\n-    // FIXME stub\n-}\n-\n-type Level = super::proc_macro::Level;\n-type LineColumn = super::proc_macro::LineColumn;\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-}\n-\n-// Rustc Server Ident has to be `Copyable`\n-// We use a stub here for bypassing\n-#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n-pub struct IdentId(u32);\n-\n-#[derive(Clone, Hash, Eq, PartialEq)]\n-struct IdentData(tt::Ident);\n-\n-#[derive(Default)]\n-struct IdentInterner {\n-    idents: HashMap<IdentData, u32>,\n-    ident_data: Vec<IdentData>,\n-}\n-\n-impl IdentInterner {\n-    fn intern(&mut self, data: &IdentData) -> u32 {\n-        if let Some(index) = self.idents.get(data) {\n-            return *index;\n-        }\n-\n-        let index = self.idents.len() as u32;\n-        self.ident_data.push(data.clone());\n-        self.idents.insert(data.clone(), index);\n-        index\n-    }\n-\n-    fn get(&self, index: u32) -> &IdentData {\n-        &self.ident_data[index as usize]\n-    }\n-\n-    #[allow(unused)]\n-    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n-        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n-    }\n-}\n-\n-pub struct TokenStreamBuilder {\n-    acc: TokenStream,\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use std::str::FromStr;\n-\n-    use super::{TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = super::IntoIter<TokenTree>;\n-\n-        fn into_iter(self) -> Self::IntoIter {\n-            self.token_trees.into_iter()\n-        }\n-    }\n-\n-    type LexError = String;\n-\n-    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n-    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-    /// or characters not existing in the language.\n-    /// All tokens in the parsed stream get `Span::call_site()` spans.\n-    ///\n-    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-    /// change these errors into `LexError`s later.\n-    impl FromStr for TokenStream {\n-        type Err = LexError;\n-\n-        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-            let (subtree, _token_map) =\n-                mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n-\n-            let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n-            Ok(TokenStream::with_subtree(subtree))\n-        }\n-    }\n-\n-    impl ToString for TokenStream {\n-        fn to_string(&self) -> String {\n-            tt::pretty(&self.token_trees)\n-        }\n-    }\n-\n-    fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n-        tt::Subtree {\n-            delimiter: subtree\n-                .delimiter\n-                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n-            token_trees: subtree\n-                .token_trees\n-                .into_iter()\n-                .map(token_tree_replace_token_ids_with_unspecified)\n-                .collect(),\n-        }\n-    }\n-\n-    fn token_tree_replace_token_ids_with_unspecified(tt: tt::TokenTree) -> tt::TokenTree {\n-        match tt {\n-            tt::TokenTree::Leaf(leaf) => {\n-                tt::TokenTree::Leaf(leaf_replace_token_ids_with_unspecified(leaf))\n-            }\n-            tt::TokenTree::Subtree(subtree) => {\n-                tt::TokenTree::Subtree(subtree_replace_token_ids_with_unspecified(subtree))\n-            }\n-        }\n-    }\n-\n-    fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n-        match leaf {\n-            tt::Leaf::Literal(lit) => {\n-                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n-            }\n-            tt::Leaf::Punct(punct) => {\n-                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n-            }\n-            tt::Leaf::Ident(ident) => {\n-                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n-            }\n-        }\n-    }\n-}\n-\n-impl TokenStreamBuilder {\n-    fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder { acc: TokenStream::new() }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        self.acc.extend(stream.into_iter())\n-    }\n-\n-    fn build(self) -> TokenStream {\n-        self.acc\n-    }\n-}\n-\n-pub struct FreeFunctions;\n-\n-#[derive(Clone)]\n-pub struct TokenStreamIter {\n-    trees: IntoIter<TokenTree>,\n-}\n-\n-#[derive(Default)]\n-pub struct RustAnalyzer {\n-    ident_interner: IdentInterner,\n-    // FIXME: store span information here.\n-}\n-\n-impl server::Types for RustAnalyzer {\n-    type FreeFunctions = FreeFunctions;\n-    type TokenStream = TokenStream;\n-    type Ident = IdentId;\n-    type Literal = Literal;\n-    type SourceFile = SourceFile;\n-    type Diagnostic = Diagnostic;\n-    type Span = Span;\n-    type MultiSpan = Vec<Span>;\n-}\n-\n-impl server::FreeFunctions for RustAnalyzer {\n-    fn track_env_var(&mut self, _var: &str, _value: Option<&str>) {\n-        // FIXME: track env var accesses\n-        // https://github.com/rust-lang/rust/pull/71858\n-    }\n-    fn track_path(&mut self, _path: &str) {}\n-}\n-\n-impl server::TokenStream for RustAnalyzer {\n-    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n-        stream.is_empty()\n-    }\n-    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n-        use std::str::FromStr;\n-\n-        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n-    }\n-    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n-        stream.to_string()\n-    }\n-    fn from_token_tree(\n-        &mut self,\n-        tree: bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n-    ) -> Self::TokenStream {\n-        match tree {\n-            bridge::TokenTree::Group(group) => {\n-                let group = Group {\n-                    delimiter: delim_to_internal(group.delimiter),\n-                    token_trees: match group.stream {\n-                        Some(stream) => stream.into_iter().collect(),\n-                        None => Vec::new(),\n-                    },\n-                };\n-                let tree = TokenTree::from(group);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Ident(IdentId(index)) => {\n-                let IdentData(ident) = self.ident_interner.get(index).clone();\n-                let ident: tt::Ident = ident;\n-                let leaf = tt::Leaf::from(ident);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Literal(literal) => {\n-                let leaf = tt::Leaf::from(literal);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Punct(p) => {\n-                let punct = tt::Punct {\n-                    char: p.ch as char,\n-                    spacing: if p.joint { Spacing::Joint } else { Spacing::Alone },\n-                    id: p.span,\n-                };\n-                let leaf = tt::Leaf::from(punct);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-        }\n-    }\n-\n-    fn expand_expr(&mut self, self_: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n-        Ok(self_.clone())\n-    }\n-\n-    fn concat_trees(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        trees: Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for tree in trees {\n-            builder.push(self.from_token_tree(tree));\n-        }\n-        builder.build()\n-    }\n-\n-    fn concat_streams(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        streams: Vec<Self::TokenStream>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for stream in streams {\n-            builder.push(stream);\n-        }\n-        builder.build()\n-    }\n-\n-    fn into_trees(\n-        &mut self,\n-        stream: Self::TokenStream,\n-    ) -> Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n-        stream\n-            .into_iter()\n-            .map(|tree| match tree {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n-                }\n-                tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => bridge::TokenTree::Literal(lit),\n-                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n-                    bridge::TokenTree::Punct(bridge::Punct {\n-                        ch: punct.char as u8,\n-                        joint: punct.spacing == Spacing::Joint,\n-                        span: punct.id,\n-                    })\n-                }\n-                tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(bridge::Group {\n-                    delimiter: delim_to_external(subtree.delimiter),\n-                    stream: if subtree.token_trees.is_empty() {\n-                        None\n-                    } else {\n-                        Some(subtree.token_trees.into_iter().collect())\n-                    },\n-                    span: bridge::DelimSpan::from_single(\n-                        subtree.delimiter.map_or(Span::unspecified(), |del| del.id),\n-                    ),\n-                }),\n-            })\n-            .collect()\n-    }\n-}\n-\n-fn delim_to_internal(d: bridge::Delimiter) -> Option<tt::Delimiter> {\n-    let kind = match d {\n-        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n-        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n-        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        bridge::Delimiter::None => return None,\n-    };\n-    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n-}\n-\n-fn delim_to_external(d: Option<tt::Delimiter>) -> bridge::Delimiter {\n-    match d.map(|it| it.kind) {\n-        Some(tt::DelimiterKind::Parenthesis) => bridge::Delimiter::Parenthesis,\n-        Some(tt::DelimiterKind::Brace) => bridge::Delimiter::Brace,\n-        Some(tt::DelimiterKind::Bracket) => bridge::Delimiter::Bracket,\n-        None => bridge::Delimiter::None,\n-    }\n-}\n-\n-fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n-    match spacing {\n-        bridge::Spacing::Alone => Spacing::Alone,\n-        bridge::Spacing::Joint => Spacing::Joint,\n-    }\n-}\n-\n-fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n-    match spacing {\n-        Spacing::Alone => bridge::Spacing::Alone,\n-        Spacing::Joint => bridge::Spacing::Joint,\n-    }\n-}\n-\n-impl server::Ident for RustAnalyzer {\n-    fn new(&mut self, string: &str, span: Self::Span, _is_raw: bool) -> Self::Ident {\n-        IdentId(self.ident_interner.intern(&IdentData(tt::Ident { text: string.into(), id: span })))\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        self.ident_interner.get(ident.0).0.id\n-    }\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        let data = self.ident_interner.get(ident.0);\n-        let new = IdentData(tt::Ident { id: span, ..data.0.clone() });\n-        IdentId(self.ident_interner.intern(&new))\n-    }\n-}\n-\n-impl server::Literal for RustAnalyzer {\n-    fn debug_kind(&mut self, _literal: &Self::Literal) -> String {\n-        // r-a: debug_kind and suffix are unsupported; corresponding client code has been changed to not call these.\n-        // They must still be present to be ABI-compatible and work with upstream proc_macro.\n-        \"\".to_owned()\n-    }\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        Ok(Literal { text: s.into(), id: tt::TokenId::unspecified() })\n-    }\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.text.to_string()\n-    }\n-    fn suffix(&mut self, _literal: &Self::Literal) -> Option<String> {\n-        None\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.to_string()\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        let n = match n.parse::<i128>() {\n-            Ok(n) => n.to_string(),\n-            Err(_) => n.parse::<u128>().unwrap().to_string(),\n-        };\n-        Literal { text: n.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        macro_rules! def_suffixed_integer {\n-            ($kind:ident, $($ty:ty),*) => {\n-                match $kind {\n-                    $(\n-                        stringify!($ty) => {\n-                            let n: $ty = n.parse().unwrap();\n-                            format!(concat!(\"{}\", stringify!($ty)), n)\n-                        }\n-                    )*\n-                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n-                }\n-            }\n-        }\n-\n-        let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n-\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let mut text = f64::to_string(&n);\n-        if !text.contains('.') {\n-            text += \".0\"\n-        }\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        let n: f32 = n.parse().unwrap();\n-        let text = format!(\"{}f32\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let text = format!(\"{}f64\", n);\n-        Literal { text: text.into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let mut escaped = String::new();\n-        for ch in string.chars() {\n-            escaped.extend(ch.escape_debug());\n-        }\n-        Literal { text: format!(\"\\\"{}\\\"\", escaped).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        Literal { text: format!(\"'{}'\", ch).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-\n-        Literal { text: format!(\"b\\\"{}\\\"\", string).into(), id: tt::TokenId::unspecified() }\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.id\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.id = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        _literal: &Self::Literal,\n-        _start: Bound<usize>,\n-        _end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-}\n-\n-impl server::SourceFile for RustAnalyzer {\n-    // FIXME these are all stubs\n-    fn eq(&mut self, _file1: &Self::SourceFile, _file2: &Self::SourceFile) -> bool {\n-        true\n-    }\n-    fn path(&mut self, _file: &Self::SourceFile) -> String {\n-        String::new()\n-    }\n-    fn is_real(&mut self, _file: &Self::SourceFile) -> bool {\n-        true\n-    }\n-}\n-\n-impl server::Diagnostic for RustAnalyzer {\n-    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n-        let mut diag = Diagnostic::new(level, msg);\n-        diag.spans = spans;\n-        diag\n-    }\n-\n-    fn sub(\n-        &mut self,\n-        _diag: &mut Self::Diagnostic,\n-        _level: Level,\n-        _msg: &str,\n-        _spans: Self::MultiSpan,\n-    ) {\n-        // FIXME handle diagnostic\n-        //\n-    }\n-\n-    fn emit(&mut self, _diag: Self::Diagnostic) {\n-        // FIXME handle diagnostic\n-        // diag.emit()\n-    }\n-}\n-\n-impl server::Span for RustAnalyzer {\n-    fn debug(&mut self, span: Self::Span) -> String {\n-        format!(\"{:?}\", span.0)\n-    }\n-    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n-        SourceFile {}\n-    }\n-    fn save_span(&mut self, _span: Self::Span) -> usize {\n-        // FIXME stub\n-        0\n-    }\n-    fn recover_proc_macro_span(&mut self, _id: usize) -> Self::Span {\n-        // FIXME stub\n-        tt::TokenId::unspecified()\n-    }\n-    /// Recent feature, not yet in the proc_macro\n-    ///\n-    /// See PR:\n-    /// https://github.com/rust-lang/rust/pull/55780\n-    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n-        None\n-    }\n-\n-    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-    fn source(&mut self, span: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        span\n-    }\n-    fn start(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn end(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn join(&mut self, first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n-        // Just return the first span again, because some macros will unwrap the result.\n-        Some(first)\n-    }\n-    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn after(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn before(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-}\n-\n-impl server::MultiSpan for RustAnalyzer {\n-    fn new(&mut self) -> Self::MultiSpan {\n-        // FIXME handle span\n-        vec![]\n-    }\n-\n-    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n-        //TODP\n-        other.push(span)\n-    }\n-}\n-\n-impl server::Server for RustAnalyzer {\n-    fn globals(&mut self) -> bridge::ExpnGlobals<Self::Span> {\n-        bridge::ExpnGlobals {\n-            def_site: Span::unspecified(),\n-            call_site: Span::unspecified(),\n-            mixed_site: Span::unspecified(),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::super::proc_macro::bridge::server::Literal;\n-    use super::*;\n-\n-    #[test]\n-    fn test_ra_server_literals() {\n-        let mut srv = RustAnalyzer { ident_interner: IdentInterner::default() };\n-        assert_eq!(srv.integer(\"1234\").text, \"1234\");\n-\n-        assert_eq!(srv.typed_integer(\"12\", \"u8\").text, \"12u8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"u16\").text, \"255u16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"u32\").text, \"1234u32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"u64\").text, \"15846685u64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"u128\").text, \"15846685258u128\");\n-        assert_eq!(srv.typed_integer(\"156788984\", \"usize\").text, \"156788984usize\");\n-        assert_eq!(srv.typed_integer(\"127\", \"i8\").text, \"127i8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"i16\").text, \"255i16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"i32\").text, \"1234i32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"i64\").text, \"15846685i64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"i128\").text, \"15846685258i128\");\n-        assert_eq!(srv.float(\"0\").text, \"0.0\");\n-        assert_eq!(srv.float(\"15684.5867\").text, \"15684.5867\");\n-        assert_eq!(srv.f32(\"15684.58\").text, \"15684.58f32\");\n-        assert_eq!(srv.f64(\"15684.58\").text, \"15684.58f64\");\n-\n-        assert_eq!(srv.string(\"hello_world\").text, \"\\\"hello_world\\\"\");\n-        assert_eq!(srv.character('c').text, \"'c'\");\n-        assert_eq!(srv.byte_string(b\"1234586\\x88\").text, \"b\\\"1234586\\\\x88\\\"\");\n-\n-        // u128::max\n-        assert_eq!(\n-            srv.integer(\"340282366920938463463374607431768211455\").text,\n-            \"340282366920938463463374607431768211455\"\n-        );\n-        // i128::min\n-        assert_eq!(\n-            srv.integer(\"-170141183460469231731687303715884105728\").text,\n-            \"-170141183460469231731687303715884105728\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ra_server_to_string() {\n-        let s = TokenStream {\n-            token_trees: vec![\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"struct\".into(),\n-                    id: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"T\".into(),\n-                    id: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: Some(tt::Delimiter {\n-                        id: tt::TokenId::unspecified(),\n-                        kind: tt::DelimiterKind::Brace,\n-                    }),\n-                    token_trees: vec![],\n-                }),\n-            ],\n-        };\n-\n-        assert_eq!(s.to_string(), \"struct T {}\");\n-    }\n-\n-    #[test]\n-    fn test_ra_server_from_str() {\n-        use std::str::FromStr;\n-        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n-            delimiter: Some(tt::Delimiter {\n-                id: tt::TokenId::unspecified(),\n-                kind: tt::DelimiterKind::Parenthesis,\n-            }),\n-            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"a\".into(),\n-                id: tt::TokenId::unspecified(),\n-            }))],\n-        });\n-\n-        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n-        assert_eq!(t1.token_trees.len(), 1);\n-        assert_eq!(t1.token_trees[0], subtree_paren_a);\n-\n-        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n-        assert_eq!(t2.token_trees.len(), 2);\n-        assert_eq!(t2.token_trees[0], subtree_paren_a);\n-\n-        let underscore = TokenStream::from_str(\"_\").unwrap();\n-        assert_eq!(\n-            underscore.token_trees[0],\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"_\".into(),\n-                id: tt::TokenId::unspecified(),\n-            }))\n-        );\n-    }\n-}"}, {"sha": "52eb7ce17d6aeb482d41846a7781b0601ff8131a", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -20,7 +20,7 @@ use token_stream::TokenStreamBuilder;\n mod symbol;\n pub use symbol::*;\n \n-use std::{iter::FromIterator, ops::Bound};\n+use std::ops::Bound;\n \n type Group = tt::Subtree;\n type TokenTree = tt::TokenTree;"}, {"sha": "f7d3a30919e1c786c50c4ad0494f3f0c546af4aa", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -25,7 +25,6 @@\n \n mod abi_1_58;\n mod abi_1_63;\n-mod abi_1_64;\n #[cfg(feature = \"sysroot-abi\")]\n mod abi_sysroot;\n \n@@ -34,12 +33,11 @@ include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n \n // Used by `test/utils.rs`\n #[cfg(test)]\n-pub(crate) use abi_1_64::TokenStream as TestTokenStream;\n+pub(crate) use abi_1_63::TokenStream as TestTokenStream;\n \n use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_58::Abi as Abi_1_58;\n pub(crate) use abi_1_63::Abi as Abi_1_63;\n-pub(crate) use abi_1_64::Abi as Abi_1_64;\n #[cfg(feature = \"sysroot-abi\")]\n pub(crate) use abi_sysroot::Abi as Abi_Sysroot;\n use libloading::Library;\n@@ -58,7 +56,6 @@ impl PanicMessage {\n pub(crate) enum Abi {\n     Abi1_58(Abi_1_58),\n     Abi1_63(Abi_1_63),\n-    Abi1_64(Abi_1_64),\n     #[cfg(feature = \"sysroot-abi\")]\n     AbiSysroot(Abi_Sysroot),\n }\n@@ -120,10 +117,6 @@ impl Abi {\n                 let inner = unsafe { Abi_1_63::from_lib(lib, symbol_name) }?;\n                 Ok(Abi::Abi1_63(inner))\n             }\n-            (1, 64..) => {\n-                let inner = unsafe { Abi_1_64::from_lib(lib, symbol_name) }?;\n-                Ok(Abi::Abi1_64(inner))\n-            }\n             _ => Err(LoadProcMacroDylibError::UnsupportedABI),\n         }\n     }\n@@ -137,7 +130,6 @@ impl Abi {\n         match self {\n             Self::Abi1_58(abi) => abi.expand(macro_name, macro_body, attributes),\n             Self::Abi1_63(abi) => abi.expand(macro_name, macro_body, attributes),\n-            Self::Abi1_64(abi) => abi.expand(macro_name, macro_body, attributes),\n             #[cfg(feature = \"sysroot-abi\")]\n             Self::AbiSysroot(abi) => abi.expand(macro_name, macro_body, attributes),\n         }\n@@ -147,7 +139,6 @@ impl Abi {\n         match self {\n             Self::Abi1_58(abi) => abi.list_macros(),\n             Self::Abi1_63(abi) => abi.list_macros(),\n-            Self::Abi1_64(abi) => abi.list_macros(),\n             #[cfg(feature = \"sysroot-abi\")]\n             Self::AbiSysroot(abi) => abi.list_macros(),\n         }"}, {"sha": "7aba74e5396dee1778f272321144017e0140bf35", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1,7 +1,6 @@\n //! Handles dynamic library loading for proc macro\n \n use std::{\n-    convert::TryInto,\n     fmt,\n     fs::File,\n     io,"}, {"sha": "6339d56d01791dcfc359bd53f74a0dccad8fb59b", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -19,7 +19,7 @@ fn test_derive_error() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [alone] 4294967295\n+              PUNCH   ! [joint] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[derive(DeriveError)] struct S ;\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],\n@@ -109,7 +109,7 @@ fn test_fn_like_macro_clone_literals() {\n               PUNCH   , [alone] 4294967295\n               LITERAL 2_u32 4294967295\n               PUNCH   , [alone] 4294967295\n-              PUNCH   - [alone] 4294967295\n+              PUNCH   - [joint] 4294967295\n               LITERAL 4i64 4294967295\n               PUNCH   , [alone] 4294967295\n               LITERAL 3.14f32 4294967295\n@@ -130,7 +130,7 @@ fn test_attr_macro() {\n         expect![[r##\"\n             SUBTREE $\n               IDENT   compile_error 4294967295\n-              PUNCH   ! [alone] 4294967295\n+              PUNCH   ! [joint] 4294967295\n               SUBTREE () 4294967295\n                 LITERAL \"#[attr_error(some arguments)] mod m {}\" 4294967295\n               PUNCH   ; [alone] 4294967295\"##]],"}, {"sha": "84e772d1684a18e8c47bf85d56cd164fd60f416d", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -12,6 +12,7 @@ use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n use paths::AbsPathBuf;\n use rustc_hash::FxHashMap;\n+use semver::Version;\n use serde::Deserialize;\n \n use crate::{cfg_flag::CfgFlag, CargoConfig, CargoWorkspace, Package};\n@@ -77,9 +78,32 @@ impl WorkspaceBuildScripts {\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n+        toolchain: &Option<Version>,\n     ) -> io::Result<WorkspaceBuildScripts> {\n-        let mut cmd = Self::build_command(config);\n+        const RUST_1_62: Version = Version::new(1, 62, 0);\n \n+        match Self::run_(Self::build_command(config), config, workspace, progress) {\n+            Ok(WorkspaceBuildScripts { error: Some(error), .. })\n+                if toolchain.as_ref().map_or(false, |it| *it >= RUST_1_62) =>\n+            {\n+                // building build scripts failed, attempt to build with --keep-going so\n+                // that we potentially get more build data\n+                let mut cmd = Self::build_command(config);\n+                cmd.args(&[\"-Z\", \"unstable-options\", \"--keep-going\"]).env(\"RUSTC_BOOTSTRAP\", \"1\");\n+                let mut res = Self::run_(cmd, config, workspace, progress)?;\n+                res.error = Some(error);\n+                Ok(res)\n+            }\n+            res => res,\n+        }\n+    }\n+\n+    fn run_(\n+        mut cmd: Command,\n+        config: &CargoConfig,\n+        workspace: &CargoWorkspace,\n+        progress: &dyn Fn(String),\n+    ) -> io::Result<WorkspaceBuildScripts> {\n         if config.wrap_rustc_in_build_scripts {\n             // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n             // that to compile only proc macros and build scripts during the initial"}, {"sha": "8d0fa757c2e176baf6c0904927bfe252a9e4772d", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -28,6 +28,7 @@ fn load_cargo_with_overrides(file: &str, cfg_overrides: CfgOverrides) -> CrateGr\n         rustc: None,\n         rustc_cfg: Vec::new(),\n         cfg_overrides,\n+        toolchain: None,\n     };\n     to_crate_graph(project_workspace)\n }"}, {"sha": "daabb299f76cb0f18f454e3012dafc711d8e0c59", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -12,6 +12,7 @@ use base_db::{\n use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n+use semver::Version;\n use stdx::always;\n \n use crate::{\n@@ -77,6 +78,7 @@ pub enum ProjectWorkspace {\n         /// different target.\n         rustc_cfg: Vec<CfgFlag>,\n         cfg_overrides: CfgOverrides,\n+        toolchain: Option<Version>,\n     },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n     Json { project: ProjectJson, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n@@ -105,6 +107,7 @@ impl fmt::Debug for ProjectWorkspace {\n                 rustc,\n                 rustc_cfg,\n                 cfg_overrides,\n+                toolchain,\n             } => f\n                 .debug_struct(\"Cargo\")\n                 .field(\"root\", &cargo.workspace_root().file_name())\n@@ -116,6 +119,7 @@ impl fmt::Debug for ProjectWorkspace {\n                 )\n                 .field(\"n_rustc_cfg\", &rustc_cfg.len())\n                 .field(\"n_cfg_overrides\", &cfg_overrides.len())\n+                .field(\"toolchain\", &toolchain)\n                 .finish(),\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n@@ -160,6 +164,9 @@ impl ProjectWorkspace {\n                     cmd.arg(\"--version\");\n                     cmd\n                 })?;\n+                let toolchain = cargo_version\n+                    .get(\"cargo \".len()..)\n+                    .and_then(|it| Version::parse(it.split_whitespace().next()?).ok());\n \n                 let meta = CargoWorkspace::fetch_metadata(\n                     &cargo_toml,\n@@ -169,9 +176,9 @@ impl ProjectWorkspace {\n                 )\n                 .with_context(|| {\n                     format!(\n-                        \"Failed to read Cargo metadata from Cargo.toml file {}, {}\",\n+                        \"Failed to read Cargo metadata from Cargo.toml file {}, {:?}\",\n                         cargo_toml.display(),\n-                        cargo_version\n+                        toolchain\n                     )\n                 })?;\n                 let cargo = CargoWorkspace::new(meta);\n@@ -219,6 +226,7 @@ impl ProjectWorkspace {\n                     rustc,\n                     rustc_cfg,\n                     cfg_overrides,\n+                    toolchain,\n                 }\n             }\n         };\n@@ -271,8 +279,8 @@ impl ProjectWorkspace {\n         progress: &dyn Fn(String),\n     ) -> Result<WorkspaceBuildScripts> {\n         match self {\n-            ProjectWorkspace::Cargo { cargo, .. } => {\n-                WorkspaceBuildScripts::run(config, cargo, progress).with_context(|| {\n+            ProjectWorkspace::Cargo { cargo, toolchain, .. } => {\n+                WorkspaceBuildScripts::run(config, cargo, progress, toolchain).with_context(|| {\n                     format!(\"Failed to run build scripts for {}\", &cargo.workspace_root().display())\n                 })\n             }\n@@ -320,6 +328,7 @@ impl ProjectWorkspace {\n                 rustc_cfg: _,\n                 cfg_overrides: _,\n                 build_scripts,\n+                toolchain: _,\n             } => {\n                 cargo\n                     .packages()\n@@ -425,6 +434,7 @@ impl ProjectWorkspace {\n                 rustc_cfg,\n                 cfg_overrides,\n                 build_scripts,\n+                toolchain: _,\n             } => cargo_to_crate_graph(\n                 rustc_cfg.clone(),\n                 cfg_overrides,"}, {"sha": "38e9c7dd7e11c33ade9108eda5ac4f9b164fd810", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/rustc_wrapper.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Frustc_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Frustc_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Frustc_wrapper.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -17,6 +17,11 @@ pub(crate) fn run_rustc_skipping_cargo_checking(\n     rustc_executable: OsString,\n     args: Vec<OsString>,\n ) -> io::Result<ExitCode> {\n+    // `CARGO_CFG_TARGET_ARCH` is only set by cargo when executing build scripts\n+    // We don't want to exit out checks unconditionally with success if a build\n+    // script tries to invoke checks themselves\n+    // See https://github.com/rust-lang/rust-analyzer/issues/12973 for context\n+    let not_invoked_by_build_script = std::env::var_os(\"CARGO_CFG_TARGET_ARCH\").is_none();\n     let is_cargo_check = args.iter().any(|arg| {\n         let arg = arg.to_string_lossy();\n         // `cargo check` invokes `rustc` with `--emit=metadata` argument.\n@@ -29,7 +34,7 @@ pub(crate) fn run_rustc_skipping_cargo_checking(\n         //            The default output filename is CRATE_NAME.rmeta.\n         arg.starts_with(\"--emit=\") && arg.contains(\"metadata\") && !arg.contains(\"link\")\n     });\n-    if is_cargo_check {\n+    if not_invoked_by_build_script && is_cargo_check {\n         return Ok(ExitCode(Some(0)));\n     }\n     run_rustc(rustc_executable, args)"}, {"sha": "247007db0a7883474caaf5b90e031abbd70f3a09", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -43,7 +43,7 @@ impl flags::Diagnostics {\n                 println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n                 for diagnostic in analysis\n                     .diagnostics(\n-                        &DiagnosticsConfig::default(),\n+                        &DiagnosticsConfig::test_sample(),\n                         AssistResolveStrategy::None,\n                         file_id,\n                     )"}, {"sha": "080e2fb4438816717f38985da19aa681cf0817ad", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -10,6 +10,10 @@ xflags::xflags! {\n     src \"./src/cli/flags.rs\"\n \n     /// LSP server for the Rust programming language.\n+    ///\n+    /// Subcommands and their flags do not provide any stability guarantees and may be removed or\n+    /// changed without notice. Top-level flags that are not are marked as [Unstable] provide\n+    /// backwards-compatibility and may be relied on.\n     cmd rust-analyzer {\n         /// Verbosity level, can be repeated multiple times.\n         repeated -v, --verbose\n@@ -21,7 +25,7 @@ xflags::xflags! {\n         /// Flush log records to the file immediately.\n         optional --no-log-buffering\n \n-        /// Wait until a debugger is attached to (requires debug build).\n+        /// [Unstable] Wait until a debugger is attached to (requires debug build).\n         optional --wait-dbg\n \n         default cmd lsp-server {"}, {"sha": "1629c1dd328a69348f06299449291b90f06a4c39", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -881,6 +881,7 @@ impl Config {\n                 ExprFillDefaultDef::Todo => ExprFillDefaultMode::Todo,\n                 ExprFillDefaultDef::Default => ExprFillDefaultMode::Default,\n             },\n+            insert_use: self.insert_use_config(),\n         }\n     }\n "}, {"sha": "74689fd8757f82942c13842fd1305a48c41606e4", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -512,7 +512,7 @@ fn clippy_code_description(code: Option<&str>) -> Option<lsp_types::CodeDescript\n #[cfg(test)]\n #[cfg(not(windows))]\n mod tests {\n-    use std::{convert::TryInto, path::Path};\n+    use std::path::Path;\n \n     use crate::{config::Config, global_state::GlobalState};\n "}, {"sha": "943d043bc1995dbfc3eb49bde756cf4fdd0c1e8f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1320,8 +1320,7 @@ pub(crate) fn publish_diagnostics(\n                 .unwrap(),\n             }),\n             source: Some(\"rust-analyzer\".to_string()),\n-            // https://github.com/rust-lang/rust-analyzer/issues/11404\n-            message: if !d.message.is_empty() { d.message } else { \" \".to_string() },\n+            message: d.message,\n             related_information: None,\n             tags: if d.unused { Some(vec![DiagnosticTag::UNNECESSARY]) } else { None },\n             data: None,"}, {"sha": "77419998249f41fc49f2d66e1fc3f43a83ff6765", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 194, "deletions": 205, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -9,6 +9,7 @@ use std::{\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n+use flycheck::FlycheckHandle;\n use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n@@ -205,81 +206,14 @@ impl GlobalState {\n                 }\n                 lsp_server::Message::Response(resp) => self.complete_request(resp),\n             },\n-            Event::Task(mut task) => {\n+            Event::Task(task) => {\n                 let _p = profile::span(\"GlobalState::handle_event/task\");\n                 let mut prime_caches_progress = Vec::new();\n-                loop {\n-                    match task {\n-                        Task::Response(response) => self.respond(response),\n-                        Task::Retry(req) => self.on_request(req),\n-                        Task::Diagnostics(diagnostics_per_file) => {\n-                            for (file_id, diagnostics) in diagnostics_per_file {\n-                                self.diagnostics.set_native_diagnostics(file_id, diagnostics)\n-                            }\n-                        }\n-                        Task::PrimeCaches(progress) => match progress {\n-                            PrimeCachesProgress::Begin => prime_caches_progress.push(progress),\n-                            PrimeCachesProgress::Report(_) => {\n-                                match prime_caches_progress.last_mut() {\n-                                    Some(last @ PrimeCachesProgress::Report(_)) => {\n-                                        // Coalesce subsequent update events.\n-                                        *last = progress;\n-                                    }\n-                                    _ => prime_caches_progress.push(progress),\n-                                }\n-                            }\n-                            PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),\n-                        },\n-                        Task::FetchWorkspace(progress) => {\n-                            let (state, msg) = match progress {\n-                                ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n-                                ProjectWorkspaceProgress::Report(msg) => {\n-                                    (Progress::Report, Some(msg))\n-                                }\n-                                ProjectWorkspaceProgress::End(workspaces) => {\n-                                    self.fetch_workspaces_queue.op_completed(workspaces);\n \n-                                    let old = Arc::clone(&self.workspaces);\n-                                    self.switch_workspaces(\"fetched workspace\".to_string());\n-                                    let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n-\n-                                    if self.config.run_build_scripts() && workspaces_updated {\n-                                        self.fetch_build_data_queue\n-                                            .request_op(format!(\"workspace updated\"));\n-                                    }\n-\n-                                    (Progress::End, None)\n-                                }\n-                            };\n-\n-                            self.report_progress(\"Fetching\", state, msg, None);\n-                        }\n-                        Task::FetchBuildData(progress) => {\n-                            let (state, msg) = match progress {\n-                                BuildDataProgress::Begin => (Some(Progress::Begin), None),\n-                                BuildDataProgress::Report(msg) => {\n-                                    (Some(Progress::Report), Some(msg))\n-                                }\n-                                BuildDataProgress::End(build_data_result) => {\n-                                    self.fetch_build_data_queue.op_completed(build_data_result);\n-\n-                                    self.switch_workspaces(\"fetched build data\".to_string());\n-\n-                                    (Some(Progress::End), None)\n-                                }\n-                            };\n-\n-                            if let Some(state) = state {\n-                                self.report_progress(\"Loading\", state, msg, None);\n-                            }\n-                        }\n-                    }\n-\n-                    // Coalesce multiple task events into one loop turn\n-                    task = match self.task_pool.receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    };\n+                self.handle_task(&mut prime_caches_progress, task);\n+                // Coalesce multiple task events into one loop turn\n+                while let Ok(task) = self.task_pool.receiver.try_recv() {\n+                    self.handle_task(&mut prime_caches_progress, task);\n                 }\n \n                 for progress in prime_caches_progress {\n@@ -326,119 +260,20 @@ impl GlobalState {\n                     self.report_progress(\"Indexing\", state, message, Some(fraction));\n                 }\n             }\n-            Event::Vfs(mut task) => {\n+            Event::Vfs(message) => {\n                 let _p = profile::span(\"GlobalState::handle_event/vfs\");\n-                loop {\n-                    match task {\n-                        vfs::loader::Message::Loaded { files } => {\n-                            let vfs = &mut self.vfs.write().0;\n-                            for (path, contents) in files {\n-                                let path = VfsPath::from(path);\n-                                if !self.mem_docs.contains(&path) {\n-                                    vfs.set_file_contents(path, contents);\n-                                }\n-                            }\n-                        }\n-                        vfs::loader::Message::Progress { n_total, n_done, config_version } => {\n-                            always!(config_version <= self.vfs_config_version);\n-\n-                            self.vfs_progress_config_version = config_version;\n-                            self.vfs_progress_n_total = n_total;\n-                            self.vfs_progress_n_done = n_done;\n-\n-                            let state = if n_done == 0 {\n-                                Progress::Begin\n-                            } else if n_done < n_total {\n-                                Progress::Report\n-                            } else {\n-                                assert_eq!(n_done, n_total);\n-                                Progress::End\n-                            };\n-                            self.report_progress(\n-                                \"Roots Scanned\",\n-                                state,\n-                                Some(format!(\"{}/{}\", n_done, n_total)),\n-                                Some(Progress::fraction(n_done, n_total)),\n-                            )\n-                        }\n-                    }\n-                    // Coalesce many VFS event into a single loop turn\n-                    task = match self.loader.receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    }\n+                self.handle_vfs_msg(message);\n+                // Coalesce many VFS event into a single loop turn\n+                while let Ok(message) = self.loader.receiver.try_recv() {\n+                    self.handle_vfs_msg(message);\n                 }\n             }\n-            Event::Flycheck(mut task) => {\n+            Event::Flycheck(message) => {\n                 let _p = profile::span(\"GlobalState::handle_event/flycheck\");\n-                loop {\n-                    match task {\n-                        flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n-                            let snap = self.snapshot();\n-                            let diagnostics =\n-                                crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n-                                    &self.config.diagnostics_map(),\n-                                    &diagnostic,\n-                                    &workspace_root,\n-                                    &snap,\n-                                );\n-                            for diag in diagnostics {\n-                                match url_to_file_id(&self.vfs.read().0, &diag.url) {\n-                                    Ok(file_id) => self.diagnostics.add_check_diagnostic(\n-                                        id,\n-                                        file_id,\n-                                        diag.diagnostic,\n-                                        diag.fix,\n-                                    ),\n-                                    Err(err) => {\n-                                        tracing::error!(\n-                                            \"File with cargo diagnostic not found in VFS: {}\",\n-                                            err\n-                                        );\n-                                    }\n-                                };\n-                            }\n-                        }\n-\n-                        flycheck::Message::Progress { id, progress } => {\n-                            let (state, message) = match progress {\n-                                flycheck::Progress::DidStart => {\n-                                    self.diagnostics.clear_check(id);\n-                                    (Progress::Begin, None)\n-                                }\n-                                flycheck::Progress::DidCheckCrate(target) => {\n-                                    (Progress::Report, Some(target))\n-                                }\n-                                flycheck::Progress::DidCancel => (Progress::End, None),\n-                                flycheck::Progress::DidFinish(result) => {\n-                                    if let Err(err) = result {\n-                                        self.show_and_log_error(\n-                                            \"cargo check failed\".to_string(),\n-                                            Some(err.to_string()),\n-                                        );\n-                                    }\n-                                    (Progress::End, None)\n-                                }\n-                            };\n-\n-                            // When we're running multiple flychecks, we have to include a disambiguator in\n-                            // the title, or the editor complains. Note that this is a user-facing string.\n-                            let title = if self.flycheck.len() == 1 {\n-                                match self.config.flycheck() {\n-                                    Some(config) => format!(\"{}\", config),\n-                                    None => \"cargo check\".to_string(),\n-                                }\n-                            } else {\n-                                format!(\"cargo check (#{})\", id + 1)\n-                            };\n-                            self.report_progress(&title, state, message, None);\n-                        }\n-                    }\n-                    // Coalesce many flycheck updates into a single loop turn\n-                    task = match self.flycheck_receiver.try_recv() {\n-                        Ok(task) => task,\n-                        Err(_) => break,\n-                    }\n+                self.handle_flycheck_msg(message);\n+                // Coalesce many flycheck updates into a single loop turn\n+                while let Ok(message) = self.flycheck_receiver.try_recv() {\n+                    self.handle_flycheck_msg(message);\n                 }\n             }\n         }\n@@ -447,13 +282,13 @@ impl GlobalState {\n         let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n         if self.is_quiescent() {\n-            if !was_quiescent\n-                && !self.fetch_workspaces_queue.op_requested()\n-                && !self.fetch_build_data_queue.op_requested()\n-            {\n-                for flycheck in &self.flycheck {\n-                    flycheck.update();\n-                }\n+            let became_quiescent = !(was_quiescent\n+                || self.fetch_workspaces_queue.op_requested()\n+                || self.fetch_build_data_queue.op_requested());\n+\n+            if became_quiescent {\n+                // Project has loaded properly, kick off initial flycheck\n+                self.flycheck.iter().for_each(FlycheckHandle::update);\n                 if self.config.prefill_caches() {\n                     self.prime_caches_queue.request_op(\"became quiescent\".to_string());\n                 }\n@@ -492,28 +327,15 @@ impl GlobalState {\n                     continue;\n                 }\n \n-                let url = file_id_to_url(&self.vfs.read().0, file_id);\n-                let mut diagnostics =\n+                let uri = file_id_to_url(&self.vfs.read().0, file_id);\n+                let diagnostics =\n                     self.diagnostics.diagnostics_for(file_id).cloned().collect::<Vec<_>>();\n-                // https://github.com/rust-lang/rust-analyzer/issues/11404\n-                for d in &mut diagnostics {\n-                    if d.message.is_empty() {\n-                        d.message = \" \".to_string();\n-                    }\n-                    if let Some(rds) = d.related_information.as_mut() {\n-                        for rd in rds {\n-                            if rd.message.is_empty() {\n-                                rd.message = \" \".to_string();\n-                            }\n-                        }\n-                    }\n-                }\n-                let version = from_proto::vfs_path(&url)\n+                let version = from_proto::vfs_path(&uri)\n                     .map(|path| self.mem_docs.get(&path).map(|it| it.version))\n                     .unwrap_or_default();\n \n                 self.send_notification::<lsp_types::notification::PublishDiagnostics>(\n-                    lsp_types::PublishDiagnosticsParams { uri: url, diagnostics, version },\n+                    lsp_types::PublishDiagnosticsParams { uri, diagnostics, version },\n                 );\n             }\n         }\n@@ -575,11 +397,171 @@ impl GlobalState {\n         Ok(())\n     }\n \n+    fn handle_task(&mut self, prime_caches_progress: &mut Vec<PrimeCachesProgress>, task: Task) {\n+        match task {\n+            Task::Response(response) => self.respond(response),\n+            Task::Retry(req) => self.on_request(req),\n+            Task::Diagnostics(diagnostics_per_file) => {\n+                for (file_id, diagnostics) in diagnostics_per_file {\n+                    self.diagnostics.set_native_diagnostics(file_id, diagnostics)\n+                }\n+            }\n+            Task::PrimeCaches(progress) => match progress {\n+                PrimeCachesProgress::Begin => prime_caches_progress.push(progress),\n+                PrimeCachesProgress::Report(_) => {\n+                    match prime_caches_progress.last_mut() {\n+                        Some(last @ PrimeCachesProgress::Report(_)) => {\n+                            // Coalesce subsequent update events.\n+                            *last = progress;\n+                        }\n+                        _ => prime_caches_progress.push(progress),\n+                    }\n+                }\n+                PrimeCachesProgress::End { .. } => prime_caches_progress.push(progress),\n+            },\n+            Task::FetchWorkspace(progress) => {\n+                let (state, msg) = match progress {\n+                    ProjectWorkspaceProgress::Begin => (Progress::Begin, None),\n+                    ProjectWorkspaceProgress::Report(msg) => (Progress::Report, Some(msg)),\n+                    ProjectWorkspaceProgress::End(workspaces) => {\n+                        self.fetch_workspaces_queue.op_completed(workspaces);\n+\n+                        let old = Arc::clone(&self.workspaces);\n+                        self.switch_workspaces(\"fetched workspace\".to_string());\n+                        let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n+\n+                        if self.config.run_build_scripts() && workspaces_updated {\n+                            self.fetch_build_data_queue.request_op(format!(\"workspace updated\"));\n+                        }\n+\n+                        (Progress::End, None)\n+                    }\n+                };\n+\n+                self.report_progress(\"Fetching\", state, msg, None);\n+            }\n+            Task::FetchBuildData(progress) => {\n+                let (state, msg) = match progress {\n+                    BuildDataProgress::Begin => (Some(Progress::Begin), None),\n+                    BuildDataProgress::Report(msg) => (Some(Progress::Report), Some(msg)),\n+                    BuildDataProgress::End(build_data_result) => {\n+                        self.fetch_build_data_queue.op_completed(build_data_result);\n+\n+                        self.switch_workspaces(\"fetched build data\".to_string());\n+\n+                        (Some(Progress::End), None)\n+                    }\n+                };\n+\n+                if let Some(state) = state {\n+                    self.report_progress(\"Loading\", state, msg, None);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn handle_vfs_msg(&mut self, message: vfs::loader::Message) {\n+        match message {\n+            vfs::loader::Message::Loaded { files } => {\n+                let vfs = &mut self.vfs.write().0;\n+                for (path, contents) in files {\n+                    let path = VfsPath::from(path);\n+                    if !self.mem_docs.contains(&path) {\n+                        vfs.set_file_contents(path, contents);\n+                    }\n+                }\n+            }\n+            vfs::loader::Message::Progress { n_total, n_done, config_version } => {\n+                always!(config_version <= self.vfs_config_version);\n+\n+                self.vfs_progress_config_version = config_version;\n+                self.vfs_progress_n_total = n_total;\n+                self.vfs_progress_n_done = n_done;\n+\n+                let state = if n_done == 0 {\n+                    Progress::Begin\n+                } else if n_done < n_total {\n+                    Progress::Report\n+                } else {\n+                    assert_eq!(n_done, n_total);\n+                    Progress::End\n+                };\n+                self.report_progress(\n+                    \"Roots Scanned\",\n+                    state,\n+                    Some(format!(\"{}/{}\", n_done, n_total)),\n+                    Some(Progress::fraction(n_done, n_total)),\n+                )\n+            }\n+        }\n+    }\n+\n+    fn handle_flycheck_msg(&mut self, message: flycheck::Message) {\n+        match message {\n+            flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n+                let snap = self.snapshot();\n+                let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n+                    &self.config.diagnostics_map(),\n+                    &diagnostic,\n+                    &workspace_root,\n+                    &snap,\n+                );\n+                for diag in diagnostics {\n+                    match url_to_file_id(&self.vfs.read().0, &diag.url) {\n+                        Ok(file_id) => self.diagnostics.add_check_diagnostic(\n+                            id,\n+                            file_id,\n+                            diag.diagnostic,\n+                            diag.fix,\n+                        ),\n+                        Err(err) => {\n+                            tracing::error!(\"File with cargo diagnostic not found in VFS: {}\", err);\n+                        }\n+                    };\n+                }\n+            }\n+\n+            flycheck::Message::Progress { id, progress } => {\n+                let (state, message) = match progress {\n+                    flycheck::Progress::DidStart => {\n+                        self.diagnostics.clear_check(id);\n+                        (Progress::Begin, None)\n+                    }\n+                    flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n+                    flycheck::Progress::DidCancel => (Progress::End, None),\n+                    flycheck::Progress::DidFinish(result) => {\n+                        if let Err(err) = result {\n+                            self.show_and_log_error(\n+                                \"cargo check failed\".to_string(),\n+                                Some(err.to_string()),\n+                            );\n+                        }\n+                        (Progress::End, None)\n+                    }\n+                };\n+\n+                // When we're running multiple flychecks, we have to include a disambiguator in\n+                // the title, or the editor complains. Note that this is a user-facing string.\n+                let title = if self.flycheck.len() == 1 {\n+                    match self.config.flycheck() {\n+                        Some(config) => format!(\"{}\", config),\n+                        None => \"cargo check\".to_string(),\n+                    }\n+                } else {\n+                    format!(\"cargo check (#{})\", id + 1)\n+                };\n+                self.report_progress(&title, state, message, None);\n+            }\n+        }\n+    }\n+\n+    /// Registers and handles a request. This should only be called once per incoming request.\n     fn on_new_request(&mut self, request_received: Instant, req: Request) {\n         self.register_request(&req, request_received);\n         self.on_request(req);\n     }\n \n+    /// Handles a request.\n     fn on_request(&mut self, req: Request) {\n         if self.shutdown_requested {\n             self.respond(lsp_server::Response::new_err(\n@@ -670,6 +652,7 @@ impl GlobalState {\n             .finish();\n     }\n \n+    /// Handles an incoming notification.\n     fn on_notification(&mut self, not: Notification) -> Result<()> {\n         NotificationDispatcher { not: Some(not), global_state: self }\n             .on::<lsp_types::notification::Cancel>(|this, params| {\n@@ -743,6 +726,8 @@ impl GlobalState {\n                 let mut updated = false;\n                 if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n                     let (vfs, _) = &*this.vfs.read();\n+\n+                    // Trigger flychecks for all workspaces that depend on the saved file\n                     if let Some(file_id) = vfs.file_id(&vfs_path) {\n                         let analysis = this.analysis_host.analysis();\n                         // Crates containing or depending on the saved file\n@@ -800,13 +785,17 @@ impl GlobalState {\n                             }\n                         }\n                     }\n+\n+                    // Re-fetch workspaces if a workspace related file has changed\n                     if let Some(abs_path) = vfs_path.as_path() {\n                         if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n                             this.fetch_workspaces_queue\n                                 .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n                         }\n                     }\n                 }\n+\n+                // No specific flycheck was triggered, so let's trigger all of them.\n                 if !updated {\n                     for flycheck in &this.flycheck {\n                         flycheck.update();"}, {"sha": "ceb2a6d703d959ad819f422ae27d0e807f1d25d9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -219,6 +219,7 @@ impl GlobalState {\n                     cfg_overrides,\n \n                     build_scripts: _,\n+                    toolchain: _,\n                 } => Some((cargo, sysroot, rustc, rustc_cfg, cfg_overrides)),\n                 _ => None,\n             };"}, {"sha": "e7115b0732e20c6922627cd3675172cae612c686", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -1386,7 +1386,7 @@ fn main() {\n     #[test]\n     #[cfg(target_os = \"windows\")]\n     fn test_lowercase_drive_letter() {\n-        use std::{convert::TryInto, path::Path};\n+        use std::path::Path;\n \n         let url = url_from_abs_path(Path::new(\"C:\\\\Test\").try_into().unwrap());\n         assert_eq!(url.to_string(), \"file:///c:/Test\");"}, {"sha": "8f7b3fb600879eeaa35dad0b6be2fc1ef67b3206", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/operators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Foperators.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -111,10 +111,10 @@ impl fmt::Display for BinaryOp {\n             BinaryOp::ArithOp(op) => fmt::Display::fmt(op, f),\n             BinaryOp::CmpOp(op) => fmt::Display::fmt(op, f),\n             BinaryOp::Assignment { op } => {\n-                f.write_str(\"=\")?;\n                 if let Some(op) = op {\n                     fmt::Display::fmt(op, f)?;\n                 }\n+                f.write_str(\"=\")?;\n                 Ok(())\n             }\n         }"}, {"sha": "7c7a60d62994eeca97712716beef99b45146a6e2", "filename": "src/tools/rust-analyzer/crates/syntax/src/fuzz.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ffuzz.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -2,10 +2,7 @@\n //!\n //! We don't normally run fuzzying, so this is hopelessly bitrotten :(\n \n-use std::{\n-    convert::TryInto,\n-    str::{self, FromStr},\n-};\n+use std::str::{self, FromStr};\n \n use text_edit::Indel;\n "}, {"sha": "3ff4b6897a16b5f73a3fb47ae0b4dde77440abc2", "filename": "src/tools/rust-analyzer/editors/code/package-lock.json", "status": "modified", "additions": 3962, "deletions": 12, "changes": 3974, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage-lock.json?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b"}, {"sha": "27ab31db8db4fc668b91953bae3d45cca59dc6e2", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -105,6 +105,22 @@ export async function createClient(\n         traceOutputChannel: traceOutputChannel(),\n         outputChannel: outputChannel(),\n         middleware: {\n+            async handleDiagnostics(uri, diagnostics, next) {\n+                // Workaround for https://github.com/microsoft/vscode/issues/155531\n+                for (const diagnostic of diagnostics) {\n+                    if (!diagnostic.message) {\n+                        diagnostic.message = \" \";\n+                    }\n+                    if (diagnostic.relatedInformation) {\n+                        for (const relatedInformation of diagnostic.relatedInformation) {\n+                            if (!relatedInformation.message) {\n+                                relatedInformation.message = \" \";\n+                            }\n+                        }\n+                    }\n+                }\n+                next(uri, diagnostics);\n+            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,"}, {"sha": "1b793bb0b15c87af9f2d28fc210bf24c6b3c3eea", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -326,8 +326,22 @@ export function toggleInlayHints(_ctx: Ctx): Cmd {\n         const config = vscode.workspace.getConfiguration(\"editor.inlayHints\", {\n             languageId: \"rust\",\n         });\n-        const value = !config.get(\"enabled\");\n-        await config.update(\"enabled\", value, vscode.ConfigurationTarget.Global);\n+\n+        const value = config.get(\"enabled\");\n+        let stringValue;\n+        if (typeof value === \"string\") {\n+            stringValue = value;\n+        } else {\n+            stringValue = value ? \"on\" : \"off\";\n+        }\n+        const nextValues: Record<string, string> = {\n+            on: \"off\",\n+            off: \"on\",\n+            onUnlessPressed: \"offUnlessPressed\",\n+            offUnlessPressed: \"onUnlessPressed\",\n+        };\n+        const nextValue = nextValues[stringValue] ?? \"on\";\n+        await config.update(\"enabled\", nextValue, vscode.ConfigurationTarget.Global);\n     };\n }\n "}, {"sha": "50e8d06b66049795bedc69b320bad4be62d7a811", "filename": "src/tools/rust-analyzer/lib/la-arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06da98f2187d0b71317492b635cd2f43a2fc64b/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs?ref=a06da98f2187d0b71317492b635cd2f43a2fc64b", "patch": "@@ -6,7 +6,6 @@\n use std::{\n     fmt,\n     hash::{Hash, Hasher},\n-    iter::FromIterator,\n     marker::PhantomData,\n     ops::{Index, IndexMut, Range, RangeInclusive},\n };"}]}