{"sha": "3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMDA0YzZkZjhmMjVlMWYxMjAyNzljMWU5ZTliMWI2ZTM4ODEwZTA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-08T05:53:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:21Z"}, "message": "making brson's req. cleanups in #2134 plus change printf to LOG in c++", "tree": {"sha": "7666d22d817b17cf0ea62c1f1efb4232e9b39235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7666d22d817b17cf0ea62c1f1efb4232e9b39235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "html_url": "https://github.com/rust-lang/rust/commit/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53f5c0c623726d39ae5f880fb3781ac48b313f9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/53f5c0c623726d39ae5f880fb3781ac48b313f9c", "html_url": "https://github.com/rust-lang/rust/commit/53f5c0c623726d39ae5f880fb3781ac48b313f9c"}], "stats": {"total": 1168, "additions": 591, "deletions": 577}, "files": [{"sha": "f5bf7fb85d28f79a518d4cdce21df1861062ccc0", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 563, "deletions": 561, "changes": 1124, "blob_url": "https://github.com/rust-lang/rust/blob/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "patch": "@@ -620,634 +620,636 @@ crust fn process_close_timer(\n     process_close_common(id, data);\n }\n \n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_uv_new_loop_no_handles() {\n+        let test_loop = uv::loop_new();\n+        uv::run(test_loop); // this should return immediately\n+                        // since there aren't any handles..\n+        uv::loop_delete(test_loop);\n+    }\n \n-#[test]\n-fn test_uv_new_loop_no_handles() {\n-    let test_loop = uv::loop_new();\n-    uv::run(test_loop); // this should return immediately\n-                    // since there aren't any handles..\n-    uv::loop_delete(test_loop);\n-}\n-\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_simple_async() {\n-    let test_loop = uv::loop_new();\n-    let exit_port = comm::port::<bool>();\n-    let exit_chan = comm::chan::<bool>(exit_port);\n-    uv::async_init(test_loop, {|new_async|\n-        uv::close(new_async) {||\n-            comm::send(exit_chan, true);\n-        };\n-    }, {|new_async|\n-        uv::async_send(new_async);\n-    });\n-    uv::run(test_loop);\n-    let result = comm::recv(exit_port);\n-    assert result;\n-    uv::loop_delete(test_loop);\n-}\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_simple_async() {\n+        let test_loop = uv::loop_new();\n+        let exit_port = comm::port::<bool>();\n+        let exit_chan = comm::chan::<bool>(exit_port);\n+        uv::async_init(test_loop, {|new_async|\n+            uv::close(new_async) {||\n+                comm::send(exit_chan, true);\n+            };\n+        }, {|new_async|\n+            uv::async_send(new_async);\n+        });\n+        uv::run(test_loop);\n+        let result = comm::recv(exit_port);\n+        assert result;\n+        uv::loop_delete(test_loop);\n+    }\n \n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_timer() {\n-    let test_loop = uv::loop_new();\n-    let exit_port = comm::port::<bool>();\n-    let exit_chan = comm::chan::<bool>(exit_port);\n-    uv::timer_init(test_loop) {|new_timer|\n-        uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n-            uv::timer_stop(started_timer) {|stopped_timer|\n-                uv::close(stopped_timer) {||\n-                    comm::send(exit_chan, true);\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_timer() {\n+        let test_loop = uv::loop_new();\n+        let exit_port = comm::port::<bool>();\n+        let exit_chan = comm::chan::<bool>(exit_port);\n+        uv::timer_init(test_loop) {|new_timer|\n+            uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n+                uv::timer_stop(started_timer) {|stopped_timer|\n+                    uv::close(stopped_timer) {||\n+                        comm::send(exit_chan, true);\n+                    };\n                 };\n             };\n         };\n-    };\n-    uv::run(test_loop);\n-    assert comm::recv(exit_port);\n-    uv::loop_delete(test_loop);\n-}\n-\n-enum tcp_read_data {\n-    tcp_read_eof,\n-    tcp_read_more([u8]),\n-    tcp_read_error\n-}\n-\n-type request_wrapper = {\n-    write_req: *ll::uv_write_t,\n-    req_buf: *[ll::uv_buf_t],\n-    read_chan: *comm::chan<str>\n-};\n+        uv::run(test_loop);\n+        assert comm::recv(exit_port);\n+        uv::loop_delete(test_loop);\n+    }\n \n-crust fn after_close_cb(handle: *libc::c_void) {\n-    log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n-                    handle));\n-}\n+    enum tcp_read_data {\n+        tcp_read_eof,\n+        tcp_read_more([u8]),\n+        tcp_read_error\n+    }\n \n-crust fn on_alloc_cb(handle: *libc::c_void,\n-                     ++suggested_size: libc::size_t)\n-    -> ll::uv_buf_t unsafe {\n-    log(debug, \"on_alloc_cb!\");\n-    let char_ptr = ll::malloc_buf_base_of(suggested_size);\n-    log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n-                     handle,\n-                     char_ptr as uint,\n-                     suggested_size as uint));\n-    ret ll::buf_init(char_ptr, suggested_size);\n-}\n+    type request_wrapper = {\n+        write_req: *ll::uv_write_t,\n+        req_buf: *[ll::uv_buf_t],\n+        read_chan: *comm::chan<str>\n+    };\n \n-crust fn on_read_cb(stream: *ll::uv_stream_t,\n-                    nread: libc::ssize_t,\n-                    ++buf: ll::uv_buf_t) unsafe {\n-    log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n-    if (nread > 0) {\n-        // we have data\n-        log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n-        ll::read_stop(stream);\n-        let client_data = ll::\n-            get_data_for_uv_handle(stream as *libc::c_void)\n-              as *request_wrapper;\n-        let buf_base = ll::get_base_from_buf(buf);\n-        let buf_len = ll::get_len_from_buf(buf);\n-        let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-        let read_chan = *((*client_data).read_chan);\n-        let msg_from_server = str::from_bytes(bytes);\n-        comm::send(read_chan, msg_from_server);\n-        ll::close(stream as *libc::c_void, after_close_cb)\n+    crust fn after_close_cb(handle: *libc::c_void) {\n+        log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n+                        handle));\n     }\n-    else if (nread == -1) {\n-        // err .. possibly EOF\n-        log(debug, \"read: eof!\");\n-    }\n-    else {\n-        // nread == 0 .. do nothing, just free buf as below\n-        log(debug, \"read: do nothing!\");\n-    }\n-    // when we're done\n-    ll::free_base_of_buf(buf);\n-    log(debug, \"CLIENT exiting on_read_cb\");\n-}\n \n-crust fn on_write_complete_cb(write_req: *ll::uv_write_t,\n-                              status: libc::c_int) unsafe {\n-    log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n-                     status as int));\n-    let stream = ll::get_stream_handle_from_write_req(write_req);\n-    log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-        stream as int, write_req as int));\n-    let result = ll::read_start(stream, on_alloc_cb, on_read_cb);\n-    log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                     result as int));\n-}\n+    crust fn on_alloc_cb(handle: *libc::c_void,\n+                         ++suggested_size: libc::size_t)\n+        -> ll::uv_buf_t unsafe {\n+        log(debug, \"on_alloc_cb!\");\n+        let char_ptr = ll::malloc_buf_base_of(suggested_size);\n+        log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                         handle,\n+                         char_ptr as uint,\n+                         suggested_size as uint));\n+        ret ll::buf_init(char_ptr, suggested_size);\n+    }\n \n-crust fn on_connect_cb(connect_req_ptr: *ll::uv_connect_t,\n-                             status: libc::c_int) unsafe {\n-    log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n-                     status as int));\n-    let stream =\n-        ll::get_stream_handle_from_connect_req(connect_req_ptr);\n-    if (status == 0i32) {\n-        log(debug, \"on_connect_cb: in status=0 if..\");\n-        let client_data = ll::get_data_for_req(\n-            connect_req_ptr as *libc::c_void)\n-            as *request_wrapper;\n-        let write_handle = (*client_data).write_req as *libc::c_void;\n-        log(debug, #fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n-                        stream as int, write_handle as int));\n-        let write_result = ll::write(write_handle,\n-                          stream as *libc::c_void,\n-                          (*client_data).req_buf,\n-                          on_write_complete_cb);\n-        log(debug, #fmt(\"on_connect_cb: ll::write() status: %d\",\n-                         write_result as int));\n+    crust fn on_read_cb(stream: *ll::uv_stream_t,\n+                        nread: libc::ssize_t,\n+                        ++buf: ll::uv_buf_t) unsafe {\n+        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\", nread));\n+        if (nread > 0) {\n+            // we have data\n+            log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n+            ll::read_stop(stream);\n+            let client_data = ll::\n+                get_data_for_uv_handle(stream as *libc::c_void)\n+                  as *request_wrapper;\n+            let buf_base = ll::get_base_from_buf(buf);\n+            let buf_len = ll::get_len_from_buf(buf);\n+            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let read_chan = *((*client_data).read_chan);\n+            let msg_from_server = str::from_bytes(bytes);\n+            comm::send(read_chan, msg_from_server);\n+            ll::close(stream as *libc::c_void, after_close_cb)\n+        }\n+        else if (nread == -1) {\n+            // err .. possibly EOF\n+            log(debug, \"read: eof!\");\n+        }\n+        else {\n+            // nread == 0 .. do nothing, just free buf as below\n+            log(debug, \"read: do nothing!\");\n+        }\n+        // when we're done\n+        ll::free_base_of_buf(buf);\n+        log(debug, \"CLIENT exiting on_read_cb\");\n     }\n-    else {\n-        let test_loop = ll::get_loop_for_uv_handle(\n-            stream as *libc::c_void);\n-        let err_msg = ll::get_last_err_info(test_loop);\n-        log(debug, err_msg);\n-        assert false;\n+\n+    crust fn on_write_complete_cb(write_req: *ll::uv_write_t,\n+                                  status: libc::c_int) unsafe {\n+        log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n+                         status as int));\n+        let stream = ll::get_stream_handle_from_write_req(write_req);\n+        log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+            stream as int, write_req as int));\n+        let result = ll::read_start(stream, on_alloc_cb, on_read_cb);\n+        log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n+                         result as int));\n     }\n-    log(debug, \"finishing on_connect_cb\");\n-}\n \n-fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n-                      client_chan: *comm::chan<str>) unsafe {\n-    let test_loop = ll::loop_new();\n-    let tcp_handle = ll::tcp_t();\n-    let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n-    let connect_handle = ll::connect_t();\n-    let connect_req_ptr = ptr::addr_of(connect_handle);\n-\n-    // this is the persistent payload of data that we\n-    // need to pass around to get this example to work.\n-    // In C, this would be a malloc'd or stack-allocated\n-    // struct that we'd cast to a void* and store as the\n-    // data field in our uv_connect_t struct\n-    let req_str_bytes = str::bytes(req_str);\n-    let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n-    log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n-    let req_msg = [\n-        ll::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n-    ];\n-    // this is the enclosing record, we'll pass a ptr to\n-    // this to C..\n-    let write_handle = ll::write_t();\n-    let write_handle_ptr = ptr::addr_of(write_handle);\n-    log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n-                     tcp_handle_ptr as int,\n-                     write_handle_ptr as int));\n-    let client_data = { writer_handle: write_handle_ptr,\n-                req_buf: ptr::addr_of(req_msg),\n-                read_chan: client_chan };\n-\n-    let tcp_init_result = ll::tcp_init(\n-        test_loop as *libc::c_void, tcp_handle_ptr);\n-    if (tcp_init_result == 0i32) {\n-        log(debug, \"sucessful tcp_init_result\");\n-\n-        log(debug, \"building addr...\");\n-        let addr = ll::ip4_addr(ip, port);\n-        // FIXME ref #2064\n-        let addr_ptr = ptr::addr_of(addr);\n-        log(debug, #fmt(\"after build addr in rust. port: %u\",\n-                         addr.sin_port as uint));\n-\n-        // this should set up the connection request..\n-        log(debug, #fmt(\"before calling tcp_connect .. connect cb ptr: %u \",\n-                        on_connect_cb as uint));\n-        let tcp_connect_result = ll::tcp_connect(\n-            connect_req_ptr, tcp_handle_ptr,\n-            addr_ptr, on_connect_cb);\n-        if (tcp_connect_result == 0i32) {\n-            // not set the data on the connect_req\n-            // until its initialized\n-            ll::set_data_for_req(\n-                connect_req_ptr as *libc::c_void,\n-                ptr::addr_of(client_data) as *libc::c_void);\n-            ll::set_data_for_uv_handle(\n-                tcp_handle_ptr as *libc::c_void,\n-                ptr::addr_of(client_data) as *libc::c_void);\n-            log(debug, \"before run tcp req loop\");\n-            ll::run(test_loop);\n-            log(debug, \"after run tcp req loop\");\n+    crust fn on_connect_cb(connect_req_ptr: *ll::uv_connect_t,\n+                                 status: libc::c_int) unsafe {\n+        log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n+                         status as int));\n+        let stream =\n+            ll::get_stream_handle_from_connect_req(connect_req_ptr);\n+        if (status == 0i32) {\n+            log(debug, \"on_connect_cb: in status=0 if..\");\n+            let client_data = ll::get_data_for_req(\n+                connect_req_ptr as *libc::c_void)\n+                as *request_wrapper;\n+            let write_handle = (*client_data).write_req as *libc::c_void;\n+            log(debug, #fmt(\"on_connect_cb: tcp: %d write_hdl: %d\",\n+                            stream as int, write_handle as int));\n+            let write_result = ll::write(write_handle,\n+                              stream as *libc::c_void,\n+                              (*client_data).req_buf,\n+                              on_write_complete_cb);\n+            log(debug, #fmt(\"on_connect_cb: ll::write() status: %d\",\n+                             write_result as int));\n         }\n         else {\n-           log(debug, \"ll::tcp_connect() failure\");\n-           assert false;\n+            let test_loop = ll::get_loop_for_uv_handle(\n+                stream as *libc::c_void);\n+            let err_msg = ll::get_last_err_info(test_loop);\n+            log(debug, err_msg);\n+            assert false;\n         }\n+        log(debug, \"finishing on_connect_cb\");\n     }\n-    else {\n-        log(debug, \"ll::tcp_init() failure\");\n-        assert false;\n-    }\n-    ll::loop_delete(test_loop);\n \n-}\n+    fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n+                          client_chan: *comm::chan<str>) unsafe {\n+        let test_loop = ll::loop_new();\n+        let tcp_handle = ll::tcp_t();\n+        let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n+        let connect_handle = ll::connect_t();\n+        let connect_req_ptr = ptr::addr_of(connect_handle);\n+\n+        // this is the persistent payload of data that we\n+        // need to pass around to get this example to work.\n+        // In C, this would be a malloc'd or stack-allocated\n+        // struct that we'd cast to a void* and store as the\n+        // data field in our uv_connect_t struct\n+        let req_str_bytes = str::bytes(req_str);\n+        let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n+        log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n+        let req_msg = [\n+            ll::buf_init(req_msg_ptr, vec::len(req_str_bytes))\n+        ];\n+        // this is the enclosing record, we'll pass a ptr to\n+        // this to C..\n+        let write_handle = ll::write_t();\n+        let write_handle_ptr = ptr::addr_of(write_handle);\n+        log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n+                         tcp_handle_ptr as int,\n+                         write_handle_ptr as int));\n+        let client_data = { writer_handle: write_handle_ptr,\n+                    req_buf: ptr::addr_of(req_msg),\n+                    read_chan: client_chan };\n+\n+        let tcp_init_result = ll::tcp_init(\n+            test_loop as *libc::c_void, tcp_handle_ptr);\n+        if (tcp_init_result == 0i32) {\n+            log(debug, \"sucessful tcp_init_result\");\n+\n+            log(debug, \"building addr...\");\n+            let addr = ll::ip4_addr(ip, port);\n+            // FIXME ref #2064\n+            let addr_ptr = ptr::addr_of(addr);\n+            log(debug, #fmt(\"after build addr in rust. port: %u\",\n+                             addr.sin_port as uint));\n+\n+            // this should set up the connection request..\n+            log(debug, #fmt(\"b4 call tcp_connect connect cb: %u \",\n+                            on_connect_cb as uint));\n+            let tcp_connect_result = ll::tcp_connect(\n+                connect_req_ptr, tcp_handle_ptr,\n+                addr_ptr, on_connect_cb);\n+            if (tcp_connect_result == 0i32) {\n+                // not set the data on the connect_req\n+                // until its initialized\n+                ll::set_data_for_req(\n+                    connect_req_ptr as *libc::c_void,\n+                    ptr::addr_of(client_data) as *libc::c_void);\n+                ll::set_data_for_uv_handle(\n+                    tcp_handle_ptr as *libc::c_void,\n+                    ptr::addr_of(client_data) as *libc::c_void);\n+                log(debug, \"before run tcp req loop\");\n+                ll::run(test_loop);\n+                log(debug, \"after run tcp req loop\");\n+            }\n+            else {\n+               log(debug, \"ll::tcp_connect() failure\");\n+               assert false;\n+            }\n+        }\n+        else {\n+            log(debug, \"ll::tcp_init() failure\");\n+            assert false;\n+        }\n+        ll::loop_delete(test_loop);\n \n-crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-    log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n-               handle));\n-}\n+    }\n \n-crust fn client_stream_after_close_cb(handle: *libc::c_void)\n-    unsafe {\n-    log(debug, \"SERVER: closed client stream, now closing server stream\");\n-    let client_data = ll::get_data_for_uv_handle(\n-        handle) as\n-        *tcp_server_data;\n-    ll::close((*client_data).server as *libc::c_void,\n-                  server_after_close_cb);\n-}\n+    crust fn server_after_close_cb(handle: *libc::c_void) unsafe {\n+        log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n+                   handle));\n+    }\n \n-crust fn after_server_resp_write(req: *ll::uv_write_t) unsafe {\n-    let client_stream_ptr =\n-        ll::get_stream_handle_from_write_req(req);\n-    log(debug, \"SERVER: resp sent... closing client stream\");\n-    ll::close(client_stream_ptr as *libc::c_void,\n-                  client_stream_after_close_cb)\n-}\n+    crust fn client_stream_after_close_cb(handle: *libc::c_void)\n+        unsafe {\n+        log(debug, \"SERVER: closed client stream, now closing server stream\");\n+        let client_data = ll::get_data_for_uv_handle(\n+            handle) as\n+            *tcp_server_data;\n+        ll::close((*client_data).server as *libc::c_void,\n+                      server_after_close_cb);\n+    }\n \n-crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n-                           nread: libc::ssize_t,\n-                           ++buf: ll::uv_buf_t) unsafe {\n-    if (nread > 0) {\n-        // we have data\n-        log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n-\n-        // pull out the contents of the write from the client\n-        let buf_base = ll::get_base_from_buf(buf);\n-        let buf_len = ll::get_len_from_buf(buf);\n-        log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n-                         buf_base as uint,\n-                         buf_len as uint,\n-                         nread));\n-        let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n-        let request_str = str::from_bytes(bytes);\n+    crust fn after_server_resp_write(req: *ll::uv_write_t) unsafe {\n+        let client_stream_ptr =\n+            ll::get_stream_handle_from_write_req(req);\n+        log(debug, \"SERVER: resp sent... closing client stream\");\n+        ll::close(client_stream_ptr as *libc::c_void,\n+                      client_stream_after_close_cb)\n+    }\n \n-        let client_data = ll::get_data_for_uv_handle(\n-            client_stream_ptr as *libc::c_void) as *tcp_server_data;\n-\n-        let server_kill_msg = (*client_data).server_kill_msg;\n-        let write_req = (*client_data).server_write_req;\n-        if (str::contains(request_str, server_kill_msg)) {\n-            log(debug, \"SERVER: client request contains server_kill_msg!\");\n-            log(debug, \"SERVER: sending response to client\");\n-            ll::read_stop(client_stream_ptr);\n-            let server_chan = *((*client_data).server_chan);\n-            comm::send(server_chan, request_str);\n-            let write_result = ll::write(\n-                write_req as *libc::c_void,\n-                client_stream_ptr as *libc::c_void,\n-                (*client_data).server_resp_buf,\n-                after_server_resp_write);\n-            log(debug, #fmt(\"SERVER: resp write result: %d\",\n-                        write_result as int));\n-            if (write_result != 0i32) {\n-                log(debug, \"bad result for server resp ll::write()\");\n-                log(debug, ll::get_last_err_info(\n-                    ll::get_loop_for_uv_handle(client_stream_ptr\n-                        as *libc::c_void)));\n-                assert false;\n+    crust fn on_server_read_cb(client_stream_ptr: *ll::uv_stream_t,\n+                               nread: libc::ssize_t,\n+                               ++buf: ll::uv_buf_t) unsafe {\n+        if (nread > 0) {\n+            // we have data\n+            log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n+\n+            // pull out the contents of the write from the client\n+            let buf_base = ll::get_base_from_buf(buf);\n+            let buf_len = ll::get_len_from_buf(buf);\n+            log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n+                             buf_base as uint,\n+                             buf_len as uint,\n+                             nread));\n+            let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+            let request_str = str::from_bytes(bytes);\n+\n+            let client_data = ll::get_data_for_uv_handle(\n+                client_stream_ptr as *libc::c_void) as *tcp_server_data;\n+\n+            let server_kill_msg = (*client_data).server_kill_msg;\n+            let write_req = (*client_data).server_write_req;\n+            if (str::contains(request_str, server_kill_msg)) {\n+                log(debug, \"SERVER: client req contains kill_msg!\");\n+                log(debug, \"SERVER: sending response to client\");\n+                ll::read_stop(client_stream_ptr);\n+                let server_chan = *((*client_data).server_chan);\n+                comm::send(server_chan, request_str);\n+                let write_result = ll::write(\n+                    write_req as *libc::c_void,\n+                    client_stream_ptr as *libc::c_void,\n+                    (*client_data).server_resp_buf,\n+                    after_server_resp_write);\n+                log(debug, #fmt(\"SERVER: resp write result: %d\",\n+                            write_result as int));\n+                if (write_result != 0i32) {\n+                    log(debug, \"bad result for server resp ll::write()\");\n+                    log(debug, ll::get_last_err_info(\n+                        ll::get_loop_for_uv_handle(client_stream_ptr\n+                            as *libc::c_void)));\n+                    assert false;\n+                }\n+            }\n+            else {\n+                log(debug, \"SERVER: client req !contain kill_msg!\");\n             }\n         }\n+        else if (nread == -1) {\n+            // err .. possibly EOF\n+            log(debug, \"read: eof!\");\n+        }\n         else {\n-            log(debug, \"SERVER: client req DOESNT contain server_kill_msg!\");\n+            // nread == 0 .. do nothing, just free buf as below\n+            log(debug, \"read: do nothing!\");\n         }\n+        // when we're done\n+        ll::free_base_of_buf(buf);\n+        log(debug, \"SERVER exiting on_read_cb\");\n     }\n-    else if (nread == -1) {\n-        // err .. possibly EOF\n-        log(debug, \"read: eof!\");\n-    }\n-    else {\n-        // nread == 0 .. do nothing, just free buf as below\n-        log(debug, \"read: do nothing!\");\n-    }\n-    // when we're done\n-    ll::free_base_of_buf(buf);\n-    log(debug, \"SERVER exiting on_read_cb\");\n-}\n \n-crust fn server_connection_cb(server_stream_ptr:\n-                                *ll::uv_stream_t,\n-                              status: libc::c_int) unsafe {\n-    log(debug, \"client connecting!\");\n-    let test_loop = ll::get_loop_for_uv_handle(\n-                           server_stream_ptr as *libc::c_void);\n-    if status != 0i32 {\n-        let err_msg = ll::get_last_err_info(test_loop);\n-        log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n-                     err_msg));\n-        ret;\n-    }\n-    let server_data = ll::get_data_for_uv_handle(\n-        server_stream_ptr as *libc::c_void) as *tcp_server_data;\n-    let client_stream_ptr = (*server_data).client;\n-    let client_init_result = ll::tcp_init(test_loop,\n-                                              client_stream_ptr);\n-    ll::set_data_for_uv_handle(\n-        client_stream_ptr as *libc::c_void,\n-        server_data as *libc::c_void);\n-    if (client_init_result == 0i32) {\n-        log(debug, \"successfully initialized client stream\");\n-        let accept_result = ll::accept(server_stream_ptr as\n-                                             *libc::c_void,\n-                                           client_stream_ptr as\n-                                             *libc::c_void);\n-        if (accept_result == 0i32) {\n-            // start reading\n-            let read_result = ll::read_start(\n-                client_stream_ptr as *ll::uv_stream_t,\n-                                                 on_alloc_cb,\n-                                                 on_server_read_cb);\n-            if (read_result == 0i32) {\n-                log(debug, \"successful server read start\");\n+    crust fn server_connection_cb(server_stream_ptr:\n+                                    *ll::uv_stream_t,\n+                                  status: libc::c_int) unsafe {\n+        log(debug, \"client connecting!\");\n+        let test_loop = ll::get_loop_for_uv_handle(\n+                               server_stream_ptr as *libc::c_void);\n+        if status != 0i32 {\n+            let err_msg = ll::get_last_err_info(test_loop);\n+            log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n+                         err_msg));\n+            ret;\n+        }\n+        let server_data = ll::get_data_for_uv_handle(\n+            server_stream_ptr as *libc::c_void) as *tcp_server_data;\n+        let client_stream_ptr = (*server_data).client;\n+        let client_init_result = ll::tcp_init(test_loop,\n+                                                  client_stream_ptr);\n+        ll::set_data_for_uv_handle(\n+            client_stream_ptr as *libc::c_void,\n+            server_data as *libc::c_void);\n+        if (client_init_result == 0i32) {\n+            log(debug, \"successfully initialized client stream\");\n+            let accept_result = ll::accept(server_stream_ptr as\n+                                                 *libc::c_void,\n+                                               client_stream_ptr as\n+                                                 *libc::c_void);\n+            if (accept_result == 0i32) {\n+                // start reading\n+                let read_result = ll::read_start(\n+                    client_stream_ptr as *ll::uv_stream_t,\n+                                                     on_alloc_cb,\n+                                                     on_server_read_cb);\n+                if (read_result == 0i32) {\n+                    log(debug, \"successful server read start\");\n+                }\n+                else {\n+                    log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n+                                    read_result as int));\n+                    assert false;\n+                }\n             }\n             else {\n-                log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n-                                read_result as int));\n+                log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n+                            accept_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n-                        accept_result as int));\n+            log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n+                        client_init_result as int));\n             assert false;\n         }\n     }\n-    else {\n-        log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n-                    client_init_result as int));\n-        assert false;\n-    }\n-}\n \n-type tcp_server_data = {\n-    client: *ll::uv_tcp_t,\n-    server: *ll::uv_tcp_t,\n-    server_kill_msg: str,\n-    server_resp_buf: *[ll::uv_buf_t],\n-    server_chan: *comm::chan<str>,\n-    server_write_req: *ll::uv_write_t\n-};\n+    type tcp_server_data = {\n+        client: *ll::uv_tcp_t,\n+        server: *ll::uv_tcp_t,\n+        server_kill_msg: str,\n+        server_resp_buf: *[ll::uv_buf_t],\n+        server_chan: *comm::chan<str>,\n+        server_write_req: *ll::uv_write_t\n+    };\n \n-type async_handle_data = {\n-    continue_chan: *comm::chan<bool>\n-};\n+    type async_handle_data = {\n+        continue_chan: *comm::chan<bool>\n+    };\n \n-crust fn async_close_cb(handle: *libc::c_void) {\n-    log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n-               handle));\n-}\n+    crust fn async_close_cb(handle: *libc::c_void) {\n+        log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n+                   handle));\n+    }\n \n-crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n-                           status: libc::c_int) unsafe {\n-    // once we're in the body of this callback,\n-    // the tcp server's loop is set up, so we\n-    // can continue on to let the tcp client\n-    // do its thang\n-    let data = ll::get_data_for_uv_handle(\n-        async_handle as *libc::c_void) as *async_handle_data;\n-    let continue_chan = *((*data).continue_chan);\n-    let should_continue = status == 0i32;\n-    comm::send(continue_chan, should_continue);\n-    ll::close(async_handle as *libc::c_void, async_close_cb);\n-}\n+    crust fn continue_async_cb(async_handle: *ll::uv_async_t,\n+                               status: libc::c_int) unsafe {\n+        // once we're in the body of this callback,\n+        // the tcp server's loop is set up, so we\n+        // can continue on to let the tcp client\n+        // do its thang\n+        let data = ll::get_data_for_uv_handle(\n+            async_handle as *libc::c_void) as *async_handle_data;\n+        let continue_chan = *((*data).continue_chan);\n+        let should_continue = status == 0i32;\n+        comm::send(continue_chan, should_continue);\n+        ll::close(async_handle as *libc::c_void, async_close_cb);\n+    }\n \n-fn impl_uv_tcp_server(server_ip: str,\n-                      server_port: int,\n-                      kill_server_msg: str,\n-                      server_resp_msg: str,\n-                      server_chan: *comm::chan<str>,\n-                      continue_chan: *comm::chan<bool>) unsafe {\n-    let test_loop = ll::loop_new();\n-    let tcp_server = ll::tcp_t();\n-    let tcp_server_ptr = ptr::addr_of(tcp_server);\n-\n-    let tcp_client = ll::tcp_t();\n-    let tcp_client_ptr = ptr::addr_of(tcp_client);\n-\n-    let server_write_req = ll::write_t();\n-    let server_write_req_ptr = ptr::addr_of(server_write_req);\n-\n-    let resp_str_bytes = str::bytes(server_resp_msg);\n-    let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n-    log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n-    let resp_msg = [\n-        ll::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n-    ];\n-\n-    let continue_async_handle = ll::async_t();\n-    let continue_async_handle_ptr =\n-        ptr::addr_of(continue_async_handle);\n-    let async_data =\n-        { continue_chan: continue_chan };\n-    let async_data_ptr = ptr::addr_of(async_data);\n-\n-    let server_data: tcp_server_data = {\n-        client: tcp_client_ptr,\n-        server: tcp_server_ptr,\n-        server_kill_msg: kill_server_msg,\n-        server_resp_buf: ptr::addr_of(resp_msg),\n-        server_chan: server_chan,\n-        server_write_req: server_write_req_ptr\n-    };\n-    let server_data_ptr = ptr::addr_of(server_data);\n-    ll::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n-                                   server_data_ptr as *libc::c_void);\n-\n-    // uv_tcp_init()\n-    let tcp_init_result = ll::tcp_init(\n-        test_loop as *libc::c_void, tcp_server_ptr);\n-    if (tcp_init_result == 0i32) {\n-        let server_addr = ll::ip4_addr(server_ip, server_port);\n-        // FIXME ref #2064\n-        let server_addr_ptr = ptr::addr_of(server_addr);\n-\n-        // uv_tcp_bind()\n-        let bind_result = ll::tcp_bind(tcp_server_ptr,\n-                                           server_addr_ptr);\n-        if (bind_result == 0i32) {\n-            log(debug, \"successful uv_tcp_bind, listening\");\n-\n-            // uv_listen()\n-            let listen_result = ll::listen(tcp_server_ptr as\n-                                                 *libc::c_void,\n-                                               128i32,\n-                                               server_connection_cb);\n-            if (listen_result == 0i32) {\n-                // let the test know it can set up the tcp server,\n-                // now.. this may still present a race, not sure..\n-                let async_result = ll::async_init(test_loop,\n-                                   continue_async_handle_ptr,\n-                                   continue_async_cb);\n-                if (async_result == 0i32) {\n-                    ll::set_data_for_uv_handle(\n-                        continue_async_handle_ptr as *libc::c_void,\n-                        async_data_ptr as *libc::c_void);\n-                    ll::async_send(continue_async_handle_ptr);\n-                    // uv_run()\n-                    ll::run(test_loop);\n-                    log(debug, \"server uv::run() has returned\");\n+    fn impl_uv_tcp_server(server_ip: str,\n+                          server_port: int,\n+                          kill_server_msg: str,\n+                          server_resp_msg: str,\n+                          server_chan: *comm::chan<str>,\n+                          continue_chan: *comm::chan<bool>) unsafe {\n+        let test_loop = ll::loop_new();\n+        let tcp_server = ll::tcp_t();\n+        let tcp_server_ptr = ptr::addr_of(tcp_server);\n+\n+        let tcp_client = ll::tcp_t();\n+        let tcp_client_ptr = ptr::addr_of(tcp_client);\n+\n+        let server_write_req = ll::write_t();\n+        let server_write_req_ptr = ptr::addr_of(server_write_req);\n+\n+        let resp_str_bytes = str::bytes(server_resp_msg);\n+        let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n+        log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n+        let resp_msg = [\n+            ll::buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+        ];\n+\n+        let continue_async_handle = ll::async_t();\n+        let continue_async_handle_ptr =\n+            ptr::addr_of(continue_async_handle);\n+        let async_data =\n+            { continue_chan: continue_chan };\n+        let async_data_ptr = ptr::addr_of(async_data);\n+\n+        let server_data: tcp_server_data = {\n+            client: tcp_client_ptr,\n+            server: tcp_server_ptr,\n+            server_kill_msg: kill_server_msg,\n+            server_resp_buf: ptr::addr_of(resp_msg),\n+            server_chan: server_chan,\n+            server_write_req: server_write_req_ptr\n+        };\n+        let server_data_ptr = ptr::addr_of(server_data);\n+        ll::set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n+                                       server_data_ptr as *libc::c_void);\n+\n+        // uv_tcp_init()\n+        let tcp_init_result = ll::tcp_init(\n+            test_loop as *libc::c_void, tcp_server_ptr);\n+        if (tcp_init_result == 0i32) {\n+            let server_addr = ll::ip4_addr(server_ip, server_port);\n+            // FIXME ref #2064\n+            let server_addr_ptr = ptr::addr_of(server_addr);\n+\n+            // uv_tcp_bind()\n+            let bind_result = ll::tcp_bind(tcp_server_ptr,\n+                                               server_addr_ptr);\n+            if (bind_result == 0i32) {\n+                log(debug, \"successful uv_tcp_bind, listening\");\n+\n+                // uv_listen()\n+                let listen_result = ll::listen(tcp_server_ptr as\n+                                                     *libc::c_void,\n+                                                   128i32,\n+                                                   server_connection_cb);\n+                if (listen_result == 0i32) {\n+                    // let the test know it can set up the tcp server,\n+                    // now.. this may still present a race, not sure..\n+                    let async_result = ll::async_init(test_loop,\n+                                       continue_async_handle_ptr,\n+                                       continue_async_cb);\n+                    if (async_result == 0i32) {\n+                        ll::set_data_for_uv_handle(\n+                            continue_async_handle_ptr as *libc::c_void,\n+                            async_data_ptr as *libc::c_void);\n+                        ll::async_send(continue_async_handle_ptr);\n+                        // uv_run()\n+                        ll::run(test_loop);\n+                        log(debug, \"server uv::run() has returned\");\n+                    }\n+                    else {\n+                        log(debug, #fmt(\"uv_async_init failure: %d\",\n+                                async_result as int));\n+                        assert false;\n+                    }\n                 }\n                 else {\n-                    log(debug, #fmt(\"uv_async_init failure: %d\",\n-                            async_result as int));\n+                    log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n+                                listen_result as int));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n-                            listen_result as int));\n+                log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n+                            bind_result as int));\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n-                        bind_result as int));\n+            log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n+                        tcp_init_result as int));\n             assert false;\n         }\n+        ll::loop_delete(test_loop);\n     }\n-    else {\n-        log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n-                    tcp_init_result as int));\n-        assert false;\n-    }\n-    ll::loop_delete(test_loop);\n-}\n-\n-// this is the impl for a test that is (maybe) ran on a\n-// per-platform/arch basis below\n-fn impl_uv_tcp_server_and_request() unsafe {\n-    let bind_ip = \"0.0.0.0\";\n-    let request_ip = \"127.0.0.1\";\n-    let port = 8888;\n-    let kill_server_msg = \"does a dog have buddha nature?\";\n-    let server_resp_msg = \"mu!\";\n-    let client_port = comm::port::<str>();\n-    let client_chan = comm::chan::<str>(client_port);\n-    let server_port = comm::port::<str>();\n-    let server_chan = comm::chan::<str>(server_port);\n-\n-    let continue_port = comm::port::<bool>();\n-    let continue_chan = comm::chan::<bool>(continue_port);\n-    let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n-    task::spawn_sched(task::manual_threads(1u)) {||\n-        impl_uv_tcp_server(bind_ip, port,\n-                           kill_server_msg,\n-                           server_resp_msg,\n-                           ptr::addr_of(server_chan),\n-                           continue_chan_ptr);\n-    };\n+    // this is the impl for a test that is (maybe) ran on a\n+    // per-platform/arch basis below\n+    fn impl_uv_tcp_server_and_request() unsafe {\n+        let bind_ip = \"0.0.0.0\";\n+        let request_ip = \"127.0.0.1\";\n+        let port = 8888;\n+        let kill_server_msg = \"does a dog have buddha nature?\";\n+        let server_resp_msg = \"mu!\";\n+        let client_port = comm::port::<str>();\n+        let client_chan = comm::chan::<str>(client_port);\n+        let server_port = comm::port::<str>();\n+        let server_chan = comm::chan::<str>(server_port);\n+\n+        let continue_port = comm::port::<bool>();\n+        let continue_chan = comm::chan::<bool>(continue_port);\n+        let continue_chan_ptr = ptr::addr_of(continue_chan);\n+\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            impl_uv_tcp_server(bind_ip, port,\n+                               kill_server_msg,\n+                               server_resp_msg,\n+                               ptr::addr_of(server_chan),\n+                               continue_chan_ptr);\n+        };\n \n-    // block until the server up is.. possibly a race?\n-    log(debug, \"before receiving on server continue_port\");\n-    comm::recv(continue_port);\n-    log(debug, \"received on continue port, set up tcp client\");\n+        // block until the server up is.. possibly a race?\n+        log(debug, \"before receiving on server continue_port\");\n+        comm::recv(continue_port);\n+        log(debug, \"received on continue port, set up tcp client\");\n \n-    task::spawn_sched(task::manual_threads(1u)) {||\n-        impl_uv_tcp_request(request_ip, port,\n-                           kill_server_msg,\n-                           ptr::addr_of(client_chan));\n-    };\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            impl_uv_tcp_request(request_ip, port,\n+                               kill_server_msg,\n+                               ptr::addr_of(client_chan));\n+        };\n \n-    let msg_from_client = comm::recv(server_port);\n-    let msg_from_server = comm::recv(client_port);\n+        let msg_from_client = comm::recv(server_port);\n+        let msg_from_server = comm::recv(client_port);\n \n-    assert str::contains(msg_from_client, kill_server_msg);\n-    assert str::contains(msg_from_server, server_resp_msg);\n-}\n+        assert str::contains(msg_from_client, kill_server_msg);\n+        assert str::contains(msg_from_server, server_resp_msg);\n+    }\n \n-// don't run this test on fbsd or 32bit linux\n-#[cfg(target_os=\"win32\")]\n-#[cfg(target_os=\"darwin\")]\n-#[cfg(target_os=\"linux\")]\n-mod tcp_and_server_client_test {\n-    #[cfg(target_arch=\"x86_64\")]\n-    mod impl64 {\n-        #[test]\n-        fn test_uv_tcp_server_and_request() unsafe {\n-            impl_uv_tcp_server_and_request();\n+    // don't run this test on fbsd or 32bit linux\n+    #[cfg(target_os=\"win32\")]\n+    #[cfg(target_os=\"darwin\")]\n+    #[cfg(target_os=\"linux\")]\n+    mod tcp_and_server_client_test {\n+        #[cfg(target_arch=\"x86_64\")]\n+        mod impl64 {\n+            #[test]\n+            fn test_uv_tcp_server_and_request() unsafe {\n+                impl_uv_tcp_server_and_request();\n+            }\n         }\n-    }\n-    #[cfg(target_arch=\"x86\")]\n-    mod impl32 {\n-        #[test]\n-        #[ignore(cfg(target_os = \"linux\"))]\n-        fn test_uv_tcp_server_and_request() unsafe {\n-            impl_uv_tcp_server_and_request();\n+        #[cfg(target_arch=\"x86\")]\n+        mod impl32 {\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_uv_tcp_server_and_request() unsafe {\n+                impl_uv_tcp_server_and_request();\n+            }\n         }\n     }\n-}\n \n-// struct size tests\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_uv_tcp_t() {\n-    let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n-    let rust_handle_size = sys::size_of::<ll::uv_tcp_t>();\n-    let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_uv_connect_t() {\n-    let native_handle_size =\n-        rustrt::rust_uv_helper_uv_connect_t_size();\n-    let rust_handle_size = sys::size_of::<ll::uv_connect_t>();\n-    let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_uv_buf_t() {\n-    let native_handle_size =\n-        rustrt::rust_uv_helper_uv_buf_t_size();\n-    let rust_handle_size = sys::size_of::<ll::uv_buf_t>();\n-    let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_uv_write_t() {\n-    let native_handle_size =\n-        rustrt::rust_uv_helper_uv_write_t_size();\n-    let rust_handle_size = sys::size_of::<ll::uv_write_t>();\n-    let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n+    // struct size tests\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_uv_tcp_t() {\n+        let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n+        let rust_handle_size = sys::size_of::<ll::uv_tcp_t>();\n+        let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_uv_connect_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_connect_t_size();\n+        let rust_handle_size = sys::size_of::<ll::uv_connect_t>();\n+        let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_uv_buf_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_buf_t_size();\n+        let rust_handle_size = sys::size_of::<ll::uv_buf_t>();\n+        let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_uv_write_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_write_t_size();\n+        let rust_handle_size = sys::size_of::<ll::uv_write_t>();\n+        let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n \n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_sockaddr_in() {\n-    let native_handle_size =\n-        rustrt::rust_uv_helper_sockaddr_in_size();\n-    let rust_handle_size = sys::size_of::<ll::sockaddr_in>();\n-    let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_sockaddr_in() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_sockaddr_in_size();\n+        let rust_handle_size = sys::size_of::<ll::sockaddr_in>();\n+        let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n \n-#[test]\n-#[ignore(cfg(target_os = \"freebsd\"))]\n-fn test_uv_struct_size_uv_async_t() {\n-    let native_handle_size =\n-        rustrt::rust_uv_helper_uv_async_t_size();\n-    let rust_handle_size = sys::size_of::<ll::uv_async_t>();\n-    let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n-                      native_handle_size as uint, rust_handle_size);\n-    log(debug, output);\n-    assert native_handle_size as uint == rust_handle_size;\n-}\n+    #[test]\n+    #[ignore(cfg(target_os = \"freebsd\"))]\n+    fn test_uv_struct_size_uv_async_t() {\n+        let native_handle_size =\n+            rustrt::rust_uv_helper_uv_async_t_size();\n+        let rust_handle_size = sys::size_of::<ll::uv_async_t>();\n+        let output = #fmt(\"uv_async_t -- native: %u rust: %u\",\n+                          native_handle_size as uint, rust_handle_size);\n+        log(debug, output);\n+        assert native_handle_size as uint == rust_handle_size;\n+    }\n \n+}"}, {"sha": "765f3df992df5710b14d662b0df9dec7ce8dcfde", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "patch": "@@ -14,7 +14,7 @@ export interact, prepare_loop;\n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \n-# Fields\n+# Arguments\n \n * async_handle - a pointer to a uv_async_t struct used to 'poke'\n the C uv loop to process any pending callbacks\n@@ -30,7 +30,7 @@ type high_level_loop = {\n #[doc = \"\n Pass in a callback to be processed on the running libuv loop's thread\n \n-# Fields\n+# Arguments\n \n * a_loop - a high_level_loop record that represents a channel of\n communication with an active libuv loop running on a thread\n@@ -59,14 +59,14 @@ After this is ran against a loop, a library developer can run\n the loop in its own thread and then use the returned\n `high_level_loop` to interact with it.\n \n-# Fields\n+# Arguments\n \n * loop_ptr - a pointer to a newly created `uv_loop_t*` with no\n handles registered (this will interfere with the internal lifecycle\n management this module provides). Ideally, this should be called\n immediately after using `uv::ll::loop_new()`\n \n-# Returns\n+# Return\n \n A `high_level_loop` record that can be used to interact with the\n loop (after you use `uv::ll::run()` on the `uv_loop_t*`, of course"}, {"sha": "fc104c59248bafe85d3f421d2b7dcd2937f05532", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d004c6df8f25e1f120279c1e9e9b1b6e38810e0/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3d004c6df8f25e1f120279c1e9e9b1b6e38810e0", "patch": "@@ -5,6 +5,7 @@\n \n #include \"rust_globals.h\"\n #include \"rust_task.h\"\n+#include \"rust_log.h\"\n #include \"uv.h\"\n \n // crust fn pointers\n@@ -221,23 +222,29 @@ rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n         uv_tcp_t* tcp_ptr,\n         uv_connect_cb cb,\n         sockaddr_in* addr_ptr) {\n-    printf(\"inside rust_uv_tcp_connect\\n\");\n+    rust_task* task = rust_get_current_task();\n+    LOG(task, stdlib, \"inside rust_uv_tcp_connect\\n\");\n     // FIXME ref #2064\n     sockaddr_in addr = *addr_ptr;\n-    printf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n-    printf(\"before tcp_connect.. tcp stream: %lu cb ptr: %lu\\n\",\n-            (unsigned long int)tcp_ptr, (unsigned long int)cb);\n+    LOG(task, stdlib, \"before tcp_connect .. port: %d\\n\",\n+        addr.sin_port);\n+    LOG(task, stdlib, \"before tcp_connect.. tcp stream:\" \\\n+        \"%lu cb ptr: %lu\\n\",\n+        (unsigned long int)tcp_ptr, (unsigned long int)cb);\n     int result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n-    printf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\",\n+    LOG(task, stdlib, \"leaving rust_uv_tcp_connect..\" \\\n+        \"and result: %d\\n\",\n             result);\n     return result;\n }\n \n extern \"C\" int\n rust_uv_tcp_bind(uv_tcp_t* tcp_server, sockaddr_in* addr_ptr) {\n     // FIXME ref #2064\n+    rust_task* task = rust_get_current_task();\n     sockaddr_in addr = *addr_ptr;\n-    printf(\"before uv_tcp_bind .. tcp_server: %lu port: %d\\n\",\n+    LOG(task, stdlib, \"before uv_tcp_bind .. tcp_server:\" \\\n+        \"%lu port: %d\\n\",\n             (unsigned long int)tcp_server, addr.sin_port);\n     return uv_tcp_bind(tcp_server, addr);\n }\n@@ -302,11 +309,14 @@ current_kernel_malloc_alloc_cb(uv_handle_t* handle,\n \n extern \"C\" void\n rust_uv_buf_init(uv_buf_t* out_buf, char* base, size_t len) {\n-    printf(\"rust_uv_buf_init: base: %lu len: %lu\\n\",\n-        (long unsigned int)base,\n-        (long unsigned int)len);\n+    rust_task* task = rust_get_current_task();\n+    LOG(task, stdlib,\"rust_uv_buf_init: base: %lu\" \\\n+        \"len: %lu\\n\",\n+        (unsigned long int)base,\n+        (unsigned long int)len);\n     *out_buf = uv_buf_init(base, len);\n-    printf(\"rust_uv_buf_init: after: result->base: %lu len: %lu\\n\",\n+    LOG(task, stdlib, \"rust_uv_buf_init: after: \"\n+        \"result->base: %\" PRIxPTR \" len: %\\n\" PRIxPTR,\n            (unsigned long int)(*out_buf).base,\n            (unsigned long int)(*out_buf).len);\n }\n@@ -393,8 +403,10 @@ rust_uv_free_base_of_buf(uv_buf_t buf) {\n \n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n-    printf(\"before creating addr_ptr.. ip %s port %d\\n\", ip, port);\n+    rust_task* task = rust_get_current_task();\n+    LOG(task, stdlib, \"before creating addr_ptr.. ip %s\" \\\n+        \"port %d\\n\", ip, port);\n     struct sockaddr_in addr = uv_ip4_addr(ip, port);\n-    printf(\"after creating .. port: %d\\n\", addr.sin_port);\n+    LOG(task, stdlib, \"after creating .. port: %d\\n\", addr.sin_port);\n     return addr;\n }"}]}