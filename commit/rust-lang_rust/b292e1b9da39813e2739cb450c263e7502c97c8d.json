{"sha": "b292e1b9da39813e2739cb450c263e7502c97c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOTJlMWI5ZGEzOTgxM2UyNzM5Y2I0NTBjMjYzZTc1MDJjOTdjOGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:44:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:44:31Z"}, "message": "internal: refactor missing match arms diagnostics", "tree": {"sha": "92a09f547c7d7ca41f90ebdc68f0f81ac1805560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92a09f547c7d7ca41f90ebdc68f0f81ac1805560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b292e1b9da39813e2739cb450c263e7502c97c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b292e1b9da39813e2739cb450c263e7502c97c8d", "html_url": "https://github.com/rust-lang/rust/commit/b292e1b9da39813e2739cb450c263e7502c97c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b292e1b9da39813e2739cb450c263e7502c97c8d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "url": "https://api.github.com/repos/rust-lang/rust/commits/3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "html_url": "https://github.com/rust-lang/rust/commit/3478897f86cc1b3e3f83e9d4e7cedff41721fb04"}], "stats": {"total": 1865, "additions": 935, "deletions": 930}, "files": [{"sha": "5cffef47f1ba7b872befe91434a280be51df5709", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=b292e1b9da39813e2739cb450c263e7502c97c8d", "patch": "@@ -38,6 +38,7 @@ diagnostics![\n     MacroError,\n     MismatchedArgCount,\n     MissingFields,\n+    MissingMatchArms,\n     MissingOkOrSomeInTailExpr,\n     MissingUnsafe,\n     NoSuchField,\n@@ -149,31 +150,13 @@ pub struct MissingOkOrSomeInTailExpr {\n     pub required: String,\n }\n \n-// Diagnostic: missing-match-arm\n-//\n-// This diagnostic is triggered if `match` block is missing one or more match arms.\n #[derive(Debug)]\n pub struct MissingMatchArms {\n     pub file: HirFileId,\n     pub match_expr: AstPtr<ast::Expr>,\n     pub arms: AstPtr<ast::MatchArmList>,\n }\n \n-impl Diagnostic for MissingMatchArms {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-match-arm\")\n-    }\n-    fn message(&self) -> String {\n-        String::from(\"Missing match arm\")\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.match_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct InternalBailedOut {\n     pub file: HirFileId,"}, {"sha": "2e794ff4aa9161094b178b643a0e61c969ca6f0e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b292e1b9da39813e2739cb450c263e7502c97c8d", "patch": "@@ -1209,11 +1209,14 @@ impl Function {\n                                 if let (Some(match_expr), Some(arms)) =\n                                     (match_expr.expr(), match_expr.match_arm_list())\n                                 {\n-                                    sink.push(MissingMatchArms {\n-                                        file: source_ptr.file_id,\n-                                        match_expr: AstPtr::new(&match_expr),\n-                                        arms: AstPtr::new(&arms),\n-                                    })\n+                                    acc.push(\n+                                        MissingMatchArms {\n+                                            file: source_ptr.file_id,\n+                                            match_expr: AstPtr::new(&match_expr),\n+                                            arms: AstPtr::new(&arms),\n+                                        }\n+                                        .into(),\n+                                    )\n                                 }\n                             }\n                         }"}, {"sha": "01b68232e7034e908e4856a42d09cfd087f73425", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 907, "changes": 909, "blob_url": "https://github.com/rust-lang/rust/blob/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=b292e1b9da39813e2739cb450c263e7502c97c8d", "patch": "@@ -10,6 +10,7 @@ mod incorrect_case;\n mod macro_error;\n mod mismatched_arg_count;\n mod missing_fields;\n+mod missing_match_arms;\n mod missing_ok_or_some_in_tail_expr;\n mod missing_unsafe;\n mod no_such_field;\n@@ -205,6 +206,7 @@ pub(crate) fn diagnostics(\n             AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::MissingMatchArms(d) => missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n@@ -545,910 +547,3 @@ pub struct Claims {\n         );\n     }\n }\n-\n-#[cfg(test)]\n-pub(super) mod match_check_tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match () { }\n-        //^^ Missing match arm\n-    match (()) { }\n-        //^^^^ Missing match arm\n-\n-    match () { _ => (), }\n-    match () { () => (), }\n-    match (()) { (()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match ((), ()) { }\n-        //^^^^^^^^ Missing match arm\n-\n-    match ((), ()) { ((), ()) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn boolean() {\n-        check_diagnostics(\n-            r#\"\n-fn test_main() {\n-    match false { }\n-        //^^^^^ Missing match arm\n-    match false { true => (), }\n-        //^^^^^ Missing match arm\n-    match (false, true) {}\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) { (true, true) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-    match (false, true) {\n-        //^^^^^^^^^^^^^ Missing match arm\n-        (false, true) => (),\n-        (false, false) => (),\n-        (true, false) => (),\n-    }\n-    match (false, true) { (true, _x) => (), }\n-        //^^^^^^^^^^^^^ Missing match arm\n-\n-    match false { true => (), false => (), }\n-    match (false, true) {\n-        (false, _) => (),\n-        (true, false) => (),\n-        (_, true) => (),\n-    }\n-    match (false, true) {\n-        (true, true) => (),\n-        (true, false) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true) {\n-        (true, _x) => (),\n-        (false, true) => (),\n-        (false, false) => (),\n-    }\n-    match (false, true, false) {\n-        (false, ..) => (),\n-        (true, ..) => (),\n-    }\n-    match (false, true, false) {\n-        (.., false) => (),\n-        (.., true) => (),\n-    }\n-    match (false, true, false) { (..) => (), }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, ((), false)) {}\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, ((), true)) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-    match (false, ((), false)) { (true, _) => (), }\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, ((), true)) => (),\n-        (false, ((), false)) => (),\n-    }\n-    match (false, ((), false)) {\n-        (true, ((), true)) => (),\n-        (true, ((), false)) => (),\n-        (false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enums() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B, }\n-\n-fn main() {\n-    match Either::A { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B { Either::A => (), }\n-        //^^^^^^^^^ Missing match arm\n-\n-    match &Either::B {\n-        //^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-\n-    match Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-    match &Either::B {\n-        Either::A => (), Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_containing_bool() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B }\n-\n-fn main() {\n-    match Either::B { }\n-        //^^^^^^^^^ Missing match arm\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true) => (), Either::B => ()\n-    }\n-\n-    match Either::B {\n-        Either::A(true) => (),\n-        Either::A(false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::B => (),\n-        _ => (),\n-    }\n-    match Either::B {\n-        Either::A(_) => (),\n-        Either::B => (),\n-    }\n-\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_different_sizes() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-\n-fn main() {\n-    match Either::A(false) {\n-        //^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A(_) => (),\n-        Either::B(false, _) => (),\n-    }\n-\n-    match Either::A(false) {\n-        Either::A(_) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-    match Either::A(false) {\n-        Either::A(true) | Either::A(false) => (),\n-        Either::B(true, _) => (),\n-        Either::B(false, _) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_enum_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A(bool), B(bool, bool) }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match (Either::A(false), Either2::C) {\n-        (Either::A(true), _) | (Either::A(false), _) => (),\n-        (Either::B(true, _), Either2::C) => (),\n-        (Either::B(false, _), Either2::C) => (),\n-        (Either::B(_, _), Either2::D) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn or_pattern_no_diagnostic() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {A, B}\n-\n-fn main() {\n-    match (Either::A, Either::B) {\n-        (Either::A | Either::B, _) => (),\n-    }\n-}\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-enum Either2 { C, D }\n-\n-fn main() {\n-    match Either::A {\n-        Either2::C => (),\n-    //  ^^^^^^^^^^ Internal: match check bailed out\n-        Either2::D => (),\n-    }\n-    match (true, false) {\n-        (true, false, true) => (),\n-    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n-        (true) => (),\n-    }\n-    match (true, false) { (true,) => {} }\n-    //                    ^^^^^^^ Internal: match check bailed out\n-    match (0) { () => () }\n-            //  ^^ Internal: match check bailed out\n-    match Unresolved::Bar { Unresolved::Baz => () }\n-}\n-        \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types_in_or_patterns() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match false { true | () => {} }\n-    //            ^^^^^^^^^ Internal: match check bailed out\n-    match (false,) { (true | (),) => {} }\n-    //               ^^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_tuple_enum_missing_pattern() {\n-        // We are testing to be sure we don't panic here when the match\n-        // arm `Either::B` is missing its pattern.\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B(u32) }\n-\n-fn main() {\n-    match Either::A {\n-        Either::A => (),\n-        Either::B() => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn malformed_match_arm_extra_fields() {\n-        check_diagnostics(\n-            r#\"\n-enum A { B(isize, isize), C }\n-fn main() {\n-    match A::B(1, 2) {\n-        A::B(_, _, _) => (),\n-    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match A::B(1, 2) {\n-        A::C(_) => (),\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A, B }\n-\n-fn main() {\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-        Either::B => (),\n-    }\n-    match loop {} {\n-        Either::A => (),\n-    //  ^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match loop { break Foo::A } {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Either::A => (),\n-    }\n-    match loop { break Foo::A } {\n-        Either::A => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_partially_diverges() {\n-        check_diagnostics(\n-            r#\"\n-enum Either<T> { A(T), B }\n-\n-fn foo() -> Either<!> { Either::B }\n-fn main() -> u32 {\n-    match foo() {\n-        Either::A(val) => val,\n-        Either::B => 0,\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record() {\n-        check_diagnostics(\n-            r#\"\n-enum Either { A { foo: bool }, B }\n-\n-fn main() {\n-    let a = Either::A { foo: true };\n-    match a { }\n-        //^ Missing match arm\n-    match a { Either::A { foo: true } => () }\n-        //^ Missing match arm\n-    match a {\n-        Either::A { } => (),\n-      //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { } => (),\n-    } //^^^^^^^^^ Missing structure fields:\n-      //        | - foo\n-\n-    match a {\n-        Either::A { foo: true } => (),\n-        Either::A { foo: false } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        Either::A { foo: _ } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: () },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::A { foo: true, bar: () };\n-    match a {\n-        //^ Missing match arm\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-    }\n-\n-    match a {\n-        Either::A { bar: (), foo: false } => (),\n-        Either::A { foo: true, bar: () } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_record_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A { foo: bool, bar: bool },\n-    B,\n-}\n-\n-fn main() {\n-    let a = Either::B;\n-    match a {\n-        //^ Missing match arm\n-        Either::A { foo: true, .. } => (),\n-        Either::B => (),\n-    }\n-    match a {\n-        //^ Missing match arm\n-        Either::A { .. } => (),\n-    }\n-\n-    match a {\n-        Either::A { foo: true, .. } => (),\n-        Either::A { foo: false, .. } => (),\n-        Either::B => (),\n-    }\n-\n-    match a {\n-        Either::A { .. } => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis() {\n-        check_diagnostics(\n-            r#\"\n-enum Either {\n-    A(bool, bool, bool, bool),\n-    B,\n-}\n-\n-fn main() {\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::B => (),\n-    }\n-\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(false, .., true) => (),\n-        Either::A(false, .., false) => (),\n-        Either::B => (),\n-    }\n-    match Either::B {\n-        Either::A(true, .., true) => (),\n-        Either::A(true, .., false) => (),\n-        Either::A(.., true) => (),\n-        Either::A(.., false) => (),\n-        Either::B => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn never() {\n-        check_diagnostics(\n-            r#\"\n-enum Never {}\n-\n-fn enum_(never: Never) {\n-    match never {}\n-}\n-fn enum_ref(never: &Never) {\n-    match never {}\n-        //^^^^^ Missing match arm\n-}\n-fn bang(never: !) {\n-    match never {}\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unknown_type() {\n-        check_diagnostics(\n-            r#\"\n-enum Option<T> { Some(T), None }\n-\n-fn main() {\n-    // `Never` is deliberately not defined so that it's an uninferred type.\n-    match Option::<Never>::None {\n-        None => (),\n-        Some(never) => match never {},\n-    //  ^^^^^^^^^^^ Internal: match check bailed out\n-    }\n-    match Option::<Never>::None {\n-        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        Option::Some(_never) => {},\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (false, ..) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (.., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match (false, true, false) {\n-        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n-        (true, .., false) => (),\n-    }\n-}\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo { a: bool }\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo { a: true } => () }\n-        //^ Missing match arm\n-    match &f { Foo { a: true } => () }\n-        //^^ Missing match arm\n-    match f { Foo { a: _ } => () }\n-    match f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-    match &f {\n-        Foo { a: true } => (),\n-        Foo { a: false } => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo(bool);\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo(true) => () }\n-        //^ Missing match arm\n-    match f {\n-        Foo(true) => (),\n-        Foo(false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unit_struct() {\n-        check_diagnostics(\n-            r#\"struct Foo;\n-fn main(f: Foo) {\n-    match f {}\n-        //^ Missing match arm\n-    match f { Foo => () }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_ellipsis() {\n-        check_diagnostics(\n-            r#\"struct Foo { foo: bool, bar: bool }\n-fn main(f: Foo) {\n-    match f { Foo { foo: true, .. } => () }\n-        //^ Missing match arm\n-    match f {\n-        //^ Missing match arm\n-        Foo { foo: true, .. } => (),\n-        Foo { bar: false, .. } => ()\n-    }\n-    match f { Foo { .. } => () }\n-    match f {\n-        Foo { foo: true, .. } => (),\n-        Foo { foo: false, .. } => ()\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn internal_or() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    enum Either { A(bool), B }\n-    match Either::B {\n-        //^^^^^^^^^ Missing match arm\n-        Either::A(true | false) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_panic_at_unimplemented_subpattern_type() {\n-        check_diagnostics(\n-            r#\"\n-struct S { a: char}\n-fn main(v: S) {\n-    match v { S{ a }      => {} }\n-    match v { S{ a: _x }  => {} }\n-    match v { S{ a: 'a' } => {} }\n-            //^^^^^^^^^^^ Internal: match check bailed out\n-    match v { S{..}       => {} }\n-    match v { _           => {} }\n-    match v { }\n-        //^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        _x @ true => {}\n-        false     => {}\n-    }\n-    match true { _x @ true => {} }\n-        //^^^^ Missing match arm\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn binding_ref_has_correct_type() {\n-        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n-        // If that's not true match checking will panic with \"incompatible constructors\"\n-        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n-        check_diagnostics(\n-            r#\"\n-enum Foo { A }\n-fn main() {\n-    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n-    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n-    match Foo::A {\n-        ref _x => {}\n-    //  ^^^^^^ Internal: match check bailed out\n-        Foo::A => {}\n-    }\n-    match (true,) {\n-        (ref _x,) => {}\n-        (true,) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_non_exhaustive() {\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:lib\n-#[non_exhaustive]\n-pub enum E { A, B }\n-fn _local() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        E::A | E::B => {}\n-    }\n-}\n-\n-//- /main.rs crate:main deps:lib\n-use lib::E;\n-fn main() {\n-    match E::A { _ => {} }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A => {}\n-        E::B => {}\n-    }\n-    match E::A {\n-        //^^^^ Missing match arm\n-        E::A | E::B => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_guard() {\n-        check_diagnostics(\n-            r#\"\n-fn main() {\n-    match true {\n-        true if false => {}\n-        true          => {}\n-        false         => {}\n-    }\n-    match true {\n-        //^^^^ Missing match arm\n-        true if false => {}\n-        false         => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn pattern_type_is_of_substitution() {\n-        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n-        check_diagnostics(\n-            r#\"\n-struct Foo<T>(T);\n-struct Bar;\n-fn main() {\n-    match Foo(Bar) {\n-        _ | Foo(Bar) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn record_struct_no_such_field() {\n-        check_diagnostics(\n-            r#\"\n-struct Foo { }\n-fn main(f: Foo) {\n-    match f { Foo { bar } => () }\n-    //        ^^^^^^^^^^^ Internal: match check bailed out\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn match_ergonomics_issue_9095() {\n-        check_diagnostics(\n-            r#\"\n-enum Foo<T> { A(T) }\n-fn main() {\n-    match &Foo::A(true) {\n-        _ => {}\n-        Foo::A(_) => {}\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    mod false_negatives {\n-        //! The implementation of match checking here is a work in progress. As we roll this out, we\n-        //! prefer false negatives to false positives (ideally there would be no false positives). This\n-        //! test module should document known false negatives. Eventually we will have a complete\n-        //! implementation of match checking and this module will be empty.\n-        //!\n-        //! The reasons for documenting known false negatives:\n-        //!\n-        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n-        //!   2. It ensures the code doesn't panic when handling these cases.\n-        use super::*;\n-\n-        #[test]\n-        fn integers() {\n-            // We don't currently check integer exhaustiveness.\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match 5 {\n-        10 => (),\n-    //  ^^ Internal: match check bailed out\n-        11..20 => (),\n-    }\n-}\n-\"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_at_top_level() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match &false {\n-        &true => {}\n-    //  ^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-\n-        #[test]\n-        fn reference_patterns_in_fields() {\n-            check_diagnostics(\n-                r#\"\n-fn main() {\n-    match (&false,) {\n-        (true,) => {}\n-    //  ^^^^^^^ Internal: match check bailed out\n-    }\n-    match (&false,) {\n-        (&true,) => {}\n-    //  ^^^^^^^^ Internal: match check bailed out\n-    }\n-}\n-            \"#,\n-            );\n-        }\n-    }\n-}"}, {"sha": "6b977fa59b61be9e9a0c9e6618c0eafd6fe9cb2c", "filename": "crates/ide/src/diagnostics/missing_match_arms.rs", "status": "added", "additions": 924, "deletions": 0, "changes": 924, "blob_url": "https://github.com/rust-lang/rust/blob/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b292e1b9da39813e2739cb450c263e7502c97c8d/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_match_arms.rs?ref=b292e1b9da39813e2739cb450c263e7502c97c8d", "patch": "@@ -0,0 +1,924 @@\n+use hir::InFile;\n+\n+use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-match-arm\n+//\n+// This diagnostic is triggered if `match` block is missing one or more match arms.\n+pub(super) fn missing_match_arms(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::MissingMatchArms,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"missing-match-arm\",\n+        \"missing match arm\",\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.match_expr.clone().into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+pub(super) mod tests {\n+    use crate::diagnostics::tests::check_diagnostics;\n+\n+    #[test]\n+    fn empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ missing match arm\n+    match (()) { }\n+        //^^^^ missing match arm\n+\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ missing match arm\n+\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ missing match arm\n+    match false { true => (), }\n+        //^^^^^ missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n+    }\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enums() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B, }\n+\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ missing match arm\n+\n+    match &Either::B {\n+        //^^^^^^^^^^ missing match arm\n+        Either::A => (),\n+    }\n+\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n+\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true) => (), Either::B => ()\n+    }\n+\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n+    }\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n+    }\n+\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n+    }\n+\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_no_diagnostic() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {A, B}\n+\n+fn main() {\n+    match (Either::A, Either::B) {\n+        (Either::A | Either::B, _) => (),\n+    }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn mismatched_types() {\n+        // Match statements with arms that don't match the\n+        // expression pattern do not fire this diagnostic.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+    //  ^^^^^^^^^^ Internal: match check bailed out\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n+        (true) => (),\n+    }\n+    match (true, false) { (true,) => {} }\n+    //                    ^^^^^^^ Internal: match check bailed out\n+    match (0) { () => () }\n+            //  ^^ Internal: match check bailed out\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mismatched_types_in_or_patterns() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match false { true | () => {} }\n+    //            ^^^^^^^^^ Internal: match check bailed out\n+    match (false,) { (true | (),) => {} }\n+    //               ^^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_tuple_enum_missing_pattern() {\n+        // We are testing to be sure we don't panic here when the match\n+        // arm `Either::B` is missing its pattern.\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n+\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn malformed_match_arm_extra_fields() {\n+        check_diagnostics(\n+            r#\"\n+enum A { B(isize, isize), C }\n+fn main() {\n+    match A::B(1, 2) {\n+        A::B(_, _, _) => (),\n+    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match A::B(1, 2) {\n+        A::C(_) => (),\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn expr_partially_diverges() {\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n+\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n+\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ missing match arm\n+    match a {\n+        Either::A { } => (),\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ missing match arm\n+        Either::A { } => (),\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n+\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+    }\n+\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n+\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n+    }\n+    match a {\n+        //^ missing match arm\n+        Either::A { .. } => (),\n+    }\n+\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n+    }\n+\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n+\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n+\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+        //^^^^^ missing match arm\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    //  ^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match Option::<Never>::None {\n+        //^^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        Option::Some(_never) => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (false, ..) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (.., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_ellipsis_in_middle_missing_arm() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, true, false) {\n+        //^^^^^^^^^^^^^^^^^^^^ missing match arm\n+        (true, .., false) => (),\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo { a: true } => () }\n+        //^ missing match arm\n+    match &f { Foo { a: true } => () }\n+        //^^ missing match arm\n+    match f { Foo { a: _ } => () }\n+    match f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+    match &f {\n+        Foo { a: true } => (),\n+        Foo { a: false } => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo(bool);\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo(true) => () }\n+        //^ missing match arm\n+    match f {\n+        Foo(true) => (),\n+        Foo(false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unit_struct() {\n+        check_diagnostics(\n+            r#\"struct Foo;\n+fn main(f: Foo) {\n+    match f {}\n+        //^ missing match arm\n+    match f { Foo => () }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_ellipsis() {\n+        check_diagnostics(\n+            r#\"struct Foo { foo: bool, bar: bool }\n+fn main(f: Foo) {\n+    match f { Foo { foo: true, .. } => () }\n+        //^ missing match arm\n+    match f {\n+        //^ missing match arm\n+        Foo { foo: true, .. } => (),\n+        Foo { bar: false, .. } => ()\n+    }\n+    match f { Foo { .. } => () }\n+    match f {\n+        Foo { foo: true, .. } => (),\n+        Foo { foo: false, .. } => ()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn internal_or() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        //^^^^^^^^^ missing match arm\n+        Either::A(true | false) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_panic_at_unimplemented_subpattern_type() {\n+        check_diagnostics(\n+            r#\"\n+struct S { a: char}\n+fn main(v: S) {\n+    match v { S{ a }      => {} }\n+    match v { S{ a: _x }  => {} }\n+    match v { S{ a: 'a' } => {} }\n+            //^^^^^^^^^^^ Internal: match check bailed out\n+    match v { S{..}       => {} }\n+    match v { _           => {} }\n+    match v { }\n+        //^ missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        _x @ true => {}\n+        false     => {}\n+    }\n+    match true { _x @ true => {} }\n+        //^^^^ missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding_ref_has_correct_type() {\n+        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n+        // If that's not true match checking will panic with \"incompatible constructors\"\n+        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n+        check_diagnostics(\n+            r#\"\n+enum Foo { A }\n+fn main() {\n+    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    match Foo::A {\n+        ref _x => {}\n+    //  ^^^^^^ Internal: match check bailed out\n+        Foo::A => {}\n+    }\n+    match (true,) {\n+        (ref _x,) => {}\n+        (true,) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_non_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib\n+#[non_exhaustive]\n+pub enum E { A, B }\n+fn _local() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        E::A | E::B => {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:lib\n+use lib::E;\n+fn main() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        //^^^^ missing match arm\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        //^^^^ missing match arm\n+        E::A | E::B => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        true if false => {}\n+        true          => {}\n+        false         => {}\n+    }\n+    match true {\n+        //^^^^ missing match arm\n+        true if false => {}\n+        false         => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn pattern_type_is_of_substitution() {\n+        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n+        check_diagnostics(\n+            r#\"\n+struct Foo<T>(T);\n+struct Bar;\n+fn main() {\n+    match Foo(Bar) {\n+        _ | Foo(Bar) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_no_such_field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { }\n+fn main(f: Foo) {\n+    match f { Foo { bar } => () }\n+    //        ^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_ergonomics_issue_9095() {\n+        check_diagnostics(\n+            r#\"\n+enum Foo<T> { A(T) }\n+fn main() {\n+    match &Foo::A(true) {\n+        _ => {}\n+        Foo::A(_) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    mod false_negatives {\n+        //! The implementation of match checking here is a work in progress. As we roll this out, we\n+        //! prefer false negatives to false positives (ideally there would be no false positives). This\n+        //! test module should document known false negatives. Eventually we will have a complete\n+        //! implementation of match checking and this module will be empty.\n+        //!\n+        //! The reasons for documenting known false negatives:\n+        //!\n+        //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+        //!   2. It ensures the code doesn't panic when handling these cases.\n+        use super::*;\n+\n+        #[test]\n+        fn integers() {\n+            // We don't currently check integer exhaustiveness.\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+    //  ^^ Internal: match check bailed out\n+        11..20 => (),\n+    }\n+}\n+\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_at_top_level() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match &false {\n+        &true => {}\n+    //  ^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_in_fields() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (&false,) {\n+        (true,) => {}\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+    match (&false,) {\n+        (&true,) => {}\n+    //  ^^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+    }\n+}"}]}