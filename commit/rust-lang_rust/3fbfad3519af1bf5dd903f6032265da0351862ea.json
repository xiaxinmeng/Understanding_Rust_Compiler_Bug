{"sha": "3fbfad3519af1bf5dd903f6032265da0351862ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYmZhZDM1MTlhZjFiZjVkZDkwM2Y2MDMyMjY1ZGEwMzUxODYyZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-30T15:32:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-30T15:32:27Z"}, "message": "Auto merge of #21604 - nikomatsakis:closure-move-indiv-vars, r=eddyb\n\nr? @eddyb", "tree": {"sha": "4a33ddb14eddc935e3ea84c4d8f7bf82ae3815b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a33ddb14eddc935e3ea84c4d8f7bf82ae3815b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fbfad3519af1bf5dd903f6032265da0351862ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbfad3519af1bf5dd903f6032265da0351862ea", "html_url": "https://github.com/rust-lang/rust/commit/3fbfad3519af1bf5dd903f6032265da0351862ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fbfad3519af1bf5dd903f6032265da0351862ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a51eb9cca3ae5f815825096de4dfbdc9267f735", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a51eb9cca3ae5f815825096de4dfbdc9267f735", "html_url": "https://github.com/rust-lang/rust/commit/1a51eb9cca3ae5f815825096de4dfbdc9267f735"}, {"sha": "ced10626de2906444fb73315449dc02eceb513cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ced10626de2906444fb73315449dc02eceb513cd", "html_url": "https://github.com/rust-lang/rust/commit/ced10626de2906444fb73315449dc02eceb513cd"}], "stats": {"total": 1124, "additions": 644, "deletions": 480}, "files": [{"sha": "8960667fdfa861481f82f4d721c9a6ff5ee9f925", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -70,6 +70,7 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n+#![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(core)]\n #![feature(hash)]"}, {"sha": "0b9b865c13700af59ada7f8cb5828fe4678f9c46", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -1183,6 +1183,7 @@ impl<F,A,R> FnOnce<A,R> for F\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n #[cfg(not(stage0))]\n+#[rustc_paren_sugar]\n pub trait Fn<Args> {\n     type Output;\n \n@@ -1195,6 +1196,7 @@ pub trait Fn<Args> {\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n #[cfg(not(stage0))]\n+#[rustc_paren_sugar]\n pub trait FnMut<Args> {\n     type Output;\n \n@@ -1207,6 +1209,7 @@ pub trait FnMut<Args> {\n #[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n #[cfg(not(stage0))]\n+#[rustc_paren_sugar]\n pub trait FnOnce<Args> {\n     type Output;\n "}, {"sha": "ee7c0ee894fc7b927200ca7744e81ab010c0f4a5", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -670,6 +670,7 @@ impl LintPass for UnusedAttributes {\n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\",\n             \"old_impl_check\",\n+            \"rustc_paren_sugar\", // FIXME: #18101 temporary unboxed closure hack\n         ];\n \n         static CRATE_ATTRS: &'static [&'static str] = &["}, {"sha": "242ab630a20ef424a8eaef8ebd506b9d12dc9da7", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -140,7 +140,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_moves_map = 0x52,\n     tag_table_capture_map = 0x53,\n     tag_table_closures = 0x54,\n-    tag_table_upvar_borrow_map = 0x55,\n+    tag_table_upvar_capture_map = 0x55,\n     tag_table_capture_modes = 0x56,\n     tag_table_object_cast_map = 0x57,\n }\n@@ -265,3 +265,5 @@ pub const tag_polarity: uint = 0xb4;\n pub const tag_macro_defs: uint = 0xb5;\n pub const tag_macro_def: uint = 0xb6;\n pub const tag_macro_def_body: uint = 0xb7;\n+\n+pub const tag_paren_sugar: uint = 0xb8;"}, {"sha": "93ca42e9a2872c41fb2d5b64ad946c39c49b8d8c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -371,6 +371,11 @@ fn parse_unsafety(item_doc: rbml::Doc) -> ast::Unsafety {\n     }\n }\n \n+fn parse_paren_sugar(item_doc: rbml::Doc) -> bool {\n+    let paren_sugar_doc = reader::get_doc(item_doc, tag_paren_sugar);\n+    reader::doc_as_u8(paren_sugar_doc) != 0\n+}\n+\n fn parse_polarity(item_doc: rbml::Doc) -> ast::ImplPolarity {\n     let polarity_doc = reader::get_doc(item_doc, tag_polarity);\n     if reader::doc_as_u8(polarity_doc) != 0 {\n@@ -400,8 +405,10 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     let bounds = trait_def_bounds(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n+    let paren_sugar = parse_paren_sugar(item_doc);\n \n     ty::TraitDef {\n+        paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: generics,\n         bounds: bounds,"}, {"sha": "6767f77de84bb61ed017a3b2874f6ed500be4209", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -1317,6 +1317,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_unsafety(rbml_w, trait_def.unsafety);\n+        encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_associated_type_names(rbml_w, trait_def.associated_type_names.as_slice());\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n@@ -1697,6 +1698,11 @@ fn encode_unsafety(rbml_w: &mut Encoder, unsafety: ast::Unsafety) {\n     rbml_w.wr_tagged_u8(tag_unsafety, byte);\n }\n \n+fn encode_paren_sugar(rbml_w: &mut Encoder, paren_sugar: bool) {\n+    let byte: u8 = if paren_sugar {1} else {0};\n+    rbml_w.wr_tagged_u8(tag_paren_sugar, byte);\n+}\n+\n fn encode_associated_type_names(rbml_w: &mut Encoder, names: &[ast::Name]) {\n     rbml_w.start_tag(tag_associated_type_names);\n     for &name in names.iter() {"}, {"sha": "902c029fef4bf3907e82dcb61a0f109b292c0ad1", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -518,10 +518,6 @@ fn encode_freevar_entry(rbml_w: &mut Encoder, fv: &ty::Freevar) {\n     (*fv).encode(rbml_w).unwrap();\n }\n \n-fn encode_capture_mode(rbml_w: &mut Encoder, cm: ast::CaptureClause) {\n-    cm.encode(rbml_w).unwrap();\n-}\n-\n trait rbml_decoder_helper {\n     fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> ty::Freevar;\n@@ -559,6 +555,15 @@ impl tr for ty::UpvarBorrow {\n     }\n }\n \n+impl tr for ty::UpvarCapture {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+        match *self {\n+            ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n+            ty::UpvarCapture::ByRef(ref data) => ty::UpvarCapture::ByRef(data.tr(dcx)),\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -1210,34 +1215,20 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         });\n \n         for freevar in fv.iter() {\n-            match tcx.capture_mode(id) {\n-                ast::CaptureByRef => {\n-                    rbml_w.tag(c::tag_table_upvar_borrow_map, |rbml_w| {\n-                        rbml_w.id(id);\n-                        rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                            let var_id = freevar.def.def_id().node;\n-                            let upvar_id = ty::UpvarId {\n-                                var_id: var_id,\n-                                closure_expr_id: id\n-                            };\n-                            let upvar_borrow = tcx.upvar_borrow_map.borrow()[upvar_id].clone();\n-                            var_id.encode(rbml_w);\n-                            upvar_borrow.encode(rbml_w);\n-                        })\n-                    })\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    for &cm in tcx.capture_modes.borrow().get(&id).iter() {\n-        rbml_w.tag(c::tag_table_capture_modes, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                encode_capture_mode(rbml_w, *cm);\n+            rbml_w.tag(c::tag_table_upvar_capture_map, |rbml_w| {\n+                rbml_w.id(id);\n+                rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                    let var_id = freevar.def.def_id().node;\n+                    let upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: id\n+                    };\n+                    let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                    var_id.encode(rbml_w);\n+                    upvar_capture.encode(rbml_w);\n+                })\n             })\n-        })\n+        }\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n@@ -1911,21 +1902,14 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         }).unwrap().into_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n-                    c::tag_table_upvar_borrow_map => {\n+                    c::tag_table_upvar_capture_map => {\n                         let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n                         let upvar_id = ty::UpvarId {\n                             var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n-                        let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n-                    }\n-                    c::tag_table_capture_modes => {\n-                        let capture_mode = val_dsr.read_capture_mode();\n-                        dcx.tcx\n-                           .capture_modes\n-                           .borrow_mut()\n-                           .insert(id, capture_mode);\n+                        let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n+                        dcx.tcx.upvar_capture_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);"}, {"sha": "9457a1a99f6d516bc12d4865de941459eef5e556", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -366,6 +366,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n+        debug!(\"delegate_consume(consume_id={}, cmt={})\",\n+               consume_id, cmt.repr(self.tcx()));\n+\n         let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n@@ -1208,53 +1211,32 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n         ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n-            match self.tcx().capture_mode(closure_expr.id) {\n-                ast::CaptureByRef => {\n-                    self.walk_by_ref_captures(closure_expr, freevars);\n-                }\n-                ast::CaptureByValue => {\n-                    self.walk_by_value_captures(closure_expr, freevars);\n+            for freevar in freevars.iter() {\n+                let id_var = freevar.def.def_id().node;\n+                let upvar_id = ty::UpvarId { var_id: id_var,\n+                                             closure_expr_id: closure_expr.id };\n+                let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+                let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n+                                                                   closure_expr.span,\n+                                                                   freevar.def));\n+                match upvar_capture {\n+                    ty::UpvarCapture::ByValue => {\n+                        let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n+                        self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n+                    }\n+                    ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                        self.delegate.borrow(closure_expr.id,\n+                                             closure_expr.span,\n+                                             cmt_var,\n+                                             upvar_borrow.region,\n+                                             upvar_borrow.kind,\n+                                             ClosureCapture(freevar.span));\n+                    }\n                 }\n             }\n         });\n     }\n \n-    fn walk_by_ref_captures(&mut self,\n-                            closure_expr: &ast::Expr,\n-                            freevars: &[ty::Freevar]) {\n-        for freevar in freevars.iter() {\n-            let id_var = freevar.def.def_id().node;\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-\n-            // Lookup the kind of borrow the callee requires, as\n-            // inferred by regionbk\n-            let upvar_id = ty::UpvarId { var_id: id_var,\n-                                         closure_expr_id: closure_expr.id };\n-            let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n-\n-            self.delegate.borrow(closure_expr.id,\n-                                 closure_expr.span,\n-                                 cmt_var,\n-                                 upvar_borrow.region,\n-                                 upvar_borrow.kind,\n-                                 ClosureCapture(freevar.span));\n-        }\n-    }\n-\n-    fn walk_by_value_captures(&mut self,\n-                              closure_expr: &ast::Expr,\n-                              freevars: &[ty::Freevar]) {\n-        for freevar in freevars.iter() {\n-            let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n-                                                               closure_expr.span,\n-                                                               freevar.def));\n-            let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n-            self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n-        }\n-    }\n-\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,"}, {"sha": "5fe5a4c7eb2cf7a4dbe38dda5e0af2fefa095095", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 115, "deletions": 120, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -277,9 +277,7 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<region::CodeExtent>;\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow>;\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause;\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture>;\n }\n \n impl MutabilityCategory {\n@@ -595,8 +593,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n               match ty.sty {\n                   ty::ty_closure(closure_id, _, _) => {\n                       let kind = self.typer.closure_kind(closure_id);\n-                      let mode = self.typer.capture_mode(fn_node_id);\n-                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode)\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug(\n@@ -628,10 +625,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n-                 kind: ty::ClosureKind,\n-                 mode: ast::CaptureClause)\n-                 -> McResult<cmt<'tcx>> {\n-        // An upvar can have up to 3 components.  The base is a\n+                 kind: ty::ClosureKind)\n+                 -> McResult<cmt<'tcx>>\n+    {\n+        // An upvar can have up to 3 components. We translate first to a\n+        // `cat_upvar`, which is itself a fiction -- it represents the reference to the\n+        // field from the environment.\n+        //\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n         // appropriate borrow kind for closure kinds that take self by\n@@ -650,135 +650,130 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n-        let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n+        let var_ty = try!(self.node_ty(var_id));\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // Construct information about env pointer dereference, if any\n-        let mutbl = match kind {\n-            ty::FnOnceClosureKind => None, // None, env is by-value\n-            ty::FnMutClosureKind => match mode { // Depends on capture type\n-                ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n-                ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n-            },\n-            ty::FnClosureKind => Some(McImmutable) // Never mutable\n+        // Construct the upvar. This represents access to the field\n+        // from the environment (perhaps we should eventually desugar\n+        // this field further, but it will do for now).\n+        let cmt_result = cmt_ {\n+            id: id,\n+            span: span,\n+            cat: cat_upvar(Upvar {id: upvar_id, kind: kind}),\n+            mutbl: var_mutbl,\n+            ty: var_ty,\n+            note: NoteNone\n         };\n-        let env_info = mutbl.map(|env_mutbl| {\n-            // Look up the node ID of the closure body so we can construct\n-            // a free region within it\n-            let fn_body_id = {\n-                let fn_expr = match self.tcx().map.find(fn_node_id) {\n-                    Some(ast_map::NodeExpr(e)) => e,\n-                    _ => unreachable!()\n-                };\n \n-                match fn_expr.node {\n-                    ast::ExprClosure(_, _, _, ref body) => body.id,\n-                    _ => unreachable!()\n-                }\n-            };\n-\n-            // Region of environment pointer\n-            let env_region = ty::ReFree(ty::FreeRegion {\n-                scope: region::CodeExtent::from_node_id(fn_body_id),\n-                bound_region: ty::BrEnv\n-            });\n-\n-            let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n-                ty::MutBorrow\n-            } else {\n-                ty::ImmBorrow\n-            }, env_region);\n-\n-            (env_mutbl, env_ptr)\n-        });\n+        // If this is a `FnMut` or `Fn` closure, then the above is\n+        // conceptually a `&mut` or `&` reference, so we have to add a\n+        // deref.\n+        let cmt_result = match kind {\n+            ty::FnOnceClosureKind => {\n+                cmt_result\n+            }\n+            ty::FnMutClosureKind => {\n+                self.env_deref(id, span, upvar_id, var_mutbl, ty::MutBorrow, cmt_result)\n+            }\n+            ty::FnClosureKind => {\n+                self.env_deref(id, span, upvar_id, var_mutbl, ty::ImmBorrow, cmt_result)\n+            }\n+        };\n \n-        // First, switch by capture mode\n-        Ok(match mode {\n-            ast::CaptureByValue => {\n-                let mut base = cmt_ {\n+        // If this is a by-ref capture, then the upvar we loaded is\n+        // actually a reference, so we have to add an implicit deref\n+        // for that.\n+        let upvar_id = ty::UpvarId { var_id: var_id,\n+                                     closure_expr_id: fn_node_id };\n+        let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+        let cmt_result = match upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n+                cmt_result\n+            }\n+            ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+                cmt_ {\n                     id: id,\n                     span: span,\n-                    cat: cat_upvar(Upvar {\n-                        id: upvar_id,\n-                        kind: kind\n-                    }),\n-                    mutbl: var_mutbl,\n+                    cat: cat_deref(Rc::new(cmt_result), 0, ptr),\n+                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n                     ty: var_ty,\n-                    note: NoteNone\n-                };\n-\n-                match env_info {\n-                    Some((env_mutbl, env_ptr)) => {\n-                        // We need to add the env deref.  This means\n-                        // that the above is actually immutable and\n-                        // has a ref type.  However, nothing should\n-                        // actually look at the type, so we can get\n-                        // away with stuffing a `ty_err` in there\n-                        // instead of bothering to construct a proper\n-                        // one.\n-                        base.mutbl = McImmutable;\n-                        base.ty = self.tcx().types.err;\n-                        Rc::new(cmt_ {\n-                            id: id,\n-                            span: span,\n-                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                            mutbl: env_mutbl,\n-                            ty: var_ty,\n-                            note: NoteClosureEnv(upvar_id)\n-                        })\n-                    }\n-                    None => Rc::new(base)\n+                    note: NoteUpvarRef(upvar_id)\n                 }\n-            },\n-            ast::CaptureByRef => {\n-                // The type here is actually a ref (or ref of a ref),\n-                // but we can again get away with not constructing one\n-                // properly since it will never be used.\n-                let mut base = cmt_ {\n-                    id: id,\n-                    span: span,\n-                    cat: cat_upvar(Upvar {\n-                        id: upvar_id,\n-                        kind: kind\n-                    }),\n-                    mutbl: McImmutable,\n-                    ty: self.tcx().types.err,\n-                    note: NoteNone\n-                };\n+            }\n+        };\n \n-                match env_info {\n-                    Some((env_mutbl, env_ptr)) => {\n-                        base = cmt_ {\n-                            id: id,\n-                            span: span,\n-                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                            mutbl: env_mutbl,\n-                            ty: self.tcx().types.err,\n-                            note: NoteClosureEnv(upvar_id)\n-                        };\n-                    }\n-                    None => {}\n-                }\n+        Ok(Rc::new(cmt_result))\n+    }\n \n-                // Look up upvar borrow so we can get its region\n-                let upvar_borrow = self.typer.upvar_borrow(upvar_id).unwrap();\n-                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+    fn env_deref(&self,\n+                 id: ast::NodeId,\n+                 span: Span,\n+                 upvar_id: ty::UpvarId,\n+                 upvar_mutbl: MutabilityCategory,\n+                 env_borrow_kind: ty::BorrowKind,\n+                 cmt_result: cmt_<'tcx>)\n+                 -> cmt_<'tcx>\n+    {\n+        // Look up the node ID of the closure body so we can construct\n+        // a free region within it\n+        let fn_body_id = {\n+            let fn_expr = match self.tcx().map.find(upvar_id.closure_expr_id) {\n+                Some(ast_map::NodeExpr(e)) => e,\n+                _ => unreachable!()\n+            };\n \n-                Rc::new(cmt_ {\n-                    id: id,\n-                    span: span,\n-                    cat: cat_deref(Rc::new(base), 0, ptr),\n-                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n-                    ty: var_ty,\n-                    note: NoteUpvarRef(upvar_id)\n-                })\n+            match fn_expr.node {\n+                ast::ExprClosure(_, _, _, ref body) => body.id,\n+                _ => unreachable!()\n             }\n-        })\n+        };\n+\n+        // Region of environment pointer\n+        let env_region = ty::ReFree(ty::FreeRegion {\n+            scope: region::CodeExtent::from_node_id(fn_body_id),\n+            bound_region: ty::BrEnv\n+        });\n+\n+        let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n+\n+        let var_ty = cmt_result.ty;\n+\n+        // We need to add the env deref.  This means\n+        // that the above is actually immutable and\n+        // has a ref type.  However, nothing should\n+        // actually look at the type, so we can get\n+        // away with stuffing a `ty_err` in there\n+        // instead of bothering to construct a proper\n+        // one.\n+        let cmt_result = cmt_ {\n+            mutbl: McImmutable,\n+            ty: self.tcx().types.err,\n+            ..cmt_result\n+        };\n+\n+        let mut deref_mutbl = MutabilityCategory::from_borrow_kind(env_borrow_kind);\n+\n+        // Issue #18335. If variable is declared as immutable, override the\n+        // mutability from the environment and substitute an `&T` anyway.\n+        match upvar_mutbl {\n+            McImmutable => { deref_mutbl = McImmutable; }\n+            McDeclared | McInherited => { }\n+        }\n+\n+        cmt_ {\n+            id: id,\n+            span: span,\n+            cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n+            mutbl: deref_mutbl,\n+            ty: var_ty,\n+            note: NoteClosureEnv(upvar_id)\n+        }\n     }\n \n     pub fn cat_rvalue_node(&self,"}, {"sha": "425acbae483fe4824245056986c1bb80794e93d7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 63, "deletions": 103, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -777,7 +777,7 @@ pub struct ctxt<'tcx> {\n     pub populated_external_traits: RefCell<DefIdSet>,\n \n     /// Borrows\n-    pub upvar_borrow_map: RefCell<UpvarBorrowMap>,\n+    pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n@@ -803,9 +803,6 @@ pub struct ctxt<'tcx> {\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index>,\n \n-    /// Maps closures to their capture clauses.\n-    pub capture_modes: RefCell<CaptureModeMap>,\n-\n     /// Maps def IDs to true if and only if they're associated types.\n     pub associated_types: RefCell<DefIdMap<bool>>,\n \n@@ -1247,60 +1244,31 @@ pub enum BorrowKind {\n     MutBorrow\n }\n \n-/// Information describing the borrowing of an upvar. This is computed\n-/// during `typeck`, specifically by `regionck`. The general idea is\n-/// that the compiler analyses treat closures like:\n-///\n-///     let closure: &'e fn() = || {\n-///        x = 1;   // upvar x is assigned to\n-///        use(y);  // upvar y is read\n-///        foo(&z); // upvar z is borrowed immutably\n-///     };\n-///\n-/// as if they were \"desugared\" to something loosely like:\n-///\n-///     struct Vars<'x,'y,'z> { x: &'x mut int,\n-///                             y: &'y const int,\n-///                             z: &'z int }\n-///     let closure: &'e fn() = {\n-///         fn f(env: &Vars) {\n-///             *env.x = 1;\n-///             use(*env.y);\n-///             foo(env.z);\n-///         }\n-///         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n-///                                                       y: &'y const y,\n-///                                                       z: &'z z };\n-///         (env, f)\n-///     };\n-///\n-/// This is basically what happens at runtime. The closure is basically\n-/// an existentially quantified version of the `(env, f)` pair.\n-///\n-/// This data structure indicates the region and mutability of a single\n-/// one of the `x...z` borrows.\n-///\n-/// It may not be obvious why each borrowed variable gets its own\n-/// lifetime (in the desugared version of the example, these are indicated\n-/// by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n-/// Each such lifetime must encompass the lifetime `'e` of the closure itself,\n-/// but need not be identical to it. The reason that this makes sense:\n-///\n-/// - Callers are only permitted to invoke the closure, and hence to\n-///   use the pointers, within the lifetime `'e`, so clearly `'e` must\n-///   be a sublifetime of `'x...'z`.\n-/// - The closure creator knows which upvars were borrowed by the closure\n-///   and thus `x...z` will be reserved for `'x...'z` respectively.\n-/// - Through mutation, the borrowed upvars can actually escape\n-///   the closure, so sometimes it is necessary for them to be larger\n-///   than the closure lifetime itself.\n+/// Information describing the capture of an upvar. This is computed\n+/// during `typeck`, specifically by `regionck`.\n+#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub enum UpvarCapture {\n+    /// Upvar is captured by value. This is always true when the\n+    /// closure is labeled `move`, but can also be true in other cases\n+    /// depending on inference.\n+    ByValue,\n+\n+    /// Upvar is captured by reference.\n+    ByRef(UpvarBorrow),\n+}\n+\n #[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct UpvarBorrow {\n+    /// The kind of borrow: by-ref upvars have access to shared\n+    /// immutable borrows, which are not part of the normal language\n+    /// syntax.\n     pub kind: BorrowKind,\n+\n+    /// Region of the resulting reference.\n     pub region: ty::Region,\n }\n \n-pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n+pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n@@ -1320,7 +1288,7 @@ impl Region {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Debug, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -1329,7 +1297,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Debug, Copy)]\n+         RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -2253,6 +2221,12 @@ pub struct TypeScheme<'tcx> {\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n \n+    /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n+    /// attribute, indicating that it should be used with `Foo()`\n+    /// sugar. This is a temporary thing -- eventually any trait wil\n+    /// be usable with the sugar (or without it).\n+    pub paren_sugar: bool,\n+\n     /// Generic type definitions. Note that `Self` is listed in here\n     /// as having a single bound, the trait itself (e.g., in the trait\n     /// `Eq`, there is a single bound `Self : Eq`). This is so that\n@@ -2359,7 +2333,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n-                     capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx>\n@@ -2413,7 +2386,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n         populated_external_traits: RefCell::new(DefIdSet()),\n-        upvar_borrow_map: RefCell::new(FnvHashMap()),\n+        upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n         extern_const_variants: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n@@ -2422,7 +2395,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap()),\n@@ -5646,7 +5618,6 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n     let tcx = typer.tcx();\n-    let capture_mode = tcx.capture_modes.borrow()[closure_id.node].clone();\n     match tcx.freevars.borrow().get(&closure_id.node) {\n         None => Some(vec![]),\n         Some(ref freevars) => {\n@@ -5659,43 +5630,38 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                         };\n                         let freevar_ty = freevar_ty.subst(tcx, substs);\n \n-                        match capture_mode {\n-                            ast::CaptureByValue => {\n-                                Some(ClosureUpvar { def: freevar.def,\n-                                                    span: freevar.span,\n-                                                    ty: freevar_ty })\n+                        let upvar_id = ty::UpvarId {\n+                            var_id: freevar_def_id.node,\n+                            closure_expr_id: closure_id.node\n+                        };\n+\n+                        let captured_freevar_ty = match typer.upvar_capture(upvar_id) {\n+                            Some(UpvarCapture::ByValue) => {\n+                                freevar_ty\n                             }\n \n-                            ast::CaptureByRef => {\n-                                let upvar_id = ty::UpvarId {\n-                                    var_id: freevar_def_id.node,\n-                                    closure_expr_id: closure_id.node\n-                                };\n+                            Some(UpvarCapture::ByRef(borrow)) => {\n+                                mk_rptr(tcx,\n+                                        tcx.mk_region(borrow.region),\n+                                        ty::mt {\n+                                            ty: freevar_ty,\n+                                            mutbl: borrow.kind.to_mutbl_lossy(),\n+                                        })\n+                            }\n \n-                                // FIXME\n-                                let freevar_ref_ty = match typer.upvar_borrow(upvar_id) {\n-                                    Some(borrow) => {\n-                                        mk_rptr(tcx,\n-                                                tcx.mk_region(borrow.region),\n-                                                ty::mt {\n-                                                    ty: freevar_ty,\n-                                                    mutbl: borrow.kind.to_mutbl_lossy(),\n-                                                })\n-                                    }\n-                                    None => {\n-                                        // FIXME(#16640) we should really return None here;\n-                                        // but that requires better inference integration,\n-                                        // for now gin up something.\n-                                        freevar_ty\n-                                    }\n-                                };\n-                                Some(ClosureUpvar {\n-                                    def: freevar.def,\n-                                    span: freevar.span,\n-                                    ty: freevar_ref_ty,\n-                                })\n+                            None => {\n+                                // FIXME(#16640) we should really return None here;\n+                                // but that requires better inference integration,\n+                                // for now gin up something.\n+                                freevar_ty\n                             }\n-                        }\n+                        };\n+\n+                        Some(ClosureUpvar {\n+                            def: freevar.def,\n+                            span: freevar.span,\n+                            ty: captured_freevar_ty,\n+                        })\n                     })\n                     .collect()\n         }\n@@ -6449,14 +6415,13 @@ impl BorrowKind {\n }\n \n impl<'tcx> ctxt<'tcx> {\n-    pub fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.capture_modes.borrow()[closure_expr_id].clone()\n-    }\n-\n     pub fn is_method_call(&self, expr_id: ast::NodeId) -> bool {\n         self.method_map.borrow().contains_key(&MethodCall::expr(expr_id))\n     }\n+\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        Some(self.upvar_capture_map.borrow()[upvar_id].clone())\n+    }\n }\n \n impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n@@ -6494,13 +6459,8 @@ impl<'a,'tcx> mc::Typer<'tcx> for ParameterEnvironment<'a,'tcx> {\n         self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.tcx.upvar_borrow_map.borrow()[upvar_id].clone())\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx.capture_mode(closure_expr_id)\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tcx.upvar_capture(upvar_id)\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {"}, {"sha": "15a91fd0f8da08cb159f6a333588bf3e1c6f18fc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -1292,6 +1292,15 @@ impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for ty::UpvarCapture {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        match *self {\n+            ty::UpvarCapture::ByValue => format!(\"ByValue\"),\n+            ty::UpvarCapture::ByRef(ref data) => format!(\"ByRef({})\", data.repr(tcx)),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", self)"}, {"sha": "fc64cf9470ad7812136e592c5bc4e2e45a3a385f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -560,7 +560,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let resolve::CrateMap {\n         def_map,\n         freevars,\n-        capture_mode_map,\n         export_map,\n         trait_map,\n         external_exports,\n@@ -606,7 +605,6 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             named_region_map,\n                             ast_map,\n                             freevars,\n-                            capture_mode_map,\n                             region_map,\n                             lang_items,\n                             stability_index);"}, {"sha": "45ff1c4537cd5fdffe32e1de005c02a4ed94c4a7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -121,7 +121,7 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n-    let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n+    let resolve::CrateMap { def_map, freevars, .. } =\n         resolve::resolve_crate(&sess, &ast_map, &lang_items, krate, resolve::MakeGlobMap::No);\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n@@ -132,7 +132,6 @@ fn test_env<F>(source_string: &str,\n                           named_region_map,\n                           ast_map,\n                           freevars,\n-                          capture_mode_map,\n                           region_map,\n                           lang_items,\n                           stability_index);"}, {"sha": "c099762036a969813e62d0620d29cff86d6812bd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::lang_items::LanguageItems;\n use rustc::middle::pat_util::pat_bindings;\n use rustc::middle::privacy::*;\n use rustc::middle::subst::{ParamSpace, FnSpace, TypeSpace};\n-use rustc::middle::ty::{CaptureModeMap, Freevar, FreevarMap, TraitMap, GlobMap};\n+use rustc::middle::ty::{Freevar, FreevarMap, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n@@ -900,7 +900,6 @@ struct Resolver<'a, 'tcx:'a> {\n     def_map: DefMap,\n     freevars: RefCell<FreevarMap>,\n     freevars_seen: RefCell<NodeMap<NodeSet>>,\n-    capture_mode_map: CaptureModeMap,\n     export_map: ExportMap,\n     trait_map: TraitMap,\n     external_exports: ExternalExports,\n@@ -974,7 +973,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             def_map: RefCell::new(NodeMap()),\n             freevars: RefCell::new(NodeMap()),\n             freevars_seen: RefCell::new(NodeMap()),\n-            capture_mode_map: NodeMap(),\n             export_map: NodeMap(),\n             trait_map: NodeMap(),\n             used_imports: HashSet::new(),\n@@ -4523,8 +4521,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprClosure(capture_clause, _, ref fn_decl, ref block) => {\n-                self.capture_mode_map.insert(expr.id, capture_clause);\n+            ExprClosure(_, _, ref fn_decl, ref block) => {\n                 self.resolve_function(ClosureRibKind(expr.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);\n@@ -4835,7 +4832,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n pub struct CrateMap {\n     pub def_map: DefMap,\n     pub freevars: RefCell<FreevarMap>,\n-    pub capture_mode_map: RefCell<CaptureModeMap>,\n     pub export_map: ExportMap,\n     pub trait_map: TraitMap,\n     pub external_exports: ExternalExports,\n@@ -4875,7 +4871,6 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     CrateMap {\n         def_map: resolver.def_map,\n         freevars: resolver.freevars,\n-        capture_mode_map: RefCell::new(resolver.capture_mode_map),\n         export_map: resolver.export_map,\n         trait_map: resolver.trait_map,\n         external_exports: resolver.external_exports,"}, {"sha": "7b4acfac4b3b71396a8f622b8c5ba84848f45c07", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -1775,7 +1775,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    _attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n                                    abi: Abi,\n-                                   closure_env: closure::ClosureEnv<'b, 'tcx>) {\n+                                   closure_env: closure::ClosureEnv<'b>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1784,12 +1784,17 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n \n+    let has_env = match closure_env {\n+        closure::ClosureEnv::Closure(_) => true,\n+        closure::ClosureEnv::NotClosure => false,\n+    };\n+\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfndecl,\n                       fn_ast_id,\n-                      closure_env.kind != closure::NotClosure,\n+                      has_env,\n                       output_type,\n                       param_substs,\n                       Some(body.span),\n@@ -1808,13 +1813,13 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         decl.inputs.iter()\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n-    let monomorphized_arg_types = match closure_env.kind {\n-        closure::NotClosure => {\n+    let monomorphized_arg_types = match closure_env {\n+        closure::ClosureEnv::NotClosure => {\n             monomorphized_arg_types\n         }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        closure::Closure(..) => {\n+        closure::ClosureEnv::Closure(_) => {\n             vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n         }\n     };\n@@ -1835,14 +1840,14 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             &monomorphized_arg_types[])\n     };\n \n-    bcx = match closure_env.kind {\n-        closure::NotClosure => {\n+    bcx = match closure_env {\n+        closure::ClosureEnv::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n                                  &decl.inputs[],\n                                  arg_datums)\n         }\n-        closure::Closure(..) => {\n+        closure::ClosureEnv::Closure(_) => {\n             copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n@@ -1932,7 +1937,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   attrs,\n                   output_type,\n                   abi,\n-                  closure::ClosureEnv::new(&[], closure::NotClosure));\n+                  closure::ClosureEnv::NotClosure);\n }\n \n pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "a15ede095a709be359a6e271f70af896bcbf05e8", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::ClosureKind::*;\n-\n use back::link::mangle_internal_name_by_path_and_seq;\n use middle::mem_categorization::Typer;\n use trans::adt;\n@@ -33,9 +31,9 @@ use syntax::ast_util;\n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         arg_scope_id: ScopeId,\n-                                        freevar_mode: ast::CaptureClause,\n                                         freevars: &[ty::Freevar])\n-                                        -> Block<'blk, 'tcx> {\n+                                        -> Block<'blk, 'tcx>\n+{\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n \n     // Special case for small by-value selfs.\n@@ -65,18 +63,21 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+                                     closure_expr_id: closure_id.node };\n+        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n         let mut upvar_ptr = GEPi(bcx, llenv, &[0, i]);\n-        let captured_by_ref = match freevar_mode {\n-            ast::CaptureByRef => {\n+        let captured_by_ref = match upvar_capture {\n+            ty::UpvarCapture::ByValue => false,\n+            ty::UpvarCapture::ByRef(..) => {\n                 upvar_ptr = Load(bcx, upvar_ptr);\n                 true\n             }\n-            ast::CaptureByValue => false\n         };\n         let def_id = freevar.def.def_id();\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n-        if kind == ty::FnOnceClosureKind && freevar_mode == ast::CaptureByValue {\n+        if kind == ty::FnOnceClosureKind && !captured_by_ref {\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n                                       node_id_type(bcx, def_id.node))\n@@ -96,38 +97,23 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-#[derive(PartialEq)]\n-pub enum ClosureKind<'tcx> {\n+pub enum ClosureEnv<'a> {\n     NotClosure,\n-    // See load_closure_environment.\n-    Closure(ast::CaptureClause)\n+    Closure(&'a [ty::Freevar]),\n }\n \n-pub struct ClosureEnv<'a, 'tcx> {\n-    freevars: &'a [ty::Freevar],\n-    pub kind: ClosureKind<'tcx>\n-}\n-\n-impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n-    pub fn new(freevars: &'a [ty::Freevar], kind: ClosureKind<'tcx>)\n-               -> ClosureEnv<'a, 'tcx> {\n-        ClosureEnv {\n-            freevars: freevars,\n-            kind: kind\n-        }\n-    }\n-\n-    pub fn load<'blk>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n-                      -> Block<'blk, 'tcx> {\n-        // Don't bother to create the block if there's nothing to load\n-        if self.freevars.is_empty() {\n-            return bcx;\n-        }\n-\n-        match self.kind {\n-            NotClosure => bcx,\n-            Closure(freevar_mode) => {\n-                load_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+impl<'a> ClosureEnv<'a> {\n+    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n+                           -> Block<'blk, 'tcx>\n+    {\n+        match self {\n+            ClosureEnv::NotClosure => bcx,\n+            ClosureEnv::Closure(freevars) => {\n+                if freevars.is_empty() {\n+                    bcx\n+                } else {\n+                    load_closure_environment(bcx, arg_scope, freevars)\n+                }\n             }\n         }\n     }\n@@ -212,7 +198,6 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n-    let freevar_mode = bcx.tcx().capture_mode(id);\n \n     let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n \n@@ -225,8 +210,7 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::new(&freevars[],\n-                                  Closure(freevar_mode)));\n+                  ClosureEnv::Closure(&freevars[]));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n@@ -249,11 +233,14 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                    dest_addr,\n                                                    0,\n                                                    i);\n-        match freevar_mode {\n-            ast::CaptureByValue => {\n+        let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n+                                     closure_expr_id: id };\n+        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n+        match upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n                 bcx = datum.store_to(bcx, upvar_slot_dest);\n             }\n-            ast::CaptureByRef => {\n+            ty::UpvarCapture::ByRef(..) => {\n                 Store(bcx, datum.to_llref(), upvar_slot_dest);\n             }\n         }"}, {"sha": "a0dbc9c40a68d535473c744552c58136e04970aa", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -679,13 +679,8 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx().region_maps.temporary_scope(rvalue_id)\n     }\n \n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        Some(self.tcx().upvar_borrow_map.borrow()[upvar_id].clone())\n-    }\n-\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        Some(self.tcx().upvar_capture_map.borrow()[upvar_id].clone())\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {"}, {"sha": "350227c6662433757bbede36c59a63a9c0a06d24", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -614,11 +614,9 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n \n     let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n-            // For now, require that parenthetical notation be used\n+            // For now, require that parenthetical5D notation be used\n             // only with `Fn()` etc.\n-            if !this.tcx().sess.features.borrow().unboxed_closures &&\n-                this.tcx().lang_items.fn_trait_kind(trait_def_id).is_some()\n-            {\n+            if !this.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n                 span_err!(this.tcx().sess, path.span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n@@ -632,9 +630,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n         ast::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n             // only with `Fn()` etc.\n-            if !this.tcx().sess.features.borrow().unboxed_closures &&\n-                this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n-            {\n+            if !this.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n                 span_err!(this.tcx().sess, path.span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");"}, {"sha": "640c8d8d4bed992d44cf4c057db9d84abfd18f93", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -160,7 +160,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n     adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n     method_map: MethodMap<'tcx>,\n-    upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n+    upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n     closures: RefCell<DefIdMap<ty::Closure<'tcx>>>,\n     object_cast_map: ObjectCastMap<'tcx>,\n \n@@ -305,7 +305,7 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n         let ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n+        !traits::type_known_to_meet_builtin_bound(self.infcx(), self, ty, ty::BoundCopy, span)\n     }\n     fn node_method_ty(&self, method_call: ty::MethodCall)\n                       -> Option<Ty<'tcx>> {\n@@ -330,12 +330,8 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n         self.param_env().temporary_scope(rvalue_id)\n     }\n-    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarBorrow> {\n-        self.inh.upvar_borrow_map.borrow().get(&upvar_id).cloned()\n-    }\n-    fn capture_mode(&self, closure_expr_id: ast::NodeId)\n-                    -> ast::CaptureClause {\n-        self.ccx.tcx.capture_mode(closure_expr_id)\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.inh.upvar_capture_map.borrow().get(&upvar_id).cloned()\n     }\n }\n \n@@ -378,7 +374,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             adjustments: RefCell::new(NodeMap()),\n             method_map: RefCell::new(FnvHashMap()),\n             object_cast_map: RefCell::new(NodeMap()),\n-            upvar_borrow_map: RefCell::new(FnvHashMap()),\n+            upvar_capture_map: RefCell::new(FnvHashMap()),\n             closures: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),"}, {"sha": "d1fee578218280230fad008bbd56eabb96ff9f0e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -742,16 +742,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     match function_type.sty {\n         ty::ty_closure(_, region, _) => {\n-            if tcx.capture_modes.borrow()[expr.id].clone() == ast::CaptureByRef {\n-                ty::with_freevars(tcx, expr.id, |freevars| {\n-                    if !freevars.is_empty() {\n-                        // Variables being referenced must be constrained and registered\n-                        // in the upvar borrow map\n-                        constrain_free_variables_in_by_ref_closure(\n-                            rcx, *region, expr, freevars);\n-                    }\n-                })\n-            }\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n+                constrain_captured_variables(rcx, *region, expr, freevars);\n+            })\n         }\n         _ => { }\n     }\n@@ -799,14 +792,14 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let raw_var_ty = rcx.resolve_node_type(var_node_id);\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n-                Some(upvar_borrow) => {\n+            let var_ty = match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n+                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n                                 rcx.tcx().mk_region(upvar_borrow.region),\n                                 ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n                                          ty: raw_var_ty })\n                 }\n-                None => raw_var_ty\n+                ty::UpvarCapture::ByValue => raw_var_ty,\n             };\n \n             // Check that the type meets the criteria of the existential bounds:\n@@ -824,17 +817,17 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n \n     /// Make sure that all free variables referenced inside the closure outlive the closure's\n     /// lifetime bound. Also, create an entry in the upvar_borrows map with a region.\n-    fn constrain_free_variables_in_by_ref_closure(\n+    fn constrain_captured_variables(\n         rcx: &mut Rcx,\n         region_bound: ty::Region,\n         expr: &ast::Expr,\n         freevars: &[ty::Freevar])\n     {\n         let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"constrain_free_variables({}, {})\",\n+        debug!(\"constrain_captured_variables({}, {})\",\n                region_bound.repr(tcx), expr.repr(tcx));\n         for freevar in freevars.iter() {\n-            debug!(\"freevar def is {:?}\", freevar.def);\n+            debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n \n             // Identify the variable being closed over and its node-id.\n             let def = freevar.def;\n@@ -846,16 +839,20 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n \n-            let upvar_borrow = rcx.fcx.inh.upvar_borrow_map.borrow()[upvar_id];\n-\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, upvar_borrow.region);\n-\n-            // Guarantee that the closure does not outlive the variable itself.\n-            let enclosing_region = region_of_def(rcx.fcx, def);\n-            debug!(\"enclosing_region = {}\", enclosing_region.repr(tcx));\n-            rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                            region_bound, enclosing_region);\n+            match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n+                ty::UpvarCapture::ByValue => { }\n+                ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                                    region_bound, upvar_borrow.region);\n+\n+                    // Guarantee that the closure does not outlive the variable itself.\n+                    let enclosing_region = region_of_def(rcx.fcx, def);\n+                    debug!(\"constrain_captured_variables: enclosing_region = {}\",\n+                           enclosing_region.repr(tcx));\n+                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n+                                    region_bound, enclosing_region);\n+                }\n+            }\n         }\n     }\n }\n@@ -1333,22 +1330,20 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let mut upvar_borrow_map =\n-                rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-            match upvar_borrow_map.get_mut(upvar_id) {\n-                Some(upvar_borrow) => {\n+            let upvar_capture_map = rcx.fcx.inh.upvar_capture_map.borrow_mut();\n+            match upvar_capture_map.get(upvar_id) {\n+                Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n                     // by the above adjustment, so update our local variable.\n                     ref_kind = upvar_borrow.kind;\n \n                     infer::ReborrowUpvar(span, *upvar_id)\n                 }\n-                None => {\n+                _ => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n                         &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(\n-                                    rcx.tcx()))[]);\n+                                upvar_id.repr(rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "449220b1c85285c4b56fc79a76a0b65d60484b3a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 90, "deletions": 38, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -121,25 +121,29 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n                      capture_clause: ast::CaptureClause,\n                      _body: &ast::Block)\n     {\n-        match capture_clause {\n-            ast::CaptureByValue => {}\n-            _ => {\n-                ty::with_freevars(self.tcx(), expr.id, |freevars| {\n-                    for freevar in freevars.iter() {\n-                        let var_node_id = freevar.def.local_node_id();\n-                        let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                                     closure_expr_id: expr.id };\n-                        debug!(\"seed upvar_id {:?}\", upvar_id);\n+        ty::with_freevars(self.tcx(), expr.id, |freevars| {\n+            for freevar in freevars.iter() {\n+                let var_node_id = freevar.def.local_node_id();\n+                let upvar_id = ty::UpvarId { var_id: var_node_id,\n+                                             closure_expr_id: expr.id };\n+                debug!(\"seed upvar_id {:?}\", upvar_id);\n+\n+                let capture_kind = match capture_clause {\n+                    ast::CaptureByValue => {\n+                        ty::UpvarCapture::ByValue\n+                    }\n+                    ast::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, expr.span);\n                         let freevar_region = self.infcx().next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                              region: freevar_region };\n-                        self.fcx.inh.upvar_borrow_map.borrow_mut().insert(upvar_id,\n-                                                                          upvar_borrow);\n+                        ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n-                });\n+                };\n+\n+                self.fcx.inh.upvar_capture_map.borrow_mut().insert(upvar_id, capture_kind);\n             }\n-        }\n+        });\n     }\n }\n \n@@ -150,7 +154,7 @@ struct AdjustBorrowKind<'a,'tcx:'a> {\n     fcx: &'a FnCtxt<'a,'tcx>\n }\n \n-impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n+impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>) -> AdjustBorrowKind<'a,'tcx> {\n         AdjustBorrowKind { fcx: fcx }\n     }\n@@ -172,6 +176,41 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n         euv.walk_fn(decl, body);\n     }\n \n+    fn adjust_upvar_borrow_kind_for_consume(&self,\n+                                            cmt: mc::cmt<'tcx>,\n+                                            mode: euv::ConsumeMode)\n+    {\n+        debug!(\"adjust_upvar_borrow_kind_for_consume(cmt={}, mode={:?})\",\n+               cmt.repr(self.tcx()), mode);\n+\n+        // we only care about moves\n+        match mode {\n+            euv::Copy => { return; }\n+            euv::Move(_) => { }\n+        }\n+\n+        // watch out for a move of the deref of a borrowed pointer;\n+        // for that to be legal, the upvar would have to be borrowed\n+        // by value instead\n+        let guarantor = cmt.guarantor();\n+        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={}\",\n+               guarantor.repr(self.tcx()));\n+        match guarantor.cat {\n+            mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n+            mc::cat_deref(_, _, mc::Implicit(..)) => {\n+                if let mc::NoteUpvarRef(upvar_id) = cmt.note {\n+                    debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n+                            setting upvar_id={:?} to by value\",\n+                           upvar_id);\n+\n+                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                    upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+\n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borow.\n@@ -195,8 +234,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n                     // upvar, then we need to modify the\n                     // borrow_kind of the upvar to make sure it\n                     // is inferred to mutable if necessary\n-                    let mut upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow_mut();\n-                    let ub = &mut upvar_borrow_map[upvar_id];\n+                    let mut upvar_capture_map = self.fcx.inh.upvar_capture_map.borrow_mut();\n+                    let ub = &mut upvar_capture_map[upvar_id];\n                     self.adjust_upvar_borrow_kind(upvar_id, ub, ty::MutBorrow);\n                 } else {\n                     // assignment to deref of an `&mut`\n@@ -237,7 +276,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n                     // upvar, then we need to modify the\n                     // borrow_kind of the upvar to make sure it\n                     // is inferred to unique if necessary\n-                    let mut ub = self.fcx.inh.upvar_borrow_map.borrow_mut();\n+                    let mut ub = self.fcx.inh.upvar_capture_map.borrow_mut();\n                     let ub = &mut ub[upvar_id];\n                     self.adjust_upvar_borrow_kind(upvar_id, ub, ty::UniqueImmBorrow);\n                 } else {\n@@ -262,23 +301,30 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx>{\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&self,\n                                 upvar_id: ty::UpvarId,\n-                                upvar_borrow: &mut ty::UpvarBorrow,\n+                                upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n-        debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n-               upvar_id, upvar_borrow.kind, kind);\n-\n-        match (upvar_borrow.kind, kind) {\n-            // Take RHS:\n-            (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-            (ty::ImmBorrow, ty::MutBorrow) |\n-            (ty::UniqueImmBorrow, ty::MutBorrow) => {\n-                upvar_borrow.kind = kind;\n+        debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n+               upvar_id, upvar_capture, kind);\n+\n+        match *upvar_capture {\n+            ty::UpvarCapture::ByValue => {\n+                // Upvar is already by-value, the strongest criteria.\n             }\n-            // Take LHS:\n-            (ty::ImmBorrow, ty::ImmBorrow) |\n-            (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-            (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-            (ty::MutBorrow, _) => {\n+            ty::UpvarCapture::ByRef(ref mut upvar_borrow) => {\n+                match (upvar_borrow.kind, kind) {\n+                    // Take RHS:\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+                    (ty::ImmBorrow, ty::MutBorrow) |\n+                    (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                        upvar_borrow.kind = kind;\n+                    }\n+                    // Take LHS:\n+                    (ty::ImmBorrow, ty::ImmBorrow) |\n+                    (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+                    (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+                    (ty::MutBorrow, _) => {\n+                    }\n+                }\n             }\n         }\n     }\n@@ -308,9 +354,12 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,\n-               _cmt: mc::cmt<'tcx>,\n-               _mode: euv::ConsumeMode)\n-    {}\n+               cmt: mc::cmt<'tcx>,\n+               mode: euv::ConsumeMode)\n+    {\n+        debug!(\"consume(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n+    }\n \n     fn matched_pat(&mut self,\n                    _matched_pat: &ast::Pat,\n@@ -320,9 +369,12 @@ impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n \n     fn consume_pat(&mut self,\n                    _consume_pat: &ast::Pat,\n-                   _cmt: mc::cmt<'tcx>,\n-                   _mode: euv::ConsumeMode)\n-    {}\n+                   cmt: mc::cmt<'tcx>,\n+                   mode: euv::ConsumeMode)\n+    {\n+        debug!(\"consume_pat(cmt={},mode={:?})\", cmt.repr(self.tcx()), mode);\n+        self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n+    }\n \n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,"}, {"sha": "f7e1afed8fc53f219d1ea8d25d771ab447acd7c6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -182,16 +182,20 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_borrow) in self.fcx.inh.upvar_borrow_map.borrow().iter() {\n-            let r = upvar_borrow.region;\n-            let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n-            let new_upvar_borrow = ty::UpvarBorrow { kind: upvar_borrow.kind,\n-                                                     region: r };\n-            debug!(\"Upvar borrow for {} resolved to {}\",\n+        for (upvar_id, upvar_capture) in self.fcx.inh.upvar_capture_map.borrow().iter() {\n+            let new_upvar_capture = match *upvar_capture {\n+                ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n+                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n+                    let r = upvar_borrow.region;\n+                    let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n+                    ty::UpvarCapture::ByRef(\n+                        ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                }\n+            };\n+            debug!(\"Upvar capture for {} resolved to {}\",\n                    upvar_id.repr(self.tcx()),\n-                   new_upvar_borrow.repr(self.tcx()));\n-            self.fcx.tcx().upvar_borrow_map.borrow_mut().insert(\n-                *upvar_id, new_upvar_borrow);\n+                   new_upvar_capture.repr(self.tcx()));\n+            self.fcx.tcx().upvar_capture_map.borrow_mut().insert(*upvar_id, new_upvar_capture);\n         }\n     }\n "}, {"sha": "ed33ddd458a54223de475475d659c74b577454e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -855,6 +855,17 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n     };\n \n+    let paren_sugar = ty::has_attr(tcx, def_id, \"rustc_paren_sugar\");\n+    if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n+        ccx.tcx.sess.span_err(\n+            it.span,\n+            \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n+             which traits can use parenthetical notation\");\n+        span_help!(ccx.tcx.sess, it.span,\n+                   \"add `#![feature(unboxed_closures)]` to \\\n+                    the crate attributes to use it\");\n+    }\n+\n     let substs = ccx.tcx.mk_substs(mk_trait_substs(ccx, generics));\n \n     let ty_generics = ty_generics_for_trait(ccx,\n@@ -887,6 +898,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     });\n \n     let trait_def = Rc::new(ty::TraitDef {\n+        paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: ty_generics,\n         bounds: bounds,"}, {"sha": "9b9edce243bb77ce9a9c5e94b4ff5356cbe4b752", "filename": "src/test/compile-fail/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-call-is-borrow-issue-12224.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -58,8 +58,10 @@ fn test6() {\n fn test7() {\n     fn foo<F>(_: F) where F: FnMut(Box<FnMut(isize)>, isize) {}\n     let mut f = |&mut: g: Box<FnMut(isize)>, b: isize| {};\n-    f(box |a| { //~ ERROR: cannot borrow `f` as immutable because it is also borrowed as mutable\n-        foo(f); //~ ERROR: cannot move out of captured outer variable\n+    f(box |a| {\n+        foo(f);\n+        //~^ ERROR cannot move `f` into closure because it is borrowed\n+        //~| ERROR cannot move out of captured outer variable in an `FnMut` closure\n     }, 3);\n }\n "}, {"sha": "1312b42fb82d4ccdeaf33e2cb2a738bc415fa182", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -19,24 +19,24 @@ fn main() {\n     // By-ref cases\n     {\n         let x = box 0us;\n-        let f = |&:| drop(x); //~ cannot move\n+        let f = |&:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |&mut:| drop(x); //~ cannot move\n+        let f = |&mut:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |:| drop(x); //~ cannot move\n+        let f = |:| drop(x); // OK -- FnOnce\n     }\n     // By-value cases\n     {\n         let x = box 0us;\n-        let f = move |&:| drop(x); //~ cannot move\n+        let f = move |&:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |&mut:| drop(x); //~ cannot move\n+        let f = move |&mut:| drop(x); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;"}, {"sha": "e66610c14960757e852c51c5110f9749948a2993", "filename": "src/test/compile-fail/unboxed-closures-move-upvar-from-non-once-ref-closure.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-move-upvar-from-non-once-ref-closure.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a by-ref `FnMut` closure gets an error when it tries to\n+// consume a value.\n+\n+fn call<F>(f: F) where F : Fn() {\n+    f();\n+}\n+\n+fn main() {\n+    let y = vec!(format!(\"World\"));\n+    call(|| {\n+        y.into_iter();\n+        //~^ ERROR cannot move out of captured outer variable in an `Fn` closure\n+    });\n+}"}, {"sha": "96c7948dcb0469253d781a411a6e85ab3bfda608", "filename": "src/test/compile-fail/unboxed-closures-mutate-upvar.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we cannot mutate an outer variable that is not declared\n+// as `mut` through a closure. Also test that we CAN mutate a moved copy,\n+// unless this is a `Fn` closure. Issue #16749.\n+\n+use std::mem;\n+\n+fn a() {\n+    let n = 0u8;\n+    let mut f = |&mut:| { //~ ERROR closure cannot assign\n+        n += 1;\n+    };\n+}\n+\n+fn b() {\n+    let mut n = 0u8;\n+    let mut f = |&mut:| {\n+        n += 1; // OK\n+    };\n+}\n+\n+fn c() {\n+    let n = 0u8;\n+    let mut f = move |&mut:| {\n+        // If we just did a straight-forward desugaring, this would\n+        // compile, but we do something a bit more subtle, and hence\n+        // we get an error.\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn d() {\n+    let mut n = 0u8;\n+    let mut f = move |&mut:| {\n+        n += 1; // OK\n+    };\n+}\n+\n+fn e() {\n+    let n = 0u8;\n+    let mut f = move |&:| {\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn f() {\n+    let mut n = 0u8;\n+    let mut f = move |&:| {\n+        n += 1; //~ ERROR cannot assign\n+    };\n+}\n+\n+fn main() { }"}, {"sha": "2345a86595e2da0223b60d29f68147c5964c3bdc", "filename": "src/test/compile-fail/unboxed-closures-mutated-upvar-from-fn-closure.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutated-upvar-from-fn-closure.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a by-ref `FnMut` closure gets an error when it tries to\n+// mutate a value.\n+\n+fn call<F>(f: F) where F : Fn() {\n+    f();\n+}\n+\n+fn main() {\n+    let mut counter = 0_u32;\n+    call(|| {\n+        counter += 1;\n+        //~^ ERROR cannot assign to data in a captured outer variable in an `Fn` closure\n+    });\n+}"}, {"sha": "e921f0c723ee5a6a1f2d3e2d4d6ba3076bd89cbb", "filename": "src/test/run-pass/unboxed-closures-counter-not-moved.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-counter-not-moved.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we mutate a counter on the stack only when we expect to.\n+\n+fn call<F>(f: F) where F : FnOnce() {\n+    f();\n+}\n+\n+fn main() {\n+    let y = vec!(format!(\"Hello\"), format!(\"World\"));\n+    let mut counter = 22_u32;\n+\n+    call(|| {\n+        // Move `y`, but do not move `counter`, even though it is read\n+        // by value (note that it is also mutated).\n+        for item in y.into_iter() {\n+            let v = counter;\n+            counter += v;\n+        }\n+    });\n+    assert_eq!(counter, 88);\n+\n+    call(move || {\n+        // this mutates a moved copy, and hence doesn't affect original\n+        counter += 1;\n+    });\n+    assert_eq!(counter, 88);\n+}"}, {"sha": "9534ee6fa12619449e6568bc11f46b2847751e92", "filename": "src/test/run-pass/unboxed-closures-move-some-upvars-in-by-ref-closure.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbfad3519af1bf5dd903f6032265da0351862ea/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-move-some-upvars-in-by-ref-closure.rs?ref=3fbfad3519af1bf5dd903f6032265da0351862ea", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that in a by-ref once closure we move some variables even as\n+// we capture others by mutable reference.\n+\n+fn call<F>(f: F) where F : FnOnce() {\n+    f();\n+}\n+\n+fn main() {\n+    let mut x = vec!(format!(\"Hello\"));\n+    let y = vec!(format!(\"World\"));\n+    call(|| {\n+        // Here: `x` must be captured with a mutable reference in\n+        // order for us to append on it, and `y` must be captured by\n+        // value.\n+        for item in y.into_iter() {\n+            x.push(item);\n+        }\n+    });\n+    assert_eq!(x.len(), 2);\n+    assert_eq!(&*x[0], \"Hello\");\n+    assert_eq!(&*x[1], \"World\");\n+}"}]}