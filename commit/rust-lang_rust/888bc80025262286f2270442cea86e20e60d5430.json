{"sha": "888bc80025262286f2270442cea86e20e60d5430", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OGJjODAwMjUyNjIyODZmMjI3MDQ0MmNlYTg2ZTIwZTYwZDU0MzA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-13T12:19:56Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T10:46:57Z"}, "message": "Parse and resolve implementations.\n\nIssue #1227", "tree": {"sha": "a3669ada9d5903e378b0a44c5ff608dfe0234779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3669ada9d5903e378b0a44c5ff608dfe0234779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888bc80025262286f2270442cea86e20e60d5430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888bc80025262286f2270442cea86e20e60d5430", "html_url": "https://github.com/rust-lang/rust/commit/888bc80025262286f2270442cea86e20e60d5430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888bc80025262286f2270442cea86e20e60d5430/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5af61d6799ee8c1af583ba1fed0b9e3ce162f2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5af61d6799ee8c1af583ba1fed0b9e3ce162f2c", "html_url": "https://github.com/rust-lang/rust/commit/d5af61d6799ee8c1af583ba1fed0b9e3ce162f2c"}], "stats": {"total": 342, "additions": 261, "deletions": 81}, "files": [{"sha": "2ba91d2ecbdcac0f28e8bd95e4e3f8986ec7a1e7", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -162,7 +162,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n              bind middle::ast_map::map_crate(*crate));\n     time(time_passes, \"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n-    let {def_map: def_map, ext_map: ext_map, exp_map: exp_map} =\n+    let {def_map, ext_map, exp_map, impl_map} =\n         time(time_passes, \"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     let freevars =\n@@ -171,7 +171,8 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     time(time_passes, \"const checking\",\n          bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n-    time(time_passes, \"typechecking\", bind typeck::check_crate(ty_cx, crate));\n+    time(time_passes, \"typechecking\",\n+         bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"block-use checking\",\n          bind middle::block_use::check_crate(ty_cx, crate));\n     time(time_passes, \"function usage\",\n@@ -267,11 +268,11 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n       ppm_typed. {\n         crate = syntax::ext::expand::expand_crate(sess, crate);\n         let amap = middle::ast_map::map_crate(*crate);\n-        let {def_map: def_map, ext_map: ext_map, exp_map: _exp_map} =\n+        let {def_map, ext_map, impl_map, _} =\n             resolve::resolve_crate(sess, amap, crate);\n         let freevars = freevars::annotate_freevars(def_map, crate);\n         let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, amap, freevars);\n-        typeck::check_crate(ty_cx, crate);\n+        typeck::check_crate(ty_cx, impl_map, crate);\n         ann = {pre: ann_paren_for_expr, post: bind ann_typed_post(ty_cx, _)};\n       }\n       ppm_identified. {"}, {"sha": "f5bebd344cc7441283f94380d05ae93116e9530c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -532,7 +532,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n fn def_is_local(d: ast::def, objfields_count: bool) -> bool {\n     ret alt d {\n           ast::def_local(_, _) | ast::def_arg(_, _) | ast::def_binding(_) |\n-          ast::def_upvar(_, _, _) {\n+          ast::def_upvar(_, _, _) | ast::def_self(_) {\n             true\n           }\n           ast::def_obj_field(_, _) { objfields_count }"}, {"sha": "8d9526796781fb4e00a32b5aec2692f8e964aa22", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -264,6 +264,7 @@ fn is_immutable_def(def: def) -> option::t<str> {\n       def_arg(_, by_ref.) | def_arg(_, by_val.) |\n       def_arg(_, mode_infer.) { some(\"argument\") }\n       def_obj_field(_, imm.) { some(\"immutable object field\") }\n+      def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, mut) {\n         if !mut { some(\"upvar\") } else { is_immutable_def(*inner) }\n       }"}, {"sha": "4121771e8b6492430e2a10f91d41283b10ec0a63", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 166, "deletions": 35, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -19,9 +19,7 @@ import option::{some, none, is_none, is_some};\n import syntax::print::pprust::*;\n \n export resolve_crate;\n-export def_map;\n-export ext_map;\n-export exp_map;\n+export def_map, ext_map, exp_map, impl_map;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -45,14 +43,23 @@ type scopes = list<scope>;\n \n tag import_state {\n     todo(ast::node_id, ast::ident, @[ast::ident], codemap::span, scopes);\n+    is_glob(@[ast::ident], scopes, codemap::span);\n     resolving(span);\n     resolved(option::t<def>, /* value */\n              option::t<def>, /* type */\n              option::t<def>, /* module */\n+             @[def_id],\n              /* used for reporting unused import warning */\n              ast::ident, codemap::span);\n }\n \n+tag glob_import_state {\n+    glob_resolving(span);\n+    glob_resolved(option::t<def>,  /* value */\n+                  option::t<def>,  /* type */\n+                  option::t<def>); /* module */\n+}\n+\n type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n@@ -89,7 +96,7 @@ type indexed_mod = {\n     m: option::t<ast::_mod>,\n     index: mod_index,\n     mutable glob_imports: [glob_imp_def],\n-    glob_imported_names: hashmap<str, import_state>,\n+    glob_imported_names: hashmap<str, glob_import_state>,\n     path: str\n };\n \n@@ -99,6 +106,7 @@ type indexed_mod = {\n type def_map = hashmap<node_id, def>;\n type ext_map = hashmap<def_id, [ident]>;\n type exp_map = hashmap<str, def>;\n+type impl_map = hashmap<node_id, iscopes>;\n \n type env =\n     {cstore: cstore::cstore,\n@@ -109,6 +117,7 @@ type env =\n      mod_map: hashmap<ast::node_id, @indexed_mod>,\n      block_map: hashmap<ast::node_id, [glob_imp_def]>,\n      ext_map: ext_map,\n+     impl_map: impl_map,\n      ext_cache: ext_hash,\n      used_imports: {mutable track: bool,\n                     mutable data: [ast::node_id]},\n@@ -124,7 +133,8 @@ tag dir { inside; outside; }\n tag namespace { ns_value; ns_type; ns_module; }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n-   {def_map: def_map, ext_map: ext_map, exp_map: exp_map} {\n+   {def_map: def_map, ext_map: ext_map,\n+    exp_map: exp_map, impl_map: impl_map} {\n     let e =\n         @{cstore: sess.get_cstore(),\n           def_map: new_int_hash(),\n@@ -134,6 +144,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           mod_map: new_int_hash(),\n           block_map: new_int_hash(),\n           ext_map: new_def_hash(),\n+          impl_map: new_int_hash(),\n           ext_cache: new_ext_hash(),\n           used_imports: {mutable track: false, mutable data:  []},\n           mutable reported: [],\n@@ -144,10 +155,12 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n     check_for_collisions(e, *crate);\n     check_exports(e);\n     resolve_names(e, crate);\n+    resolve_impls(e, crate);\n     if sess.get_opts().warn_unused_imports {\n         check_unused_imports(e);\n     }\n-    ret {def_map: e.def_map, ext_map: e.ext_map, exp_map: e.exp_map};\n+    ret {def_map: e.def_map, ext_map: e.ext_map,\n+         exp_map: e.exp_map, impl_map: e.impl_map};\n }\n \n // Locate all modules and imports and index them, so that the next passes can\n@@ -166,7 +179,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: [],\n-                       glob_imported_names: new_str_hash::<import_state>(),\n+                       glob_imported_names: new_str_hash(),\n                        path: \"\"});\n     fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n         alt i.node {\n@@ -181,6 +194,9 @@ fn map_crate(e: @env, c: @ast::crate) {\n                                       ident.span, sc));\n             }\n           }\n+          ast::view_item_import_glob(pth, id) {\n+            e.imports.insert(id, is_glob(pth, sc, i.span));\n+          }\n           _ { }\n         }\n     }\n@@ -198,21 +214,19 @@ fn map_crate(e: @env, c: @ast::crate) {\n         visit_item_with_scope(i, sc, v);\n         alt i.node {\n           ast::item_mod(md) {\n-            let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n                              @{m: some(md),\n                                index: index_mod(md),\n                                mutable glob_imports: [],\n-                               glob_imported_names: s,\n+                               glob_imported_names: new_str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n           ast::item_native_mod(nmd) {\n-            let s = new_str_hash::<import_state>();\n             e.mod_map.insert(i.id,\n                              @{m: none::<ast::_mod>,\n                                index: index_nmod(nmd),\n                                mutable glob_imports: [],\n-                               glob_imported_names: s,\n+                               glob_imported_names: new_str_hash(),\n                                path: path_from_scope(sc, i.ident)});\n           }\n           _ { }\n@@ -233,7 +247,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, *path, vi.span);\n             if option::is_some(imp) {\n-                let glob = {def: option::get(imp), item: vi};;\n+                let glob = {def: option::get(imp), item: vi};\n                 alt list::head(sc) {\n                   scope_item(i) {\n                     e.mod_map.get(i.id).glob_imports += [glob];\n@@ -262,7 +276,7 @@ fn resolve_imports(e: env) {\n           todo(node_id, name, path, span, scopes) {\n             resolve_import(e, local_def(node_id), name, *path, span, scopes);\n           }\n-          resolved(_, _, _, _, _) { }\n+          resolved(_, _, _, _, _, _) | is_glob(_, _, _) { }\n         }\n     };\n     e.used_imports.track = false;\n@@ -272,7 +286,7 @@ fn resolve_imports(e: env) {\n fn check_unused_imports(e: @env) {\n     e.imports.items {|k, v|\n         alt v {\n-            resolved(val, ty, md, name, sp) {\n+            resolved(_, _, _, _, name, sp) {\n               if !vec::member(k, e.used_imports.data) {\n                 e.sess.span_warn(sp, \"unused import \" + name);\n               }\n@@ -472,13 +486,14 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                   ids: [ast::ident], sp: codemap::span, sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n-                name: ast::ident, lookup: block(namespace) -> option::t<def>){\n+                name: ast::ident, lookup: block(namespace) -> option::t<def>,\n+                impls: [def_id]) {\n         let val = lookup(ns_value), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) {\n             unresolved_err(e, cx, sp, name, \"import\");\n         } else {\n-            e.imports.insert(id, resolved(val, typ, md, name, sp));\n+            e.imports.insert(id, resolved(val, typ, md, @impls, name, sp));\n         }\n     }\n     // Temporarily disable this import and the imports coming after during\n@@ -527,7 +542,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     let end_id = ids[n_idents - 1u];\n     if n_idents == 1u {\n         register(e, defid.node, in_scope(sc), sp, name,\n-                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns) });\n+                 {|ns| lookup_in_scope(e, sc, sp, end_id, ns) }, []);\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n           none. {\n@@ -537,9 +552,11 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n             let dcur = dcur_, i = 1u;\n             while true {\n                 if i == n_idents - 1u {\n+                    let impls = [];\n+                    find_impls_in_mod(e, dcur, impls, some(end_id));\n                     register(e, defid.node, in_mod(dcur), sp, name, {|ns|\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n-                    });\n+                    }, impls);\n                     break;\n                 } else {\n                     dcur = alt lookup_in_mod(e, dcur, sp, ids[i], ns_module,\n@@ -563,7 +580,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     // import\n     alt e.imports.find(defid.node) {\n       some(resolving(sp)) {\n-        e.imports.insert(defid.node, resolved(none, none, none, \"\", sp));\n+        e.imports.insert(defid.node, resolved(none, none, none, @[], \"\", sp));\n       }\n       _ { }\n     }\n@@ -726,6 +743,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_obj(ob, ty_params, _) {\n                 ret lookup_in_obj(name, ob, ty_params, ns);\n               }\n+              ast::item_impl(_, _, _) {\n+                if (name == \"self\" && ns == ns_value) {\n+                    ret some(ast::def_self(local_def(it.id)));\n+                }\n+              }\n               ast::item_tag(_, ty_params) {\n                 if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n               }\n@@ -819,7 +841,6 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n         }\n     }\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n-\n }\n \n fn lookup_in_ty_params(name: ident, ty_params: [ast::ty_param]) ->\n@@ -999,7 +1020,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       }\n       _ { }\n     }\n-    ret none::<def>;\n+    ret none;\n }\n \n fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n@@ -1060,11 +1081,12 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n         e.sess.span_err(sp, \"cyclic import\");\n         ret none;\n       }\n-      resolved(val, typ, md, _, _) {\n+      resolved(val, typ, md, _, _, _) {\n         if e.used_imports.track {\n             e.used_imports.data += [defid.node];\n         }\n-        ret alt ns { ns_value. { val } ns_type. { typ } ns_module. { md } };\n+        ret alt ns { ns_value. { val } ns_type. { typ }\n+                     ns_module. { md } };\n       }\n     }\n }\n@@ -1136,22 +1158,20 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n     if !info.glob_imported_names.contains_key(id) {\n-        info.glob_imported_names.insert(id, resolving(sp));\n+        info.glob_imported_names.insert(id, glob_resolving(sp));\n         let val = lookup_in_globs(e, info.glob_imports, sp, id, ns_value, dr);\n         let typ = lookup_in_globs(e, info.glob_imports, sp, id, ns_type, dr);\n         let md = lookup_in_globs(e, info.glob_imports, sp, id, ns_module, dr);\n-        info.glob_imported_names.insert(id, resolved(val, typ, md, id, sp));\n+        info.glob_imported_names.insert(id, glob_resolved(val, typ, md));\n     }\n     alt info.glob_imported_names.get(id) {\n-      todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n-      //circularity is okay in import globs\n-      resolving(sp) { ret none::<def>; }\n-      resolved(val, typ, md, _, _) {\n+      glob_resolving(sp) { ret none::<def>; }\n+      glob_resolved(val, typ, md) {\n         ret alt wanted_ns {\n-              ns_value. { val }\n-              ns_type. { typ }\n-              ns_module. { md }\n-            };\n+          ns_value. { val }\n+          ns_type. { typ }\n+          ns_module. { md }\n+        };\n       }\n     }\n }\n@@ -1229,7 +1249,8 @@ fn index_mod(md: ast::_mod) -> mod_index {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n-          ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) {\n+          ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) |\n+          ast::item_impl(_, _, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n           ast::item_tag(variants, _) {\n@@ -1289,6 +1310,7 @@ fn ns_for_def(d: def) -> namespace {\n           ast::def_use(_) { ns_module }\n           ast::def_native_ty(_) { ns_type }\n           ast::def_native_fn(_, _) { ns_value }\n+          ast::def_self(_) { ns_value }\n         };\n }\n \n@@ -1558,7 +1580,7 @@ fn check_exports(e: @env) {\n                 alt x {\n                   mie_import_ident(id, _) {\n                     alt e.imports.get(id) {\n-                      resolved(v, t, m, rid, _) {\n+                      resolved(v, t, m, _, rid, _) {\n                         maybe_add_reexport(e, val.path + rid, v);\n                         maybe_add_reexport(e, val.path + rid, t);\n                         maybe_add_reexport(e, val.path + rid, m);\n@@ -1596,6 +1618,115 @@ fn check_exports(e: @env) {\n     };\n }\n \n+// Impl resolution\n+\n+fn resolve_impls(e: @env, c: @ast::crate) {\n+    visit::visit_crate(*c, nil, visit::mk_vt(@{\n+        visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n+        visit_item: bind visit_item_with_impl_scope(e, _, _, _),\n+        visit_expr: bind resolve_impl_in_expr(e, _, _, _)\n+        with *visit::default_visitor()\n+    }));\n+}\n+\n+fn find_impls_in_view_item(e: env, vi: @ast::view_item, &impls: [def_id]) {\n+    alt vi.node {\n+      ast::view_item_import(ident, _, id) {\n+        // FIXME if single name, simply look in our own iscope\n+        alt e.imports.get(id) {\n+          resolved(_, _, _, is, _, _) { impls += *is; }\n+        }\n+      }\n+      ast::view_item_import_from(base, names, _) {\n+        for nm in names {\n+            alt e.imports.get(nm.node.id) {\n+              resolved(_, _, _, is, _, _) { impls += *is; }\n+            }\n+        }\n+      }\n+      ast::view_item_import_glob(ids, id) {\n+          alt e.imports.get(id) {\n+            is_glob(path, sc, sp) {\n+              alt follow_import(e, sc, *path, sp) {\n+                some(def) { find_impls_in_mod(e, def, impls, none); }\n+                _ {}\n+              }\n+            }\n+          }\n+      }\n+      _ {}\n+    }\n+}\n+\n+fn find_impls_in_item(i: @ast::item, &impls: [def_id],\n+                      name: option::t<ident>, _dir: dir) {\n+    // FIXME check exports\n+    alt i.node {\n+      ast::item_impl(_, _, _) {\n+        if alt name { some(n) { n == i.ident } _ { true } } {\n+            impls += [local_def(i.id)];\n+        }\n+      }\n+      _ {}\n+    }\n+}\n+\n+fn find_impls_in_mod(e: env, m: def, &impls: [def_id],\n+                     name: option::t<ident>) {\n+    alt m {\n+      ast::def_mod(defid) {\n+        // FIXME external importing of impls\n+        if defid.crate == ast::local_crate {\n+            for i in option::get(e.mod_map.get(defid.node).m).items {\n+                find_impls_in_item(i, impls, name, outside);\n+            }\n+        }\n+      }\n+      _ {}\n+    }\n+}\n+\n+type iscopes = list<@[def_id]>;\n+\n+fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n+                               v: vt<iscopes>) {\n+    let impls = [];\n+    for vi in b.node.view_items { find_impls_in_view_item(*e, vi, impls); }\n+    for st in b.node.stmts {\n+        alt st.node {\n+          ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n+            find_impls_in_item(i, impls, none, inside);\n+          }\n+          _ {}\n+        }\n+    }\n+    let sc = vec::len(impls) > 0u ? cons(@impls, @sc) : sc;\n+    visit::visit_block(b, sc, v);\n+}\n+\n+fn visit_item_with_impl_scope(e: @env, i: @ast::item, sc: iscopes,\n+                              v: vt<iscopes>) {\n+    let sc = sc;\n+    alt i.node {\n+      ast::item_mod(m) {\n+        let impls = [];\n+        for vi in m.view_items { find_impls_in_view_item(*e, vi, impls); }\n+        for i in m.items { find_impls_in_item(i, impls, none, inside); }\n+        if vec::len(impls) > 0u { sc = cons(@impls, @sc); }\n+      }\n+      _ {}\n+    }\n+    visit::visit_item(i, sc, v);\n+}\n+\n+fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n+    alt x.node {\n+      ast::expr_field(_, _) { e.impl_map.insert(x.id, sc); }\n+      _ {}\n+    }\n+    visit::visit_expr(x, sc, v);\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "bd25cc4e9bf7f29fcd26df898d320f4bf1f8c764", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -2678,6 +2678,9 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n         assert (cx.fcx.llobjfields.contains_key(did.node));\n         ret { val: cx.fcx.llobjfields.get(did.node), kind: owned };\n       }\n+      ast::def_self(did) {\n+        ret lval_owned(cx, cx.fcx.llenv);\n+      }\n       _ {\n         bcx_ccx(cx).sess.span_unimpl\n             (cx.sp, \"unsupported def type in trans_local_def\");\n@@ -4946,6 +4949,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n+      ast::item_impl(_, _, _) { fail \"FIXME[impl]\"; }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n         trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n "}, {"sha": "f622acb70400909a72c22e491c170430edf7b875", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -26,17 +26,14 @@ fn find_pre_post_native_mod(_m: native_mod) -> native_mod {\n     fail;\n }\n \n-fn find_pre_post_obj(ccx: crate_ctxt, o: _obj) {\n-    fn do_a_method(ccx: crate_ctxt, m: @method) {\n-        assert (ccx.fm.contains_key(m.node.id));\n-        let fcx: fn_ctxt =\n-            {enclosing: ccx.fm.get(m.node.id),\n-             id: m.node.id,\n-             name: m.node.ident,\n-             ccx: ccx};\n-        find_pre_post_fn(fcx, m.node.meth);\n-    }\n-    for m: @method in o.methods { do_a_method(ccx, m); }\n+fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n+    assert (ccx.fm.contains_key(m.node.id));\n+    let fcx: fn_ctxt =\n+        {enclosing: ccx.fm.get(m.node.id),\n+         id: m.node.id,\n+         name: m.node.ident,\n+         ccx: ccx};\n+    find_pre_post_fn(fcx, m.node.meth);\n }\n \n fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n@@ -77,7 +74,8 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              ccx: ccx};\n         find_pre_post_fn(fcx, dtor);\n       }\n-      item_obj(o, _, _) { find_pre_post_obj(ccx, o); }\n+      item_obj(o, _, _) {for m in o.methods { find_pre_post_method(ccx, m); }}\n+      item_impl(_, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n     }\n }\n "}, {"sha": "1c5bdcb18f5fee0918da36eeb39ea52ac096248f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -2702,20 +2702,12 @@ fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n-      ast::def_fn(_, _) { ret true; }\n-      ast::def_obj_field(_, _) { ret false; }\n-      ast::def_mod(_) { ret false; }\n-      ast::def_const(_) { ret false; }\n-      ast::def_arg(_, _) { ret false; }\n-      ast::def_local(_, _) { ret false; }\n-      ast::def_upvar(_, _, _) { ret false; }\n-      ast::def_variant(_, _) { ret true; }\n-      ast::def_ty(_) { ret false; }\n-      ast::def_ty_param(_, _) { ret false; }\n-      ast::def_binding(_) { ret false; }\n-      ast::def_use(_) { ret false; }\n-      ast::def_native_ty(_) { ret false; }\n-      ast::def_native_fn(_, _) { ret true; }\n+      ast::def_obj_field(_, _) | ast::def_mod(_) | ast::def_const(_) |\n+      ast::def_arg(_, _) | ast::def_local(_, _) | ast::def_upvar(_, _, _) |\n+      ast::def_ty_param(_, _) | ast::def_binding(_) | ast::def_use(_) |\n+      ast::def_native_ty(_) | ast::def_self(_) | ast::def_ty(_) { false }\n+      ast::def_fn(_, _) | ast::def_variant(_, _) |\n+      ast::def_native_fn(_, _) { true }\n     }\n }\n "}, {"sha": "1150f4637de81989b93145d77ef8eb7967dc9d72", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -33,7 +33,9 @@ tag obj_info {\n     anon_obj([ast::obj_field], option::t<ty::sty>);\n }\n \n-type crate_ctxt = {mutable obj_infos: [obj_info], tcx: ty::ctxt};\n+type crate_ctxt = {mutable obj_infos: [obj_info],\n+                   impl_map: resolve::impl_map,\n+                   tcx: ty::ctxt};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -89,6 +91,7 @@ fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {kinds: no_kinds, ty: typ};\n       }\n+      ast::def_self(id) { fail \"FIXME[impl]\"; }\n       ast::def_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_native_fn(id, _) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_const(id) { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n@@ -686,7 +689,7 @@ mod collect {\n     }\n     fn convert(cx: @ctxt, it: @ast::item) {\n         alt it.node {\n-          ast::item_mod(_) {\n+          ast::item_mod(_) | ast::item_impl(_, _, _) {\n             // ignore item_mod, it has no type.\n           }\n           ast::item_native_mod(native_mod) {\n@@ -2657,12 +2660,15 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n-fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n+fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n+               crate: @ast::crate) {\n     collect::collect_item_types(tcx, crate);\n \n     let obj_infos: [obj_info] = [];\n \n-    let ccx = @{mutable obj_infos: obj_infos, tcx: tcx};\n+    let ccx = @{mutable obj_infos: obj_infos,\n+                impl_map: impl_map,\n+                tcx: tcx};\n     let visit =\n         visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _)\n                                       with *visit::default_simple_visitor()});"}, {"sha": "0672e9de5c7eee2e23586a6c4bc60b5b7e524379", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -33,9 +33,8 @@ tag def {\n     def_const(def_id);\n     def_arg(def_id, mode);\n     def_local(def_id, let_style);\n-    def_variant(def_id, /* tag */def_id);\n-\n-    /* variant */\n+    def_variant(def_id /* tag */, def_id /* variant */);\n+    def_self(def_id);\n     def_ty(def_id);\n     def_ty_param(uint, kind);\n     def_binding(def_id);\n@@ -507,6 +506,7 @@ tag item_ {\n              node_id /* dtor id */,\n              [ty_param],\n              node_id /* ctor id */);\n+    item_impl(@path /* iface */, @ty /* self */, [@method]);\n }\n \n type native_item ="}, {"sha": "ea3ca0bd50416c4ce5b3ca3d519eaef314346268", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -36,6 +36,7 @@ fn def_id_of_def(d: def) -> def_id {\n     alt d {\n       def_fn(id, _) { ret id; }\n       def_obj_field(id, _) { ret id; }\n+      def_self(id) { ret id; }\n       def_mod(id) { ret id; }\n       def_native_mod(id) { ret id; }\n       def_const(id) { ret id; }"}, {"sha": "05a4893ccd001b5bc98d634c6eeb6ea57b7ecb97", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -235,6 +235,10 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                       methods: vec::map(fld.fold_method, o.methods)},\n                      typms, d)\n           }\n+          item_impl(iface, ty, methods) {\n+            item_impl(fld.fold_path(iface), fld.fold_ty(ty),\n+                      vec::map(fld.fold_method, methods))\n+          }\n           item_res(dtor, did, typms, cid) {\n             item_res(fld.fold_fn(dtor), did, typms, cid)\n           }"}, {"sha": "d1e11bf8700b6aaa254122644a7cd278555a9dea", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -155,7 +155,8 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"cont\", \"ret\", \"be\", \"fail\", \"type\", \"resource\", \"check\",\n                  \"assert\", \"claim\", \"native\", \"fn\", \"lambda\", \"pure\",\n                  \"unsafe\", \"block\", \"import\", \"export\", \"let\", \"const\",\n-                 \"log\", \"log_err\", \"tag\", \"obj\", \"self\", \"copy\", \"sendfn\"] {\n+                 \"log\", \"log_err\", \"tag\", \"obj\", \"self\", \"copy\", \"sendfn\",\n+                 \"impl\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -941,8 +942,8 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         let e = parse_expr(p);\n         ex = ast::expr_copy(e);\n         hi = e.span.hi;\n-    } else if eat_word(p, \"self\") {\n-        expect(p, token::DOT);\n+    } else if is_word(p, \"self\") && p.look_ahead(1u) == token::DOT {\n+        p.bump(); p.bump();\n         // The rest is a call expression.\n         let f: @ast::expr = parse_self_method(p);\n         let es =\n@@ -1873,6 +1874,17 @@ fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n+fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+    let lo = p.get_last_lo_pos(), ty = parse_ty(p, false);\n+    expect(p, token::COLON);\n+    let path = parse_path(p), meths = [];\n+    expect(p, token::LBRACE);\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p)]; }\n+    ret mk_item(p, lo, p.get_last_hi_pos(),\n+                path.node.idents[vec::len(path.node.idents) - 1u],\n+                ast::item_impl(path, ty, meths), attrs);\n+}\n+\n fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n@@ -2139,14 +2151,15 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n         ret some(parse_item_mod(p, attrs));\n     } else if eat_word(p, \"native\") {\n         ret some(parse_item_native_mod(p, attrs));\n-    }\n-    if eat_word(p, \"type\") {\n+    } if eat_word(p, \"type\") {\n         ret some(parse_item_type(p, attrs));\n     } else if eat_word(p, \"tag\") {\n         ret some(parse_item_tag(p, attrs));\n     } else if is_word(p, \"obj\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         ret some(parse_item_obj(p, attrs));\n+    } else if eat_word(p, \"impl\") {\n+        ret some(parse_item_impl(p, attrs));\n     } else if eat_word(p, \"resource\") {\n         ret some(parse_item_res(p, attrs));\n     } else { ret none; }"}, {"sha": "57720d8dc14da391e7dce0d4977461c32e95629d", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -483,6 +483,22 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n+      ast::item_impl(path, ty, methods) {\n+        head(s, \"impl\");\n+        print_type(s, ty);\n+        word_space(s, \":\");\n+        print_path(s, path, false);\n+        bopen(s);\n+        for meth in methods {\n+            hardbreak_if_not_bol(s);\n+            maybe_print_comment(s, meth.span.lo);\n+            print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n+                     meth.node.ident, [], []);\n+            word(s.s, \" \");\n+            print_block(s, meth.node.meth.body);\n+        }\n+        bclose(s, item.span);\n+      }\n       ast::item_res(dt, dt_id, tps, ct_id) {\n         head(s, \"resource\");\n         word(s.s, item.ident);"}, {"sha": "35f81fe187ace991289dc9d34921480ded94daf9", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bc80025262286f2270442cea86e20e60d5430/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=888bc80025262286f2270442cea86e20e60d5430", "patch": "@@ -105,6 +105,14 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                        e, v);\n         }\n       }\n+      item_impl(path, ty, methods) {\n+        visit_path(path, e, v);\n+        visit_ty(ty, e, v);\n+        for m in methods {\n+            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n+                       e, v);\n+        }\n+      }\n     }\n }\n \n@@ -133,7 +141,8 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n             v.visit_ty(m.node.output, e, v);\n         }\n       }\n-      ty_path(p, _) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n+      ty_path(p, _) { visit_path(p, e, v); }\n+      ty_type. {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n         for tc: @spanned<constr_general_<@path, node_id>> in cs {\n@@ -149,10 +158,14 @@ fn visit_constr<E>(_operator: @path, _sp: span, _id: node_id, _e: E,\n     // default\n }\n \n+fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n+    for tp: @ty in p.node.types { v.visit_ty(tp, e, v); }\n+}\n+\n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_tag(path, children) {\n-        for tp: @ty in path.node.types { v.visit_ty(tp, e, v); }\n+        visit_path(path, e, v);\n         for child: @pat in children { v.visit_pat(child, e, v); }\n       }\n       pat_rec(fields, _) {\n@@ -286,7 +299,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       }\n       expr_field(x, _) { v.visit_expr(x, e, v); }\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n-      expr_path(p) { for tp: @ty in p.node.types { v.visit_ty(tp, e, v); } }\n+      expr_path(p) { visit_path(p, e, v); }\n       expr_fail(eo) { visit_expr_opt(eo, e, v); }\n       expr_break. { }\n       expr_cont. { }"}]}