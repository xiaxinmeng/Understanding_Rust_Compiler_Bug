{"sha": "3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZDhhYTZiODdjYjc4ODAzZDI4NGMzN2QzM2EwNjRiNTY3N2E1ZmE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-28T04:10:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T16:21:33Z"}, "message": "rbml: move the tagged encoder/decoder to librustc_metadata.", "tree": {"sha": "bc8c45dc3eecec642b1295d4d13336b72f15da24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8c45dc3eecec642b1295d4d13336b72f15da24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "html_url": "https://github.com/rust-lang/rust/commit/3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a79104e0c639be1c79bafb338ad7214802caada9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a79104e0c639be1c79bafb338ad7214802caada9", "html_url": "https://github.com/rust-lang/rust/commit/a79104e0c639be1c79bafb338ad7214802caada9"}], "stats": {"total": 3118, "additions": 1564, "deletions": 1554}, "files": [{"sha": "65259f903a99cdc3c05c94cff6dd6a45e9230eaf", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 1548, "changes": 1550, "blob_url": "https://github.com/rust-lang/rust/blob/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "patch": "@@ -8,108 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n-//! This is not intended to be used by users.\n-//!\n-//! Originally based on the Extensible Binary Markup Language\n-//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n-//! it is now a separate format tuned for the rust object metadata.\n-//!\n-//! # Encoding\n-//!\n-//! RBML document consists of the tag, length and data.\n-//! The encoded data can contain multiple RBML documents concatenated.\n-//!\n-//! **Tags** are a hint for the following data.\n-//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n-//! Tags less than 0xf0 are encoded in one literal byte.\n-//! Tags greater than 0xff are encoded in two big-endian bytes,\n-//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n-//!\n-//! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned isize, and one of the following forms:\n-//!\n-//! - `80` through `fe` for lengths up to 0x7e;\n-//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n-//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n-//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n-//!\n-//! The \"overlong\" form is allowed so that the length can be encoded\n-//! without the prior knowledge of the encoded data.\n-//! For example, the length 0 can be represented either by `80`, `40 00`,\n-//! `20 00 00` or `10 00 00 00`.\n-//! The encoder tries to minimize the length if possible.\n-//! Also, some predefined tags listed below are so commonly used that\n-//! their lengths are omitted (\"implicit length\").\n-//!\n-//! **Data** can be either binary bytes or zero or more nested RBML documents.\n-//! Nested documents cannot overflow, and should be entirely contained\n-//! within a parent document.\n-//!\n-//! # Predefined Tags\n-//!\n-//! Most RBML tags are defined by the application.\n-//! (For the rust object metadata, see also `rustc::metadata::common`.)\n-//! RBML itself does define a set of predefined tags however,\n-//! intended for the auto-serialization implementation.\n-//!\n-//! Predefined tags with an implicit length:\n-//!\n-//! - `U8`  (`00`): 1-byte unsigned integer.\n-//! - `U16` (`01`): 2-byte big endian unsigned integer.\n-//! - `U32` (`02`): 4-byte big endian unsigned integer.\n-//! - `U64` (`03`): 8-byte big endian unsigned integer.\n-//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n-//!   as long as it is no greater than the actual size.\n-//!   For example, `u8` can only be represented via the `U8` tag.\n-//!\n-//! - `I8`  (`04`): 1-byte signed integer.\n-//! - `I16` (`05`): 2-byte big endian signed integer.\n-//! - `I32` (`06`): 4-byte big endian signed integer.\n-//! - `I64` (`07`): 8-byte big endian signed integer.\n-//!   Similar to `U*` tags. Always uses two's complement encoding.\n-//!\n-//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n-//!\n-//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n-//!   Surrogate pairs or out-of-bound values are invalid.\n-//!\n-//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n-//!   IEEE 754 binary32 floating-point format.\n-//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//!\n-//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n-//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n-//!   Those two tags normally occur as the first subdocument of certain tags,\n-//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n-//!   They can be used interchangeably.\n-//!\n-//! Predefined tags with an explicit length:\n-//!\n-//! - `Str` (`10`): A UTF-8-encoded string.\n-//!\n-//! - `Enum` (`11`): An enum.\n-//!   The first subdocument should be `Sub*` tags with a variant ID.\n-//!   Subsequent subdocuments, if any, encode variant arguments.\n-//!\n-//! - `Vec` (`12`): A vector (sequence).\n-//! - `VecElt` (`13`): A vector element.\n-//!   The first subdocument should be `Sub*` tags with the number of elements.\n-//!   Subsequent subdocuments should be `VecElt` tag per each element.\n-//!\n-//! - `Map` (`14`): A map (associated array).\n-//! - `MapKey` (`15`): A key part of the map entry.\n-//! - `MapVal` (`16`): A value part of the map entry.\n-//!   The first subdocument should be `Sub*` tags with the number of entries.\n-//!   Subsequent subdocuments should be an alternating sequence of\n-//!   `MapKey` and `MapVal` tags per each entry.\n-//!\n-//! - `Opaque` (`17`): An opaque, custom-format tag.\n-//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type information.\n-//!\n-//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n+//! Skeleton of RBML (Really Bad Markup Language).\n+//! See `src/librustc_metadata/reader.rs` for more details.\n \n #![crate_name = \"rbml\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n@@ -142,93 +42,10 @@ extern crate test;\n pub mod opaque;\n pub mod leb128;\n \n-pub use self::EbmlEncoderTag::*;\n pub use self::Error::*;\n \n-use std::str;\n use std::fmt;\n \n-/// Common data structures\n-#[derive(Clone, Copy)]\n-pub struct Doc<'a> {\n-    pub data: &'a [u8],\n-    pub start: usize,\n-    pub end: usize,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc {\n-            data: data,\n-            start: 0,\n-            end: data.len(),\n-        }\n-    }\n-\n-    pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        reader::get_doc(*self, tag)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.start == self.end\n-    }\n-\n-    pub fn as_str(&self) -> &'doc str {\n-        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n-    }\n-\n-    pub fn to_string(&self) -> String {\n-        self.as_str().to_string()\n-    }\n-}\n-\n-pub struct TaggedDoc<'a> {\n-    tag: usize,\n-    pub doc: Doc<'a>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EbmlEncoderTag {\n-    // tags 00..1f are reserved for auto-serialization.\n-    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-    EsU8 = 0x00, // + 1 byte\n-    EsU16 = 0x01, // + 2 bytes\n-    EsU32 = 0x02, // + 4 bytes\n-    EsU64 = 0x03, // + 8 bytes\n-    EsI8 = 0x04, // + 1 byte\n-    EsI16 = 0x05, // + 2 bytes\n-    EsI32 = 0x06, // + 4 bytes\n-    EsI64 = 0x07, // + 8 bytes\n-    EsBool = 0x08, // + 1 byte\n-    EsChar = 0x09, // + 4 bytes\n-    EsF32 = 0x0a, // + 4 bytes\n-    EsF64 = 0x0b, // + 8 bytes\n-    EsSub8 = 0x0c, // + 1 byte\n-    EsSub32 = 0x0d, // + 4 bytes\n-    // 0x0e and 0x0f are reserved\n-    EsStr = 0x10,\n-    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt = 0x13,\n-    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey = 0x15,\n-    EsMapVal = 0x16,\n-    EsOpaque = 0x17,\n-}\n-\n-const NUM_TAGS: usize = 0x1000;\n-const NUM_IMPLICIT_TAGS: usize = 0x0e;\n-\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    1, 2, 4, 8, // EsU*\n-    1, 2, 4, 8, // ESI*\n-    1, // EsBool\n-    4, // EsChar\n-    4, 8, // EsF*\n-    1, 4, // EsSub*\n-];\n-\n #[derive(Debug)]\n pub enum Error {\n     IntTooBig(usize),\n@@ -244,1366 +61,3 @@ impl fmt::Display for Error {\n         fmt::Debug::fmt(self, f)\n     }\n }\n-// --------------------------------------\n-\n-pub mod reader {\n-    use std::char;\n-\n-    use std::isize;\n-    use std::mem::transmute;\n-\n-    use serialize;\n-\n-    use super::opaque;\n-    use super::{ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-                EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32,\n-                EsChar, EsStr, EsMapVal, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc, Error,\n-                IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN};\n-\n-    pub type DecodeResult<T> = Result<T, Error>;\n-    // rbml reading\n-\n-    macro_rules! try_or {\n-        ($e:expr, $r:expr) => (\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => {\n-                    debug!(\"ignored error: {:?}\", e);\n-                    return $r\n-                }\n-            }\n-        )\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct Res {\n-        pub val: usize,\n-        pub next: usize,\n-    }\n-\n-    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let v = data[start] as usize;\n-        if v < 0xf0 {\n-            Ok(Res {\n-                val: v,\n-                next: start + 1,\n-            })\n-        } else if v > 0xf0 {\n-            Ok(Res {\n-                val: ((v & 0xf) << 8) | data[start + 1] as usize,\n-                next: start + 2,\n-            })\n-        } else {\n-            // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-            Err(InvalidTag(v))\n-        }\n-    }\n-\n-    #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let a = data[start];\n-        if a & 0x80 != 0 {\n-            return Ok(Res {\n-                val: (a & 0x7f) as usize,\n-                next: start + 1,\n-            });\n-        }\n-        if a & 0x40 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n-                next: start + 2,\n-            });\n-        }\n-        if a & 0x20 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n-                     (data[start + 2] as usize),\n-                next: start + 3,\n-            });\n-        }\n-        if a & 0x10 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n-                     (data[start + 2] as usize) << 8 |\n-                     (data[start + 3] as usize),\n-                next: start + 4,\n-            });\n-        }\n-        Err(IntTooBig(a as usize))\n-    }\n-\n-    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        if data.len() - start < 4 {\n-            return vuint_at_slow(data, start);\n-        }\n-\n-        // Lookup table for parsing EBML Element IDs as per\n-        // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n-        // reading a big endian u32 positioned at data[start].  Using the four\n-        // most significant bits of the u32 we lookup in the table below how\n-        // the element ID should be derived from it.\n-        //\n-        // The table stores tuples (shift, mask) where shift is the number the\n-        // u32 should be right shifted with and mask is the value the right\n-        // shifted value should be masked with.  If for example the most\n-        // significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we\n-        // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n-        // significant bit is set).\n-        //\n-        // By storing the number of shifts and masks in a table instead of\n-        // checking in order if the most significant bit is set, the second\n-        // most significant bit is set etc. we can replace up to three\n-        // \"and+branch\" with a single table lookup which gives us a measured\n-        // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n-                                                       (0, 0x0fffffff),\n-                                                       (8, 0x1fffff),\n-                                                       (8, 0x1fffff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f)];\n-\n-        unsafe {\n-            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-            let val = u32::from_be(*ptr);\n-\n-            let i = (val >> 28) as usize;\n-            let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Ok(Res {\n-                val: ((val >> shift) & mask) as usize,\n-                next: start + ((32 - shift) >> 3),\n-            })\n-        }\n-    }\n-\n-    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n-        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res {\n-                val: TAG_IMPLICIT_LEN[tag.val] as usize,\n-                next: tag.next,\n-            })\n-        } else {\n-            vuint_at(data, tag.next)\n-        }\n-    }\n-\n-    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = tag_at(data, start)?;\n-        let elt_size = tag_len_at(data, elt_tag)?;\n-        let end = elt_size.next + elt_size.val;\n-        Ok(TaggedDoc {\n-            tag: elt_tag.val,\n-            doc: Doc {\n-                data: data,\n-                start: elt_size.next,\n-                end: end,\n-            },\n-        })\n-    }\n-\n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = try_or!(tag_at(d.data, pos), None);\n-            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                return Some(Doc {\n-                    data: d.data,\n-                    start: elt_size.next,\n-                    end: pos,\n-                });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n-        match maybe_get_doc(d, tg) {\n-            Some(d) => d,\n-            None => {\n-                error!(\"failed to find block with tag {:?}\", tg);\n-                panic!();\n-            }\n-        }\n-    }\n-\n-    pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-        DocsIterator { d: d }\n-    }\n-\n-    pub struct DocsIterator<'a> {\n-        d: Doc<'a>,\n-    }\n-\n-    impl<'a> Iterator for DocsIterator<'a> {\n-        type Item = (usize, Doc<'a>);\n-\n-        fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n-            if self.d.start >= self.d.end {\n-                return None;\n-            }\n-\n-            let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-            let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-\n-            let end = elt_size.next + elt_size.val;\n-            let doc = Doc {\n-                data: self.d.data,\n-                start: elt_size.next,\n-                end: end,\n-            };\n-\n-            self.d.start = end;\n-            return Some((elt_tag.val, doc));\n-        }\n-    }\n-\n-    pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n-        TaggedDocsIterator {\n-            iter: docs(d),\n-            tag: tag,\n-        }\n-    }\n-\n-    pub struct TaggedDocsIterator<'a> {\n-        iter: DocsIterator<'a>,\n-        tag: usize,\n-    }\n-\n-    impl<'a> Iterator for TaggedDocsIterator<'a> {\n-        type Item = Doc<'a>;\n-\n-        fn next(&mut self) -> Option<Doc<'a>> {\n-            while let Some((tag, doc)) = self.iter.next() {\n-                if tag == self.tag {\n-                    return Some(doc);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n-        where F: FnOnce(&[u8]) -> T\n-    {\n-        f(&d.data[d.start..d.end])\n-    }\n-\n-    pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1);\n-        d.data[d.start]\n-    }\n-\n-    pub fn doc_as_u64(d: Doc) -> u64 {\n-        if d.end >= 8 {\n-            // For performance, we read 8 big-endian bytes,\n-            // and mask off the junk if there is any. This\n-            // obviously won't work on the first 8 bytes\n-            // of a file - we will fall of the start\n-            // of the page and segfault.\n-\n-            let mut b = [0; 8];\n-            b.copy_from_slice(&d.data[d.end - 8..d.end]);\n-            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n-            let len = d.end - d.start;\n-            if len < 8 {\n-                data & ((1 << (len * 8)) - 1)\n-            } else {\n-                data\n-            }\n-        } else {\n-            let mut result = 0;\n-            for b in &d.data[d.start..d.end] {\n-                result = (result << 8) + (*b as u64);\n-            }\n-            result\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        doc_as_u64(d) as u16\n-    }\n-    #[inline]\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        doc_as_u64(d) as u32\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_i8(d: Doc) -> i8 {\n-        doc_as_u8(d) as i8\n-    }\n-    #[inline]\n-    pub fn doc_as_i16(d: Doc) -> i16 {\n-        doc_as_u16(d) as i16\n-    }\n-    #[inline]\n-    pub fn doc_as_i32(d: Doc) -> i32 {\n-        doc_as_u32(d) as i32\n-    }\n-    #[inline]\n-    pub fn doc_as_i64(d: Doc) -> i64 {\n-        doc_as_u64(d) as i64\n-    }\n-\n-    pub struct Decoder<'a> {\n-        parent: Doc<'a>,\n-        pos: usize,\n-    }\n-\n-    impl<'doc> Decoder<'doc> {\n-        pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n-            Decoder {\n-                parent: d,\n-                pos: d.start,\n-            }\n-        }\n-\n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag as usize) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                                            exp_tag,\n-                                            r_tag)));\n-            }\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            Ok(r_doc)\n-        }\n-\n-        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            let d = self.next_doc(exp_tag)?;\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f(self)?;\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(r)\n-        }\n-\n-        fn _next_sub(&mut self) -> DecodeResult<usize> {\n-            // empty vector/map optimization\n-            if self.parent.is_empty() {\n-                return Ok(0);\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if r_tag == (EsSub8 as usize) {\n-                doc_as_u8(r_doc) as usize\n-            } else if r_tag == (EsSub32 as usize) {\n-                doc_as_u32(r_doc) as usize\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n-                                             tag {:?}\",\n-                                            EsSub8,\n-                                            EsSub32,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_sub result={:?}\", r);\n-            Ok(r)\n-        }\n-\n-        // variable-length unsigned integer with different tags.\n-        // `first_tag` should be a tag for u8 or i8.\n-        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n-        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-        fn _next_int(&mut self,\n-                     first_tag: EbmlEncoderTag,\n-                     last_tag: EbmlEncoderTag)\n-                     -> DecodeResult<u64> {\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n-                match r_tag - first_tag as usize {\n-                    0 => doc_as_u8(r_doc) as u64,\n-                    1 => doc_as_u16(r_doc) as u64,\n-                    2 => doc_as_u32(r_doc) as u64,\n-                    3 => doc_as_u64(r_doc),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n-                                             found tag {:?}\",\n-                                            first_tag,\n-                                            last_tag,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n-            Ok(r)\n-        }\n-\n-        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-            where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n-        {\n-            let doc = self.next_doc(EsOpaque)?;\n-\n-            let result = {\n-                let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n-                op(&mut opaque_decoder, doc)?\n-            };\n-\n-            Ok(result)\n-        }\n-\n-        pub fn position(&self) -> usize {\n-            self.pos\n-        }\n-\n-        pub fn advance(&mut self, bytes: usize) {\n-            self.pos += bytes;\n-        }\n-    }\n-\n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        type Error = Error;\n-        fn read_nil(&mut self) -> DecodeResult<()> {\n-            Ok(())\n-        }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> {\n-            self._next_int(EsU8, EsU64)\n-        }\n-        fn read_u32(&mut self) -> DecodeResult<u32> {\n-            Ok(self._next_int(EsU8, EsU32)? as u32)\n-        }\n-        fn read_u16(&mut self) -> DecodeResult<u16> {\n-            Ok(self._next_int(EsU8, EsU16)? as u16)\n-        }\n-        fn read_u8(&mut self) -> DecodeResult<u8> {\n-            Ok(doc_as_u8(self.next_doc(EsU8)?))\n-        }\n-        fn read_usize(&mut self) -> DecodeResult<usize> {\n-            let v = self._next_int(EsU8, EsU64)?;\n-            if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as usize)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(self._next_int(EsI8, EsI64)? as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(self._next_int(EsI8, EsI32)? as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(self._next_int(EsI8, EsI16)? as i16)\n-        }\n-        fn read_i8(&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n-        }\n-        fn read_isize(&mut self) -> DecodeResult<isize> {\n-            let v = self._next_int(EsI8, EsI64)? as i64;\n-            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as isize)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(self.next_doc(EsF64)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(self.next_doc(EsF32)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(self.next_doc(EsStr)?.to_string())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum({})\", name);\n-\n-            let doc = self.next_doc(EsEnum)?;\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self)?;\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: usize,\n-                                                f: F)\n-                                                -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n-                                          `{}`\",\n-                                         tuple_len,\n-                                         len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-}\n-\n-pub mod writer {\n-    use std::mem;\n-    use std::io::prelude::*;\n-    use std::io::{self, SeekFrom, Cursor};\n-\n-    use super::opaque;\n-    use super::{EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey, EsU64, EsU32, EsU16,\n-                EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-                EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS};\n-\n-    use serialize;\n-\n-\n-    pub type EncodeResult = io::Result<()>;\n-\n-    // rbml writing\n-    pub struct Encoder<'a> {\n-        pub writer: &'a mut Cursor<Vec<u8>>,\n-        size_positions: Vec<u64>,\n-        relax_limit: u64, // do not move encoded bytes before this position\n-    }\n-\n-    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0xf0 {\n-            w.write_all(&[n as u8])\n-        } else if 0x100 <= n && n < NUM_TAGS {\n-            w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n-        }\n-    }\n-\n-    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n-        match size {\n-            1 => w.write_all(&[0x80 | (n as u8)]),\n-            2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n-            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n-            _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n-        }\n-    }\n-\n-    pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0x7f {\n-            return write_sized_vuint(w, n, 1);\n-        }\n-        if n < 0x4000 {\n-            return write_sized_vuint(w, n, 2);\n-        }\n-        if n < 0x200000 {\n-            return write_sized_vuint(w, n, 3);\n-        }\n-        if n < 0x10000000 {\n-            return write_sized_vuint(w, n, 4);\n-        }\n-        Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n-            Encoder {\n-                writer: w,\n-                size_positions: vec![],\n-                relax_limit: 0,\n-            }\n-        }\n-\n-        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n-            debug!(\"Start tag {:?}\", tag_id);\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-\n-            // Write the enum ID:\n-            write_tag(self.writer, tag_id)?;\n-\n-            // Write a placeholder four-byte size.\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.size_positions.push(cur_pos);\n-            let zeroes: &[u8] = &[0, 0, 0, 0];\n-            self.writer.write_all(zeroes)\n-        }\n-\n-        pub fn end_tag(&mut self) -> EncodeResult {\n-            let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.writer.seek(SeekFrom::Start(last_size_pos))?;\n-            let size = (cur_pos - last_size_pos - 4) as usize;\n-\n-            // relax the size encoding for small tags (bigger tags are costly to move).\n-            // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: usize = 0x100;\n-            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n-                // we can't alter the buffer in place, so have a temporary buffer\n-                let mut buf = [0u8; RELAX_MAX_SIZE];\n-                {\n-                    let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n-                    buf[..size].copy_from_slice(data);\n-                }\n-\n-                // overwrite the size and data and continue\n-                write_vuint(self.writer, size)?;\n-                self.writer.write_all(&buf[..size])?;\n-            } else {\n-                // overwrite the size with an overlong encoding and skip past the data\n-                write_sized_vuint(self.writer, size, 4)?;\n-                self.writer.seek(SeekFrom::Start(cur_pos))?;\n-            }\n-\n-            debug!(\"End tag (size = {:?})\", size);\n-            Ok(())\n-        }\n-\n-        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n-            where F: FnOnce() -> EncodeResult\n-        {\n-            self.start_tag(tag_id)?;\n-            blk()?;\n-            self.end_tag()\n-        }\n-\n-        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-            write_tag(self.writer, tag_id)?;\n-            write_vuint(self.writer, b.len())?;\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            // tagged integers are emitted in big-endian, with no\n-            // leading zeros.\n-            let leading_zero_bytes = v.leading_zeros() / 8;\n-            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_u32(tag_id, v as u32)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_u16(tag_id, v as u16)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes())\n-        }\n-\n-        // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            write_tag(self.writer, tag_id)?;\n-            self.writer.write_all(b)\n-        }\n-\n-        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v])\n-        }\n-\n-        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_raw_u64(tag_id, v as u64)\n-        }\n-\n-        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_raw_u32(tag_id, v as u32)\n-        }\n-\n-        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_raw_u16(tag_id, v as u16)\n-        }\n-\n-        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {:?}\", s);\n-            self.writer.write_all(s.as_bytes())\n-        }\n-\n-        /// Returns the current position while marking it stable, i.e.\n-        /// generated bytes so far wouldn't be affected by relaxation.\n-        pub fn mark_stable_position(&mut self) -> u64 {\n-            let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n-            if self.relax_limit < pos {\n-                self.relax_limit = pos;\n-            }\n-            pos\n-        }\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if v as u8 as usize == v {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n-            } else if v as u32 as usize == v {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::Other,\n-                                   &format!(\"length or variant id too big: {}\", v)[..]))\n-            }\n-        }\n-\n-        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n-        {\n-            self.start_tag(EsOpaque as usize)?;\n-\n-            {\n-                let mut opaque_encoder = opaque::Encoder::new(self.writer);\n-                f(&mut opaque_encoder)?;\n-            }\n-\n-            self.mark_stable_position();\n-            self.end_tag()\n-        }\n-    }\n-\n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        type Error = io::Error;\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-            self.emit_u64(v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            if v as u32 as u64 == v {\n-                self.emit_u32(v as u32)\n-            } else {\n-                self.wr_tagged_raw_u64(EsU64 as usize, v)\n-            }\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            if v as u16 as u32 == v {\n-                self.emit_u16(v as u16)\n-            } else {\n-                self.wr_tagged_raw_u32(EsU32 as usize, v)\n-            }\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            if v as u8 as u16 == v {\n-                self.emit_u8(v as u8)\n-            } else {\n-                self.wr_tagged_raw_u16(EsU16 as usize, v)\n-            }\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as usize, v)\n-        }\n-\n-        fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-            self.emit_i64(v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            if v as i32 as i64 == v {\n-                self.emit_i32(v as i32)\n-            } else {\n-                self.wr_tagged_raw_i64(EsI64 as usize, v)\n-            }\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            if v as i16 as i32 == v {\n-                self.emit_i16(v as i16)\n-            } else {\n-                self.wr_tagged_raw_i32(EsI32 as usize, v)\n-            }\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            if v as i8 as i16 == v {\n-                self.emit_i8(v as i8)\n-            } else {\n-                self.wr_tagged_raw_i16(EsI16 as usize, v)\n-            }\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as usize, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as usize, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsEnum as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self._emit_tagged_sub(v_id)?;\n-            f(self)\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: usize,\n-                                       cnt: usize,\n-                                       f: F)\n-                                       -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as usize, &[]);\n-            }\n-\n-            self.start_tag(EsVec as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsVecElt as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as usize, &[]);\n-            }\n-\n-            self.start_tag(EsMap as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsMapKey as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsMapVal as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{Doc, reader, writer};\n-\n-    use serialize::{Encodable, Decodable};\n-\n-    use std::io::Cursor;\n-\n-    #[test]\n-    fn test_vuint_at() {\n-        let data = &[\n-            0x80,\n-            0xff,\n-            0x40, 0x00,\n-            0x7f, 0xff,\n-            0x20, 0x00, 0x00,\n-            0x3f, 0xff, 0xff,\n-            0x10, 0x00, 0x00, 0x00,\n-            0x1f, 0xff, 0xff, 0xff\n-        ];\n-\n-        let mut res: reader::Res;\n-\n-        // Class A\n-        res = reader::vuint_at(data, 0).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 7) - 1);\n-        assert_eq!(res.next, 2);\n-\n-        // Class B\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 14) - 1);\n-        assert_eq!(res.next, 6);\n-\n-        // Class C\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 21) - 1);\n-        assert_eq!(res.next, 12);\n-\n-        // Class D\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 28) - 1);\n-        assert_eq!(res.next, 20);\n-    }\n-\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<isize>) {\n-            debug!(\"v == {:?}\", v);\n-            let mut wr = Cursor::new(Vec::new());\n-            {\n-                let mut rbml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut rbml_w);\n-            }\n-            let rbml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(rbml_doc);\n-            let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {:?}\", v1);\n-            assert_eq!(v, v1);\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(non_snake_case)]\n-    use test::Bencher;\n-    use super::reader;\n-\n-    #[bench]\n-    pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               0 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               1 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               0 => 0x10,\n-                               3 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               1 => 0x10,\n-                               0 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-}"}, {"sha": "55ab2afe4454d88977671ac505a0ade0f159f77b", "filename": "src/librbml/opaque.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrbml%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrbml%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fopaque.rs?ref=3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use Error as DecodeError;\n-use writer::EncodeResult;\n use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n use std::io::{self, Write};\n use serialize;\n@@ -18,6 +17,8 @@ use serialize;\n // Encoder\n // -----------------------------------------------------------------------------\n \n+pub type EncodeResult = io::Result<()>;\n+\n pub struct Encoder<'a> {\n     pub cursor: &'a mut io::Cursor<Vec<u8>>,\n }\n@@ -255,10 +256,6 @@ impl<'a> Encoder<'a> {\n     pub fn position(&self) -> usize {\n         self.cursor.position() as usize\n     }\n-\n-    pub fn from_rbml<'b: 'c, 'c>(rbml: &'c mut ::writer::Encoder<'b>) -> Encoder<'c> {\n-        Encoder { cursor: rbml.writer }\n-    }\n }\n \n // -----------------------------------------------------------------------------"}, {"sha": "d0d3d822f860583fa90a593dd4b8a3a8adf7199f", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "patch": "@@ -27,13 +27,13 @@\n #![feature(rustc_macro_internals)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![cfg_attr(test, feature(test))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n extern crate syntax_pos;\n extern crate flate;\n-extern crate rbml;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n@@ -46,6 +46,18 @@ extern crate rustc_llvm;\n extern crate rustc_macro;\n extern crate rustc_const_math;\n \n+#[cfg(test)]\n+extern crate test;\n+\n+pub mod rbml {\n+    pub extern crate rbml as rbml_crate;\n+    pub use self::rbml_crate::{Error, leb128, opaque};\n+\n+    pub mod writer;\n+    pub mod reader;\n+    pub use self::reader::Doc;\n+}\n+\n pub use rustc::middle;\n \n #[macro_use]"}, {"sha": "0950372477e46d7399d3ce0157b5b8afa2f8c118", "filename": "src/librustc_metadata/rbml/reader.rs", "status": "added", "additions": 1025, "deletions": 0, "changes": 1025, "blob_url": "https://github.com/rust-lang/rust/blob/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Frbml%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Freader.rs?ref=3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "patch": "@@ -0,0 +1,1025 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n+//! This is not intended to be used by users.\n+//!\n+//! Originally based on the Extensible Binary Markup Language\n+//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n+//! it is now a separate format tuned for the rust object metadata.\n+//!\n+//! # Encoding\n+//!\n+//! RBML document consists of the tag, length and data.\n+//! The encoded data can contain multiple RBML documents concatenated.\n+//!\n+//! **Tags** are a hint for the following data.\n+//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n+//! Tags less than 0xf0 are encoded in one literal byte.\n+//! Tags greater than 0xff are encoded in two big-endian bytes,\n+//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n+//!\n+//! **Lengths** encode the length of the following data.\n+//! It is a variable-length unsigned isize, and one of the following forms:\n+//!\n+//! - `80` through `fe` for lengths up to 0x7e;\n+//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n+//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n+//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n+//!\n+//! The \"overlong\" form is allowed so that the length can be encoded\n+//! without the prior knowledge of the encoded data.\n+//! For example, the length 0 can be represented either by `80`, `40 00`,\n+//! `20 00 00` or `10 00 00 00`.\n+//! The encoder tries to minimize the length if possible.\n+//! Also, some predefined tags listed below are so commonly used that\n+//! their lengths are omitted (\"implicit length\").\n+//!\n+//! **Data** can be either binary bytes or zero or more nested RBML documents.\n+//! Nested documents cannot overflow, and should be entirely contained\n+//! within a parent document.\n+//!\n+//! # Predefined Tags\n+//!\n+//! Most RBML tags are defined by the application.\n+//! (For the rust object metadata, see also `rustc::metadata::common`.)\n+//! RBML itself does define a set of predefined tags however,\n+//! intended for the auto-serialization implementation.\n+//!\n+//! Predefined tags with an implicit length:\n+//!\n+//! - `U8`  (`00`): 1-byte unsigned integer.\n+//! - `U16` (`01`): 2-byte big endian unsigned integer.\n+//! - `U32` (`02`): 4-byte big endian unsigned integer.\n+//! - `U64` (`03`): 8-byte big endian unsigned integer.\n+//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n+//!   as long as it is no greater than the actual size.\n+//!   For example, `u8` can only be represented via the `U8` tag.\n+//!\n+//! - `I8`  (`04`): 1-byte signed integer.\n+//! - `I16` (`05`): 2-byte big endian signed integer.\n+//! - `I32` (`06`): 4-byte big endian signed integer.\n+//! - `I64` (`07`): 8-byte big endian signed integer.\n+//!   Similar to `U*` tags. Always uses two's complement encoding.\n+//!\n+//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n+//!\n+//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n+//!   Surrogate pairs or out-of-bound values are invalid.\n+//!\n+//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n+//!   IEEE 754 binary32 floating-point format.\n+//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n+//!   IEEE 754 binary64 floating-point format.\n+//!\n+//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n+//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n+//!   Those two tags normally occur as the first subdocument of certain tags,\n+//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n+//!   They can be used interchangeably.\n+//!\n+//! Predefined tags with an explicit length:\n+//!\n+//! - `Str` (`10`): A UTF-8-encoded string.\n+//!\n+//! - `Enum` (`11`): An enum.\n+//!   The first subdocument should be `Sub*` tags with a variant ID.\n+//!   Subsequent subdocuments, if any, encode variant arguments.\n+//!\n+//! - `Vec` (`12`): A vector (sequence).\n+//! - `VecElt` (`13`): A vector element.\n+//!   The first subdocument should be `Sub*` tags with the number of elements.\n+//!   Subsequent subdocuments should be `VecElt` tag per each element.\n+//!\n+//! - `Map` (`14`): A map (associated array).\n+//! - `MapKey` (`15`): A key part of the map entry.\n+//! - `MapVal` (`16`): A value part of the map entry.\n+//!   The first subdocument should be `Sub*` tags with the number of entries.\n+//!   Subsequent subdocuments should be an alternating sequence of\n+//!   `MapKey` and `MapVal` tags per each entry.\n+//!\n+//! - `Opaque` (`17`): An opaque, custom-format tag.\n+//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n+//!   Rustc typically uses this to encode type information.\n+//!\n+//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n+\n+#[cfg(test)]\n+use test::Bencher;\n+\n+pub use self::EbmlEncoderTag::*;\n+\n+use std::char;\n+use std::isize;\n+use std::mem::transmute;\n+use std::str;\n+\n+use rustc_serialize as serialize;\n+\n+use rbml::opaque;\n+use rbml::Error;\n+use rbml::Error::*;\n+\n+#[derive(Clone, Copy)]\n+pub struct Doc<'a> {\n+    pub data: &'a [u8],\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n+impl<'doc> Doc<'doc> {\n+    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n+        Doc {\n+            data: data,\n+            start: 0,\n+            end: data.len(),\n+        }\n+    }\n+\n+    pub fn get(&self, tag: usize) -> Doc<'doc> {\n+        get_doc(*self, tag)\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.start == self.end\n+    }\n+\n+    pub fn as_str(&self) -> &'doc str {\n+        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n+    }\n+\n+    pub fn to_string(&self) -> String {\n+        self.as_str().to_string()\n+    }\n+}\n+\n+pub struct TaggedDoc<'a> {\n+    tag: usize,\n+    pub doc: Doc<'a>,\n+}\n+\n+pub type DecodeResult<T> = Result<T, Error>;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum EbmlEncoderTag {\n+    // tags 00..1f are reserved for auto-serialization.\n+    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n+    EsU8 = 0x00, // + 1 byte\n+    EsU16 = 0x01, // + 2 bytes\n+    EsU32 = 0x02, // + 4 bytes\n+    EsU64 = 0x03, // + 8 bytes\n+    EsI8 = 0x04, // + 1 byte\n+    EsI16 = 0x05, // + 2 bytes\n+    EsI32 = 0x06, // + 4 bytes\n+    EsI64 = 0x07, // + 8 bytes\n+    EsBool = 0x08, // + 1 byte\n+    EsChar = 0x09, // + 4 bytes\n+    EsF32 = 0x0a, // + 4 bytes\n+    EsF64 = 0x0b, // + 8 bytes\n+    EsSub8 = 0x0c, // + 1 byte\n+    EsSub32 = 0x0d, // + 4 bytes\n+    // 0x0e and 0x0f are reserved\n+    EsStr = 0x10,\n+    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n+    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n+    EsVecElt = 0x13,\n+    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n+    EsMapKey = 0x15,\n+    EsMapVal = 0x16,\n+    EsOpaque = 0x17,\n+}\n+\n+pub const NUM_IMPLICIT_TAGS: usize = 0x0e;\n+\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n+    1, 2, 4, 8, // EsU*\n+    1, 2, 4, 8, // ESI*\n+    1, // EsBool\n+    4, // EsChar\n+    4, 8, // EsF*\n+    1, 4, // EsSub*\n+];\n+\n+// rbml reading\n+\n+macro_rules! try_or {\n+    ($e:expr, $r:expr) => (\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => {\n+                debug!(\"ignored error: {:?}\", e);\n+                return $r\n+            }\n+        }\n+    )\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Res {\n+    pub val: usize,\n+    pub next: usize,\n+}\n+\n+pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+    let v = data[start] as usize;\n+    if v < 0xf0 {\n+        Ok(Res {\n+            val: v,\n+            next: start + 1,\n+        })\n+    } else if v > 0xf0 {\n+        Ok(Res {\n+            val: ((v & 0xf) << 8) | data[start + 1] as usize,\n+            next: start + 2,\n+        })\n+    } else {\n+        // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n+        Err(InvalidTag(v))\n+    }\n+}\n+\n+#[inline(never)]\n+fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n+    let a = data[start];\n+    if a & 0x80 != 0 {\n+        return Ok(Res {\n+            val: (a & 0x7f) as usize,\n+            next: start + 1,\n+        });\n+    }\n+    if a & 0x40 != 0 {\n+        return Ok(Res {\n+            val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n+            next: start + 2,\n+        });\n+    }\n+    if a & 0x20 != 0 {\n+        return Ok(Res {\n+            val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n+                 (data[start + 2] as usize),\n+            next: start + 3,\n+        });\n+    }\n+    if a & 0x10 != 0 {\n+        return Ok(Res {\n+            val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n+                 (data[start + 2] as usize) << 8 |\n+                 (data[start + 3] as usize),\n+            next: start + 4,\n+        });\n+    }\n+    Err(IntTooBig(a as usize))\n+}\n+\n+pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+    if data.len() - start < 4 {\n+        return vuint_at_slow(data, start);\n+    }\n+\n+    // Lookup table for parsing EBML Element IDs as per\n+    // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n+    // reading a big endian u32 positioned at data[start].  Using the four\n+    // most significant bits of the u32 we lookup in the table below how\n+    // the element ID should be derived from it.\n+    //\n+    // The table stores tuples (shift, mask) where shift is the number the\n+    // u32 should be right shifted with and mask is the value the right\n+    // shifted value should be masked with.  If for example the most\n+    // significant bit is set this means it's a class A ID and the u32\n+    // should be right shifted with 24 and masked with 0x7f. Therefore we\n+    // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n+    // significant bit is set).\n+    //\n+    // By storing the number of shifts and masks in a table instead of\n+    // checking in order if the most significant bit is set, the second\n+    // most significant bit is set etc. we can replace up to three\n+    // \"and+branch\" with a single table lookup which gives us a measured\n+    // speedup of around 2x on x86_64.\n+    static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n+                                                   (0, 0x0fffffff),\n+                                                   (8, 0x1fffff),\n+                                                   (8, 0x1fffff),\n+                                                   (16, 0x3fff),\n+                                                   (16, 0x3fff),\n+                                                   (16, 0x3fff),\n+                                                   (16, 0x3fff),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f),\n+                                                   (24, 0x7f)];\n+\n+    unsafe {\n+        let ptr = data.as_ptr().offset(start as isize) as *const u32;\n+        let val = u32::from_be(*ptr);\n+\n+        let i = (val >> 28) as usize;\n+        let (shift, mask) = SHIFT_MASK_TABLE[i];\n+        Ok(Res {\n+            val: ((val >> shift) & mask) as usize,\n+            next: start + ((32 - shift) >> 3),\n+        })\n+    }\n+}\n+\n+pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n+    if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n+        Ok(Res {\n+            val: TAG_IMPLICIT_LEN[tag.val] as usize,\n+            next: tag.next,\n+        })\n+    } else {\n+        vuint_at(data, tag.next)\n+    }\n+}\n+\n+pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n+    let elt_tag = tag_at(data, start)?;\n+    let elt_size = tag_len_at(data, elt_tag)?;\n+    let end = elt_size.next + elt_size.val;\n+    Ok(TaggedDoc {\n+        tag: elt_tag.val,\n+        doc: Doc {\n+            data: data,\n+            start: elt_size.next,\n+            end: end,\n+        },\n+    })\n+}\n+\n+pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n+    let mut pos = d.start;\n+    while pos < d.end {\n+        let elt_tag = try_or!(tag_at(d.data, pos), None);\n+        let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n+        pos = elt_size.next + elt_size.val;\n+        if elt_tag.val == tg {\n+            return Some(Doc {\n+                data: d.data,\n+                start: elt_size.next,\n+                end: pos,\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n+    match maybe_get_doc(d, tg) {\n+        Some(d) => d,\n+        None => {\n+            error!(\"failed to find block with tag {:?}\", tg);\n+            panic!();\n+        }\n+    }\n+}\n+\n+pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n+    DocsIterator { d: d }\n+}\n+\n+pub struct DocsIterator<'a> {\n+    d: Doc<'a>,\n+}\n+\n+impl<'a> Iterator for DocsIterator<'a> {\n+    type Item = (usize, Doc<'a>);\n+\n+    fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n+        if self.d.start >= self.d.end {\n+            return None;\n+        }\n+\n+        let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n+            self.d.start = self.d.end;\n+            None\n+        });\n+        let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n+            self.d.start = self.d.end;\n+            None\n+        });\n+\n+        let end = elt_size.next + elt_size.val;\n+        let doc = Doc {\n+            data: self.d.data,\n+            start: elt_size.next,\n+            end: end,\n+        };\n+\n+        self.d.start = end;\n+        return Some((elt_tag.val, doc));\n+    }\n+}\n+\n+pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n+    TaggedDocsIterator {\n+        iter: docs(d),\n+        tag: tag,\n+    }\n+}\n+\n+pub struct TaggedDocsIterator<'a> {\n+    iter: DocsIterator<'a>,\n+    tag: usize,\n+}\n+\n+impl<'a> Iterator for TaggedDocsIterator<'a> {\n+    type Item = Doc<'a>;\n+\n+    fn next(&mut self) -> Option<Doc<'a>> {\n+        while let Some((tag, doc)) = self.iter.next() {\n+            if tag == self.tag {\n+                return Some(doc);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n+    where F: FnOnce(&[u8]) -> T\n+{\n+    f(&d.data[d.start..d.end])\n+}\n+\n+pub fn doc_as_u8(d: Doc) -> u8 {\n+    assert_eq!(d.end, d.start + 1);\n+    d.data[d.start]\n+}\n+\n+pub fn doc_as_u64(d: Doc) -> u64 {\n+    if d.end >= 8 {\n+        // For performance, we read 8 big-endian bytes,\n+        // and mask off the junk if there is any. This\n+        // obviously won't work on the first 8 bytes\n+        // of a file - we will fall of the start\n+        // of the page and segfault.\n+\n+        let mut b = [0; 8];\n+        b.copy_from_slice(&d.data[d.end - 8..d.end]);\n+        let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n+        let len = d.end - d.start;\n+        if len < 8 {\n+            data & ((1 << (len * 8)) - 1)\n+        } else {\n+            data\n+        }\n+    } else {\n+        let mut result = 0;\n+        for b in &d.data[d.start..d.end] {\n+            result = (result << 8) + (*b as u64);\n+        }\n+        result\n+    }\n+}\n+\n+#[inline]\n+pub fn doc_as_u16(d: Doc) -> u16 {\n+    doc_as_u64(d) as u16\n+}\n+#[inline]\n+pub fn doc_as_u32(d: Doc) -> u32 {\n+    doc_as_u64(d) as u32\n+}\n+\n+#[inline]\n+pub fn doc_as_i8(d: Doc) -> i8 {\n+    doc_as_u8(d) as i8\n+}\n+#[inline]\n+pub fn doc_as_i16(d: Doc) -> i16 {\n+    doc_as_u16(d) as i16\n+}\n+#[inline]\n+pub fn doc_as_i32(d: Doc) -> i32 {\n+    doc_as_u32(d) as i32\n+}\n+#[inline]\n+pub fn doc_as_i64(d: Doc) -> i64 {\n+    doc_as_u64(d) as i64\n+}\n+\n+pub struct Decoder<'a> {\n+    parent: Doc<'a>,\n+    pos: usize,\n+}\n+\n+impl<'doc> Decoder<'doc> {\n+    pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n+        Decoder {\n+            parent: d,\n+            pos: d.start,\n+        }\n+    }\n+\n+    fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n+        debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n+        if self.pos >= self.parent.end {\n+            return Err(Expected(format!(\"no more documents in current node!\")));\n+        }\n+        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n+        debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n+               self.parent.start,\n+               self.parent.end,\n+               self.pos,\n+               r_tag,\n+               r_doc.start,\n+               r_doc.end);\n+        if r_tag != (exp_tag as usize) {\n+            return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                                        exp_tag,\n+                                        r_tag)));\n+        }\n+        if r_doc.end > self.parent.end {\n+            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                         {:#x}\",\n+                                        r_doc.end,\n+                                        self.parent.end)));\n+        }\n+        self.pos = r_doc.end;\n+        Ok(r_doc)\n+    }\n+\n+    fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        let d = self.next_doc(exp_tag)?;\n+        let old_parent = self.parent;\n+        let old_pos = self.pos;\n+        self.parent = d;\n+        self.pos = d.start;\n+        let r = f(self)?;\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        Ok(r)\n+    }\n+\n+    fn _next_sub(&mut self) -> DecodeResult<usize> {\n+        // empty vector/map optimization\n+        if self.parent.is_empty() {\n+            return Ok(0);\n+        }\n+\n+        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n+        let r = if r_tag == (EsSub8 as usize) {\n+            doc_as_u8(r_doc) as usize\n+        } else if r_tag == (EsSub32 as usize) {\n+            doc_as_u32(r_doc) as usize\n+        } else {\n+            return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n+                                         tag {:?}\",\n+                                        EsSub8,\n+                                        EsSub32,\n+                                        r_tag)));\n+        };\n+        if r_doc.end > self.parent.end {\n+            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                         {:#x}\",\n+                                        r_doc.end,\n+                                        self.parent.end)));\n+        }\n+        self.pos = r_doc.end;\n+        debug!(\"_next_sub result={:?}\", r);\n+        Ok(r)\n+    }\n+\n+    // variable-length unsigned integer with different tags.\n+    // `first_tag` should be a tag for u8 or i8.\n+    // `last_tag` should be the largest allowed integer tag with the matching signedness.\n+    // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n+    fn _next_int(&mut self,\n+                 first_tag: EbmlEncoderTag,\n+                 last_tag: EbmlEncoderTag)\n+                 -> DecodeResult<u64> {\n+        if self.pos >= self.parent.end {\n+            return Err(Expected(format!(\"no more documents in current node!\")));\n+        }\n+\n+        let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n+        let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n+            match r_tag - first_tag as usize {\n+                0 => doc_as_u8(r_doc) as u64,\n+                1 => doc_as_u16(r_doc) as u64,\n+                2 => doc_as_u32(r_doc) as u64,\n+                3 => doc_as_u64(r_doc),\n+                _ => unreachable!(),\n+            }\n+        } else {\n+            return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n+                                         found tag {:?}\",\n+                                        first_tag,\n+                                        last_tag,\n+                                        r_tag)));\n+        };\n+        if r_doc.end > self.parent.end {\n+            return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n+                                         {:#x}\",\n+                                        r_doc.end,\n+                                        self.parent.end)));\n+        }\n+        self.pos = r_doc.end;\n+        debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n+        Ok(r)\n+    }\n+\n+    pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n+        where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n+    {\n+        let doc = self.next_doc(EsOpaque)?;\n+\n+        let result = {\n+            let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n+            op(&mut opaque_decoder, doc)?\n+        };\n+\n+        Ok(result)\n+    }\n+\n+    pub fn position(&self) -> usize {\n+        self.pos\n+    }\n+\n+    pub fn advance(&mut self, bytes: usize) {\n+        self.pos += bytes;\n+    }\n+}\n+\n+impl<'doc> serialize::Decoder for Decoder<'doc> {\n+    type Error = Error;\n+    fn read_nil(&mut self) -> DecodeResult<()> {\n+        Ok(())\n+    }\n+\n+    fn read_u64(&mut self) -> DecodeResult<u64> {\n+        self._next_int(EsU8, EsU64)\n+    }\n+    fn read_u32(&mut self) -> DecodeResult<u32> {\n+        Ok(self._next_int(EsU8, EsU32)? as u32)\n+    }\n+    fn read_u16(&mut self) -> DecodeResult<u16> {\n+        Ok(self._next_int(EsU8, EsU16)? as u16)\n+    }\n+    fn read_u8(&mut self) -> DecodeResult<u8> {\n+        Ok(doc_as_u8(self.next_doc(EsU8)?))\n+    }\n+    fn read_usize(&mut self) -> DecodeResult<usize> {\n+        let v = self._next_int(EsU8, EsU64)?;\n+        if v > (::std::usize::MAX as u64) {\n+            Err(IntTooBig(v as usize))\n+        } else {\n+            Ok(v as usize)\n+        }\n+    }\n+\n+    fn read_i64(&mut self) -> DecodeResult<i64> {\n+        Ok(self._next_int(EsI8, EsI64)? as i64)\n+    }\n+    fn read_i32(&mut self) -> DecodeResult<i32> {\n+        Ok(self._next_int(EsI8, EsI32)? as i32)\n+    }\n+    fn read_i16(&mut self) -> DecodeResult<i16> {\n+        Ok(self._next_int(EsI8, EsI16)? as i16)\n+    }\n+    fn read_i8(&mut self) -> DecodeResult<i8> {\n+        Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n+    }\n+    fn read_isize(&mut self) -> DecodeResult<isize> {\n+        let v = self._next_int(EsI8, EsI64)? as i64;\n+        if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n+            debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+            Err(IntTooBig(v as usize))\n+        } else {\n+            Ok(v as isize)\n+        }\n+    }\n+\n+    fn read_bool(&mut self) -> DecodeResult<bool> {\n+        Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n+    }\n+\n+    fn read_f64(&mut self) -> DecodeResult<f64> {\n+        let bits = doc_as_u64(self.next_doc(EsF64)?);\n+        Ok(unsafe { transmute(bits) })\n+    }\n+    fn read_f32(&mut self) -> DecodeResult<f32> {\n+        let bits = doc_as_u32(self.next_doc(EsF32)?);\n+        Ok(unsafe { transmute(bits) })\n+    }\n+    fn read_char(&mut self) -> DecodeResult<char> {\n+        Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n+    }\n+    fn read_str(&mut self) -> DecodeResult<String> {\n+        Ok(self.next_doc(EsStr)?.to_string())\n+    }\n+\n+    // Compound types:\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_enum({})\", name);\n+\n+        let doc = self.next_doc(EsEnum)?;\n+\n+        let (old_parent, old_pos) = (self.parent, self.pos);\n+        self.parent = doc;\n+        self.pos = self.parent.start;\n+\n+        let result = f(self)?;\n+\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        Ok(result)\n+    }\n+\n+    fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n+        where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+    {\n+        debug!(\"read_enum_variant()\");\n+        let idx = self._next_sub()?;\n+        debug!(\"  idx={}\", idx);\n+\n+        f(self, idx)\n+    }\n+\n+    fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_enum_variant_arg(idx={})\", idx);\n+        f(self)\n+    }\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n+        where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+    {\n+        debug!(\"read_enum_struct_variant()\");\n+        let idx = self._next_sub()?;\n+        debug!(\"  idx={}\", idx);\n+\n+        f(self, idx)\n+    }\n+\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                            name: &str,\n+                                            idx: usize,\n+                                            f: F)\n+                                            -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+        f(self)\n+    }\n+\n+    fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_struct(name={})\", name);\n+        f(self)\n+    }\n+\n+    fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n+        f(self)\n+    }\n+\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_tuple()\");\n+        self.read_seq(move |d, len| {\n+            if len == tuple_len {\n+                f(d)\n+            } else {\n+                Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n+                                      `{}`\",\n+                                     tuple_len,\n+                                     len)))\n+            }\n+        })\n+    }\n+\n+    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_tuple_arg(idx={})\", idx);\n+        self.read_seq_elt(idx, f)\n+    }\n+\n+    fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_tuple_struct(name={})\", name);\n+        self.read_tuple(len, f)\n+    }\n+\n+    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n+        self.read_tuple_arg(idx, f)\n+    }\n+\n+    fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n+        where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n+    {\n+        debug!(\"read_option()\");\n+        self.read_enum(\"Option\", move |this| {\n+            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n+                match idx {\n+                    0 => f(this, false),\n+                    1 => f(this, true),\n+                    _ => Err(Expected(format!(\"Expected None or Some\"))),\n+                }\n+            })\n+        })\n+    }\n+\n+    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+    {\n+        debug!(\"read_seq()\");\n+        self.push_doc(EsVec, move |d| {\n+            let len = d._next_sub()?;\n+            debug!(\"  len={}\", len);\n+            f(d, len)\n+        })\n+    }\n+\n+    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_seq_elt(idx={})\", idx);\n+        self.push_doc(EsVecElt, f)\n+    }\n+\n+    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n+    {\n+        debug!(\"read_map()\");\n+        self.push_doc(EsMap, move |d| {\n+            let len = d._next_sub()?;\n+            debug!(\"  len={}\", len);\n+            f(d, len)\n+        })\n+    }\n+\n+    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_map_elt_key(idx={})\", idx);\n+        self.push_doc(EsMapKey, f)\n+    }\n+\n+    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+        where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n+    {\n+        debug!(\"read_map_elt_val(idx={})\", idx);\n+        self.push_doc(EsMapVal, f)\n+    }\n+\n+    fn error(&mut self, err: &str) -> Error {\n+        ApplicationError(err.to_string())\n+    }\n+}\n+\n+#[test]\n+fn test_vuint_at() {\n+    let data = &[\n+        0x80,\n+        0xff,\n+        0x40, 0x00,\n+        0x7f, 0xff,\n+        0x20, 0x00, 0x00,\n+        0x3f, 0xff, 0xff,\n+        0x10, 0x00, 0x00, 0x00,\n+        0x1f, 0xff, 0xff, 0xff\n+    ];\n+\n+    let mut res: Res;\n+\n+    // Class A\n+    res = vuint_at(data, 0).unwrap();\n+    assert_eq!(res.val, 0);\n+    assert_eq!(res.next, 1);\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, (1 << 7) - 1);\n+    assert_eq!(res.next, 2);\n+\n+    // Class B\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, 0);\n+    assert_eq!(res.next, 4);\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, (1 << 14) - 1);\n+    assert_eq!(res.next, 6);\n+\n+    // Class C\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, 0);\n+    assert_eq!(res.next, 9);\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, (1 << 21) - 1);\n+    assert_eq!(res.next, 12);\n+\n+    // Class D\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, 0);\n+    assert_eq!(res.next, 16);\n+    res = vuint_at(data, res.next).unwrap();\n+    assert_eq!(res.val, (1 << 28) - 1);\n+    assert_eq!(res.next, 20);\n+}\n+\n+#[bench]\n+pub fn vuint_at_A_aligned(b: &mut Bencher) {\n+    let data = (0..4 * 100)\n+                   .map(|i| {\n+                       match i % 2 {\n+                           0 => 0x80,\n+                           _ => i as u8,\n+                       }\n+                   })\n+                   .collect::<Vec<_>>();\n+    let mut sum = 0;\n+    b.iter(|| {\n+        let mut i = 0;\n+        while i < data.len() {\n+            sum += vuint_at(&data, i).unwrap().val;\n+            i += 4;\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n+    let data = (0..4 * 100 + 1)\n+                   .map(|i| {\n+                       match i % 2 {\n+                           1 => 0x80,\n+                           _ => i as u8,\n+                       }\n+                   })\n+                   .collect::<Vec<_>>();\n+    let mut sum = 0;\n+    b.iter(|| {\n+        let mut i = 1;\n+        while i < data.len() {\n+            sum += vuint_at(&data, i).unwrap().val;\n+            i += 4;\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn vuint_at_D_aligned(b: &mut Bencher) {\n+    let data = (0..4 * 100)\n+                   .map(|i| {\n+                       match i % 4 {\n+                           0 => 0x10,\n+                           3 => i as u8,\n+                           _ => 0,\n+                       }\n+                   })\n+                   .collect::<Vec<_>>();\n+    let mut sum = 0;\n+    b.iter(|| {\n+        let mut i = 0;\n+        while i < data.len() {\n+            sum += vuint_at(&data, i).unwrap().val;\n+            i += 4;\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n+    let data = (0..4 * 100 + 1)\n+                   .map(|i| {\n+                       match i % 4 {\n+                           1 => 0x10,\n+                           0 => i as u8,\n+                           _ => 0,\n+                       }\n+                   })\n+                   .collect::<Vec<_>>();\n+    let mut sum = 0;\n+    b.iter(|| {\n+        let mut i = 1;\n+        while i < data.len() {\n+            sum += vuint_at(&data, i).unwrap().val;\n+            i += 4;\n+        }\n+    });\n+}"}, {"sha": "d6f4b0d03f22c52863c1cb2b41517e799b3a3e79", "filename": "src/librustc_metadata/rbml/writer.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ad8aa6b87cb78803d284c37d33a064b5677a5fa/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frbml%2Fwriter.rs?ref=3ad8aa6b87cb78803d284c37d33a064b5677a5fa", "patch": "@@ -0,0 +1,522 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use std::io::prelude::*;\n+use std::io::{self, SeekFrom, Cursor};\n+\n+use rbml::opaque;\n+use rbml::reader::EbmlEncoderTag::*;\n+use rbml::reader::NUM_IMPLICIT_TAGS;\n+\n+use rustc_serialize as serialize;\n+\n+pub type EncodeResult = io::Result<()>;\n+\n+// rbml writing\n+pub struct Encoder<'a> {\n+    pub writer: &'a mut Cursor<Vec<u8>>,\n+    size_positions: Vec<u64>,\n+    relax_limit: u64, // do not move encoded bytes before this position\n+}\n+\n+const NUM_TAGS: usize = 0x1000;\n+\n+fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n+    if n < 0xf0 {\n+        w.write_all(&[n as u8])\n+    } else if 0x100 <= n && n < NUM_TAGS {\n+        w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n+    } else {\n+        Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n+    }\n+}\n+\n+fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n+    match size {\n+        1 => w.write_all(&[0x80 | (n as u8)]),\n+        2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n+        3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n+        4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n+        _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n+    }\n+}\n+\n+pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n+    if n < 0x7f {\n+        return write_sized_vuint(w, n, 1);\n+    }\n+    if n < 0x4000 {\n+        return write_sized_vuint(w, n, 2);\n+    }\n+    if n < 0x200000 {\n+        return write_sized_vuint(w, n, 3);\n+    }\n+    if n < 0x10000000 {\n+        return write_sized_vuint(w, n, 4);\n+    }\n+    Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n+}\n+\n+impl<'a> Encoder<'a> {\n+    pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n+        Encoder {\n+            writer: w,\n+            size_positions: vec![],\n+            relax_limit: 0,\n+        }\n+    }\n+\n+    pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n+        debug!(\"Start tag {:?}\", tag_id);\n+        assert!(tag_id >= NUM_IMPLICIT_TAGS);\n+\n+        // Write the enum ID:\n+        write_tag(self.writer, tag_id)?;\n+\n+        // Write a placeholder four-byte size.\n+        let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n+        self.size_positions.push(cur_pos);\n+        let zeroes: &[u8] = &[0, 0, 0, 0];\n+        self.writer.write_all(zeroes)\n+    }\n+\n+    pub fn end_tag(&mut self) -> EncodeResult {\n+        let last_size_pos = self.size_positions.pop().unwrap();\n+        let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n+        self.writer.seek(SeekFrom::Start(last_size_pos))?;\n+        let size = (cur_pos - last_size_pos - 4) as usize;\n+\n+        // relax the size encoding for small tags (bigger tags are costly to move).\n+        // we should never try to move the stable positions, however.\n+        const RELAX_MAX_SIZE: usize = 0x100;\n+        if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n+            // we can't alter the buffer in place, so have a temporary buffer\n+            let mut buf = [0u8; RELAX_MAX_SIZE];\n+            {\n+                let last_size_pos = last_size_pos as usize;\n+                let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n+                buf[..size].copy_from_slice(data);\n+            }\n+\n+            // overwrite the size and data and continue\n+            write_vuint(self.writer, size)?;\n+            self.writer.write_all(&buf[..size])?;\n+        } else {\n+            // overwrite the size with an overlong encoding and skip past the data\n+            write_sized_vuint(self.writer, size, 4)?;\n+            self.writer.seek(SeekFrom::Start(cur_pos))?;\n+        }\n+\n+        debug!(\"End tag (size = {:?})\", size);\n+        Ok(())\n+    }\n+\n+    pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n+        where F: FnOnce() -> EncodeResult\n+    {\n+        self.start_tag(tag_id)?;\n+        blk()?;\n+        self.end_tag()\n+    }\n+\n+    pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n+        assert!(tag_id >= NUM_IMPLICIT_TAGS);\n+        write_tag(self.writer, tag_id)?;\n+        write_vuint(self.writer, b.len())?;\n+        self.writer.write_all(b)\n+    }\n+\n+    pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n+        let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n+        // tagged integers are emitted in big-endian, with no\n+        // leading zeros.\n+        let leading_zero_bytes = v.leading_zeros() / 8;\n+        self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n+        self.wr_tagged_u64(tag_id, v as u64)\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n+        self.wr_tagged_u64(tag_id, v as u64)\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n+        self.wr_tagged_bytes(tag_id, &[v])\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n+        self.wr_tagged_u64(tag_id, v as u64)\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n+        self.wr_tagged_u32(tag_id, v as u32)\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n+        self.wr_tagged_u16(tag_id, v as u16)\n+    }\n+\n+    #[inline]\n+    pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n+        self.wr_tagged_bytes(tag_id, &[v as u8])\n+    }\n+\n+    pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n+        self.wr_tagged_bytes(tag_id, v.as_bytes())\n+    }\n+\n+    // for auto-serialization\n+    fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n+        write_tag(self.writer, tag_id)?;\n+        self.writer.write_all(b)\n+    }\n+\n+    fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n+        let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n+        self.wr_tagged_raw_bytes(tag_id, &bytes)\n+    }\n+\n+    fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n+        let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n+        self.wr_tagged_raw_bytes(tag_id, &bytes)\n+    }\n+\n+    fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n+        let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n+        self.wr_tagged_raw_bytes(tag_id, &bytes)\n+    }\n+\n+    fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n+        self.wr_tagged_raw_bytes(tag_id, &[v])\n+    }\n+\n+    fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n+        self.wr_tagged_raw_u64(tag_id, v as u64)\n+    }\n+\n+    fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n+        self.wr_tagged_raw_u32(tag_id, v as u32)\n+    }\n+\n+    fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n+        self.wr_tagged_raw_u16(tag_id, v as u16)\n+    }\n+\n+    fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n+        self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n+    }\n+\n+    pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n+        debug!(\"Write {:?} bytes\", b.len());\n+        self.writer.write_all(b)\n+    }\n+\n+    pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n+        debug!(\"Write str: {:?}\", s);\n+        self.writer.write_all(s.as_bytes())\n+    }\n+\n+    /// Returns the current position while marking it stable, i.e.\n+    /// generated bytes so far wouldn't be affected by relaxation.\n+    pub fn mark_stable_position(&mut self) -> u64 {\n+        let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n+        if self.relax_limit < pos {\n+            self.relax_limit = pos;\n+        }\n+        pos\n+    }\n+}\n+\n+impl<'a> Encoder<'a> {\n+    // used internally to emit things like the vector length and so on\n+    fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n+        if v as u8 as usize == v {\n+            self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n+        } else if v as u32 as usize == v {\n+            self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other,\n+                               &format!(\"length or variant id too big: {}\", v)[..]))\n+        }\n+    }\n+\n+    pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n+        where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n+    {\n+        self.start_tag(EsOpaque as usize)?;\n+\n+        {\n+            let mut opaque_encoder = opaque::Encoder::new(self.writer);\n+            f(&mut opaque_encoder)?;\n+        }\n+\n+        self.mark_stable_position();\n+        self.end_tag()\n+    }\n+}\n+\n+impl<'a> serialize::Encoder for Encoder<'a> {\n+    type Error = io::Error;\n+\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        Ok(())\n+    }\n+\n+    fn emit_usize(&mut self, v: usize) -> EncodeResult {\n+        self.emit_u64(v as u64)\n+    }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n+        if v as u32 as u64 == v {\n+            self.emit_u32(v as u32)\n+        } else {\n+            self.wr_tagged_raw_u64(EsU64 as usize, v)\n+        }\n+    }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n+        if v as u16 as u32 == v {\n+            self.emit_u16(v as u16)\n+        } else {\n+            self.wr_tagged_raw_u32(EsU32 as usize, v)\n+        }\n+    }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n+        if v as u8 as u16 == v {\n+            self.emit_u8(v as u8)\n+        } else {\n+            self.wr_tagged_raw_u16(EsU16 as usize, v)\n+        }\n+    }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n+        self.wr_tagged_raw_u8(EsU8 as usize, v)\n+    }\n+\n+    fn emit_isize(&mut self, v: isize) -> EncodeResult {\n+        self.emit_i64(v as i64)\n+    }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n+        if v as i32 as i64 == v {\n+            self.emit_i32(v as i32)\n+        } else {\n+            self.wr_tagged_raw_i64(EsI64 as usize, v)\n+        }\n+    }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n+        if v as i16 as i32 == v {\n+            self.emit_i16(v as i16)\n+        } else {\n+            self.wr_tagged_raw_i32(EsI32 as usize, v)\n+        }\n+    }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n+        if v as i8 as i16 == v {\n+            self.emit_i8(v as i8)\n+        } else {\n+            self.wr_tagged_raw_i16(EsI16 as usize, v)\n+        }\n+    }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n+        self.wr_tagged_raw_i8(EsI8 as usize, v)\n+    }\n+\n+    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+        let bits = unsafe { mem::transmute(v) };\n+        self.wr_tagged_raw_u64(EsF64 as usize, bits)\n+    }\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+        let bits = unsafe { mem::transmute(v) };\n+        self.wr_tagged_raw_u32(EsF32 as usize, bits)\n+    }\n+    fn emit_char(&mut self, v: char) -> EncodeResult {\n+        self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n+    }\n+\n+    fn emit_str(&mut self, v: &str) -> EncodeResult {\n+        self.wr_tagged_str(EsStr as usize, v)\n+    }\n+\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.start_tag(EsEnum as usize)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+\n+    fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self._emit_tagged_sub(v_id)?;\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                   v_name: &str,\n+                                   v_id: usize,\n+                                   cnt: usize,\n+                                   f: F)\n+                                   -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_enum_variant(v_name, v_id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.emit_enum(\"Option\", f)\n+    }\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+    }\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+\n+        self.emit_enum_variant(\"Some\", 1, 1, f)\n+    }\n+\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        if len == 0 {\n+            // empty vector optimization\n+            return self.wr_tagged_bytes(EsVec as usize, &[]);\n+        }\n+\n+        self.start_tag(EsVec as usize)?;\n+        self._emit_tagged_sub(len)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+\n+    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+\n+        self.start_tag(EsVecElt as usize)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        if len == 0 {\n+            // empty map optimization\n+            return self.wr_tagged_bytes(EsMap as usize, &[]);\n+        }\n+\n+        self.start_tag(EsMap as usize)?;\n+        self._emit_tagged_sub(len)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+\n+    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+\n+        self.start_tag(EsMapKey as usize)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n+    {\n+        self.start_tag(EsMapVal as usize)?;\n+        f(self)?;\n+        self.end_tag()\n+    }\n+}\n+\n+#[test]\n+fn test_option_int() {\n+    use rbml::reader;\n+    use serialize::{Encodable, Decodable};\n+    use std::io::Cursor;\n+\n+    fn test_v(v: Option<isize>) {\n+        debug!(\"v == {:?}\", v);\n+        let mut wr = Cursor::new(Vec::new());\n+        {\n+            let mut rbml_w = Encoder::new(&mut wr);\n+            let _ = v.encode(&mut rbml_w);\n+        }\n+        let rbml_doc = reader::Doc::new(wr.get_ref());\n+        let mut deser = reader::Decoder::new(rbml_doc);\n+        let v1 = Decodable::decode(&mut deser).unwrap();\n+        debug!(\"v1 == {:?}\", v1);\n+        assert_eq!(v, v1);\n+    }\n+\n+    test_v(Some(22));\n+    test_v(None);\n+    test_v(Some(3));\n+}"}]}