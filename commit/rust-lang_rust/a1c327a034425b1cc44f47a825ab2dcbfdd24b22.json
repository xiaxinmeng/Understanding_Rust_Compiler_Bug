{"sha": "a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzMyN2EwMzQ0MjViMWNjNDRmNDdhODI1YWIyZGNiZmRkMjRiMjI=", "commit": {"author": {"name": "Lokathor", "email": "zefria@gmail.com", "date": "2020-10-07T00:57:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-07T00:57:24Z"}, "message": "Merge pull request #27 from thomcc/abs_from_to_bits\n\nImplement abs, to_bits, and from_bits for float vectors", "tree": {"sha": "4d55bbdc6c8669bdf8d31d38ac8c446f3d0622f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d55bbdc6c8669bdf8d31d38ac8c446f3d0622f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffRJ0CRBK7hj4Ov3rIwAAdHIIACapIzER6ohaD7TQa9/OWDCu\nqZ9rbt7VsfvgAwsjcwQ2o8SQy+ZCoC2HkDvW38pV+YpRlt2jTrkHLbHahjmxoJk6\nPfQ0/FF2HSUhlBF4twNdzEHGYxSUXINBC7oxGC9V5KRu4hTyv+Mg+t2Q+gb5OFyp\nBbtP55BirXIMMklDlbyFP8F5jH9SQ9bRpeFRfiLQuZp2tPNBiBD+V7BIZ5h9eTb7\nNbfBIDTIsusNMbc4e4hSlfa2acgMSoohULgW5Zj6jeml8K+8VYMuyXGp9XVP42WX\nSNK3jMZB47TURHTI8TEWCgx9KdsyTY8mH62PS5dpWsDT0Z7/baf8ec5qshNWJo0=\n=NlBb\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d55bbdc6c8669bdf8d31d38ac8c446f3d0622f9\nparent 0b39351ba5b42becb7bc9b53adb8e95f9490cbdf\nparent 8d3d616b130e65bcb926645597b69fb136cc03b5\nauthor Lokathor <zefria@gmail.com> 1602032244 -0600\ncommitter GitHub <noreply@github.com> 1602032244 -0600\n\nMerge pull request #27 from thomcc/abs_from_to_bits\n\nImplement abs, to_bits, and from_bits for float vectors"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "html_url": "https://github.com/rust-lang/rust/commit/a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/comments", "author": {"login": "Lokathor", "id": 5456384, "node_id": "MDQ6VXNlcjU0NTYzODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5456384?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lokathor", "html_url": "https://github.com/Lokathor", "followers_url": "https://api.github.com/users/Lokathor/followers", "following_url": "https://api.github.com/users/Lokathor/following{/other_user}", "gists_url": "https://api.github.com/users/Lokathor/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lokathor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lokathor/subscriptions", "organizations_url": "https://api.github.com/users/Lokathor/orgs", "repos_url": "https://api.github.com/users/Lokathor/repos", "events_url": "https://api.github.com/users/Lokathor/events{/privacy}", "received_events_url": "https://api.github.com/users/Lokathor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b39351ba5b42becb7bc9b53adb8e95f9490cbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b39351ba5b42becb7bc9b53adb8e95f9490cbdf", "html_url": "https://github.com/rust-lang/rust/commit/0b39351ba5b42becb7bc9b53adb8e95f9490cbdf"}, {"sha": "8d3d616b130e65bcb926645597b69fb136cc03b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3d616b130e65bcb926645597b69fb136cc03b5", "html_url": "https://github.com/rust-lang/rust/commit/8d3d616b130e65bcb926645597b69fb136cc03b5"}], "stats": {"total": 117, "additions": 110, "deletions": 7}, "files": [{"sha": "f37d13c3ca32edd8f5d14da928d2468a38b7d07f", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "patch": "@@ -270,6 +270,51 @@ macro_rules! define_vector {\n     }\n }\n \n+/// Implements inherent methods for a float vector `$name` containing multiple\n+/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n+/// representation. Called from `define_float_vector!`.\n+macro_rules! impl_float_vector {\n+    { $name:path => [$type:ty; $lanes:literal]; bits $bits_ty:ty; } => {\n+        impl $name {\n+            /// Raw transmutation to an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn to_bits(self) -> $bits_ty {\n+                unsafe { core::mem::transmute(self) }\n+            }\n+\n+            /// Raw transmutation from an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn from_bits(bits: $bits_ty) -> Self {\n+                unsafe { core::mem::transmute(bits) }\n+            }\n+\n+            /// Produces a vector where every lane has the absolute value of the\n+            /// equivalently-indexed lane in `self`.\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                let no_sign = <$bits_ty>::splat(!0 >> 1);\n+                Self::from_bits(self.to_bits() & no_sign)\n+            }\n+        }\n+    };\n+}\n+\n+/// Defines a float vector `$name` containing multiple `$lanes` of float\n+/// `$type`, which uses `$bits_ty` as its binary representation.\n+macro_rules! define_float_vector {\n+    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); bits $bits_ty:ty; } => {\n+        define_vector! {\n+            $(#[$attr])*\n+            struct $name([$type; $lanes]);\n+        }\n+\n+        impl_float_vector! { $name => [$type; $lanes]; bits $bits_ty; }\n+    }\n+}\n+\n+\n /// Defines an integer vector `$name` containing multiple `$lanes` of integer `$type`.\n macro_rules! define_integer_vector {\n     { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {"}, {"sha": "17b382ee739e58c59dfd249e473276b89a693281", "filename": "crates/core_simd/src/vectors_f32.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs?ref=a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "patch": "@@ -1,23 +1,29 @@\n-define_vector! {\n+define_float_vector! {\n     /// Vector of two `f32` values\n     struct f32x2([f32; 2]);\n+    bits crate::u32x2;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of four `f32` values\n     struct f32x4([f32; 4]);\n+    bits crate::u32x4;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of eight `f32` values\n     struct f32x8([f32; 8]);\n+    bits crate::u32x8;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of 16 `f32` values\n     struct f32x16([f32; 16]);\n+    bits crate::u32x16;\n }\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n //from_transmute_x86! { unsafe f32x16 => __m512 }\n+\n+"}, {"sha": "b41923ca6f10d367af6634fe0bb25c41cac7ce3b", "filename": "crates/core_simd/src/vectors_f64.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs?ref=a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "patch": "@@ -1,16 +1,19 @@\n-define_vector! {\n+define_float_vector! {\n     /// Vector of two `f64` values\n     struct f64x2([f64; 2]);\n+    bits crate::u64x2;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of four `f64` values\n     struct f64x4([f64; 4]);\n+    bits crate::u64x4;\n }\n \n-define_vector! {\n+define_float_vector! {\n     /// Vector of eight `f64` values\n     struct f64x8([f64; 8]);\n+    bits crate::u64x8;\n }\n \n from_transmute_x86! { unsafe f64x2 => __m128d }"}, {"sha": "1c969a2e8af3be2c19432e342009a69d72203787", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c327a034425b1cc44f47a825ab2dcbfdd24b22/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=a1c327a034425b1cc44f47a825ab2dcbfdd24b22", "patch": "@@ -19,8 +19,32 @@ macro_rules! float_tests {\n                 value\n             }\n \n+            fn slice_chunks(slice: &[$scalar]) -> impl Iterator<Item = core_simd::$vector> + '_ {\n+                let lanes = core::mem::size_of::<core_simd::$vector>() / core::mem::size_of::<$scalar>();\n+                slice.chunks_exact(lanes).map(from_slice)\n+            }\n+\n             const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n             const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n+            const C: [$scalar; 16] = [\n+                -0.0,\n+                0.0,\n+                -1.0,\n+                1.0,\n+                <$scalar>::MIN,\n+                <$scalar>::MAX,\n+                <$scalar>::INFINITY,\n+                <$scalar>::NEG_INFINITY,\n+                <$scalar>::MIN_POSITIVE,\n+                -<$scalar>::MIN_POSITIVE,\n+                <$scalar>::EPSILON,\n+                -<$scalar>::EPSILON,\n+                <$scalar>::NAN,\n+                -<$scalar>::NAN,\n+                // TODO: Would be nice to check sNaN...\n+                100.0 / 3.0,\n+                -100.0 / 3.0,\n+            ];\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n@@ -264,6 +288,31 @@ macro_rules! float_tests {\n                 let expected = apply_unary_lanewise(v, core::ops::Neg::neg);\n                 assert_biteq!(-v, expected);\n             }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_negative() {\n+                let v = -from_slice(&A);\n+                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                assert_biteq!(v.abs(), expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_positive() {\n+                let v = from_slice(&B);\n+                let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                assert_biteq!(v.abs(), expected);\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn abs_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::abs);\n+                    assert_biteq!(v.abs(), expected);\n+                }\n+            }\n         }\n     }\n }"}]}