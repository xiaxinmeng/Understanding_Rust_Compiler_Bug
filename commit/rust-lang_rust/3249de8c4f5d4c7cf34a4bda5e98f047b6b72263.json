{"sha": "3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDlkZThjNGY1ZDRjN2NmMzRhNGJkYTVlOThmMDQ3YjZiNzIyNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-02T17:02:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-02T17:02:01Z"}, "message": "auto merge of #11274 : michaelwoerister/rust/issue11083, r=pcwalton\n\nThis pull request fixes #11083. The problem was that recursive type definitions were not properly handled for enum types, leading to problems with LLVM's metadata \"uniquing\". This bug has already been fixed for struct types some time ago (#9658) but I seem to have forgotten about enums back then. I added the offending code from issue #11083 as a test case.", "tree": {"sha": "bde0dfa80e18dcf911d134eb8ca429db08d58a31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde0dfa80e18dcf911d134eb8ca429db08d58a31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "html_url": "https://github.com/rust-lang/rust/commit/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff578b7c83efd8d8335dad86f83da346753c8f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff578b7c83efd8d8335dad86f83da346753c8f34", "html_url": "https://github.com/rust-lang/rust/commit/ff578b7c83efd8d8335dad86f83da346753c8f34"}, {"sha": "645bb327dbd1fab65a87d2f0bd6ca8c3ec620422", "url": "https://api.github.com/repos/rust-lang/rust/commits/645bb327dbd1fab65a87d2f0bd6ca8c3ec620422", "html_url": "https://github.com/rust-lang/rust/commit/645bb327dbd1fab65a87d2f0bd6ca8c3ec620422"}], "stats": {"total": 172, "additions": 108, "deletions": 64}, "files": [{"sha": "fd6e341503bf52203ef02c8fbf6dbf7cda400adf", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "patch": "@@ -1658,7 +1658,8 @@ pub mod llvm {\n                                             AlignInBits: c_ulonglong,\n                                             Flags: c_uint,\n                                             Elements: ValueRef,\n-                                            RunTimeLang: c_uint)\n+                                            RunTimeLang: c_uint,\n+                                            UniqueId: *c_char)\n                                             -> ValueRef;\n \n         pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);"}, {"sha": "88dc4928164a2d6a8bbbb9cc8356f720946f8be0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "patch": "@@ -157,7 +157,7 @@ use syntax::parse::token::special_idents;\n static DW_LANG_RUST: c_uint = 0x9000;\n \n static DW_TAG_auto_variable: c_uint = 0x100;\n-// static DW_TAG_arg_variable: c_uint = 0x101;\n+static DW_TAG_arg_variable: c_uint = 0x101;\n \n static DW_ATE_boolean: c_uint = 0x02;\n static DW_ATE_float: c_uint = 0x04;\n@@ -980,11 +980,11 @@ fn declare_local(bcx: @Block,\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n-    let argument_index = match variable_kind {\n-        ArgumentVariable(index) => index,\n+    let (argument_index, dwarf_tag) = match variable_kind {\n+        ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n         LocalVariable    |\n-        CapturedVariable => 0\n-    } as c_uint;\n+        CapturedVariable => (0, DW_TAG_auto_variable)\n+    };\n \n     let (var_alloca, var_metadata) = name.with_c_str(|name| {\n         match variable_access {\n@@ -993,7 +993,7 @@ fn declare_local(bcx: @Block,\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateLocalVariable(\n                         DIB(cx),\n-                        DW_TAG_auto_variable,\n+                        dwarf_tag,\n                         scope_metadata,\n                         name,\n                         file_metadata,\n@@ -1009,7 +1009,7 @@ fn declare_local(bcx: @Block,\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateComplexVariable(\n                         DIB(cx),\n-                        DW_TAG_auto_variable,\n+                        dwarf_tag,\n                         scope_metadata,\n                         name,\n                         file_metadata,\n@@ -1256,14 +1256,12 @@ impl RecursiveTypeDescription {\n             } => {\n                 // Insert the stub into the cache in order to allow recursive references ...\n                 {\n-                    let mut created_types = debug_context(cx).created_types\n-                                                             .borrow_mut();\n+                    let mut created_types = debug_context(cx).created_types.borrow_mut();\n                     created_types.get().insert(cache_id, metadata_stub);\n                 }\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory.\n-                    create_member_descriptions(cx);\n+                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n@@ -1348,13 +1346,13 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n             .enumerate()\n             .map(|(i, struct_def)| {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n-                    describe_variant(cx,\n-                                     struct_def,\n-                                     self.variants[i],\n-                                     Some(self.discriminant_type_metadata),\n-                                     self.containing_scope,\n-                                     self.file_metadata,\n-                                     self.span);\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          self.variants[i],\n+                                          Some(self.discriminant_type_metadata),\n+                                          self.containing_scope,\n+                                          self.file_metadata,\n+                                          self.span);\n \n                 let member_descriptions =\n                     member_desc_factory.create_member_descriptions(cx);\n@@ -1398,14 +1396,14 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     }\n }\n \n-fn describe_variant(cx: &CrateContext,\n-                    struct_def: &adt::Struct,\n-                    variant_info: &ty::VariantInfo,\n-                    discriminant_type_metadata: Option<DIType>,\n-                    containing_scope: DIScope,\n-                    file_metadata: DIFile,\n-                    span: Span)\n-                 -> (DICompositeType, Type, @MemberDescriptionFactory) {\n+fn describe_enum_variant(cx: &CrateContext,\n+                         struct_def: &adt::Struct,\n+                         variant_info: &ty::VariantInfo,\n+                         discriminant_type_metadata: Option<DIType>,\n+                         containing_scope: DIScope,\n+                         file_metadata: DIFile,\n+                         span: Span)\n+                      -> (DICompositeType, Type, @MemberDescriptionFactory) {\n     let variant_name = token::ident_to_str(&variant_info.name);\n     let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                           struct_def.packed);\n@@ -1538,13 +1536,13 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             assert!(variants.len() == 1);\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_variant(cx,\n-                                                                struct_def,\n-                                                                variants[0],\n-                                                                None,\n-                                                                containing_scope,\n-                                                                file_metadata,\n-                                                                span);\n+                 member_description_factory) = describe_enum_variant(cx,\n+                                                                     struct_def,\n+                                                                     variants[0],\n+                                                                     None,\n+                                                                     containing_scope,\n+                                                                     file_metadata,\n+                                                                     span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1557,21 +1555,25 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             let discriminant_type_metadata = discriminant_type_metadata(inttype);\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n+            let unique_id = generate_unique_type_id(\"DI_ENUM_\");\n \n             let enum_metadata = enum_name.with_c_str(|enum_name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateUnionType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    enum_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(enum_type_size),\n-                    bytes_to_bits(enum_type_align),\n-                    0, // Flags\n-                    ptr::null(),\n-                    0) // RuntimeLang\n-                }\n+                unique_id.with_c_str(|unique_id| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateUnionType(\n+                        DIB(cx),\n+                        containing_scope,\n+                        enum_name,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        bytes_to_bits(enum_type_size),\n+                        bytes_to_bits(enum_type_align),\n+                        0, // Flags\n+                        ptr::null(),\n+                        0, // RuntimeLang\n+                        unique_id)\n+                    }\n+                })\n             });\n \n             UnfinishedMetadata {\n@@ -1592,13 +1594,13 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_variant(cx,\n-                                                                struct_def,\n-                                                                variants[nndiscr],\n-                                                                None,\n-                                                                containing_scope,\n-                                                                file_metadata,\n-                                                                span);\n+                 member_description_factory) = describe_enum_variant(cx,\n+                                                                     struct_def,\n+                                                                     variants[nndiscr],\n+                                                                     None,\n+                                                                     containing_scope,\n+                                                                     file_metadata,\n+                                                                     span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1725,10 +1727,7 @@ fn create_struct_stub(cx: &CrateContext,\n \n     // We assign unique IDs to the type stubs so LLVM metadata uniquing does not reuse instances\n     // where we don't want it.\n-    let unique_id = unsafe {\n-        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n-        format!(\"DiStructStub{}\", unique_id_counter.fetch_add(1, atomics::SeqCst))\n-    };\n+    let unique_id = generate_unique_type_id(\"DI_STRUCT_\");\n \n     return unsafe {\n         struct_type_name.with_c_str(|name| {\n@@ -2059,10 +2058,6 @@ fn trait_metadata(cx: &CrateContext,\n                                    definition_span);\n }\n \n-fn cache_id_for_type(t: ty::t) -> uint {\n-    ty::type_id(t)\n-}\n-\n fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n@@ -2244,6 +2239,19 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n //  Utility Functions\n //=-------------------------------------------------------------------------------------------------\n \n+fn cache_id_for_type(t: ty::t) -> uint {\n+    ty::type_id(t)\n+}\n+\n+// Used to avoid LLVM metadata uniquing problems. See `create_struct_stub()` and\n+// `prepare_enum_metadata()`.\n+fn generate_unique_type_id(prefix: &'static str) -> ~str {\n+    unsafe {\n+        static mut unique_id_counter: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+        format!(\"{}{}\", prefix, unique_id_counter.fetch_add(1, atomics::SeqCst))\n+    }\n+}\n+\n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)"}, {"sha": "1fb05b89381234044dfb9be29114187976926e24", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "patch": "@@ -420,7 +420,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n     uint64_t AlignInBits,\n     unsigned Flags,\n     LLVMValueRef Elements,\n-    unsigned RunTimeLang)\n+    unsigned RunTimeLang,\n+    const char* UniqueId)\n {\n     return wrap(Builder->createUnionType(\n         unwrapDI<DIDescriptor>(Scope),\n@@ -431,7 +432,8 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n         AlignInBits,\n         Flags,\n         unwrapDI<DIArray>(Elements),\n-        RunTimeLang));\n+        RunTimeLang,\n+        UniqueId));\n }\n \n extern \"C\" void LLVMSetUnnamedAddr(LLVMValueRef Value, LLVMBool Unnamed) {"}, {"sha": "4bdc9994c439f9ec484036a8f90254d0afd74ba0", "filename": "src/test/debug-info/recursive-enum.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3249de8c4f5d4c7cf34a4bda5e98f047b6b72263/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Frecursive-enum.rs?ref=3249de8c4f5d4c7cf34a4bda5e98f047b6b72263", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-android: FIXME(#10381)\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:run\n+\n+// Test whether compiling a recursive enum definition crashes debug info generation. The test case\n+// is taken from issue #11083.\n+\n+#[allow(unused_variable)];\n+\n+pub struct Window<'a> {\n+    callbacks: WindowCallbacks<'a>\n+}\n+\n+struct WindowCallbacks<'a> {\n+    pos_callback: Option<WindowPosCallback<'a>>,\n+}\n+\n+pub type WindowPosCallback<'a> = 'a |&Window, i32, i32|;\n+\n+fn main() {\n+    let x = WindowCallbacks { pos_callback: None };\n+}"}]}