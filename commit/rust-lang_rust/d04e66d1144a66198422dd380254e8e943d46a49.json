{"sha": "d04e66d1144a66198422dd380254e8e943d46a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGU2NmQxMTQ0YTY2MTk4NDIyZGQzODAyNTRlOGU5NDNkNDZhNDk=", "commit": {"author": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-02T14:52:53Z"}, "committer": {"name": "Irina Popa", "email": "irinagpopa@gmail.com", "date": "2018-07-30T15:36:29Z"}, "message": "rustc_codegen_llvm: use safe references for Type.", "tree": {"sha": "2749a2b06c7698422d9c2d59cb7cf845075923f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2749a2b06c7698422d9c2d59cb7cf845075923f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04e66d1144a66198422dd380254e8e943d46a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04e66d1144a66198422dd380254e8e943d46a49", "html_url": "https://github.com/rust-lang/rust/commit/d04e66d1144a66198422dd380254e8e943d46a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04e66d1144a66198422dd380254e8e943d46a49/comments", "author": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "irinagpopa", "id": 32459019, "node_id": "MDQ6VXNlcjMyNDU5MDE5", "avatar_url": "https://avatars.githubusercontent.com/u/32459019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irinagpopa", "html_url": "https://github.com/irinagpopa", "followers_url": "https://api.github.com/users/irinagpopa/followers", "following_url": "https://api.github.com/users/irinagpopa/following{/other_user}", "gists_url": "https://api.github.com/users/irinagpopa/gists{/gist_id}", "starred_url": "https://api.github.com/users/irinagpopa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irinagpopa/subscriptions", "organizations_url": "https://api.github.com/users/irinagpopa/orgs", "repos_url": "https://api.github.com/users/irinagpopa/repos", "events_url": "https://api.github.com/users/irinagpopa/events{/privacy}", "received_events_url": "https://api.github.com/users/irinagpopa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "249d5acaec0b10ee15b21b888977b5445baba42e", "url": "https://api.github.com/repos/rust-lang/rust/commits/249d5acaec0b10ee15b21b888977b5445baba42e", "html_url": "https://github.com/rust-lang/rust/commit/249d5acaec0b10ee15b21b888977b5445baba42e"}], "stats": {"total": 1101, "additions": 568, "deletions": 533}, "files": [{"sha": "1d6214ab740936bc18a50eb94f6cc458a7dd02ed", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -103,11 +103,11 @@ impl ArgAttributesExt for ArgAttributes {\n }\n \n pub trait LlvmType {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type;\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type;\n }\n \n impl LlvmType for Reg {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n             RegKind::Integer => Type::ix(cx, self.size.bits()),\n             RegKind::Float => {\n@@ -118,14 +118,14 @@ impl LlvmType for Reg {\n                 }\n             }\n             RegKind::Vector => {\n-                Type::vector(&Type::i8(cx), self.size.bytes())\n+                Type::vector(Type::i8(cx), self.size.bytes())\n             }\n         }\n     }\n }\n \n impl LlvmType for CastTarget {\n-    fn llvm_type(&self, cx: &CodegenCx) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         let rest_ll_unit = self.rest.unit.llvm_type(cx);\n         let (rest_count, rem_bytes) = if self.rest.unit.size.bytes() == 0 {\n             (0, 0)\n@@ -142,7 +142,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return Type::array(&rest_ll_unit, rest_count);\n+                return Type::array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -165,23 +165,23 @@ impl LlvmType for CastTarget {\n }\n \n pub trait ArgTypeExt<'a, 'tcx> {\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>);\n-    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>);\n+    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n+    fn store(&self, bx: &Builder<'a, 'll, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>);\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>);\n }\n \n impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n-    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         self.layout.llvm_type(cx)\n     }\n \n     /// Store a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    fn store(&self, bx: &Builder<'a, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n+    fn store(&self, bx: &Builder<'a, 'll, 'tcx>, val: ValueRef, dst: PlaceRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> ArgTypeExt<'a, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn store_fn_arg(&self, bx: &Builder<'a, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n+    fn store_fn_arg(&self, bx: &Builder<'a, 'll, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx>) {\n         let mut next = || {\n             let val = llvm::get_param(bx.llfn(), *idx as c_uint);\n             *idx += 1;\n@@ -270,10 +270,10 @@ pub trait FnTypeExt<'a, 'tcx> {\n     fn adjust_for_abi(&mut self,\n                       cx: &CodegenCx<'a, 'tcx>,\n                       abi: Abi);\n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: ValueRef);\n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef);\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: ValueRef);\n }\n \n impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n@@ -606,9 +606,9 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n \n         if self.variadic {\n-            Type::variadic_func(&llargument_tys, &llreturn_ty)\n+            Type::variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            Type::func(&llargument_tys, &llreturn_ty)\n+            Type::func(&llargument_tys, llreturn_ty)\n         }\n     }\n \n@@ -659,7 +659,7 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n         }\n     }\n \n-    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'tcx>, callsite: ValueRef) {\n+    fn apply_attrs_callsite(&self, bx: &Builder<'a, 'll, 'tcx>, callsite: ValueRef) {\n         let mut i = 0;\n         let mut apply = |attrs: &ArgAttributes| {\n             attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);"}, {"sha": "c046b98685a77931f3f85ad4c17c4dbe6c0a42f0", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -24,8 +24,8 @@ use syntax::ast::AsmDialect;\n use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn codegen_inline_asm<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn codegen_inline_asm(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<PlaceRef<'tcx>>,\n     mut inputs: Vec<ValueRef>"}, {"sha": "ce51a3572d837bab7fe300a1b8fb00ee4ce5dda0", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -831,7 +831,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     let llconst = C_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst).to_ref(),\n+        val_ty(llconst),\n         \"rustc.embedded.module\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -851,7 +851,7 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     let llconst = C_bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst).to_ref(),\n+        val_ty(llconst),\n         \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -2380,7 +2380,7 @@ fn create_msvc_imps(cgcx: &CodegenContext, llcx: &llvm::Context, llmod: &llvm::M\n             .collect::<Vec<_>>();\n         for (imp_name, val) in globals {\n             let imp = llvm::LLVMAddGlobal(llmod,\n-                                          i8p_ty.to_ref(),\n+                                          i8p_ty,\n                                           imp_name.as_ptr() as *const _);\n             llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n             llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);"}, {"sha": "21b22b387c9f3ea104391d9b8be1a195a0c60aa6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -19,9 +19,9 @@\n //!\n //!   * There's no way to find out the Ty type of a ValueRef.  Doing so\n //!     would be \"trying to get the eggs out of an omelette\" (credit:\n-//!     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n-//!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n-//!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n+//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n+//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n+//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n \n use super::ModuleLlvm;\n use super::ModuleSource;\n@@ -91,14 +91,14 @@ use mir::operand::OperandValue;\n \n use rustc_codegen_utils::check_for_rustc_errors_attr;\n \n-pub struct StatRecorder<'a, 'tcx: 'a> {\n-    cx: &'a CodegenCx<'a, 'tcx>,\n+pub struct StatRecorder<'a, 'll: 'a, 'tcx: 'll> {\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n     name: Option<String>,\n     istart: usize,\n }\n \n-impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n-    pub fn new(cx: &'a CodegenCx<'a, 'tcx>, name: String) -> StatRecorder<'a, 'tcx> {\n+impl StatRecorder<'a, 'll, 'tcx> {\n+    pub fn new(cx: &'a CodegenCx<'ll, 'tcx>, name: String) -> Self {\n         let istart = cx.stats.borrow().n_llvm_insns;\n         StatRecorder {\n             cx,\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n+impl Drop for StatRecorder<'a, 'll, 'tcx> {\n     fn drop(&mut self) {\n         if self.cx.sess().codegen_stats() {\n             let mut stats = self.cx.stats.borrow_mut();\n@@ -155,12 +155,12 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOpKind) -> llvm::RealPredicate {\n     }\n }\n \n-pub fn compare_simd_types<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn compare_simd_types(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n-    ret_ty: Type,\n+    ret_ty: &'ll Type,\n     op: hir::BinOpKind\n ) -> ValueRef {\n     let signed = match t.sty {\n@@ -216,8 +216,8 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n }\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn unsize_thin_ptr(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     src: ValueRef,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n@@ -271,9 +271,11 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                     src: PlaceRef<'tcx>,\n-                                     dst: PlaceRef<'tcx>) {\n+pub fn coerce_unsized_into(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    src: PlaceRef<'tcx>,\n+    dst: PlaceRef<'tcx>\n+) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n@@ -334,14 +336,14 @@ pub fn cast_shift_expr_rhs(\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-fn cast_shift_rhs<F, G>(op: hir::BinOpKind,\n+fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n                         lhs: ValueRef,\n                         rhs: ValueRef,\n                         trunc: F,\n                         zext: G)\n                         -> ValueRef\n-    where F: FnOnce(ValueRef, Type) -> ValueRef,\n-          G: FnOnce(ValueRef, Type) -> ValueRef\n+    where F: FnOnce(ValueRef, &'ll Type) -> ValueRef,\n+          G: FnOnce(ValueRef, &'ll Type) -> ValueRef\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n@@ -378,7 +380,7 @@ pub fn wants_msvc_seh(sess: &Session) -> bool {\n     sess.target.target.options.is_like_msvc\n }\n \n-pub fn call_assume<'a, 'tcx>(bx: &Builder<'a, 'tcx>, val: ValueRef) {\n+pub fn call_assume(bx: &Builder<'a, 'll, 'tcx>, val: ValueRef) {\n     let assume_intrinsic = bx.cx.get_intrinsic(\"llvm.assume\");\n     bx.call(assume_intrinsic, &[val], None);\n }\n@@ -430,8 +432,8 @@ pub fn call_memcpy(bx: &Builder,\n     bx.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn memcpy_ty(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     dst: ValueRef,\n     src: ValueRef,\n     layout: TyLayout<'tcx>,\n@@ -446,12 +448,14 @@ pub fn memcpy_ty<'a, 'tcx>(\n     call_memcpy(bx, dst, src, C_usize(bx.cx, size), align, flags);\n }\n \n-pub fn call_memset<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                             ptr: ValueRef,\n-                             fill_byte: ValueRef,\n-                             size: ValueRef,\n-                             align: ValueRef,\n-                             volatile: bool) -> ValueRef {\n+pub fn call_memset(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    ptr: ValueRef,\n+    fill_byte: ValueRef,\n+    size: ValueRef,\n+    align: ValueRef,\n+    volatile: bool,\n+) -> ValueRef {\n     let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n@@ -553,7 +557,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n                        rust_main: ValueRef,\n                        rust_main_def_id: DefId,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], &Type::c_int(cx));\n+        let llfty = Type::func(&[Type::c_int(cx), Type::i8p(cx).ptr_to()], Type::c_int(cx));\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -656,7 +660,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -1206,7 +1210,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, val_ty(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                     llvm::LLVMDeleteGlobal(old_g);\n                 }\n@@ -1221,7 +1225,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,\n-                                                val_ty(array).to_ref(),\n+                                                val_ty(array),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n                     llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);"}, {"sha": "a8bfc721a9e9e4a29434ed52497c5410933a6469", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -31,12 +31,12 @@ use syntax_pos::Span;\n \n // All Builders must have an llfn associated with them\n #[must_use]\n-pub struct Builder<'a, 'tcx: 'a> {\n+pub struct Builder<'a, 'll: 'a, 'tcx: 'll> {\n     pub llbuilder: BuilderRef,\n-    pub cx: &'a CodegenCx<'a, 'tcx>,\n+    pub cx: &'a CodegenCx<'ll, 'tcx>,\n }\n \n-impl<'a, 'tcx> Drop for Builder<'a, 'tcx> {\n+impl Drop for Builder<'a, 'll, 'tcx> {\n     fn drop(&mut self) {\n         unsafe {\n             llvm::LLVMDisposeBuilder(self.llbuilder);\n@@ -59,8 +59,8 @@ bitflags! {\n     }\n }\n \n-impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn new_block<'b>(cx: &'a CodegenCx<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+impl Builder<'a, 'll, 'tcx> {\n+    pub fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n         let bx = Builder::with_cx(cx);\n         let llbb = unsafe {\n             let name = CString::new(name).unwrap();\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         bx\n     }\n \n-    pub fn with_cx(cx: &'a CodegenCx<'a, 'tcx>) -> Self {\n+    pub fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n             llvm::LLVMCreateBuilderInContext(cx.llcx)\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n+    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn(), name)\n     }\n \n@@ -504,22 +504,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n+    pub fn alloca(&self, ty: &'ll Type, name: &str, align: Align) -> ValueRef {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n         bx.dynamic_alloca(ty, name, align)\n     }\n \n-    pub fn dynamic_alloca(&self, ty: Type, name: &str, align: Align) -> ValueRef {\n+    pub fn dynamic_alloca(&self, ty: &'ll Type, name: &str, align: Align) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n             } else {\n                 let name = CString::new(name).unwrap();\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n+                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n                                       name.as_ptr())\n             };\n             llvm::LLVMSetAlignment(alloca, align.abi() as c_uint);\n@@ -678,136 +678,136 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /* Casts */\n-    pub fn trunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn trunc(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"trunc\");\n         unsafe {\n-            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn zext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"zext\");\n         unsafe {\n-            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn sext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"sext\");\n         unsafe {\n-            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptoui(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptoui(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"fptoui\");\n         unsafe {\n-            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptosi(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptosi(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"fptosi\");\n         unsafe {\n-            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty.to_ref(),noname())\n+            llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n-    pub fn uitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn uitofp(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"uitofp\");\n         unsafe {\n-            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sitofp(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn sitofp(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"sitofp\");\n         unsafe {\n-            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fptrunc(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fptrunc(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"fptrunc\");\n         unsafe {\n-            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn fpext(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fpext(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"fpext\");\n         unsafe {\n-            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn ptrtoint(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn ptrtoint(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"ptrtoint\");\n         unsafe {\n-            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn inttoptr(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn inttoptr(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"inttoptr\");\n         unsafe {\n-            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"bitcast\");\n         unsafe {\n-            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn zext_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"zextorbitcast\");\n         unsafe {\n-            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildZExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn sext_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"sextorbitcast\");\n         unsafe {\n-            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildSExtOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn trunc_or_bitcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"truncorbitcast\");\n         unsafe {\n-            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildTruncOrBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn cast(&self, op: Opcode, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"cast\");\n         unsafe {\n-            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildCast(self.llbuilder, op, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn pointercast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn pointercast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"pointercast\");\n         unsafe {\n-            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n-    pub fn intcast(&self, val: ValueRef, dest_ty: Type, is_signed: bool) -> ValueRef {\n+    pub fn intcast(&self, val: ValueRef, dest_ty: &'ll Type, is_signed: bool) -> ValueRef {\n         self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), is_signed)\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n-    pub fn fpcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn fpcast(&self, val: ValueRef, dest_ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"fpcast\");\n         unsafe {\n-            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMBuildFPCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n@@ -828,14 +828,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /* Miscellaneous instructions */\n-    pub fn empty_phi(&self, ty: Type) -> ValueRef {\n+    pub fn empty_phi(&self, ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"emptyphi\");\n         unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty.to_ref(), noname())\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n         }\n     }\n \n-    pub fn phi(&self, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+    pub fn phi(&self, ty: &'ll Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n         assert_eq!(vals.len(), bbs.len());\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n@@ -865,7 +865,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.count_insn(\"inlineasm\");\n             let comment_text = CString::new(comment_text).unwrap();\n             let asm = unsafe {\n-                llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.cx)).to_ref(),\n+                llvm::LLVMConstInlineAsm(Type::func(&[], Type::void(self.cx)),\n                                          comment_text.as_ptr(), noname(), False,\n                                          False)\n             };\n@@ -874,7 +874,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n-                         inputs: &[ValueRef], output: Type,\n+                         inputs: &[ValueRef], output: &'ll Type,\n                          volatile: bool, alignstack: bool,\n                          dia: AsmDialect) -> ValueRef {\n         self.count_insn(\"inlineasm\");\n@@ -890,10 +890,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = Type::func(&argtys[..], &output);\n+        let fty = Type::func(&argtys[..], output);\n         unsafe {\n             let v = llvm::LLVMRustInlineAsm(\n-                fty.to_ref(), asm, cons, volatile, alignstack, dia);\n+                fty, asm, cons, volatile, alignstack, dia);\n             self.call(v, inputs, None)\n         }\n     }\n@@ -946,10 +946,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn va_arg(&self, list: ValueRef, ty: Type) -> ValueRef {\n+    pub fn va_arg(&self, list: ValueRef, ty: &'ll Type) -> ValueRef {\n         self.count_insn(\"vaarg\");\n         unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty.to_ref(), noname())\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n@@ -977,9 +977,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn vector_splat(&self, num_elts: usize, elt: ValueRef) -> ValueRef {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n+            let undef = llvm::LLVMGetUndef(Type::vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n-            let vec_i32_ty = Type::vector(&Type::i32(self.cx), num_elts as u64);\n+            let vec_i32_ty = Type::vector(Type::i32(self.cx), num_elts as u64);\n             self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n@@ -1164,11 +1164,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef,\n+    pub fn landing_pad(&self, ty: &'ll Type, pers_fn: ValueRef,\n                        num_clauses: usize) -> ValueRef {\n         self.count_insn(\"landingpad\");\n         unsafe {\n-            llvm::LLVMBuildLandingPad(self.llbuilder, ty.to_ref(), pers_fn,\n+            llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }"}, {"sha": "7b90616416890f067890bd053c5d2e247863db82", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -112,41 +112,42 @@ impl Funclet {\n     }\n }\n \n-pub fn val_ty(v: ValueRef) -> Type {\n+// TODO: use proper lifetime in return type\n+pub fn val_ty(v: ValueRef) -> &'static Type {\n     unsafe {\n-        Type::from_ref(llvm::LLVMTypeOf(v))\n+        llvm::LLVMTypeOf(&*v)\n     }\n }\n \n // LLVM constant constructors.\n-pub fn C_null(t: Type) -> ValueRef {\n+pub fn C_null(t: &Type) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstNull(t.to_ref())\n+        llvm::LLVMConstNull(t)\n     }\n }\n \n-pub fn C_undef(t: Type) -> ValueRef {\n+pub fn C_undef(t: &Type) -> ValueRef {\n     unsafe {\n-        llvm::LLVMGetUndef(t.to_ref())\n+        llvm::LLVMGetUndef(t)\n     }\n }\n \n-pub fn C_int(t: Type, i: i64) -> ValueRef {\n+pub fn C_int(t: &Type, i: i64) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), i as u64, True)\n+        llvm::LLVMConstInt(t, i as u64, True)\n     }\n }\n \n-pub fn C_uint(t: Type, i: u64) -> ValueRef {\n+pub fn C_uint(t: &Type, i: u64) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), i, False)\n+        llvm::LLVMConstInt(t, i, False)\n     }\n }\n \n-pub fn C_uint_big(t: Type, u: u128) -> ValueRef {\n+pub fn C_uint_big(t: &Type, u: u128) -> ValueRef {\n     unsafe {\n         let words = [u as u64, (u >> 64) as u64];\n-        llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n+        llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n     }\n }\n \n@@ -233,9 +234,9 @@ pub fn C_struct_in_context(llcx: &llvm::Context, elts: &[ValueRef], packed: bool\n     }\n }\n \n-pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: &Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n@@ -345,8 +346,8 @@ pub fn langcall(tcx: TyCtxt,\n // all shifts). For 32- and 64-bit types, this matches the semantics\n // of Java. (See related discussion on #1877 and #10183.)\n \n-pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+pub fn build_unchecked_lshift(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n@@ -356,8 +357,8 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n     bx.shl(lhs, rhs)\n }\n \n-pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+pub fn build_unchecked_rshift(\n+    bx: &Builder<'a, 'll, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n@@ -370,15 +371,15 @@ pub fn build_unchecked_rshift<'a, 'tcx>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n-pub fn shift_mask_val<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n-    llty: Type,\n-    mask_llty: Type,\n+pub fn shift_mask_val(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    llty: &'ll Type,\n+    mask_llty: &'ll Type,\n     invert: bool\n ) -> ValueRef {\n     let kind = llty.kind();"}, {"sha": "956e81f746da9ef6ad01ee5dc7e3408f996ce03d", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -31,15 +31,15 @@ use rustc::hir::{self, CodegenFnAttrs, CodegenFnAttrFlags};\n \n use std::ffi::{CStr, CString};\n \n-pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n+pub fn ptrcast(val: ValueRef, ty: &Type) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstPointerCast(val, ty.to_ref())\n+        llvm::LLVMConstPointerCast(val, ty)\n     }\n }\n \n-pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n+pub fn bitcast(val: ValueRef, ty: &Type) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstBitCast(val, ty.to_ref())\n+        llvm::LLVMConstBitCast(val, ty)\n     }\n }\n \n@@ -294,7 +294,7 @@ pub fn codegen_static<'a, 'tcx>(\n         let mut val_llty = val_ty(v);\n         let v = if val_llty == Type::i1(cx) {\n             val_llty = Type::i8(cx);\n-            llvm::LLVMConstZExt(v, val_llty.to_ref())\n+            llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n         };\n@@ -316,7 +316,7 @@ pub fn codegen_static<'a, 'tcx>(\n             let visibility = llvm::LLVMRustGetVisibility(g);\n \n             let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                cx.llmod, name_string.as_ptr(), val_llty.to_ref());\n+                cx.llmod, name_string.as_ptr(), val_llty);\n \n             llvm::LLVMRustSetLinkage(new_g, linkage);\n             llvm::LLVMRustSetVisibility(new_g, visibility);\n@@ -411,7 +411,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+            let cast = llvm::LLVMConstPointerCast(g, Type::i8p(cx));\n             cx.used_statics.borrow_mut().push(cast);\n         }\n     }"}, {"sha": "1616d54a77aaaf6bb79f95a18c540802d0f77782", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -89,10 +89,10 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n     pub used_statics: RefCell<Vec<ValueRef>>,\n \n-    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), Type>>,\n-    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n+    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<usize>), &'a Type>>,\n+    pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'a Type>>,\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n-    pub isize_ty: Type,\n+    pub isize_ty: &'a Type,\n \n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'a, 'tcx>>,\n \n@@ -373,7 +373,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = Type::variadic_func(&[], &Type::i32(self));\n+                let fty = Type::variadic_func(&[], Type::i32(self));\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n@@ -439,25 +439,25 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CodegenCx<'a, 'tcx> {\n+impl ty::layout::HasDataLayout for &'a CodegenCx<'ll, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> HasTargetSpec for &'a CodegenCx<'a, 'tcx> {\n+impl HasTargetSpec for &'a CodegenCx<'ll, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target.target\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'a, 'tcx> {\n+impl ty::layout::HasTyCtxt<'tcx> for &'a CodegenCx<'ll, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for &'a CodegenCx<'a, 'tcx> {\n+impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;\n \n@@ -475,23 +475,23 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::variadic_func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], &$ret));\n+                let f = declare::declare_cfn(cx, $name, Type::func(&[$($arg),*], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -513,14 +513,14 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n-    let t_v2f32 = Type::vector(&t_f32, 2);\n-    let t_v4f32 = Type::vector(&t_f32, 4);\n-    let t_v8f32 = Type::vector(&t_f32, 8);\n-    let t_v16f32 = Type::vector(&t_f32, 16);\n+    let t_v2f32 = Type::vector(t_f32, 2);\n+    let t_v4f32 = Type::vector(t_f32, 4);\n+    let t_v8f32 = Type::vector(t_f32, 8);\n+    let t_v16f32 = Type::vector(t_f32, 16);\n \n-    let t_v2f64 = Type::vector(&t_f64, 2);\n-    let t_v4f64 = Type::vector(&t_f64, 4);\n-    let t_v8f64 = Type::vector(&t_f64, 8);\n+    let t_v2f64 = Type::vector(t_f64, 2);\n+    let t_v4f64 = Type::vector(t_f64, 4);\n+    let t_v8f64 = Type::vector(t_f64, 8);\n \n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);"}, {"sha": "de43a4522cc28da73df5d36b47bb822946641c9b", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -54,7 +54,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = Type::array(&Type::i8(cx),\n+            let llvm_type = Type::array(Type::i8(cx),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,"}, {"sha": "3336e46ea797dbc7e02a0865c31a299cbcbc8b5a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -471,14 +471,16 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                               dbg_context: &FunctionDebugContext,\n-                               variable_name: ast::Name,\n-                               variable_type: Ty<'tcx>,\n-                               scope_metadata: DIScope,\n-                               variable_access: VariableAccess,\n-                               variable_kind: VariableKind,\n-                               span: Span) {\n+pub fn declare_local(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    dbg_context: &FunctionDebugContext,\n+    variable_name: ast::Name,\n+    variable_type: Ty<'tcx>,\n+    scope_metadata: DIScope,\n+    variable_access: VariableAccess,\n+    variable_kind: VariableKind,\n+    span: Span,\n+) {\n     assert!(!dbg_context.get_ref(span).source_locations_enabled.get());\n     let cx = bx.cx;\n "}, {"sha": "69d457f2188327ec8832ca482a708cb308fa473a", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -49,8 +49,7 @@ pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n }\n \n #[inline]\n-pub fn debug_context<'a, 'tcx>(cx: &'a CodegenCx<'a, 'tcx>)\n-                           -> &'a CrateDebugContext<'a, 'tcx> {\n+pub fn debug_context(cx: &'a CodegenCx<'ll, 'tcx>) -> &'a CrateDebugContext<'a, 'tcx> {\n     cx.dbg_cx.as_ref().unwrap()\n }\n "}, {"sha": "1a9346ed8933db4a43774c92f95fbaa751f714f9", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -40,13 +40,13 @@ use std::ffi::CString;\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// return its ValueRef instead.\n-pub fn declare_global(cx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n+pub fn declare_global(cx: &CodegenCx, name: &str, ty: &Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     unsafe {\n-        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertGlobal(cx.llmod, namebuf.as_ptr(), ty)\n     }\n }\n \n@@ -55,13 +55,13 @@ pub fn declare_global(cx: &CodegenCx, name: &str, ty: Type) -> llvm::ValueRef {\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type) -> ValueRef {\n+fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: &Type) -> ValueRef {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         bug!(\"name {:?} contains an interior null byte\", name)\n     });\n     let llfn = unsafe {\n-        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty.to_ref())\n+        llvm::LLVMRustGetOrInsertFunction(cx.llmod, namebuf.as_ptr(), ty)\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n@@ -115,7 +115,7 @@ fn declare_raw_fn(cx: &CodegenCx, name: &str, callconv: llvm::CallConv, ty: Type\n ///\n /// If there\u2019s a value with the same name already declared, the function will\n /// update the declaration and return existing ValueRef instead.\n-pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: Type) -> ValueRef {\n+pub fn declare_cfn(cx: &CodegenCx, name: &str, fn_type: &Type) -> ValueRef {\n     declare_raw_fn(cx, name, llvm::CCallConv, fn_type)\n }\n \n@@ -154,7 +154,7 @@ pub fn declare_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, name: &str,\n /// return None if the name already has a definition associated with it. In that\n /// case an error should be reported to the user, because it usually happens due\n /// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n-pub fn define_global(cx: &CodegenCx, name: &str, ty: Type) -> Option<ValueRef> {\n+pub fn define_global(cx: &CodegenCx, name: &str, ty: &Type) -> Option<ValueRef> {\n     if get_defined_value(cx, name).is_some() {\n         None\n     } else {"}, {"sha": "992ff9f24de1347d5415dcd7faa6e0c83dd9ae02", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst(bx: &Builder<'a, 'll, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));"}, {"sha": "7dca1e907a857137a0404d8e7d8aa40e920ede36", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 78, "deletions": 67, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -85,12 +85,14 @@ fn get_simple_intrinsic(cx: &CodegenCx, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_codegen_llvm/context.rs\n-pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                      callee_ty: Ty<'tcx>,\n-                                      fn_ty: &FnType<'tcx, Ty<'tcx>>,\n-                                      args: &[OperandRef<'tcx>],\n-                                      llresult: ValueRef,\n-                                      span: Span) {\n+pub fn codegen_intrinsic_call(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    callee_ty: Ty<'tcx>,\n+    fn_ty: &FnType<'tcx, Ty<'tcx>>,\n+    args: &[OperandRef<'tcx>],\n+    llresult: ValueRef,\n+    span: Span,\n+) {\n     let cx = bx.cx;\n     let tcx = cx.tcx;\n \n@@ -545,7 +547,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n             }\n-            fn ty_to_type(cx: &CodegenCx, t: &intrinsics::Type) -> Vec<Type> {\n+            fn ty_to_type(cx: &CodegenCx<'ll, '_>, t: &intrinsics::Type) -> Vec<&'ll Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n                     Void => vec![Type::void(cx)],\n@@ -567,7 +569,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![Type::vector(&elem, length as u64)]\n+                        vec![Type::vector(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n@@ -587,10 +589,11 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                                          t: &intrinsics::Type,\n-                                          arg: &OperandRef<'tcx>)\n-                                          -> Vec<ValueRef>\n+            fn modify_as_needed(\n+                bx: &Builder<'a, 'll, 'tcx>,\n+                t: &intrinsics::Type,\n+                arg: &OperandRef<'tcx>,\n+            ) -> Vec<ValueRef>\n             {\n                 match *t {\n                     intrinsics::Type::Aggregate(true, ref contents) => {\n@@ -616,7 +619,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bx.cx, llvm_elem));\n-                        vec![bx.bitcast(arg.immediate(), Type::vector(&llvm_elem, length as u64))]\n+                        vec![bx.bitcast(arg.immediate(), Type::vector(llvm_elem, length as u64))]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n@@ -644,7 +647,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 Type::func(&inputs, &outputs));\n+                                                 Type::func(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -677,14 +680,15 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            allow_overlap: bool,\n-                            volatile: bool,\n-                            ty: Ty<'tcx>,\n-                            dst: ValueRef,\n-                            src: ValueRef,\n-                            count: ValueRef)\n-                            -> ValueRef {\n+fn copy_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    allow_overlap: bool,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: ValueRef,\n+    src: ValueRef,\n+    count: ValueRef,\n+) -> ValueRef {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = C_usize(cx, size.bytes());\n@@ -712,8 +716,8 @@ fn copy_intrinsic<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         None)\n }\n \n-fn memset_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+fn memset_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n@@ -728,8 +732,8 @@ fn memset_intrinsic<'a, 'tcx>(\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n \n-fn try_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+fn try_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     cx: &CodegenCx,\n     func: ValueRef,\n     data: ValueRef,\n@@ -754,12 +758,14 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn codegen_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            cx: &CodegenCx,\n-                            func: ValueRef,\n-                            data: ValueRef,\n-                            local_ptr: ValueRef,\n-                            dest: ValueRef) {\n+fn codegen_msvc_try(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    cx: &CodegenCx,\n+    func: ValueRef,\n+    data: ValueRef,\n+    local_ptr: ValueRef,\n+    dest: ValueRef,\n+) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n \n@@ -862,12 +868,14 @@ fn codegen_msvc_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn codegen_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                           cx: &CodegenCx,\n-                           func: ValueRef,\n-                           data: ValueRef,\n-                           local_ptr: ValueRef,\n-                           dest: ValueRef) {\n+fn codegen_gnu_try(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    cx: &CodegenCx,\n+    func: ValueRef,\n+    data: ValueRef,\n+    local_ptr: ValueRef,\n+    dest: ValueRef,\n+) {\n     let llfn = get_rust_try_fn(cx, &mut |bx| {\n         let cx = bx.cx;\n \n@@ -922,12 +930,13 @@ fn codegen_gnu_try<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to codegen a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                    name: &str,\n-                    inputs: Vec<Ty<'tcx>>,\n-                    output: Ty<'tcx>,\n-                    codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n-                    -> ValueRef {\n+fn gen_fn<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    name: &str,\n+    inputs: Vec<Ty<'tcx>>,\n+    output: Ty<'tcx>,\n+    codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n+) -> ValueRef {\n     let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n         output,\n@@ -945,9 +954,10 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n-                             -> ValueRef {\n+fn get_rust_try_fn<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n+) -> ValueRef {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;\n     }\n@@ -972,13 +982,13 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n     span_err!(a, b, E0511, \"{}\", c);\n }\n \n-fn generic_simd_intrinsic<'a, 'tcx>(\n-    bx: &Builder<'a, 'tcx>,\n+fn generic_simd_intrinsic(\n+    bx: &Builder<'a, 'll, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     args: &[OperandRef<'tcx>],\n     ret_ty: Ty<'tcx>,\n-    llret_ty: Type,\n+    llret_ty: &'ll Type,\n     span: Span\n ) -> Result<ValueRef, ()> {\n     // macros for error handling:\n@@ -1145,19 +1155,20 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = Type::i1(bx.cx);\n-        let i1xn = Type::vector(&i1, m_len as u64);\n+        let i1xn = Type::vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n-    fn simd_simple_float_intrinsic<'a, 'tcx>(name: &str,\n-                                             in_elem: &::rustc::ty::TyS,\n-                                             in_ty: &::rustc::ty::TyS,\n-                                             in_len: usize,\n-                                             bx: &Builder<'a, 'tcx>,\n-                                             span: Span,\n-                                             args: &[OperandRef<'tcx>])\n-                                             -> Result<ValueRef, ()> {\n+    fn simd_simple_float_intrinsic(\n+        name: &str,\n+        in_elem: &::rustc::ty::TyS,\n+        in_ty: &::rustc::ty::TyS,\n+        in_len: usize,\n+        bx: &Builder<'a, 'll, 'tcx>,\n+        span: Span,\n+        args: &[OperandRef<'tcx>],\n+    ) -> Result<ValueRef, ()> {\n         macro_rules! emit_error {\n             ($msg: tt) => {\n                 emit_error!($msg, )\n@@ -1283,8 +1294,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         }\n     }\n \n-    fn llvm_vector_ty(cx: &CodegenCx, elem_ty: ty::Ty, vec_len: usize,\n-                      mut no_pointers: usize) -> Type {\n+    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: ty::Ty, vec_len: usize,\n+                      mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n             ty::TyInt(v) => Type::int_from_ty(cx, v),\n@@ -1296,7 +1307,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n             elem_ty = elem_ty.ptr_to();\n             no_pointers -= 1;\n         }\n-        Type::vector(&elem_ty, vec_len as u64)\n+        Type::vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1379,7 +1390,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(&i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1395,7 +1406,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n                                      Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n-                                                  llvm_elem_vec_ty], &llvm_elem_vec_ty));\n+                                                  llvm_elem_vec_ty], llvm_elem_vec_ty));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n                         None);\n@@ -1476,7 +1487,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n             let i1 = Type::i1(bx.cx);\n-            let i1xn = Type::vector(&i1, in_len as u64);\n+            let i1xn = Type::vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1496,7 +1507,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                                      Type::func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n-                                                  mask_ty], &ret_t));\n+                                                  mask_ty], ret_t));\n         llvm::SetUnnamedAddr(f, false);\n         let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask],\n                         None);\n@@ -1629,7 +1640,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n                     // boolean reductions operate on vectors of i1s:\n                     let i1 = Type::i1(bx.cx);\n-                    let i1xn = Type::vector(&i1, in_len as u64);\n+                    let i1xn = Type::vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {"}, {"sha": "1c7988fa8d55526790f094bc198643f652cbc2f7", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -377,8 +377,7 @@ pub enum ThreadLocalMode {\n // Opaque pointer types\n extern { pub type Module; }\n extern { pub type Context; }\n-extern { pub type Type_opaque; }\n-pub type TypeRef = *mut Type_opaque;\n+extern { pub type Type; }\n extern { pub type Value_opaque; }\n pub type ValueRef = *mut Value_opaque;\n extern { pub type Metadata_opaque; }\n@@ -517,55 +516,55 @@ extern \"C\" {\n     pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n-    pub fn LLVMRustGetTypeKind(Ty: TypeRef) -> TypeKind;\n+    pub fn LLVMRustGetTypeKind(Ty: &Type) -> TypeKind;\n \n     // Operations on integer types\n-    pub fn LLVMInt1TypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMInt8TypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMInt16TypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMInt32TypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMInt64TypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMIntTypeInContext(C: &Context, NumBits: c_uint) -> TypeRef;\n+    pub fn LLVMInt1TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt8TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt16TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt32TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMInt64TypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMIntTypeInContext(C: &Context, NumBits: c_uint) -> &Type;\n \n-    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: &Type) -> c_uint;\n \n     // Operations on real types\n-    pub fn LLVMFloatTypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMDoubleTypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMFloatTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMDoubleTypeInContext(C: &Context) -> &Type;\n \n     // Operations on function types\n-    pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                            ParamTypes: *const TypeRef,\n+    pub fn LLVMFunctionType(ReturnType: &'a Type,\n+                            ParamTypes: *const &'a Type,\n                             ParamCount: c_uint,\n                             IsVarArg: Bool)\n-                            -> TypeRef;\n-    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *mut TypeRef);\n+                            -> &'a Type;\n+    pub fn LLVMGetReturnType(FunctionTy: &Type) -> &Type;\n+    pub fn LLVMCountParamTypes(FunctionTy: &Type) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: &'a Type, Dest: *mut &'a Type);\n \n     // Operations on struct types\n-    pub fn LLVMStructTypeInContext(C: &Context,\n-                                   ElementTypes: *const TypeRef,\n+    pub fn LLVMStructTypeInContext(C: &'a Context,\n+                                   ElementTypes: *const &'a Type,\n                                    ElementCount: c_uint,\n                                    Packed: Bool)\n-                                   -> TypeRef;\n-    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+                                   -> &'a Type;\n+    pub fn LLVMIsPackedStruct(StructTy: &Type) -> Bool;\n \n     // Operations on array, pointer, and vector types (sequence types)\n-    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint) -> TypeRef;\n-    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint) -> TypeRef;\n+    pub fn LLVMRustArrayType(ElementType: &Type, ElementCount: u64) -> &Type;\n+    pub fn LLVMPointerType(ElementType: &Type, AddressSpace: c_uint) -> &Type;\n+    pub fn LLVMVectorType(ElementType: &Type, ElementCount: c_uint) -> &Type;\n \n-    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetElementType(Ty: &Type) -> &Type;\n+    pub fn LLVMGetVectorSize(VectorTy: &Type) -> c_uint;\n \n     // Operations on other types\n-    pub fn LLVMVoidTypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMX86MMXTypeInContext(C: &Context) -> TypeRef;\n-    pub fn LLVMRustMetadataTypeInContext(C: &Context) -> TypeRef;\n+    pub fn LLVMVoidTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMX86MMXTypeInContext(C: &Context) -> &Type;\n+    pub fn LLVMRustMetadataTypeInContext(C: &Context) -> &Type;\n \n     // Operations on all values\n-    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub fn LLVMTypeOf(Val: &Value_opaque) -> &Type;\n     pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n     pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n     pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n@@ -580,19 +579,19 @@ extern \"C\" {\n     pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n \n     // Operations on constants of any type\n-    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstNull(Ty: &Type) -> ValueRef;\n     pub fn LLVMConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n     pub fn LLVMConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef;\n-    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMGetUndef(Ty: &Type) -> ValueRef;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> ValueRef;\n     pub fn LLVMMDNodeInContext(C: &Context, Vals: *const ValueRef, Count: c_uint) -> ValueRef;\n     pub fn LLVMAddNamedMetadataOperand(M: &Module, Name: *const c_char, Val: ValueRef);\n \n     // Operations on scalar constants\n-    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n-    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n+    pub fn LLVMConstInt(IntTy: &Type, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: &Type, Wn: c_uint, Ws: *const u64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n@@ -612,14 +611,14 @@ extern \"C\" {\n                                     Packed: Bool)\n                                     -> ValueRef;\n \n-    pub fn LLVMConstArray(ElementTy: TypeRef,\n+    pub fn LLVMConstArray(ElementTy: &Type,\n                           ConstantVals: *const ValueRef,\n                           Length: c_uint)\n                           -> ValueRef;\n     pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint) -> ValueRef;\n \n     // Constant expressions\n-    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: &Type) -> ValueRef;\n     pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n     pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n     pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n@@ -651,23 +650,23 @@ extern \"C\" {\n         ConstantIndices: *const ValueRef,\n         NumIndices: c_uint,\n     ) -> ValueRef;\n-    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n-    pub fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: TypeRef, isSigned: Bool) -> ValueRef;\n-    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef) -> ValueRef;\n+    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n+    pub fn LLVMConstIntCast(ConstantVal: ValueRef, ToType: &Type, isSigned: Bool) -> ValueRef;\n+    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: &Type) -> ValueRef;\n     pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n                                  IdxList: *const c_uint,\n                                  NumIdx: c_uint)\n                                  -> ValueRef;\n-    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n+    pub fn LLVMConstInlineAsm(Ty: &Type,\n                               AsmString: *const c_char,\n                               Constraints: *const c_char,\n                               HasSideEffects: Bool,\n@@ -690,9 +689,9 @@ extern \"C\" {\n \n     // Operations on global variables\n     pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n-    pub fn LLVMAddGlobal(M: &Module, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMAddGlobal(M: &Module, Ty: &Type, Name: *const c_char) -> ValueRef;\n     pub fn LLVMGetNamedGlobal(M: &Module, Name: *const c_char) -> ValueRef;\n-    pub fn LLVMRustGetOrInsertGlobal(M: &Module, Name: *const c_char, T: TypeRef) -> ValueRef;\n+    pub fn LLVMRustGetOrInsertGlobal(M: &Module, Name: *const c_char, T: &Type) -> ValueRef;\n     pub fn LLVMGetFirstGlobal(M: &Module) -> ValueRef;\n     pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n     pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n@@ -706,13 +705,13 @@ extern \"C\" {\n     pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n     // Operations on functions\n-    pub fn LLVMAddFunction(M: &Module, Name: *const c_char, FunctionTy: TypeRef) -> ValueRef;\n+    pub fn LLVMAddFunction(M: &Module, Name: *const c_char, FunctionTy: &Type) -> ValueRef;\n     pub fn LLVMGetNamedFunction(M: &Module, Name: *const c_char) -> ValueRef;\n     pub fn LLVMGetFirstFunction(M: &Module) -> ValueRef;\n     pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n     pub fn LLVMRustGetOrInsertFunction(M: &Module,\n                                        Name: *const c_char,\n-                                       FunctionTy: TypeRef)\n+                                       FunctionTy: &Type)\n                                        -> ValueRef;\n     pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n     pub fn LLVMRustAddAlignmentAttr(Fn: ValueRef, index: c_uint, bytes: u32);\n@@ -801,7 +800,7 @@ extern \"C\" {\n                                Name: *const c_char)\n                                -> ValueRef;\n     pub fn LLVMBuildLandingPad(B: BuilderRef,\n-                               Ty: TypeRef,\n+                               Ty: &Type,\n                                PersFn: ValueRef,\n                                NumClauses: c_uint,\n                                Name: *const c_char)\n@@ -989,7 +988,7 @@ extern \"C\" {\n     pub fn LLVMRustSetHasUnsafeAlgebra(Instr: ValueRef);\n \n     // Memory\n-    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: &Type, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n     pub fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *const c_char) -> ValueRef;\n \n@@ -1024,98 +1023,98 @@ extern \"C\" {\n     // Casts\n     pub fn LLVMBuildTrunc(B: BuilderRef,\n                           Val: ValueRef,\n-                          DestTy: TypeRef,\n+                          DestTy: &Type,\n                           Name: *const c_char)\n                           -> ValueRef;\n     pub fn LLVMBuildZExt(B: BuilderRef,\n                          Val: ValueRef,\n-                         DestTy: TypeRef,\n+                         DestTy: &Type,\n                          Name: *const c_char)\n                          -> ValueRef;\n     pub fn LLVMBuildSExt(B: BuilderRef,\n                          Val: ValueRef,\n-                         DestTy: TypeRef,\n+                         DestTy: &Type,\n                          Name: *const c_char)\n                          -> ValueRef;\n     pub fn LLVMBuildFPToUI(B: BuilderRef,\n                            Val: ValueRef,\n-                           DestTy: TypeRef,\n+                           DestTy: &Type,\n                            Name: *const c_char)\n                            -> ValueRef;\n     pub fn LLVMBuildFPToSI(B: BuilderRef,\n                            Val: ValueRef,\n-                           DestTy: TypeRef,\n+                           DestTy: &Type,\n                            Name: *const c_char)\n                            -> ValueRef;\n     pub fn LLVMBuildUIToFP(B: BuilderRef,\n                            Val: ValueRef,\n-                           DestTy: TypeRef,\n+                           DestTy: &Type,\n                            Name: *const c_char)\n                            -> ValueRef;\n     pub fn LLVMBuildSIToFP(B: BuilderRef,\n                            Val: ValueRef,\n-                           DestTy: TypeRef,\n+                           DestTy: &Type,\n                            Name: *const c_char)\n                            -> ValueRef;\n     pub fn LLVMBuildFPTrunc(B: BuilderRef,\n                             Val: ValueRef,\n-                            DestTy: TypeRef,\n+                            DestTy: &Type,\n                             Name: *const c_char)\n                             -> ValueRef;\n     pub fn LLVMBuildFPExt(B: BuilderRef,\n                           Val: ValueRef,\n-                          DestTy: TypeRef,\n+                          DestTy: &Type,\n                           Name: *const c_char)\n                           -> ValueRef;\n     pub fn LLVMBuildPtrToInt(B: BuilderRef,\n                              Val: ValueRef,\n-                             DestTy: TypeRef,\n+                             DestTy: &Type,\n                              Name: *const c_char)\n                              -> ValueRef;\n     pub fn LLVMBuildIntToPtr(B: BuilderRef,\n                              Val: ValueRef,\n-                             DestTy: TypeRef,\n+                             DestTy: &Type,\n                              Name: *const c_char)\n                              -> ValueRef;\n     pub fn LLVMBuildBitCast(B: BuilderRef,\n                             Val: ValueRef,\n-                            DestTy: TypeRef,\n+                            DestTy: &Type,\n                             Name: *const c_char)\n                             -> ValueRef;\n     pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                   Val: ValueRef,\n-                                  DestTy: TypeRef,\n+                                  DestTy: &Type,\n                                   Name: *const c_char)\n                                   -> ValueRef;\n     pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                   Val: ValueRef,\n-                                  DestTy: TypeRef,\n+                                  DestTy: &Type,\n                                   Name: *const c_char)\n                                   -> ValueRef;\n     pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                    Val: ValueRef,\n-                                   DestTy: TypeRef,\n+                                   DestTy: &Type,\n                                    Name: *const c_char)\n                                    -> ValueRef;\n     pub fn LLVMBuildCast(B: BuilderRef,\n                          Op: Opcode,\n                          Val: ValueRef,\n-                         DestTy: TypeRef,\n+                         DestTy: &Type,\n                          Name: *const c_char)\n                          -> ValueRef;\n     pub fn LLVMBuildPointerCast(B: BuilderRef,\n                                 Val: ValueRef,\n-                                DestTy: TypeRef,\n+                                DestTy: &Type,\n                                 Name: *const c_char)\n                                 -> ValueRef;\n     pub fn LLVMRustBuildIntCast(B: BuilderRef,\n                                 Val: ValueRef,\n-                                DestTy: TypeRef,\n+                                DestTy: &Type,\n                                 IsSized: bool)\n                                 -> ValueRef;\n     pub fn LLVMBuildFPCast(B: BuilderRef,\n                            Val: ValueRef,\n-                           DestTy: TypeRef,\n+                           DestTy: &Type,\n                            Name: *const c_char)\n                            -> ValueRef;\n \n@@ -1134,7 +1133,7 @@ extern \"C\" {\n                          -> ValueRef;\n \n     // Miscellaneous instructions\n-    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildPhi(B: BuilderRef, Ty: &Type, Name: *const c_char) -> ValueRef;\n     pub fn LLVMRustBuildCall(B: BuilderRef,\n                              Fn: ValueRef,\n                              Args: *const ValueRef,\n@@ -1150,7 +1149,7 @@ extern \"C\" {\n                            -> ValueRef;\n     pub fn LLVMBuildVAArg(B: BuilderRef,\n                           list: ValueRef,\n-                          Ty: TypeRef,\n+                          Ty: &Type,\n                           Name: *const c_char)\n                           -> ValueRef;\n     pub fn LLVMBuildExtractElement(B: BuilderRef,\n@@ -1347,15 +1346,15 @@ extern \"C\" {\n     /// Print the pass timings since static dtors aren't picking them up.\n     pub fn LLVMRustPrintPassTimings();\n \n-    pub fn LLVMStructCreateNamed(C: &Context, Name: *const c_char) -> TypeRef;\n+    pub fn LLVMStructCreateNamed(C: &Context, Name: *const c_char) -> &Type;\n \n-    pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                             ElementTypes: *const TypeRef,\n+    pub fn LLVMStructSetBody(StructTy: &'a Type,\n+                             ElementTypes: *const &'a Type,\n                              ElementCount: c_uint,\n                              Packed: Bool);\n \n     /// Prepares inline assembly.\n-    pub fn LLVMRustInlineAsm(Ty: TypeRef,\n+    pub fn LLVMRustInlineAsm(Ty: &Type,\n                              AsmString: *const c_char,\n                              Constraints: *const c_char,\n                              SideEffects: Bool,\n@@ -1587,7 +1586,7 @@ extern \"C\" {\n     pub fn LLVMRustDIBuilderCreateOpDeref() -> i64;\n     pub fn LLVMRustDIBuilderCreateOpPlusUconst() -> i64;\n \n-    pub fn LLVMRustWriteTypeToString(Type: TypeRef, s: RustStringRef);\n+    pub fn LLVMRustWriteTypeToString(Type: &Type, s: RustStringRef);\n     pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n \n     pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;"}, {"sha": "c313c04d8047afd369de4df13a597f7d1f6a72c3", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> VirtualIndex {\n         VirtualIndex(index as u64 + 3)\n     }\n \n-    pub fn get_fn(self, bx: &Builder<'a, 'tcx>,\n+    pub fn get_fn(self, bx: &Builder<'a, 'll, 'tcx>,\n                   llvtable: ValueRef,\n                   fn_ty: &FnType<'tcx, Ty<'tcx>>) -> ValueRef {\n         // Load the data pointer from the object.\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> VirtualIndex {\n         ptr\n     }\n \n-    pub fn get_usize(self, bx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n+    pub fn get_usize(self, bx: &Builder<'a, 'll, 'tcx>, llvtable: ValueRef) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n "}, {"sha": "7bf548a6b12d5bfef7ae8054244a5706d18f2a8b", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Local> {\n+pub fn non_ssa_locals(fx: &FunctionCx<'a, 'll, 'tcx>) -> BitVector<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -51,17 +51,17 @@ pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Loc\n     analyzer.non_ssa_locals\n }\n \n-struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n-    fx: &'mir FunctionCx<'a, 'tcx>,\n+struct LocalAnalyzer<'mir, 'a: 'mir, 'll: 'a, 'tcx: 'll> {\n+    fx: &'mir FunctionCx<'a, 'll, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitVector<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n }\n \n-impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n+impl LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n+    fn new(fx: &'mir FunctionCx<'a, 'll, 'tcx>) -> Self {\n         let invalid_location =\n             mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n@@ -102,7 +102,7 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n     }\n }\n \n-impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n+impl Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'll, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     place: &mir::Place<'tcx>,"}, {"sha": "349978c18b7e6465c034e1f71a964893378827f0", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -33,7 +33,7 @@ use super::place::PlaceRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n         let mut bx = self.build_block(bb);\n         let data = &self.mir[bb];\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_terminator(&mut self,\n-                        mut bx: Builder<'a, 'tcx>,\n+                        mut bx: Builder<'a, 'll, 'tcx>,\n                         bb: mir::BasicBlock,\n                         terminator: &mir::Terminator<'tcx>)\n     {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n         let do_call = |\n             this: &mut Self,\n-            bx: Builder<'a, 'tcx>,\n+            bx: Builder<'a, 'll, 'tcx>,\n             fn_ty: FnType<'tcx, Ty<'tcx>>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_argument(&mut self,\n-                      bx: &Builder<'a, 'tcx>,\n+                      bx: &Builder<'a, 'll, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn codegen_arguments_untupled(&mut self,\n-                                bx: &Builder<'a, 'tcx>,\n+                                bx: &Builder<'a, 'll, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 args: &[ArgType<'tcx, Ty<'tcx>>]) {\n@@ -728,7 +728,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn get_personality_slot(&mut self, bx: &Builder<'a, 'tcx>) -> PlaceRef<'tcx> {\n+    fn get_personality_slot(&mut self, bx: &Builder<'a, 'll, 'tcx>) -> PlaceRef<'tcx> {\n         let cx = bx.cx;\n         if let Some(slot) = self.personality_slot {\n             slot\n@@ -777,7 +777,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         bx.llbb()\n     }\n \n-    fn landing_pad_type(&self) -> Type {\n+    fn landing_pad_type(&self) -> &'ll Type {\n         let cx = self.cx;\n         Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false)\n     }\n@@ -791,17 +791,17 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+    pub fn new_block(&self, name: &str) -> Builder<'a, 'll, 'tcx> {\n         Builder::new_block(self.cx, self.llfn, name)\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'll, 'tcx> {\n         let bx = Builder::with_cx(self.cx);\n         bx.position_at_end(self.blocks[bb]);\n         bx\n     }\n \n-    fn make_return_dest(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                         dest: &mir::Place<'tcx>, fn_ret: &ArgType<'tcx, Ty<'tcx>>,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n                         -> ReturnDest<'tcx> {\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                        src: &mir::Operand<'tcx>,\n                        dst: &mir::Place<'tcx>) {\n         if let mir::Place::Local(index) = *dst {\n@@ -884,7 +884,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         }\n     }\n \n-    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'tcx>,\n+    fn codegen_transmute_into(&mut self, bx: &Builder<'a, 'll, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n                             dst: PlaceRef<'tcx>) {\n         let src = self.codegen_operand(bx, src);\n@@ -897,7 +897,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bx: &Builder<'a, 'tcx>,\n+                    bx: &Builder<'a, 'll, 'tcx>,\n                     dest: ReturnDest<'tcx>,\n                     ret_ty: &ArgType<'tcx, Ty<'tcx>>,\n                     llval: ValueRef) {"}, {"sha": "3fc86af3e6d40f0711a2c555accf06e8d71eb220", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -33,7 +33,7 @@ use super::FunctionCx;\n pub fn scalar_to_llvm(cx: &CodegenCx,\n                        cv: Scalar,\n                        layout: &layout::Scalar,\n-                       llty: Type) -> ValueRef {\n+                       llty: &Type) -> ValueRef {\n     let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n         Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n@@ -42,7 +42,7 @@ pub fn scalar_to_llvm(cx: &CodegenCx,\n         Scalar::Bits { bits, .. } => {\n             let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n-                unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n+                unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n@@ -73,7 +73,7 @@ pub fn scalar_to_llvm(cx: &CodegenCx,\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n-                unsafe { llvm::LLVMConstPtrToInt(llval, llty.to_ref()) }\n+                unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n@@ -135,10 +135,10 @@ pub fn codegen_static_initializer<'a, 'tcx>(\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     fn fully_evaluate(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         constant: &'tcx ty::Const<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         match constant.val {\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n     pub fn eval_mir_constant(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         let c = self.monomorphize(&constant.literal);\n@@ -168,7 +168,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     /// process constant containing SIMD shuffle indices\n     pub fn simd_shuffle_indices(\n         &mut self,\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n         constant: Result<&'tcx ty::Const<'tcx>, Lrc<ConstEvalErr<'tcx>>>,"}, {"sha": "4b33459740c5541806c02bdd7dd6918e80eb930a", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -43,7 +43,7 @@ use rustc::mir::traversal;\n use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n-pub struct FunctionCx<'a, 'tcx:'a> {\n+pub struct FunctionCx<'a, 'll: 'a, 'tcx: 'll> {\n     instance: Instance<'tcx>,\n \n     mir: &'a mir::Mir<'tcx>,\n@@ -52,7 +52,7 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n \n     llfn: ValueRef,\n \n-    cx: &'a CodegenCx<'a, 'tcx>,\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n \n     fn_ty: FnType<'tcx, Ty<'tcx>>,\n \n@@ -106,7 +106,7 @@ pub struct FunctionCx<'a, 'tcx:'a> {\n     param_substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n@@ -198,8 +198,8 @@ impl<'a, 'tcx> LocalRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn codegen_mir<'a, 'tcx: 'a>(\n-    cx: &'a CodegenCx<'a, 'tcx>,\n+pub fn codegen_mir(\n+    cx: &'a CodegenCx<'ll, 'tcx>,\n     llfn: ValueRef,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n@@ -344,9 +344,9 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n     }\n }\n \n-fn create_funclets<'a, 'tcx>(\n+fn create_funclets(\n     mir: &'a Mir<'tcx>,\n-    bx: &Builder<'a, 'tcx>,\n+    bx: &Builder<'a, 'll, 'tcx>,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n     -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n@@ -413,11 +413,12 @@ fn create_funclets<'a, 'tcx>(\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n-                            fx: &FunctionCx<'a, 'tcx>,\n-                            scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n-                            memory_locals: &BitVector<mir::Local>)\n-                            -> Vec<LocalRef<'tcx>> {\n+fn arg_local_refs(\n+    bx: &Builder<'a, 'll, 'tcx>,\n+    fx: &FunctionCx<'a, 'll, 'tcx>,\n+    scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n+    memory_locals: &BitVector<mir::Local>,\n+) -> Vec<LocalRef<'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n     let mut idx = 0;"}, {"sha": "790dbae447bd4ddb87ebebabe8ea6c84f850d996", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn from_const(bx: &Builder<'a, 'tcx>,\n+    pub fn from_const(bx: &Builder<'a, 'll, 'tcx>,\n                       val: &'tcx ty::Const<'tcx>)\n                       -> Result<OperandRef<'tcx>, Lrc<ConstEvalErr<'tcx>>> {\n         let layout = bx.cx.layout_of(val.ty);\n@@ -174,7 +174,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a `Pair`, we return an aggregate with the two values.\n     /// For other cases, see `immediate`.\n-    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'tcx>) -> ValueRef {\n+    pub fn immediate_or_packed_pair(self, bx: &Builder<'a, 'll, 'tcx>) -> ValueRef {\n         if let OperandValue::Pair(a, b) = self.val {\n             let llty = self.layout.llvm_type(bx.cx);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n \n     /// If the type is a pair, we return a `Pair`, otherwise, an `Immediate`.\n-    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'tcx>,\n+    pub fn from_immediate_or_packed_pair(bx: &Builder<'a, 'll, 'tcx>,\n                                          llval: ValueRef,\n                                          layout: TyLayout<'tcx>)\n                                          -> OperandRef<'tcx> {\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         OperandRef { val, layout }\n     }\n \n-    pub fn extract_field(&self, bx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+    pub fn extract_field(&self, bx: &Builder<'a, 'll, 'tcx>, i: usize) -> OperandRef<'tcx> {\n         let field = self.layout.field(bx.cx, i);\n         let offset = self.layout.fields.offset(i);\n \n@@ -267,23 +267,23 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandValue {\n-    pub fn store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::empty());\n     }\n \n-    pub fn volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE);\n     }\n \n-    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn unaligned_volatile_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::VOLATILE | MemFlags::UNALIGNED);\n     }\n \n-    pub fn nontemporal_store(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>) {\n+    pub fn nontemporal_store(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>) {\n         self.store_with_flags(bx, dest, MemFlags::NONTEMPORAL);\n     }\n \n-    fn store_with_flags(self, bx: &Builder<'a, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n+    fn store_with_flags(self, bx: &Builder<'a, 'll, 'tcx>, dest: PlaceRef<'tcx>, flags: MemFlags) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n@@ -310,9 +310,9 @@ impl<'a, 'tcx> OperandValue {\n     }\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     fn maybe_codegen_consume_direct(&mut self,\n-                                  bx: &Builder<'a, 'tcx>,\n+                                  bx: &Builder<'a, 'll, 'tcx>,\n                                   place: &mir::Place<'tcx>)\n                                    -> Option<OperandRef<'tcx>>\n     {\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_consume(&mut self,\n-                         bx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'll, 'tcx>,\n                          place: &mir::Place<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_operand(&mut self,\n-                         bx: &Builder<'a, 'tcx>,\n+                         bx: &Builder<'a, 'll, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {"}, {"sha": "9cb513e21586a3ba001ad8f4188dd27aa9a9edc8", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     pub fn from_const_alloc(\n-        bx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'll, 'tcx>,\n         layout: TyLayout<'tcx>,\n         alloc: &mir::interpret::Allocation,\n         offset: Size,\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n-    pub fn alloca(bx: &Builder<'a, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n+    pub fn alloca(bx: &Builder<'a, 'll, 'tcx>, layout: TyLayout<'tcx>, name: &str)\n                   -> PlaceRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bx.alloca(layout.llvm_type(bx.cx), name, layout.align);\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n-    pub fn load(&self, bx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn load(&self, bx: &Builder<'a, 'll, 'tcx>) -> OperandRef<'tcx> {\n         debug!(\"PlaceRef::load: {:?}\", self);\n \n         assert!(!self.has_extra());\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Access a field, at a point when the value's case is known.\n-    pub fn project_field(self, bx: &Builder<'a, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n+    pub fn project_field(self, bx: &Builder<'a, 'll, 'tcx>, ix: usize) -> PlaceRef<'tcx> {\n         let cx = bx.cx;\n         let field = self.layout.field(cx, ix);\n         let offset = self.layout.fields.offset(ix);\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n     }\n \n     /// Obtain the actual discriminant of a value.\n-    pub fn codegen_get_discr(self, bx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+    pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n-    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'tcx>, variant_index: usize) {\n+    pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n         if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn project_index(&self, bx: &Builder<'a, 'tcx>, llindex: ValueRef)\n+    pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: ValueRef)\n                          -> PlaceRef<'tcx> {\n         PlaceRef {\n             llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         }\n     }\n \n-    pub fn project_downcast(&self, bx: &Builder<'a, 'tcx>, variant_index: usize)\n+    pub fn project_downcast(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize)\n                             -> PlaceRef<'tcx> {\n         let mut downcast = *self;\n         downcast.layout = self.layout.for_variant(bx.cx, variant_index);\n@@ -406,18 +406,18 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n         downcast\n     }\n \n-    pub fn storage_live(&self, bx: &Builder<'a, 'tcx>) {\n+    pub fn storage_live(&self, bx: &Builder<'a, 'll, 'tcx>) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n \n-    pub fn storage_dead(&self, bx: &Builder<'a, 'tcx>) {\n+    pub fn storage_dead(&self, bx: &Builder<'a, 'll, 'tcx>) {\n         bx.lifetime_end(self.llval, self.layout.size);\n     }\n }\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_place(&mut self,\n-                        bx: &Builder<'a, 'tcx>,\n+                        bx: &Builder<'a, 'll, 'tcx>,\n                         place: &mir::Place<'tcx>)\n                         -> PlaceRef<'tcx> {\n         debug!(\"codegen_place(place={:?})\", place);"}, {"sha": "ca61f94e428179a2c4fa8a2a015119692c68a838", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -32,12 +32,12 @@ use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_rvalue(&mut self,\n-                        bx: Builder<'a, 'tcx>,\n+                        bx: Builder<'a, 'll, 'tcx>,\n                         dest: PlaceRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> Builder<'a, 'tcx>\n+                        -> Builder<'a, 'll, 'tcx>\n     {\n         debug!(\"codegen_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n@@ -176,9 +176,9 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_rvalue_operand(&mut self,\n-                                bx: Builder<'a, 'tcx>,\n+                                bx: Builder<'a, 'll, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'll, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot codegen {:?} to operand\", rvalue);\n \n@@ -512,7 +512,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     fn evaluate_array_len(&mut self,\n-                          bx: &Builder<'a, 'tcx>,\n+                          bx: &Builder<'a, 'll, 'tcx>,\n                           place: &mir::Place<'tcx>) -> ValueRef\n     {\n         // ZST are passed as operands and require special handling\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_scalar_binop(&mut self,\n-                              bx: &Builder<'a, 'tcx>,\n+                              bx: &Builder<'a, 'll, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_fat_ptr_binop(&mut self,\n-                               bx: &Builder<'a, 'tcx>,\n+                               bx: &Builder<'a, 'll, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -644,7 +644,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     }\n \n     pub fn codegen_scalar_checked_binop(&mut self,\n-                                      bx: &Builder<'a, 'tcx>,\n+                                      bx: &Builder<'a, 'll, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -796,11 +796,11 @@ fn get_overflow_intrinsic(oop: OverflowOp, bx: &Builder, ty: Ty) -> ValueRef {\n     bx.cx.get_intrinsic(&name)\n }\n \n-fn cast_int_to_float(bx: &Builder,\n+fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n                      x: ValueRef,\n-                     int_ty: Type,\n-                     float_ty: Type) -> ValueRef {\n+                     int_ty: &'ll Type,\n+                     float_ty: &'ll Type) -> ValueRef {\n     // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n@@ -826,11 +826,11 @@ fn cast_int_to_float(bx: &Builder,\n     }\n }\n \n-fn cast_float_to_int(bx: &Builder,\n+fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n                      signed: bool,\n                      x: ValueRef,\n-                     float_ty: Type,\n-                     int_ty: Type) -> ValueRef {\n+                     float_ty: &'ll Type,\n+                     int_ty: &'ll Type) -> ValueRef {\n     let fptosui_result = if signed {\n         bx.fptosi(x, int_ty)\n     } else {\n@@ -859,22 +859,22 @@ fn cast_float_to_int(bx: &Builder,\n     // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n     // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n     // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n-    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128) {\n+    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: &Type) -> (u128, u128) {\n         let rounded_min = F::from_i128_r(int_min(signed, int_ty), Round::TowardZero);\n         assert_eq!(rounded_min.status, Status::OK);\n         let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n         assert!(rounded_max.value.is_finite());\n         (rounded_min.value.to_bits(), rounded_max.value.to_bits())\n     }\n-    fn int_max(signed: bool, int_ty: Type) -> u128 {\n+    fn int_max(signed: bool, int_ty: &Type) -> u128 {\n         let shift_amount = 128 - int_ty.int_width();\n         if signed {\n             i128::MAX as u128 >> shift_amount\n         } else {\n             u128::MAX >> shift_amount\n         }\n     }\n-    fn int_min(signed: bool, int_ty: Type) -> i128 {\n+    fn int_min(signed: bool, int_ty: &Type) -> i128 {\n         if signed {\n             i128::MIN >> (128 - int_ty.int_width())\n         } else {"}, {"sha": "06340a3e5d8b43f01e898c16bc782d94c00e7005", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -16,11 +16,11 @@ use builder::Builder;\n use super::FunctionCx;\n use super::LocalRef;\n \n-impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n+impl FunctionCx<'a, 'll, 'tcx> {\n     pub fn codegen_statement(&mut self,\n-                           bx: Builder<'a, 'tcx>,\n+                           bx: Builder<'a, 'll, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> Builder<'a, 'tcx> {\n+                           -> Builder<'a, 'll, 'tcx> {\n         debug!(\"codegen_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bx, statement.source_info);"}, {"sha": "4e3a82f0d74e5e3652cd68c5192134ac6e8fbde0", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 119, "deletions": 101, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -10,8 +10,10 @@\n \n #![allow(non_upper_case_globals)]\n \n+pub use llvm::Type;\n+\n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind};\n+use llvm::{Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CodegenCx;\n@@ -21,121 +23,125 @@ use rustc::ty::layout::{self, Align, Size};\n \n use std::ffi::CString;\n use std::fmt;\n-use std::mem;\n \n use libc::c_uint;\n \n-#[derive(Clone, Copy, PartialEq)]\n-#[repr(C)]\n-pub struct Type {\n-    rf: TypeRef\n+impl PartialEq for Type {\n+    fn eq(&self, other: &Self) -> bool {\n+        self as *const _ == other as *const _\n+    }\n }\n \n impl fmt::Debug for Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n-            llvm::LLVMRustWriteTypeToString(self.to_ref(), s);\n+            llvm::LLVMRustWriteTypeToString(self, s);\n         }).expect(\"non-UTF8 type description from LLVM\"))\n     }\n }\n \n-macro_rules! ty {\n-    ($e:expr) => ( Type::from_ref(unsafe { $e }))\n-}\n-\n-/// Wrapper for LLVM TypeRef\n impl Type {\n-    #[inline(always)]\n-    pub fn from_ref(r: TypeRef) -> Type {\n-        Type {\n-            rf: r\n+    pub fn void(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMVoidTypeInContext(cx.llcx)\n         }\n     }\n \n-    #[inline(always)] // So it doesn't kill --opt-level=0 builds of the compiler\n-    pub fn to_ref(&self) -> TypeRef {\n-        self.rf\n-    }\n-\n-    pub fn to_ref_slice(slice: &[Type]) -> &[TypeRef] {\n-        unsafe { mem::transmute(slice) }\n-    }\n-\n-    pub fn void(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(cx.llcx))\n-    }\n-\n-    pub fn metadata(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMRustMetadataTypeInContext(cx.llcx))\n+    pub fn metadata(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMRustMetadataTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i1(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(cx.llcx))\n+    pub fn i1(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt1TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i8(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(cx.llcx))\n+    pub fn i8(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i8_llcx(llcx: &llvm::Context) -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(llcx))\n+    pub fn i8_llcx(llcx: &llvm::Context) -> &Type {\n+        unsafe {\n+            llvm::LLVMInt8TypeInContext(llcx)\n+        }\n     }\n \n-    pub fn i16(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(cx.llcx))\n+    pub fn i16(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt16TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i32(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(cx.llcx))\n+    pub fn i32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt32TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i64(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(cx.llcx))\n+    pub fn i64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMInt64TypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn i128(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(cx.llcx, 128))\n+    pub fn i128(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(cx.llcx, 128)\n+        }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix(cx: &CodegenCx, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint))\n+    pub fn ix(cx: &CodegenCx<'ll, '_>, num_bits: u64) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(cx.llcx, num_bits as c_uint)\n+        }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> Type {\n-        ty!(llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint))\n+    pub fn ix_llcx(llcx: &llvm::Context, num_bits: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMIntTypeInContext(llcx, num_bits as c_uint)\n+        }\n     }\n \n-    pub fn f32(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(cx.llcx))\n+    pub fn f32(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFloatTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn f64(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(cx.llcx))\n+    pub fn f64(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMDoubleTypeInContext(cx.llcx)\n+        }\n     }\n \n-    pub fn bool(cx: &CodegenCx) -> Type {\n+    pub fn bool(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i8(cx)\n     }\n \n-    pub fn char(cx: &CodegenCx) -> Type {\n+    pub fn char(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i32(cx)\n     }\n \n-    pub fn i8p(cx: &CodegenCx) -> Type {\n+    pub fn i8p(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         Type::i8(cx).ptr_to()\n     }\n \n-    pub fn i8p_llcx(llcx: &llvm::Context) -> Type {\n+    pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn isize(cx: &CodegenCx) -> Type {\n+    pub fn isize(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         cx.isize_ty\n     }\n \n-    pub fn c_int(cx: &CodegenCx) -> Type {\n+    pub fn c_int(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match &cx.tcx.sess.target.target.target_c_int_width[..] {\n             \"16\" => Type::i16(cx),\n             \"32\" => Type::i32(cx),\n@@ -144,7 +150,7 @@ impl Type {\n         }\n     }\n \n-    pub fn int_from_ty(cx: &CodegenCx, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::IntTy) -> &'ll Type {\n         match t {\n             ast::IntTy::Isize => cx.isize_ty,\n             ast::IntTy::I8 => Type::i8(cx),\n@@ -155,7 +161,7 @@ impl Type {\n         }\n     }\n \n-    pub fn uint_from_ty(cx: &CodegenCx, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::UintTy) -> &'ll Type {\n         match t {\n             ast::UintTy::Usize => cx.isize_ty,\n             ast::UintTy::U8 => Type::i8(cx),\n@@ -166,83 +172,93 @@ impl Type {\n         }\n     }\n \n-    pub fn float_from_ty(cx: &CodegenCx, t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(cx: &CodegenCx<'ll, '_>, t: ast::FloatTy) -> &'ll Type {\n         match t {\n             ast::FloatTy::F32 => Type::f32(cx),\n             ast::FloatTy::F64 => Type::f64(cx),\n         }\n     }\n \n-    pub fn func(args: &[Type], ret: &Type) -> Type {\n-        let slice: &[TypeRef] = Type::to_ref_slice(args);\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), slice.as_ptr(),\n-                                   args.len() as c_uint, False))\n+    pub fn func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFunctionType(ret, args.as_ptr(),\n+                                   args.len() as c_uint, False)\n+        }\n     }\n \n-    pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n-        let slice: &[TypeRef] = Type::to_ref_slice(args);\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), slice.as_ptr(),\n-                                   args.len() as c_uint, True))\n+    pub fn variadic_func(args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMFunctionType(ret, args.as_ptr(),\n+                                   args.len() as c_uint, True)\n+        }\n     }\n \n-    pub fn struct_(cx: &CodegenCx, els: &[Type], packed: bool) -> Type {\n-        let els: &[TypeRef] = Type::to_ref_slice(els);\n-        ty!(llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n+    pub fn struct_(cx: &CodegenCx<'ll, '_>, els: &[&'ll Type], packed: bool) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMStructTypeInContext(cx.llcx, els.as_ptr(),\n                                           els.len() as c_uint,\n-                                          packed as Bool))\n+                                          packed as Bool)\n+        }\n     }\n \n-    pub fn named_struct(cx: &CodegenCx, name: &str) -> Type {\n+    pub fn named_struct(cx: &CodegenCx<'ll, '_>, name: &str) -> &'ll Type {\n         let name = CString::new(name).unwrap();\n-        ty!(llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr()))\n+        unsafe {\n+            llvm::LLVMStructCreateNamed(cx.llcx, name.as_ptr())\n+        }\n     }\n \n \n-    pub fn array(ty: &Type, len: u64) -> Type {\n-        ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n+    pub fn array(ty: &Type, len: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMRustArrayType(ty, len)\n+        }\n     }\n \n-    pub fn vector(ty: &Type, len: u64) -> Type {\n-        ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n+    pub fn vector(ty: &Type, len: u64) -> &Type {\n+        unsafe {\n+            llvm::LLVMVectorType(ty, len as c_uint)\n+        }\n     }\n \n     pub fn kind(&self) -> TypeKind {\n         unsafe {\n-            llvm::LLVMRustGetTypeKind(self.to_ref())\n+            llvm::LLVMRustGetTypeKind(self)\n         }\n     }\n \n-    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n-        let slice: &[TypeRef] = Type::to_ref_slice(els);\n+    pub fn set_struct_body(&'ll self, els: &[&'ll Type], packed: bool) {\n         unsafe {\n-            llvm::LLVMStructSetBody(self.to_ref(), slice.as_ptr(),\n+            llvm::LLVMStructSetBody(self, els.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n \n-    pub fn ptr_to(&self) -> Type {\n-        ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n+    pub fn ptr_to(&self) -> &Type {\n+        unsafe {\n+            llvm::LLVMPointerType(self, 0)\n+        }\n     }\n \n-    pub fn element_type(&self) -> Type {\n+    pub fn element_type(&self) -> &Type {\n         unsafe {\n-            Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n+            llvm::LLVMGetElementType(self)\n         }\n     }\n \n     /// Return the number of elements in `self` if it is a LLVM vector type.\n     pub fn vector_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self.to_ref()) as usize\n+            llvm::LLVMGetVectorSize(self) as usize\n         }\n     }\n \n-    pub fn func_params(&self) -> Vec<Type> {\n+    pub fn func_params(&self) -> Vec<&Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n-            let mut args = vec![Type { rf: 0 as *mut _ }; n_args];\n-            llvm::LLVMGetParamTypes(self.to_ref(),\n-                                    args.as_mut_ptr() as *mut TypeRef);\n+            let n_args = llvm::LLVMCountParamTypes(self) as usize;\n+            let mut args = Vec::with_capacity(n_args);\n+            llvm::LLVMGetParamTypes(self, args.as_mut_ptr());\n+            args.set_len(n_args);\n             args\n         }\n     }\n@@ -260,11 +276,11 @@ impl Type {\n     /// Retrieve the bit width of the integer type `self`.\n     pub fn int_width(&self) -> u64 {\n         unsafe {\n-            llvm::LLVMGetIntTypeWidth(self.to_ref()) as u64\n+            llvm::LLVMGetIntTypeWidth(self) as u64\n         }\n     }\n \n-    pub fn from_integer(cx: &CodegenCx, i: layout::Integer) -> Type {\n+    pub fn from_integer(cx: &CodegenCx<'ll, '_>, i: layout::Integer) -> &'ll Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n             I8 => Type::i8(cx),\n@@ -277,23 +293,25 @@ impl Type {\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(cx: &CodegenCx, align: Align) -> Type {\n+    pub fn pointee_for_abi_align(cx: &CodegenCx<'ll, '_>, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(cx, align);\n         Type::from_integer(cx, ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(cx: &CodegenCx, size: Size, align: Align) -> Type {\n+    pub fn padding_filler(cx: &CodegenCx<'ll, '_>, size: Size, align: Align) -> &'ll Type {\n         let unit = layout::Integer::approximate_abi_align(cx, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        Type::array(&Type::from_integer(cx, unit), size / unit_size)\n+        Type::array(Type::from_integer(cx, unit), size / unit_size)\n     }\n \n-    pub fn x86_mmx(cx: &CodegenCx) -> Type {\n-        ty!(llvm::LLVMX86MMXTypeInContext(cx.llcx))\n+    pub fn x86_mmx(cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMX86MMXTypeInContext(cx.llcx)\n+        }\n     }\n }"}, {"sha": "5fd4f15acd1574c719cda4a117994e0c2bd0f3b6", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04e66d1144a66198422dd380254e8e943d46a49/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=d04e66d1144a66198422dd380254e8e943d46a49", "patch": "@@ -23,8 +23,8 @@ use std::fmt::Write;\n \n fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                 layout: TyLayout<'tcx>,\n-                                defer: &mut Option<(Type, TyLayout<'tcx>)>)\n-                                -> Type {\n+                                defer: &mut Option<(&'a Type, TyLayout<'tcx>)>)\n+                                -> &'a Type {\n     match layout.abi {\n         layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         layout::Abi::Vector { ref element, count } => {\n@@ -42,7 +42,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 return Type::x86_mmx(cx)\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return Type::vector(&element, count);\n+                return Type::vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n@@ -96,7 +96,7 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            Type::array(&layout.field(cx, 0).llvm_type(cx), count)\n+            Type::array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n@@ -116,14 +116,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                              layout: TyLayout<'tcx>)\n-                             -> (Vec<Type>, bool) {\n+                             -> (Vec<&'a Type>, bool) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n \n     let mut packed = false;\n     let mut offset = Size::ZERO;\n     let mut prev_align = layout.align;\n-    let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n+    let mut result: Vec<_> = Vec::with_capacity(1 + field_count * 2);\n     for i in layout.fields.index_by_increasing_offset() {\n         let field = layout.field(cx, i);\n         packed |= layout.align.abi() < field.align.abi();\n@@ -201,12 +201,12 @@ pub struct PointeeInfo {\n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n-    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n-    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type;\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                               scalar: &layout::Scalar, offset: Size) -> Type;\n+                               scalar: &layout::Scalar, offset: Size) -> &'a Type;\n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize, immediate: bool) -> Type;\n+                                         index: usize, immediate: bool) -> &'a Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size)\n                            -> Option<PointeeInfo>;\n@@ -244,7 +244,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -304,15 +304,15 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         cx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n \n-        if let Some((mut llty, layout)) = defer {\n+        if let Some((llty, layout)) = defer {\n             let (llfields, packed) = struct_llfields(cx, layout);\n             llty.set_struct_body(&llfields, packed)\n         }\n \n         llty\n     }\n \n-    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n+    fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n                 return Type::i1(cx);\n@@ -322,7 +322,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                               scalar: &layout::Scalar, offset: Size) -> Type {\n+                               scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n             layout::Int(i, _) => Type::from_integer(cx, i),\n             layout::Float(FloatTy::F32) => Type::f32(cx),\n@@ -340,7 +340,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn scalar_pair_element_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n-                                         index: usize, immediate: bool) -> Type {\n+                                         index: usize, immediate: bool) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.sty {"}]}