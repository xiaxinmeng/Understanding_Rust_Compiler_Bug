{"sha": "2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYzZjZGY2YTE4N2Q1NDkxYWY3ZGEzNmI3ODZiMmJiZDJmZDZlMzk=", "commit": {"author": {"name": "Rusty Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-09-28T02:10:29Z"}, "committer": {"name": "Rusty Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-09-28T02:10:29Z"}, "message": "Ran RustFmt on the file", "tree": {"sha": "c14fd1a556362a6a7f13a04665641fb27f51013e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c14fd1a556362a6a7f13a04665641fb27f51013e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "html_url": "https://github.com/rust-lang/rust/commit/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39/comments", "author": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41", "html_url": "https://github.com/rust-lang/rust/commit/c9865b1c37f8cb8a257591e6ea0b32a5df1f3d41"}], "stats": {"total": 440, "additions": 234, "deletions": 206}, "files": [{"sha": "a62051121a3540020e2f414c5ff44978c3abe78d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 234, "deletions": 206, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=2ac6cdf6a187d5491af7da36b786b2bbd2fd6e39", "patch": "@@ -8,22 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::WriteKind;\n-use borrow_check::prefixes::IsPrefixOf;\n use borrow_check::nll::explain_borrow::BorrowExplanation;\n+use borrow_check::prefixes::IsPrefixOf;\n+use borrow_check::WriteKind;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, FakeReadCause, Field, Local,\n     LocalDecl, LocalKind, Location, Operand, Place, PlaceProjection, ProjectionElem, Rvalue,\n     Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n use rustc::ty;\n+use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc::util::ppaux::with_highlight_region_for_bound_region;\n use syntax_pos::Span;\n \n use super::borrow_set::BorrowData;\n@@ -45,12 +45,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} place={:?} \\\n-            span={:?} mpi={:?}\",\n+             span={:?} mpi={:?}\",\n             context, desired_action, place, span, mpi\n         );\n \n-        let use_spans = self\n-            .move_spans(place, context.loc)\n+        let use_spans = self.move_spans(place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n@@ -60,7 +59,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if mois.is_empty() {\n             let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n \n-            if self.uninitialized_error_reported.contains(&root_place.clone()) {\n+            if self.uninitialized_error_reported\n+                .contains(&root_place.clone())\n+            {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n@@ -77,8 +78,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n-                &self\n-                    .describe_place_with_options(place, IncludingDowncast(true))\n+                &self.describe_place_with_options(place, IncludingDowncast(true))\n                     .unwrap_or(\"_\".to_owned()),\n                 Origin::Mir,\n             );\n@@ -92,9 +92,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             err.buffer(&mut self.errors_buffer);\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&mois) {\n-                if self.prefixes(&reported_place, PrefixSet::All).any(|p| p == place) {\n-                    debug!(\"report_use_of_moved_or_uninitialized place: error suppressed \\\n-                           mois={:?}\", mois);\n+                if self.prefixes(&reported_place, PrefixSet::All)\n+                    .any(|p| p == place)\n+                {\n+                    debug!(\n+                        \"report_use_of_moved_or_uninitialized place: error suppressed \\\n+                         mois={:?}\",\n+                        mois\n+                    );\n                     return;\n                 }\n             }\n@@ -170,9 +175,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     let place = &self.move_data.move_paths[mpi].place;\n \n                     if let Some(ty) = self.retrieve_type_for_place(place) {\n-                        let note_msg = match self\n-                            .describe_place_with_options(place, IncludingDowncast(true))\n-                        {\n+                        let note_msg = match self.describe_place_with_options(\n+                            place,\n+                            IncludingDowncast(true),\n+                        ) {\n                             Some(name) => format!(\"`{}`\", name),\n                             None => \"value\".to_owned(),\n                         };\n@@ -186,10 +192,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            if let Some((_, mut old_err)) = self.move_error_reported.insert(\n-                mois,\n-                (place.clone(), err)\n-            ) {\n+            if let Some((_, mut old_err)) =\n+                self.move_error_reported.insert(mois, (place.clone(), err))\n+            {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();\n             }\n@@ -255,8 +260,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             borrow_span,\n-            &self\n-                .describe_place(&borrow.borrowed_place)\n+            &self.describe_place(&borrow.borrowed_place)\n                 .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n@@ -299,8 +303,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"mutable\",\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n-            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => tcx\n-                .cannot_reborrow_already_borrowed(\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n+                tcx.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -311,27 +315,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => tcx\n-                .cannot_mutably_borrow_multiply(\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n+                tcx.cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => tcx\n-                .cannot_uniquely_borrow_by_two_closures(\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n                     issued_span,\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n             (BorrowKind::Mut { .. }, _, _, BorrowKind::Shallow, _, _)\n             | (BorrowKind::Unique, _, _, BorrowKind::Shallow, _, _) => {\n@@ -344,10 +351,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n                 borrow_spans.var_span_label(\n                     &mut err,\n-                    format!(\n-                        \"borrow occurs due to use of `{}` in closure\",\n-                        desc_place\n-                    ),\n+                    format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n                 );\n                 err.buffer(&mut self.errors_buffer);\n \n@@ -365,8 +369,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -375,10 +379,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n+                tcx.cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -387,13 +392,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                ),\n+                )\n+            }\n \n             (BorrowKind::Shallow, _, _, BorrowKind::Unique, _, _)\n             | (BorrowKind::Shallow, _, _, BorrowKind::Mut { .. }, _, _) => {\n                 // Shallow borrows are uses from the user's point of view.\n                 self.report_use_while_mutably_borrowed(context, (place, span), issued_borrow);\n-                return\n+                return;\n             }\n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _)\n             | (BorrowKind::Shared, _, _, BorrowKind::Shallow, _, _)\n@@ -447,16 +453,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n-        debug!(\"report_borrowed_value_does_not_live_long_enough(\\\n-                {:?}, {:?}, {:?}, {:?}\\\n-                )\",\n-               context, borrow, place_span, kind\n+        debug!(\n+            \"report_borrowed_value_does_not_live_long_enough(\\\n+             {:?}, {:?}, {:?}, {:?}\\\n+             )\",\n+            context, borrow, place_span, kind\n         );\n \n         let drop_span = place_span.1;\n         let scope_tree = self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-        let root_place = self\n-            .prefixes(&borrow.borrowed_place, PrefixSet::All)\n+        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();\n \n@@ -468,8 +474,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => drop_span,\n         };\n \n-        if self\n-            .access_place_error_reported\n+        if self.access_place_error_reported\n             .contains(&(root_place.clone(), borrow_span))\n         {\n             debug!(\n@@ -482,28 +487,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         self.access_place_error_reported\n             .insert((root_place.clone(), borrow_span));\n \n-        if let StorageDeadOrDrop::Destructor(dropped_ty)\n-            = self.classify_drop_access_kind(&borrow.borrowed_place)\n+        if let StorageDeadOrDrop::Destructor(dropped_ty) =\n+            self.classify_drop_access_kind(&borrow.borrowed_place)\n         {\n             // If a borrow of path `B` conflicts with drop of `D` (and\n             // we're not in the uninteresting case where `B` is a\n             // prefix of `D`), then report this as a more interesting\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n                 self.report_borrow_conflicts_with_destructor(\n-                    context,\n-                    borrow,\n-                    place_span,\n-                    kind,\n-                    dropped_ty,\n+                    context, borrow, place_span, kind, dropped_ty,\n                 );\n                 return;\n             }\n         }\n \n         let err = match &self.describe_place(&borrow.borrowed_place) {\n-            Some(_) if self.is_place_thread_local(root_place) =>\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span),\n+            Some(_) if self.is_place_thread_local(root_place) => {\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n+            }\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n                 context,\n                 name,\n@@ -556,16 +558,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             err.span_label(\n                 borrow_span,\n-                format!(\"`{}` would have to be valid for `{}`...\", name, region_name)\n+                format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n             if let Some(fn_node_id) = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id) {\n                 err.span_label(\n                     drop_span,\n                     format!(\n                         \"...but `{}` will be dropped here, when the function `{}` returns\",\n-                        name, self.infcx.tcx.hir.name(fn_node_id),\n-                    )\n+                        name,\n+                        self.infcx.tcx.hir.name(fn_node_id),\n+                    ),\n                 );\n \n                 err.note(\n@@ -579,16 +582,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             } else {\n                 err.span_label(\n                     drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name)\n+                    format!(\"...but `{}` dropped here while still borrowed\", name),\n                 );\n             }\n \n-            if let BorrowExplanation::MustBeValidFor(..) = explanation { } else {\n+            if let BorrowExplanation::MustBeValidFor(..) = explanation {\n+            } else {\n                 explanation.emit(self.infcx.tcx, &mut err);\n             }\n         } else {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-            err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n+            err.span_label(\n+                drop_span,\n+                format!(\"`{}` dropped here while still borrowed\", name),\n+            );\n \n             borrow_spans.args_span_label(&mut err, \"value captured here\");\n \n@@ -616,34 +623,40 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        let mut err = self.infcx.tcx.cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n+        let mut err = self.infcx\n+            .tcx\n+            .cannot_borrow_across_destructor(borrow_span, Origin::Mir);\n \n         let what_was_dropped = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name.as_str()),\n             None => format!(\"temporary value\"),\n         };\n \n         let label = match self.describe_place(&borrow.borrowed_place) {\n-            Some(borrowed) =>\n-                format!(\"here, drop of {D} needs exclusive access to `{B}`, \\\n-                         because the type `{T}` implements the `Drop` trait\",\n-                        D=what_was_dropped, T=dropped_ty, B=borrowed),\n-            None =>\n-                format!(\"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n-                        D=what_was_dropped, T=dropped_ty),\n+            Some(borrowed) => format!(\n+                \"here, drop of {D} needs exclusive access to `{B}`, \\\n+                 because the type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty,\n+                B = borrowed\n+            ),\n+            None => format!(\n+                \"here is drop of {D}; whose type `{T}` implements the `Drop` trait\",\n+                D = what_was_dropped,\n+                T = dropped_ty\n+            ),\n         };\n         err.span_label(drop_span, label);\n \n         // Only give this note and suggestion if they could be relevant.\n-        let explanation = self.explain_why_borrow_contains_point(\n-            context, borrow, kind.map(|k| (k, place)),\n-        );\n+        let explanation =\n+            self.explain_why_borrow_contains_point(context, borrow, kind.map(|k| (k, place)));\n         match explanation {\n-            BorrowExplanation::UsedLater {..} |\n-            BorrowExplanation::UsedLaterWhenDropped {..} => {\n+            BorrowExplanation::UsedLater { .. }\n+            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n \n         explanation.emit(self.infcx.tcx, &mut err);\n@@ -663,9 +676,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span, borrow_span\n         );\n \n-        let mut err = self.infcx.tcx.thread_local_value_does_not_live_long_enough(\n-            borrow_span, Origin::Mir\n-        );\n+        let mut err = self.infcx\n+            .tcx\n+            .thread_local_value_does_not_live_long_enough(borrow_span, Origin::Mir);\n \n         err.span_label(\n             borrow_span,\n@@ -693,20 +706,25 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let tcx = self.infcx.tcx;\n-        let mut err =\n-            tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n-        err.span_label(proper_span, \"creates a temporary which is freed while still in use\");\n-        err.span_label(drop_span, \"temporary value is freed at the end of this statement\");\n+        let mut err = tcx.temporary_value_borrowed_for_too_long(proper_span, Origin::Mir);\n+        err.span_label(\n+            proper_span,\n+            \"creates a temporary which is freed while still in use\",\n+        );\n+        err.span_label(\n+            drop_span,\n+            \"temporary value is freed at the end of this statement\",\n+        );\n \n         let explanation = self.explain_why_borrow_contains_point(context, borrow, None);\n         match explanation {\n-            BorrowExplanation::UsedLater(..) |\n-            BorrowExplanation::UsedLaterInLoop(..) |\n-            BorrowExplanation::UsedLaterWhenDropped(..) => {\n+            BorrowExplanation::UsedLater(..)\n+            | BorrowExplanation::UsedLaterInLoop(..)\n+            | BorrowExplanation::UsedLaterWhenDropped(..) => {\n                 // Only give this note and suggestion if it could be relevant.\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n         explanation.emit(self.infcx.tcx, &mut err);\n \n@@ -785,11 +803,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             // check for inits\n             let mut any_match = false;\n-            drop_flag_effects::for_location_inits(self.infcx.tcx, self.mir, self.move_data, l, |m| {\n-                if m == mpi {\n-                    any_match = true;\n-                }\n-            });\n+            drop_flag_effects::for_location_inits(\n+                self.infcx.tcx,\n+                self.mir,\n+                self.move_data,\n+                l,\n+                |m| {\n+                    if m == mpi {\n+                        any_match = true;\n+                    }\n+                },\n+            );\n             if any_match {\n                 continue 'dfs;\n             }\n@@ -829,7 +853,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         loan_spans.var_span_label(&mut err, \"borrow occurs due to use in closure\");\n \n-        self.explain_why_borrow_contains_point(context, loan, None).emit(self.infcx.tcx, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None)\n+            .emit(self.infcx.tcx, &mut err);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1151,7 +1176,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n                     let node_id = self.infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    let freevar = self.infcx.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+                    let freevar = self.infcx\n+                        .tcx\n+                        .with_freevars(node_id, |fv| fv[field.index()]);\n \n                     self.infcx.tcx.hir.name(freevar.var_id()).to_string()\n                 }\n@@ -1218,35 +1245,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n-            Place::Local(_)\n-            | Place::Static(_)\n-            | Place::Promoted(_) => StorageDeadOrDrop::LocalStorageDead,\n+            Place::Local(_) | Place::Static(_) | Place::Promoted(_) => {\n+                StorageDeadOrDrop::LocalStorageDead\n+            }\n             Place::Projection(box PlaceProjection { base, elem }) => {\n                 let base_access = self.classify_drop_access_kind(base);\n                 match elem {\n-                    ProjectionElem::Deref => {\n-                        match base_access {\n-                            StorageDeadOrDrop::LocalStorageDead\n-                            | StorageDeadOrDrop::BoxedStorageDead => {\n-                                assert!(base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n-                                        \"Drop of value behind a reference or raw pointer\");\n-                                StorageDeadOrDrop::BoxedStorageDead\n-                            }\n-                            StorageDeadOrDrop::Destructor(_) => {\n-                                base_access\n-                            }\n+                    ProjectionElem::Deref => match base_access {\n+                        StorageDeadOrDrop::LocalStorageDead\n+                        | StorageDeadOrDrop::BoxedStorageDead => {\n+                            assert!(\n+                                base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                \"Drop of value behind a reference or raw pointer\"\n+                            );\n+                            StorageDeadOrDrop::BoxedStorageDead\n                         }\n-                    }\n-                    ProjectionElem::Field(..)\n-                    | ProjectionElem::Downcast(..) => {\n+                        StorageDeadOrDrop::Destructor(_) => base_access,\n+                    },\n+                    ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n                         let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n                                 match base_access {\n-                                    StorageDeadOrDrop::Destructor(_) => {\n-                                        base_access\n-                                    }\n+                                    StorageDeadOrDrop::Destructor(_) => base_access,\n                                     StorageDeadOrDrop::LocalStorageDead\n                                     | StorageDeadOrDrop::BoxedStorageDead => {\n                                         StorageDeadOrDrop::Destructor(base_ty)\n@@ -1277,13 +1299,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if is_closure {\n                 None\n             } else {\n-                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-                 match ty.sty {\n-                     ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) =>\n-                        self.annotate_fn_sig(\n-                            self.mir_def_id,\n-                            self.infcx.tcx.fn_sig(self.mir_def_id)\n-                        ),\n+                let ty = self.infcx.tcx.type_of(self.mir_def_id);\n+                match ty.sty {\n+                    ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id,\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n                     _ => None,\n                 }\n             }\n@@ -1296,13 +1317,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // place. If it was, we can add annotations about the function's return type and arguments\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n-        debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        match &self.mir[location.block].statements.get(location.statement_index) {\n+        debug!(\n+            \"annotate_argument_and_return_for_borrow: location={:?}\",\n+            location\n+        );\n+        match &self.mir[location.block]\n+            .statements\n+            .get(location.statement_index)\n+        {\n             Some(&Statement {\n                 kind: StatementKind::Assign(ref reservation, _),\n                 ..\n             }) => {\n-                debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n+                debug!(\n+                    \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n+                    reservation\n+                );\n                 // Check that the initial assignment of the reserve location is into a temporary.\n                 let mut target = *match reservation {\n                     Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n@@ -1317,21 +1347,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                         target, stmt\n                     );\n-                    if let StatementKind::Assign(\n-                        Place::Local(assigned_to),\n-                        box rvalue,\n-                    ) = &stmt.kind {\n-                        debug!(\"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                               rvalue={:?}\", assigned_to, rvalue);\n+                    if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n+                    {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                             rvalue={:?}\",\n+                            assigned_to, rvalue\n+                        );\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n-                                box AggregateKind::Closure(def_id, substs),\n-                                operands,\n-                        ) = rvalue {\n+                            box AggregateKind::Closure(def_id, substs),\n+                            operands,\n+                        ) = rvalue\n+                        {\n                             for operand in operands {\n                                 let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) |\n-                                    Operand::Move(assigned_from) => assigned_from,\n+                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                        assigned_from\n+                                    }\n                                     _ => continue,\n                                 };\n                                 debug!(\n@@ -1354,13 +1387,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure = self.annotate_fn_sig(\n                                     *def_id,\n-                                    self.infcx.closure_sig(*def_id, *substs)\n+                                    self.infcx.closure_sig(*def_id, *substs),\n                                 );\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\\n                                      assigned_to={:?}\",\n-                                     annotated_closure, assigned_from_local, assigned_to\n+                                    annotated_closure, assigned_from_local, assigned_to\n                                 );\n \n                                 if *assigned_to == mir::RETURN_PLACE {\n@@ -1382,15 +1415,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         let assigned_from = match rvalue {\n                             Rvalue::Ref(_, _, assigned_from) => assigned_from,\n                             Rvalue::Use(operand) => match operand {\n-                                Operand::Copy(assigned_from) |\n-                                Operand::Move(assigned_from) => assigned_from,\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n                                 _ => continue,\n                             },\n                             _ => continue,\n                         };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from={:?}\", assigned_from,\n+                             assigned_from={:?}\",\n+                            assigned_from,\n                         );\n \n                         // Find the local from the rvalue.\n@@ -1400,7 +1435,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n-                             assigned_from_local={:?}\", assigned_from_local,\n+                             assigned_from_local={:?}\",\n+                            assigned_from_local,\n                         );\n \n                         // Check if our local matches the target - if so, we've assigned our\n@@ -1414,7 +1450,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n                              assigned_from_local={:?} assigned_to={:?}\",\n-                             assigned_from_local, assigned_to\n+                            assigned_from_local, assigned_to\n                         );\n                         if *assigned_to == mir::RETURN_PLACE {\n                             // If it was then return the annotated closure if there was one,\n@@ -1438,15 +1474,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     destination: Some((Place::Local(assigned_to), _)),\n                     args,\n                     ..\n-                } = &terminator.kind {\n+                } = &terminator.kind\n+                {\n                     debug!(\n                         \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n                         assigned_to, args\n                     );\n                     for operand in args {\n                         let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) |\n-                            Operand::Move(assigned_from) => assigned_from,\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n                             _ => continue,\n                         };\n                         debug!(\n@@ -1460,9 +1498,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 assigned_from_local,\n                             );\n \n-                            if *assigned_to == mir::RETURN_PLACE &&\n-                                assigned_from_local == target\n-                            {\n+                            if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n                                 return annotated_closure.or_else(fallback);\n                             }\n                         }\n@@ -1529,7 +1565,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // With access to the lifetime, we can get\n                                     // the span of it.\n                                     arguments.push((*argument, lifetime.span));\n-                                },\n+                                }\n                                 _ => bug!(\"ty type is a ref but hir type is not\"),\n                             }\n                         }\n@@ -1556,7 +1592,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     return_ty,\n                     return_span,\n                 })\n-            },\n+            }\n             ty::TyKind::Ref(_, _, _) if is_closure => {\n                 // This is case 2 from above but only for closures, return type is anonymous\n                 // reference so we select\n@@ -1577,7 +1613,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 None\n-            },\n+            }\n             ty::TyKind::Ref(_, _, _) => {\n                 // This is also case 2 from above but for functions, return type is still an\n                 // anonymous reference so we select the first argument.\n@@ -1589,7 +1625,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // We expect the first argument to be a reference.\n                 match argument_ty.sty {\n-                    ty::TyKind::Ref(_, _, _) => {},\n+                    ty::TyKind::Ref(_, _, _) => {}\n                     _ => return None,\n                 }\n \n@@ -1599,12 +1635,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     return_ty,\n                     return_span,\n                 })\n-            },\n+            }\n             _ => {\n                 // This is case 3 from above, return type is not a reference so don't highlight\n                 // anything.\n                 None\n-            },\n+            }\n         }\n     }\n }\n@@ -1625,36 +1661,33 @@ enum AnnotatedBorrowFnSignature<'tcx> {\n     Closure {\n         argument_ty: ty::Ty<'tcx>,\n         argument_span: Span,\n-    }\n+    },\n }\n \n impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     /// Annotate the provided diagnostic with information about borrow from the fn signature that\n     /// helps explain.\n-    fn emit(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>\n-    ) -> String {\n+    fn emit(&self, diag: &mut DiagnosticBuilder<'_>) -> String {\n         match self {\n-            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+            AnnotatedBorrowFnSignature::Closure {\n+                argument_ty,\n+                argument_span,\n+            } => {\n                 diag.span_label(\n                     *argument_span,\n                     format!(\"has type `{}`\", self.get_name_for_ty(argument_ty, 0)),\n                 );\n \n                 self.get_region_name_for_ty(argument_ty, 0)\n-            },\n+            }\n             AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n                 let argument_ty_name = self.get_name_for_ty(argument_ty, 0);\n-                diag.span_label(\n-                    *argument_span,\n-                    format!(\"has type `{}`\", argument_ty_name)\n-                );\n+                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n                 let return_ty_name = self.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n@@ -1664,7 +1697,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                         \"{}has type `{}`\",\n                         if types_equal { \"also \" } else { \"\" },\n                         return_ty_name,\n-                    )\n+                    ),\n                 );\n \n                 diag.note(\n@@ -1676,7 +1709,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 );\n \n                 self.get_region_name_for_ty(return_ty, 0)\n-            },\n+            }\n             AnnotatedBorrowFnSignature::NamedFunction {\n                 arguments,\n                 return_ty,\n@@ -1685,30 +1718,22 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n                 // Region of return type and arguments checked to be the same earlier.\n                 let region_name = self.get_region_name_for_ty(return_ty, 0);\n                 for (_, argument_span) in arguments {\n-                    diag.span_label(\n-                        *argument_span,\n-                        format!(\"has lifetime `{}`\", region_name)\n-                    );\n+                    diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }\n \n                 diag.span_label(\n                     *return_span,\n-                    format!(\n-                        \"also has lifetime `{}`\",\n-                        region_name,\n-                    )\n+                    format!(\"also has lifetime `{}`\", region_name,),\n                 );\n \n-                diag.help(\n-                    &format!(\n-                        \"use data from the highlighted arguments which match the `{}` lifetime of \\\n-                         the return type\",\n-                         region_name,\n-                    ),\n-                );\n+                diag.help(&format!(\n+                    \"use data from the highlighted arguments which match the `{}` lifetime of \\\n+                     the return type\",\n+                    region_name,\n+                ));\n \n                 region_name\n-            },\n+            }\n         }\n     }\n \n@@ -1719,9 +1744,10 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n-            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _) |\n-            ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) =>\n-                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty)),\n+            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n+            | ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) => {\n+                with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty))\n+            }\n             _ => format!(\"{}\", ty),\n         }\n     }\n@@ -1731,11 +1757,11 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n             ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br) |\n-                ty::RegionKind::ReSkolemized(_, br) =>\n-                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region)),\n+                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::ReSkolemized(_, br) => {\n+                    with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n+                }\n                 _ => format!(\"{}\", region),\n-            }\n+            },\n             _ => bug!(\"ty for annotation of borrow region is not a reference\"),\n         }\n     }\n@@ -1828,9 +1854,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 debug!(\"find_closure_move_span: found closure {:?}\", places);\n \n                 if let Some(node_id) = self.infcx.tcx.hir.as_local_node_id(def_id) {\n-                    if let Closure(\n-                        _, _, _, args_span, _\n-                    ) = self.infcx.tcx.hir.expect_expr(node_id).node {\n+                    if let Closure(_, _, _, args_span, _) =\n+                        self.infcx.tcx.hir.expect_expr(node_id).node\n+                    {\n                         if let Some(var_span) = self.infcx.tcx.with_freevars(node_id, |freevars| {\n                             for (v, place) in freevars.iter().zip(places) {\n                                 match place {\n@@ -1886,8 +1912,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places))\n-                = stmt.kind {\n+            if let StatementKind::Assign(_, box Rvalue::Aggregate(ref kind, ref places)) = stmt.kind\n+            {\n                 if let AggregateKind::Closure(def_id, _) = **kind {\n                     debug!(\"find_closure_borrow_span: found closure {:?}\", places);\n \n@@ -1900,13 +1926,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             return OtherUse(use_span);\n                         };\n \n-                        self.infcx.tcx\n+                        self.infcx\n+                            .tcx\n                             .with_freevars(node_id, |freevars| {\n                                 for (v, place) in freevars.iter().zip(places) {\n                                     match *place {\n                                         Operand::Copy(Place::Local(l))\n-                                        | Operand::Move(Place::Local(l))\n-                                            if local == l =>\n+                                        | Operand::Move(Place::Local(l)) if local == l =>\n                                         {\n                                             debug!(\n                                                 \"find_closure_borrow_span: found captured local \\\n@@ -1919,10 +1945,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     }\n                                 }\n                                 None\n-                            }).map(|var_span| ClosureUse {\n+                            })\n+                            .map(|var_span| ClosureUse {\n                                 args_span,\n                                 var_span,\n-                            }).unwrap_or(OtherUse(use_span))\n+                            })\n+                            .unwrap_or(OtherUse(use_span))\n                     } else {\n                         OtherUse(use_span)\n                     };"}]}