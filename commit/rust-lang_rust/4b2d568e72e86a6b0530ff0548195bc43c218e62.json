{"sha": "4b2d568e72e86a6b0530ff0548195bc43c218e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMmQ1NjhlNzJlODZhNmIwNTMwZmYwNTQ4MTk1YmM0M2MyMThlNjI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-09-01T00:07:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-01T00:07:45Z"}, "message": "Rollup merge of #44207 - durka:define-maps-fn, r=eddyb\n\nadd `fn` to syntax of rustc::ty::maps::define_maps\n\nThis is not a functional change, it just makes it possible to find a query by grepping without knowing that it's a query rather than a function.\n\nI didn't pursue renaming everything from \"map\" to \"query\" because it seems to be a very invasive change. It would be a good test to exercise an IDE's renaming features.\n\nCloses #44161\n\nr? @eddyb", "tree": {"sha": "763257cf7ebcceb357eb6e4f698e6250be71b782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/763257cf7ebcceb357eb6e4f698e6250be71b782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b2d568e72e86a6b0530ff0548195bc43c218e62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b2d568e72e86a6b0530ff0548195bc43c218e62", "html_url": "https://github.com/rust-lang/rust/commit/4b2d568e72e86a6b0530ff0548195bc43c218e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b2d568e72e86a6b0530ff0548195bc43c218e62/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "471f9894c95cd1f65b3f3adbb965016112ba8029", "url": "https://api.github.com/repos/rust-lang/rust/commits/471f9894c95cd1f65b3f3adbb965016112ba8029", "html_url": "https://github.com/rust-lang/rust/commit/471f9894c95cd1f65b3f3adbb965016112ba8029"}, {"sha": "da302846ac56f784fe81deb4ad3d8026bdc3aa3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/da302846ac56f784fe81deb4ad3d8026bdc3aa3f", "html_url": "https://github.com/rust-lang/rust/commit/da302846ac56f784fe81deb4ad3d8026bdc3aa3f"}], "stats": {"total": 161, "additions": 81, "deletions": 80}, "files": [{"sha": "2eb77ef3ffc1849e8fd58cfeab9cc9b5f6bec4a6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4b2d568e72e86a6b0530ff0548195bc43c218e62/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b2d568e72e86a6b0530ff0548195bc43c218e62/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4b2d568e72e86a6b0530ff0548195bc43c218e62", "patch": "@@ -593,7 +593,7 @@ macro_rules! profq_key {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n         define_map_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n@@ -954,191 +954,192 @@ macro_rules! define_provider_struct {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    [] type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    [] generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n-    [] predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    [] super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] type_param_predicates: type_param_predicates((DefId, DefId))\n+    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    [] trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-    [] adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-    [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n+    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a const fn\n-    [] is_const_fn: IsConstFn(DefId) -> bool,\n+    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    [] is_foreign_item: IsForeignItem(DefId) -> bool,\n+    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// True if this is a default impl (aka impl Foo for ..)\n-    [] is_default_impl: IsDefaultImpl(DefId) -> bool,\n+    [] fn is_default_impl: IsDefaultImpl(DefId) -> bool,\n \n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n-    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    [] impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Set of all the def-ids in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    [] mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n+    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] mir_const_qualif: MirConstQualif(DefId) -> u8,\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> u8,\n \n     /// Fetch the MIR for a given def-id up till the point where it is\n     /// ready for const evaluation.\n     ///\n     /// See the README for the `mir` module for details.\n-    [] mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-    [] mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n-    [] optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n     /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n+    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n     /// The signature of functions and closures.\n-    [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Records the signature of each generator. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n+    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n-    [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-    [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    [] has_typeck_tables: HasTypeckTables(DefId) -> bool,\n+    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n-    [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+    [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    [] borrowck: BorrowCheck(DefId) -> (),\n+    [] fn borrowck: BorrowCheck(DefId) -> (),\n     // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] mir_borrowck: MirBorrowCheck(DefId) -> (),\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n \n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n+    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    [] const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n         -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    [] privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n     /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n     /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n     /// fn item.\n-    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n-\n-    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-    [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-    [] describe_def: DescribeDef(DefId) -> Option<Def>,\n-    [] def_span: DefSpan(DefId) -> Span,\n-    [] stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n-    [] item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n-    [] fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-    [] impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    [] trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n-    [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n-    [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] is_mir_available: IsMirAvailable(DefId) -> bool,\n-\n-    [] trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n-    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n-    [] is_object_safe: ObjectSafety(DefId) -> bool,\n+    [] fn region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n+\n+    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n+\n+    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+\n+    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n+    [] fn def_span: DefSpan(DefId) -> Span,\n+    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n+    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n+    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n+    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n+    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n+    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId)\n+        -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n+    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n     // Get the ParameterEnvironment for a given item; this environment\n     // will be in \"user-facing\" mode, meaning that it is suitabe for\n     // type-checking etc, and it does not normalize specializable\n     // associated types. This is almost always what you want,\n     // unless you are doing MIR optimizations, in which case you\n     // might want to use `reveal_all()` method to change modes.\n-    [] param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n     // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n     // `ty.is_copy()`, etc, since that will prune the environment where possible.\n-    [] is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] dylib_dependency_formats: DylibDepFormats(DefId)\n+    [] fn dylib_dependency_formats: DylibDepFormats(DefId)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] is_allocator: IsAllocator(DefId) -> bool,\n-    [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n-    [] is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n-    [] has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n+    [] fn is_allocator: IsAllocator(DefId) -> bool,\n+    [] fn is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n \n-    [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n-    [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n+    [] fn lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n \n-    [] specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n-    [] module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n+    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n+    [] fn in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n+    [] fn module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}]}