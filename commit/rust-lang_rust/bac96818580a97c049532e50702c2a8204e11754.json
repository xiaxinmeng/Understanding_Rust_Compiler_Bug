{"sha": "bac96818580a97c049532e50702c2a8204e11754", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzk2ODE4NTgwYTk3YzA0OTUzMmU1MDcwMmMyYTgyMDRlMTE3NTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T02:44:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:56Z"}, "message": "Implement io::net::unix", "tree": {"sha": "cb8fc611cf345d6f6c539bd62fd778b7b214d1a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb8fc611cf345d6f6c539bd62fd778b7b214d1a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac96818580a97c049532e50702c2a8204e11754", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac96818580a97c049532e50702c2a8204e11754", "html_url": "https://github.com/rust-lang/rust/commit/bac96818580a97c049532e50702c2a8204e11754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac96818580a97c049532e50702c2a8204e11754/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "url": "https://api.github.com/repos/rust-lang/rust/commits/61f8c059c4c6082683d78b2ee3d963f65fa1eb98", "html_url": "https://github.com/rust-lang/rust/commit/61f8c059c4c6082683d78b2ee3d963f65fa1eb98"}], "stats": {"total": 688, "additions": 602, "deletions": 86}, "files": [{"sha": "9428c1f800d158976ac75996d444ec63e9528bc6", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 268, "deletions": 16, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -8,44 +8,296 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+Named pipes\n+\n+This module contains the ability to communicate over named pipes with\n+synchronous I/O. On windows, this corresponds to talking over a Named Pipe,\n+while on Unix it corresponds to UNIX domain sockets.\n+\n+These pipes are similar to TCP in the sense that you can have both a stream to a\n+server and a server itself. The server provided accepts other `UnixStream`\n+instances as clients.\n+\n+*/\n+\n use prelude::*;\n-use super::super::*;\n+\n use super::super::support::PathLike;\n+use rt::rtio::{IoFactory, IoFactoryObject, RtioUnixListenerObject};\n+use rt::rtio::{RtioUnixAcceptorObject, RtioPipeObject, RtioUnixListener};\n+use rt::rtio::RtioUnixAcceptor;\n+use rt::io::pipe::PipeStream;\n+use rt::io::{io_error, Listener, Acceptor, Reader, Writer};\n+use rt::local::Local;\n \n-pub struct UnixStream;\n+/// A stream which communicates over a named pipe.\n+pub struct UnixStream {\n+    priv obj: PipeStream,\n+}\n \n impl UnixStream {\n-    pub fn connect<P: PathLike>(_path: &P) -> Option<UnixStream> {\n-        fail!()\n+    fn new(obj: ~RtioPipeObject) -> UnixStream {\n+        UnixStream { obj: PipeStream::new_bound(obj) }\n+    }\n+\n+    /// Connect to a pipe named by `path`. This will attempt to open a\n+    /// connection to the underlying socket.\n+    ///\n+    /// The returned stream will be closed when the object falls out of scope.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if the connection\n+    /// could not be made.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::net::unix::UnixStream;\n+    ///\n+    ///     let server = Path(\"path/to/my/socket\");\n+    ///     let mut stream = UnixStream::connect(&server);\n+    ///     stream.write([1, 2, 3]);\n+    ///\n+    pub fn connect<P: PathLike>(path: &P) -> Option<UnixStream> {\n+        let pipe = unsafe {\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*io).unix_connect(path)\n+        };\n+\n+        match pipe {\n+            Ok(s) => Some(UnixStream::new(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n-\n-    fn eof(&mut self) -> bool { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.obj.read(buf) }\n+    fn eof(&mut self) -> bool { self.obj.eof() }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, _v: &[u8]) { fail!() }\n-\n-    fn flush(&mut self) { fail!() }\n+    fn write(&mut self, buf: &[u8]) { self.obj.write(buf) }\n+    fn flush(&mut self) { self.obj.flush() }\n }\n \n-pub struct UnixListener;\n+pub struct UnixListener {\n+    priv obj: ~RtioUnixListenerObject,\n+}\n \n impl UnixListener {\n-    pub fn bind<P: PathLike>(_path: &P) -> Option<UnixListener> {\n-        fail!()\n+\n+    /// Creates a new listener, ready to receive incoming connections on the\n+    /// specified socket. The server will be named by `path`.\n+    ///\n+    /// This listener will be closed when it falls out of scope.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if the specified\n+    /// path could not be bound.\n+    ///\n+    /// # Example\n+    ///\n+    ///     use std::rt::io::net::unix::UnixListener;\n+    ///\n+    ///     let server = Path(\"path/to/my/socket\");\n+    ///     let mut stream = UnixListener::bind(&server);\n+    ///     for client in stream.incoming() {\n+    ///         let mut client = client;\n+    ///         client.write([1, 2, 3, 4]);\n+    ///     }\n+    ///\n+    pub fn bind<P: PathLike>(path: &P) -> Option<UnixListener> {\n+        let listener = unsafe {\n+            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            (*io).unix_bind(path)\n+        };\n+        match listener {\n+            Ok(s) => Some(UnixListener{ obj: s }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> { fail!() }\n+    fn listen(self) -> Option<UnixAcceptor> {\n+        match self.obj.listen() {\n+            Ok(acceptor) => Some(UnixAcceptor { obj: acceptor }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n }\n \n-pub struct UnixAcceptor;\n+pub struct UnixAcceptor {\n+    priv obj: ~RtioUnixAcceptorObject,\n+}\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n+    fn accept(&mut self) -> Option<UnixStream> {\n+        match self.obj.accept() {\n+            Ok(s) => Some(UnixStream::new(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+    use cell::Cell;\n+    use rt::test::*;\n+    use rt::io::*;\n+    use rt::comm::oneshot;\n+    use os;\n+\n+    fn smalltest(server: ~fn(UnixStream), client: ~fn(UnixStream)) {\n+        let server = Cell::new(server);\n+        let client = Cell::new(client);\n+        do run_in_mt_newsched_task {\n+            let server = Cell::new(server.take());\n+            let client = Cell::new(client.take());\n+            let path1 = next_test_unix();\n+            let path2 = path1.clone();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            do spawntask {\n+                let mut acceptor = UnixListener::bind(&path1).listen();\n+                chan.take().send(());\n+                server.take()(acceptor.accept().unwrap());\n+            }\n+\n+            do spawntask {\n+                port.take().recv();\n+                client.take()(UnixStream::connect(&path2).unwrap());\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn bind_error() {\n+        do run_in_mt_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert!(e.kind == PermissionDenied);\n+                called = true;\n+            }).inside {\n+                let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n+                assert!(listener.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn connect_error() {\n+        do run_in_mt_newsched_task {\n+            let mut called = false;\n+            do io_error::cond.trap(|e| {\n+                assert_eq!(e.kind, OtherIoError);\n+                called = true;\n+            }).inside {\n+                let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n+                assert!(stream.is_none());\n+            }\n+            assert!(called);\n+        }\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        smalltest(|mut server| {\n+            let mut buf = [0];\n+            server.read(buf);\n+            assert!(buf[0] == 99);\n+        }, |mut client| {\n+            client.write([99]);\n+        })\n+    }\n+\n+    #[test]\n+    fn read_eof() {\n+        smalltest(|mut server| {\n+            let mut buf = [0];\n+            assert!(server.read(buf).is_none());\n+            assert!(server.read(buf).is_none());\n+        }, |_client| {\n+            // drop the client\n+        })\n+    }\n+\n+    #[test]\n+    fn write_begone() {\n+        smalltest(|mut server| {\n+            let buf = [0];\n+            let mut stop = false;\n+            while !stop{\n+                do io_error::cond.trap(|e| {\n+                    assert_eq!(e.kind, BrokenPipe);\n+                    stop = true;\n+                }).inside {\n+                    server.write(buf);\n+                }\n+            }\n+        }, |_client| {\n+            // drop the client\n+        })\n+    }\n+\n+    #[test]\n+    fn accept_lots() {\n+        do run_in_mt_newsched_task {\n+            let times = 10;\n+            let path1 = next_test_unix();\n+            let path2 = path1.clone();\n+            let (port, chan) = oneshot();\n+            let port = Cell::new(port);\n+            let chan = Cell::new(chan);\n+\n+            do spawntask {\n+                let mut acceptor = UnixListener::bind(&path1).listen();\n+                chan.take().send(());\n+                do times.times {\n+                    let mut client = acceptor.accept();\n+                    let mut buf = [0];\n+                    client.read(buf);\n+                    assert_eq!(buf[0], 100);\n+                }\n+            }\n+\n+            do spawntask {\n+                port.take().recv();\n+                do times.times {\n+                    let mut stream = UnixStream::connect(&path2);\n+                    stream.write([100]);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn path_exists() {\n+        do run_in_mt_newsched_task {\n+            let path = next_test_unix();\n+            let _acceptor = UnixListener::bind(&path).listen();\n+            assert!(os::path_exists(&path));\n+        }\n+    }\n }"}, {"sha": "ff1bd55d594b71d3af353974fca134205a48c5d1", "filename": "src/libstd/rt/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fpipe.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -21,7 +21,7 @@ use rt::rtio::{RtioPipe, RtioPipeObject, IoFactoryObject, IoFactory};\n use rt::rtio::RtioUnboundPipeObject;\n \n pub struct PipeStream {\n-    priv obj: RtioPipeObject\n+    priv obj: ~RtioPipeObject\n }\n \n // This should not be a newtype, but rt::uv::process::set_stdio needs to reach\n@@ -45,7 +45,7 @@ impl PipeStream {\n         }\n     }\n \n-    pub fn bind(inner: RtioPipeObject) -> PipeStream {\n+    pub fn new_bound(inner: ~RtioPipeObject) -> PipeStream {\n         PipeStream { obj: inner }\n     }\n }"}, {"sha": "e0ffa82b59fe317f9ccaf9bf2ba69e0171cf8d26", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -100,7 +100,7 @@ impl Process {\n             Ok((p, io)) => Some(Process{\n                 handle: p,\n                 io: io.move_iter().map(|p|\n-                    p.map(|p| io::PipeStream::bind(p))\n+                    p.map(|p| io::PipeStream::new_bound(p))\n                 ).collect()\n             }),\n             Err(ioerr) => {"}, {"sha": "0964f94d6d5281026804edca282af882356e064d", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -36,6 +36,8 @@ pub type PausibleIdleCallback = uvio::UvPausibleIdleCallback;\n pub type RtioPipeObject = uvio::UvPipeStream;\n pub type RtioUnboundPipeObject = uvio::UvUnboundPipe;\n pub type RtioProcessObject = uvio::UvProcess;\n+pub type RtioUnixListenerObject = uvio::UvUnixListener;\n+pub type RtioUnixAcceptorObject = uvio::UvUnixAcceptor;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -86,7 +88,12 @@ pub trait IoFactory {\n         Result<~[Path], IoError>;\n     fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>;\n+            -> Result<(~RtioProcessObject, ~[Option<~RtioPipeObject>]), IoError>;\n+\n+    fn unix_bind<P: PathLike>(&mut self, path: &P) ->\n+        Result<~RtioUnixListenerObject, IoError>;\n+    fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n+        Result<~RtioPipeObject, IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {\n@@ -154,3 +161,13 @@ pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n }\n+\n+pub trait RtioUnixListener {\n+    fn listen(self) -> Result<~RtioUnixAcceptorObject, IoError>;\n+}\n+\n+pub trait RtioUnixAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipeObject, IoError>;\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n+}"}, {"sha": "759550e5cbd039cdef69ccf52810acd22ded529f", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rand;\n+use rand::Rng;\n+use os;\n use libc;\n use option::{Some, None};\n+use path::{Path, GenericPath};\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n@@ -327,6 +331,12 @@ pub fn next_test_port() -> u16 {\n     }\n }\n \n+/// Get a temporary path which could be the location of a unix socket\n+#[fixed_stack_segment] #[inline(never)]\n+pub fn next_test_unix() -> Path {\n+    os::tmpdir().push(rand::task_rng().gen_ascii_str(20))\n+}\n+\n /// Get a unique IPv4 localhost:port pair starting at 9600\n pub fn next_test_ip4() -> SocketAddr {\n     SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }"}, {"sha": "2e85900a3f23ca1d1b2ebe106146be9311b80bee", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -206,12 +206,6 @@ impl StreamWatcher {\n         }\n     }\n \n-    pub fn accept(&mut self, stream: StreamWatcher) {\n-        let self_handle = self.native_handle() as *c_void;\n-        let stream_handle = stream.native_handle() as *c_void;\n-        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n-    }\n-\n     pub fn close(self, cb: NullCallback) {\n         {\n             let mut this = self;\n@@ -230,6 +224,36 @@ impl StreamWatcher {\n             cb();\n         }\n     }\n+\n+    pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n+\n+        unsafe {\n+            static BACKLOG: c_int = 128; // XXX should be configurable\n+            match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n+                0 => Ok(()),\n+                n => Err(UvError(n))\n+            }\n+        }\n+\n+        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n+            rtdebug!(\"connection_cb\");\n+            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n+            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n+            let status = status_to_maybe_uv_error(status);\n+            (*cb)(stream_watcher, status);\n+        }\n+    }\n+\n+    pub fn accept(&mut self, stream: StreamWatcher) {\n+        let self_handle = self.native_handle() as *c_void;\n+        let stream_handle = stream.native_handle() as *c_void;\n+        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n+    }\n }\n \n impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n@@ -300,28 +324,6 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn listen(&mut self, cb: ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            static BACKLOG: c_int = 128; // XXX should be configurable\n-            // XXX: This can probably fail\n-            assert_eq!(0, uvll::listen(self.native_handle(), BACKLOG, connection_cb));\n-        }\n-\n-        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n-            rtdebug!(\"connection_cb\");\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(stream_watcher, status);\n-        }\n-    }\n-\n     pub fn as_stream(&self) -> StreamWatcher {\n         NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n     }\n@@ -644,7 +646,8 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n                 let mut loop_ = loop_;\n@@ -678,7 +681,9 @@ mod test {\n                     }\n                     count_cell.put_back(count);\n                 }\n-            }\n+            };\n+\n+            assert!(res.is_ok());\n \n             let client_thread = do Thread::start {\n                 rtdebug!(\"starting client thread\");\n@@ -705,7 +710,7 @@ mod test {\n             loop_.run();\n             loop_.close();\n             client_thread.join();\n-        }\n+        };\n     }\n \n     #[test]\n@@ -718,7 +723,8 @@ mod test {\n             server_tcp_watcher.bind(addr);\n             let loop_ = loop_;\n             rtdebug!(\"listening\");\n-            do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n+            let mut stream = server_tcp_watcher.as_stream();\n+            let res = do stream.listen |mut server_stream_watcher, status| {\n                 rtdebug!(\"listened!\");\n                 assert!(status.is_none());\n                 let mut loop_ = loop_;\n@@ -754,7 +760,8 @@ mod test {\n                     }\n                     count_cell.put_back(count);\n                 }\n-            }\n+            };\n+            assert!(res.is_ok());\n \n             let client_thread = do Thread::start {\n                 rtdebug!(\"starting client thread\");"}, {"sha": "1cb86d4df2ca28f0abefb6ae7eeda0d3e988016e", "filename": "src/libstd/rt/uv/pipe.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fpipe.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -10,6 +10,7 @@\n \n use prelude::*;\n use libc;\n+use c_str::CString;\n \n use rt::uv;\n use rt::uv::net;\n@@ -37,6 +38,54 @@ impl Pipe {\n         net::StreamWatcher(**self as *uvll::uv_stream_t)\n     }\n \n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn open(&mut self, file: libc::c_int) -> Result<(), uv::UvError> {\n+        match unsafe { uvll::uv_pipe_open(self.native_handle(), file) } {\n+            0 => Ok(()),\n+            n => Err(uv::UvError(n))\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn bind(&mut self, name: &CString) -> Result<(), uv::UvError> {\n+        do name.with_ref |name| {\n+            match unsafe { uvll::uv_pipe_bind(self.native_handle(), name) } {\n+                0 => Ok(()),\n+                n => Err(uv::UvError(n))\n+            }\n+        }\n+    }\n+\n+    #[fixed_stack_segment] #[inline(never)]\n+    pub fn connect(&mut self, name: &CString, cb: uv::ConnectionCallback) {\n+        {\n+            let data = self.get_watcher_data();\n+            assert!(data.connect_cb.is_none());\n+            data.connect_cb = Some(cb);\n+        }\n+\n+        let connect = net::ConnectRequest::new();\n+        let name = do name.with_ref |p| { p };\n+\n+        unsafe {\n+            uvll::uv_pipe_connect(connect.native_handle(),\n+                                  self.native_handle(),\n+                                  name,\n+                                  connect_cb)\n+        }\n+\n+        extern \"C\" fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n+            let connect_request: net::ConnectRequest =\n+                    uv::NativeHandle::from_native_handle(req);\n+            let mut stream_watcher = connect_request.stream();\n+            connect_request.delete();\n+\n+            let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n+            let status = uv::status_to_maybe_uv_error(status);\n+            cb(stream_watcher, status);\n+        }\n+    }\n+\n     pub fn close(self, cb: uv::NullCallback) {\n         {\n             let mut this = self;\n@@ -47,7 +96,7 @@ impl Pipe {\n \n         unsafe { uvll::close(self.native_handle(), close_cb); }\n \n-        extern fn close_cb(handle: *uvll::uv_pipe_t) {\n+        extern \"C\" fn close_cb(handle: *uvll::uv_pipe_t) {\n             let mut process: Pipe = uv::NativeHandle::from_native_handle(handle);\n             process.get_watcher_data().close_cb.take_unwrap()();\n             process.drop_watcher_data();"}, {"sha": "3c629a783cf7a1ae4cfdc67d1c0ccfc4c73c4686", "filename": "src/libstd/rt/uv/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fprocess.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -44,7 +44,7 @@ impl Process {\n     /// occurred.\n     pub fn spawn(&mut self, loop_: &uv::Loop, mut config: ProcessConfig,\n                  exit_cb: uv::ExitCallback)\n-                    -> Result<~[Option<UvPipeStream>], uv::UvError>\n+                    -> Result<~[Option<~UvPipeStream>], uv::UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n \n@@ -144,7 +144,7 @@ impl Process {\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: StdioContainer) -> Option<UvPipeStream> {\n+                    io: StdioContainer) -> Option<~UvPipeStream> {\n     match io {\n         Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n@@ -166,7 +166,7 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n             let handle = pipe.pipe.as_stream().native_handle();\n             uvll::set_stdio_container_flags(dst, flags);\n             uvll::set_stdio_container_stream(dst, handle);\n-            Some(pipe.bind())\n+            Some(~UvPipeStream::new(**pipe))\n         }\n     }\n }"}, {"sha": "6888aa23e99e7d2980be47794533e96f429b5860", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 176, "deletions": 29, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -746,11 +746,11 @@ impl IoFactory for UvIoFactory {\n \n     fn pipe_init(&mut self, ipc: bool) -> Result<~RtioUnboundPipeObject, IoError> {\n         let home = get_handle_to_current_scheduler!();\n-        Ok(~UvUnboundPipe { pipe: Pipe::new(self.uv_loop(), ipc), home: home })\n+        Ok(~UvUnboundPipe::new(Pipe::new(self.uv_loop(), ipc), home))\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcessObject, ~[Option<RtioPipeObject>]), IoError>\n+            -> Result<(~RtioProcessObject, ~[Option<~RtioPipeObject>]), IoError>\n     {\n         // Sadly, we must create the UvProcess before we actually call uv_spawn\n         // so that the exit_cb can close over it and notify it when the process\n@@ -801,6 +801,74 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n     }\n+\n+    fn unix_bind<P: PathLike>(&mut self, path: &P) ->\n+        Result<~RtioUnixListenerObject, IoError> {\n+        let mut pipe = Pipe::new(self.uv_loop(), false);\n+        match pipe.bind(&path.path_as_str(|s| s.to_c_str())) {\n+            Ok(()) => {\n+                let handle = get_handle_to_current_scheduler!();\n+                let pipe = UvUnboundPipe::new(pipe, handle);\n+                Ok(~UvUnixListener::new(pipe))\n+            }\n+            Err(e) => {\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do pipe.close {\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(\n+                            task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(e))\n+            }\n+        }\n+    }\n+\n+    fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n+        Result<~RtioPipeObject, IoError>\n+    {\n+        let scheduler: ~Scheduler = Local::take();\n+        let mut pipe = Pipe::new(self.uv_loop(), false);\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<~RtioPipeObject, IoError>> = &result_cell;\n+\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let cstr = do path.path_as_str |s| { s.to_c_str() };\n+            do pipe.connect(&cstr) |stream, err| {\n+                let res = match err {\n+                    None => {\n+                        let handle = stream.native_handle();\n+                        let pipe = NativeHandle::from_native_handle(\n+                                        handle as *uvll::uv_pipe_t);\n+                        let home = get_handle_to_current_scheduler!();\n+                        let pipe = UvUnboundPipe::new(pipe, home);\n+                        Ok(~UvPipeStream::new(pipe))\n+                    }\n+                    Some(e) => { Err(uv_error_to_io_error(e)) }\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        let ret = result_cell.take();\n+        if ret.is_err() {\n+            let scheduler: ~Scheduler = Local::take();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do pipe.close {\n+                    let scheduler: ~Scheduler = Local::take();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n }\n \n pub struct UvTcpListener {\n@@ -843,9 +911,10 @@ impl RtioSocket for UvTcpListener {\n impl RtioTcpListener for UvTcpListener {\n     fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError> {\n         do self.home_for_io_consume |self_| {\n-            let mut acceptor = ~UvTcpAcceptor::new(self_);\n+            let acceptor = ~UvTcpAcceptor::new(self_);\n             let incoming = Cell::new(acceptor.incoming.clone());\n-            do acceptor.listener.watcher.listen |mut server, status| {\n+            let mut stream = acceptor.listener.watcher.as_stream();\n+            let res = do stream.listen |mut server, status| {\n                 do incoming.with_mut_ref |incoming| {\n                     let inc = match status {\n                         Some(_) => Err(standard_error(OtherIoError)),\n@@ -860,7 +929,10 @@ impl RtioTcpListener for UvTcpListener {\n                     incoming.send(inc);\n                 }\n             };\n-            Ok(acceptor)\n+            match res {\n+                Ok(()) => Ok(acceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n         }\n     }\n }\n@@ -888,6 +960,17 @@ impl RtioSocket for UvTcpAcceptor {\n     }\n }\n \n+fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n+    let r = unsafe {\n+        uvll::tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n+    };\n+\n+    match status_to_maybe_uv_error(r) {\n+        Some(err) => Err(uv_error_to_io_error(err)),\n+        None => Ok(())\n+    }\n+}\n+\n impl RtioTcpAcceptor for UvTcpAcceptor {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n         do self.home_for_io |self_| {\n@@ -897,27 +980,13 @@ impl RtioTcpAcceptor for UvTcpAcceptor {\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 1 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 1)\n         }\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 0 as c_int)\n-            };\n-\n-            match status_to_maybe_uv_error(r) {\n-                Some(err) => Err(uv_error_to_io_error(err)),\n-                None => Ok(())\n-            }\n+            accept_simultaneously(self_.listener.watcher.as_stream(), 0)\n         }\n     }\n }\n@@ -994,6 +1063,12 @@ pub struct UvUnboundPipe {\n     priv home: SchedHandle,\n }\n \n+impl UvUnboundPipe {\n+    fn new(pipe: Pipe, home: SchedHandle) -> UvUnboundPipe {\n+        UvUnboundPipe { pipe: pipe, home: home }\n+    }\n+}\n+\n impl HomingIO for UvUnboundPipe {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n@@ -1013,18 +1088,12 @@ impl Drop for UvUnboundPipe {\n     }\n }\n \n-impl UvUnboundPipe {\n-    pub unsafe fn bind(~self) -> UvPipeStream {\n-        UvPipeStream { inner: self }\n-    }\n-}\n-\n pub struct UvPipeStream {\n-    priv inner: ~UvUnboundPipe,\n+    priv inner: UvUnboundPipe,\n }\n \n impl UvPipeStream {\n-    pub fn new(inner: ~UvUnboundPipe) -> UvPipeStream {\n+    pub fn new(inner: UvUnboundPipe) -> UvPipeStream {\n         UvPipeStream { inner: inner }\n     }\n }\n@@ -1612,6 +1681,84 @@ impl RtioProcess for UvProcess {\n     }\n }\n \n+pub struct UvUnixListener {\n+    priv inner: UvUnboundPipe\n+}\n+\n+impl HomingIO for UvUnixListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.inner.home() }\n+}\n+\n+impl UvUnixListener {\n+    fn new(pipe: UvUnboundPipe) -> UvUnixListener {\n+        UvUnixListener { inner: pipe }\n+    }\n+}\n+\n+impl RtioUnixListener for UvUnixListener {\n+    fn listen(self) -> Result<~RtioUnixAcceptorObject, IoError> {\n+        do self.home_for_io_consume |self_| {\n+            let acceptor = ~UvUnixAcceptor::new(self_);\n+            let incoming = Cell::new(acceptor.incoming.clone());\n+            let mut stream = acceptor.listener.inner.pipe.as_stream();\n+            let res = do stream.listen |mut server, status| {\n+                do incoming.with_mut_ref |incoming| {\n+                    let inc = match status {\n+                        Some(e) => Err(uv_error_to_io_error(e)),\n+                        None => {\n+                            let inc = Pipe::new(&server.event_loop(), false);\n+                            server.accept(inc.as_stream());\n+                            let home = get_handle_to_current_scheduler!();\n+                            let pipe = UvUnboundPipe::new(inc, home);\n+                            Ok(~UvPipeStream::new(pipe))\n+                        }\n+                    };\n+                    incoming.send(inc);\n+                }\n+            };\n+            match res {\n+                Ok(()) => Ok(acceptor),\n+                Err(e) => Err(uv_error_to_io_error(e)),\n+            }\n+        }\n+    }\n+}\n+\n+pub struct UvUnixAcceptor {\n+    listener: UvUnixListener,\n+    incoming: Tube<Result<~RtioPipeObject, IoError>>,\n+}\n+\n+impl HomingIO for UvUnixAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n+\n+impl UvUnixAcceptor {\n+    fn new(listener: UvUnixListener) -> UvUnixAcceptor {\n+        UvUnixAcceptor { listener: listener, incoming: Tube::new() }\n+    }\n+}\n+\n+impl RtioUnixAcceptor for UvUnixAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipeObject, IoError> {\n+        do self.home_for_io |self_| {\n+            self_.incoming.recv()\n+        }\n+    }\n+\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 1)\n+        }\n+    }\n+\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 0)\n+        }\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_mt_newsched_task {"}, {"sha": "eb770d0807074ba23eb4d54204643470d815c137", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -1102,4 +1102,23 @@ extern {\n     fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n                                        stream: *uv_stream_t);\n     fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n+\n+    pub fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n+    pub fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n+    pub fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                           name: *c_char, cb: uv_connect_cb);\n+\n+    // These should all really be constants...\n+    #[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n+    #[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n+    #[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n+    #[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n+    #[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n+    #[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n+    #[rust_stack] pub fn rust_AI_ALL() -> c_int;\n+    #[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n+    #[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n+    #[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n+    #[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n+    #[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n }"}, {"sha": "b144820c4424636262367a2f49ece50bc41b55ae", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bac96818580a97c049532e50702c2a8204e11754/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bac96818580a97c049532e50702c2a8204e11754/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=bac96818580a97c049532e50702c2a8204e11754", "patch": "@@ -199,3 +199,18 @@ bufrelease\n bufnew\n rust_take_dlerror_lock\n rust_drop_dlerror_lock\n+rust_SOCK_STREAM\n+rust_SOCK_DGRAM\n+rust_SOCK_RAW\n+rust_IPPROTO_UDP\n+rust_IPPROTO_TCP\n+rust_AI_ADDRCONFIG\n+rust_AI_ALL\n+rust_AI_CANONNAME\n+rust_AI_NUMERICHOST\n+rust_AI_NUMERICSERV\n+rust_AI_PASSIVE\n+rust_AI_V4MAPPED\n+uv_pipe_open\n+uv_pipe_bind\n+uv_pipe_connect"}]}