{"sha": "4d44a970a39d4bd6ec517b3958e180def9040e3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNDRhOTcwYTM5ZDRiZDZlYzUxN2IzOTU4ZTE4MGRlZjkwNDBlM2Q=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T07:38:59Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T07:38:59Z"}, "message": "move some methods from FnEvalContext to GlobalEvalContext", "tree": {"sha": "866d2ee4fcd51a53bda81a49dbc5d5b67e5db184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/866d2ee4fcd51a53bda81a49dbc5d5b67e5db184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d44a970a39d4bd6ec517b3958e180def9040e3d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXV8uTAAoJEFbW7qD8Z6xG/JcP/0KRAq7hVB6kCASz0HgmVE19\n4EdqvFqeq/hUYVHAD3ntOFdDuCc+GBx+7D4T2ehZrxxhQHVYxANndFQhxPvfttg4\nSqbStEcv0dDTPAw5j2A56EacBRKOLsMhG1H0IX87k2iKS/5UpNof6bFJYXTIyloe\nVZC1GZSU4Cspt5E8jC+Ks5DRVPHWk7CgocZtc7c46VY56BPRUnoJWtRI/2nJIjaq\nWv4n5KHkX8lM5NRK4owoJqe3Umnbr2V7CH4NkDAc8gA7qDkWVyX2LRSePaZGf3Df\nlYIQE8nxVRqDoOnMYHTAuGxalhi4osI2JJXGq9thCHxEiVkV8IbQ/kIQLoPn2MS4\nEjfW0bzlTvt5GqKNUbLkt3IQoFWTivazMNDacwhHAoehH0PH67qw665yIv4BpMHG\nqE6qjfygM0tVmziywu2XiJhrlqGWuNxGiLPtehLjQqYahiTR2RI6EJdDl+DCoNQU\nOihAGgXuGXtl06zgJjqdbzVflb3+GbOrpqjDWYVixs9CFTM136nJbcCJfBIj1Yj1\nVf8ARW2C2Mg4Ua6qFRL1u0PTCYnSPpGNmF5DjjwLjTYnQbIl87aV3V4ofWqiZIQU\nHLuV/ru3T0kHQOrhiMv7AcAka+SAE8abGy4abvP5ZXOq6zWd3aHEBJueA/BPU1CA\nnuGT8ju4DJRdnPltcJjS\n=bd6H\n-----END PGP SIGNATURE-----", "payload": "tree 866d2ee4fcd51a53bda81a49dbc5d5b67e5db184\nparent 4c833a54d2ff4e180d8d2e9dd81274ad9c8cc367\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465371539 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465371539 +0200\n\nmove some methods from FnEvalContext to GlobalEvalContext"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d44a970a39d4bd6ec517b3958e180def9040e3d", "html_url": "https://github.com/rust-lang/rust/commit/4d44a970a39d4bd6ec517b3958e180def9040e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d44a970a39d4bd6ec517b3958e180def9040e3d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c833a54d2ff4e180d8d2e9dd81274ad9c8cc367", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c833a54d2ff4e180d8d2e9dd81274ad9c8cc367", "html_url": "https://github.com/rust-lang/rust/commit/4c833a54d2ff4e180d8d2e9dd81274ad9c8cc367"}], "stats": {"total": 256, "additions": 160, "deletions": 96}, "files": [{"sha": "5072270f1aa7ba1ff11cc2f5b3898d812b9e52b1", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 160, "deletions": 96, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/4d44a970a39d4bd6ec517b3958e180def9040e3d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d44a970a39d4bd6ec517b3958e180def9040e3d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=4d44a970a39d4bd6ec517b3958e180def9040e3d", "patch": "@@ -173,16 +173,150 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n \n     fn call(&mut self, mir: &mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n         let substs = self.tcx.mk_substs(subst::Substs::empty());\n+        let return_ptr = self.alloc_ret_ptr(mir.return_ty, substs);\n \n         let mut nested_fecx = FnEvalContext::new(self);\n \n         nested_fecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n-        let return_ptr = nested_fecx.alloc_ret_ptr(mir.return_ty);\n+\n         nested_fecx.frame_mut().return_ptr = return_ptr;\n \n         nested_fecx.run()?;\n         Ok(return_ptr)\n     }\n+\n+    fn alloc_ret_ptr(&mut self, ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+        match ty {\n+            ty::FnConverging(ty) => {\n+                let size = self.type_size(ty, substs);\n+                Some(self.memory.allocate(size))\n+            }\n+            ty::FnDiverging => None,\n+        }\n+    }\n+    // TODO(solson): Try making const_to_primval instead.\n+    fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n+        use rustc::middle::const_val::ConstVal::*;\n+        match *const_val {\n+            Float(_f) => unimplemented!(),\n+            Integral(int) => {\n+                // TODO(solson): Check int constant type.\n+                let ptr = self.memory.allocate(8);\n+                self.memory.write_uint(ptr, int.to_u64_unchecked(), 8)?;\n+                Ok(ptr)\n+            }\n+            Str(ref s) => {\n+                let psize = self.memory.pointer_size;\n+                let static_ptr = self.memory.allocate(s.len());\n+                let ptr = self.memory.allocate(psize * 2);\n+                self.memory.write_bytes(static_ptr, s.as_bytes())?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n+                self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n+                Ok(ptr)\n+            }\n+            ByteStr(ref bs) => {\n+                let psize = self.memory.pointer_size;\n+                let static_ptr = self.memory.allocate(bs.len());\n+                let ptr = self.memory.allocate(psize);\n+                self.memory.write_bytes(static_ptr, bs)?;\n+                self.memory.write_ptr(ptr, static_ptr)?;\n+                Ok(ptr)\n+            }\n+            Bool(b) => {\n+                let ptr = self.memory.allocate(1);\n+                self.memory.write_bool(ptr, b)?;\n+                Ok(ptr)\n+            }\n+            Char(_c)          => unimplemented!(),\n+            Struct(_node_id)  => unimplemented!(),\n+            Tuple(_node_id)   => unimplemented!(),\n+            Function(_def_id) => unimplemented!(),\n+            Array(_, _)       => unimplemented!(),\n+            Repeat(_, _)      => unimplemented!(),\n+            Dummy             => unimplemented!(),\n+        }\n+    }\n+\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+    }\n+\n+    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n+    }\n+\n+    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n+        // Do the initial selection for the obligation. This yields the shallow result we are\n+        // looking for -- that is, what specific impl.\n+        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+            let obligation = traits::Obligation::new(\n+                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+                trait_ref.to_poly_trait_predicate(),\n+            );\n+            let selection = selcx.select(&obligation).unwrap().unwrap();\n+\n+            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n+            // This is because they can inform the inference of the impl's type parameters.\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let vtable = selection.map(|predicate| {\n+                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+            });\n+            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n+        })\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub fn trait_method(\n+        &self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> (DefId, &'tcx Substs<'tcx>) {\n+        let method_item = self.tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n+        match self.fulfill_obligation(trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = self.tcx.item_name(def_id);\n+                // Create a concatenated set of substitutions which includes those from the impl\n+                // and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(substs);\n+                let substs = self.tcx.mk_substs(impl_substs);\n+                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n+\n+                (mth.method.def_id, mth.substs)\n+            }\n+\n+            traits::VtableClosure(vtable_closure) =>\n+                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n+\n+            traits::VtableFnPointer(_fn_ty) => {\n+                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                unimplemented!()\n+                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                // let method_ty = def_ty(tcx, def_id, substs);\n+                // let fn_ptr_ty = match method_ty.sty {\n+                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                //     _ => unreachable!(\"expected fn item type, found {}\",\n+                //                       method_ty)\n+                // };\n+                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+\n+            traits::VtableObject(ref _data) => {\n+                unimplemented!()\n+                // Callee {\n+                //     data: Virtual(traits::get_vtable_index_of_object_method(\n+                //                   tcx, data, def_id)),\n+                //                   ty: def_ty(tcx, def_id, substs)\n+                // }\n+            }\n+            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n+        }\n+    }\n }\n \n impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n@@ -193,33 +327,36 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         }\n     }\n \n-    fn alloc_ret_ptr(&mut self, ty: ty::FnOutput<'tcx>) -> Option<Pointer> {\n-        match ty {\n-            ty::FnConverging(ty) => {\n-                let size = self.type_size(ty);\n-                Some(self.memory.allocate(size))\n+    #[inline(never)]\n+    #[cold]\n+    fn report(&self, e: &EvalError) {\n+        let stmt = self.frame().stmt;\n+        let block = self.basic_block();\n+        let span = if stmt < block.statements.len() {\n+            block.statements[stmt].span\n+        } else {\n+            block.terminator().span\n+        };\n+        let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n+        for &Frame{ def_id, substs, span, .. } in self.stack.iter().rev() {\n+            // FIXME(solson): Find a way to do this without this Display impl hack.\n+            use rustc::util::ppaux;\n+            use std::fmt;\n+            struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n+            impl<'tcx> fmt::Display for Instance<'tcx> {\n+                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                    ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n+                        |tcx| tcx.lookup_item_type(self.0).generics)\n+                }\n             }\n-            ty::FnDiverging => None,\n+            err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n         }\n+        err.emit();\n     }\n \n-    fn maybe_report<T>(&self, span: codemap::Span, r: EvalResult<T>) -> EvalResult<T> {\n+    fn maybe_report<T>(&self, r: EvalResult<T>) -> EvalResult<T> {\n         if let Err(ref e) = r {\n-            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n-            for &Frame{ def_id, substs, span, .. } in self.stack.iter().rev() {\n-                // FIXME(solson): Find a way to do this without this Display impl hack.\n-                use rustc::util::ppaux;\n-                use std::fmt;\n-                struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n-                impl<'tcx> fmt::Display for Instance<'tcx> {\n-                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                        ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                            |tcx| tcx.lookup_item_type(self.0).generics)\n-                    }\n-                }\n-                err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n-            }\n-            err.emit();\n+            self.report(e);\n         }\n         r\n     }\n@@ -1317,79 +1454,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n         }\n     }\n-\n-    fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n-        // Do the initial selection for the obligation. This yields the shallow result we are\n-        // looking for -- that is, what specific impl.\n-        self.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n-            let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-            let obligation = traits::Obligation::new(\n-                traits::ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-                trait_ref.to_poly_trait_predicate(),\n-            );\n-            let selection = selcx.select(&obligation).unwrap().unwrap();\n-\n-            // Currently, we use a fulfillment context to completely resolve all nested obligations.\n-            // This is because they can inform the inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &vtable)\n-        })\n-    }\n-\n-    /// Trait method, which has to be resolved to an impl method.\n-    pub fn trait_method(\n-        &self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    ) -> (DefId, &'tcx Substs<'tcx>) {\n-        let method_item = self.tcx.impl_or_trait_item(def_id);\n-        let trait_id = method_item.container().id();\n-        let trait_ref = ty::Binder(substs.to_trait_ref(self.tcx, trait_id));\n-        match self.fulfill_obligation(trait_ref) {\n-            traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = self.tcx.item_name(def_id);\n-                // Create a concatenated set of substitutions which includes those from the impl\n-                // and those from the method:\n-                let impl_substs = vtable_impl.substs.with_method_from(substs);\n-                let substs = self.tcx.mk_substs(impl_substs);\n-                let mth = get_impl_method(self.tcx, impl_did, substs, mname);\n-\n-                (mth.method.def_id, mth.substs)\n-            }\n-\n-            traits::VtableClosure(vtable_closure) =>\n-                (vtable_closure.closure_def_id, vtable_closure.substs.func_substs),\n-\n-            traits::VtableFnPointer(_fn_ty) => {\n-                let _trait_closure_kind = self.tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                unimplemented!()\n-                // let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n-\n-                // let method_ty = def_ty(tcx, def_id, substs);\n-                // let fn_ptr_ty = match method_ty.sty {\n-                //     ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-                //     _ => unreachable!(\"expected fn item type, found {}\",\n-                //                       method_ty)\n-                // };\n-                // Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n-            }\n-\n-            traits::VtableObject(ref _data) => {\n-                unimplemented!()\n-                // Callee {\n-                //     data: Virtual(traits::get_vtable_index_of_object_method(\n-                //                   tcx, data, def_id)),\n-                //                   ty: def_ty(tcx, def_id, substs)\n-                // }\n-            }\n-            vtable => unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n-        }\n-    }\n }\n \n fn pointee_type(ptr_ty: ty::Ty) -> Option<ty::Ty> {"}]}