{"sha": "348cbc054c91dbdae3633d5f401a1187e79232ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OGNiYzA1NGM5MWRiZGFlMzYzM2Q1ZjQwMWExMTg3ZTc5MjMyZWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-10T17:28:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-10T17:28:59Z"}, "message": "Merge #4418\n\n4418: Refactor protocol handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d05381a92e7e4dd0372d6cf915872e16f47f66e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d05381a92e7e4dd0372d6cf915872e16f47f66e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/348cbc054c91dbdae3633d5f401a1187e79232ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeuDnbCRBK7hj4Ov3rIwAAdHIIAACwe5/bCN9j47KyEeQW8kfJ\nIRPEV27lVi2AOYwpw78b70Kl1gd3w3VnElxxlU/n0I6BygofVwmK4/tN8l+U+2pL\nMdWC4KL2MUbEqbzTzF1OjTmG1P/isQ+tHFzxWtLj4ZYYS3sr91fSofRpajXoI0Rs\nwlinpFI/reFmwtejWOxhC/c5mQDGxQVm7LmFa0K+o0gTI9DY6F6vvHgXdVX0zkZg\nGqTRFVFrp7jOcYgT7kiVcwNZa4C/jP2OWB3j6PD+nuSu9h2FObUmD7EIGEAMdSXx\nZ4HWaKQkaWhecjXVWkCeFekE2SI4vsVkQYMTR8K0f0QN8Fq9NdIK8PYlUXkqDxs=\n=rI4Z\n-----END PGP SIGNATURE-----\n", "payload": "tree d05381a92e7e4dd0372d6cf915872e16f47f66e3\nparent 225f353aa26329260b8c7f69305f616a9edaad70\nparent 3bec2be9de400dc044ae924cb0ae36faa454d111\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589131739 +0000\ncommitter GitHub <noreply@github.com> 1589131739 +0000\n\nMerge #4418\n\n4418: Refactor protocol handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/348cbc054c91dbdae3633d5f401a1187e79232ee", "html_url": "https://github.com/rust-lang/rust/commit/348cbc054c91dbdae3633d5f401a1187e79232ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/348cbc054c91dbdae3633d5f401a1187e79232ee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225f353aa26329260b8c7f69305f616a9edaad70", "url": "https://api.github.com/repos/rust-lang/rust/commits/225f353aa26329260b8c7f69305f616a9edaad70", "html_url": "https://github.com/rust-lang/rust/commit/225f353aa26329260b8c7f69305f616a9edaad70"}, {"sha": "3bec2be9de400dc044ae924cb0ae36faa454d111", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bec2be9de400dc044ae924cb0ae36faa454d111", "html_url": "https://github.com/rust-lang/rust/commit/3bec2be9de400dc044ae924cb0ae36faa454d111"}], "stats": {"total": 2122, "additions": 999, "deletions": 1123}, "files": [{"sha": "5da28edd24144396e8a3f73f92706f8873529b33", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::FileSymbol;\n+use crate::{FileRange, FileSymbol};\n \n use super::short_label::ShortLabel;\n \n@@ -22,10 +22,11 @@ use super::short_label::ShortLabel;\n /// code, like a function or a struct, but this is not strictly required.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct NavigationTarget {\n+    // FIXME: use FileRange?\n     file_id: FileId,\n+    full_range: TextRange,\n     name: SmolStr,\n     kind: SyntaxKind,\n-    full_range: TextRange,\n     focus_range: Option<TextRange>,\n     container_name: Option<SmolStr>,\n     description: Option<String>,\n@@ -63,6 +64,10 @@ impl NavigationTarget {\n         self.file_id\n     }\n \n+    pub fn file_range(&self) -> FileRange {\n+        FileRange { file_id: self.file_id, range: self.full_range }\n+    }\n+\n     pub fn full_range(&self) -> TextRange {\n         self.full_range\n     }"}, {"sha": "37f77cc47c50a6af30a55325b3ec679391c5e2bf", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -75,6 +75,7 @@ impl TextEdit {\n         self.indels.is_empty()\n     }\n \n+    // FXME: impl IntoIter instead\n     pub fn as_indels(&self) -> &[Indel] {\n         &self.indels\n     }"}, {"sha": "f64c90b5b17ad2bbbccdbdd92f5e44f4dbacc35d", "filename": "crates/rust-analyzer/src/conv.rs", "status": "removed", "additions": 0, "deletions": 726, "changes": 726, "blob_url": "https://github.com/rust-lang/rust/blob/225f353aa26329260b8c7f69305f616a9edaad70/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/225f353aa26329260b8c7f69305f616a9edaad70/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=225f353aa26329260b8c7f69305f616a9edaad70", "patch": "@@ -1,726 +0,0 @@\n-//! Convenience module responsible for translating between rust-analyzer's types\n-//! and LSP types.\n-\n-use lsp_types::{\n-    self, CreateFile, DiagnosticSeverity, DocumentChangeOperation, DocumentChanges, Documentation,\n-    Location, LocationLink, MarkupContent, MarkupKind, ParameterInformation, ParameterLabel,\n-    Position, Range, RenameFile, ResourceOp, SemanticTokenModifier, SemanticTokenType,\n-    SignatureInformation, SymbolKind, TextDocumentEdit, TextDocumentIdentifier, TextDocumentItem,\n-    TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, WorkspaceEdit,\n-};\n-use ra_ide::{\n-    translate_offset_with_edit, CompletionItem, CompletionItemKind, FileId, FilePosition,\n-    FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HighlightModifier, HighlightTag,\n-    InlayHint, InlayKind, InsertTextFormat, LineCol, LineIndex, NavigationTarget, RangeInfo,\n-    ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n-};\n-use ra_syntax::{SyntaxKind, TextRange, TextSize};\n-use ra_text_edit::{Indel, TextEdit};\n-use ra_vfs::LineEndings;\n-\n-use crate::{\n-    req,\n-    semantic_tokens::{self, ModifierSet, CONSTANT, CONTROL_FLOW, MUTABLE, UNSAFE},\n-    world::WorldSnapshot,\n-    Result,\n-};\n-use semantic_tokens::{\n-    ATTRIBUTE, BUILTIN_TYPE, ENUM_MEMBER, FORMAT_SPECIFIER, LIFETIME, TYPE_ALIAS, UNION,\n-    UNRESOLVED_REFERENCE,\n-};\n-\n-pub trait Conv {\n-    type Output;\n-    fn conv(self) -> Self::Output;\n-}\n-\n-pub trait ConvWith<CTX> {\n-    type Output;\n-    fn conv_with(self, ctx: CTX) -> Self::Output;\n-}\n-\n-pub trait TryConvWith<CTX> {\n-    type Output;\n-    fn try_conv_with(self, ctx: CTX) -> Result<Self::Output>;\n-}\n-\n-impl Conv for SyntaxKind {\n-    type Output = SymbolKind;\n-\n-    fn conv(self) -> <Self as Conv>::Output {\n-        match self {\n-            SyntaxKind::FN_DEF => SymbolKind::Function,\n-            SyntaxKind::STRUCT_DEF => SymbolKind::Struct,\n-            SyntaxKind::ENUM_DEF => SymbolKind::Enum,\n-            SyntaxKind::ENUM_VARIANT => SymbolKind::EnumMember,\n-            SyntaxKind::TRAIT_DEF => SymbolKind::Interface,\n-            SyntaxKind::MACRO_CALL => SymbolKind::Function,\n-            SyntaxKind::MODULE => SymbolKind::Module,\n-            SyntaxKind::TYPE_ALIAS_DEF => SymbolKind::TypeParameter,\n-            SyntaxKind::RECORD_FIELD_DEF => SymbolKind::Field,\n-            SyntaxKind::STATIC_DEF => SymbolKind::Constant,\n-            SyntaxKind::CONST_DEF => SymbolKind::Constant,\n-            SyntaxKind::IMPL_DEF => SymbolKind::Object,\n-            _ => SymbolKind::Variable,\n-        }\n-    }\n-}\n-\n-impl Conv for ReferenceAccess {\n-    type Output = ::lsp_types::DocumentHighlightKind;\n-\n-    fn conv(self) -> Self::Output {\n-        use lsp_types::DocumentHighlightKind;\n-        match self {\n-            ReferenceAccess::Read => DocumentHighlightKind::Read,\n-            ReferenceAccess::Write => DocumentHighlightKind::Write,\n-        }\n-    }\n-}\n-\n-impl Conv for CompletionItemKind {\n-    type Output = ::lsp_types::CompletionItemKind;\n-\n-    fn conv(self) -> <Self as Conv>::Output {\n-        use lsp_types::CompletionItemKind::*;\n-        match self {\n-            CompletionItemKind::Keyword => Keyword,\n-            CompletionItemKind::Snippet => Snippet,\n-            CompletionItemKind::Module => Module,\n-            CompletionItemKind::Function => Function,\n-            CompletionItemKind::Struct => Struct,\n-            CompletionItemKind::Enum => Enum,\n-            CompletionItemKind::EnumVariant => EnumMember,\n-            CompletionItemKind::BuiltinType => Struct,\n-            CompletionItemKind::Binding => Variable,\n-            CompletionItemKind::Field => Field,\n-            CompletionItemKind::Trait => Interface,\n-            CompletionItemKind::TypeAlias => Struct,\n-            CompletionItemKind::Const => Constant,\n-            CompletionItemKind::Static => Value,\n-            CompletionItemKind::Method => Method,\n-            CompletionItemKind::TypeParam => TypeParameter,\n-            CompletionItemKind::Macro => Method,\n-            CompletionItemKind::Attribute => EnumMember,\n-        }\n-    }\n-}\n-\n-impl Conv for Severity {\n-    type Output = DiagnosticSeverity;\n-    fn conv(self) -> DiagnosticSeverity {\n-        match self {\n-            Severity::Error => DiagnosticSeverity::Error,\n-            Severity::WeakWarning => DiagnosticSeverity::Hint,\n-        }\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n-    type Output = ::lsp_types::CompletionItem;\n-\n-    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> ::lsp_types::CompletionItem {\n-        let mut additional_text_edits = Vec::new();\n-        let mut text_edit = None;\n-        // LSP does not allow arbitrary edits in completion, so we have to do a\n-        // non-trivial mapping here.\n-        for indel in self.text_edit().as_indels() {\n-            if indel.delete.contains_range(self.source_range()) {\n-                text_edit = Some(if indel.delete == self.source_range() {\n-                    indel.conv_with((ctx.0, ctx.1))\n-                } else {\n-                    assert!(self.source_range().end() == indel.delete.end());\n-                    let range1 = TextRange::new(indel.delete.start(), self.source_range().start());\n-                    let range2 = self.source_range();\n-                    let edit1 = Indel::replace(range1, String::new());\n-                    let edit2 = Indel::replace(range2, indel.insert.clone());\n-                    additional_text_edits.push(edit1.conv_with((ctx.0, ctx.1)));\n-                    edit2.conv_with((ctx.0, ctx.1))\n-                })\n-            } else {\n-                assert!(self.source_range().intersect(indel.delete).is_none());\n-                additional_text_edits.push(indel.conv_with((ctx.0, ctx.1)));\n-            }\n-        }\n-        let text_edit = text_edit.unwrap();\n-\n-        let mut res = lsp_types::CompletionItem {\n-            label: self.label().to_string(),\n-            detail: self.detail().map(|it| it.to_string()),\n-            filter_text: Some(self.lookup().to_string()),\n-            kind: self.kind().map(|it| it.conv()),\n-            text_edit: Some(text_edit.into()),\n-            additional_text_edits: Some(additional_text_edits),\n-            documentation: self.documentation().map(|it| it.conv()),\n-            deprecated: Some(self.deprecated()),\n-            command: if self.trigger_call_info() {\n-                let cmd = lsp_types::Command {\n-                    title: \"triggerParameterHints\".into(),\n-                    command: \"editor.action.triggerParameterHints\".into(),\n-                    arguments: None,\n-                };\n-                Some(cmd)\n-            } else {\n-                None\n-            },\n-            ..Default::default()\n-        };\n-\n-        if self.score().is_some() {\n-            res.preselect = Some(true)\n-        }\n-\n-        if self.deprecated() {\n-            res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n-        }\n-\n-        res.insert_text_format = Some(match self.insert_text_format() {\n-            InsertTextFormat::Snippet => lsp_types::InsertTextFormat::Snippet,\n-            InsertTextFormat::PlainText => lsp_types::InsertTextFormat::PlainText,\n-        });\n-\n-        res\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for Position {\n-    type Output = TextSize;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> TextSize {\n-        let line_col = LineCol { line: self.line as u32, col_utf16: self.character as u32 };\n-        line_index.offset(line_col)\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for TextSize {\n-    type Output = Position;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> Position {\n-        let line_col = line_index.line_col(self);\n-        Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16))\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for TextRange {\n-    type Output = Range;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> Range {\n-        Range::new(self.start().conv_with(line_index), self.end().conv_with(line_index))\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for Range {\n-    type Output = TextRange;\n-\n-    fn conv_with(self, line_index: &LineIndex) -> TextRange {\n-        TextRange::new(self.start.conv_with(line_index), self.end.conv_with(line_index))\n-    }\n-}\n-\n-impl Conv for ra_ide::Documentation {\n-    type Output = lsp_types::Documentation;\n-    fn conv(self) -> Documentation {\n-        Documentation::MarkupContent(MarkupContent {\n-            kind: MarkupKind::Markdown,\n-            value: crate::markdown::format_docs(self.as_str()),\n-        })\n-    }\n-}\n-\n-impl ConvWith<bool> for ra_ide::FunctionSignature {\n-    type Output = lsp_types::SignatureInformation;\n-    fn conv_with(self, concise: bool) -> Self::Output {\n-        let (label, documentation, params) = if concise {\n-            let mut params = self.parameters;\n-            if self.has_self_param {\n-                params.remove(0);\n-            }\n-            (params.join(\", \"), None, params)\n-        } else {\n-            (self.to_string(), self.doc.map(|it| it.conv()), self.parameters)\n-        };\n-\n-        let parameters: Vec<ParameterInformation> = params\n-            .into_iter()\n-            .map(|param| ParameterInformation {\n-                label: ParameterLabel::Simple(param),\n-                documentation: None,\n-            })\n-            .collect();\n-\n-        SignatureInformation { label, documentation, parameters: Some(parameters) }\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for TextEdit {\n-    type Output = Vec<lsp_types::TextEdit>;\n-\n-    fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> Vec<lsp_types::TextEdit> {\n-        self.as_indels().iter().map_conv_with(ctx).collect()\n-    }\n-}\n-\n-impl ConvWith<(&LineIndex, LineEndings)> for &Indel {\n-    type Output = lsp_types::TextEdit;\n-\n-    fn conv_with(\n-        self,\n-        (line_index, line_endings): (&LineIndex, LineEndings),\n-    ) -> lsp_types::TextEdit {\n-        let mut new_text = self.insert.clone();\n-        if line_endings == LineEndings::Dos {\n-            new_text = new_text.replace('\\n', \"\\r\\n\");\n-        }\n-        lsp_types::TextEdit { range: self.delete.conv_with(line_index), new_text }\n-    }\n-}\n-\n-pub(crate) struct FoldConvCtx<'a> {\n-    pub(crate) text: &'a str,\n-    pub(crate) line_index: &'a LineIndex,\n-    pub(crate) line_folding_only: bool,\n-}\n-\n-impl ConvWith<&FoldConvCtx<'_>> for Fold {\n-    type Output = lsp_types::FoldingRange;\n-\n-    fn conv_with(self, ctx: &FoldConvCtx) -> lsp_types::FoldingRange {\n-        let kind = match self.kind {\n-            FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n-            FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n-            FoldKind::Mods => None,\n-            FoldKind::Block => None,\n-        };\n-\n-        let range = self.range.conv_with(&ctx.line_index);\n-\n-        if ctx.line_folding_only {\n-            // Clients with line_folding_only == true (such as VSCode) will fold the whole end line\n-            // even if it contains text not in the folding range. To prevent that we exclude\n-            // range.end.line from the folding region if there is more text after range.end\n-            // on the same line.\n-            let has_more_text_on_end_line = ctx.text\n-                [TextRange::new(self.range.end(), TextSize::of(ctx.text))]\n-            .chars()\n-            .take_while(|it| *it != '\\n')\n-            .any(|it| !it.is_whitespace());\n-\n-            let end_line = if has_more_text_on_end_line {\n-                range.end.line.saturating_sub(1)\n-            } else {\n-                range.end.line\n-            };\n-\n-            lsp_types::FoldingRange {\n-                start_line: range.start.line,\n-                start_character: None,\n-                end_line,\n-                end_character: None,\n-                kind,\n-            }\n-        } else {\n-            lsp_types::FoldingRange {\n-                start_line: range.start.line,\n-                start_character: Some(range.start.character),\n-                end_line: range.end.line,\n-                end_character: Some(range.end.character),\n-                kind,\n-            }\n-        }\n-    }\n-}\n-\n-impl ConvWith<&LineIndex> for InlayHint {\n-    type Output = req::InlayHint;\n-    fn conv_with(self, line_index: &LineIndex) -> Self::Output {\n-        req::InlayHint {\n-            label: self.label.to_string(),\n-            range: self.range.conv_with(line_index),\n-            kind: match self.kind {\n-                InlayKind::ParameterHint => req::InlayKind::ParameterHint,\n-                InlayKind::TypeHint => req::InlayKind::TypeHint,\n-                InlayKind::ChainingHint => req::InlayKind::ChainingHint,\n-            },\n-        }\n-    }\n-}\n-\n-impl Conv for Highlight {\n-    type Output = (u32, u32);\n-\n-    fn conv(self) -> Self::Output {\n-        let mut mods = ModifierSet::default();\n-        let type_ = match self.tag {\n-            HighlightTag::Struct => SemanticTokenType::STRUCT,\n-            HighlightTag::Enum => SemanticTokenType::ENUM,\n-            HighlightTag::Union => UNION,\n-            HighlightTag::TypeAlias => TYPE_ALIAS,\n-            HighlightTag::Trait => SemanticTokenType::INTERFACE,\n-            HighlightTag::BuiltinType => BUILTIN_TYPE,\n-            HighlightTag::SelfType => SemanticTokenType::TYPE,\n-            HighlightTag::Field => SemanticTokenType::MEMBER,\n-            HighlightTag::Function => SemanticTokenType::FUNCTION,\n-            HighlightTag::Module => SemanticTokenType::NAMESPACE,\n-            HighlightTag::Constant => {\n-                mods |= CONSTANT;\n-                mods |= SemanticTokenModifier::STATIC;\n-                SemanticTokenType::VARIABLE\n-            }\n-            HighlightTag::Static => {\n-                mods |= SemanticTokenModifier::STATIC;\n-                SemanticTokenType::VARIABLE\n-            }\n-            HighlightTag::EnumVariant => ENUM_MEMBER,\n-            HighlightTag::Macro => SemanticTokenType::MACRO,\n-            HighlightTag::Local => SemanticTokenType::VARIABLE,\n-            HighlightTag::TypeParam => SemanticTokenType::TYPE_PARAMETER,\n-            HighlightTag::Lifetime => LIFETIME,\n-            HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => SemanticTokenType::NUMBER,\n-            HighlightTag::CharLiteral | HighlightTag::StringLiteral => SemanticTokenType::STRING,\n-            HighlightTag::Comment => SemanticTokenType::COMMENT,\n-            HighlightTag::Attribute => ATTRIBUTE,\n-            HighlightTag::Keyword => SemanticTokenType::KEYWORD,\n-            HighlightTag::UnresolvedReference => UNRESOLVED_REFERENCE,\n-            HighlightTag::FormatSpecifier => FORMAT_SPECIFIER,\n-        };\n-\n-        for modifier in self.modifiers.iter() {\n-            let modifier = match modifier {\n-                HighlightModifier::Definition => SemanticTokenModifier::DECLARATION,\n-                HighlightModifier::ControlFlow => CONTROL_FLOW,\n-                HighlightModifier::Mutable => MUTABLE,\n-                HighlightModifier::Unsafe => UNSAFE,\n-            };\n-            mods |= modifier;\n-        }\n-\n-        (semantic_tokens::type_index(type_), mods.0)\n-    }\n-}\n-\n-impl<T: ConvWith<CTX>, CTX> ConvWith<CTX> for Option<T> {\n-    type Output = Option<T::Output>;\n-\n-    fn conv_with(self, ctx: CTX) -> Self::Output {\n-        self.map(|x| ConvWith::conv_with(x, ctx))\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &Url {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        world.uri_to_file_id(self)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for FileId {\n-    type Output = Url;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<Url> {\n-        world.file_id_to_uri(self)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentItem {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        self.uri.try_conv_with(world)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &VersionedTextDocumentIdentifier {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        self.uri.try_conv_with(world)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentIdentifier {\n-    type Output = FileId;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileId> {\n-        world.uri_to_file_id(&self.uri)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &TextDocumentPositionParams {\n-    type Output = FilePosition;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FilePosition> {\n-        let file_id = self.text_document.try_conv_with(world)?;\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let offset = self.position.conv_with(&line_index);\n-        Ok(FilePosition { file_id, offset })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (&TextDocumentIdentifier, Range) {\n-    type Output = FileRange;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<FileRange> {\n-        let file_id = self.0.try_conv_with(world)?;\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = self.1.conv_with(&line_index);\n-        Ok(FileRange { file_id, range })\n-    }\n-}\n-\n-impl<T: TryConvWith<CTX>, CTX: Copy> TryConvWith<CTX> for Vec<T> {\n-    type Output = Vec<<T as TryConvWith<CTX>>::Output>;\n-    fn try_conv_with(self, ctx: CTX) -> Result<Self::Output> {\n-        let mut res = Vec::with_capacity(self.len());\n-        for item in self {\n-            res.push(item.try_conv_with(ctx)?);\n-        }\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for SourceChange {\n-    type Output = req::SourceChange;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<req::SourceChange> {\n-        let cursor_position = match self.cursor_position {\n-            None => None,\n-            Some(pos) => {\n-                let line_index = world.analysis().file_line_index(pos.file_id)?;\n-                let edit = self\n-                    .source_file_edits\n-                    .iter()\n-                    .find(|it| it.file_id == pos.file_id)\n-                    .map(|it| &it.edit);\n-                let line_col = match edit {\n-                    Some(edit) => translate_offset_with_edit(&*line_index, pos.offset, edit),\n-                    None => line_index.line_col(pos.offset),\n-                };\n-                let position =\n-                    Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16));\n-                Some(TextDocumentPositionParams {\n-                    text_document: TextDocumentIdentifier::new(pos.file_id.try_conv_with(world)?),\n-                    position,\n-                })\n-            }\n-        };\n-        let mut document_changes: Vec<DocumentChangeOperation> = Vec::new();\n-        for resource_op in self.file_system_edits.try_conv_with(world)? {\n-            document_changes.push(DocumentChangeOperation::Op(resource_op));\n-        }\n-        for text_document_edit in self.source_file_edits.try_conv_with(world)? {\n-            document_changes.push(DocumentChangeOperation::Edit(text_document_edit));\n-        }\n-        let workspace_edit = WorkspaceEdit {\n-            changes: None,\n-            document_changes: Some(DocumentChanges::Operations(document_changes)),\n-        };\n-        Ok(req::SourceChange { label: self.label, workspace_edit, cursor_position })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for SourceFileEdit {\n-    type Output = TextDocumentEdit;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<TextDocumentEdit> {\n-        let text_document = VersionedTextDocumentIdentifier {\n-            uri: self.file_id.try_conv_with(world)?,\n-            version: None,\n-        };\n-        let line_index = world.analysis().file_line_index(self.file_id)?;\n-        let line_endings = world.file_line_endings(self.file_id);\n-        let edits =\n-            self.edit.as_indels().iter().map_conv_with((&line_index, line_endings)).collect();\n-        Ok(TextDocumentEdit { text_document, edits })\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for FileSystemEdit {\n-    type Output = ResourceOp;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<ResourceOp> {\n-        let res = match self {\n-            FileSystemEdit::CreateFile { source_root, path } => {\n-                let uri = world.path_to_uri(source_root, &path)?;\n-                ResourceOp::Create(CreateFile { uri, options: None })\n-            }\n-            FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-                let old_uri = world.file_id_to_uri(src)?;\n-                let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n-                ResourceOp::Rename(RenameFile { old_uri, new_uri, options: None })\n-            }\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for &NavigationTarget {\n-    type Output = Location;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<Location> {\n-        let line_index = world.analysis().file_line_index(self.file_id())?;\n-        let range = self.range();\n-        to_location(self.file_id(), range, &world, &line_index)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (FileId, RangeInfo<NavigationTarget>) {\n-    type Output = LocationLink;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<LocationLink> {\n-        let (src_file_id, target) = self;\n-\n-        let target_uri = target.info.file_id().try_conv_with(world)?;\n-        let src_line_index = world.analysis().file_line_index(src_file_id)?;\n-        let tgt_line_index = world.analysis().file_line_index(target.info.file_id())?;\n-\n-        let target_range = target.info.full_range().conv_with(&tgt_line_index);\n-\n-        let target_selection_range = target\n-            .info\n-            .focus_range()\n-            .map(|it| it.conv_with(&tgt_line_index))\n-            .unwrap_or(target_range);\n-\n-        let res = LocationLink {\n-            origin_selection_range: Some(target.range.conv_with(&src_line_index)),\n-            target_uri,\n-            target_range,\n-            target_selection_range,\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-impl TryConvWith<&WorldSnapshot> for (FileId, RangeInfo<Vec<NavigationTarget>>) {\n-    type Output = req::GotoDefinitionResponse;\n-    fn try_conv_with(self, world: &WorldSnapshot) -> Result<req::GotoTypeDefinitionResponse> {\n-        let (file_id, RangeInfo { range, info: navs }) = self;\n-        let links = navs\n-            .into_iter()\n-            .map(|nav| (file_id, RangeInfo::new(range, nav)))\n-            .try_conv_with_to_vec(world)?;\n-        if world.config.client_caps.location_link {\n-            Ok(links.into())\n-        } else {\n-            let locations: Vec<Location> = links\n-                .into_iter()\n-                .map(|link| Location { uri: link.target_uri, range: link.target_selection_range })\n-                .collect();\n-            Ok(locations.into())\n-        }\n-    }\n-}\n-\n-pub fn to_call_hierarchy_item(\n-    file_id: FileId,\n-    range: TextRange,\n-    world: &WorldSnapshot,\n-    line_index: &LineIndex,\n-    nav: NavigationTarget,\n-) -> Result<lsp_types::CallHierarchyItem> {\n-    Ok(lsp_types::CallHierarchyItem {\n-        name: nav.name().to_string(),\n-        kind: nav.kind().conv(),\n-        tags: None,\n-        detail: nav.description().map(|it| it.to_string()),\n-        uri: file_id.try_conv_with(&world)?,\n-        range: nav.range().conv_with(&line_index),\n-        selection_range: range.conv_with(&line_index),\n-    })\n-}\n-\n-pub fn to_location(\n-    file_id: FileId,\n-    range: TextRange,\n-    world: &WorldSnapshot,\n-    line_index: &LineIndex,\n-) -> Result<Location> {\n-    let url = file_id.try_conv_with(world)?;\n-    let loc = Location::new(url, range.conv_with(line_index));\n-    Ok(loc)\n-}\n-\n-pub trait MapConvWith<CTX>: Sized {\n-    type Output;\n-\n-    fn map_conv_with(self, ctx: CTX) -> ConvWithIter<Self, CTX> {\n-        ConvWithIter { iter: self, ctx }\n-    }\n-}\n-\n-impl<CTX, I> MapConvWith<CTX> for I\n-where\n-    I: Iterator,\n-    I::Item: ConvWith<CTX>,\n-{\n-    type Output = <I::Item as ConvWith<CTX>>::Output;\n-}\n-\n-pub struct ConvWithIter<I, CTX> {\n-    iter: I,\n-    ctx: CTX,\n-}\n-\n-impl<I, CTX> Iterator for ConvWithIter<I, CTX>\n-where\n-    I: Iterator,\n-    I::Item: ConvWith<CTX>,\n-    CTX: Copy,\n-{\n-    type Item = <I::Item as ConvWith<CTX>>::Output;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.iter.next().map(|item| item.conv_with(self.ctx))\n-    }\n-}\n-\n-pub trait TryConvWithToVec<CTX>: Sized {\n-    type Output;\n-\n-    fn try_conv_with_to_vec(self, ctx: CTX) -> Result<Vec<Self::Output>>;\n-}\n-\n-impl<I, CTX> TryConvWithToVec<CTX> for I\n-where\n-    I: Iterator,\n-    I::Item: TryConvWith<CTX>,\n-    CTX: Copy,\n-{\n-    type Output = <I::Item as TryConvWith<CTX>>::Output;\n-\n-    fn try_conv_with_to_vec(self, ctx: CTX) -> Result<Vec<Self::Output>> {\n-        self.map(|it| it.try_conv_with(ctx)).collect()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::extract_ranges;\n-\n-    #[test]\n-    fn conv_fold_line_folding_only_fixup() {\n-        let text = r#\"<fold>mod a;\n-mod b;\n-mod c;</fold>\n-\n-fn main() <fold>{\n-    if cond <fold>{\n-        a::do_a();\n-    }</fold> else <fold>{\n-        b::do_b();\n-    }</fold>\n-}</fold>\"#;\n-\n-        let (ranges, text) = extract_ranges(text, \"fold\");\n-        assert_eq!(ranges.len(), 4);\n-        let folds = vec![\n-            Fold { range: ranges[0], kind: FoldKind::Mods },\n-            Fold { range: ranges[1], kind: FoldKind::Block },\n-            Fold { range: ranges[2], kind: FoldKind::Block },\n-            Fold { range: ranges[3], kind: FoldKind::Block },\n-        ];\n-\n-        let line_index = LineIndex::new(&text);\n-        let ctx = FoldConvCtx { text: &text, line_index: &line_index, line_folding_only: true };\n-        let converted: Vec<_> = folds.into_iter().map_conv_with(&ctx).collect();\n-\n-        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n-        assert_eq!(converted.len(), expected_lines.len());\n-        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n-            assert_eq!(folding_range.start_line, *start_line);\n-            assert_eq!(folding_range.start_character, None);\n-            assert_eq!(folding_range.end_line, *end_line);\n-            assert_eq!(folding_range.end_character, None);\n-        }\n-    }\n-}"}, {"sha": "4bb16a496c09555739a12cae8af52803332b9576", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -0,0 +1,42 @@\n+//! Conversion lsp_types types to rust-analyzer specific ones.\n+use ra_db::{FileId, FilePosition, FileRange};\n+use ra_ide::{LineCol, LineIndex};\n+use ra_syntax::{TextRange, TextSize};\n+\n+use crate::{world::WorldSnapshot, Result};\n+\n+pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n+    let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n+    line_index.offset(line_col)\n+}\n+\n+pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> TextRange {\n+    let start = offset(line_index, range.start);\n+    let end = offset(line_index, range.end);\n+    TextRange::new(start, end)\n+}\n+\n+pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+    world.uri_to_file_id(url)\n+}\n+\n+pub(crate) fn file_position(\n+    world: &WorldSnapshot,\n+    tdpp: lsp_types::TextDocumentPositionParams,\n+) -> Result<FilePosition> {\n+    let file_id = file_id(world, &tdpp.text_document.uri)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n+    let offset = offset(&*line_index, tdpp.position);\n+    Ok(FilePosition { file_id, offset })\n+}\n+\n+pub(crate) fn file_range(\n+    world: &WorldSnapshot,\n+    text_document_identifier: lsp_types::TextDocumentIdentifier,\n+    range: lsp_types::Range,\n+) -> Result<FileRange> {\n+    let file_id = file_id(world, &text_document_identifier.uri)?;\n+    let line_index = world.analysis().file_line_index(file_id)?;\n+    let range = text_range(&line_index, range);\n+    Ok(FileRange { file_id, range })\n+}"}, {"sha": "57d0e92188e30a44672a8d49bcbcf4068c052e57", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -20,10 +20,11 @@ macro_rules! eprintln {\n mod vfs_glob;\n mod caps;\n mod cargo_target_spec;\n-mod conv;\n+mod to_proto;\n+mod from_proto;\n mod main_loop;\n mod markdown;\n-pub mod req;\n+pub mod lsp_ext;\n pub mod config;\n mod world;\n mod diagnostics;"}, {"sha": "313a8c7697e636becc22df52cc42dae278754597", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "renamed", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -1,25 +1,12 @@\n-//! Defines `rust-analyzer` specific custom messages.\n+//! rust-analyzer extensions to the LSP.\n \n+use std::path::PathBuf;\n+\n+use lsp_types::request::Request;\n use lsp_types::{Location, Position, Range, TextDocumentIdentifier};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n \n-pub use lsp_types::{\n-    notification::*, request::*, ApplyWorkspaceEditParams, CodeActionParams, CodeLens,\n-    CodeLensParams, CompletionParams, CompletionResponse, ConfigurationItem, ConfigurationParams,\n-    DiagnosticTag, DidChangeConfigurationParams, DidChangeWatchedFilesParams,\n-    DidChangeWatchedFilesRegistrationOptions, DocumentHighlightParams,\n-    DocumentOnTypeFormattingParams, DocumentSymbolParams, DocumentSymbolResponse,\n-    FileSystemWatcher, GotoDefinitionParams, GotoDefinitionResponse, Hover, HoverParams,\n-    InitializeResult, MessageType, PartialResultParams, ProgressParams, ProgressParamsValue,\n-    ProgressToken, PublishDiagnosticsParams, ReferenceParams, Registration, RegistrationParams,\n-    SelectionRange, SelectionRangeParams, SemanticTokensParams, SemanticTokensRangeParams,\n-    SemanticTokensRangeResult, SemanticTokensResult, ServerCapabilities, ShowMessageParams,\n-    SignatureHelp, SignatureHelpParams, SymbolKind, TextDocumentEdit, TextDocumentPositionParams,\n-    TextEdit, WorkDoneProgressParams, WorkspaceEdit, WorkspaceSymbolParams,\n-};\n-use std::path::PathBuf;\n-\n pub enum AnalyzerStatus {}\n \n impl Request for AnalyzerStatus {\n@@ -91,7 +78,7 @@ pub struct FindMatchingBraceParams {\n pub enum ParentModule {}\n \n impl Request for ParentModule {\n-    type Params = TextDocumentPositionParams;\n+    type Params = lsp_types::TextDocumentPositionParams;\n     type Result = Vec<Location>;\n     const METHOD: &'static str = \"rust-analyzer/parentModule\";\n }\n@@ -114,7 +101,7 @@ pub struct JoinLinesParams {\n pub enum OnEnter {}\n \n impl Request for OnEnter {\n-    type Params = TextDocumentPositionParams;\n+    type Params = lsp_types::TextDocumentPositionParams;\n     type Result = Option<SourceChange>;\n     const METHOD: &'static str = \"rust-analyzer/onEnter\";\n }\n@@ -150,8 +137,8 @@ pub struct Runnable {\n #[serde(rename_all = \"camelCase\")]\n pub struct SourceChange {\n     pub label: String,\n-    pub workspace_edit: WorkspaceEdit,\n-    pub cursor_position: Option<TextDocumentPositionParams>,\n+    pub workspace_edit: lsp_types::WorkspaceEdit,\n+    pub cursor_position: Option<lsp_types::TextDocumentPositionParams>,\n }\n \n pub enum InlayHints {}", "previous_filename": "crates/rust-analyzer/src/req.rs"}, {"sha": "fa72a9cc64d2353357c812deb091ed998c9a7a95", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 94, "deletions": 82, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -37,13 +37,12 @@ use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher},\n-    conv::{ConvWith, TryConvWith},\n     diagnostics::DiagnosticTask,\n+    from_proto, lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    req,\n     world::{WorldSnapshot, WorldState},\n     Result,\n };\n@@ -104,7 +103,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n \n             if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n-                    req::MessageType::Error,\n+                    lsp_types::MessageType::Error,\n                     format!(\n                         \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n                         ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n@@ -124,7 +123,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                     .map_err(|err| {\n                         log::error!(\"failed to load workspace: {:#}\", err);\n                         show_message(\n-                            req::MessageType::Error,\n+                            lsp_types::MessageType::Error,\n                             format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n                             &connection.sender,\n                         );\n@@ -142,23 +141,25 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             .collect::<std::result::Result<Vec<_>, _>>()?;\n \n         if let FilesWatcher::Client = config.files.watcher {\n-            let registration_options = req::DidChangeWatchedFilesRegistrationOptions {\n+            let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                 watchers: workspaces\n                     .iter()\n                     .flat_map(ProjectWorkspace::to_roots)\n                     .filter(PackageRoot::is_member)\n                     .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n-                    .map(|glob_pattern| req::FileSystemWatcher { glob_pattern, kind: None })\n+                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n                     .collect(),\n             };\n-            let registration = req::Registration {\n+            let registration = lsp_types::Registration {\n                 id: \"file-watcher\".to_string(),\n                 method: \"workspace/didChangeWatchedFiles\".to_string(),\n                 register_options: Some(serde_json::to_value(registration_options).unwrap()),\n             };\n-            let params = req::RegistrationParams { registrations: vec![registration] };\n-            let request =\n-                request_new::<req::RegisterCapability>(loop_state.next_request_id(), params);\n+            let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n+            let request = request_new::<lsp_types::request::RegisterCapability>(\n+                loop_state.next_request_id(),\n+                params,\n+            );\n             connection.sender.send(request.into()).unwrap();\n         }\n \n@@ -258,14 +259,14 @@ impl fmt::Debug for Event {\n \n         match self {\n             Event::Msg(Message::Notification(not)) => {\n-                if notification_is::<req::DidOpenTextDocument>(not)\n-                    || notification_is::<req::DidChangeTextDocument>(not)\n+                if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n+                    || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n                 {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n             Event::Task(Task::Notify(not)) => {\n-                if notification_is::<req::PublishDiagnostics>(not) {\n+                if notification_is::<lsp_types::notification::PublishDiagnostics>(not) {\n                     return debug_verbose_not(not, f);\n                 }\n             }\n@@ -450,7 +451,7 @@ fn loop_turn(\n         log::error!(\"overly long loop turn: {:?}\", loop_duration);\n         if env::var(\"RA_PROFILE\").is_ok() {\n             show_message(\n-                req::MessageType::Error,\n+                lsp_types::MessageType::Error,\n                 format!(\"overly long loop turn: {:?}\", loop_duration),\n                 &connection.sender,\n             );\n@@ -500,45 +501,51 @@ fn on_request(\n         request_received,\n     };\n     pool_dispatcher\n-        .on_sync::<req::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n-        .on_sync::<req::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n-        .on_sync::<req::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n-        .on_sync::<req::SelectionRangeRequest>(|s, p| {\n+        .on_sync::<lsp_ext::CollectGarbage>(|s, ()| Ok(s.collect_garbage()))?\n+        .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n+        .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n+        .on_sync::<lsp_types::request::SelectionRangeRequest>(|s, p| {\n             handlers::handle_selection_range(s.snapshot(), p)\n         })?\n-        .on_sync::<req::FindMatchingBrace>(|s, p| {\n+        .on_sync::<lsp_ext::FindMatchingBrace>(|s, p| {\n             handlers::handle_find_matching_brace(s.snapshot(), p)\n         })?\n-        .on::<req::AnalyzerStatus>(handlers::handle_analyzer_status)?\n-        .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n-        .on::<req::ExpandMacro>(handlers::handle_expand_macro)?\n-        .on::<req::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n-        .on::<req::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n-        .on::<req::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n-        .on::<req::GotoDefinition>(handlers::handle_goto_definition)?\n-        .on::<req::GotoImplementation>(handlers::handle_goto_implementation)?\n-        .on::<req::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n-        .on::<req::ParentModule>(handlers::handle_parent_module)?\n-        .on::<req::Runnables>(handlers::handle_runnables)?\n-        .on::<req::Completion>(handlers::handle_completion)?\n-        .on::<req::CodeActionRequest>(handlers::handle_code_action)?\n-        .on::<req::CodeLensRequest>(handlers::handle_code_lens)?\n-        .on::<req::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n-        .on::<req::FoldingRangeRequest>(handlers::handle_folding_range)?\n-        .on::<req::SignatureHelpRequest>(handlers::handle_signature_help)?\n-        .on::<req::HoverRequest>(handlers::handle_hover)?\n-        .on::<req::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n-        .on::<req::Rename>(handlers::handle_rename)?\n-        .on::<req::References>(handlers::handle_references)?\n-        .on::<req::Formatting>(handlers::handle_formatting)?\n-        .on::<req::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n-        .on::<req::InlayHints>(handlers::handle_inlay_hints)?\n-        .on::<req::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)?\n-        .on::<req::CallHierarchyIncomingCalls>(handlers::handle_call_hierarchy_incoming)?\n-        .on::<req::CallHierarchyOutgoingCalls>(handlers::handle_call_hierarchy_outgoing)?\n-        .on::<req::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n-        .on::<req::SemanticTokensRangeRequest>(handlers::handle_semantic_tokens_range)?\n-        .on::<req::Ssr>(handlers::handle_ssr)?\n+        .on::<lsp_ext::AnalyzerStatus>(handlers::handle_analyzer_status)?\n+        .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)?\n+        .on::<lsp_ext::ExpandMacro>(handlers::handle_expand_macro)?\n+        .on::<lsp_ext::ParentModule>(handlers::handle_parent_module)?\n+        .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n+        .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n+        .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n+        .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n+        .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n+        .on::<lsp_types::request::GotoDefinition>(handlers::handle_goto_definition)?\n+        .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)?\n+        .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)?\n+        .on::<lsp_types::request::Completion>(handlers::handle_completion)?\n+        .on::<lsp_types::request::CodeActionRequest>(handlers::handle_code_action)?\n+        .on::<lsp_types::request::CodeLensRequest>(handlers::handle_code_lens)?\n+        .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n+        .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n+        .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n+        .on::<lsp_types::request::HoverRequest>(handlers::handle_hover)?\n+        .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n+        .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n+        .on::<lsp_types::request::References>(handlers::handle_references)?\n+        .on::<lsp_types::request::Formatting>(handlers::handle_formatting)?\n+        .on::<lsp_types::request::DocumentHighlightRequest>(handlers::handle_document_highlight)?\n+        .on::<lsp_types::request::CallHierarchyPrepare>(handlers::handle_call_hierarchy_prepare)?\n+        .on::<lsp_types::request::CallHierarchyIncomingCalls>(\n+            handlers::handle_call_hierarchy_incoming,\n+        )?\n+        .on::<lsp_types::request::CallHierarchyOutgoingCalls>(\n+            handlers::handle_call_hierarchy_outgoing,\n+        )?\n+        .on::<lsp_types::request::SemanticTokensRequest>(handlers::handle_semantic_tokens)?\n+        .on::<lsp_types::request::SemanticTokensRangeRequest>(\n+            handlers::handle_semantic_tokens_range,\n+        )?\n+        .on::<lsp_ext::Ssr>(handlers::handle_ssr)?\n         .finish();\n     Ok(())\n }\n@@ -549,7 +556,7 @@ fn on_notification(\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n-    let not = match notification_cast::<req::Cancel>(not) {\n+    let not = match notification_cast::<lsp_types::notification::Cancel>(not) {\n         Ok(params) => {\n             let id: RequestId = match params.id {\n                 NumberOrString::Number(id) => id.into(),\n@@ -567,7 +574,7 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidOpenTextDocument>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidOpenTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n@@ -580,11 +587,11 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidChangeTextDocument>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidChangeTextDocument>(not) {\n         Ok(params) => {\n             let DidChangeTextDocumentParams { text_document, content_changes } = params;\n             let world = state.snapshot();\n-            let file_id = text_document.try_conv_with(&world)?;\n+            let file_id = from_proto::file_id(&world, &text_document.uri)?;\n             let line_index = world.analysis().file_line_index(file_id)?;\n             let uri = text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n@@ -595,7 +602,7 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidSaveTextDocument>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidSaveTextDocument>(not) {\n         Ok(_params) => {\n             if let Some(flycheck) = &state.flycheck {\n                 flycheck.update();\n@@ -604,30 +611,30 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidCloseTextDocument>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidCloseTextDocument>(not) {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n             let path = uri.to_file_path().map_err(|()| format!(\"invalid uri: {}\", uri))?;\n             if let Some(file_id) = state.vfs.write().remove_file_overlay(path.as_path()) {\n                 loop_state.subscriptions.remove_sub(FileId(file_id.0));\n             }\n             let params =\n-                req::PublishDiagnosticsParams { uri, diagnostics: Vec::new(), version: None };\n-            let not = notification_new::<req::PublishDiagnostics>(params);\n+                lsp_types::PublishDiagnosticsParams { uri, diagnostics: Vec::new(), version: None };\n+            let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n             msg_sender.send(not.into()).unwrap();\n             return Ok(());\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidChangeConfiguration>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidChangeConfiguration>(not) {\n         Ok(_) => {\n             // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n             // this notification's parameters should be ignored and the actual config queried separately.\n             let request_id = loop_state.next_request_id();\n-            let request = request_new::<req::WorkspaceConfiguration>(\n+            let request = request_new::<lsp_types::request::WorkspaceConfiguration>(\n                 request_id.clone(),\n-                req::ConfigurationParams {\n-                    items: vec![req::ConfigurationItem {\n+                lsp_types::ConfigurationParams {\n+                    items: vec![lsp_types::ConfigurationItem {\n                         scope_uri: None,\n                         section: Some(\"rust-analyzer\".to_string()),\n                     }],\n@@ -640,7 +647,7 @@ fn on_notification(\n         }\n         Err(not) => not,\n     };\n-    let not = match notification_cast::<req::DidChangeWatchedFiles>(not) {\n+    let not = match notification_cast::<lsp_types::notification::DidChangeWatchedFiles>(not) {\n         Ok(params) => {\n             let mut vfs = state.vfs.write();\n             for change in params.changes {\n@@ -694,7 +701,7 @@ fn apply_document_changes(\n                     line_index = Cow::Owned(LineIndex::new(&old_text));\n                 }\n                 index_valid = IndexValid::UpToLineExclusive(range.start.line);\n-                let range = range.conv_with(&line_index);\n+                let range = from_proto::text_range(&line_index, range);\n                 let mut text = old_text.to_owned();\n                 match std::panic::catch_unwind(move || {\n                     text.replace_range(Range::<usize>::from(range), &change.text);\n@@ -742,11 +749,11 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(progress) => {\n-            let params = req::ProgressParams {\n-                token: req::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n-                value: req::ProgressParamsValue::WorkDone(progress),\n+            let params = lsp_types::ProgressParams {\n+                token: lsp_types::ProgressToken::String(\"rustAnalyzer/cargoWatcher\".to_string()),\n+                value: lsp_types::ProgressParamsValue::WorkDone(progress),\n             };\n-            let not = notification_new::<req::Progress>(params);\n+            let not = notification_new::<lsp_types::notification::Progress>(params);\n             task_sender.send(Task::Notify(not)).unwrap();\n         }\n     };\n@@ -768,8 +775,8 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n         };\n \n         let diagnostics = state.diagnostics.diagnostics_for(file_id).cloned().collect();\n-        let params = req::PublishDiagnosticsParams { uri, diagnostics, version: None };\n-        let not = notification_new::<req::PublishDiagnostics>(params);\n+        let params = lsp_types::PublishDiagnosticsParams { uri, diagnostics, version: None };\n+        let not = notification_new::<lsp_types::notification::PublishDiagnostics>(params);\n         msg_sender.send(not.into()).unwrap();\n     }\n }\n@@ -782,10 +789,10 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n \n     match (prev, loop_state.workspace_loaded) {\n         (None, false) => {\n-            let work_done_progress_create = request_new::<req::WorkDoneProgressCreate>(\n+            let work_done_progress_create = request_new::<lsp_types::request::WorkDoneProgressCreate>(\n                 loop_state.next_request_id(),\n                 WorkDoneProgressCreateParams {\n-                    token: req::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n+                    token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n                 },\n             );\n             sender.send(work_done_progress_create.into()).unwrap();\n@@ -817,10 +824,11 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n     }\n \n     fn send_startup_progress_notif(sender: &Sender<Message>, work_done_progress: WorkDoneProgress) {\n-        let notif = notification_new::<req::Progress>(req::ProgressParams {\n-            token: req::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n-            value: req::ProgressParamsValue::WorkDone(work_done_progress),\n-        });\n+        let notif =\n+            notification_new::<lsp_types::notification::Progress>(lsp_types::ProgressParams {\n+                token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n+                value: lsp_types::ProgressParamsValue::WorkDone(work_done_progress),\n+            });\n         sender.send(notif.into()).unwrap();\n     }\n }\n@@ -842,7 +850,7 @@ impl<'a> PoolDispatcher<'a> {\n         f: fn(&mut WorldState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n     where\n-        R: req::Request + 'static,\n+        R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + panic::UnwindSafe + 'static,\n         R::Result: Serialize + 'static,\n     {\n@@ -865,7 +873,7 @@ impl<'a> PoolDispatcher<'a> {\n     /// Dispatches the request onto thread pool\n     fn on<R>(&mut self, f: fn(WorldSnapshot, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n     where\n-        R: req::Request + 'static,\n+        R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n         R::Result: Serialize + 'static,\n     {\n@@ -891,7 +899,7 @@ impl<'a> PoolDispatcher<'a> {\n \n     fn parse<R>(&mut self) -> Option<(RequestId, R::Params)>\n     where\n-        R: req::Request + 'static,\n+        R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + 'static,\n     {\n         let req = self.req.take()?;\n@@ -928,7 +936,7 @@ impl<'a> PoolDispatcher<'a> {\n \n fn result_to_task<R>(id: RequestId, result: Result<R::Result>) -> Task\n where\n-    R: req::Request + 'static,\n+    R: lsp_types::request::Request + 'static,\n     R::Params: DeserializeOwned + 'static,\n     R::Result: Serialize + 'static,\n {\n@@ -984,10 +992,14 @@ fn update_file_notifications_on_threadpool(\n     }\n }\n \n-pub fn show_message(typ: req::MessageType, message: impl Into<String>, sender: &Sender<Message>) {\n+pub fn show_message(\n+    typ: lsp_types::MessageType,\n+    message: impl Into<String>,\n+    sender: &Sender<Message>,\n+) {\n     let message = message.into();\n-    let params = req::ShowMessageParams { typ, message };\n-    let not = notification_new::<req::ShowMessage>(params);\n+    let params = lsp_types::ShowMessageParams { typ, message };\n+    let not = notification_new::<lsp_types::notification::ShowMessage>(params);\n     sender.send(not.into()).unwrap();\n }\n "}, {"sha": "be8688bc3953f0a309805176446efe39c9043231", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 240, "deletions": 279, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -22,6 +22,7 @@ use ra_ide::{\n     Assist, FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n };\n use ra_prof::profile;\n+use ra_project_model::TargetKind;\n use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n@@ -31,18 +32,13 @@ use stdx::format_to;\n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n-    conv::{\n-        to_call_hierarchy_item, to_location, Conv, ConvWith, FoldConvCtx, MapConvWith, TryConvWith,\n-        TryConvWithToVec,\n-    },\n     diagnostics::DiagnosticTask,\n-    from_json,\n-    req::{self, InlayHint, InlayHintsParams},\n-    semantic_tokens::SemanticTokensBuilder,\n+    from_json, from_proto,\n+    lsp_ext::{self, InlayHint, InlayHintsParams},\n+    to_proto,\n     world::WorldSnapshot,\n     LspError, Result,\n };\n-use ra_project_model::TargetKind;\n \n pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n@@ -56,48 +52,51 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n     Ok(buf)\n }\n \n-pub fn handle_syntax_tree(world: WorldSnapshot, params: req::SyntaxTreeParams) -> Result<String> {\n+pub fn handle_syntax_tree(\n+    world: WorldSnapshot,\n+    params: lsp_ext::SyntaxTreeParams,\n+) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = params.text_document.try_conv_with(&world)?;\n+    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(id)?;\n-    let text_range = params.range.map(|p| p.conv_with(&line_index));\n+    let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n     let res = world.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n pub fn handle_expand_macro(\n     world: WorldSnapshot,\n-    params: req::ExpandMacroParams,\n-) -> Result<Option<req::ExpandedMacro>> {\n+    params: lsp_ext::ExpandMacroParams,\n+) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|p| p.conv_with(&line_index));\n+    let offset = params.position.map(|p| from_proto::offset(&line_index, p));\n \n     match offset {\n         None => Ok(None),\n         Some(offset) => {\n             let res = world.analysis().expand_macro(FilePosition { file_id, offset })?;\n-            Ok(res.map(|it| req::ExpandedMacro { name: it.name, expansion: it.expansion }))\n+            Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n         }\n     }\n }\n \n pub fn handle_selection_range(\n     world: WorldSnapshot,\n-    params: req::SelectionRangeParams,\n-) -> Result<Option<Vec<req::SelectionRange>>> {\n+    params: lsp_types::SelectionRangeParams,\n+) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let res: Result<Vec<req::SelectionRange>> = params\n+    let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n-        .map_conv_with(&line_index)\n         .map(|position| {\n+            let offset = from_proto::offset(&line_index, position);\n             let mut ranges = Vec::new();\n             {\n-                let mut range = TextRange::new(position, position);\n+                let mut range = TextRange::new(offset, offset);\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n@@ -109,13 +108,13 @@ pub fn handle_selection_range(\n                     }\n                 }\n             }\n-            let mut range = req::SelectionRange {\n-                range: ranges.last().unwrap().conv_with(&line_index),\n+            let mut range = lsp_types::SelectionRange {\n+                range: to_proto::range(&line_index, *ranges.last().unwrap()),\n                 parent: None,\n             };\n-            for r in ranges.iter().rev().skip(1) {\n-                range = req::SelectionRange {\n-                    range: r.conv_with(&line_index),\n+            for &r in ranges.iter().rev().skip(1) {\n+                range = lsp_types::SelectionRange {\n+                    range: to_proto::range(&line_index, r),\n                     parent: Some(Box::new(range)),\n                 }\n             }\n@@ -128,57 +127,55 @@ pub fn handle_selection_range(\n \n pub fn handle_find_matching_brace(\n     world: WorldSnapshot,\n-    params: req::FindMatchingBraceParams,\n+    params: lsp_ext::FindMatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_find_matching_brace\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n     let res = params\n         .offsets\n         .into_iter()\n-        .map_conv_with(&line_index)\n-        .map(|offset| {\n-            if let Ok(Some(matching_brace_offset)) =\n-                world.analysis().matching_brace(FilePosition { file_id, offset })\n-            {\n-                matching_brace_offset\n-            } else {\n-                offset\n-            }\n+        .map(|position| {\n+            let offset = from_proto::offset(&line_index, position);\n+            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+                Ok(Some(matching_brace_offset)) => matching_brace_offset,\n+                Err(_) | Ok(None) => offset,\n+            };\n+            to_proto::position(&line_index, offset)\n         })\n-        .map_conv_with(&line_index)\n         .collect();\n     Ok(res)\n }\n \n pub fn handle_join_lines(\n     world: WorldSnapshot,\n-    params: req::JoinLinesParams,\n-) -> Result<req::SourceChange> {\n+    params: lsp_ext::JoinLinesParams,\n+) -> Result<lsp_ext::SourceChange> {\n     let _p = profile(\"handle_join_lines\");\n-    let frange = (&params.text_document, params.range).try_conv_with(&world)?;\n-    world.analysis().join_lines(frange)?.try_conv_with(&world)\n+    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n+    let source_change = world.analysis().join_lines(frange)?;\n+    to_proto::source_change(&world, source_change)\n }\n \n pub fn handle_on_enter(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n-) -> Result<Option<req::SourceChange>> {\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<Option<lsp_ext::SourceChange>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params)?;\n     match world.analysis().on_enter(position)? {\n         None => Ok(None),\n-        Some(edit) => Ok(Some(edit.try_conv_with(&world)?)),\n+        Some(source_change) => to_proto::source_change(&world, source_change).map(Some),\n     }\n }\n \n // Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n     world: WorldSnapshot,\n-    params: req::DocumentOnTypeFormattingParams,\n+    params: lsp_types::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = params.text_document_position.try_conv_with(&world)?;\n+    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n \n@@ -208,29 +205,28 @@ pub fn handle_on_type_formatting(\n     // This should be a single-file edit\n     let edit = edit.source_file_edits.pop().unwrap();\n \n-    let change: Vec<TextEdit> = edit.edit.conv_with((&line_index, line_endings));\n+    let change = to_proto::text_edit_vec(&line_index, line_endings, edit.edit);\n     Ok(Some(change))\n }\n \n pub fn handle_document_symbol(\n     world: WorldSnapshot,\n-    params: req::DocumentSymbolParams,\n-) -> Result<Option<req::DocumentSymbolResponse>> {\n+    params: lsp_types::DocumentSymbolParams,\n+) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let url = file_id.try_conv_with(&world)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n     for symbol in world.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n-            kind: symbol.kind.conv(),\n+            kind: to_proto::symbol_kind(symbol.kind),\n             deprecated: Some(symbol.deprecated),\n-            range: symbol.node_range.conv_with(&line_index),\n-            selection_range: symbol.navigation_range.conv_with(&line_index),\n+            range: to_proto::range(&line_index, symbol.node_range),\n+            selection_range: to_proto::range(&line_index, symbol.navigation_range),\n             children: None,\n         };\n         parents.push((doc_symbol, symbol.parent));\n@@ -249,40 +245,41 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    if world.config.client_caps.hierarchical_symbols {\n-        Ok(Some(document_symbols.into()))\n+    let res = if world.config.client_caps.hierarchical_symbols {\n+        document_symbols.into()\n     } else {\n+        let url = to_proto::url(&world, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n         }\n+        symbol_information.into()\n+    };\n+    return Ok(Some(res));\n \n-        Ok(Some(symbol_information.into()))\n-    }\n-}\n-\n-fn flatten_document_symbol(\n-    symbol: &DocumentSymbol,\n-    container_name: Option<String>,\n-    url: &Url,\n-    res: &mut Vec<SymbolInformation>,\n-) {\n-    res.push(SymbolInformation {\n-        name: symbol.name.clone(),\n-        kind: symbol.kind,\n-        deprecated: symbol.deprecated,\n-        location: Location::new(url.clone(), symbol.range),\n-        container_name: container_name,\n-    });\n+    fn flatten_document_symbol(\n+        symbol: &DocumentSymbol,\n+        container_name: Option<String>,\n+        url: &Url,\n+        res: &mut Vec<SymbolInformation>,\n+    ) {\n+        res.push(SymbolInformation {\n+            name: symbol.name.clone(),\n+            kind: symbol.kind,\n+            deprecated: symbol.deprecated,\n+            location: Location::new(url.clone(), symbol.range),\n+            container_name: container_name,\n+        });\n \n-    for child in symbol.children.iter().flatten() {\n-        flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n+        for child in symbol.children.iter().flatten() {\n+            flatten_document_symbol(child, Some(symbol.name.clone()), url, res);\n+        }\n     }\n }\n \n pub fn handle_workspace_symbol(\n     world: WorldSnapshot,\n-    params: req::WorkspaceSymbolParams,\n+    params: lsp_types::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let _p = profile(\"handle_workspace_symbol\");\n     let all_symbols = params.query.contains('#');\n@@ -313,8 +310,8 @@ pub fn handle_workspace_symbol(\n         for nav in world.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n-                kind: nav.kind().conv(),\n-                location: nav.try_conv_with(world)?,\n+                kind: to_proto::symbol_kind(nav.kind()),\n+                location: to_proto::location(world, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -326,63 +323,80 @@ pub fn handle_workspace_symbol(\n \n pub fn handle_goto_definition(\n     world: WorldSnapshot,\n-    params: req::GotoDefinitionParams,\n-) -> Result<Option<req::GotoDefinitionResponse>> {\n+    params: lsp_types::GotoDefinitionParams,\n+) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_implementation(\n     world: WorldSnapshot,\n-    params: req::GotoImplementationParams,\n-) -> Result<Option<req::GotoImplementationResponse>> {\n+    params: lsp_types::request::GotoImplementationParams,\n+) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_type_definition(\n     world: WorldSnapshot,\n-    params: req::GotoTypeDefinitionParams,\n-) -> Result<Option<req::GotoTypeDefinitionResponse>> {\n+    params: lsp_types::request::GotoTypeDefinitionParams,\n+) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let nav_info = match world.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let res = (position.file_id, nav_info).try_conv_with(&world)?;\n+    let res = to_proto::goto_definition_response(\n+        &world,\n+        FileRange { file_id: position.file_id, range: nav_info.range },\n+        nav_info.info,\n+    )?;\n     Ok(Some(res))\n }\n \n pub fn handle_parent_module(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = params.try_conv_with(&world)?;\n-    world.analysis().parent_module(position)?.iter().try_conv_with_to_vec(&world)\n+    let position = from_proto::file_position(&world, params)?;\n+    world\n+        .analysis()\n+        .parent_module(position)?\n+        .into_iter()\n+        .map(|it| to_proto::location(&world, it.file_range()))\n+        .collect::<Result<Vec<_>>>()\n }\n \n pub fn handle_runnables(\n     world: WorldSnapshot,\n-    params: req::RunnablesParams,\n-) -> Result<Vec<req::Runnable>> {\n+    params: lsp_ext::RunnablesParams,\n+) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|it| it.conv_with(&line_index));\n+    let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n     let workspace_root = world.workspace_root_for(file_id);\n     let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n@@ -408,7 +422,7 @@ pub fn handle_runnables(\n     match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n-                res.push(req::Runnable {\n+                res.push(lsp_ext::Runnable {\n                     range: Default::default(),\n                     label: format!(\"cargo {} -p {}\", cmd, spec.package),\n                     bin: \"cargo\".to_string(),\n@@ -420,7 +434,7 @@ pub fn handle_runnables(\n             }\n         }\n         None => {\n-            res.push(req::Runnable {\n+            res.push(lsp_ext::Runnable {\n                 range: Default::default(),\n                 label: \"cargo check --workspace\".to_string(),\n                 bin: \"cargo\".to_string(),\n@@ -436,10 +450,10 @@ pub fn handle_runnables(\n \n pub fn handle_completion(\n     world: WorldSnapshot,\n-    params: req::CompletionParams,\n-) -> Result<Option<req::CompletionResponse>> {\n+    params: lsp_types::CompletionParams,\n+) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n@@ -468,8 +482,10 @@ pub fn handle_completion(\n     };\n     let line_index = world.analysis().file_line_index(position.file_id)?;\n     let line_endings = world.file_line_endings(position.file_id);\n-    let items: Vec<CompletionItem> =\n-        items.into_iter().map(|item| item.conv_with((&line_index, line_endings))).collect();\n+    let items: Vec<CompletionItem> = items\n+        .into_iter()\n+        .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n+        .collect();\n \n     Ok(Some(items.into()))\n }\n@@ -479,52 +495,51 @@ pub fn handle_folding_range(\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let folds = world.analysis().folding_ranges(file_id)?;\n     let text = world.analysis().file_text(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let ctx = FoldConvCtx {\n-        text: &text,\n-        line_index: &line_index,\n-        line_folding_only: world.config.client_caps.line_folding_only,\n-    };\n-    let res = Some(folds.into_iter().map_conv_with(&ctx).collect());\n-    Ok(res)\n+    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let res = folds\n+        .into_iter()\n+        .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n+        .collect();\n+    Ok(Some(res))\n }\n \n pub fn handle_signature_help(\n     world: WorldSnapshot,\n-    params: req::SignatureHelpParams,\n-) -> Result<Option<req::SignatureHelp>> {\n+    params: lsp_types::SignatureHelpParams,\n+) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n-    if let Some(call_info) = world.analysis().call_info(position)? {\n-        let concise = !world.config.call_info_full;\n-        let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n-        if concise && call_info.signature.has_self_param {\n-            active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n-        }\n-        let sig_info = call_info.signature.conv_with(concise);\n-\n-        Ok(Some(req::SignatureHelp {\n-            signatures: vec![sig_info],\n-            active_signature: Some(0),\n-            active_parameter,\n-        }))\n-    } else {\n-        Ok(None)\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let call_info = match world.analysis().call_info(position)? {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let concise = !world.config.call_info_full;\n+    let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n+    if concise && call_info.signature.has_self_param {\n+        active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n     }\n+    let sig_info = to_proto::signature_information(call_info.signature, concise);\n+\n+    Ok(Some(lsp_types::SignatureHelp {\n+        signatures: vec![sig_info],\n+        active_signature: Some(0),\n+        active_parameter,\n+    }))\n }\n \n-pub fn handle_hover(world: WorldSnapshot, params: req::HoverParams) -> Result<Option<Hover>> {\n+pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Result<Option<Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n     let info = match world.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n     let line_index = world.analysis.file_line_index(position.file_id)?;\n-    let range = info.range.conv_with(&line_index);\n+    let range = to_proto::range(&line_index, info.range);\n     let res = Hover {\n         contents: HoverContents::Markup(MarkupContent {\n             kind: MarkupKind::Markdown,\n@@ -537,26 +552,25 @@ pub fn handle_hover(world: WorldSnapshot, params: req::HoverParams) -> Result<Op\n \n pub fn handle_prepare_rename(\n     world: WorldSnapshot,\n-    params: req::TextDocumentPositionParams,\n+    params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = params.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params)?;\n \n     let optional_change = world.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let range = range.conv_with(&line_index);\n+    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -567,22 +581,21 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n     }\n \n     let optional_change = world.analysis().rename(position, &*params.new_name)?;\n-    let change = match optional_change {\n+    let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n \n-    let source_change_req = change.try_conv_with(&world)?;\n-\n-    Ok(Some(source_change_req.workspace_edit))\n+    let source_change = to_proto::source_change(&world, source_change)?;\n+    Ok(Some(source_change.workspace_edit))\n }\n \n pub fn handle_references(\n     world: WorldSnapshot,\n-    params: req::ReferenceParams,\n+    params: lsp_types::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = params.text_document_position.try_conv_with(&world)?;\n+    let position = from_proto::file_position(&world, params.text_document_position)?;\n \n     let refs = match world.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n@@ -591,33 +604,13 @@ pub fn handle_references(\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| {\n-                let line_index =\n-                    world.analysis().file_line_index(reference.file_range.file_id).ok()?;\n-                to_location(\n-                    reference.file_range.file_id,\n-                    reference.file_range.range,\n-                    &world,\n-                    &line_index,\n-                )\n-                .ok()\n-            })\n+            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| {\n-                let line_index =\n-                    world.analysis().file_line_index(reference.file_range.file_id).ok()?;\n-                to_location(\n-                    reference.file_range.file_id,\n-                    reference.file_range.range,\n-                    &world,\n-                    &line_index,\n-                )\n-                .ok()\n-            })\n+            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n             .collect()\n     };\n \n@@ -629,12 +622,12 @@ pub fn handle_formatting(\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let file = world.analysis().file_text(file_id)?;\n     let crate_ids = world.analysis().crate_for(file_id)?;\n \n     let file_line_index = world.analysis().file_line_index(file_id)?;\n-    let end_position = TextSize::of(file.as_str()).conv_with(&file_line_index);\n+    let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n     let mut rustfmt = match &world.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n@@ -700,33 +693,14 @@ pub fn handle_formatting(\n     }]))\n }\n \n-fn create_single_code_action(assist: Assist, world: &WorldSnapshot) -> Result<CodeAction> {\n-    let arg = to_value(assist.source_change.try_conv_with(world)?)?;\n-    let title = assist.label;\n-    let command = Command {\n-        title: title.clone(),\n-        command: \"rust-analyzer.applySourceChange\".to_string(),\n-        arguments: Some(vec![arg]),\n-    };\n-\n-    Ok(CodeAction {\n-        title,\n-        kind: Some(String::new()),\n-        diagnostics: None,\n-        edit: None,\n-        command: Some(command),\n-        is_preferred: None,\n-    })\n-}\n-\n pub fn handle_code_action(\n     world: WorldSnapshot,\n-    params: req::CodeActionParams,\n+    params: lsp_types::CodeActionParams,\n ) -> Result<Option<CodeActionResponse>> {\n     let _p = profile(\"handle_code_action\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n-    let range = params.range.conv_with(&line_index);\n+    let range = from_proto::text_range(&line_index, params.range);\n \n     let diagnostics = world.analysis().diagnostics(file_id)?;\n     let mut res = CodeActionResponse::default();\n@@ -739,7 +713,7 @@ pub fn handle_code_action(\n \n     for source_edit in fixes_from_diagnostics {\n         let title = source_edit.label.clone();\n-        let edit = source_edit.try_conv_with(&world)?;\n+        let edit = to_proto::source_change(&world, source_edit)?;\n \n         let command = Command {\n             title,\n@@ -758,7 +732,7 @@ pub fn handle_code_action(\n     }\n \n     for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n-        let fix_range = fix.range.conv_with(&line_index);\n+        let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n         }\n@@ -779,21 +753,21 @@ pub fn handle_code_action(\n                 .1\n                 .push(assist),\n             None => {\n-                res.push(create_single_code_action(assist, &world)?.into());\n+                res.push(to_proto::code_action(&world, assist)?.into());\n             }\n         }\n     }\n \n     for (group_label, (idx, assists)) in grouped_assists {\n         if assists.len() == 1 {\n-            res[idx] =\n-                create_single_code_action(assists.into_iter().next().unwrap(), &world)?.into();\n+            res[idx] = to_proto::code_action(&world, assists.into_iter().next().unwrap())?.into();\n         } else {\n             let title = group_label;\n \n             let mut arguments = Vec::with_capacity(assists.len());\n             for assist in assists {\n-                arguments.push(to_value(assist.source_change.try_conv_with(&world)?)?);\n+                let source_change = to_proto::source_change(&world, assist.source_change)?;\n+                arguments.push(to_value(source_change)?);\n             }\n \n             let command = Some(Command {\n@@ -835,10 +809,10 @@ pub fn handle_code_action(\n \n pub fn handle_code_lens(\n     world: WorldSnapshot,\n-    params: req::CodeLensParams,\n+    params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n     let mut lenses: Vec<CodeLens> = Default::default();\n@@ -902,10 +876,10 @@ pub fn handle_code_lens(\n                 _ => false,\n             })\n             .map(|it| {\n-                let range = it.node_range.conv_with(&line_index);\n+                let range = to_proto::range(&line_index, it.node_range);\n                 let pos = range.start;\n-                let lens_params = req::GotoImplementationParams {\n-                    text_document_position_params: req::TextDocumentPositionParams::new(\n+                let lens_params = lsp_types::request::GotoImplementationParams {\n+                    text_document_position_params: lsp_types::TextDocumentPositionParams::new(\n                         params.text_document.clone(),\n                         pos,\n                     ),\n@@ -926,7 +900,7 @@ pub fn handle_code_lens(\n #[derive(Debug, Serialize, Deserialize)]\n #[serde(rename_all = \"camelCase\")]\n enum CodeLensResolveData {\n-    Impls(req::GotoImplementationParams),\n+    Impls(lsp_types::request::GotoImplementationParams),\n }\n \n pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n@@ -937,9 +911,9 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n         Some(CodeLensResolveData::Impls(lens_params)) => {\n             let locations: Vec<Location> =\n                 match handle_goto_implementation(world, lens_params.clone())? {\n-                    Some(req::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n-                    Some(req::GotoDefinitionResponse::Array(locs)) => locs,\n-                    Some(req::GotoDefinitionResponse::Link(links)) => links\n+                    Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n+                    Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n+                    Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n                         .into_iter()\n                         .map(|link| Location::new(link.target_uri, link.target_selection_range))\n                         .collect(),\n@@ -976,37 +950,39 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n \n pub fn handle_document_highlight(\n     world: WorldSnapshot,\n-    params: req::DocumentHighlightParams,\n+    params: lsp_types::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let file_id = params.text_document_position_params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let line_index = world.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world.analysis().find_all_refs(\n-        params.text_document_position_params.try_conv_with(&world)?,\n-        Some(SearchScope::single_file(file_id)),\n-    )? {\n+    let refs = match world\n+        .analysis()\n+        .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n+    {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n-    Ok(Some(\n-        refs.into_iter()\n-            .filter(|reference| reference.file_range.file_id == file_id)\n-            .map(|reference| DocumentHighlight {\n-                range: reference.file_range.range.conv_with(&line_index),\n-                kind: reference.access.map(|it| it.conv()),\n-            })\n-            .collect(),\n-    ))\n+    let res = refs\n+        .into_iter()\n+        .filter(|reference| reference.file_range.file_id == position.file_id)\n+        .map(|reference| DocumentHighlight {\n+            range: to_proto::range(&line_index, reference.file_range.range),\n+            kind: reference.access.map(to_proto::document_highlight_kind),\n+        })\n+        .collect();\n+    Ok(Some(res))\n }\n \n-pub fn handle_ssr(world: WorldSnapshot, params: req::SsrParams) -> Result<req::SourceChange> {\n+pub fn handle_ssr(\n+    world: WorldSnapshot,\n+    params: lsp_ext::SsrParams,\n+) -> Result<lsp_ext::SourceChange> {\n     let _p = profile(\"handle_ssr\");\n-    world\n-        .analysis()\n-        .structural_search_replace(&params.query, params.parse_only)??\n-        .try_conv_with(&world)\n+    let source_change =\n+        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::source_change(&world, source_change)\n }\n \n pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n@@ -1017,8 +993,8 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n         .diagnostics(file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n-            range: d.range.conv_with(&line_index),\n-            severity: Some(d.severity.conv()),\n+            range: to_proto::range(&line_index, d.range),\n+            severity: Some(to_proto::diagnostic_severity(d.severity)),\n             code: None,\n             source: Some(\"rust-analyzer\".to_string()),\n             message: d.message,\n@@ -1033,7 +1009,7 @@ fn to_lsp_runnable(\n     world: &WorldSnapshot,\n     file_id: FileId,\n     runnable: Runnable,\n-) -> Result<req::Runnable> {\n+) -> Result<lsp_ext::Runnable> {\n     let spec = CargoTargetSpec::for_file(world, file_id)?;\n     let (args, extra_args) = CargoTargetSpec::runnable_args(spec, &runnable.kind)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n@@ -1044,8 +1020,8 @@ fn to_lsp_runnable(\n         RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n         RunnableKind::Bin => \"run binary\".to_string(),\n     };\n-    Ok(req::Runnable {\n-        range: runnable.range.conv_with(&line_index),\n+    Ok(lsp_ext::Runnable {\n+        range: to_proto::range(&line_index, runnable.range),\n         label,\n         bin: \"cargo\".to_string(),\n         args,\n@@ -1064,13 +1040,13 @@ pub fn handle_inlay_hints(\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let analysis = world.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n         .inlay_hints(file_id, &world.config.inlay_hints)?\n         .into_iter()\n-        .map_conv_with(&line_index)\n+        .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n@@ -1079,21 +1055,19 @@ pub fn handle_call_hierarchy_prepare(\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = params.text_document_position_params.try_conv_with(&world)?;\n-    let file_id = position.file_id;\n+    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n \n     let nav_info = match world.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n \n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let RangeInfo { range, info: navs } = nav_info;\n+    let RangeInfo { range: _, info: navs } = nav_info;\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .filter_map(|it| to_call_hierarchy_item(file_id, range, &world, &line_index, it).ok())\n-        .collect();\n+        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n@@ -1106,7 +1080,7 @@ pub fn handle_call_hierarchy_incoming(\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange: FileRange = (&doc, item.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let call_items = match world.analysis().incoming_calls(fpos)? {\n@@ -1119,11 +1093,14 @@ pub fn handle_call_hierarchy_incoming(\n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n         let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = call_item.target.range();\n-        let item = to_call_hierarchy_item(file_id, range, &world, &line_index, call_item.target)?;\n+        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n-            from_ranges: call_item.ranges.iter().map(|it| it.conv_with(&line_index)).collect(),\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n         });\n     }\n \n@@ -1138,7 +1115,7 @@ pub fn handle_call_hierarchy_outgoing(\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange: FileRange = (&doc, item.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let call_items = match world.analysis().outgoing_calls(fpos)? {\n@@ -1151,11 +1128,14 @@ pub fn handle_call_hierarchy_outgoing(\n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n         let line_index = world.analysis().file_line_index(file_id)?;\n-        let range = call_item.target.range();\n-        let item = to_call_hierarchy_item(file_id, range, &world, &line_index, call_item.target)?;\n+        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n-            from_ranges: call_item.ranges.iter().map(|it| it.conv_with(&line_index)).collect(),\n+            from_ranges: call_item\n+                .ranges\n+                .into_iter()\n+                .map(|it| to_proto::range(&line_index, it))\n+                .collect(),\n         });\n     }\n \n@@ -1168,26 +1148,13 @@ pub fn handle_semantic_tokens(\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n     let text = world.analysis().file_text(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id)?;\n \n-    let mut builder = SemanticTokensBuilder::default();\n-\n-    for highlight_range in world.analysis().highlight(file_id)?.into_iter() {\n-        let (token_index, modifier_bitset) = highlight_range.highlight.conv();\n-        for mut range in line_index.lines(highlight_range.range) {\n-            if text[range].ends_with('\\n') {\n-                range = TextRange::new(range.start(), range.end() - TextSize::of('\\n'));\n-            }\n-            let range = range.conv_with(&line_index);\n-            builder.push(range, token_index, modifier_bitset);\n-        }\n-    }\n-\n-    let tokens = builder.build();\n-\n-    Ok(Some(tokens.into()))\n+    let highlights = world.analysis().highlight(file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n+    Ok(Some(semantic_tokens.into()))\n }\n \n pub fn handle_semantic_tokens_range(\n@@ -1196,17 +1163,11 @@ pub fn handle_semantic_tokens_range(\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = (&params.text_document, params.range).try_conv_with(&world)?;\n+    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n+    let text = world.analysis().file_text(frange.file_id)?;\n     let line_index = world.analysis().file_line_index(frange.file_id)?;\n \n-    let mut builder = SemanticTokensBuilder::default();\n-\n-    for highlight_range in world.analysis().highlight_range(frange)?.into_iter() {\n-        let (token_type, token_modifiers) = highlight_range.highlight.conv();\n-        builder.push(highlight_range.range.conv_with(&line_index), token_type, token_modifiers);\n-    }\n-\n-    let tokens = builder.build();\n-\n-    Ok(Some(tokens.into()))\n+    let highlights = world.analysis().highlight_range(frange)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n+    Ok(Some(semantic_tokens.into()))\n }"}, {"sha": "4500d49827e3dd04bb9d7e1d4123c20de1b7b7cc", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -0,0 +1,592 @@\n+//! Conversion of rust-analyzer specific types to lsp_types equivalents.\n+use ra_db::{FileId, FileRange};\n+use ra_ide::{\n+    translate_offset_with_edit, Assist, CompletionItem, CompletionItemKind, Documentation,\n+    FileSystemEdit, Fold, FoldKind, FunctionSignature, Highlight, HighlightModifier, HighlightTag,\n+    HighlightedRange, InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget,\n+    ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n+};\n+use ra_syntax::{SyntaxKind, TextRange, TextSize};\n+use ra_text_edit::{Indel, TextEdit};\n+use ra_vfs::LineEndings;\n+\n+use crate::{lsp_ext, semantic_tokens, world::WorldSnapshot, Result};\n+\n+pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n+    let line_col = line_index.line_col(offset);\n+    let line = u64::from(line_col.line);\n+    let character = u64::from(line_col.col_utf16);\n+    lsp_types::Position::new(line, character)\n+}\n+\n+pub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {\n+    let start = position(line_index, range.start());\n+    let end = position(line_index, range.end());\n+    lsp_types::Range::new(start, end)\n+}\n+\n+pub(crate) fn symbol_kind(syntax_kind: SyntaxKind) -> lsp_types::SymbolKind {\n+    match syntax_kind {\n+        SyntaxKind::FN_DEF => lsp_types::SymbolKind::Function,\n+        SyntaxKind::STRUCT_DEF => lsp_types::SymbolKind::Struct,\n+        SyntaxKind::ENUM_DEF => lsp_types::SymbolKind::Enum,\n+        SyntaxKind::ENUM_VARIANT => lsp_types::SymbolKind::EnumMember,\n+        SyntaxKind::TRAIT_DEF => lsp_types::SymbolKind::Interface,\n+        SyntaxKind::MACRO_CALL => lsp_types::SymbolKind::Function,\n+        SyntaxKind::MODULE => lsp_types::SymbolKind::Module,\n+        SyntaxKind::TYPE_ALIAS_DEF => lsp_types::SymbolKind::TypeParameter,\n+        SyntaxKind::RECORD_FIELD_DEF => lsp_types::SymbolKind::Field,\n+        SyntaxKind::STATIC_DEF => lsp_types::SymbolKind::Constant,\n+        SyntaxKind::CONST_DEF => lsp_types::SymbolKind::Constant,\n+        SyntaxKind::IMPL_DEF => lsp_types::SymbolKind::Object,\n+        _ => lsp_types::SymbolKind::Variable,\n+    }\n+}\n+\n+pub(crate) fn document_highlight_kind(\n+    reference_access: ReferenceAccess,\n+) -> lsp_types::DocumentHighlightKind {\n+    match reference_access {\n+        ReferenceAccess::Read => lsp_types::DocumentHighlightKind::Read,\n+        ReferenceAccess::Write => lsp_types::DocumentHighlightKind::Write,\n+    }\n+}\n+\n+pub(crate) fn diagnostic_severity(severity: Severity) -> lsp_types::DiagnosticSeverity {\n+    match severity {\n+        Severity::Error => lsp_types::DiagnosticSeverity::Error,\n+        Severity::WeakWarning => lsp_types::DiagnosticSeverity::Hint,\n+    }\n+}\n+\n+pub(crate) fn documentation(documentation: Documentation) -> lsp_types::Documentation {\n+    let value = crate::markdown::format_docs(documentation.as_str());\n+    let markup_content = lsp_types::MarkupContent { kind: lsp_types::MarkupKind::Markdown, value };\n+    lsp_types::Documentation::MarkupContent(markup_content)\n+}\n+\n+pub(crate) fn insert_text_format(\n+    insert_text_format: InsertTextFormat,\n+) -> lsp_types::InsertTextFormat {\n+    match insert_text_format {\n+        InsertTextFormat::Snippet => lsp_types::InsertTextFormat::Snippet,\n+        InsertTextFormat::PlainText => lsp_types::InsertTextFormat::PlainText,\n+    }\n+}\n+\n+pub(crate) fn completion_item_kind(\n+    completion_item_kind: CompletionItemKind,\n+) -> lsp_types::CompletionItemKind {\n+    match completion_item_kind {\n+        CompletionItemKind::Keyword => lsp_types::CompletionItemKind::Keyword,\n+        CompletionItemKind::Snippet => lsp_types::CompletionItemKind::Snippet,\n+        CompletionItemKind::Module => lsp_types::CompletionItemKind::Module,\n+        CompletionItemKind::Function => lsp_types::CompletionItemKind::Function,\n+        CompletionItemKind::Struct => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Enum => lsp_types::CompletionItemKind::Enum,\n+        CompletionItemKind::EnumVariant => lsp_types::CompletionItemKind::EnumMember,\n+        CompletionItemKind::BuiltinType => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Binding => lsp_types::CompletionItemKind::Variable,\n+        CompletionItemKind::Field => lsp_types::CompletionItemKind::Field,\n+        CompletionItemKind::Trait => lsp_types::CompletionItemKind::Interface,\n+        CompletionItemKind::TypeAlias => lsp_types::CompletionItemKind::Struct,\n+        CompletionItemKind::Const => lsp_types::CompletionItemKind::Constant,\n+        CompletionItemKind::Static => lsp_types::CompletionItemKind::Value,\n+        CompletionItemKind::Method => lsp_types::CompletionItemKind::Method,\n+        CompletionItemKind::TypeParam => lsp_types::CompletionItemKind::TypeParameter,\n+        CompletionItemKind::Macro => lsp_types::CompletionItemKind::Method,\n+        CompletionItemKind::Attribute => lsp_types::CompletionItemKind::EnumMember,\n+    }\n+}\n+\n+pub(crate) fn text_edit(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    indel: Indel,\n+) -> lsp_types::TextEdit {\n+    let range = range(line_index, indel.delete);\n+    let new_text = match line_endings {\n+        LineEndings::Unix => indel.insert,\n+        LineEndings::Dos => indel.insert.replace('\\n', \"\\r\\n\"),\n+    };\n+    lsp_types::TextEdit { range, new_text }\n+}\n+\n+pub(crate) fn text_edit_vec(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    text_edit: TextEdit,\n+) -> Vec<lsp_types::TextEdit> {\n+    text_edit\n+        .as_indels()\n+        .iter()\n+        .map(|it| self::text_edit(line_index, line_endings, it.clone()))\n+        .collect()\n+}\n+\n+pub(crate) fn completion_item(\n+    line_index: &LineIndex,\n+    line_endings: LineEndings,\n+    completion_item: CompletionItem,\n+) -> lsp_types::CompletionItem {\n+    let mut additional_text_edits = Vec::new();\n+    let mut text_edit = None;\n+    // LSP does not allow arbitrary edits in completion, so we have to do a\n+    // non-trivial mapping here.\n+    let source_range = completion_item.source_range();\n+    for indel in completion_item.text_edit().as_indels() {\n+        if indel.delete.contains_range(source_range) {\n+            text_edit = Some(if indel.delete == source_range {\n+                self::text_edit(line_index, line_endings, indel.clone())\n+            } else {\n+                assert!(source_range.end() == indel.delete.end());\n+                let range1 = TextRange::new(indel.delete.start(), source_range.start());\n+                let range2 = source_range;\n+                let indel1 = Indel::replace(range1, String::new());\n+                let indel2 = Indel::replace(range2, indel.insert.clone());\n+                additional_text_edits.push(self::text_edit(line_index, line_endings, indel1));\n+                self::text_edit(line_index, line_endings, indel2)\n+            })\n+        } else {\n+            assert!(source_range.intersect(indel.delete).is_none());\n+            let text_edit = self::text_edit(line_index, line_endings, indel.clone());\n+            additional_text_edits.push(text_edit);\n+        }\n+    }\n+    let text_edit = text_edit.unwrap();\n+\n+    let mut res = lsp_types::CompletionItem {\n+        label: completion_item.label().to_string(),\n+        detail: completion_item.detail().map(|it| it.to_string()),\n+        filter_text: Some(completion_item.lookup().to_string()),\n+        kind: completion_item.kind().map(completion_item_kind),\n+        text_edit: Some(text_edit.into()),\n+        additional_text_edits: Some(additional_text_edits),\n+        documentation: completion_item.documentation().map(documentation),\n+        deprecated: Some(completion_item.deprecated()),\n+        command: if completion_item.trigger_call_info() {\n+            let cmd = lsp_types::Command {\n+                title: \"triggerParameterHints\".into(),\n+                command: \"editor.action.triggerParameterHints\".into(),\n+                arguments: None,\n+            };\n+            Some(cmd)\n+        } else {\n+            None\n+        },\n+        ..Default::default()\n+    };\n+\n+    if completion_item.score().is_some() {\n+        res.preselect = Some(true)\n+    }\n+\n+    if completion_item.deprecated() {\n+        res.tags = Some(vec![lsp_types::CompletionItemTag::Deprecated])\n+    }\n+\n+    res.insert_text_format = Some(insert_text_format(completion_item.insert_text_format()));\n+\n+    res\n+}\n+\n+pub(crate) fn signature_information(\n+    signature: FunctionSignature,\n+    concise: bool,\n+) -> lsp_types::SignatureInformation {\n+    let (label, documentation, params) = if concise {\n+        let mut params = signature.parameters;\n+        if signature.has_self_param {\n+            params.remove(0);\n+        }\n+        (params.join(\", \"), None, params)\n+    } else {\n+        (signature.to_string(), signature.doc.map(documentation), signature.parameters)\n+    };\n+\n+    let parameters: Vec<lsp_types::ParameterInformation> = params\n+        .into_iter()\n+        .map(|param| lsp_types::ParameterInformation {\n+            label: lsp_types::ParameterLabel::Simple(param),\n+            documentation: None,\n+        })\n+        .collect();\n+\n+    lsp_types::SignatureInformation { label, documentation, parameters: Some(parameters) }\n+}\n+\n+pub(crate) fn inlay_int(line_index: &LineIndex, inlay_hint: InlayHint) -> lsp_ext::InlayHint {\n+    lsp_ext::InlayHint {\n+        label: inlay_hint.label.to_string(),\n+        range: range(line_index, inlay_hint.range),\n+        kind: match inlay_hint.kind {\n+            InlayKind::ParameterHint => lsp_ext::InlayKind::ParameterHint,\n+            InlayKind::TypeHint => lsp_ext::InlayKind::TypeHint,\n+            InlayKind::ChainingHint => lsp_ext::InlayKind::ChainingHint,\n+        },\n+    }\n+}\n+\n+pub(crate) fn semantic_tokens(\n+    text: &str,\n+    line_index: &LineIndex,\n+    highlights: Vec<HighlightedRange>,\n+) -> lsp_types::SemanticTokens {\n+    let mut builder = semantic_tokens::SemanticTokensBuilder::default();\n+\n+    for highlight_range in highlights {\n+        let (type_, mods) = semantic_token_type_and_modifiers(highlight_range.highlight);\n+        let token_index = semantic_tokens::type_index(type_);\n+        let modifier_bitset = mods.0;\n+\n+        for mut text_range in line_index.lines(highlight_range.range) {\n+            if text[text_range].ends_with('\\n') {\n+                text_range =\n+                    TextRange::new(text_range.start(), text_range.end() - TextSize::of('\\n'));\n+            }\n+            let range = range(&line_index, text_range);\n+            builder.push(range, token_index, modifier_bitset);\n+        }\n+    }\n+\n+    builder.build()\n+}\n+\n+fn semantic_token_type_and_modifiers(\n+    highlight: Highlight,\n+) -> (lsp_types::SemanticTokenType, semantic_tokens::ModifierSet) {\n+    let mut mods = semantic_tokens::ModifierSet::default();\n+    let type_ = match highlight.tag {\n+        HighlightTag::Struct => lsp_types::SemanticTokenType::STRUCT,\n+        HighlightTag::Enum => lsp_types::SemanticTokenType::ENUM,\n+        HighlightTag::Union => semantic_tokens::UNION,\n+        HighlightTag::TypeAlias => semantic_tokens::TYPE_ALIAS,\n+        HighlightTag::Trait => lsp_types::SemanticTokenType::INTERFACE,\n+        HighlightTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n+        HighlightTag::SelfType => lsp_types::SemanticTokenType::TYPE,\n+        HighlightTag::Field => lsp_types::SemanticTokenType::MEMBER,\n+        HighlightTag::Function => lsp_types::SemanticTokenType::FUNCTION,\n+        HighlightTag::Module => lsp_types::SemanticTokenType::NAMESPACE,\n+        HighlightTag::Constant => {\n+            mods |= semantic_tokens::CONSTANT;\n+            mods |= lsp_types::SemanticTokenModifier::STATIC;\n+            lsp_types::SemanticTokenType::VARIABLE\n+        }\n+        HighlightTag::Static => {\n+            mods |= lsp_types::SemanticTokenModifier::STATIC;\n+            lsp_types::SemanticTokenType::VARIABLE\n+        }\n+        HighlightTag::EnumVariant => semantic_tokens::ENUM_MEMBER,\n+        HighlightTag::Macro => lsp_types::SemanticTokenType::MACRO,\n+        HighlightTag::Local => lsp_types::SemanticTokenType::VARIABLE,\n+        HighlightTag::TypeParam => lsp_types::SemanticTokenType::TYPE_PARAMETER,\n+        HighlightTag::Lifetime => semantic_tokens::LIFETIME,\n+        HighlightTag::ByteLiteral | HighlightTag::NumericLiteral => {\n+            lsp_types::SemanticTokenType::NUMBER\n+        }\n+        HighlightTag::CharLiteral | HighlightTag::StringLiteral => {\n+            lsp_types::SemanticTokenType::STRING\n+        }\n+        HighlightTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HighlightTag::Attribute => semantic_tokens::ATTRIBUTE,\n+        HighlightTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HighlightTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n+        HighlightTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n+    };\n+\n+    for modifier in highlight.modifiers.iter() {\n+        let modifier = match modifier {\n+            HighlightModifier::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n+            HighlightModifier::ControlFlow => semantic_tokens::CONTROL_FLOW,\n+            HighlightModifier::Mutable => semantic_tokens::MUTABLE,\n+            HighlightModifier::Unsafe => semantic_tokens::UNSAFE,\n+        };\n+        mods |= modifier;\n+    }\n+\n+    (type_, mods)\n+}\n+\n+pub(crate) fn folding_range(\n+    text: &str,\n+    line_index: &LineIndex,\n+    line_folding_only: bool,\n+    fold: Fold,\n+) -> lsp_types::FoldingRange {\n+    let kind = match fold.kind {\n+        FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n+        FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n+        FoldKind::Mods | FoldKind::Block => None,\n+    };\n+\n+    let range = range(line_index, fold.range);\n+\n+    if line_folding_only {\n+        // Clients with line_folding_only == true (such as VSCode) will fold the whole end line\n+        // even if it contains text not in the folding range. To prevent that we exclude\n+        // range.end.line from the folding region if there is more text after range.end\n+        // on the same line.\n+        let has_more_text_on_end_line = text[TextRange::new(fold.range.end(), TextSize::of(text))]\n+            .chars()\n+            .take_while(|it| *it != '\\n')\n+            .any(|it| !it.is_whitespace());\n+\n+        let end_line = if has_more_text_on_end_line {\n+            range.end.line.saturating_sub(1)\n+        } else {\n+            range.end.line\n+        };\n+\n+        lsp_types::FoldingRange {\n+            start_line: range.start.line,\n+            start_character: None,\n+            end_line,\n+            end_character: None,\n+            kind,\n+        }\n+    } else {\n+        lsp_types::FoldingRange {\n+            start_line: range.start.line,\n+            start_character: Some(range.start.character),\n+            end_line: range.end.line,\n+            end_character: Some(range.end.character),\n+            kind,\n+        }\n+    }\n+}\n+\n+pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    world.file_id_to_uri(file_id)\n+}\n+\n+pub(crate) fn text_document_identifier(\n+    world: &WorldSnapshot,\n+    file_id: FileId,\n+) -> Result<lsp_types::TextDocumentIdentifier> {\n+    let res = lsp_types::TextDocumentIdentifier { uri: url(world, file_id)? };\n+    Ok(res)\n+}\n+\n+pub(crate) fn versioned_text_document_identifier(\n+    world: &WorldSnapshot,\n+    file_id: FileId,\n+    version: Option<i64>,\n+) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    Ok(res)\n+}\n+\n+pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n+    let url = url(world, frange.file_id)?;\n+    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let range = range(&line_index, frange.range);\n+    let loc = lsp_types::Location::new(url, range);\n+    Ok(loc)\n+}\n+\n+pub(crate) fn location_link(\n+    world: &WorldSnapshot,\n+    src: FileRange,\n+    target: NavigationTarget,\n+) -> Result<lsp_types::LocationLink> {\n+    let src_location = location(world, src)?;\n+    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let res = lsp_types::LocationLink {\n+        origin_selection_range: Some(src_location.range),\n+        target_uri,\n+        target_range,\n+        target_selection_range,\n+    };\n+    Ok(res)\n+}\n+\n+fn location_info(\n+    world: &WorldSnapshot,\n+    target: NavigationTarget,\n+) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n+    let line_index = world.analysis().file_line_index(target.file_id())?;\n+\n+    let target_uri = url(world, target.file_id())?;\n+    let target_range = range(&line_index, target.full_range());\n+    let target_selection_range =\n+        target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n+    Ok((target_uri, target_range, target_selection_range))\n+}\n+\n+pub(crate) fn goto_definition_response(\n+    world: &WorldSnapshot,\n+    src: FileRange,\n+    targets: Vec<NavigationTarget>,\n+) -> Result<lsp_types::GotoDefinitionResponse> {\n+    if world.config.client_caps.location_link {\n+        let links = targets\n+            .into_iter()\n+            .map(|nav| location_link(world, src, nav))\n+            .collect::<Result<Vec<_>>>()?;\n+        Ok(links.into())\n+    } else {\n+        let locations = targets\n+            .into_iter()\n+            .map(|nav| {\n+                location(\n+                    world,\n+                    FileRange {\n+                        file_id: nav.file_id(),\n+                        range: nav.focus_range().unwrap_or(nav.range()),\n+                    },\n+                )\n+            })\n+            .collect::<Result<Vec<_>>>()?;\n+        Ok(locations.into())\n+    }\n+}\n+\n+pub(crate) fn text_document_edit(\n+    world: &WorldSnapshot,\n+    source_file_edit: SourceFileEdit,\n+) -> Result<lsp_types::TextDocumentEdit> {\n+    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n+    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let edits = source_file_edit\n+        .edit\n+        .as_indels()\n+        .iter()\n+        .map(|it| text_edit(&line_index, line_endings, it.clone()))\n+        .collect();\n+    Ok(lsp_types::TextDocumentEdit { text_document, edits })\n+}\n+\n+pub(crate) fn resource_op(\n+    world: &WorldSnapshot,\n+    file_system_edit: FileSystemEdit,\n+) -> Result<lsp_types::ResourceOp> {\n+    let res = match file_system_edit {\n+        FileSystemEdit::CreateFile { source_root, path } => {\n+            let uri = world.path_to_uri(source_root, &path)?;\n+            lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n+        }\n+        FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n+            let old_uri = world.file_id_to_uri(src)?;\n+            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n+        }\n+    };\n+    Ok(res)\n+}\n+\n+pub(crate) fn source_change(\n+    world: &WorldSnapshot,\n+    source_change: SourceChange,\n+) -> Result<lsp_ext::SourceChange> {\n+    let cursor_position = match source_change.cursor_position {\n+        None => None,\n+        Some(pos) => {\n+            let line_index = world.analysis().file_line_index(pos.file_id)?;\n+            let edit = source_change\n+                .source_file_edits\n+                .iter()\n+                .find(|it| it.file_id == pos.file_id)\n+                .map(|it| &it.edit);\n+            let line_col = match edit {\n+                Some(edit) => translate_offset_with_edit(&*line_index, pos.offset, edit),\n+                None => line_index.line_col(pos.offset),\n+            };\n+            let position =\n+                lsp_types::Position::new(u64::from(line_col.line), u64::from(line_col.col_utf16));\n+            Some(lsp_types::TextDocumentPositionParams {\n+                text_document: text_document_identifier(world, pos.file_id)?,\n+                position,\n+            })\n+        }\n+    };\n+    let mut document_changes: Vec<lsp_types::DocumentChangeOperation> = Vec::new();\n+    for op in source_change.file_system_edits {\n+        let op = resource_op(&world, op)?;\n+        document_changes.push(lsp_types::DocumentChangeOperation::Op(op));\n+    }\n+    for edit in source_change.source_file_edits {\n+        let edit = text_document_edit(&world, edit)?;\n+        document_changes.push(lsp_types::DocumentChangeOperation::Edit(edit));\n+    }\n+    let workspace_edit = lsp_types::WorkspaceEdit {\n+        changes: None,\n+        document_changes: Some(lsp_types::DocumentChanges::Operations(document_changes)),\n+    };\n+    Ok(lsp_ext::SourceChange { label: source_change.label, workspace_edit, cursor_position })\n+}\n+\n+pub fn call_hierarchy_item(\n+    world: &WorldSnapshot,\n+    target: NavigationTarget,\n+) -> Result<lsp_types::CallHierarchyItem> {\n+    let name = target.name().to_string();\n+    let detail = target.description().map(|it| it.to_string());\n+    let kind = symbol_kind(target.kind());\n+    let (uri, range, selection_range) = location_info(world, target)?;\n+    Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::extract_ranges;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn conv_fold_line_folding_only_fixup() {\n+        let text = r#\"<fold>mod a;\n+mod b;\n+mod c;</fold>\n+\n+fn main() <fold>{\n+    if cond <fold>{\n+        a::do_a();\n+    }</fold> else <fold>{\n+        b::do_b();\n+    }</fold>\n+}</fold>\"#;\n+\n+        let (ranges, text) = extract_ranges(text, \"fold\");\n+        assert_eq!(ranges.len(), 4);\n+        let folds = vec![\n+            Fold { range: ranges[0], kind: FoldKind::Mods },\n+            Fold { range: ranges[1], kind: FoldKind::Block },\n+            Fold { range: ranges[2], kind: FoldKind::Block },\n+            Fold { range: ranges[3], kind: FoldKind::Block },\n+        ];\n+\n+        let line_index = LineIndex::new(&text);\n+        let converted: Vec<lsp_types::FoldingRange> =\n+            folds.into_iter().map(|it| folding_range(&text, &line_index, true, it)).collect();\n+\n+        let expected_lines = [(0, 2), (4, 10), (5, 6), (7, 9)];\n+        assert_eq!(converted.len(), expected_lines.len());\n+        for (folding_range, (start_line, end_line)) in converted.iter().zip(expected_lines.iter()) {\n+            assert_eq!(folding_range.start_line, *start_line);\n+            assert_eq!(folding_range.start_character, None);\n+            assert_eq!(folding_range.end_line, *end_line);\n+            assert_eq!(folding_range.end_character, None);\n+        }\n+    }\n+}\n+\n+pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_types::CodeAction> {\n+    let source_change = source_change(&world, assist.source_change)?;\n+    let arg = serde_json::to_value(source_change)?;\n+    let title = assist.label;\n+    let command = lsp_types::Command {\n+        title: title.clone(),\n+        command: \"rust-analyzer.applySourceChange\".to_string(),\n+        arguments: Some(vec![arg]),\n+    };\n+\n+    Ok(lsp_types::CodeAction {\n+        title,\n+        kind: Some(String::new()),\n+        diagnostics: None,\n+        edit: None,\n+        command: Some(command),\n+        is_preferred: None,\n+    })\n+}"}, {"sha": "5011cc2734dc2234e72f298b40de001193976bf0", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -3,15 +3,16 @@ mod support;\n use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n use lsp_types::{\n-    CodeActionContext, DidOpenTextDocumentParams, DocumentFormattingParams, FormattingOptions,\n-    GotoDefinitionParams, HoverParams, PartialResultParams, Position, Range, TextDocumentItem,\n-    TextDocumentPositionParams, WorkDoneProgressParams,\n-};\n-use rust_analyzer::req::{\n-    CodeActionParams, CodeActionRequest, Completion, CompletionParams, DidOpenTextDocument,\n-    Formatting, GotoDefinition, GotoTypeDefinition, HoverRequest, OnEnter, Runnables,\n-    RunnablesParams,\n+    notification::DidOpenTextDocument,\n+    request::{\n+        CodeActionRequest, Completion, Formatting, GotoDefinition, GotoTypeDefinition, HoverRequest,\n+    },\n+    CodeActionContext, CodeActionParams, CompletionParams, DidOpenTextDocumentParams,\n+    DocumentFormattingParams, FormattingOptions, GotoDefinitionParams, HoverParams,\n+    PartialResultParams, Position, Range, TextDocumentItem, TextDocumentPositionParams,\n+    WorkDoneProgressParams,\n };\n+use rust_analyzer::lsp_ext::{OnEnter, Runnables, RunnablesParams};\n use serde_json::json;\n use tempfile::TempDir;\n use test_utils::skip_slow_tests;"}, {"sha": "8756ad4a3c8a8b0c02b587f928ff93e9eebb119a", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348cbc054c91dbdae3633d5f401a1187e79232ee/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=348cbc054c91dbdae3633d5f401a1187e79232ee", "patch": "@@ -13,15 +13,15 @@ use lsp_types::{\n     request::Shutdown,\n     DidOpenTextDocumentParams, TextDocumentIdentifier, TextDocumentItem, Url, WorkDoneProgress,\n };\n+use lsp_types::{ProgressParams, ProgressParamsValue};\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n-use req::{ProgressParams, ProgressParamsValue};\n use rust_analyzer::{\n     config::{ClientCapsConfig, Config},\n-    main_loop, req,\n+    main_loop,\n };\n \n pub struct Project<'a> {\n@@ -206,7 +206,7 @@ impl Server {\n             Message::Notification(n) if n.method == \"$/progress\" => {\n                 match n.clone().extract::<ProgressParams>(\"$/progress\").unwrap() {\n                     ProgressParams {\n-                        token: req::ProgressToken::String(ref token),\n+                        token: lsp_types::ProgressToken::String(ref token),\n                         value: ProgressParamsValue::WorkDone(WorkDoneProgress::End(_)),\n                     } if token == \"rustAnalyzer/startup\" => true,\n                     _ => false,"}]}