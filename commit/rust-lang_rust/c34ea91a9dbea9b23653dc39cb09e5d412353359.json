{"sha": "c34ea91a9dbea9b23653dc39cb09e5d412353359", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNGVhOTFhOWRiZWE5YjIzNjUzZGMzOWNiMDllNWQ0MTIzNTMzNTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-16T04:23:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-16T04:23:26Z"}, "message": "Rollup merge of #65778 - bdonlan:stable_weak_count, r=dtolnay\n\nStabilize `std::{rc,sync}::Weak::{weak_count, strong_count}`\n\n* Original PR: #56696\n* Tracking issue: #57977\n\nCloses: #57977\n\nSupporting comments:\n\n> Although these were added for testing, it is occasionally useful to have a way to probe optimistically for whether a weak pointer has become dangling, without actually taking the overhead of manipulating atomics. Are there any plans to stabilize this?\n\n_Originally posted by @bdonlan in https://github.com/rust-lang/rust/issues/57977#issuecomment-516970921_\n\n> Having this stabilized would help. Currently, the only way to check if a weak pointer has become dangling is to call `upgrade`, which is by far expensive.\n\n_Originally posted by @glebpom in https://github.com/rust-lang/rust/issues/57977#issuecomment-526934709_\n\nNot sure if stabilizing these warrants a full RFC, so throwing this out here as a start for now.\n\nNote: per CONTRIBUTING.md, I ran the tidy checks, but they seem to be failing on unchanged files (primarily in `src/stdsimd`).", "tree": {"sha": "9c0a6a2c865a4204d1dde9d4d6885903f33fda55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0a6a2c865a4204d1dde9d4d6885903f33fda55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c34ea91a9dbea9b23653dc39cb09e5d412353359", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd9wa+CRBK7hj4Ov3rIwAAdHIIAHSlqHFmi+sbCSP/Ou5YJyH0\n3lWWwG0kFF5quext5M4A7iM4hnSOTxGfTM2Dx69eRJRd76gpAIrSQ01q5sJwPhGx\nvyl8hBhn6hE7xGs9HHcx5q7AxKxolgY41GfXNoVnIl2FCm0n3vQwJhxSdBchfNQ2\nJ6mKaHuonrwh/ywpI8wMp+c2KqU7CBIlXumtDgXzWCU/skymBw66kO4z/6mtthMK\nE0VWTnyKqEsgQou4ojyQwLPW5Z77cIPl2eGqDpfcJrthuVpot6HeMvvatsJL5t+u\ncw3kHB5Pir98LUMFLpUHlFfG0fzCpoKrYg0xbDH6Q6ZExApiHbkF6BqYdYheKLA=\n=RnYj\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c0a6a2c865a4204d1dde9d4d6885903f33fda55\nparent a605441e049f0b6d5f7715b94b8ac4662fd7fcf6\nparent 9778e03665edbed80eb684ba893abd4e18a0a583\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576470206 +0100\ncommitter GitHub <noreply@github.com> 1576470206 +0100\n\nRollup merge of #65778 - bdonlan:stable_weak_count, r=dtolnay\n\nStabilize `std::{rc,sync}::Weak::{weak_count, strong_count}`\n\n* Original PR: #56696\n* Tracking issue: #57977\n\nCloses: #57977\n\nSupporting comments:\n\n> Although these were added for testing, it is occasionally useful to have a way to probe optimistically for whether a weak pointer has become dangling, without actually taking the overhead of manipulating atomics. Are there any plans to stabilize this?\n\n_Originally posted by @bdonlan in https://github.com/rust-lang/rust/issues/57977#issuecomment-516970921_\n\n> Having this stabilized would help. Currently, the only way to check if a weak pointer has become dangling is to call `upgrade`, which is by far expensive.\n\n_Originally posted by @glebpom in https://github.com/rust-lang/rust/issues/57977#issuecomment-526934709_\n\nNot sure if stabilizing these warrants a full RFC, so throwing this out here as a start for now.\n\nNote: per CONTRIBUTING.md, I ran the tidy checks, but they seem to be failing on unchanged files (primarily in `src/stdsimd`).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c34ea91a9dbea9b23653dc39cb09e5d412353359", "html_url": "https://github.com/rust-lang/rust/commit/c34ea91a9dbea9b23653dc39cb09e5d412353359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c34ea91a9dbea9b23653dc39cb09e5d412353359/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "html_url": "https://github.com/rust-lang/rust/commit/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6"}, {"sha": "9778e03665edbed80eb684ba893abd4e18a0a583", "url": "https://api.github.com/repos/rust-lang/rust/commits/9778e03665edbed80eb684ba893abd4e18a0a583", "html_url": "https://github.com/rust-lang/rust/commit/9778e03665edbed80eb684ba893abd4e18a0a583"}], "stats": {"total": 84, "additions": 35, "deletions": 49}, "files": [{"sha": "42a278de98befd7ccfedd347734e616bd31b6ac4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c34ea91a9dbea9b23653dc39cb09e5d412353359", "patch": "@@ -1836,7 +1836,7 @@ impl<T: ?Sized> Weak<T> {\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() {\n             inner.strong()\n@@ -1847,20 +1847,16 @@ impl<T: ?Sized> Weak<T> {\n \n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return `None`. If\n-    /// not, the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n-    ///\n-    /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n+    /// If no strong pointers remain, this will return zero.\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n             if inner.strong() > 0 {\n                 inner.weak() - 1  // subtract the implicit weak ptr\n             } else {\n-                inner.weak()\n+                0\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`"}, {"sha": "bf5c85a5c59601af7a142a7483d419b723c66382", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=c34ea91a9dbea9b23653dc39cb09e5d412353359", "patch": "@@ -114,28 +114,28 @@ fn test_weak_count() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Rc::new(0);\n     let w = Rc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}, {"sha": "a99564c0dac8a97f10beec0df3b74b54de4d181e", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=c34ea91a9dbea9b23653dc39cb09e5d412353359", "patch": "@@ -12,7 +12,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n-use core::cmp::{self, Ordering};\n+use core::cmp::Ordering;\n use core::iter;\n use core::intrinsics::abort;\n use core::mem::{self, align_of, align_of_val, size_of_val};\n@@ -1529,7 +1529,7 @@ impl<T: ?Sized> Weak<T> {\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() {\n             inner.strong.load(SeqCst)\n@@ -1541,9 +1541,8 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n     /// allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return 0. If not,\n-    /// the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n+    /// If `self` was created using [`Weak::new`], or if there are no remaining\n+    /// strong pointers, this will return 0.\n     ///\n     /// # Accuracy\n     ///\n@@ -1552,31 +1551,22 @@ impl<T: ?Sized> Weak<T> {\n     /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n-        // Due to the implicit weak pointer added when any strong pointers are\n-        // around, we cannot implement `weak_count` correctly since it\n-        // necessarily requires accessing the strong count and weak count in an\n-        // unsynchronized fashion. So this version is a bit racy.\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n-            let strong = inner.strong.load(SeqCst);\n             let weak = inner.weak.load(SeqCst);\n+            let strong = inner.strong.load(SeqCst);\n             if strong == 0 {\n-                // If the last `Arc` has *just* been dropped, it might not yet\n-                // have removed the implicit weak count, so the value we get\n-                // here might be 1 too high.\n-                weak\n+                0\n             } else {\n-                // As long as there's still at least 1 `Arc` around, subtract\n-                // the implicit weak pointer.\n-                // Note that the last `Arc` might get dropped between the 2\n-                // loads we do above, removing the implicit weak pointer. This\n-                // means that the value might be 1 too low here. In order to not\n-                // return 0 here (which would happen if we're the only weak\n-                // pointer), we guard against that specifically.\n-                cmp::max(1, weak - 1)\n+                // Since we observed that there was at least one strong pointer\n+                // after reading the weak count, we know that the implicit weak\n+                // reference (present whenever any strong references are alive)\n+                // was still around when we observed the weak count, and can\n+                // therefore safely subtract it.\n+                weak - 1\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,"}, {"sha": "8f516129cd00f4a4eb8c6df315da2680413411e0", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ea91a9dbea9b23653dc39cb09e5d412353359/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=c34ea91a9dbea9b23653dc39cb09e5d412353359", "patch": "@@ -62,28 +62,28 @@ fn test_arc_get_mut() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Arc::new(0);\n     let w = Arc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}]}