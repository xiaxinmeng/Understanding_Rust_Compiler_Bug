{"sha": "24160171e48a277ef71e84e14fbffffe3c81438a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MTYwMTcxZTQ4YTI3N2VmNzFlODRlMTRmYmZmZmZlM2M4MTQzOGE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-22T00:47:23Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-24T18:49:33Z"}, "message": "Tweak macro parse errors when reaching EOF during macro call parse\n\n- Add detail on origin of current parser when reaching EOF and stop\n  saying \"found <eof>\" and point at the end of macro calls\n- Handle empty `cfg_attr` attribute\n- Reword empty `derive` attribute error", "tree": {"sha": "e4d594acb224da13101b0146d9e785910021f412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d594acb224da13101b0146d9e785910021f412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24160171e48a277ef71e84e14fbffffe3c81438a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24160171e48a277ef71e84e14fbffffe3c81438a", "html_url": "https://github.com/rust-lang/rust/commit/24160171e48a277ef71e84e14fbffffe3c81438a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24160171e48a277ef71e84e14fbffffe3c81438a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc45382c125d940822368e866588568d78551946", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc45382c125d940822368e866588568d78551946", "html_url": "https://github.com/rust-lang/rust/commit/fc45382c125d940822368e866588568d78551946"}], "stats": {"total": 269, "additions": 176, "deletions": 93}, "files": [{"sha": "c84d15b3adb8c359ffb3287f425e2b742333148b", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -627,7 +627,7 @@ mod tests {\n     use super::*;\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-        let parser = Parser::new(fmt, None, vec![], false);\n+        let parser = Parser::new(fmt, None, vec![], false, None);\n         assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n     }\n \n@@ -643,7 +643,7 @@ mod tests {\n     }\n \n     fn musterr(s: &str) {\n-        let mut p = Parser::new(s, None, vec![], false);\n+        let mut p = Parser::new(s, None, vec![], false, None);\n         p.next();\n         assert!(!p.errors.is_empty());\n     }"}, {"sha": "1c17ace90c2fbbc458f1ea4e8dab464da5e67ed7", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -226,12 +226,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         Ok(result)\n     }\n \n-    fn verify(&self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              trait_def_id: DefId,\n-              span: Span)\n-              -> Result<(), ErrorReported>\n-    {\n+    fn verify(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        span: Span,\n+    ) -> Result<(), ErrorReported> {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0, None, vec![], false);\n@@ -272,12 +272,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         result\n     }\n \n-    pub fn format(&self,\n-                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                  trait_ref: ty::TraitRef<'tcx>,\n-                  options: &FxHashMap<String, String>)\n-                  -> String\n-    {\n+    pub fn format(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &FxHashMap<String, String>,\n+    ) -> String {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.def_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);"}, {"sha": "48948e4d0d79c1829c30cbbf199319c4ab046737", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -278,7 +278,14 @@ impl Attribute {\n     pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n-        let mut parser = Parser::new(sess, self.tokens.clone(), None, false, false);\n+        let mut parser = Parser::new(\n+            sess,\n+            self.tokens.clone(),\n+            None,\n+            false,\n+            false,\n+            Some(\"attribute\"),\n+        );\n         let result = f(&mut parser)?;\n         if parser.token != token::Eof {\n             parser.unexpected()?;"}, {"sha": "ca047dc66cb166e8f6c8581d4e2f38f5b0298540", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -94,6 +94,17 @@ impl<'a> StripUnconfigured<'a> {\n         if !attr.check_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n+        if attr.tokens.len() == 0 {\n+            self.sess.span_diagnostic.struct_span_err(attr.span, \"bad `cfg_attr` attribute\")\n+                .span_label(attr.span, \"missing condition and attribute\")\n+                .note(\"`cfg_attr` must be of the form: \\\n+                       `#[cfg_attr(condition, attribute)]`\")\n+                .note(\"for more information, visit \\\n+                       <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n+                       #the-cfg_attr-attribute>\")\n+                .emit();\n+            return vec![];\n+        }\n \n         let (cfg_predicate, expanded_attrs) = match attr.parse(self.sess, |parser| {\n             parser.expect(&token::OpenDelim(token::Paren))?;\n@@ -117,7 +128,7 @@ impl<'a> StripUnconfigured<'a> {\n             Ok(result) => result,\n             Err(mut e) => {\n                 e.emit();\n-                return Vec::new();\n+                return vec![];\n             }\n         };\n "}, {"sha": "ef7317e00389a9a7e3d6a262d5cfb8d04dd964c1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -850,7 +850,11 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n-        parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect())\n+        parse::stream_to_parser(\n+            self.parse_sess,\n+            tts.iter().cloned().collect(),\n+            Some(\"macro arguments\"),\n+        )\n     }\n     pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }"}, {"sha": "bbdda4932f11729738fed574a2cf406a7cabc663", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -17,8 +17,11 @@ pub fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) ->\n             return true;\n         }\n         if !attr.is_meta_item_list() {\n-            cx.span_err(attr.span,\n-                        \"attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\");\n+            cx.struct_span_err(attr.span, \"bad `derive` attribute\")\n+                .span_label(attr.span, \"missing traits to be derived\")\n+                .note(\"`derive` must be of the form: \\\n+                       `#[derive(Trait1, Trait2, ...)]`\")\n+                .emit();\n             return false;\n         }\n "}, {"sha": "02e986c9e75b6d4452fb4f3cc0ccb24624e93d4d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -658,7 +658,14 @@ pub fn parse(\n     recurse_into_modules: bool,\n ) -> NamedParseResult {\n     // Create a parser that can be used for the \"black box\" parts.\n-    let mut parser = Parser::new(sess, tts, directory, recurse_into_modules, true);\n+    let mut parser = Parser::new(\n+        sess,\n+        tts,\n+        directory,\n+        recurse_into_modules,\n+        true,\n+        Some(\"macro arguments\"),\n+    );\n \n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then"}, {"sha": "2debd8f048bc35a578fafd2429062c9ebfd81c0d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -172,7 +172,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                     path: Cow::from(cx.current_expansion.module.directory.as_path()),\n                     ownership: cx.current_expansion.directory_ownership,\n                 };\n-                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false);\n+                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n                 p.root_module_name = cx.current_expansion.module.mod_path.last()\n                     .map(|id| id.as_str().to_string());\n "}, {"sha": "ece6137e881b88d716b22a6b297b1695daeeccd2", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -236,7 +236,7 @@ fn maybe_source_file_to_parser(\n ) -> Result<Parser<'_>, Vec<Diagnostic>> {\n     let end_pos = source_file.end_pos;\n     let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n-    let mut parser = stream_to_parser(sess, stream);\n+    let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof && parser.span.is_dummy() {\n         parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n@@ -248,7 +248,7 @@ fn maybe_source_file_to_parser(\n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n-    stream_to_parser(sess, tts.into_iter().collect())\n+    stream_to_parser(sess, tts.into_iter().collect(), Some(\"macro arguments\"))\n }\n \n \n@@ -328,8 +328,12 @@ pub fn maybe_file_to_stream(\n }\n \n /// Given stream and the `ParseSess`, produces a parser.\n-pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n-    Parser::new(sess, stream, None, true, false)\n+pub fn stream_to_parser<'a>(\n+    sess: &'a ParseSess,\n+    stream: TokenStream,\n+    is_subparser: Option<&'static str>,\n+) -> Parser<'a> {\n+    Parser::new(sess, stream, None, true, false, is_subparser)\n }\n \n /// Given stream, the `ParseSess` and the base directory, produces a parser."}, {"sha": "38aa5091f9898451d82101bcaa3e03d5d56f1028", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 58, "deletions": 33, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -51,7 +51,7 @@ use crate::symbol::{kw, sym, Symbol};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{\n-    Span, MultiSpan, BytePos, FileName,\n+    BytePos, DUMMY_SP, FileName, MultiSpan, Span,\n     hygiene::CompilerDesugaringKind,\n };\n use log::{debug, trace};\n@@ -233,6 +233,8 @@ pub struct Parser<'a> {\n     /// error.\n     crate unclosed_delims: Vec<UnmatchedBrace>,\n     last_unexpected_token_span: Option<Span>,\n+    /// If `true`, this `Parser` is not parsing Rust code but rather a macro call.\n+    is_subparser: Option<&'static str>,\n }\n \n impl<'a> Drop for Parser<'a> {\n@@ -309,7 +311,7 @@ impl TokenCursor {\n                 self.frame = frame;\n                 continue\n             } else {\n-                return TokenAndSpan { tok: token::Eof, sp: syntax_pos::DUMMY_SP }\n+                return TokenAndSpan { tok: token::Eof, sp: DUMMY_SP }\n             };\n \n             match self.frame.last_token {\n@@ -533,17 +535,19 @@ enum TokenExpectType {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess,\n-               tokens: TokenStream,\n-               directory: Option<Directory<'a>>,\n-               recurse_into_file_modules: bool,\n-               desugar_doc_comments: bool)\n-               -> Self {\n+    pub fn new(\n+        sess: &'a ParseSess,\n+        tokens: TokenStream,\n+        directory: Option<Directory<'a>>,\n+        recurse_into_file_modules: bool,\n+        desugar_doc_comments: bool,\n+        is_subparser: Option<&'static str>,\n+    ) -> Self {\n         let mut parser = Parser {\n             sess,\n             token: token::Whitespace,\n-            span: syntax_pos::DUMMY_SP,\n-            prev_span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n+            prev_span: DUMMY_SP,\n             meta_var_span: None,\n             prev_token_kind: PrevTokenKind::Other,\n             restrictions: Restrictions::empty(),\n@@ -568,6 +572,7 @@ impl<'a> Parser<'a> {\n             max_angle_bracket_count: 0,\n             unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n+            is_subparser,\n         };\n \n         let tok = parser.next_tok();\n@@ -639,16 +644,28 @@ impl<'a> Parser<'a> {\n             } else {\n                 let token_str = pprust::token_to_string(t);\n                 let this_token_str = self.this_token_descr();\n-                let mut err = self.fatal(&format!(\"expected `{}`, found {}\",\n-                                                  token_str,\n-                                                  this_token_str));\n-\n-                let sp = if self.token == token::Token::Eof {\n-                    // EOF, don't want to point at the following char, but rather the last token\n-                    self.prev_span\n-                } else {\n-                    self.sess.source_map().next_point(self.prev_span)\n+                let (prev_sp, sp) = match (&self.token, self.is_subparser) {\n+                    // Point at the end of the macro call when reaching end of macro arguments.\n+                    (token::Token::Eof, Some(_)) => {\n+                        let sp = self.sess.source_map().next_point(self.span);\n+                        (sp, sp)\n+                    }\n+                    // We don't want to point at the following span after DUMMY_SP.\n+                    // This happens when the parser finds an empty TokenStream.\n+                    _ if self.prev_span == DUMMY_SP => (self.span, self.span),\n+                    // EOF, don't want to point at the following char, but rather the last token.\n+                    (token::Token::Eof, None) => (self.prev_span, self.span),\n+                    _ => (self.sess.source_map().next_point(self.prev_span), self.span),\n                 };\n+                let msg = format!(\n+                    \"expected `{}`, found {}\",\n+                    token_str,\n+                    match (&self.token, self.is_subparser) {\n+                        (token::Token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n+                        _ => this_token_str,\n+                    },\n+                );\n+                let mut err = self.struct_span_err(sp, &msg);\n                 let label_exp = format!(\"expected `{}`\", token_str);\n                 match self.recover_closing_delimiter(&[t.clone()], err) {\n                     Err(e) => err = e,\n@@ -657,15 +674,15 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 let cm = self.sess.source_map();\n-                match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n+                match (cm.lookup_line(prev_sp.lo()), cm.lookup_line(sp.lo())) {\n                     (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n                         // When the spans are in the same line, it means that the only content\n                         // between them is whitespace, point only at the found token.\n-                        err.span_label(self.span, label_exp);\n+                        err.span_label(sp, label_exp);\n                     }\n                     _ => {\n-                        err.span_label(sp, label_exp);\n-                        err.span_label(self.span, \"unexpected token\");\n+                        err.span_label(prev_sp, label_exp);\n+                        err.span_label(sp, \"unexpected token\");\n                     }\n                 }\n                 Err(err)\n@@ -812,7 +829,7 @@ impl<'a> Parser<'a> {\n                     //   |                   expected one of 8 possible tokens here\n                     err.span_label(self.span, label_exp);\n                 }\n-                _ if self.prev_span == syntax_pos::DUMMY_SP => {\n+                _ if self.prev_span == DUMMY_SP => {\n                     // Account for macro context where the previous span might not be\n                     // available to avoid incorrect output (#54841).\n                     err.span_label(self.span, \"unexpected token\");\n@@ -2041,7 +2058,7 @@ impl<'a> Parser<'a> {\n             path = self.parse_path(PathStyle::Type)?;\n             path_span = path_lo.to(self.prev_span);\n         } else {\n-            path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+            path = ast::Path { segments: Vec::new(), span: DUMMY_SP };\n             path_span = self.span.to(self.span);\n         }\n \n@@ -2627,16 +2644,24 @@ impl<'a> Parser<'a> {\n                         }\n                         Err(mut err) => {\n                             self.cancel(&mut err);\n-                            let msg = format!(\"expected expression, found {}\",\n-                                              self.this_token_descr());\n-                            let mut err = self.fatal(&msg);\n+                            let (span, msg) = match (&self.token, self.is_subparser) {\n+                                (&token::Token::Eof, Some(origin)) => {\n+                                    let sp = self.sess.source_map().next_point(self.span);\n+                                    (sp, format!( \"expected expression, found end of {}\", origin))\n+                                }\n+                                _ => (self.span, format!(\n+                                    \"expected expression, found {}\",\n+                                    self.this_token_descr(),\n+                                )),\n+                            };\n+                            let mut err = self.struct_span_err(span, &msg);\n                             let sp = self.sess.source_map().start_point(self.span);\n                             if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow()\n                                 .get(&sp)\n                             {\n                                 self.sess.expr_parentheses_needed(&mut err, *sp, None);\n                             }\n-                            err.span_label(self.span, \"expected expression\");\n+                            err.span_label(span, \"expected expression\");\n                             return Err(err);\n                         }\n                     }\n@@ -5592,7 +5617,7 @@ impl<'a> Parser<'a> {\n                 where_clause: WhereClause {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n-                    span: syntax_pos::DUMMY_SP,\n+                    span: DUMMY_SP,\n                 },\n                 span: span_lo.to(self.prev_span),\n             })\n@@ -5838,7 +5863,7 @@ impl<'a> Parser<'a> {\n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n-            span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n \n         if !self.eat_keyword(kw::Where) {\n@@ -7005,15 +7030,15 @@ impl<'a> Parser<'a> {\n                             Ident::with_empty_ctxt(sym::warn_directory_ownership)),\n                         tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n-                        span: syntax_pos::DUMMY_SP,\n+                        span: DUMMY_SP,\n                     };\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }\n                 Ok((id, ItemKind::Mod(module), Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod {\n-                    inner: syntax_pos::DUMMY_SP,\n+                    inner: DUMMY_SP,\n                     items: Vec::new(),\n                     inline: false\n                 };"}, {"sha": "704665e0a84d66917d135ad035327988f7a146c7", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -138,7 +138,11 @@ fn parse_inline_asm<'a>(\n                 if p2.token != token::Eof {\n                     let mut extra_tts = p2.parse_all_token_trees()?;\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n-                    p = parse::stream_to_parser(cx.parse_sess, extra_tts.into_iter().collect());\n+                    p = parse::stream_to_parser(\n+                        cx.parse_sess,\n+                        extra_tts.into_iter().collect(),\n+                        Some(\"inline assembly\"),\n+                    );\n                 }\n \n                 asm = s;"}, {"sha": "975d96951dc5571d54d8090ca80b1362e5ecb44d", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -89,7 +89,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n         let msg = \"proc-macro derive produced unparseable tokens\";\n \n-        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream);\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n \n         loop {"}, {"sha": "fd4f93091944cd5af20d48bfad1f05a82f47584d", "filename": "src/test/ui/macros/format-parse-errors.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -12,17 +12,17 @@ error: expected expression, found keyword `struct`\n LL |     format!(struct);\n    |             ^^^^^^ expected expression\n \n-error: expected expression, found `<eof>`\n-  --> $DIR/format-parse-errors.rs:4:23\n+error: expected expression, found end of macro arguments\n+  --> $DIR/format-parse-errors.rs:4:24\n    |\n LL |     format!(\"s\", name =);\n-   |                       ^ expected expression\n+   |                        ^ expected expression\n \n-error: expected `=`, found `<eof>`\n-  --> $DIR/format-parse-errors.rs:5:29\n+error: expected `=`, found end of macro arguments\n+  --> $DIR/format-parse-errors.rs:5:32\n    |\n LL |     format!(\"s\", foo = foo, bar);\n-   |                             ^^^ expected `=`\n+   |                                ^ expected `=`\n \n error: expected expression, found keyword `struct`\n   --> $DIR/format-parse-errors.rs:6:24"}, {"sha": "1a87cd2d11cb572895a0375a79e16b56d67ed35c", "filename": "src/test/ui/malformed/malformed-derive-entry.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -1,17 +1,13 @@\n-#[derive(Copy(Bad))]\n-//~^ ERROR expected one of `)`, `,`, or `::`, found `(`\n+#[derive(Copy(Bad))] //~ ERROR expected one of `)`, `,`, or `::`, found `(`\n struct Test1;\n \n-#[derive(Copy=\"bad\")]\n-//~^ ERROR expected one of `)`, `,`, or `::`, found `=`\n+#[derive(Copy=\"bad\")] //~ ERROR expected one of `)`, `,`, or `::`, found `=`\n struct Test2;\n \n-#[derive()]\n-//~^ WARNING empty trait list\n+#[derive()] //~ WARNING empty trait list\n struct Test3;\n \n-#[derive]\n-//~^ ERROR attribute must be of the form\n+#[derive] //~ ERROR bad `derive` attribute\n struct Test4;\n \n fn main() {}"}, {"sha": "aa1334d21a86a53c41ed006942b9599876b13816", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -5,22 +5,24 @@ LL | #[derive(Copy(Bad))]\n    |              ^ expected one of `)`, `,`, or `::` here\n \n error: expected one of `)`, `,`, or `::`, found `=`\n-  --> $DIR/malformed-derive-entry.rs:5:14\n+  --> $DIR/malformed-derive-entry.rs:4:14\n    |\n LL | #[derive(Copy=\"bad\")]\n    |              ^ expected one of `)`, `,`, or `::` here\n \n warning: empty trait list in `derive`\n-  --> $DIR/malformed-derive-entry.rs:9:1\n+  --> $DIR/malformed-derive-entry.rs:7:1\n    |\n LL | #[derive()]\n    | ^^^^^^^^^^^\n \n-error: attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n-  --> $DIR/malformed-derive-entry.rs:13:1\n+error: bad `derive` attribute\n+  --> $DIR/malformed-derive-entry.rs:10:1\n    |\n LL | #[derive]\n-   | ^^^^^^^^^\n+   | ^^^^^^^^^ missing traits to be derived\n+   |\n+   = note: `derive` must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "5f1c4795a89b0e883d3b65b997706094c7cbdeec", "filename": "src/test/ui/malformed/malformed-special-attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -1,13 +1,13 @@\n-#[cfg_attr] //~ ERROR expected `(`, found `<eof>`\n+#[cfg_attr] //~ ERROR bad `cfg_attr` attribute\n struct S1;\n \n #[cfg_attr = \"\"] //~ ERROR expected `(`, found `=`\n struct S2;\n \n-#[derive] //~ ERROR attribute must be of the form\n+#[derive] //~ ERROR bad `derive` attribute\n struct S3;\n \n-#[derive = \"\"] //~ ERROR attribute must be of the form\n+#[derive = \"\"] //~ ERROR bad `derive` attribute\n struct S4;\n \n fn main() {}"}, {"sha": "483ecf7338734d49dc5e8821da79e560a636e41a", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -1,25 +1,33 @@\n-error: expected `(`, found `<eof>`\n+error: bad `cfg_attr` attribute\n+  --> $DIR/malformed-special-attrs.rs:1:1\n+   |\n+LL | #[cfg_attr]\n+   | ^^^^^^^^^^^ missing condition and attribute\n+   |\n+   = note: `cfg_attr` must be of the form: `#[cfg_attr(condition, attribute)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected `(`, found `=`\n   --> $DIR/malformed-special-attrs.rs:4:12\n    |\n-LL | #[cfg_attr]\n-   | - expected `(`\n-...\n LL | #[cfg_attr = \"\"]\n-   |            ^ unexpected token\n+   |            ^ expected `(`\n \n-error: attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n+error: bad `derive` attribute\n   --> $DIR/malformed-special-attrs.rs:7:1\n    |\n LL | #[derive]\n-   | ^^^^^^^^^\n+   | ^^^^^^^^^ missing traits to be derived\n+   |\n+   = note: `derive` must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n-error: attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n+error: bad `derive` attribute\n   --> $DIR/malformed-special-attrs.rs:10:1\n    |\n LL | #[derive = \"\"]\n-   | ^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^ missing traits to be derived\n+   |\n+   = note: `derive` must be of the form: `#[derive(Trait1, Trait2, ...)]`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4b6d23890653d44637f1694095c9f593451edb48", "filename": "src/test/ui/parser/bad-macro-argument.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let message = \"world\";\n+    println!(\"Hello, {}\", message/); //~ ERROR expected expression\n+}"}, {"sha": "3cd8accb662948cc4b5d90ff687c3edcee74058a", "filename": "src/test/ui/parser/bad-macro-argument.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-macro-argument.stderr?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -0,0 +1,8 @@\n+error: expected expression, found end of macro arguments\n+  --> $DIR/bad-macro-argument.rs:3:35\n+   |\n+LL |     println!(\"Hello, {}\", message/);\n+   |                                   ^ expected expression\n+\n+error: aborting due to previous error\n+"}, {"sha": "fab98f0ce5ebe68f1411d3681d994d2049785462", "filename": "src/test/ui/proc-macro/attr-invalid-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -9,7 +9,7 @@ use attr_stmt_expr::{duplicate, no_output};\n \n fn main() {\n     let _ = #[no_output] \"Hello, world!\";\n-    //~^ ERROR expected expression, found `<eof>`\n+    //~^ ERROR expected expression, found end of macro arguments\n \n     let _ = #[duplicate] \"Hello, world!\";\n     //~^ ERROR macro expansion ignores token `,` and any following"}, {"sha": "49fe0bd0fcfe280cd9e1f9a81c6ed735ca4bdb7a", "filename": "src/test/ui/proc-macro/attr-invalid-exprs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24160171e48a277ef71e84e14fbffffe3c81438a/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr?ref=24160171e48a277ef71e84e14fbffffe3c81438a", "patch": "@@ -1,4 +1,4 @@\n-error: expected expression, found `<eof>`\n+error: expected expression, found end of macro arguments\n   --> $DIR/attr-invalid-exprs.rs:11:13\n    |\n LL |     let _ = #[no_output] \"Hello, world!\";"}]}