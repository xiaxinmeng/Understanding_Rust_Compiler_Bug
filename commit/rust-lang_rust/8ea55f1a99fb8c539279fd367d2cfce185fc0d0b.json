{"sha": "8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYTU1ZjFhOTlmYjhjNTM5Mjc5ZmQzNjdkMmNmY2UxODVmYzBkMGI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-10T08:26:54Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-21T09:18:01Z"}, "message": "Cache decoded predicate shorthands", "tree": {"sha": "3cbed9babe428c50b8a8e4ba65db82f40f0a8268", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cbed9babe428c50b8a8e4ba65db82f40f0a8268"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "html_url": "https://github.com/rust-lang/rust/commit/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2", "html_url": "https://github.com/rust-lang/rust/commit/228a0ed7b0cef2fbfeb781acf6c23015ccc40ba2"}], "stats": {"total": 189, "additions": 118, "deletions": 71}, "files": [{"sha": "2254d553337d5fed65d94daa7b19b3d40311af0f", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "patch": "@@ -294,15 +294,36 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n \n         let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n \n-        if let Some(&ty) = tcx.rcache.borrow().get(&key) {\n+        if let Some(&ty) = tcx.ty_rcache.borrow().get(&key) {\n             return Ok(ty);\n         }\n \n         let ty = or_insert_with(self)?;\n-        tcx.rcache.borrow_mut().insert(key, ty);\n+        tcx.ty_rcache.borrow_mut().insert(key, ty);\n         Ok(ty)\n     }\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n+    {\n+        let tcx = self.tcx();\n+\n+        let key = ty::CReaderCacheKey { cnum: self.cdata().cnum, pos: shorthand };\n+\n+        if let Some(&pred) = tcx.pred_rcache.borrow().get(&key) {\n+            return Ok(pred);\n+        }\n+\n+        let pred = or_insert_with(self)?;\n+        tcx.pred_rcache.borrow_mut().insert(key, pred);\n+        Ok(pred)\n+    }\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "d01c767e2bc044219b9c74695c9370e69c90e33c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "patch": "@@ -239,6 +239,17 @@ where\n     }\n }\n \n+impl<'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'tcx> {\n+    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(predicate).is_some());\n+        let predicate =\n+            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n+        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n+            &mut encoder.predicate_shorthands\n+        })\n+    }\n+}\n+\n impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -256,22 +267,6 @@ impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> SpecializedEncoder<&'a [(ty::Predicate<'b>, Span)]> for EncodeContext<'tcx> {\n-    fn specialized_encode(\n-        &mut self,\n-        predicates: &&'a [(ty::Predicate<'b>, Span)],\n-    ) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(*predicates).is_some());\n-        let predicates = unsafe {\n-            std::mem::transmute::<\n-                &&'a [(ty::Predicate<'b>, Span)],\n-                &&'tcx [(ty::Predicate<'tcx>, Span)],\n-            >(predicates)\n-        };\n-        ty_codec::encode_spanned_predicates(self, &predicates, |ecx| &mut ecx.predicate_shorthands)\n-    }\n-}\n-\n impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.opaque)"}, {"sha": "67ceaca103e9f172333b2f34a74bad96d067d64d", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{self, interpret::Allocation};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, ToPredicate, Ty, TyCtxt};\n+use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n@@ -95,23 +95,6 @@ where\n     Ok(())\n }\n \n-pub fn encode_spanned_predicates<'tcx, E, C>(\n-    encoder: &mut E,\n-    predicates: &[(ty::Predicate<'tcx>, Span)],\n-    cache: C,\n-) -> Result<(), E::Error>\n-where\n-    E: TyEncoder,\n-    C: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<ty::Predicate<'tcx>, usize>,\n-{\n-    predicates.len().encode(encoder)?;\n-    for (predicate, span) in predicates {\n-        encode_with_shorthand(encoder, predicate, &cache)?;\n-        span.encode(encoder)?;\n-    }\n-    Ok(())\n-}\n-\n pub trait TyDecoder<'tcx>: Decoder {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n@@ -127,6 +110,14 @@ pub trait TyDecoder<'tcx>: Decoder {\n     where\n         F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>;\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R;\n@@ -188,6 +179,26 @@ where\n     }\n }\n \n+#[inline]\n+pub fn decode_predicate<D>(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n+{\n+    // Handle shorthands first, if we have an usize > 0x80.\n+    if decoder.positioned_at_shorthand() {\n+        let pos = decoder.read_usize()?;\n+        assert!(pos >= SHORTHAND_OFFSET);\n+        let shorthand = pos - SHORTHAND_OFFSET;\n+\n+        decoder.cached_predicate_for_shorthand(shorthand, |decoder| {\n+            decoder.with_position(shorthand, ty::Predicate::decode)\n+        })\n+    } else {\n+        let tcx = decoder.tcx();\n+        Ok(tcx.mk_predicate(ty::PredicateKind::decode(decoder)?))\n+    }\n+}\n+\n #[inline]\n pub fn decode_spanned_predicates<D>(\n     decoder: &mut D,\n@@ -198,20 +209,7 @@ where\n     let tcx = decoder.tcx();\n     Ok(tcx.arena.alloc_from_iter(\n         (0..decoder.read_usize()?)\n-            .map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate_kind = if decoder.positioned_at_shorthand() {\n-                    let pos = decoder.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let shorthand = pos - SHORTHAND_OFFSET;\n-\n-                    decoder.with_position(shorthand, ty::PredicateKind::decode)\n-                } else {\n-                    ty::PredicateKind::decode(decoder)\n-                }?;\n-                let predicate = predicate_kind.to_predicate(tcx);\n-                Ok((predicate, Decodable::decode(decoder)?))\n-            })\n+            .map(|_| Decodable::decode(decoder))\n             .collect::<Result<Vec<_>, _>>()?,\n     ))\n }\n@@ -421,7 +419,6 @@ macro_rules! implement_ty_decoder {\n             // FIXME(#36588): These impls are horribly unsound as they allow\n             // the caller to pick any lifetime for `'tcx`, including `'static`.\n \n-            rustc_hir::arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n \n             impl<$($typaram),*> SpecializedDecoder<CrateNum>\n@@ -436,7 +433,24 @@ macro_rules! implement_ty_decoder {\n             where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n             {\n                 fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n-                    unsafe { transmute::<Result<ty::Ty<'tcx>, Self::Error>, Result<&'_x ty::TyS<'_y>, Self::Error>>(decode_ty(self)) }\n+                    unsafe {\n+                        transmute::<\n+                            Result<ty::Ty<'tcx>, Self::Error>,\n+                            Result<&'_x ty::TyS<'_y>, Self::Error>,\n+                        >(decode_ty(self))\n+                    }\n+                }\n+            }\n+\n+            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Predicate<'_x>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<ty::Predicate<'_x>, Self::Error> {\n+                    unsafe {\n+                        transmute::<\n+                            Result<ty::Predicate<'tcx>, Self::Error>,\n+                            Result<ty::Predicate<'_x>, Self::Error>,\n+                        >(decode_predicate(self))\n+                    }\n                 }\n             }\n "}, {"sha": "1b909b42fdf604e79cb015468b0d388c0c144062", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "patch": "@@ -938,8 +938,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n \n-    // Internal cache for metadata decoding. No need to track deps on this.\n-    pub rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    // Internal caches for metadata decoding. No need to track deps on this.\n+    pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub pred_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Predicate<'tcx>>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n@@ -1128,7 +1129,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             definitions,\n             def_path_hash_to_def_id,\n             queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n-            rcache: Default::default(),\n+            ty_rcache: Default::default(),\n+            pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n             crate_name: Symbol::intern(crate_name),"}, {"sha": "c84a7c38d0a0e70f5417b0a7ff986f78ba9a73c1", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea55f1a99fb8c539279fd367d2cfce185fc0d0b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=8ea55f1a99fb8c539279fd367d2cfce185fc0d0b", "patch": "@@ -524,16 +524,39 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         let cache_key =\n             ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n \n-        if let Some(&ty) = tcx.rcache.borrow().get(&cache_key) {\n+        if let Some(&ty) = tcx.ty_rcache.borrow().get(&cache_key) {\n             return Ok(ty);\n         }\n \n         let ty = or_insert_with(self)?;\n         // This may overwrite the entry, but it should overwrite with the same value.\n-        tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n+        tcx.ty_rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n \n+    fn cached_predicate_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> Result<ty::Predicate<'tcx>, Self::Error>\n+    where\n+        F: FnOnce(&mut Self) -> Result<ty::Predicate<'tcx>, Self::Error>,\n+    {\n+        let tcx = self.tcx();\n+\n+        let cache_key =\n+            ty::CReaderCacheKey { cnum: CrateNum::ReservedForIncrCompCache, pos: shorthand };\n+\n+        if let Some(&pred) = tcx.pred_rcache.borrow().get(&cache_key) {\n+            return Ok(pred);\n+        }\n+\n+        let pred = or_insert_with(self)?;\n+        // This may overwrite the entry, but it should overwrite with the same value.\n+        tcx.pred_rcache.borrow_mut().insert_same(cache_key, pred);\n+        Ok(pred)\n+    }\n+\n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -820,24 +843,16 @@ where\n     }\n }\n \n-impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b [(ty::Predicate<'c>, Span)]>\n-    for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'b, 'tcx, E> SpecializedEncoder<ty::Predicate<'b>> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,\n {\n     #[inline]\n-    fn specialized_encode(\n-        &mut self,\n-        predicates: &&'b [(ty::Predicate<'c>, Span)],\n-    ) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(*predicates).is_some());\n-        let predicates = unsafe {\n-            std::mem::transmute::<\n-                &&'b [(ty::Predicate<'c>, Span)],\n-                &&'tcx [(ty::Predicate<'tcx>, Span)],\n-            >(predicates)\n-        };\n-        ty_codec::encode_spanned_predicates(self, predicates, |encoder| {\n+    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n+        debug_assert!(self.tcx.lift(predicate).is_some());\n+        let predicate =\n+            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n+        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n             &mut encoder.predicate_shorthands\n         })\n     }"}]}