{"sha": "168c14a1a59de279534c09a1b4e23b3b7f8f774d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OGMxNGExYTU5ZGUyNzk1MzRjMDlhMWI0ZTIzYjNiN2Y4Zjc3NGQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-10T09:53:52Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-13T18:50:46Z"}, "message": "Avoid propagating redundant outlives constraints from closures", "tree": {"sha": "d3b7fb5e5f0412a339c9c4b6c6867faf8a52f034", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b7fb5e5f0412a339c9c4b6c6867faf8a52f034"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/168c14a1a59de279534c09a1b4e23b3b7f8f774d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/168c14a1a59de279534c09a1b4e23b3b7f8f774d", "html_url": "https://github.com/rust-lang/rust/commit/168c14a1a59de279534c09a1b4e23b3b7f8f774d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/168c14a1a59de279534c09a1b4e23b3b7f8f774d/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e54494727855cd14229f5d456591ed2a2f027c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e54494727855cd14229f5d456591ed2a2f027c46", "html_url": "https://github.com/rust-lang/rust/commit/e54494727855cd14229f5d456591ed2a2f027c46"}], "stats": {"total": 142, "additions": 93, "deletions": 49}, "files": [{"sha": "7a0cd2ac26c3bfeab86979093eda1e8d0f6137c1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 93, "deletions": 49, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/168c14a1a59de279534c09a1b4e23b3b7f8f774d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/168c14a1a59de279534c09a1b4e23b3b7f8f774d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=168c14a1a59de279534c09a1b4e23b3b7f8f774d", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::{\n     ConstraintCategory, Local, Location, Mir,\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n-use rustc::util::common;\n+use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n@@ -1157,63 +1157,107 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .is_none()\n         );\n \n+        // Only check all of the relations for the main representative of each\n+        // SCC, otherwise just check that we outlive said representative. This\n+        // reduces the number of redundant relations propagated out of\n+        // closures.\n+        // Note that the representative will be a universal region if there is\n+        // one in this SCC, so we will always check the representative here.\n+        let representative = self.scc_representatives[longer_fr_scc];\n+        if representative != longer_fr {\n+            self.check_universal_region_relation(\n+                longer_fr,\n+                representative,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            );\n+            return;\n+        }\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n-            // If it is known that `fr: o`, carry on.\n-            if self.universal_region_relations\n-                .outlives(longer_fr, shorter_fr)\n-            {\n-                continue;\n+            if let Some(ErrorReported) = self.check_universal_region_relation(\n+                longer_fr,\n+                shorter_fr,\n+                infcx,\n+                mir,\n+                mir_def_id,\n+                propagated_outlives_requirements,\n+                errors_buffer,\n+            ) {\n+                // continuing to iterate just reports more errors than necessary\n+                return;\n             }\n+        }\n+    }\n \n-            debug!(\n-                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n-                longer_fr, shorter_fr,\n-            );\n+    fn check_universal_region_relation(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+    ) -> Option<ErrorReported> {\n+        // If it is known that `fr: o`, carry on.\n+        if self.universal_region_relations\n+            .outlives(longer_fr, shorter_fr)\n+        {\n+            return None;\n+        }\n \n-            let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n-\n-            if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n-                // Shrink `fr` until we find a non-local region (if we do).\n-                // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_region_relations\n-                    .non_local_lower_bound(longer_fr)\n-                {\n-                    debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n-\n-                    // Grow `shorter_fr` until we find a non-local\n-                    // region. (We always will.)  We'll call that\n-                    // `shorter_fr+` -- it's ever so slightly larger than\n-                    // `fr`.\n-                    let shorter_fr_plus = self.universal_region_relations\n-                        .non_local_upper_bound(shorter_fr);\n-                    debug!(\n-                        \"check_universal_region: shorter_fr_plus={:?}\",\n-                        shorter_fr_plus\n-                    );\n+        debug!(\n+            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            longer_fr, shorter_fr,\n+        );\n \n-                    // Push the constraint `fr-: shorter_fr+`\n-                    propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n-                        subject: ClosureOutlivesSubject::Region(fr_minus),\n-                        outlived_free_region: shorter_fr_plus,\n-                        blame_span: blame_span_category.1,\n-                        category: blame_span_category.0,\n-                    });\n-                    continue;\n-                }\n-            }\n \n-            // If we are not in a context where we can propagate\n-            // errors, or we could not shrink `fr` to something\n-            // smaller, then just report an error.\n-            //\n-            // Note: in this case, we use the unapproximated regions\n-            // to report the error. This gives better error messages\n-            // in some cases.\n-            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n-            return; // continuing to iterate just reports more errors than necessary\n+        if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n+            // Shrink `fr` until we find a non-local region (if we do).\n+            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+            if let Some(fr_minus) = self.universal_region_relations\n+                .non_local_lower_bound(longer_fr)\n+            {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n+\n+                // Grow `shorter_fr` until we find a non-local\n+                // region. (We always will.)  We'll call that\n+                // `shorter_fr+` -- it's ever so slightly larger than\n+                // `fr`.\n+                let shorter_fr_plus = self.universal_region_relations\n+                    .non_local_upper_bound(shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n+                );\n+\n+                // Push the constraint `fr-: shorter_fr+`\n+                propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                    subject: ClosureOutlivesSubject::Region(fr_minus),\n+                    outlived_free_region: shorter_fr_plus,\n+                    blame_span: blame_span_category.1,\n+                    category: blame_span_category.0,\n+                });\n+                return None;\n+            }\n         }\n+\n+        // If we are not in a context where we can't propagate errors, or we\n+        // could not shrink `fr` to something smaller, then just report an\n+        // error.\n+        //\n+        // Note: in this case, we use the unapproximated regions to report the\n+        // error. This gives better error messages in some cases.\n+        self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        Some(ErrorReported)\n     }\n \n     fn check_bound_universal_region<'gcx>("}]}