{"sha": "d92a88bf09e89575710915eeec1541bea8df4e88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MmE4OGJmMDllODk1NzU3MTA5MTVlZWVjMTU0MWJlYThkZjRlODg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T18:41:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T18:41:36Z"}, "message": "remove lifetime from syntax node text", "tree": {"sha": "7546061affcf551243a810c2f81a9918a8441515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7546061affcf551243a810c2f81a9918a8441515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d92a88bf09e89575710915eeec1541bea8df4e88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d92a88bf09e89575710915eeec1541bea8df4e88", "html_url": "https://github.com/rust-lang/rust/commit/d92a88bf09e89575710915eeec1541bea8df4e88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d92a88bf09e89575710915eeec1541bea8df4e88/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "002529937075bd69d7f71483d798d6e4f43d1de9", "url": "https://api.github.com/repos/rust-lang/rust/commits/002529937075bd69d7f71483d798d6e4f43d1de9", "html_url": "https://github.com/rust-lang/rust/commit/002529937075bd69d7f71483d798d6e4f43d1de9"}], "stats": {"total": 29, "additions": 15, "deletions": 14}, "files": [{"sha": "604abe5c6ca3b36c609ea24c0e3a757c0bcb2f06", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d92a88bf09e89575710915eeec1541bea8df4e88", "patch": "@@ -238,7 +238,7 @@ fn api_walkthrough() {\n \n     // You can get node's text as a `SyntaxText` object, which will traverse the\n     // tree collecting token's text:\n-    let text: SyntaxText<'_> = expr_syntax.text();\n+    let text: SyntaxText = expr_syntax.text();\n     assert_eq!(text.to_string(), \"1 + 1\");\n \n     // There's a bunch of traversal methods on `SyntaxNode`:"}, {"sha": "51bae04de7703245e572d9b3b6f39d8e811e16e2", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=d92a88bf09e89575710915eeec1541bea8df4e88", "patch": "@@ -68,7 +68,7 @@ impl SyntaxNode {\n     }\n \n     pub fn text(&self) -> SyntaxText {\n-        SyntaxText::new(self)\n+        SyntaxText::new(self.clone())\n     }\n \n     pub fn parent(&self) -> Option<SyntaxNode> {"}, {"sha": "2ad98809b48737d529a249e39a994b338d26741d", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92a88bf09e89575710915eeec1541bea8df4e88/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=d92a88bf09e89575710915eeec1541bea8df4e88", "patch": "@@ -6,14 +6,15 @@ use std::{\n use crate::{SmolStr, SyntaxElement, SyntaxNode, TextRange, TextUnit};\n \n #[derive(Clone)]\n-pub struct SyntaxText<'a> {\n-    node: &'a SyntaxNode,\n+pub struct SyntaxText {\n+    node: SyntaxNode,\n     range: TextRange,\n }\n \n-impl<'a> SyntaxText<'a> {\n-    pub(crate) fn new(node: &'a SyntaxNode) -> SyntaxText<'a> {\n-        SyntaxText { node, range: node.range() }\n+impl SyntaxText {\n+    pub(crate) fn new(node: SyntaxNode) -> SyntaxText {\n+        let range = node.range();\n+        SyntaxText { node, range }\n     }\n \n     pub fn try_fold_chunks<T, F, E>(&self, init: T, mut f: F) -> Result<T, E>\n@@ -95,7 +96,7 @@ impl<'a> SyntaxText<'a> {\n         self.range.is_empty()\n     }\n \n-    pub fn slice(&self, range: impl ops::RangeBounds<TextUnit>) -> SyntaxText<'a> {\n+    pub fn slice(&self, range: impl ops::RangeBounds<TextUnit>) -> SyntaxText {\n         let start = match range.start_bound() {\n             Bound::Included(&b) => b,\n             Bound::Excluded(_) => panic!(\"utf-aware slicing can't work this way\"),\n@@ -123,7 +124,7 @@ impl<'a> SyntaxText<'a> {\n             self.range,\n             range,\n         );\n-        SyntaxText { node: self.node, range }\n+        SyntaxText { node: self.node.clone(), range }\n     }\n \n     pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n@@ -149,25 +150,25 @@ fn found<T>(res: Result<(), T>) -> Option<T> {\n     }\n }\n \n-impl<'a> fmt::Debug for SyntaxText<'a> {\n+impl fmt::Debug for SyntaxText {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&self.to_string(), f)\n     }\n }\n \n-impl<'a> fmt::Display for SyntaxText<'a> {\n+impl fmt::Display for SyntaxText {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&self.to_string(), f)\n     }\n }\n \n-impl From<SyntaxText<'_>> for String {\n+impl From<SyntaxText> for String {\n     fn from(text: SyntaxText) -> String {\n         text.to_string()\n     }\n }\n \n-impl PartialEq<str> for SyntaxText<'_> {\n+impl PartialEq<str> for SyntaxText {\n     fn eq(&self, mut rhs: &str) -> bool {\n         self.try_for_each_chunk(|chunk| {\n             if !rhs.starts_with(chunk) {\n@@ -180,7 +181,7 @@ impl PartialEq<str> for SyntaxText<'_> {\n     }\n }\n \n-impl PartialEq<&'_ str> for SyntaxText<'_> {\n+impl PartialEq<&'_ str> for SyntaxText {\n     fn eq(&self, rhs: &&str) -> bool {\n         self == *rhs\n     }"}]}