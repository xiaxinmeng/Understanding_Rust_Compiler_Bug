{"sha": "ac948b4ccd485f12019f0b1d11359990725dfab5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTQ4YjRjY2Q0ODVmMTIwMTlmMGIxZDExMzU5OTkwNzI1ZGZhYjU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-06-28T23:11:41Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-26T19:30:14Z"}, "message": "Resolve and typecheck alias-environment-capturing blocks.", "tree": {"sha": "d186caf92fdc31a3db3725ec7acb805c4767396c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d186caf92fdc31a3db3725ec7acb805c4767396c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac948b4ccd485f12019f0b1d11359990725dfab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac948b4ccd485f12019f0b1d11359990725dfab5", "html_url": "https://github.com/rust-lang/rust/commit/ac948b4ccd485f12019f0b1d11359990725dfab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac948b4ccd485f12019f0b1d11359990725dfab5/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c8fa79312e4c357bd234df5112ceba75ef0dd34", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8fa79312e4c357bd234df5112ceba75ef0dd34", "html_url": "https://github.com/rust-lang/rust/commit/8c8fa79312e4c357bd234df5112ceba75ef0dd34"}], "stats": {"total": 141, "additions": 107, "deletions": 34}, "files": [{"sha": "f08fd5b8f3f901585b0eafcf5b5b73ae5bb4db9d", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=ac948b4ccd485f12019f0b1d11359990725dfab5", "patch": "@@ -250,6 +250,11 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             ret ty::mk_fn(st.tcx, ast::proto_iter, func.args, func.ty,\n                           func.cf, func.cs);\n         }\n+        case ('B') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty::mk_fn(st.tcx, ast::proto_block, func.args, func.ty,\n+                          func.cf, func.cs);\n+        }\n         case ('N') {\n             auto abi;\n             alt (next(st) as char) {"}, {"sha": "2935e244c4f94519c95a8458fc5fe7c45f84c2e1", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=ac948b4ccd485f12019f0b1d11359990725dfab5", "patch": "@@ -200,6 +200,7 @@ fn enc_proto(&ioivec::writer w, proto proto) {\n     alt (proto) {\n         case (proto_iter) { w.write_char('W'); }\n         case (proto_fn) { w.write_char('F'); }\n+        case (proto_block) { w.write_char('B'); }\n     }\n }\n "}, {"sha": "46b1568889808744e43e9f305a891934adfdce10", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=ac948b4ccd485f12019f0b1d11359990725dfab5", "patch": "@@ -49,7 +49,7 @@ export def_map;\n tag scope {\n     scope_crate;\n     scope_item(@ast::item);\n-    scope_fn(ast::fn_decl, ast::ty_param[]);\n+    scope_fn(ast::fn_decl, ast::proto, ast::ty_param[]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::blk);\n@@ -360,7 +360,7 @@ fn visit_fn_with_scope(&@env e, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n         resolve_constr(e, id, c, sc, v);\n     }\n     visit::visit_fn(f, tp, sp, name, id,\n-                    cons(scope_fn(f.decl, tp), @sc), v);\n+                    cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n }\n \n fn visit_block_with_scope(&ast::blk b, &scopes sc, &vt[scopes] v) {\n@@ -381,7 +381,7 @@ fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n         v.visit_block(blk, new_sc, v);\n       }\n       ast::expr_fn(?f) {\n-        visit::visit_expr(x, cons(scope_fn(f.decl, ~[]), @sc), v);\n+        visit::visit_expr(x, cons(scope_fn(f.decl, f.proto, ~[]), @sc), v);\n       }\n       _ { visit::visit_expr(x, sc, v); }\n     };\n@@ -536,7 +536,7 @@ fn unresolved_err(&env e, &scopes sc, &span sp, &ident name, &str kind) {\n             alt sc {\n               cons(?cur, ?rest) {\n                 alt cur {\n-                  scope_crate | scope_fn(_, _) |\n+                  scope_crate | scope_fn(_, _, _) |\n                   scope_item(@{node: ast::item_mod(_), _}) {\n                     ret cur;\n                   }\n@@ -602,9 +602,11 @@ fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident name,\n \n fn scope_is_fn(&scope sc) -> bool {\n     ret alt (sc) {\n-            scope_fn(_, _) | scope_native_item(_) { true }\n-            _ { false }\n-        };\n+        scope_fn(_, ast::proto_iter, _) |\n+            scope_fn(_, ast::proto_fn, _) |\n+            scope_native_item(_) { true }\n+        _ { false }\n+    };\n }\n \n fn def_is_local(&def d) -> bool {\n@@ -663,7 +665,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n                     }\n                 }\n             }\n-            case (scope_fn(?decl, ?ty_params)) {\n+            case (scope_fn(?decl, _, ?ty_params)) {\n                 ret lookup_in_fn(name, decl, ty_params, ns);\n             }\n             case (scope_loop(?local)) {"}, {"sha": "6c29b204da91f0aa28e113d25228933eb7d5ef2c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ac948b4ccd485f12019f0b1d11359990725dfab5", "patch": "@@ -889,6 +889,7 @@ fn type_is_structural(&ctxt cx, &t ty) -> bool {\n fn type_is_copyable(&ctxt cx, &t ty) -> bool {\n     ret alt (struct(cx, ty)) {\n         case (ty_res(_, _, _)) { false }\n+        case (ty_fn(proto_block, _, _, _, _)) { false }\n         case (_) { true }\n     };\n }"}, {"sha": "a205ebf18cbc6ed2c25aa08fc40714a67fbefca0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 90, "deletions": 26, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac948b4ccd485f12019f0b1d11359990725dfab5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ac948b4ccd485f12019f0b1d11359990725dfab5", "patch": "@@ -65,10 +65,13 @@ type crate_ctxt = rec(mutable obj_info[] obj_infos, ty::ctxt tcx);\n type fn_ctxt =\n     rec(ty::t ret_ty,\n         ast::purity purity,\n+        // var_bindings, locals, local_names, and next_var_id are shared\n+        // with any nested functions that capture the environment\n+        // (and with any functions whose environment is being captured).\n         @ty::unify::var_bindings var_bindings,\n         hashmap[ast::node_id, int] locals,\n         hashmap[ast::node_id, ast::ident] local_names,\n-        mutable int next_var_id,\n+        @mutable int next_var_id,\n         mutable ast::node_id[] fixups,\n         @crate_ctxt ccx);\n \n@@ -237,6 +240,18 @@ fn structure_of(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::sty {\n     ret ty::struct(fcx.ccx.tcx, structurally_resolved_type(fcx, sp, typ));\n }\n \n+// Returns the one-level-deep structure of the given type or none if it\n+// is not known yet.\n+fn structure_of_maybe(&@fn_ctxt fcx, &span sp, ty::t typ)\n+    -> option::t[ty::sty] {\n+    auto r =\n+        ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n+    ret alt (r) {\n+      case (fix_ok(?typ_s)) { some(ty::struct(fcx.ccx.tcx, typ_s)) }\n+      case (fix_err(_)) { none }\n+    }\n+}\n+\n fn type_is_integral(&@fn_ctxt fcx, &span sp, ty::t typ) -> bool {\n     auto typ_s = structurally_resolved_type(fcx, sp, typ);\n     ret ty::type_is_integral(fcx.ccx.tcx, typ_s);\n@@ -470,6 +485,15 @@ mod write {\n     }\n }\n \n+// Determine the proto for a fn type given the proto for its associated\n+// code. This is needed because fn and lambda have fn type while iter\n+// has iter type and block has block type. This may end up changing.\n+fn proto_to_ty_proto(&ast::proto proto) -> ast::proto {\n+    ret alt (proto) {\n+        ast::proto_iter | ast::proto_block { proto }\n+        _ { ast::proto_fn }\n+    };\n+}\n \n // Item collection - a pair of bootstrap passes:\n //\n@@ -511,8 +535,8 @@ mod collect {\n             out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n         auto t_fn =\n-            ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n-                      out_constrs);\n+            ty::mk_fn(cx.tcx, proto_to_ty_proto(proto), input_tys,\n+                      output_ty, decl.cf, out_constrs);\n         auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n         auto tpt = rec(count=ty_param_count, ty=t_fn);\n         alt (def_id) {\n@@ -590,9 +614,9 @@ mod collect {\n         for (@ast::constr constr in m.node.meth.decl.constraints) {\n             out_constrs += ~[ty::ast_constr_to_constr(cx.tcx, constr)];\n         }\n-        ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n-                inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n-                constrs=out_constrs);\n+        ret rec(proto=proto_to_ty_proto(m.node.meth.proto),\n+                ident=m.node.ident, inputs=inputs, output=output,\n+                cf=m.node.meth.decl.cf, constrs=out_constrs);\n     }\n     fn ty_of_obj(@ctxt cx, &ast::ident id, &ast::_obj ob,\n                  &ast::ty_param[] ty_params) -> ty::ty_param_count_and_ty {\n@@ -872,7 +896,7 @@ mod unify {\n     }\n }\n \n-tag autoderef_kind { AUTODEREF_OK; NO_AUTODEREF; }\n+tag autoderef_kind { AUTODEREF_OK; NO_AUTODEREF; AUTODEREF_BLOCK_COERCE; }\n \n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n@@ -917,6 +941,29 @@ fn count_boxes(&@fn_ctxt fcx, &span sp, &ty::t t) -> uint {\n     fail;\n }\n \n+fn do_fn_block_coerce(&@fn_ctxt fcx, &span sp,\n+                      &ty::t actual, &ty::t expected) -> ty::t {\n+    // fns can be silently coerced to blocks when being used as\n+    // function call or bind arguments, but not the reverse.\n+    // If our actual type is a fn and our expected type is a block,\n+    // build up a new expected type that is identical to the old one\n+    // except for its proto. If we don't know the expected or actual\n+    // types, that's fine, but we can't do the coercion.\n+    ret alt (structure_of_maybe(fcx, sp, actual)) {\n+      some(ty::ty_fn(ast::proto_fn, ?args, ?ret_ty, ?cf, ?constrs)) {\n+        alt (structure_of_maybe(fcx, sp, expected)) {\n+          some(ty::ty_fn(ast::proto_block, _, _, _, _)) {\n+            ty::mk_fn(fcx.ccx.tcx,\n+                      ast::proto_block, args, ret_ty, cf, constrs)\n+          }\n+          _ { actual }\n+        }\n+      }\n+      _ { actual }\n+    }\n+}\n+\n+\n fn resolve_type_vars_if_possible(&@fn_ctxt fcx, ty::t typ) -> ty::t {\n     alt (ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ)) {\n         case (fix_ok(?new_type)) { ret new_type; }\n@@ -951,6 +998,8 @@ mod demand {\n             expected_1 = do_autoderef(fcx, sp, expected_1);\n             actual_1 = do_autoderef(fcx, sp, actual_1);\n             implicit_boxes = count_boxes(fcx, sp, actual);\n+        } else if (adk == AUTODEREF_BLOCK_COERCE) {\n+            actual_1 = do_fn_block_coerce(fcx, sp, actual, expected);\n         }\n         let ty::t[mutable] ty_param_substs = ~[mutable];\n         let int[] ty_param_subst_var_ids = ~[];\n@@ -1175,11 +1224,12 @@ type gather_result =\n     rec(@ty::unify::var_bindings var_bindings,\n         hashmap[ast::node_id, int] locals,\n         hashmap[ast::node_id, ast::ident] local_names,\n-        int next_var_id);\n+        @mutable int next_var_id);\n \n // Used only as a helper for check_fn.\n fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n-                 &ast::node_id id) -> gather_result {\n+                 &ast::node_id id, &option::t[@fn_ctxt] old_fcx)\n+    -> gather_result {\n     fn next_var_id(@mutable int nvi) -> int {\n         auto rv = *nvi;\n         *nvi += 1;\n@@ -1201,10 +1251,22 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n             }\n         }\n     }\n-    auto vb = ty::unify::mk_var_bindings();\n-    auto locals = new_int_hash[int]();\n-    auto local_names = new_int_hash[ast::ident]();\n-    auto nvi = @mutable 0;\n+\n+    auto vb; auto locals; auto local_names; auto nvi;\n+    alt (old_fcx) {\n+        none {\n+            vb = ty::unify::mk_var_bindings();\n+            locals = new_int_hash[int]();\n+            local_names = new_int_hash[ast::ident]();\n+            nvi = @mutable 0;\n+        }\n+        some(?fcx) {\n+            vb = fcx.var_bindings;\n+            locals = fcx.locals;\n+            local_names = fcx.local_names;\n+            nvi = fcx.next_var_id;\n+        }\n+    }\n \n     // Add object fields, if any.\n     auto obj_fields = ~[];\n@@ -1288,7 +1350,7 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n     ret rec(var_bindings=vb,\n             locals=locals,\n             local_names=local_names,\n-            next_var_id=*nvi);\n+            next_var_id=nvi);\n }\n \n // AST fragment checking\n@@ -1555,8 +1617,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             alt (a_opt) {\n                 case (some(?a)) {\n                     check_expr(fcx, a);\n-                    demand::simple(fcx, a.span, arg_tys.(i).ty,\n-                                   expr_ty(fcx.ccx.tcx, a));\n+                    demand::full(fcx, a.span, arg_tys.(i).ty,\n+                                 expr_ty(fcx.ccx.tcx, a), ~[],\n+                                 AUTODEREF_BLOCK_COERCE);\n                 }\n                 case (none) {\n                     check_ty_vars = true;\n@@ -2013,7 +2076,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n                                        f.proto, ~[], none).ty;\n             write::ty_only_fixup(fcx, id, fty);\n-            check_fn(fcx.ccx, f, id);\n+            check_fn(fcx.ccx, f, id, some(fcx));\n         }\n         case (ast::expr_block(?b)) {\n             check_block(fcx, b);\n@@ -2487,8 +2550,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n }\n \n fn next_ty_var_id(@fn_ctxt fcx) -> int {\n-    auto id = fcx.next_var_id;\n-    fcx.next_var_id += 1;\n+    auto id = *fcx.next_var_id;\n+    *fcx.next_var_id = fcx.next_var_id + 1;\n     ret id;\n }\n \n@@ -2586,24 +2649,25 @@ fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::node_id id) {\n              var_bindings=ty::unify::mk_var_bindings(),\n              locals=new_int_hash[int](),\n              local_names=new_int_hash[ast::ident](),\n-             mutable next_var_id=0,\n+             next_var_id=@mutable 0,\n              mutable fixups=fixups,\n              ccx=ccx);\n     check_expr(fcx, e);\n }\n \n-fn check_fn(&@crate_ctxt ccx, &ast::_fn f, &ast::node_id id) {\n+fn check_fn(&@crate_ctxt ccx, &ast::_fn f, &ast::node_id id,\n+            &option::t[@fn_ctxt] old_fcx) {\n     auto decl = f.decl;\n     auto body = f.body;\n-    auto gather_result = gather_locals(ccx, f, id);\n+    auto gather_result = gather_locals(ccx, f, id, old_fcx);\n     let ast::node_id[] fixups = ~[];\n     let @fn_ctxt fcx =\n         @rec(ret_ty=ast_ty_to_ty_crate(ccx, decl.output),\n              purity=decl.purity,\n              var_bindings=gather_result.var_bindings,\n              locals=gather_result.locals,\n              local_names=gather_result.local_names,\n-             mutable next_var_id=gather_result.next_var_id,\n+             next_var_id=gather_result.next_var_id,\n              mutable fixups=fixups,\n              ccx=ccx);\n \n@@ -2636,7 +2700,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::_fn f, &ast::node_id id) {\n }\n \n fn check_method(&@crate_ctxt ccx, &@ast::method method) {\n-    check_fn(ccx, method.node.meth, method.node.id);\n+    check_fn(ccx, method.node.meth, method.node.id, none);\n }\n \n fn check_item(@crate_ctxt ccx, &@ast::item it) {\n@@ -2645,10 +2709,10 @@ fn check_item(@crate_ctxt ccx, &@ast::item it) {\n             check_const(ccx, it.span, e, it.id);\n         }\n         case (ast::item_fn(?f, _)) {\n-            check_fn(ccx, f, it.id);\n+            check_fn(ccx, f, it.id, none);\n         }\n         case (ast::item_res(?f, ?dtor_id, _, _)) {\n-            check_fn(ccx, f, dtor_id);\n+            check_fn(ccx, f, dtor_id, none);\n         }\n         case (ast::item_obj(?ob, _, _)) {\n             // We're entering an object, so gather up the info we need."}]}