{"sha": "517d361a1f78cf13d589d0f6b94f5ca005bef540", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxN2QzNjFhMWY3OGNmMTNkNTg5ZDBmNmI5NGY1Y2EwMDViZWY1NDA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-27T17:54:56Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-06-27T18:01:59Z"}, "message": "Use an 'approximate' universal upper bound when reporting region errors\n\nFixes #67765\n\nWhen reporting errors during MIR region inference, we sometimes use\n`universal_upper_bound` to obtain a named universal region that we\ncan display to the user. However, this is not always possible - in a\ncase like `fn foo<'a, 'b>() { .. }`, the only upper bound for a region\ncontaining `'a` and `'b` is `'static`. When displaying diagnostics, it's\nusually better to display *some* named region (even if there are\nmultiple involved) rather than fall back to a generic error involving\n`'static`.\n\nThis commit adds a new `approx_universal_upper_bound` method, which\nuses the lowest-numbered universal region if the only alternative is to\nreturn `'static`.", "tree": {"sha": "01b4e4dcce5dbb0ada91a25ada41119a0c9205cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01b4e4dcce5dbb0ada91a25ada41119a0c9205cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/517d361a1f78cf13d589d0f6b94f5ca005bef540", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl73iZgACgkQtAh+UQ6Y\nsWQ74xAAgPasw4pkfMLSU8ae8zxApY77ZY6A8r94XzMQMonHMZzf3qqWUGOl4lWf\nQNw54PzTG7sd4XlXbhMZrP4X/WxYTYd6Wp6hG+QaJ9w2r0NxDD7XRD+si2POLpu4\nIv/1rLGKDMKaqDN8dhxWdSVN6Llsh1maE9xB4TEHcBozR/5kIij2x41Y8cl2IcDN\npeNL/AFFa9tsJgqLIg+BQ+1DBJ/7YJowOnxZoPPgLSfbk2dOtiKcJxHnAtns5MOY\nycownjYtbaqiMalo+5k4UbAorvcdB6blOXtP6yyviKgp8sjdw/EQ0CPYq5Ix/3UW\nBRV9zVBol5SraKAPNpvB+sarTHWYunHSjK3azBMf7H3S2wc0CIXnxn8tjZkFoi/Q\ntY+kwHT8BTCRJ9xcxsUBucYbj0pyMKbzBbSq5w17ZNyZpT+inF7kdE4FDmj6CXZS\n/cKSBz36A/d28D7DARcOc5zDoREi++rUqe0xYgTHdvP5NIRLXaDByrBxLpD5wu7M\nopfuq8Lnw/Iqfj2JwAj4DDqg7RPLxwohaTdSkCRfFod0qENSZ8UlmUvc47OCcIb/\nTbD7a+0rsOuKL3Jb0GK3lLqD9+cPn9gT+V8rJtp9EaYjGpQb7G7ZccMBdN9pvQOe\nYyEAIFnVkCcFD+x1feRElAwWwBZC89dqqPoAARxGVvyiIqU39kg=\n=KT1V\n-----END PGP SIGNATURE-----", "payload": "tree 01b4e4dcce5dbb0ada91a25ada41119a0c9205cc\nparent 394e1b40d264aa6928811919c1124fa248e7d802\nauthor Aaron Hill <aa1ronham@gmail.com> 1593280496 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1593280919 -0400\n\nUse an 'approximate' universal upper bound when reporting region errors\n\nFixes #67765\n\nWhen reporting errors during MIR region inference, we sometimes use\n`universal_upper_bound` to obtain a named universal region that we\ncan display to the user. However, this is not always possible - in a\ncase like `fn foo<'a, 'b>() { .. }`, the only upper bound for a region\ncontaining `'a` and `'b` is `'static`. When displaying diagnostics, it's\nusually better to display *some* named region (even if there are\nmultiple involved) rather than fall back to a generic error involving\n`'static`.\n\nThis commit adds a new `approx_universal_upper_bound` method, which\nuses the lowest-numbered universal region if the only alternative is to\nreturn `'static`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/517d361a1f78cf13d589d0f6b94f5ca005bef540", "html_url": "https://github.com/rust-lang/rust/commit/517d361a1f78cf13d589d0f6b94f5ca005bef540", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/517d361a1f78cf13d589d0f6b94f5ca005bef540/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "394e1b40d264aa6928811919c1124fa248e7d802", "url": "https://api.github.com/repos/rust-lang/rust/commits/394e1b40d264aa6928811919c1124fa248e7d802", "html_url": "https://github.com/rust-lang/rust/commit/394e1b40d264aa6928811919c1124fa248e7d802"}], "stats": {"total": 113, "additions": 101, "deletions": 12}, "files": [{"sha": "fa4846a20cbfb06dbe700bae37509d902f7af2c3", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -122,7 +122,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let upper_bound = self.regioncx.universal_upper_bound(r);\n+            // We just want something nameable, even if it's not\n+            // actually an upper bound.\n+            let upper_bound = self.regioncx.approx_universal_upper_bound(r);\n \n             if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)"}, {"sha": "081125cb625c237a1dca978be4aa403c701412e4", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -1114,6 +1114,40 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lub\n     }\n \n+    /// Like `universal_upper_bound`, but returns an approximation more suitable\n+    /// for diagnostics. If `r` contains multiple disjoint universal regions\n+    /// (e.g. 'a and 'b in `fn foo<'a, 'b> { ... }`, we pick the lower-numbered region.\n+    /// This corresponds to picking named regions over unnamed regions\n+    /// (e.g. picking early-bound regions over a closure late-bound region).\n+    ///\n+    /// This means that the returned value may not be a true upper bound, since\n+    /// only 'static is known to outlive disjoint universal regions.\n+    /// Therefore, this method should only be used in diagnostic code,\n+    /// where displaying *some* named universal region is better than\n+    /// falling back to 'static.\n+    pub(in crate::borrow_check) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+\n+        // Find the smallest universal region that contains all other\n+        // universal regions within `region`.\n+        let mut lub = self.universal_regions.fr_fn_body;\n+        let r_scc = self.constraint_sccs.scc(r);\n+        let static_r = self.universal_regions.fr_static;\n+        for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n+            let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n+            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            if ur != static_r && lub != static_r && new_lub == static_r {\n+                lub = std::cmp::min(ur, lub);\n+            } else {\n+                lub = new_lub;\n+            }\n+        }\n+\n+        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+\n+        lub\n+    }\n+\n     /// Tests if `test` is true when applied to `lower_bound` at\n     /// `point`.\n     fn eval_verify_bound("}, {"sha": "325dca8c8ca9997425f6f062f6e67065787ace33", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -141,7 +141,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     {\n         tcx.fold_regions(&ty, &mut false, |region, _| match *region {\n             ty::ReVar(vid) => {\n-                let upper_bound = self.universal_upper_bound(vid);\n+                // Find something that we can name\n+                let upper_bound = self.approx_universal_upper_bound(vid);\n                 self.definitions[upper_bound].external_name.unwrap_or(region)\n             }\n             _ => region,"}, {"sha": "5093916e73a45b68aa0672aae38da94b83fc1fbe", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+//\n+// Regression test for issue #67765\n+// Tests that we point at the proper location when giving\n+// a lifetime error.\n+fn main() {}\n+\n+async fn func<'a>() -> Result<(), &'a str> {\n+    let s = String::new();\n+\n+    let b = &s[..];\n+\n+    Err(b)?; //~ ERROR cannot return value referencing local variable `s`\n+\n+    Ok(())\n+}"}, {"sha": "78253042bee1c35eb4ace7a201f892bbf5d3a92e", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `s`\n+  --> $DIR/issue-67765-async-diagnostic.rs:13:11\n+   |\n+LL |     let b = &s[..];\n+   |              - `s` is borrowed here\n+LL | \n+LL |     Err(b)?;\n+   |           ^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "8deb3655158409ae252528e7d023615c19e8b419", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR `a` does not live long enough\n+    [0].iter().flat_map(|a| [0].iter().map(|_| &a)); //~ ERROR closure may outlive\n }"}, {"sha": "34470119112fbf60b35265029b804dfcf4fc9dad", "filename": "src/test/ui/lifetimes/unnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Funnamed-closure-doesnt-life-long-enough-issue-67634.stderr?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -1,15 +1,21 @@\n-error[E0597]: `a` does not live long enough\n-  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:49\n+error[E0373]: closure may outlive the current function, but it borrows `a`, which is owned by the current function\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:44\n    |\n LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n-   |                                             -   ^- ...but `a` will be dropped here, when the enclosing closure returns\n-   |                                             |   |\n-   |                                             |   `a` would have to be valid for `'_`...\n-   |                                             has type `&i32`\n+   |                                            ^^^  - `a` is borrowed here\n+   |                                            |\n+   |                                            may outlive borrowed value `a`\n    |\n-   = note: functions cannot return a borrow to data owned within the function's scope, functions can only return borrows to data passed as arguments\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references>\n+note: closure is returned here\n+  --> $DIR/unnamed-closure-doesnt-life-long-enough-issue-67634.rs:2:29\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(|_| &a));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^\n+help: to force the closure to take ownership of `a` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     [0].iter().flat_map(|a| [0].iter().map(move |_| &a));\n+   |                                            ^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "d0feb3b65e12ac09bab1b0c7a7d8686725308952", "filename": "src/test/ui/return-disjoint-regions.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.rs?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -0,0 +1,7 @@\n+// See https://github.com/rust-lang/rust/pull/67911#issuecomment-576023915\n+fn f<'a, 'b>(x: i32) -> (&'a i32, &'b i32) {\n+    let y = &x;\n+    (y, y) //~ ERROR cannot return\n+}\n+\n+fn main() {}"}, {"sha": "ed159298804ae89265c0e2cc321e3689c7a0ced1", "filename": "src/test/ui/return-disjoint-regions.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/517d361a1f78cf13d589d0f6b94f5ca005bef540/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-disjoint-regions.stderr?ref=517d361a1f78cf13d589d0f6b94f5ca005bef540", "patch": "@@ -0,0 +1,11 @@\n+error[E0515]: cannot return value referencing function parameter `x`\n+  --> $DIR/return-disjoint-regions.rs:4:5\n+   |\n+LL |     let y = &x;\n+   |             -- `x` is borrowed here\n+LL |     (y, y)\n+   |     ^^^^^^ returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}]}