{"sha": "d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGE0MmJmMmMyMTE1ZmMxODY5YjNhNzJlZTQwZmE0ZGQ0NDU3OTU=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-11-01T19:43:38Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-11-07T21:56:06Z"}, "message": "Look at projections from supertraits when constructing trait objects.", "tree": {"sha": "ea3b31be61940c2a7275da8f57952472803cf572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea3b31be61940c2a7275da8f57952472803cf572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "html_url": "https://github.com/rust-lang/rust/commit/d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a42b2ceb46887e9941cec667eac99844dd7ad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a42b2ceb46887e9941cec667eac99844dd7ad0", "html_url": "https://github.com/rust-lang/rust/commit/25a42b2ceb46887e9941cec667eac99844dd7ad0"}], "stats": {"total": 146, "additions": 77, "deletions": 69}, "files": [{"sha": "f57e3ff913b38dd407a7b856fde7093c2281edc4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "patch": "@@ -506,9 +506,9 @@ pub enum TraitBoundModifier {\n }\n \n /// The AST represents all type param bounds as types.\n-/// typeck::collect::compute_bounds matches these against\n-/// the \"special\" built-in traits (see middle::lang_items) and\n-/// detects Copy, Send and Sync.\n+/// `typeck::collect::compute_bounds` matches these against\n+/// the \"special\" built-in traits (see `middle::lang_items`) and\n+/// detects `Copy`, `Send` and `Sync`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),"}, {"sha": "24097fcca703b934e89c59ec813643ae3b571497", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "patch": "@@ -333,7 +333,7 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx,I:Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {"}, {"sha": "c18c55bcb5db79c5f37233e6353ad3e2d757aadf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "patch": "@@ -294,7 +294,7 @@ impl Visibility {\n         }\n     }\n \n-    /// Returns true if an item with this visibility is accessible from the given block.\n+    /// Returns `true` if an item with this visibility is accessible from the given block.\n     pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n         let restriction = match self {\n             // Public items are visible everywhere.\n@@ -309,7 +309,7 @@ impl Visibility {\n         tree.is_descendant_of(module, restriction)\n     }\n \n-    /// Returns true if this visibility is at least as accessible as the given visibility\n+    /// Returns `true` if this visibility is at least as accessible as the given visibility\n     pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n@@ -320,7 +320,7 @@ impl Visibility {\n         self.is_accessible_from(vis_restriction, tree)\n     }\n \n-    // Returns true if this item is visible anywhere in the local crate.\n+    // Returns `true` if this item is visible anywhere in the local crate.\n     pub fn is_visible_locally(self) -> bool {\n         match self {\n             Visibility::Public => true,\n@@ -451,7 +451,7 @@ bitflags! {\n         // FIXME: Rename this to the actual property since it's used for generators too\n         const HAS_TY_CLOSURE     = 1 << 9;\n \n-        // true if there are \"names\" of types and regions and so forth\n+        // `true` if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n         const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n \n@@ -953,7 +953,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected lifetime parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .region_param(param, tcx)\n         }\n     }\n@@ -970,7 +970,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n                 _ => bug!(\"expected type parameter, but found another generic parameter\")\n             }\n         } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n                .type_param(param, tcx)\n         }\n     }\n@@ -993,6 +993,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n+\n     pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                            -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n@@ -1256,14 +1257,14 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the def-id of the associated item being projected.\n+    /// Returns the `DefId` of the associated item being projected.\n     pub fn item_def_id(&self) -> DefId {\n         self.skip_binder().projection_ty.item_def_id\n     }\n \n     pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n-        // Note: unlike with TraitRef::to_poly_trait_ref(),\n-        // self.0.trait_ref is permitted to have escaping regions.\n+        // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n+        // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n         // return value, so we are preserving the number of binding\n         // levels.\n@@ -1274,12 +1275,12 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n-    /// The DefId of the TraitItem for the associated type.\n+    /// The `DefId` of the `TraitItem` for the associated type.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(projection_def_id()).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // ok to skip binder since trait def-id does not care about regions\n+        // okay to skip binder since trait def-id does not care about regions\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1515,14 +1516,14 @@ impl UniverseIndex {\n         UniverseIndex::from_u32(self.private.checked_add(1).unwrap())\n     }\n \n-    /// True if `self` can name a name from `other` -- in other words,\n+    /// `true` if `self` can name a name from `other` -- in other words,\n     /// if the set of names in `self` is a superset of those in\n     /// `other` (`self >= other`).\n     pub fn can_name(self, other: UniverseIndex) -> bool {\n         self.private >= other.private\n     }\n \n-    /// True if `self` cannot name some names from `other` -- in other\n+    /// `true` if `self` cannot name some names from `other` -- in other\n     /// words, if the set of names in `self` is a strict subset of\n     /// those in `other` (`self < other`).\n     pub fn cannot_name(self, other: UniverseIndex) -> bool {\n@@ -1574,7 +1575,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n         Self::new(List::empty(), Reveal::All)\n@@ -1979,14 +1980,14 @@ impl ReprOptions {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n \n-    /// Returns true if this `#[repr()]` should inhabit \"smart enum\n+    /// Returns `true` if this `#[repr()]` should inhabit \"smart enum\n     /// layout\" optimizations, such as representing `Foo<&T>` as a\n     /// single pointer.\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n         self.c() || self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit struct field reordering\n+    /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with repr(C) or repr(packed(1)).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n@@ -2089,7 +2090,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns true if this is PhantomData<T>.\n+    /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n@@ -2105,7 +2106,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.intersects(AdtFlags::IS_RC)\n     }\n \n-    /// Returns true if this is Box<T>.\n+    /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n         self.flags.intersects(AdtFlags::IS_BOX)\n@@ -2422,7 +2423,7 @@ impl<'a, 'tcx> ClosureKind {\n         }\n     }\n \n-    /// True if this a type that impls this closure kind\n+    /// Returns `true` if this a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n         match (self, other) {\n@@ -2678,7 +2679,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n-    /// Returns true if the impls are the same polarity and the trait either\n+    /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated #[marker] and prevents item overrides.\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId) -> bool {\n         if self.features().overlapping_marker_traits {\n@@ -2802,7 +2803,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n \n-    /// Returns true if this is an `auto trait`.\n+    /// Returns `true` if this is an `auto trait`.\n     pub fn trait_is_auto(self, trait_def_id: DefId) -> bool {\n         self.trait_def(trait_def_id).has_auto_impl\n     }"}, {"sha": "daf04aa0db22397c8335216e48cb6d5cfd02cad2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "patch": "@@ -451,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n \n         // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n+        // methods in `subst.rs` so that we can iterate over the arguments and\n         // parameters in lock-step linearly, rather than trying to match each pair.\n         let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n@@ -469,7 +469,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n \n-            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            // `Self` is handled first, unless it's been handled in `parent_substs`.\n             if has_self {\n                 if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n@@ -698,7 +698,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n-    /// Get the DefId of the given trait ref. It _must_ actually be a trait.\n+    /// Get the `DefId` of the given trait ref. It _must_ actually be a trait.\n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n         match path.def {\n@@ -711,7 +711,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    /// The given `trait_ref` must actually be trait.\n+    /// The given trait ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n@@ -738,7 +738,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n                     trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n-            // ok to ignore Err because ErrorReported (see above)\n+            // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n@@ -947,14 +947,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         )\n     }\n \n-    /// Transform a `PolyTraitRef` into a `PolyExistentialTraitRef` by\n-    /// removing the dummy `Self` type (`TRAIT_OBJECT_DUMMY_SELF`).\n-    fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n-                                -> ty::ExistentialTraitRef<'tcx> {\n-        assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n-        ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n-    }\n-\n     fn conv_object_ty_poly_trait_ref(&self,\n         span: Span,\n         trait_bounds: &[hir::PolyTraitRef],\n@@ -969,7 +961,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        let mut projection_bounds = vec![];\n+        let mut projection_bounds = Vec::new();\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n         let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n@@ -994,23 +986,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n-        // Erase the dummy_self (TRAIT_OBJECT_DUMMY_SELF) used above.\n-        let existential_principal = principal.map_bound(|trait_ref| {\n-            self.trait_ref_to_existential(trait_ref)\n-        });\n-        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|b| {\n-                let trait_ref = self.trait_ref_to_existential(b.projection_ty.trait_ref(tcx));\n-                ty::ExistentialProjection {\n-                    ty: b.ty,\n-                    item_def_id: b.projection_ty.item_def_id,\n-                    substs: trait_ref.substs,\n-                }\n-            })\n-        });\n-\n         // Check that there are no gross object safety violations;\n-        // most importantly, that the supertraits don't contain Self,\n+        // most importantly, that the supertraits don't contain `Self`,\n         // to avoid ICEs.\n         let object_safety_violations =\n             tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n@@ -1021,13 +998,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             return tcx.types.err;\n         }\n \n-        // Use a BTreeSet to keep output in a more consistent order.\n+        // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n         for tr in traits::supertraits(tcx, principal) {\n             associated_types.extend(tcx.associated_items(tr.def_id())\n                 .filter(|item| item.kind == ty::AssociatedKind::Type)\n                 .map(|item| item.def_id));\n+\n+            projection_bounds.extend(tcx.predicates_of(tr.def_id())\n+                .predicates.into_iter()\n+                .filter_map(|(pred, span)| {\n+                    if let ty::Predicate::Projection(proj) = pred {\n+                        Some((proj, span))\n+                    } else {\n+                        None\n+                    }\n+                }));\n         }\n \n         for (projection_bound, _) in &projection_bounds {\n@@ -1046,11 +1033,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 .emit();\n         }\n \n+        // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above.\n+        let existential_principal = principal.map_bound(|trait_ref| {\n+            assert_eq!(trait_ref.self_ty().sty, TRAIT_OBJECT_DUMMY_SELF);\n+            ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n+        });\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n+            bound.map_bound(|b| {\n+                let trait_ref = ty::ExistentialTraitRef::erase_self_ty(self.tcx(),\n+                    b.projection_ty.trait_ref(tcx));\n+                ty::ExistentialProjection {\n+                    ty: b.ty,\n+                    item_def_id: b.projection_ty.item_def_id,\n+                    substs: trait_ref.substs,\n+                }\n+            })\n+        });\n+\n         // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n         auto_traits.sort();\n         auto_traits.dedup();\n \n-        // skip_binder is okay, because the predicates are re-bound.\n+        // Calling `skip_binder` is okay, because the predicates are re-bound.\n         let mut v =\n             iter::once(ty::ExistentialPredicate::Trait(*existential_principal.skip_binder()))\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n@@ -1128,7 +1132,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                       span)\n     }\n \n-\n     // Checks that bounds contains exactly one element and reports appropriate\n     // errors otherwise.\n     fn one_bound_for_assoc_type<I>(&self,\n@@ -1186,11 +1189,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Create a type from a path to an associated type.\n-    // For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n-    // and item_segment is the path segment for D. We return a type and a def for\n+    // For a path `A::B::C::D`, `ty` and `ty_path_def` are the type and def for `A::B::C`\n+    // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n-    // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n-    // parameter or Self.\n+    // Will fail except for `T::A` and `Self::A`; i.e., if `ty`/`ty_path_def` are not a type\n+    // parameter or `Self`.\n     pub fn associated_path_def_to_ty(&self,\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n@@ -1210,7 +1213,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n-                // `Self` in an impl of a trait - we have a concrete self type and a\n+                // `Self` in an impl of a trait - we have a concrete `self` type and a\n                 // trait reference.\n                 let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n                     Some(trait_ref) => trait_ref,\n@@ -1361,7 +1364,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         let span = path.span;\n         match path.def {\n             Def::Existential(did) => {\n-                // check for desugared impl trait\n+                // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n                 self.prohibit_generics(item_segment.1);\n@@ -1398,15 +1401,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 tcx.mk_ty_param(index, tcx.hir.name(node_id).as_interned_str())\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n-                // Self in impl (we know the concrete type).\n+                // `Self` in impl (we know the concrete type)\n \n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n-                // Self in trait.\n+                // `Self` in trait\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()"}, {"sha": "53f536578632c52d9eab8f2e222c9ad3a05e43c0", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08a42bf2c2115fc1869b3a72ee40fa4dd445795/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d08a42bf2c2115fc1869b3a72ee40fa4dd445795", "patch": "@@ -186,6 +186,8 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    item_id: ast::NodeId,\n                                    span: Span,\n                                    sig_if_method: Option<&hir::MethodSig>) {\n+    debug!(\"check_associated_item: {:?}\", item_id);\n+\n     let code = ObligationCauseCode::MiscObligation;\n     for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n@@ -311,6 +313,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    debug!(\"check_trait: {:?}\", item.id);\n+\n     let trait_def_id = tcx.hir.local_def_id(item.id);\n \n     let trait_def = tcx.trait_def(trait_def_id);\n@@ -1012,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             None => {\n-                // Inherent impl: take implied bounds from the self type.\n+                // Inherent impl: take implied bounds from the `self` type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n                 let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]"}]}