{"sha": "9b195ae228be1c74b2ccdc83697219e35439b01f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMTk1YWUyMjhiZTFjNzRiMmNjZGM4MzY5NzIxOWUzNTQzOWIwMWY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-11T05:32:44Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-11T05:32:44Z"}, "message": "Refactor format_impl", "tree": {"sha": "761054186e79c53e1ba6a16bfb5cd39597c366df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761054186e79c53e1ba6a16bfb5cd39597c366df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b195ae228be1c74b2ccdc83697219e35439b01f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b195ae228be1c74b2ccdc83697219e35439b01f", "html_url": "https://github.com/rust-lang/rust/commit/9b195ae228be1c74b2ccdc83697219e35439b01f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b195ae228be1c74b2ccdc83697219e35439b01f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd80077be89b3e8584d8c93af263e38c0e156d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd80077be89b3e8584d8c93af263e38c0e156d5b", "html_url": "https://github.com/rust-lang/rust/commit/bd80077be89b3e8584d8c93af263e38c0e156d5b"}], "stats": {"total": 160, "additions": 82, "deletions": 78}, "files": [{"sha": "10ab6fe72dfefee17731925fecaa41272a5377be", "filename": "src/items.rs", "status": "modified", "additions": 82, "deletions": 78, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/9b195ae228be1c74b2ccdc83697219e35439b01f/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b195ae228be1c74b2ccdc83697219e35439b01f/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=9b195ae228be1c74b2ccdc83697219e35439b01f", "patch": "@@ -527,19 +527,9 @@ pub fn format_impl(context: &RewriteContext,\n                    offset: Indent,\n                    where_span_end: Option<BytePos>)\n                    -> Option<String> {\n-    if let ast::ItemKind::Impl(_, _, _, ref generics, ref trait_ref, _, ref items) = item.node {\n+    if let ast::ItemKind::Impl(_, _, _, ref generics, _, _, ref items) = item.node {\n         let mut result = String::new();\n-        // First try to format the ref and type without a split at the 'for'.\n-        let mut ref_and_type =\n-            format_impl_ref_and_type(context, item, offset, false)\n-                .unwrap_or(try_opt!(format_impl_ref_and_type(context, item, offset, true)));\n-\n-        // If there is a line break present in the first result format it again\n-        // with a split at the 'for'. Skip this if there is no trait ref and\n-        // therefore no 'for'.\n-        if ref_and_type.contains('\\n') && trait_ref.is_some() {\n-            ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset, true));\n-        }\n+        let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n         result.push_str(&ref_and_type);\n \n         let where_budget = if result.contains('\\n') {\n@@ -651,8 +641,7 @@ fn is_impl_single_line(context: &RewriteContext,\n \n fn format_impl_ref_and_type(context: &RewriteContext,\n                             item: &ast::Item,\n-                            offset: Indent,\n-                            split_at_for: bool)\n+                            offset: Indent)\n                             -> Option<String> {\n     if let ast::ItemKind::Impl(unsafety,\n                                polarity,\n@@ -672,65 +661,90 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             Some(ref tr) => tr.path.span.lo,\n             None => self_ty.span.lo,\n         };\n-        let generics_indent = offset + last_line_width(&result);\n         let shape = generics_shape_from_config(context.config,\n-                                               Shape::indented(generics_indent, context.config),\n+                                               Shape::indented(offset + last_line_width(&result),\n+                                                               context.config),\n                                                0);\n-        let mut generics_str =\n+        let generics_str =\n             try_opt!(rewrite_generics(context, generics, shape, shape.width, mk_sp(lo, hi)));\n-        add_polarity(&mut generics_str, &polarity, trait_ref.is_some());\n+\n+        let polarity_str = if polarity == ast::ImplPolarity::Negative {\n+            \"!\"\n+        } else {\n+            \"\"\n+        };\n \n         if let Some(ref trait_ref) = *trait_ref {\n             let success = format_trait_ref_then_update_result(context,\n                                                               &trait_ref,\n                                                               offset,\n                                                               &generics_str,\n-                                                              split_at_for,\n+                                                              true,\n+                                                              polarity_str,\n                                                               &mut result);\n             if !success {\n-                let mut generics_str =\n+                let generics_str =\n                     try_opt!(rewrite_generics(context, generics, shape, 0, mk_sp(lo, hi)));\n-                add_polarity(&mut generics_str, &polarity, true);\n                 if !format_trait_ref_then_update_result(context,\n                                                         &trait_ref,\n                                                         offset,\n                                                         &generics_str,\n-                                                        split_at_for,\n+                                                        false,\n+                                                        polarity_str,\n                                                         &mut result) {\n-                    // FIXME: should be unreachable\n                     return None;\n                 }\n             }\n         } else {\n             result.push_str(&generics_str);\n         }\n \n-        let mut used_space = last_line_width(&result);\n-        if generics.where_clause.predicates.is_empty() {\n+        // Try to put the self type in a single line.\n+        // ` for`\n+        let trait_ref_overhead = if trait_ref.is_some() { 4 } else { 0 };\n+        let curly_brace_overhead = if generics.where_clause.predicates.is_empty() {\n             // If there is no where clause adapt budget for type formatting to take space and curly\n             // brace into account.\n             match context.config.item_brace_style() {\n-                BraceStyle::AlwaysNextLine => {}\n-                BraceStyle::PreferSameLine => used_space += 2,\n-                BraceStyle::SameLineWhere => used_space += 2,\n+                BraceStyle::AlwaysNextLine => 0,\n+                _ => 2,\n             }\n-        }\n-\n+        } else {\n+            0\n+        };\n+        let used_space = last_line_width(&result) + trait_ref_overhead + curly_brace_overhead;\n         // 1 = space before the type.\n-        let budget = try_opt!(context.config.max_width().checked_sub(used_space + 1));\n-        let indent = offset + last_line_width(&result) + 1;\n-        let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n-        if let Some(self_ty_str) = self_ty_str {\n-            result.push_str(\" \");\n-            result.push_str(&self_ty_str);\n-            return Some(result);\n+        let budget = context\n+            .config\n+            .max_width()\n+            .checked_sub(used_space + 1)\n+            .unwrap_or(0);\n+        if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n+            if !self_ty_str.contains('\\n') {\n+                if trait_ref.is_some() {\n+                    result.push_str(\" for \");\n+                } else {\n+                    result.push(' ');\n+                }\n+                result.push_str(&self_ty_str);\n+                return Some(result);\n+            }\n         }\n \n-        // Can't fit the self type on what's left of the line, so start a new one.\n-        let indent = offset.block_indent(context.config);\n-        result.push_str(&format!(\"\\n{}\", indent.to_string(context.config)));\n-        result.push_str(&*try_opt!(self_ty.rewrite(context,\n-                                                   Shape::indented(indent, context.config))));\n+        // Couldn't fit the self type on a single line, put it on a new line.\n+        result.push('\\n');\n+        // Add indentation of one additional tab.\n+        let new_line_offset = offset.block_indent(context.config);\n+        result.push_str(&new_line_offset.to_string(context.config));\n+        if trait_ref.is_some() {\n+            result.push_str(\"for \");\n+        }\n+        let budget = context.config.max_width() - last_line_width(&result);\n+        let type_offset = match context.config.where_style() {\n+            Style::Legacy => new_line_offset + trait_ref_overhead,\n+            Style::Rfc => new_line_offset,\n+        };\n+        result.push_str(&*try_opt!(self_ty.rewrite(context, Shape::legacy(budget, type_offset))));\n         Some(result)\n     } else {\n         unreachable!();\n@@ -742,48 +756,38 @@ fn format_trait_ref_then_update_result(context: &RewriteContext,\n                                        trait_ref: &ast::TraitRef,\n                                        offset: Indent,\n                                        generics_str: &str,\n-                                       split_at_for: bool,\n+                                       retry: bool,\n+                                       polarity_str: &str,\n                                        result: &mut String)\n                                        -> bool {\n-    let used_space = if generics_str.contains('\\n') {\n-        last_line_width(&generics_str)\n-    } else {\n-        result.len() + generics_str.len()\n-    };\n-    let budget = context\n-        .config\n-        .max_width()\n-        .checked_sub(used_space)\n-        .unwrap_or(0);\n-    let indent = offset + used_space;\n-    if let Some(trait_ref_str) = trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n-        if !trait_ref_str.contains('\\n') {\n-            result.push_str(&generics_str);\n-            result.push_str(&trait_ref_str);\n-            if split_at_for {\n-                result.push('\\n');\n-                // Add indentation of one additional tab.\n-                let for_offset = match context.config.where_style() {\n-                    Style::Legacy => offset.block_indent(context.config),\n-                    Style::Rfc => offset,\n-                };\n-                result.push_str(&for_offset.to_string(context.config));\n-                result.push_str(\"for\");\n-            } else {\n-                result.push_str(\" for\");\n-            }\n+    // 1 = space between generics and trait_ref\n+    let used_space = 1 + polarity_str.len() +\n+                     if generics_str.contains('\\n') {\n+                         last_line_width(&generics_str)\n+                     } else {\n+                         result.len() + generics_str.len()\n+                     };\n+    let shape = Shape::indented(offset + used_space, context.config);\n+    if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n+        if !(retry && trait_ref_str.contains('\\n')) {\n+            result.push_str(&format!(\"{} {}{}\", generics_str, polarity_str, &trait_ref_str));\n             return true;\n         }\n     }\n-    false\n-}\n-\n-fn add_polarity(s: &mut String, polarity: &ast::ImplPolarity, has_trait_ref: bool) {\n-    if polarity == &ast::ImplPolarity::Negative {\n-        s.push_str(\" !\")\n-    } else if has_trait_ref {\n-        s.push(' ')\n+    // We could not make enough space for trait_ref, so put it on new line.\n+    if !retry {\n+        let offset = offset.block_indent(context.config);\n+        let shape = Shape::indented(offset, context.config);\n+        if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n+            result.push_str(&format!(\"{}\\n{}{}{}\",\n+                                     generics_str,\n+                                     &offset.to_string(context.config),\n+                                     polarity_str,\n+                                     &trait_ref_str));\n+            return true;\n+        }\n     }\n+    false\n }\n \n pub fn format_struct(context: &RewriteContext,"}]}