{"sha": "4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNWY2MDhiNDk5YWQ1MGFhNjZiMjIxM2UzYjkyZGQyZmU2MWVkNjg=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-24T08:26:45Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-24T08:26:45Z"}, "message": "Reorganise code", "tree": {"sha": "6ca8e205c82c5b50c4c4d77dcfe0bea09dfe31d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca8e205c82c5b50c4c4d77dcfe0bea09dfe31d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "html_url": "https://github.com/rust-lang/rust/commit/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b34ad4bc8ad368a096c14d3710239a5a2eb9ccb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b34ad4bc8ad368a096c14d3710239a5a2eb9ccb5", "html_url": "https://github.com/rust-lang/rust/commit/b34ad4bc8ad368a096c14d3710239a5a2eb9ccb5"}], "stats": {"total": 607, "additions": 347, "deletions": 260}, "files": [{"sha": "08d122e77d0d4509a0cdd21033121a7fa030d367", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -988,8 +988,10 @@ dependencies = [\n  \"ra_hir_ty\",\n  \"ra_prof\",\n  \"ra_syntax\",\n+ \"ra_tt\",\n  \"rustc-hash\",\n  \"stdx\",\n+ \"url\",\n ]\n \n [[package]]\n@@ -1081,18 +1083,14 @@ dependencies = [\n  \"ra_db\",\n  \"ra_fmt\",\n  \"ra_hir\",\n- \"ra_hir_def\",\n  \"ra_ide_db\",\n- \"ra_parser\",\n  \"ra_prof\",\n  \"ra_ssr\",\n  \"ra_syntax\",\n  \"ra_text_edit\",\n- \"ra_tt\",\n  \"rustc-hash\",\n  \"stdx\",\n  \"test_utils\",\n- \"url\",\n ]\n \n [[package]]\n@@ -1105,7 +1103,6 @@ dependencies = [\n  \"once_cell\",\n  \"ra_db\",\n  \"ra_hir\",\n- \"ra_hir_def\",\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_text_edit\","}, {"sha": "a8c4875d4e4143d30bab583adda9f59fffd19895", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -16,10 +16,13 @@ arrayvec = \"0.5.1\"\n \n itertools = \"0.9.0\"\n \n+url = \"2.1.1\"\n+\n stdx = { path = \"../stdx\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }\n hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n hir_ty = { path = \"../ra_hir_ty\", package = \"ra_hir_ty\" }\n+ra_tt = { path = \"../ra_tt\" }"}, {"sha": "8154e9bf6cb07591a166822d986c888becd8f994", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -16,7 +16,7 @@ use hir_def::{\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, ConstId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n     ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeParamId, UnionId,\n+    TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n@@ -35,12 +35,14 @@ use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n     AstNode,\n };\n+use ra_tt::{Ident, Leaf, Literal, TokenTree};\n use rustc_hash::FxHashSet;\n use stdx::impl_from;\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n     has_source::HasSource,\n+    link_rewrite::Resolvable,\n     HirDisplay, InFile, Name,\n };\n \n@@ -120,6 +122,33 @@ impl Crate {\n     pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }\n+\n+    /// Try to get the root URL of the documentation of a crate.\n+    pub fn get_doc_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {\n+        // Look for #![doc(html_root_url = \"...\")]\n+        let attrs = db.attrs(AttrDef::from(self.root_module(db)?).into());\n+        let doc_attr_q = attrs.by_key(\"doc\");\n+\n+        let doc_url = if doc_attr_q.exists() {\n+            doc_attr_q.tt_values().map(|tt| {\n+            let name = tt.token_trees.iter()\n+                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n+                .skip(2)\n+                .next();\n+\n+            match name {\n+                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n+                _ => None\n+            }\n+        }).flat_map(|t| t).next().map(|s| s.to_string())\n+        } else {\n+            None\n+        };\n+\n+        doc_url\n+            .map(|s| s.trim_matches('\"').trim_end_matches(\"/\").to_owned() + \"/\")\n+            .map(|s| s.to_string())\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -1709,3 +1738,76 @@ pub trait HasVisibility {\n         vis.is_visible_from(db.upcast(), module.id)\n     }\n }\n+\n+impl Resolvable for ModuleDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(match self {\n+            ModuleDef::Module(m) => ModuleId::from(m.clone()).resolver(db),\n+            ModuleDef::Function(f) => FunctionId::from(f.clone()).resolver(db),\n+            ModuleDef::Adt(adt) => AdtId::from(adt.clone()).resolver(db),\n+            ModuleDef::EnumVariant(ev) => {\n+                GenericDefId::from(GenericDef::from(ev.clone())).resolver(db)\n+            }\n+            ModuleDef::Const(c) => GenericDefId::from(GenericDef::from(c.clone())).resolver(db),\n+            ModuleDef::Static(s) => StaticId::from(s.clone()).resolver(db),\n+            ModuleDef::Trait(t) => TraitId::from(t.clone()).resolver(db),\n+            ModuleDef::TypeAlias(t) => ModuleId::from(t.module(db)).resolver(db),\n+            // FIXME: This should be a resolver relative to `std/core`\n+            ModuleDef::BuiltinType(_t) => None?,\n+        })\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        Some(self)\n+    }\n+}\n+\n+impl Resolvable for TypeParam {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for MacroDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)?).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for Field {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<VariantId>::into(Into::<VariantDef>::into(self.parent_def(db))).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for ImplDef {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}\n+\n+impl Resolvable for Local {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver> {\n+        Some(Into::<ModuleId>::into(self.module(db)).resolver(db))\n+    }\n+\n+    fn try_into_module_def(self) -> Option<ModuleDef> {\n+        None\n+    }\n+}"}, {"sha": "b33293a18d9c118c64fb1f831f616b500e963f62", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -27,6 +27,7 @@ pub mod diagnostics;\n \n mod from_id;\n mod code_model;\n+mod link_rewrite;\n \n mod has_source;\n \n@@ -38,6 +39,7 @@ pub use crate::{\n         Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n+    link_rewrite::resolve_doc_link,\n     semantics::{original_range, PathResolution, Semantics, SemanticsScope},\n };\n "}, {"sha": "a66f1e6fc71b749f3c53163c522d20541b61fb19", "filename": "crates/ra_hir/src/link_rewrite.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_hir%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flink_rewrite.rs?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -0,0 +1,226 @@\n+//! Resolves and rewrites links in markdown documentation for hovers/completion windows.\n+\n+use std::iter::once;\n+\n+use itertools::Itertools;\n+use url::Url;\n+\n+use crate::{db::HirDatabase, Adt, AsName, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n+use hir_def::{db::DefDatabase, resolver::Resolver};\n+use ra_syntax::ast::Path;\n+\n+pub fn resolve_doc_link<T: Resolvable + Clone, D: DefDatabase + HirDatabase>(\n+    db: &D,\n+    definition: &T,\n+    link_text: &str,\n+    link_target: &str,\n+) -> Option<(String, String)> {\n+    try_resolve_intra(db, definition, link_text, &link_target).or_else(|| {\n+        if let Some(definition) = definition.clone().try_into_module_def() {\n+            try_resolve_path(db, &definition, &link_target)\n+                .map(|target| (target, link_text.to_string()))\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n+///\n+/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n+fn try_resolve_intra<T: Resolvable, D: DefDatabase + HirDatabase>(\n+    db: &D,\n+    definition: &T,\n+    link_text: &str,\n+    link_target: &str,\n+) -> Option<(String, String)> {\n+    // Set link_target for implied shortlinks\n+    let link_target =\n+        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n+\n+    // Namespace disambiguation\n+    let namespace = Namespace::from_intra_spec(link_target);\n+\n+    // Strip prefixes/suffixes\n+    let link_target = strip_prefixes_suffixes(link_target);\n+\n+    // Parse link as a module path\n+    let path = Path::parse(link_target).ok()?;\n+    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n+\n+    // Resolve it relative to symbol's location (according to the RFC this should consider small scopes)\n+    let resolver = definition.resolver(db)?;\n+\n+    let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n+    let (defid, namespace) = match namespace {\n+        // FIXME: .or(resolved.macros)\n+        None => resolved\n+            .types\n+            .map(|t| (t.0, Namespace::Types))\n+            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n+        Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n+        Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n+        // FIXME:\n+        Some(Namespace::Macros) => None?,\n+    };\n+\n+    // Get the filepath of the final symbol\n+    let def: ModuleDef = defid.into();\n+    let module = def.module(db)?;\n+    let krate = module.krate();\n+    let ns = match namespace {\n+        Namespace::Types => ItemInNs::Types(defid),\n+        Namespace::Values => ItemInNs::Values(defid),\n+        // FIXME:\n+        Namespace::Macros => None?,\n+    };\n+    let import_map = db.import_map(krate.into());\n+    let path = import_map.path_of(ns)?;\n+\n+    Some((\n+        get_doc_url(db, &krate)?\n+            .join(&format!(\"{}/\", krate.display_name(db)?))\n+            .ok()?\n+            .join(&path.segments.iter().map(|name| name.to_string()).join(\"/\"))\n+            .ok()?\n+            .join(&get_symbol_filename(db, &def)?)\n+            .ok()?\n+            .into_string(),\n+        strip_prefixes_suffixes(link_text).to_string(),\n+    ))\n+}\n+\n+/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n+fn try_resolve_path(db: &dyn HirDatabase, moddef: &ModuleDef, link_target: &str) -> Option<String> {\n+    if !link_target.contains(\"#\") && !link_target.contains(\".html\") {\n+        return None;\n+    }\n+    let ns = ItemInNs::Types(moddef.clone().into());\n+\n+    let module = moddef.module(db)?;\n+    let krate = module.krate();\n+    let import_map = db.import_map(krate.into());\n+    let base = once(format!(\"{}\", krate.display_name(db)?))\n+        .chain(import_map.path_of(ns)?.segments.iter().map(|name| format!(\"{}\", name)))\n+        .join(\"/\");\n+\n+    get_doc_url(db, &krate)\n+        .and_then(|url| url.join(&base).ok())\n+        .and_then(|url| {\n+            get_symbol_filename(db, moddef).as_deref().map(|f| url.join(f).ok()).flatten()\n+        })\n+        .and_then(|url| url.join(link_target).ok())\n+        .map(|url| url.into_string())\n+}\n+\n+// Strip prefixes, suffixes, and inline code marks from the given string.\n+fn strip_prefixes_suffixes(mut s: &str) -> &str {\n+    s = s.trim_matches('`');\n+\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .for_each(|(prefixes, suffixes)| {\n+        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n+        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n+    });\n+    let s = s.trim_start_matches(\"@\").trim();\n+    s\n+}\n+\n+fn get_doc_url(db: &dyn HirDatabase, krate: &Crate) -> Option<Url> {\n+    krate\n+        .get_doc_url(db)\n+        .or_else(||\n+        // Fallback to docs.rs\n+        // FIXME: Specify an exact version here. This may be difficult, as multiple versions of the same crate could exist.\n+        Some(format!(\"https://docs.rs/{}/*/\", krate.display_name(db)?)))\n+        .and_then(|s| Url::parse(&s).ok())\n+}\n+\n+/// Get the filename and extension generated for a symbol by rustdoc.\n+///\n+/// Example: `struct.Shard.html`\n+fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<String> {\n+    Some(match definition {\n+        ModuleDef::Adt(adt) => match adt {\n+            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n+            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n+            Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n+        },\n+        ModuleDef::Module(_) => \"index.html\".to_string(),\n+        ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+        ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n+        ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n+        ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+        ModuleDef::EnumVariant(ev) => {\n+            format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+        }\n+        ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n+        ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n+    })\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n+enum Namespace {\n+    Types,\n+    Values,\n+    Macros,\n+}\n+\n+static TYPES: ([&str; 7], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n+static VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n+\n+impl Namespace {\n+    /// Extract the specified namespace from an intra-doc-link if one exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// * `struct MyStruct` -> `Namespace::Types`\n+    /// * `panic!` -> `Namespace::Macros`\n+    /// * `fn@from_intra_spec` -> `Namespace::Values`\n+    fn from_intra_spec(s: &str) -> Option<Self> {\n+        [\n+            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+        ]\n+        .iter()\n+        .filter(|(_ns, (prefixes, suffixes))| {\n+            prefixes\n+                .clone()\n+                .map(|prefix| {\n+                    s.starts_with(*prefix)\n+                        && s.chars()\n+                            .nth(prefix.len() + 1)\n+                            .map(|c| c == '@' || c == ' ')\n+                            .unwrap_or(false)\n+                })\n+                .any(|cond| cond)\n+                || suffixes\n+                    .clone()\n+                    .map(|suffix| {\n+                        s.starts_with(*suffix)\n+                            && s.chars()\n+                                .nth(suffix.len() + 1)\n+                                .map(|c| c == '@' || c == ' ')\n+                                .unwrap_or(false)\n+                    })\n+                    .any(|cond| cond)\n+        })\n+        .map(|(ns, (_, _))| *ns)\n+        .next()\n+    }\n+}\n+\n+/// Sealed trait used solely for the generic bound on [`resolve_doc_link`].\n+pub trait Resolvable {\n+    fn resolver<D: DefDatabase + HirDatabase>(&self, db: &D) -> Option<Resolver>;\n+    fn try_into_module_def(self) -> Option<ModuleDef>;\n+}"}, {"sha": "de606f57ed44a2dd5a2caa02dca9cf3dd806830e", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -17,10 +17,9 @@ indexmap = \"1.3.2\"\n itertools = \"0.9.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n-url = \"2.1.1\"\n+oorandom = \"11.1.2\"\n pulldown-cmark-to-cmark = \"5.0.0\"\n pulldown-cmark = {version = \"0.7.2\", default-features = false}\n-oorandom = \"11.1.2\"\n \n stdx = { path = \"../stdx\" }\n \n@@ -34,9 +33,6 @@ ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n ra_assists = { path = \"../ra_assists\" }\n ra_ssr = { path = \"../ra_ssr\" }\n-ra_hir_def = { path = \"../ra_hir_def\" }\n-ra_tt = { path = \"../ra_tt\" }\n-ra_parser = { path = \"../ra_parser\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "94d2c31c2ee579633a6ab2fb0eded0faf38f0ff9", "filename": "crates/ra_ide/src/link_rewrite.rs", "status": "modified", "additions": 10, "deletions": 231, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -1,17 +1,10 @@\n-//! Resolves and rewrites links in markdown documentation for hovers/completion windows.\n+//! This is a wrapper around [`hir::link_rewrite`] connecting it to the markdown parser.\n \n-use std::iter::once;\n-\n-use itertools::Itertools;\n use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n-use url::Url;\n \n-use hir::{Adt, AsName, AttrDef, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n-use ra_hir_def::db::DefDatabase;\n+use hir::resolve_doc_link;\n use ra_ide_db::{defs::Definition, RootDatabase};\n-use ra_syntax::ast::Path;\n-use ra_tt::{Ident, Leaf, Literal, TokenTree};\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n@@ -31,9 +24,14 @@ pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition)\n             // Two posibilities:\n             // * path-based links: `../../module/struct.MyStruct.html`\n             // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            let resolved = try_resolve_intra(db, definition, title, &target).or_else(|| {\n-                try_resolve_path(db, definition, &target).map(|target| (target, title.to_string()))\n-            });\n+            let resolved = match definition {\n+                Definition::ModuleDef(t) => resolve_doc_link(db, t, title, target),\n+                Definition::Macro(t) => resolve_doc_link(db, t, title, target),\n+                Definition::Field(t) => resolve_doc_link(db, t, title, target),\n+                Definition::SelfType(t) => resolve_doc_link(db, t, title, target),\n+                Definition::Local(t) => resolve_doc_link(db, t, title, target),\n+                Definition::TypeParam(t) => resolve_doc_link(db, t, title, target),\n+            };\n \n             match resolved {\n                 Some((target, title)) => (target, title),\n@@ -79,222 +77,3 @@ fn map_links<'e>(\n         _ => evt,\n     })\n }\n-\n-#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n-enum Namespace {\n-    Types,\n-    Values,\n-    Macros,\n-}\n-\n-static TYPES: ([&str; 7], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n-static VALUES: ([&str; 8], [&str; 1]) =\n-    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n-\n-impl Namespace {\n-    /// Extract the specified namespace from an intra-doc-link if one exists.\n-    ///\n-    /// # Examples\n-    ///\n-    /// * `struct MyStruct` -> `Namespace::Types`\n-    /// * `panic!` -> `Namespace::Macros`\n-    /// * `fn@from_intra_spec` -> `Namespace::Values`\n-    fn from_intra_spec(s: &str) -> Option<Self> {\n-        [\n-            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n-            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n-            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n-        ]\n-        .iter()\n-        .filter(|(_ns, (prefixes, suffixes))| {\n-            prefixes\n-                .clone()\n-                .map(|prefix| {\n-                    s.starts_with(*prefix)\n-                        && s.chars()\n-                            .nth(prefix.len() + 1)\n-                            .map(|c| c == '@' || c == ' ')\n-                            .unwrap_or(false)\n-                })\n-                .any(|cond| cond)\n-                || suffixes\n-                    .clone()\n-                    .map(|suffix| {\n-                        s.starts_with(*suffix)\n-                            && s.chars()\n-                                .nth(suffix.len() + 1)\n-                                .map(|c| c == '@' || c == ' ')\n-                                .unwrap_or(false)\n-                    })\n-                    .any(|cond| cond)\n-        })\n-        .map(|(ns, (_, _))| *ns)\n-        .next()\n-    }\n-}\n-\n-// Strip prefixes, suffixes, and inline code marks from the given string.\n-fn strip_prefixes_suffixes(mut s: &str) -> &str {\n-    s = s.trim_matches('`');\n-\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .for_each(|(prefixes, suffixes)| {\n-        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n-    });\n-    s.trim_start_matches(\"@\").trim()\n-}\n-\n-/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n-///\n-/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra(\n-    db: &RootDatabase,\n-    definition: &Definition,\n-    link_text: &str,\n-    link_target: &str,\n-) -> Option<(String, String)> {\n-    // Set link_target for implied shortlinks\n-    let link_target =\n-        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n-\n-    // Namespace disambiguation\n-    let namespace = Namespace::from_intra_spec(link_target);\n-\n-    // Strip prefixes/suffixes\n-    let link_target = strip_prefixes_suffixes(link_target);\n-\n-    // Parse link as a module path\n-    let path = Path::parse(link_target).ok()?;\n-    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n-\n-    // Resolve it relative to symbol's location (according to the RFC this should consider small scopes)\n-    let resolver = definition.resolver(db)?;\n-\n-    let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n-    let (defid, namespace) = match namespace {\n-        // FIXME: .or(resolved.macros)\n-        None => resolved\n-            .types\n-            .map(|t| (t.0, Namespace::Types))\n-            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n-        Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n-        Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n-        // FIXME:\n-        Some(Namespace::Macros) => None?,\n-    };\n-\n-    // Get the filepath of the final symbol\n-    let def: ModuleDef = defid.into();\n-    let module = def.module(db)?;\n-    let krate = module.krate();\n-    let ns = match namespace {\n-        Namespace::Types => ItemInNs::Types(defid),\n-        Namespace::Values => ItemInNs::Values(defid),\n-        // FIXME:\n-        Namespace::Macros => None?,\n-    };\n-    let import_map = db.import_map(krate.into());\n-    let path = import_map.path_of(ns)?;\n-\n-    Some((\n-        get_doc_url(db, &krate)?\n-            .join(&format!(\"{}/\", krate.display_name(db)?))\n-            .ok()?\n-            .join(&path.segments.iter().map(|name| name.to_string()).join(\"/\"))\n-            .ok()?\n-            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?)\n-            .ok()?\n-            .into_string(),\n-        strip_prefixes_suffixes(link_text).to_string(),\n-    ))\n-}\n-\n-/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n-fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n-    if !link.contains(\"#\") && !link.contains(\".html\") {\n-        return None;\n-    }\n-    let ns = if let Definition::ModuleDef(moddef) = definition {\n-        ItemInNs::Types(moddef.clone().into())\n-    } else {\n-        return None;\n-    };\n-    let module = definition.module(db)?;\n-    let krate = module.krate();\n-    let import_map = db.import_map(krate.into());\n-    let base = once(format!(\"{}\", krate.display_name(db)?))\n-        .chain(import_map.path_of(ns)?.segments.iter().map(|name| format!(\"{}\", name)))\n-        .join(\"/\");\n-\n-    get_doc_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten()\n-        })\n-        .and_then(|url| url.join(link).ok())\n-        .map(|url| url.into_string())\n-}\n-\n-/// Try to get the root URL of the documentation of a crate.\n-fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n-    // Look for #![doc(html_root_url = \"...\")]\n-    let attrs = db.attrs(AttrDef::from(krate.root_module(db)?).into());\n-    let doc_attr_q = attrs.by_key(\"doc\");\n-\n-    let doc_url = if doc_attr_q.exists() {\n-        doc_attr_q.tt_values().map(|tt| {\n-            let name = tt.token_trees.iter()\n-                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n-                .skip(2)\n-                .next();\n-\n-            match name {\n-                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n-                _ => None\n-            }\n-        }).flat_map(|t| t).next().map(|s| s.to_string())\n-    } else {\n-        // Fallback to docs.rs\n-        // FIXME: Specify an exact version here (from Cargo.lock)\n-        Some(format!(\"https://docs.rs/{}/*\", krate.display_name(db)?))\n-    };\n-\n-    doc_url\n-        .map(|s| s.trim_matches('\"').trim_end_matches(\"/\").to_owned() + \"/\")\n-        .and_then(|s| Url::parse(&s).ok())\n-}\n-\n-/// Get the filename and extension generated for a symbol by rustdoc.\n-///\n-/// Example: `struct.Shard.html`\n-fn get_symbol_filename(db: &RootDatabase, definition: &Definition) -> Option<String> {\n-    Some(match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Adt(adt) => match adt {\n-                Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n-                Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-                Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n-            },\n-            ModuleDef::Module(_) => \"index.html\".to_string(),\n-            ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n-            ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-            ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n-            ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n-            ModuleDef::EnumVariant(ev) => {\n-                format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n-            }\n-            ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n-            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n-        },\n-        Definition::Macro(m) => format!(\"macro.{}.html\", m.name(db)?),\n-        _ => None?,\n-    })\n-}"}, {"sha": "2716a38cc990de11cf2d14e7cb5a205be2e72b0f", "filename": "crates/ra_ide_db/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2FCargo.toml?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -26,7 +26,6 @@ ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n ra_prof = { path = \"../ra_prof\" }\n test_utils = { path = \"../test_utils\" }\n-ra_hir_def = { path = \"../ra_hir_def\" }\n \n # ra_ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`."}, {"sha": "df56f2d9e609be87ef15531a00a72fe24cc52ae9", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f5f608b499ad50aa66b2213e3b92dd2fe61ed68/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=4f5f608b499ad50aa66b2213e3b92dd2fe61ed68", "patch": "@@ -6,7 +6,6 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    db::{DefDatabase, HirDatabase},\n     Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n     Semantics, TypeParam, Visibility,\n };\n@@ -17,7 +16,6 @@ use ra_syntax::{\n };\n \n use crate::RootDatabase;\n-use ra_hir_def::resolver::{HasResolver, Resolver};\n \n // FIXME: a more precise name would probably be `Symbol`?\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -78,21 +76,6 @@ impl Definition {\n         };\n         Some(name)\n     }\n-\n-    pub fn resolver<D: HirDatabase + DefDatabase>(&self, db: &D) -> Option<Resolver> {\n-        use hir::VariantDef;\n-        use ra_hir_def::*;\n-        Some(match self {\n-            Definition::ModuleDef(def) => def.resolver(db)?,\n-            Definition::Field(field) => {\n-                Into::<VariantId>::into(Into::<VariantDef>::into(field.parent_def(db))).resolver(db)\n-            }\n-            Definition::Macro(m) => Into::<ModuleId>::into(m.module(db)?).resolver(db),\n-            Definition::SelfType(imp) => Into::<ImplId>::into(imp.clone()).resolver(db),\n-            Definition::Local(local) => Into::<DefWithBodyId>::into(local.parent(db)).resolver(db),\n-            Definition::TypeParam(tp) => Into::<ModuleId>::into(tp.module(db)).resolver(db),\n-        })\n-    }\n }\n \n #[derive(Debug)]"}]}