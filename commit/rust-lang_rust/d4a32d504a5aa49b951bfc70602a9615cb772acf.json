{"sha": "d4a32d504a5aa49b951bfc70602a9615cb772acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YTMyZDUwNGE1YWE0OWI5NTFiZmM3MDYwMmE5NjE1Y2I3NzJhY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-27T08:13:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-27T08:13:23Z"}, "message": "Auto merge of #59887 - eddyb:safer-metadata, r=Zoxc\n\nrustc_metadata: more safely read/write the index positions.\n\nThis is a small part of a larger refactor, that I want to benchmark independently.\nThe final code would be even cleaner than this, so this is sort of an \"worst case\" test.", "tree": {"sha": "f3ad915896aa97d446182a0133e3f5712aa57b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3ad915896aa97d446182a0133e3f5712aa57b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4a32d504a5aa49b951bfc70602a9615cb772acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a32d504a5aa49b951bfc70602a9615cb772acf", "html_url": "https://github.com/rust-lang/rust/commit/d4a32d504a5aa49b951bfc70602a9615cb772acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4a32d504a5aa49b951bfc70602a9615cb772acf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfeb9171b11b0791059dbe3eeddbcfe017a4708a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfeb9171b11b0791059dbe3eeddbcfe017a4708a", "html_url": "https://github.com/rust-lang/rust/commit/cfeb9171b11b0791059dbe3eeddbcfe017a4708a"}, {"sha": "f51e6c708431f0f4de2a830c67be20d6242fdef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51e6c708431f0f4de2a830c67be20d6242fdef9", "html_url": "https://github.com/rust-lang/rust/commit/f51e6c708431f0f4de2a830c67be20d6242fdef9"}], "stats": {"total": 125, "additions": 80, "deletions": 45}, "files": [{"sha": "f9543a18c68a7729b4afbcb9f44dcee1de373550", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 80, "deletions": 45, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d4a32d504a5aa49b951bfc70602a9615cb772acf/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a32d504a5aa49b951bfc70602a9615cb772acf/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=d4a32d504a5aa49b951bfc70602a9615cb772acf", "patch": "@@ -2,10 +2,71 @@ use crate::schema::*;\n \n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace};\n use rustc_serialize::opaque::Encoder;\n-use std::slice;\n use std::u32;\n use log::debug;\n \n+/// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n+pub trait FixedSizeEncoding {\n+    const BYTE_LEN: usize;\n+\n+    // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n+    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+    fn from_bytes(b: &[u8]) -> Self;\n+    fn write_to_bytes(self, b: &mut [u8]);\n+\n+    // FIXME(eddyb) make these generic functions, or at least defaults here.\n+    // (same problem as above, needs `[u8; Self::BYTE_LEN]`)\n+    // For now, a macro (`fixed_size_encoding_byte_len_and_defaults`) is used.\n+    fn read_from_bytes_at(b: &[u8], i: usize) -> Self;\n+    fn write_to_bytes_at(self, b: &mut [u8], i: usize);\n+}\n+\n+// HACK(eddyb) this shouldn't be needed (see comments on the methods above).\n+macro_rules! fixed_size_encoding_byte_len_and_defaults {\n+    ($byte_len:expr) => {\n+        const BYTE_LEN: usize = $byte_len;\n+        fn read_from_bytes_at(b: &[u8], i: usize) -> Self {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // but slicing `[u8]` with `i * N..` is optimized worse, due to the\n+            // possibility of `i * N` overflowing, than indexing `[[u8; N]]`.\n+            let b = unsafe {\n+                std::slice::from_raw_parts(\n+                    b.as_ptr() as *const [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            Self::from_bytes(&b[i])\n+        }\n+        fn write_to_bytes_at(self, b: &mut [u8], i: usize) {\n+            const BYTE_LEN: usize = $byte_len;\n+            // HACK(eddyb) ideally this would be done with fully safe code,\n+            // see similar comment in `read_from_bytes_at` for why it can't yet.\n+            let b = unsafe {\n+                std::slice::from_raw_parts_mut(\n+                    b.as_mut_ptr() as *mut [u8; BYTE_LEN],\n+                    b.len() / BYTE_LEN,\n+                )\n+            };\n+            self.write_to_bytes(&mut b[i]);\n+        }\n+    }\n+}\n+\n+impl FixedSizeEncoding for u32 {\n+    fixed_size_encoding_byte_len_and_defaults!(4);\n+\n+    fn from_bytes(b: &[u8]) -> Self {\n+        let mut bytes = [0; Self::BYTE_LEN];\n+        bytes.copy_from_slice(&b[..Self::BYTE_LEN]);\n+        Self::from_le_bytes(bytes)\n+    }\n+\n+    fn write_to_bytes(self, b: &mut [u8]) {\n+        b[..Self::BYTE_LEN].copy_from_slice(&self.to_le_bytes());\n+    }\n+}\n+\n /// While we are generating the metadata, we also track the position\n /// of each DefIndex. It is not required that all definitions appear\n /// in the metadata, nor that they are serialized in order, and\n@@ -14,14 +75,14 @@ use log::debug;\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n pub struct Index {\n-    positions: [Vec<u32>; 2]\n+    positions: [Vec<u8>; 2]\n }\n \n impl Index {\n     pub fn new((max_index_lo, max_index_hi): (usize, usize)) -> Index {\n         Index {\n-            positions: [vec![u32::MAX; max_index_lo],\n-                        vec![u32::MAX; max_index_hi]],\n+            positions: [vec![0xff; max_index_lo * 4],\n+                        vec![0xff; max_index_hi * 4]],\n         }\n     }\n \n@@ -36,26 +97,27 @@ impl Index {\n         let space_index = item.address_space().index();\n         let array_index = item.as_array_index();\n \n-        assert!(self.positions[space_index][array_index] == u32::MAX,\n+        let positions = &mut self.positions[space_index];\n+        assert!(u32::read_from_bytes_at(positions, array_index) == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item,\n-                self.positions[space_index][array_index],\n+                u32::read_from_bytes_at(positions, array_index),\n                 position);\n \n-        self.positions[space_index][array_index] = position.to_le();\n+        position.write_to_bytes_at(positions, array_index)\n     }\n \n     pub fn write_index(&self, buf: &mut Encoder) -> LazySeq<Index> {\n         let pos = buf.position();\n \n         // First we write the length of the lower range ...\n-        buf.emit_raw_bytes(words_to_bytes(&[(self.positions[0].len() as u32).to_le()]));\n+        buf.emit_raw_bytes(&(self.positions[0].len() as u32 / 4).to_le_bytes());\n         // ... then the values in the lower range ...\n-        buf.emit_raw_bytes(words_to_bytes(&self.positions[0][..]));\n+        buf.emit_raw_bytes(&self.positions[0]);\n         // ... then the values in the higher range.\n-        buf.emit_raw_bytes(words_to_bytes(&self.positions[1][..]));\n+        buf.emit_raw_bytes(&self.positions[1]);\n         LazySeq::with_position_and_length(pos as usize,\n-            self.positions[0].len() + self.positions[1].len() + 1)\n+            (self.positions[0].len() + self.positions[1].len()) / 4 + 1)\n     }\n }\n \n@@ -64,24 +126,21 @@ impl<'tcx> LazySeq<Index> {\n     /// DefIndex (if any).\n     #[inline(never)]\n     pub fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-\n-        debug!(\"Index::lookup: index={:?} words.len={:?}\",\n+        let bytes = &bytes[self.position..];\n+        debug!(\"Index::lookup: index={:?} len={:?}\",\n                def_index,\n-               words.len());\n+               self.len);\n \n-        let positions = match def_index.address_space() {\n-            DefIndexAddressSpace::Low => &words[1..],\n+        let i = def_index.as_array_index() + match def_index.address_space() {\n+            DefIndexAddressSpace::Low => 0,\n             DefIndexAddressSpace::High => {\n                 // This is a DefIndex in the higher range, so find out where\n                 // that starts:\n-                let lo_count = u32::from_le(words[0].get()) as usize;\n-                &words[lo_count + 1 .. ]\n+                u32::read_from_bytes_at(bytes, 0) as usize\n             }\n         };\n \n-        let array_index = def_index.as_array_index();\n-        let position = u32::from_le(positions[array_index].get());\n+        let position = u32::read_from_bytes_at(bytes, 1 + i);\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n@@ -91,27 +150,3 @@ impl<'tcx> LazySeq<Index> {\n         }\n     }\n }\n-\n-#[repr(packed)]\n-#[derive(Copy)]\n-struct Unaligned<T>(T);\n-\n-// The derived Clone impl is unsafe for this packed struct since it needs to pass a reference to\n-// the field to `T::clone`, but this reference may not be properly aligned.\n-impl<T: Copy> Clone for Unaligned<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-impl<T> Unaligned<T> {\n-    fn get(self) -> T { self.0 }\n-}\n-\n-fn bytes_to_words(b: &[u8]) -> &[Unaligned<u32>] {\n-    unsafe { slice::from_raw_parts(b.as_ptr() as *const Unaligned<u32>, b.len() / 4) }\n-}\n-\n-fn words_to_bytes(w: &[u32]) -> &[u8] {\n-    unsafe { slice::from_raw_parts(w.as_ptr() as *const u8, w.len() * 4) }\n-}"}]}