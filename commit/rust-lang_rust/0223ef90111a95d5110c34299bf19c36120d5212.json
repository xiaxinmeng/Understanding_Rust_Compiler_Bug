{"sha": "0223ef90111a95d5110c34299bf19c36120d5212", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMjNlZjkwMTExYTk1ZDUxMTBjMzQyOTliZjE5YzM2MTIwZDUyMTI=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-05-19T17:50:58Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-07-18T02:32:32Z"}, "message": "Categorize queries for later self-profiling\n\nChange the define_queries! macro per feedback on #51657.\n\nBig thanks to @mark-i-m for the help getting the macro changes correct!", "tree": {"sha": "e155d482f3b9c264902cf25bb7d5154f8acf1a64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e155d482f3b9c264902cf25bb7d5154f8acf1a64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0223ef90111a95d5110c34299bf19c36120d5212", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0223ef90111a95d5110c34299bf19c36120d5212", "html_url": "https://github.com/rust-lang/rust/commit/0223ef90111a95d5110c34299bf19c36120d5212", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0223ef90111a95d5110c34299bf19c36120d5212/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7", "html_url": "https://github.com/rust-lang/rust/commit/4f3c7a472b77ba3f3afbc12d004b9d1bbcee7fe7"}], "stats": {"total": 1016, "additions": 563, "deletions": 453}, "files": [{"sha": "2fb289d023606ab821615981d27d6cddfcd92233", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 551, "deletions": 451, "changes": 1002, "blob_url": "https://github.com/rust-lang/rust/blob/0223ef90111a95d5110c34299bf19c36120d5212/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0223ef90111a95d5110c34299bf19c36120d5212/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=0223ef90111a95d5110c34299bf19c36120d5212", "patch": "@@ -97,457 +97,557 @@ pub use self::on_disk_cache::OnDiskCache;\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n define_queries! { <'tcx>\n-    /// Records the type of every item.\n-    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n-    /// associated generics.\n-    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-    /// predicates (where clauses) that must be proven true in order\n-    /// to reference it. This is almost always the \"predicates query\"\n-    /// that you want.\n-    ///\n-    /// `predicates_of` builds on `predicates_defined_on` -- in fact,\n-    /// it is almost always the same as that query, except for the\n-    /// case of traits. For traits, `predicates_of` contains\n-    /// an additional `Self: Trait<...>` predicate that users don't\n-    /// actually write. This reflects the fact that to invoke the\n-    /// trait (e.g., via `Default::default`) you must supply types\n-    /// that actually implement the trait. (However, this extra\n-    /// predicate gets in the way of some checks, which are intended\n-    /// to operate over only the actual where-clauses written by the\n-    /// user.)\n-    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-    /// predicates (where clauses) directly defined on it. This is\n-    /// equal to the `explicit_predicates_of` predicates plus the\n-    /// `inferred_outlives_of` predicates.\n-    [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// Returns the predicates written explicit by the user.\n-    [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// Returns the inferred outlives predicates (e.g., for `struct\n-    /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-    [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n-\n-    /// Maps from the def-id of a trait to the list of\n-    /// super-predicates. This is a subset of the full list of\n-    /// predicates. We store these in a separate map because we must\n-    /// evaluate them even during type conversion, often before the\n-    /// full predicates are available (note that supertraits have\n-    /// additional acyclicity requirements).\n-    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n-\n-    /// To avoid cycles within the predicates of a single item we compute\n-    /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n-        -> ty::GenericPredicates<'tcx>,\n-\n-    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] fn adt_dtorck_constraint: DtorckConstraint(\n-        DefId\n-    ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n-\n-    /// True if this is a const fn\n-    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n-\n-    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n-\n-    /// Get a map with the variance of every item; use `item_variance`\n-    /// instead.\n-    [] fn crate_variances: crate_variances(CrateNum) -> Lrc<ty::CrateVariancesMap>,\n-\n-    /// Maps from def-id of a type or region parameter to its\n-    /// (inferred) variance.\n-    [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n-\n-    /// Maps from def-id of a type to its (inferred) outlives.\n-    [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n-        -> Lrc<ty::CratePredicatesMap<'tcx>>,\n-\n-    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,\n-\n-    /// Maps from a trait item to the trait item \"descriptor\"\n-    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n-\n-    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n-\n-    /// Maps a DefId of a type to a list of its inherent impls.\n-    /// Contains implementations of methods that are inherent to a type.\n-    /// Methods in these implementations don't need to be exported.\n-    [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n-\n-    /// Set of all the def-ids in this crate that have MIR associated with\n-    /// them. This includes all the body owners, but also things like struct\n-    /// constructors.\n-    [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n-\n-    /// Maps DefId's that have an associated Mir to the result\n-    /// of the MIR qualify_consts pass. The actual meaning of\n-    /// the value isn't known except to the pass itself.\n-    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSetBuf<mir::Local>>),\n-\n-    /// Fetch the MIR for a given def-id right after it's built - this includes\n-    /// unreachable code.\n-    [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-    /// Fetch the MIR for a given def-id up till the point where it is\n-    /// ready for const evaluation.\n-    ///\n-    /// See the README for the `mir` module for details.\n-    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-    /// MIR after our optimization passes have run. This is MIR that is ready\n-    /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n-\n-    /// The result of unsafety-checking this def-id.\n-    [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n-\n-    /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n-    [] fn unsafe_derive_on_repr_packed: UnsafeDeriveOnReprPacked(DefId) -> (),\n-\n-    /// The signature of functions and closures.\n-    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n-\n-    /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n-        -> ty::adjustment::CoerceUnsizedInfo,\n-\n-    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n-\n-    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n-\n-    [] fn used_trait_imports: UsedTraitImports(DefId) -> Lrc<DefIdSet>,\n-\n-    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n-\n-    [] fn coherent_trait: CoherenceCheckTrait(DefId) -> (),\n-\n-    [] fn borrowck: BorrowCheck(DefId) -> Lrc<BorrowCheckResult>,\n-\n-    /// Borrow checks the function body. If this is a closure, returns\n-    /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n-\n-    /// Gets a complete map from all types to their inherent impls.\n-    /// Not meant to be used directly outside of coherence.\n-    /// (Defined only for LOCAL_CRATE)\n-    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n-\n-    /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n-    /// Not meant to be used directly outside of coherence.\n-    /// (Defined only for LOCAL_CRATE)\n-    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n-\n-    /// Results of evaluating const items or constants embedded in\n-    /// other items (such as enum variant explicit discriminants).\n-    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n-        -> ConstEvalResult<'tcx>,\n-\n-    /// Converts a constant value to an constant allocation\n-    [] fn const_value_to_allocation: const_value_to_allocation(\n-        &'tcx ty::Const<'tcx>\n-    ) -> &'tcx Allocation,\n-\n-    [] fn check_match: CheckMatch(DefId)\n-        -> Result<(), ErrorReported>,\n-\n-    /// Performs the privacy check and computes \"access levels\".\n-    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n-\n-    [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n-\n-    /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n-    /// in the case of closures, this will be redirected to the enclosing function.\n-    [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n-\n-    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n-    [] fn def_span: DefSpan(DefId) -> Span,\n-    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n-    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n-    [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n-    [] fn codegen_fn_attrs: codegen_fn_attrs(DefId) -> CodegenFnAttrs,\n-    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-    /// Gets the rendered value of the specified constant or associated constant.\n-    /// Used by rustdoc.\n-    [] fn rendered_const: RenderedConst(DefId) -> String,\n-    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n-    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n-    [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n-                          -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n-\n-    [] fn codegen_fulfill_obligation: fulfill_obligation_dep_node(\n-        (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n-    [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n-    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Lrc<specialization_graph::Graph>,\n-    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n-\n-    // Get the ParameterEnvironment for a given item; this environment\n-    // will be in \"user-facing\" mode, meaning that it is suitabe for\n-    // type-checking etc, and it does not normalize specializable\n-    // associated types. This is almost always what you want,\n-    // unless you are doing MIR optimizations, in which case you\n-    // might want to use `reveal_all()` method to change modes.\n-    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n-\n-    // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n-    // `ty.is_copy()`, etc, since that will prune the environment where possible.\n-    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                                  -> Result<&'tcx ty::layout::LayoutDetails,\n-                                            ty::layout::LayoutError<'tcx>>,\n-\n-    [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n-                                    -> Lrc<Vec<(CrateNum, LinkagePreference)>>,\n-\n-    [fatal_cycle] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n-    [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n-    [fatal_cycle] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n-    [fatal_cycle] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n-    [fatal_cycle] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n-    [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n-    [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n-\n-    [] fn extern_crate: ExternCrate(DefId) -> Lrc<Option<ExternCrate>>,\n-\n-    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-        -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>>,\n-    [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n-    [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n-\n-    [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n-\n-    [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n-    [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n-    [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n-\n-    // The DefIds of all non-generic functions and statics in the given crate\n-    // that can be reached from outside the crate.\n-    //\n-    // We expect this items to be available for being linked to.\n-    //\n-    // This query can also be called for LOCAL_CRATE. In this case it will\n-    // compute which items will be reachable to other crates, taking into account\n-    // the kind of crate that is currently compiled. Crates with only a\n-    // C interface have fewer reachable things.\n-    //\n-    // Does not include external symbols that don't have a corresponding DefId,\n-    // like the compiler-generated `main` function and so on.\n-    [] fn reachable_non_generics: ReachableNonGenerics(CrateNum)\n-        -> Lrc<DefIdMap<SymbolExportLevel>>,\n-    [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n-    [] fn is_unreachable_local_definition: IsUnreachableLocalDefinition(DefId) -> bool,\n-\n-    [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n-        -> Lrc<DefIdMap<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>>,\n-    [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n-        -> Option<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>,\n-\n-    [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n-\n-    [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n-\n-    [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n-    [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n-    [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n-    [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n-    [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n-    [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n-\n-    [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n-        -> Lrc<Vec<DefId>>,\n-    [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n-        -> Lrc<Vec<DefId>>,\n-\n-    [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n-        -> Lrc<FxHashSet<DefId>>,\n-    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n-    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n-    [] fn native_library_kind: NativeLibraryKind(DefId)\n-        -> Option<NativeLibraryKind>,\n-    [] fn link_args: link_args_node(CrateNum) -> Lrc<Vec<String>>,\n-\n-    // Lifetime resolution. See `middle::resolve_lifetimes`.\n-    [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Lrc<ResolveLifetimes>,\n-    [] fn named_region_map: NamedRegion(DefIndex) ->\n-        Option<Lrc<FxHashMap<ItemLocalId, Region>>>,\n-    [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n-        Option<Lrc<FxHashSet<ItemLocalId>>>,\n-    [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n-        -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n-\n-    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n-    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n-    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n-    [] fn item_children: ItemChildren(DefId) -> Lrc<Vec<Export>>,\n-    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n-\n-    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n-    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n-    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n-    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n-        -> Lrc<DefIdMap<DefId>>,\n-    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Lrc<CrateSource>,\n-    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-    [] fn freevars: Freevars(DefId) -> Option<Lrc<Vec<hir::Freevar>>>,\n-    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n-    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n-        -> Lrc<Vec<(DefId, Span)>>,\n-\n-    [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n-    [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n-\n-    /// A vector of every trait accessible in the whole crate\n-    /// (i.e. including those from subcrates). This is used only for\n-    /// error reporting.\n-    [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n-\n-    [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n-    [] fn collect_and_partition_mono_items:\n-        collect_and_partition_mono_items_node(CrateNum)\n-        -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn is_codegened_item: IsCodegenedItem(DefId) -> bool,\n-    [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n-    [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n-    [] fn output_filenames: output_filenames_node(CrateNum)\n-        -> Arc<OutputFilenames>,\n-\n-    // Erases regions from `ty` to yield a new type.\n-    // Normally you would just use `tcx.erase_regions(&value)`,\n-    // however, which uses this query as a kind of cache.\n-    [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n-\n-    /// Do not call this query directly: invoke `normalize` instead.\n-    [] fn normalize_projection_ty: NormalizeProjectionTy(\n-        CanonicalProjectionGoal<'tcx>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n-    [] fn normalize_ty_after_erasing_regions: NormalizeTyAfterErasingRegions(\n-        ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> Ty<'tcx>,\n-\n-    /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n-    [] fn dropck_outlives: DropckOutlives(\n-        CanonicalTyGoal<'tcx>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n-    /// `infcx.predicate_must_hold()` instead.\n-    [] fn evaluate_obligation: EvaluateObligation(\n-        CanonicalPredicateGoal<'tcx>\n-    ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n-\n-    /// Do not call this query directly: part of the `Eq` type-op\n-    [] fn type_op_eq: TypeOpEq(\n-        CanonicalTypeOpEqGoal<'tcx>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `Subtype` type-op\n-    [] fn type_op_subtype: TypeOpSubtype(\n-        CanonicalTypeOpSubtypeGoal<'tcx>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `ProvePredicate` type-op\n-    [] fn type_op_prove_predicate: TypeOpProvePredicate(\n-        CanonicalTypeOpProvePredicateGoal<'tcx>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `Normalize` type-op\n-    [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n-        CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Ty<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `Normalize` type-op\n-    [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n-        CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::Predicate<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `Normalize` type-op\n-    [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n-        CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::PolyFnSig<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    /// Do not call this query directly: part of the `Normalize` type-op\n-    [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n-        CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n-    ) -> Result<\n-        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::FnSig<'tcx>>>>,\n-        NoSolution,\n-    >,\n-\n-    [] fn substitute_normalize_and_test_predicates:\n-        substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n-\n-    [] fn target_features_whitelist:\n-        target_features_whitelist_node(CrateNum) -> Lrc<FxHashMap<String, Option<String>>>,\n-\n-    // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n-    [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n-        -> usize,\n-\n-    [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n-\n-    [] fn program_clauses_for: ProgramClausesFor(DefId) -> Clauses<'tcx>,\n-\n-    [] fn program_clauses_for_env: ProgramClausesForEnv(\n-        ty::ParamEnv<'tcx>\n-    ) -> Clauses<'tcx>,\n-\n-    [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)\n-        -> Lrc<FxHashMap<DefId, String>>,\n+    Other {\n+        /// Records the type of every item.\n+        [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+\n+        /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+        /// associated generics.\n+        [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+\n+        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n+        /// predicates (where clauses) that must be proven true in order\n+        /// to reference it. This is almost always the \"predicates query\"\n+        /// that you want.\n+        ///\n+        /// `predicates_of` builds on `predicates_defined_on` -- in fact,\n+        /// it is almost always the same as that query, except for the\n+        /// case of traits. For traits, `predicates_of` contains\n+        /// an additional `Self: Trait<...>` predicate that users don't\n+        /// actually write. This reflects the fact that to invoke the\n+        /// trait (e.g., via `Default::default`) you must supply types\n+        /// that actually implement the trait. (However, this extra\n+        /// predicate gets in the way of some checks, which are intended\n+        /// to operate over only the actual where-clauses written by the\n+        /// user.)\n+        [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n+        /// predicates (where clauses) directly defined on it. This is\n+        /// equal to the `explicit_predicates_of` predicates plus the\n+        /// `inferred_outlives_of` predicates.\n+        [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+        /// Returns the predicates written explicit by the user.\n+        [] fn explicit_predicates_of: ExplicitPredicatesOfItem(DefId)\n+            -> ty::GenericPredicates<'tcx>,\n+\n+        /// Returns the inferred outlives predicates (e.g., for `struct\n+        /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n+        [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n+\n+        /// Maps from the def-id of a trait to the list of\n+        /// super-predicates. This is a subset of the full list of\n+        /// predicates. We store these in a separate map because we must\n+        /// evaluate them even during type conversion, often before the\n+        /// full predicates are available (note that supertraits have\n+        /// additional acyclicity requirements).\n+        [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+\n+        /// To avoid cycles within the predicates of a single item we compute\n+        /// per-type-parameter predicates for resolving `T::AssocTy`.\n+        [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n+            -> ty::GenericPredicates<'tcx>,\n+\n+        [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+        [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n+        [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+        [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+        [] fn adt_dtorck_constraint: DtorckConstraint(\n+            DefId\n+        ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n+\n+        /// True if this is a const fn\n+        [] fn is_const_fn: IsConstFn(DefId) -> bool,\n+\n+        /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+        [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n+\n+        /// Get a map with the variance of every item; use `item_variance`\n+        /// instead.\n+        [] fn crate_variances: crate_variances(CrateNum) -> Lrc<ty::CrateVariancesMap>,\n+\n+        /// Maps from def-id of a type or region parameter to its\n+        /// (inferred) variance.\n+        [] fn variances_of: ItemVariances(DefId) -> Lrc<Vec<ty::Variance>>,\n+    },\n+\n+    TypeChecking {\n+        /// Maps from def-id of a type to its (inferred) outlives.\n+        [] fn inferred_outlives_crate: InferredOutlivesCrate(CrateNum)\n+            -> Lrc<ty::CratePredicatesMap<'tcx>>,\n+    },\n+\n+    Other {\n+        /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+        [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Lrc<Vec<DefId>>,\n+\n+        /// Maps from a trait item to the trait item \"descriptor\"\n+        [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+\n+        [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+        [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+    },\n+\n+    TypeChecking {\n+        /// Maps a DefId of a type to a list of its inherent impls.\n+        /// Contains implementations of methods that are inherent to a type.\n+        /// Methods in these implementations don't need to be exported.\n+        [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n+    },\n+\n+    Codegen {\n+        /// Set of all the def-ids in this crate that have MIR associated with\n+        /// them. This includes all the body owners, but also things like struct\n+        /// constructors.\n+        [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n+\n+        /// Maps DefId's that have an associated Mir to the result\n+        /// of the MIR qualify_consts pass. The actual meaning of\n+        /// the value isn't known except to the pass itself.\n+        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSetBuf<mir::Local>>),\n+\n+        /// Fetch the MIR for a given def-id right after it's built - this includes\n+        /// unreachable code.\n+        [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+        /// Fetch the MIR for a given def-id up till the point where it is\n+        /// ready for const evaluation.\n+        ///\n+        /// See the README for the `mir` module for details.\n+        [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+        [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+\n+        /// MIR after our optimization passes have run. This is MIR that is ready\n+        /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n+        [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+    },\n+\n+    TypeChecking {\n+        /// The result of unsafety-checking this def-id.\n+        [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n+\n+        /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n+        [] fn unsafe_derive_on_repr_packed: UnsafeDeriveOnReprPacked(DefId) -> (),\n+\n+        /// The signature of functions and closures.\n+        [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    },\n+\n+    Other {\n+        /// Caches CoerceUnsized kinds for impls on custom types.\n+        [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n+            -> ty::adjustment::CoerceUnsizedInfo,\n+    },\n+\n+    TypeChecking {\n+        [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+\n+        [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    },\n+\n+    Other {\n+        [] fn used_trait_imports: UsedTraitImports(DefId) -> Lrc<DefIdSet>,\n+    },\n+\n+    TypeChecking {\n+        [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n+\n+        [] fn coherent_trait: CoherenceCheckTrait(DefId) -> (),\n+    },\n+\n+    BorrowChecking {\n+        [] fn borrowck: BorrowCheck(DefId) -> Lrc<BorrowCheckResult>,\n+\n+        /// Borrow checks the function body. If this is a closure, returns\n+        /// additional requirements that the closure's creator must verify.\n+        [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n+    },\n+\n+    TypeChecking {\n+        /// Gets a complete map from all types to their inherent impls.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for LOCAL_CRATE)\n+        [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+\n+        /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+        /// Not meant to be used directly outside of coherence.\n+        /// (Defined only for LOCAL_CRATE)\n+        [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum)\n+            -> (),\n+    },\n+\n+    Other {\n+        /// Results of evaluating const items or constants embedded in\n+        /// other items (such as enum variant explicit discriminants).\n+        [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n+            -> ConstEvalResult<'tcx>,\n+\n+        /// Converts a constant value to an constant allocation\n+        [] fn const_value_to_allocation: const_value_to_allocation(\n+            &'tcx ty::Const<'tcx>\n+        ) -> &'tcx Allocation,\n+    },\n+\n+    TypeChecking {\n+        [] fn check_match: CheckMatch(DefId)\n+            -> Result<(), ErrorReported>,\n+\n+        /// Performs the privacy check and computes \"access levels\".\n+        [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Lrc<AccessLevels>,\n+    },\n+\n+    Other {\n+        [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n+\n+        /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n+        /// in the case of closures, this will be redirected to the enclosing function.\n+        [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n+\n+        [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n+\n+        [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+        [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+\n+        [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n+        [] fn def_span: DefSpan(DefId) -> Span,\n+        [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n+        [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n+        [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n+    },\n+\n+    Codegen {\n+        [] fn codegen_fn_attrs: codegen_fn_attrs(DefId) -> CodegenFnAttrs,\n+    },\n+\n+    Other {\n+        [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+        /// Gets the rendered value of the specified constant or associated constant.\n+        /// Used by rustdoc.\n+        [] fn rendered_const: RenderedConst(DefId) -> String,\n+        [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n+    },\n+\n+    TypeChecking {\n+        [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n+        [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+        [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n+    },\n+\n+    Codegen {\n+        [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+    },\n+\n+    Other {\n+        [] fn vtable_methods: vtable_methods_node(ty::PolyTraitRef<'tcx>)\n+                            -> Lrc<Vec<Option<(DefId, &'tcx Substs<'tcx>)>>>,\n+    },\n+\n+    Codegen {\n+        [] fn codegen_fulfill_obligation: fulfill_obligation_dep_node(\n+            (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> Vtable<'tcx, ()>,\n+    },\n+\n+    TypeChecking {\n+        [] fn trait_impls_of: TraitImpls(DefId) -> Lrc<ty::trait_def::TraitImpls>,\n+        [] fn specialization_graph_of: SpecializationGraph(DefId)\n+            -> Lrc<specialization_graph::Graph>,\n+        [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n+\n+        // Get the ParameterEnvironment for a given item; this environment\n+        // will be in \"user-facing\" mode, meaning that it is suitabe for\n+        // type-checking etc, and it does not normalize specializable\n+        // associated types. This is almost always what you want,\n+        // unless you are doing MIR optimizations, in which case you\n+        // might want to use `reveal_all()` method to change modes.\n+        [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+\n+        // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n+        // `ty.is_copy()`, etc, since that will prune the environment where possible.\n+        [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+        [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+        [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+        [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+        [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                                    -> Result<&'tcx ty::layout::LayoutDetails,\n+                                                ty::layout::LayoutError<'tcx>>,\n+    },\n+\n+    Other {\n+        [] fn dylib_dependency_formats: DylibDepFormats(CrateNum)\n+                                        -> Lrc<Vec<(CrateNum, LinkagePreference)>>,\n+    },\n+\n+    Codegen {\n+        [fatal_cycle] fn is_panic_runtime: IsPanicRuntime(CrateNum) -> bool,\n+        [fatal_cycle] fn is_compiler_builtins: IsCompilerBuiltins(CrateNum) -> bool,\n+        [fatal_cycle] fn has_global_allocator: HasGlobalAllocator(CrateNum) -> bool,\n+        [fatal_cycle] fn is_sanitizer_runtime: IsSanitizerRuntime(CrateNum) -> bool,\n+        [fatal_cycle] fn is_profiler_runtime: IsProfilerRuntime(CrateNum) -> bool,\n+        [fatal_cycle] fn panic_strategy: GetPanicStrategy(CrateNum) -> PanicStrategy,\n+        [fatal_cycle] fn is_no_builtins: IsNoBuiltins(CrateNum) -> bool,\n+\n+        [] fn extern_crate: ExternCrate(DefId) -> Lrc<Option<ExternCrate>>,\n+    },\n+\n+    TypeChecking {\n+        [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n+        [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<StableVec<TraitCandidate>>>>>,\n+    },\n+\n+    Other {\n+        [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n+        [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n+    },\n+\n+    TypeChecking {\n+        [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n+\n+        [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n+        [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n+        [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n+    },\n+\n+    Linking {\n+        // The DefIds of all non-generic functions and statics in the given crate\n+        // that can be reached from outside the crate.\n+        //\n+        // We expect this items to be available for being linked to.\n+        //\n+        // This query can also be called for LOCAL_CRATE. In this case it will\n+        // compute which items will be reachable to other crates, taking into account\n+        // the kind of crate that is currently compiled. Crates with only a\n+        // C interface have fewer reachable things.\n+        //\n+        // Does not include external symbols that don't have a corresponding DefId,\n+        // like the compiler-generated `main` function and so on.\n+        [] fn reachable_non_generics: ReachableNonGenerics(CrateNum)\n+            -> Lrc<DefIdMap<SymbolExportLevel>>,\n+        [] fn is_reachable_non_generic: IsReachableNonGeneric(DefId) -> bool,\n+        [] fn is_unreachable_local_definition: IsUnreachableLocalDefinition(DefId) -> bool,\n+    },\n+\n+    Codegen {\n+        [] fn upstream_monomorphizations: UpstreamMonomorphizations(CrateNum)\n+            -> Lrc<DefIdMap<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>>,\n+        [] fn upstream_monomorphizations_for: UpstreamMonomorphizationsFor(DefId)\n+            -> Option<Lrc<FxHashMap<&'tcx Substs<'tcx>, CrateNum>>>,\n+    },\n+\n+    Other {\n+        [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n+\n+        [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n+\n+        [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n+        [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n+        [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n+        [] fn crate_hash: CrateHash(CrateNum) -> Svh,\n+        [] fn original_crate_name: OriginalCrateName(CrateNum) -> Symbol,\n+        [] fn extra_filename: ExtraFileName(CrateNum) -> String,\n+    },\n+\n+    TypeChecking {\n+        [] fn implementations_of_trait: implementations_of_trait_node((CrateNum, DefId))\n+            -> Lrc<Vec<DefId>>,\n+        [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n+            -> Lrc<Vec<DefId>>,\n+    },\n+\n+    Other {\n+        [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n+            -> Lrc<FxHashSet<DefId>>,\n+        [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+        [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+        [] fn native_library_kind: NativeLibraryKind(DefId)\n+            -> Option<NativeLibraryKind>,\n+    },\n+\n+    Linking {\n+        [] fn link_args: link_args_node(CrateNum) -> Lrc<Vec<String>>,\n+    },\n+\n+    BorrowChecking {\n+        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Lrc<ResolveLifetimes>,\n+        [] fn named_region_map: NamedRegion(DefIndex) ->\n+            Option<Lrc<FxHashMap<ItemLocalId, Region>>>,\n+        [] fn is_late_bound_map: IsLateBound(DefIndex) ->\n+            Option<Lrc<FxHashSet<ItemLocalId>>>,\n+        [] fn object_lifetime_defaults_map: ObjectLifetimeDefaults(DefIndex)\n+            -> Option<Lrc<FxHashMap<ItemLocalId, Lrc<Vec<ObjectLifetimeDefault>>>>>,\n+    },\n+\n+    TypeChecking {\n+        [] fn visibility: Visibility(DefId) -> ty::Visibility,\n+    },\n+\n+    Other {\n+        [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n+        [] fn crate_name: CrateName(CrateNum) -> Symbol,\n+        [] fn item_children: ItemChildren(DefId) -> Lrc<Vec<Export>>,\n+        [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n+\n+        [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n+        [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n+        [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n+        [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n+            -> Lrc<DefIdMap<DefId>>,\n+        [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+        [] fn used_crate_source: UsedCrateSource(CrateNum) -> Lrc<CrateSource>,\n+        [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n+\n+        [] fn freevars: Freevars(DefId) -> Option<Lrc<Vec<hir::Freevar>>>,\n+        [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(DefId) -> bool,\n+        [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n+            -> Lrc<Vec<(DefId, Span)>>,\n+\n+        [] fn stability_index: stability_index_node(CrateNum) -> Lrc<stability::Index<'tcx>>,\n+        [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n+\n+        /// A vector of every trait accessible in the whole crate\n+        /// (i.e. including those from subcrates). This is used only for\n+        /// error reporting.\n+        [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n+    },\n+\n+    Linking {\n+        [] fn exported_symbols: ExportedSymbols(CrateNum)\n+            -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>>,\n+    },\n+\n+    Codegen {\n+        [] fn collect_and_partition_mono_items:\n+            collect_and_partition_mono_items_node(CrateNum)\n+            -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n+        [] fn is_codegened_item: IsCodegenedItem(DefId) -> bool,\n+        [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n+        [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n+    },\n+\n+    Other {\n+        [] fn output_filenames: output_filenames_node(CrateNum)\n+            -> Arc<OutputFilenames>,\n+    },\n+\n+    TypeChecking {\n+        // Erases regions from `ty` to yield a new type.\n+        // Normally you would just use `tcx.erase_regions(&value)`,\n+        // however, which uses this query as a kind of cache.\n+        [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n+\n+        /// Do not call this query directly: invoke `normalize` instead.\n+        [] fn normalize_projection_ty: NormalizeProjectionTy(\n+            CanonicalProjectionGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, NormalizationResult<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n+        [] fn normalize_ty_after_erasing_regions: NormalizeTyAfterErasingRegions(\n+            ParamEnvAnd<'tcx, Ty<'tcx>>\n+        ) -> Ty<'tcx>,\n+\n+        /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n+        [] fn dropck_outlives: DropckOutlives(\n+            CanonicalTyGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: invoke `infcx.predicate_may_hold()` or\n+        /// `infcx.predicate_must_hold()` instead.\n+        [] fn evaluate_obligation: EvaluateObligation(\n+            CanonicalPredicateGoal<'tcx>\n+        ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n+\n+        /// Do not call this query directly: part of the `Eq` type-op\n+        [] fn type_op_eq: TypeOpEq(\n+            CanonicalTypeOpEqGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `Subtype` type-op\n+        [] fn type_op_subtype: TypeOpSubtype(\n+            CanonicalTypeOpSubtypeGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `ProvePredicate` type-op\n+        [] fn type_op_prove_predicate: TypeOpProvePredicate(\n+            CanonicalTypeOpProvePredicateGoal<'tcx>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n+            CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Ty<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n+            CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::Predicate<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n+            CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::PolyFnSig<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        /// Do not call this query directly: part of the `Normalize` type-op\n+        [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n+            CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n+        ) -> Result<\n+            Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::FnSig<'tcx>>>>,\n+            NoSolution,\n+        >,\n+\n+        [] fn substitute_normalize_and_test_predicates:\n+            substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+    },\n+\n+    Other {\n+        [] fn target_features_whitelist:\n+            target_features_whitelist_node(CrateNum) -> Lrc<FxHashMap<String, Option<String>>>,\n+\n+        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+        [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n+            -> usize,\n+\n+        [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n+    },\n+\n+    TypeChecking {\n+        [] fn program_clauses_for: ProgramClausesFor(DefId) -> Clauses<'tcx>,\n+\n+        [] fn program_clauses_for_env: ProgramClausesForEnv(\n+            ty::ParamEnv<'tcx>\n+        ) -> Clauses<'tcx>,\n+    },\n+\n+    Linking {\n+        [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)\n+            -> Lrc<FxHashMap<DefId, String>>,\n+    },\n }\n \n // `try_get_query` can't be public because it uses the private query"}, {"sha": "78e1a6425465b8a2c40401ee8414253c6d78dbe7", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0223ef90111a95d5110c34299bf19c36120d5212/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0223ef90111a95d5110c34299bf19c36120d5212/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=0223ef90111a95d5110c34299bf19c36120d5212", "patch": "@@ -631,9 +631,19 @@ macro_rules! handle_cycle_error {\n }\n \n macro_rules! define_queries {\n+    (<$tcx:tt> $($category:tt {\n+        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n+    },)*) => {\n+        define_queries_inner! { <$tcx>\n+            $($( $(#[$attr])* category<$category> [$($modifiers)*] fn $name: $node($K) -> $V,)*)*\n+        }\n+    }\n+}\n+\n+macro_rules! define_queries_inner {\n     (<$tcx:tt>\n-     $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+     $($(#[$attr:meta])* category<$category:tt>\n+        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use std::mem;\n         #[cfg(parallel_queries)]"}]}