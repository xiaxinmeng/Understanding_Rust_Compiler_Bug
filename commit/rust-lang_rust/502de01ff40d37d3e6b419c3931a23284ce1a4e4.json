{"sha": "502de01ff40d37d3e6b419c3931a23284ce1a4e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMmRlMDFmZjQwZDM3ZDNlNmI0MTljMzkzMWEyMzI4NGNlMWE0ZTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T16:00:22Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-25T20:05:24Z"}, "message": "rustc: SIMD types use pointers in Rust's ABI\n\nThis commit changes the ABI of SIMD types in the \"Rust\" ABI to unconditionally\nbe passed via pointers instead of being passed as immediates. This should fix a\nlongstanding issue, #44367, where SIMD-using programs ended up showing very odd\nbehavior at runtime because the ABI between functions was mismatched.\n\nAs a bit of a recap, this is sort of an LLVM bug and sort of an LLVM feature\n(today's behavior). LLVM will generate code for a function solely looking at the\nfunction it's generating, including calls to other functions. Let's then say\nyou've got something that looks like:\n\n```llvm\ndefine void @foo() { ; no target features enabled\n  call void @bar(<i64 x 4> zeroinitializer)\n  ret void\n}\n\ndefine void @bar(<i64 x 4>) #0 { ; enables the AVX feature\n  ...\n}\n```\n\nLLVM will codegen the call to `bar` *without* using AVX registers becauase `foo`\ndoesn't have access to these registers. Instead it's generated with emulation\nthat uses two 128-bit registers. The `bar` function, on the other hand, will\nexpect its argument in an AVX register (as it has AVX enabled). This means we've\ngot a codegen problem!\n\nComments on #44367 have some more contexutal information but the crux of the\nissue is that if we want SIMD to work in general we'll need to ensure that\nwhenever a function calls another they ABI of the arguments being passed is in\nagreement.\n\nOne possible solution to this would be to insert \"shim functions\" where whenever\na `target_feature` mismatch is detected the compiler inserts a shim function\nwhere you pass arguments via memory to the shim and then the shim loads the\nvalues and calls the target function (where the shim and the target have the\nsame target features enabled). This unfortunately is quite nontrivial to\nimplement in rustc today (especially when accounting for function pointers and\nsuch).\n\nThis commit takes a different solution, *always* passing SIMD arguments through\nmemory instead of passing as immediates. This strategy solves the problem at the\nLLVM layer because the ABI between two functions never uses SIMD registers. This\nalso shouldn't be a hit to performance because SIMD performance is thought to\noften rely on inlining anyway, where a `call` instruction, even if using SIMD\nregisters, would be disastrous to performance regardless. LLVM should then be\nmore than capable of fixing all our memory usage to use registers instead after\nenough inlining has been performed.\n\nNote that there's a few caveats to this commit though:\n\n* The \"platform intrinsic\" ABI is omitted from \"always pass via memory\". This\n  ABI is used to define intrinsics like `simd_shuffle4` where LLVM and rustc\n  need to have the arguments as an immediate.\n\n* Additionally this commit does *not* fix the `extern` (\"C\") ABI. This means\n  that the bug in #44367 can still happen when using non-Rust-ABI functions. My\n  hope is that before stabilization we can ban and/or warn about SIMD types in\n  these functions (as AFAIK there's not much motivation to belong there anyway),\n  but I'll leave that for a later commit and if this is merged I'll file a\n  follow-up issue.\n\nAll in all this...\n\nCloses #44367", "tree": {"sha": "a0505b172b60f895621b2f3c34fe2dddd6eadc98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0505b172b60f895621b2f3c34fe2dddd6eadc98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/502de01ff40d37d3e6b419c3931a23284ce1a4e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/502de01ff40d37d3e6b419c3931a23284ce1a4e4", "html_url": "https://github.com/rust-lang/rust/commit/502de01ff40d37d3e6b419c3931a23284ce1a4e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/502de01ff40d37d3e6b419c3931a23284ce1a4e4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0dcecff90c45ad5d4eb60859e22bb3f1b03842a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0dcecff90c45ad5d4eb60859e22bb3f1b03842a", "html_url": "https://github.com/rust-lang/rust/commit/a0dcecff90c45ad5d4eb60859e22bb3f1b03842a"}], "stats": {"total": 210, "additions": 207, "deletions": 3}, "files": [{"sha": "9cabd9356e9bfe17b8c55554a6c664126d774aed", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=502de01ff40d37d3e6b419c3931a23284ce1a4e4", "patch": "@@ -871,6 +871,31 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n                 match arg.layout.abi {\n                     layout::Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    layout::Abi::Vector { .. } if abi != Abi::PlatformIntrinsic => {\n+                        arg.make_indirect();\n+                        return\n+                    }\n+\n                     _ => return\n                 }\n "}, {"sha": "dc9f63c35db2eadd00a6309477c93968d551d375", "filename": "src/test/codegen/x86_mmx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Ftest%2Fcodegen%2Fx86_mmx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fx86_mmx.rs?ref=502de01ff40d37d3e6b419c3931a23284ce1a4e4", "patch": "@@ -22,9 +22,7 @@ pub struct i8x8(u64);\n \n #[no_mangle]\n pub fn a(a: &mut i8x8, b: i8x8) -> i8x8 {\n-    // CHECK-LABEL: define x86_mmx @a(x86_mmx*{{.*}}, x86_mmx{{.*}})\n-    // CHECK: store x86_mmx %b, x86_mmx* %a\n-    // CHECK: ret x86_mmx %b\n+    // CHECK-LABEL: define void @a(x86_mmx*{{.*}}, x86_mmx*{{.*}}, x86_mmx*{{.*}})\n     *a = b;\n     return b\n }"}, {"sha": "b60aec2b5c923113d1c37fc5fb4d7508cde43f2c", "filename": "src/test/run-pass/simd-target-feature-mixup.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/502de01ff40d37d3e6b419c3931a23284ce1a4e4/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-target-feature-mixup.rs?ref=502de01ff40d37d3e6b419c3931a23284ce1a4e4", "patch": "@@ -0,0 +1,181 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, target_feature, cfg_target_feature)]\n+\n+use std::process::{Command, ExitStatus};\n+use std::env;\n+\n+fn main() {\n+    if let Some(level) = env::args().nth(1) {\n+        return test::main(&level)\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    for level in [\"sse\", \"avx\", \"avx512\"].iter() {\n+        let status = Command::new(&me).arg(level).status().unwrap();\n+        if status.success() {\n+            println!(\"success with {}\", level);\n+            continue\n+        }\n+\n+        // We don't actually know if our computer has the requisite target features\n+        // for the test below. Testing for that will get added to libstd later so\n+        // for now just asume sigill means this is a machine that can't run this test.\n+        if is_sigill(status) {\n+            println!(\"sigill with {}, assuming spurious\", level);\n+            continue\n+        }\n+        panic!(\"invalid status at {}: {}\", level, status);\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    use std::os::unix::prelude::*;\n+    status.signal() == Some(4)\n+}\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[allow(bad_style)]\n+mod test {\n+    // An SSE type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m128i(u64, u64);\n+\n+    // An AVX type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m256i(u64, u64, u64, u64);\n+\n+    // An AVX-512 type\n+    #[repr(simd)]\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct __m512i(u64, u64, u64, u64, u64, u64, u64, u64);\n+\n+    pub fn main(level: &str) {\n+        unsafe {\n+            main_normal(level);\n+            main_sse(level);\n+            if level == \"sse\" {\n+                return\n+            }\n+            main_avx(level);\n+            if level == \"avx\" {\n+                return\n+            }\n+            main_avx512(level);\n+        }\n+    }\n+\n+    macro_rules! mains {\n+        ($(\n+            $(#[$attr:meta])*\n+            unsafe fn $main:ident(level: &str) {\n+                ...\n+            }\n+        )*) => ($(\n+            $(#[$attr])*\n+            unsafe fn $main(level: &str) {\n+                let m128 = __m128i(1, 2);\n+                let m256 = __m256i(3, 4, 5, 6);\n+                let m512 = __m512i(7, 8, 9, 10, 11, 12, 13, 14);\n+                assert_eq!(id_sse_128(m128), m128);\n+                assert_eq!(id_sse_256(m256), m256);\n+                assert_eq!(id_sse_512(m512), m512);\n+\n+                if level == \"sse\" {\n+                    return\n+                }\n+                assert_eq!(id_avx_128(m128), m128);\n+                assert_eq!(id_avx_256(m256), m256);\n+                assert_eq!(id_avx_512(m512), m512);\n+\n+                if level == \"avx\" {\n+                    return\n+                }\n+                assert_eq!(id_avx512_128(m128), m128);\n+                assert_eq!(id_avx512_256(m256), m256);\n+                assert_eq!(id_avx512_512(m512), m512);\n+            }\n+        )*)\n+    }\n+\n+    mains! {\n+        unsafe fn main_normal(level: &str) { ... }\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn main_sse(level: &str) { ... }\n+        #[target_feature(enable = \"avx\")]\n+        unsafe fn main_avx(level: &str) { ... }\n+        #[target_feature(enable = \"avx512bw\")]\n+        unsafe fn main_avx512(level: &str) { ... }\n+    }\n+\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_128(a: __m128i) -> __m128i {\n+        assert_eq!(a, __m128i(1, 2));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_256(a: __m256i) -> __m256i {\n+        assert_eq!(a, __m256i(3, 4, 5, 6));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_512(a: __m512i) -> __m512i {\n+        assert_eq!(a, __m512i(7, 8, 9, 10, 11, 12, 13, 14));\n+        a.clone()\n+    }\n+}\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+mod test {\n+    pub fn main(level: &str) {}\n+}"}]}