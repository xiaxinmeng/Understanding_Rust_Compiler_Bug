{"sha": "7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "node_id": "C_kwDOAAsO6NoAKDc1MjVhMzhhZjVlYmQ5ZWVmNDA0YjE5YTExY2VmZThhMDMzZjlkMmQ", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-14T08:44:02Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T09:38:35Z"}, "message": "Support evaluating `dyn Trait` methods", "tree": {"sha": "513e6dae074877a7b2a1c947d526689953698163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/513e6dae074877a7b2a1c947d526689953698163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "html_url": "https://github.com/rust-lang/rust/commit/7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a063f000ff99989406abd1e6f58a9c2b576ba41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a063f000ff99989406abd1e6f58a9c2b576ba41a", "html_url": "https://github.com/rust-lang/rust/commit/a063f000ff99989406abd1e6f58a9c2b576ba41a"}], "stats": {"total": 257, "additions": 197, "deletions": 60}, "files": [{"sha": "f7914b578e437a9410a1017921a6fe7607de636d", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "patch": "@@ -1008,6 +1008,57 @@ fn function_traits() {\n     );\n }\n \n+#[test]\n+fn dyn_trait() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> u8 { 10 }\n+    }\n+    struct S1;\n+    struct S2;\n+    struct S3;\n+    impl Foo for S1 {\n+        fn foo(&self) -> u8 { 1 }\n+    }\n+    impl Foo for S2 {\n+        fn foo(&self) -> u8 { 2 }\n+    }\n+    impl Foo for S3 {}\n+    const GOAL: u8 = {\n+        let x: &[&dyn Foo] = &[&S1, &S2, &S3];\n+        x[0].foo() + x[1].foo() + x[2].foo()\n+    };\n+        \"#,\n+        13,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    trait Foo {\n+        fn foo(&self) -> i32 { 10 }\n+    }\n+    trait Bar {\n+        fn bar(&self) -> i32 { 20 }\n+    }\n+\n+    struct S;\n+    impl Foo for S {\n+        fn foo(&self) -> i32 { 200 }\n+    }\n+    impl Bar for dyn Foo {\n+        fn bar(&self) -> i32 { 700 }\n+    }\n+    const GOAL: i32 = {\n+        let x: &dyn Foo = &S;\n+        x.bar() + x.foo()\n+    };\n+        \"#,\n+        900,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number("}, {"sha": "6244b98104fe6962cba82ef1e8853486ea59f8d6", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "patch": "@@ -5,7 +5,7 @@\n use std::{ops::ControlFlow, sync::Arc};\n \n use base_db::{CrateId, Edition};\n-use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex};\n+use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex, WhereClause};\n use hir_def::{\n     data::ImplData, item_scope::ItemScope, lang_item::LangItem, nameres::DefMap, AssocItemId,\n     BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n@@ -692,6 +692,38 @@ pub fn lookup_impl_const(\n         .unwrap_or((const_id, subs))\n }\n \n+/// Checks if the self parameter of `Trait` method is the `dyn Trait` and we should\n+/// call the method using the vtable.\n+pub fn is_dyn_method(\n+    db: &dyn HirDatabase,\n+    _env: Arc<TraitEnvironment>,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> Option<usize> {\n+    let ItemContainerId::TraitId(trait_id) = func.lookup(db.upcast()).container else {\n+        return None;\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    if let TyKind::Dyn(d) = self_ty.kind(Interner) {\n+        let is_my_trait_in_bounds = d.bounds.skip_binders().as_slice(Interner).iter().any(|x| match x.skip_binders() {\n+            // rustc doesn't accept `impl Foo<2> for dyn Foo<5>`, so if the trait id is equal, no matter\n+            // what the generics are, we are sure that the method is come from the vtable.\n+            WhereClause::Implemented(tr) => tr.trait_id == trait_ref.trait_id,\n+            _ => false,\n+        });\n+        if is_my_trait_in_bounds {\n+            return Some(fn_params);\n+        }\n+    }\n+    None\n+}\n+\n /// Looks up the impl method that actually runs for the trait method `func`.\n ///\n /// Returns `func` if it's not a method defined in a trait or the lookup failed.\n@@ -701,9 +733,8 @@ pub fn lookup_impl_method(\n     func: FunctionId,\n     fn_subst: Substitution,\n ) -> (FunctionId, Substitution) {\n-    let trait_id = match func.lookup(db.upcast()).container {\n-        ItemContainerId::TraitId(id) => id,\n-        _ => return (func, fn_subst),\n+    let ItemContainerId::TraitId(trait_id) = func.lookup(db.upcast()).container else {\n+        return (func, fn_subst)\n     };\n     let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n     let fn_params = fn_subst.len(Interner) - trait_params;"}, {"sha": "7293156a978f91ed18e9384718066b82c0c95d00", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 103, "deletions": 55, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "patch": "@@ -23,17 +23,26 @@ use crate::{\n     infer::{normalize, PointerCast},\n     layout::layout_of_ty,\n     mapping::from_chalk,\n-    method_resolution::lookup_impl_method,\n+    method_resolution::{is_dyn_method, lookup_impl_method},\n     traits::FnTrait,\n     CallableDefId, Const, ConstScalar, FnDefId, Interner, MemoryMap, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyExt,\n+    TraitEnvironment, Ty, TyBuilder, TyExt, GenericArgData,\n };\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n     Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n };\n \n+macro_rules! from_bytes {\n+    ($ty:tt, $value:expr) => {\n+        ($ty::from_le_bytes(match ($value).try_into() {\n+            Ok(x) => x,\n+            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+        }))\n+    };\n+}\n+\n #[derive(Debug, Default)]\n struct VTableMap {\n     ty_to_id: HashMap<Ty, usize>,\n@@ -54,6 +63,11 @@ impl VTableMap {\n     fn ty(&self, id: usize) -> Result<&Ty> {\n         self.id_to_ty.get(id).ok_or(MirEvalError::InvalidVTableId(id))\n     }\n+\n+    fn ty_of_bytes(&self, bytes: &[u8]) -> Result<&Ty> {\n+        let id = from_bytes!(usize, bytes);\n+        self.ty(id)\n+    }\n }\n \n pub struct Evaluator<'a> {\n@@ -110,15 +124,6 @@ impl IntervalOrOwned {\n     }\n }\n \n-macro_rules! from_bytes {\n-    ($ty:tt, $value:expr) => {\n-        ($ty::from_le_bytes(match ($value).try_into() {\n-            Ok(x) => x,\n-            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n-        }))\n-    };\n-}\n-\n impl Address {\n     fn from_bytes(x: &[u8]) -> Result<Self> {\n         Ok(Address::from_usize(from_bytes!(usize, x)))\n@@ -781,7 +786,18 @@ impl Evaluator<'_> {\n                                         }\n                                         _ => not_supported!(\"slice unsizing from non pointers\"),\n                                     },\n-                                    TyKind::Dyn(_) => not_supported!(\"dyn pointer unsize cast\"),\n+                                    TyKind::Dyn(_) => match &current_ty.data(Interner).kind {\n+                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                            let vtable = self.vtable_map.id(ty.clone());\n+                                            let addr =\n+                                                self.eval_operand(operand, locals)?.get(&self)?;\n+                                            let mut r = Vec::with_capacity(16);\n+                                            r.extend(addr.iter().copied());\n+                                            r.extend(vtable.to_le_bytes().into_iter());\n+                                            Owned(r)\n+                                        }\n+                                        _ => not_supported!(\"dyn unsizing from non pointers\"),\n+                                    },\n                                     _ => not_supported!(\"unknown unsized cast\"),\n                                 }\n                             }\n@@ -1227,44 +1243,8 @@ impl Evaluator<'_> {\n                 let arg_bytes = args\n                     .iter()\n                     .map(|x| Ok(self.eval_operand(x, &locals)?.get(&self)?.to_owned()))\n-                    .collect::<Result<Vec<_>>>()?\n-                    .into_iter();\n-                let function_data = self.db.function_data(def);\n-                let is_intrinsic = match &function_data.abi {\n-                    Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n-                    None => match def.lookup(self.db.upcast()).container {\n-                        hir_def::ItemContainerId::ExternBlockId(block) => {\n-                            let id = block.lookup(self.db.upcast()).id;\n-                            id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n-                                == Some(\"rust-intrinsic\")\n-                        }\n-                        _ => false,\n-                    },\n-                };\n-                let result = if is_intrinsic {\n-                    self.exec_intrinsic(\n-                        function_data.name.as_text().unwrap_or_default().as_str(),\n-                        arg_bytes,\n-                        generic_args,\n-                        &locals,\n-                    )?\n-                } else if let Some(x) = self.detect_lang_function(def) {\n-                    self.exec_lang_item(x, arg_bytes)?\n-                } else {\n-                    let (imp, generic_args) = lookup_impl_method(\n-                        self.db,\n-                        self.trait_env.clone(),\n-                        def,\n-                        generic_args.clone(),\n-                    );\n-                    let generic_args = self.subst_filler(&generic_args, &locals);\n-                    let def = imp.into();\n-                    let mir_body =\n-                        self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n-                    self.interpret_mir(&mir_body, arg_bytes, generic_args)\n-                        .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n-                };\n-                self.write_memory(dest_addr, &result)?;\n+                    .collect::<Result<Vec<_>>>()?;\n+                self.exec_fn_with_args(def, arg_bytes, generic_args, locals, dest_addr)?;\n             }\n             CallableDefId::StructId(id) => {\n                 let (size, variant_layout, tag) =\n@@ -1284,6 +1264,77 @@ impl Evaluator<'_> {\n         Ok(())\n     }\n \n+    fn exec_fn_with_args(\n+        &mut self,\n+        def: FunctionId,\n+        arg_bytes: Vec<Vec<u8>>,\n+        generic_args: Substitution,\n+        locals: &Locals<'_>,\n+        dest_addr: Address,\n+    ) -> Result<()> {\n+        let function_data = self.db.function_data(def);\n+        let is_intrinsic = match &function_data.abi {\n+            Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+            None => match def.lookup(self.db.upcast()).container {\n+                hir_def::ItemContainerId::ExternBlockId(block) => {\n+                    let id = block.lookup(self.db.upcast()).id;\n+                    id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n+                        == Some(\"rust-intrinsic\")\n+                }\n+                _ => false,\n+            },\n+        };\n+        let result = if is_intrinsic {\n+            self.exec_intrinsic(\n+                function_data.name.as_text().unwrap_or_default().as_str(),\n+                arg_bytes.iter().cloned(),\n+                generic_args,\n+                &locals,\n+            )?\n+        } else if let Some(x) = self.detect_lang_function(def) {\n+            self.exec_lang_item(x, &arg_bytes)?\n+        } else {\n+            if let Some(self_ty_idx) =\n+                is_dyn_method(self.db, self.trait_env.clone(), def, generic_args.clone())\n+            {\n+                // In the layout of current possible receiver, which at the moment of writing this code is one of\n+                // `&T`, `&mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`, and `Pin<P>` where `P` is one of possible recievers,\n+                // the vtable is exactly in the `[ptr_size..2*ptr_size]` bytes. So we can use it without branching on\n+                // the type.\n+                let ty = self\n+                    .vtable_map\n+                    .ty_of_bytes(&arg_bytes[0][self.ptr_size()..self.ptr_size() * 2])?;\n+                let ty = GenericArgData::Ty(ty.clone()).intern(Interner);\n+                let mut args_for_target = arg_bytes;\n+                args_for_target[0] = args_for_target[0][0..self.ptr_size()].to_vec();\n+                let generics_for_target = Substitution::from_iter(\n+                    Interner,\n+                    generic_args\n+                        .iter(Interner)\n+                        .enumerate()\n+                        .map(|(i, x)| if i == self_ty_idx { &ty } else { x })\n+                );\n+                return self.exec_fn_with_args(\n+                    def,\n+                    args_for_target,\n+                    generics_for_target,\n+                    locals,\n+                    dest_addr,\n+                );\n+            }\n+            let (imp, generic_args) =\n+                lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args.clone());\n+            let generic_args = self.subst_filler(&generic_args, &locals);\n+            let def = imp.into();\n+            let mir_body =\n+                self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+            self.interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n+                .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n+        };\n+        self.write_memory(dest_addr, &result)?;\n+        Ok(())\n+    }\n+\n     fn exec_fn_trait(\n         &mut self,\n         ft: FnTrait,\n@@ -1317,12 +1368,9 @@ impl Evaluator<'_> {\n         Ok(())\n     }\n \n-    fn exec_lang_item(\n-        &self,\n-        x: LangItem,\n-        mut args: std::vec::IntoIter<Vec<u8>>,\n-    ) -> Result<Vec<u8>> {\n+    fn exec_lang_item(&self, x: LangItem, args: &[Vec<u8>]) -> Result<Vec<u8>> {\n         use LangItem::*;\n+        let mut args = args.iter();\n         match x {\n             PanicFmt | BeginPanic => Err(MirEvalError::Panic),\n             SliceLen => {"}, {"sha": "4fc3c67a6e1ebc9f1f3d5b4cf76f7d2844b465e0", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7525a38af5ebd9eef404b19a11cefe8a033f9d2d/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=7525a38af5ebd9eef404b19a11cefe8a033f9d2d", "patch": "@@ -230,7 +230,14 @@ impl MirLowerCtx<'_> {\n                                     self.lower_const(c, current, place, expr_id.into())?;\n                                     return Ok(Some(current))\n                                 },\n-                                _ => not_supported!(\"associated functions and types\"),\n+                                hir_def::AssocItemId::FunctionId(_) => {\n+                                    // FnDefs are zero sized, no action is needed.\n+                                    return Ok(Some(current))\n+                                }\n+                                hir_def::AssocItemId::TypeAliasId(_) => {\n+                                    // FIXME: If it is unreachable, use proper error instead of `not_supported`.\n+                                    not_supported!(\"associated functions and types\")\n+                                },\n                             }\n                         } else if let Some(variant) = self\n                             .infer"}]}