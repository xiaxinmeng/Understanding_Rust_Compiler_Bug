{"sha": "978b1407815e566b10e72bec5b36630654553b68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OGIxNDA3ODE1ZTU2NmIxMGU3MmJlYzViMzY2MzA2NTQ1NTNiNjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-16T16:38:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-16T16:38:44Z"}, "message": "Merge #9921\n\n9921: Only add entries to SourceToDef dynmaps when they come from the same file r=matklad a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9919\r\n\r\nRunning the test as described in the issue I do not get any eprintln output at all anymore.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "c5c58b33080ede0757ad75a386a45e2eb0dbd999", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c58b33080ede0757ad75a386a45e2eb0dbd999"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/978b1407815e566b10e72bec5b36630654553b68", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhGpSUCRBK7hj4Ov3rIwAA+U8IAJvES52802RQxI11SyA4E+Yo\n3JlAZBOOSzGd1UrsdppxeBBEGe+diPOVUZVeDYKf+fIXCN1VpZvVj1Ej9O+bqGtV\n+Cf67sspEedQrcoxQtF4CgkaXzk5tjnfVMo4MW2ctc3cC8M/Tn2eqTx6gycKPFE/\na4UdDtrlC14HRkd5J9HQPvNdjyFRYlBESgVQQ9J68XTIzZcLuw7nNKiQDGeHltx0\nvl0qU0u6VXnQZA1bYsY78eFx6xUMPxADxxz+Jr3sctavvpuDB8O5WsNiGJFoQzaM\nXFec2G4c61PteIxaNShdnMMwgKPxS+A+E4+WxTEiTSxExlcYHGWoKXsLksEY7t0=\n=zDqw\n-----END PGP SIGNATURE-----\n", "payload": "tree c5c58b33080ede0757ad75a386a45e2eb0dbd999\nparent bae22f9507932ada330c24afbd99d0494474161c\nparent 6523a09562fea0f02e0877b5b651b36d3dea6bcb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629131924 +0000\ncommitter GitHub <noreply@github.com> 1629131924 +0000\n\nMerge #9921\n\n9921: Only add entries to SourceToDef dynmaps when they come from the same file r=matklad a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9919\r\n\r\nRunning the test as described in the issue I do not get any eprintln output at all anymore.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/978b1407815e566b10e72bec5b36630654553b68", "html_url": "https://github.com/rust-lang/rust/commit/978b1407815e566b10e72bec5b36630654553b68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/978b1407815e566b10e72bec5b36630654553b68/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bae22f9507932ada330c24afbd99d0494474161c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bae22f9507932ada330c24afbd99d0494474161c", "html_url": "https://github.com/rust-lang/rust/commit/bae22f9507932ada330c24afbd99d0494474161c"}, {"sha": "6523a09562fea0f02e0877b5b651b36d3dea6bcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6523a09562fea0f02e0877b5b651b36d3dea6bcb", "html_url": "https://github.com/rust-lang/rust/commit/6523a09562fea0f02e0877b5b651b36d3dea6bcb"}], "stats": {"total": 198, "additions": 124, "deletions": 74}, "files": [{"sha": "773eab79315caa56fc2b602ab62e19afa0282906", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=978b1407815e566b10e72bec5b36630654553b68", "patch": "@@ -95,7 +95,7 @@ use hir_def::{\n     GenericDefId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n     TypeParamId, UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, AstId, MacroCallId, MacroDefId, MacroDefKind};\n+use hir_expand::{name::AsName, AstId, HirFileId, MacroCallId, MacroDefId, MacroDefKind};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n@@ -106,7 +106,7 @@ use syntax::{\n \n use crate::{db::HirDatabase, InFile};\n \n-pub(super) type SourceToDefCache = FxHashMap<ChildContainer, DynMap>;\n+pub(super) type SourceToDefCache = FxHashMap<(ChildContainer, HirFileId), DynMap>;\n \n pub(super) struct SourceToDefCtx<'a, 'b> {\n     pub(super) db: &'b dyn HirDatabase,\n@@ -252,17 +252,19 @@ impl SourceToDefCtx<'_, '_> {\n \n     fn dyn_map<Ast: AstNode + 'static>(&mut self, src: InFile<&Ast>) -> Option<&DynMap> {\n         let container = self.find_container(src.map(|it| it.syntax()))?;\n+        Some(self.cache_for(container, src.file_id))\n+    }\n+\n+    fn cache_for(&mut self, container: ChildContainer, file_id: HirFileId) -> &DynMap {\n         let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n-        Some(dyn_map)\n+        self.cache\n+            .entry((container, file_id))\n+            .or_insert_with(|| container.child_by_source(db, file_id))\n     }\n \n     pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::TYPE_PARAM].get(&src).copied()\n     }\n \n@@ -271,9 +273,7 @@ impl SourceToDefCtx<'_, '_> {\n         src: InFile<ast::LifetimeParam>,\n     ) -> Option<LifetimeParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::LIFETIME_PARAM].get(&src).copied()\n     }\n \n@@ -282,9 +282,7 @@ impl SourceToDefCtx<'_, '_> {\n         src: InFile<ast::ConstParam>,\n     ) -> Option<ConstParamId> {\n         let container: ChildContainer = self.find_generic_param_container(src.syntax())?.into();\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n+        let dyn_map = self.cache_for(container, src.file_id);\n         dyn_map[keys::CONST_PARAM].get(&src).copied()\n     }\n \n@@ -422,17 +420,17 @@ impl_from! {\n }\n \n impl ChildContainer {\n-    fn child_by_source(self, db: &dyn HirDatabase) -> DynMap {\n+    fn child_by_source(self, db: &dyn HirDatabase, file_id: HirFileId) -> DynMap {\n         let db = db.upcast();\n         match self {\n-            ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n-            ChildContainer::ModuleId(it) => it.child_by_source(db),\n-            ChildContainer::TraitId(it) => it.child_by_source(db),\n-            ChildContainer::ImplId(it) => it.child_by_source(db),\n-            ChildContainer::EnumId(it) => it.child_by_source(db),\n-            ChildContainer::VariantId(it) => it.child_by_source(db),\n+            ChildContainer::DefWithBodyId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::ModuleId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::TraitId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::ImplId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::EnumId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::VariantId(it) => it.child_by_source(db, file_id),\n             ChildContainer::TypeAliasId(_) => DynMap::default(),\n-            ChildContainer::GenericDefId(it) => it.child_by_source(db),\n+            ChildContainer::GenericDefId(it) => it.child_by_source(db, file_id),\n         }\n     }\n }"}, {"sha": "1a2b47cd030c1f506cf2ec8843483d02f8b3848f", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 102, "deletions": 50, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=978b1407815e566b10e72bec5b36630654553b68", "patch": "@@ -5,6 +5,7 @@\n //! node for a *child*, and get its hir.\n \n use either::Either;\n+use hir_expand::HirFileId;\n \n use crate::{\n     db::DefDatabase,\n@@ -17,145 +18,196 @@ use crate::{\n };\n \n pub trait ChildBySource {\n-    fn child_by_source(&self, db: &dyn DefDatabase) -> DynMap {\n+    fn child_by_source(&self, db: &dyn DefDatabase, file_id: HirFileId) -> DynMap {\n         let mut res = DynMap::default();\n-        self.child_by_source_to(db, &mut res);\n+        self.child_by_source_to(db, &mut res, file_id);\n         res\n     }\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, map: &mut DynMap);\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, map: &mut DynMap, file_id: HirFileId);\n }\n \n impl ChildBySource for TraitId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.trait_data(*self);\n         for (_name, item) in data.items.iter() {\n             match *item {\n                 AssocItemId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    res[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 AssocItemId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    res[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 AssocItemId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for ImplId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.impl_data(*self);\n         for &item in data.items.iter() {\n             match item {\n                 AssocItemId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    res[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 AssocItemId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    res[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 AssocItemId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    res[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        res[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for ModuleId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let def_map = self.def_map(db);\n         let module_data = &def_map[self.local_id];\n-        module_data.scope.child_by_source_to(db, res);\n+        module_data.scope.child_by_source_to(db, res, file_id);\n     }\n }\n \n impl ChildBySource for ItemScope {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n-        self.declarations().for_each(|item| add_module_def(db, res, item));\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        self.declarations().for_each(|item| add_module_def(db, file_id, res, item));\n         self.unnamed_consts().for_each(|konst| {\n             let src = konst.lookup(db).source(db);\n             res[keys::CONST].insert(src, konst);\n         });\n-        self.impls().for_each(|imp| add_impl(db, res, imp));\n+        self.impls().for_each(|imp| add_impl(db, file_id, res, imp));\n         self.attr_macro_invocs().for_each(|(ast_id, call_id)| {\n             let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n             res[keys::ATTR_MACRO].insert(item, call_id);\n         });\n \n-        fn add_module_def(db: &dyn DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n+        fn add_module_def(\n+            db: &dyn DefDatabase,\n+            file_id: HirFileId,\n+            map: &mut DynMap,\n+            item: ModuleDefId,\n+        ) {\n             match item {\n                 ModuleDefId::FunctionId(func) => {\n-                    let src = func.lookup(db).source(db);\n-                    map[keys::FUNCTION].insert(src, func)\n+                    let loc = func.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::FUNCTION].insert(src, func)\n+                    }\n                 }\n                 ModuleDefId::ConstId(konst) => {\n-                    let src = konst.lookup(db).source(db);\n-                    map[keys::CONST].insert(src, konst)\n+                    let loc = konst.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::CONST].insert(src, konst)\n+                    }\n                 }\n                 ModuleDefId::StaticId(statik) => {\n-                    let src = statik.lookup(db).source(db);\n-                    map[keys::STATIC].insert(src, statik)\n+                    let loc = statik.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::STATIC].insert(src, statik)\n+                    }\n                 }\n                 ModuleDefId::TypeAliasId(ty) => {\n-                    let src = ty.lookup(db).source(db);\n-                    map[keys::TYPE_ALIAS].insert(src, ty)\n+                    let loc = ty.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::TYPE_ALIAS].insert(src, ty)\n+                    }\n                 }\n                 ModuleDefId::TraitId(trait_) => {\n-                    let src = trait_.lookup(db).source(db);\n-                    map[keys::TRAIT].insert(src, trait_)\n+                    let loc = trait_.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        let src = loc.source(db);\n+                        map[keys::TRAIT].insert(src, trait_)\n+                    }\n                 }\n                 ModuleDefId::AdtId(adt) => match adt {\n                     AdtId::StructId(strukt) => {\n-                        let src = strukt.lookup(db).source(db);\n-                        map[keys::STRUCT].insert(src, strukt)\n+                        let loc = strukt.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::STRUCT].insert(src, strukt)\n+                        }\n                     }\n                     AdtId::UnionId(union_) => {\n-                        let src = union_.lookup(db).source(db);\n-                        map[keys::UNION].insert(src, union_)\n+                        let loc = union_.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::UNION].insert(src, union_)\n+                        }\n                     }\n                     AdtId::EnumId(enum_) => {\n-                        let src = enum_.lookup(db).source(db);\n-                        map[keys::ENUM].insert(src, enum_)\n+                        let loc = enum_.lookup(db);\n+                        if loc.id.file_id() == file_id {\n+                            let src = loc.source(db);\n+                            map[keys::ENUM].insert(src, enum_)\n+                        }\n                     }\n                 },\n                 _ => (),\n             }\n         }\n-        fn add_impl(db: &dyn DefDatabase, map: &mut DynMap, imp: ImplId) {\n-            let src = imp.lookup(db).source(db);\n-            map[keys::IMPL].insert(src, imp)\n+        fn add_impl(db: &dyn DefDatabase, file_id: HirFileId, map: &mut DynMap, imp: ImplId) {\n+            let loc = imp.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                let src = loc.source(db);\n+                map[keys::IMPL].insert(src, imp)\n+            }\n         }\n     }\n }\n \n impl ChildBySource for VariantId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n         let arena_map = self.child_source(db);\n         let arena_map = arena_map.as_ref();\n+        let parent = *self;\n         for (local_id, source) in arena_map.value.iter() {\n-            let id = FieldId { parent: *self, local_id };\n-            match source {\n+            let id = FieldId { parent, local_id };\n+            match source.clone() {\n                 Either::Left(source) => {\n-                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                    res[keys::TUPLE_FIELD].insert(arena_map.with_value(source), id)\n                 }\n                 Either::Right(source) => {\n-                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source.clone()), id)\n+                    res[keys::RECORD_FIELD].insert(arena_map.with_value(source), id)\n                 }\n             }\n         }\n     }\n }\n \n impl ChildBySource for EnumId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n         let arena_map = self.child_source(db);\n         let arena_map = arena_map.as_ref();\n         for (local_id, source) in arena_map.value.iter() {\n@@ -166,12 +218,12 @@ impl ChildBySource for EnumId {\n }\n \n impl ChildBySource for DefWithBodyId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let body = db.body(*self);\n         for (_, def_map) in body.blocks(db) {\n             // All block expressions are merged into the same map, because they logically all add\n             // inner items to the containing `DefWithBodyId`.\n-            def_map[def_map.root()].scope.child_by_source_to(db, res);\n+            def_map[def_map.root()].scope.child_by_source_to(db, res, file_id);\n         }\n     }\n }"}, {"sha": "5425ea8beaf5bba0c992c6b19b891244eea2f7f5", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/978b1407815e566b10e72bec5b36630654553b68/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=978b1407815e566b10e72bec5b36630654553b68", "patch": "@@ -7,7 +7,7 @@ use base_db::FileId;\n use either::Either;\n use hir_expand::{\n     name::{name, AsName, Name},\n-    InFile,\n+    HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n use syntax::ast::{self, GenericParamsOwner, NameOwner, TypeBoundsOwner};\n@@ -438,7 +438,7 @@ impl HasChildSource<LocalConstParamId> for GenericDefId {\n }\n \n impl ChildBySource for GenericDefId {\n-    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap) {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n         let (_, sm) = GenericParams::new(db, *self);\n \n         let sm = sm.as_ref();"}]}