{"sha": "b619954457b9790de60cb09dc3953e9a4f630bed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MTk5NTQ0NTdiOTc5MGRlNjBjYjA5ZGMzOTUzZTlhNGY2MzBiZWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T14:06:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T14:09:40Z"}, "message": "Start parsing pub/priv on regular items\n\nIssue #1893", "tree": {"sha": "d7c4c12c551b25206c0d986a47f2e9cddc00b4a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7c4c12c551b25206c0d986a47f2e9cddc00b4a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b619954457b9790de60cb09dc3953e9a4f630bed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b619954457b9790de60cb09dc3953e9a4f630bed", "html_url": "https://github.com/rust-lang/rust/commit/b619954457b9790de60cb09dc3953e9a4f630bed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b619954457b9790de60cb09dc3953e9a4f630bed/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "url": "https://api.github.com/repos/rust-lang/rust/commits/df3bf7c2a0009ef82dc6c1c6149ca0248154e197", "html_url": "https://github.com/rust-lang/rust/commit/df3bf7c2a0009ef82dc6c1c6149ca0248154e197"}], "stats": {"total": 177, "additions": 100, "deletions": 77}, "files": [{"sha": "cf338ad02c289ed272d895a56852b5087d24acaf", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -557,7 +557,7 @@ enum ret_style {\n type method = {ident: ident, attrs: [attribute],\n                tps: [ty_param], decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n-               privacy: privacy}; // privacy is always public, unless it's a\n+               vis: visibility};  // always public, unless it's a\n                                   // class method\n \n #[auto_serialize]\n@@ -580,7 +580,7 @@ type variant_arg = {ty: @ty, id: node_id};\n \n #[auto_serialize]\n type variant_ = {name: ident, attrs: [attribute], args: [variant_arg],\n-                 id: node_id, disr_expr: option<@expr>};\n+                 id: node_id, disr_expr: option<@expr>, vis: visibility};\n \n #[auto_serialize]\n type variant = spanned<variant_>;\n@@ -641,9 +641,13 @@ type attribute_ = {style: attr_style, value: meta_item};\n #[auto_serialize]\n type iface_ref = {path: @path, id: node_id};\n \n+#[auto_serialize]\n+enum visibility { public, private }\n+\n #[auto_serialize]\n type item = {ident: ident, attrs: [attribute],\n-             id: node_id, node: item_, span: span};\n+             id: node_id, node: item_,\n+             vis: visibility, span: span};\n \n #[auto_serialize]\n enum region_param {\n@@ -679,16 +683,13 @@ type class_member = spanned<class_member_>;\n \n #[auto_serialize]\n enum class_member_ {\n-    instance_var(ident, @ty, class_mutability, node_id, privacy),\n+    instance_var(ident, @ty, class_mutability, node_id, visibility),\n     class_method(@method)\n }\n \n #[auto_serialize]\n enum class_mutability { class_mutable, class_immutable }\n \n-#[auto_serialize]\n-enum privacy { priv, pub }\n-\n #[auto_serialize]\n type class_ctor = spanned<class_ctor_>;\n "}, {"sha": "f2cb613f54b46c2d7f6e78f799f53f421e042600", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -276,31 +276,31 @@ pure fn class_item_ident(ci: @class_member) -> ident {\n }\n \n type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n-             id: node_id, privacy: privacy};\n+             id: node_id, vis: visibility};\n \n fn public_methods(ms: [@method]) -> [@method] {\n-    vec::filter(ms, {|m| alt m.privacy {\n-                    pub { true }\n+    vec::filter(ms, {|m| alt m.vis {\n+                    public { true }\n                     _   { false }}})\n }\n \n fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     let mut vs = [], ms = [];\n     for cs.each {|c|\n       alt c.node {\n-        instance_var(i, t, cm, id, privacy) {\n-          vs += [{ident: i, ty: t, cm: cm, id: id, privacy: privacy}];\n+        instance_var(i, t, cm, id, vis) {\n+          vs += [{ident: i, ty: t, cm: cm, id: id, vis: vis}];\n         }\n         class_method(m) { ms += [m]; }\n       }\n     };\n     (vs, ms)\n }\n \n-pure fn class_member_privacy(ci: @class_member) -> privacy {\n+pure fn class_member_visibility(ci: @class_member) -> visibility {\n   alt ci.node {\n-     instance_var(_, _, _, _, p) { p }\n-     class_method(m) { m.privacy }\n+     instance_var(_, _, _, _, vis) { vis }\n+     class_method(m) { m.vis }\n   }\n }\n "}, {"sha": "dff4ddd7a69ad80ef72170d6184c80ae3807a543", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -546,6 +546,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n                           constraints: []},\n                          ser_tps,\n                          ser_blk),\n+      vis: ast::public,\n       span: span}\n }\n \n@@ -744,6 +745,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span, name: str, tps: [ast::ty_param],\n                           constraints: []},\n                          deser_tps,\n                          deser_blk),\n+      vis: ast::public,\n       span: span}\n }\n "}, {"sha": "9e2579cff6adde6488c2e1f048f52e0f381ce576", "filename": "src/librustsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fqquote.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -173,7 +173,7 @@ fn parse_stmt(p: parser) -> @ast::stmt {\n }\n \n fn parse_item(p: parser) -> @ast::item {\n-    alt (parser::parse_item(p, [])) {\n+    alt parser::parse_item(p, [], ast::public) {\n       some(item) { item }\n       none       { fail \"parse_item: parsing an item failed\"; }\n     }"}, {"sha": "f538cc526519addf480ac3d6379c5a03d4baf6c2", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -241,6 +241,7 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n           attrs: vec::map(i.attrs, fold_attribute),\n           id: fld.new_id(i.id),\n           node: fld.fold_item_underscore(i.node),\n+          vis: i.vis,\n           span: fld.new_span(i.span)};\n }\n \n@@ -323,7 +324,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n           id: fld.new_id(m.id),\n           span: fld.new_span(m.span),\n           self_id: fld.new_id(m.self_id),\n-          privacy: m.privacy};\n+          vis: m.vis};\n }\n \n \n@@ -564,7 +565,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     ret {name: v.name,\n          attrs: attrs,\n          args: args, id: fld.new_id(v.id),\n-         disr_expr: de};\n+         disr_expr: de,\n+         vis: v.vis};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }"}, {"sha": "b7d400de3dcb0e06551e1cbcba01df79497e0a9b", "filename": "src/librustsyntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Feval.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -107,7 +107,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n \n         let i =\n             parser::mk_item(p0, cdir.span.lo, cdir.span.hi, id,\n-                            ast::item_mod(m0), mod_attrs);\n+                            ast::item_mod(m0), ast::public, mod_attrs);\n         // Thread defids, chpos and byte_pos through the parsers\n         cx.sess.chpos = p0.reader.chpos;\n         cx.sess.byte_pos = cx.sess.byte_pos + p0.reader.pos;\n@@ -126,6 +126,7 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n               attrs: attrs + a0,\n               id: cx.sess.next_id,\n               node: ast::item_mod(m0),\n+              vis: ast::public,\n               span: cdir.span};\n         cx.sess.next_id += 1;\n         items += [i];"}, {"sha": "48d84ee9ffd73532254e6844b14697aead002ad2", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -1485,7 +1485,7 @@ fn parse_let(p: parser) -> @ast::decl {\n }\n \n /* assumes \"let\" token has already been consumed */\n-fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n+fn parse_instance_var(p:parser, pr: ast::visibility) -> @ast::class_member {\n     let mut is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n     if eat_keyword(p, \"mut\") {\n@@ -1527,7 +1527,7 @@ fn parse_stmt(p: parser, +first_item_attrs: [ast::attribute]) -> @ast::stmt {\n \n         let item_attrs = first_item_attrs + item_attrs;\n \n-        alt parse_item(p, item_attrs) {\n+        alt parse_item(p, item_attrs, ast::public) {\n           some(i) {\n             let mut hi = i.span.hi;\n             let decl = @spanned(lo, hi, ast::decl_item(i));\n@@ -1789,11 +1789,13 @@ fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n }\n \n fn mk_item(p: parser, lo: uint, hi: uint, +ident: ast::ident,\n-           +node: ast::item_, +attrs: [ast::attribute]) -> @ast::item {\n+           +node: ast::item_, vis: ast::visibility,\n+           +attrs: [ast::attribute]) -> @ast::item {\n     ret @{ident: ident,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n+          vis: vis,\n           span: mk_sp(lo, hi)};\n }\n \n@@ -1819,7 +1821,7 @@ fn parse_method_name(p: parser) -> ast::ident {\n     }\n }\n \n-fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n+fn parse_method(p: parser, pr: ast::visibility) -> @ast::method {\n     let attrs = parse_outer_attributes(p);\n     let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n@@ -1829,7 +1831,7 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n       id: p.get_id(), span: mk_sp(lo, body.span.hi),\n-      self_id: p.get_id(), privacy: pr}\n+      self_id: p.get_id(), vis: pr}\n }\n \n fn parse_item_iface(p: parser) -> item_info {\n@@ -1877,7 +1879,7 @@ fn parse_item_impl(p: parser) -> item_info {\n     let ty = parse_ty(p, false);\n     let mut meths = [];\n     expect(p, token::LBRACE);\n-    while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::pub)]; }\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::public)]; }\n     (ident, ast::item_impl(tps, rp, ifce, ty, meths), none)\n }\n \n@@ -1978,15 +1980,15 @@ fn parse_item_class(p: parser) -> item_info {\n     }\n }\n \n-fn parse_single_class_item(p: parser, privcy: ast::privacy)\n+fn parse_single_class_item(p: parser, vis: ast::visibility)\n     -> @ast::class_member {\n    if eat_keyword(p, \"let\") {\n-      let a_var = parse_instance_var(p, privcy);\n+      let a_var = parse_instance_var(p, vis);\n       expect(p, token::SEMI);\n       ret a_var;\n    }\n    else {\n-       let m = parse_method(p, privcy);\n+       let m = parse_method(p, vis);\n        ret @{node: ast::class_method(m), span: m.span};\n    }\n }\n@@ -2014,17 +2016,23 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n             expect(p, token::LBRACE);\n             let mut results = [];\n             while p.token != token::RBRACE {\n-                    results += [parse_single_class_item(p, ast::priv)];\n+                    results += [parse_single_class_item(p, ast::private)];\n             }\n             p.bump();\n             ret members(results);\n     }\n     else {\n         // Probably need to parse attrs\n-        ret members([parse_single_class_item(p, ast::pub)]);\n+        ret members([parse_single_class_item(p, ast::public)]);\n     }\n }\n \n+fn parse_visibility(p: parser, def: ast::visibility) -> ast::visibility {\n+    if eat_keyword(p, \"pub\") { ast::public }\n+    else if eat_keyword(p, \"priv\") { ast::private }\n+    else { def }\n+}\n+\n fn parse_mod_items(p: parser, term: token::token,\n                    +first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n@@ -2035,7 +2043,8 @@ fn parse_mod_items(p: parser, term: token::token,\n         let mut attrs = parse_outer_attributes(p);\n         if first { attrs = first_item_attrs + attrs; first = false; }\n         #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n-        alt parse_item(p, attrs) {\n+        let vis = parse_visibility(p, ast::private);\n+        alt parse_item(p, attrs, vis) {\n           some(i) { items += [i]; }\n           _ {\n             p.fatal(\"expected item but found '\" +\n@@ -2154,7 +2163,7 @@ fn parse_region_param(p: parser) -> ast::region_param {\n     }\n }\n \n-fn parse_item_enum(p: parser) -> item_info {\n+fn parse_item_enum(p: parser, default_vis: ast::visibility) -> item_info {\n     let id = parse_ident(p);\n     let rp = parse_region_param(p);\n     let ty_params = parse_ty_params(p);\n@@ -2171,7 +2180,8 @@ fn parse_item_enum(p: parser) -> item_info {\n                      attrs: [],\n                      args: [{ty: ty, id: p.get_id()}],\n                      id: p.get_id(),\n-                     disr_expr: none});\n+                     disr_expr: none,\n+                     vis: ast::public});\n         ret (id, ast::item_enum([variant], ty_params, rp), none);\n     }\n     expect(p, token::LBRACE);\n@@ -2181,6 +2191,7 @@ fn parse_item_enum(p: parser) -> item_info {\n     while p.token != token::RBRACE {\n         let variant_attrs = parse_outer_attributes(p);\n         let vlo = p.span.lo;\n+        let vis = parse_visibility(p, default_vis);\n         let ident = parse_value_ident(p);\n         let mut args = [], disr_expr = none;\n         if p.token == token::LPAREN {\n@@ -2198,7 +2209,7 @@ fn parse_item_enum(p: parser) -> item_info {\n \n         let vr = {name: ident, attrs: variant_attrs,\n                   args: args, id: p.get_id(),\n-                  disr_expr: disr_expr};\n+                  disr_expr: disr_expr, vis: vis};\n         variants += [spanned(vlo, p.last_span.hi, vr)];\n \n         if !eat(p, token::COMMA) { break; }\n@@ -2241,7 +2252,8 @@ fn fn_expr_lookahead(tok: token::token) -> bool {\n     }\n }\n \n-fn parse_item(p: parser, +attrs: [ast::attribute]) -> option<@ast::item> {\n+fn parse_item(p: parser, +attrs: [ast::attribute], vis: ast::visibility)\n+    -> option<@ast::item> {\n     let lo = p.span.lo;\n     let (ident, item_, extra_attrs) = if eat_keyword(p, \"const\") {\n         parse_item_const(p)\n@@ -2265,7 +2277,7 @@ fn parse_item(p: parser, +attrs: [ast::attribute]) -> option<@ast::item> {\n     } else if eat_keyword(p, \"type\") {\n         parse_item_type(p)\n     } else if eat_keyword(p, \"enum\") {\n-        parse_item_enum(p)\n+        parse_item_enum(p, vis)\n     } else if eat_keyword(p, \"iface\") {\n         parse_item_iface(p)\n     } else if eat_keyword(p, \"impl\") {\n@@ -2275,10 +2287,11 @@ fn parse_item(p: parser, +attrs: [ast::attribute]) -> option<@ast::item> {\n     } else if eat_keyword(p, \"class\") {\n         parse_item_class(p)\n     } else { ret none; };\n-    some(mk_item(p, lo, p.last_span.hi, ident, item_, alt extra_attrs {\n-        some(as) { attrs + as }\n-        none { attrs }\n-    }))\n+    some(mk_item(p, lo, p.last_span.hi, ident, item_, vis,\n+                 alt extra_attrs {\n+                     some(as) { attrs + as }\n+                     none { attrs }\n+                 }))\n }\n \n fn parse_use(p: parser) -> ast::view_item_ {"}, {"sha": "8ee9af1ac4d82e73c051708184b8df2641380494", "filename": "src/librustsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Ftoken.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -229,7 +229,7 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n         \"implements\",\n         \"move\",\n         \"of\",\n-        \"priv\",\n+        \"priv\", \"pub\",\n         \"self\", \"send\", \"static\",\n         \"to\",\n         \"use\","}, {"sha": "9af860e8872f3b04c5dc0395a7c00ac6b0ac3fa9", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -533,9 +533,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n                    */\n              hardbreak_if_not_bol(s);\n              maybe_print_comment(s, ci.span.lo);\n-             let pr = ast_util::class_member_privacy(ci);\n+             let pr = ast_util::class_member_visibility(ci);\n              alt pr {\n-                ast::priv {\n+                ast::private {\n                     head(s, \"priv\");\n                     bopen(s);\n                     hardbreak_if_not_bol(s);\n@@ -559,7 +559,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n                 }\n              }\n              alt pr {\n-                 ast::priv { bclose(s, ci.span); }\n+                 ast::private { bclose(s, ci.span); }\n                  _ {}\n              }\n           }"}, {"sha": "f7328a9d7580d0e2cfe35fc725f6a1b3839924a7", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -195,6 +195,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n          attrs: [resolve_unexported_attr],\n          id: cx.sess.next_node_id(),\n          node: item_,\n+         vis: ast::public,\n          span: dummy_sp()};\n \n     #debug(\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item));\n@@ -233,6 +234,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n          attrs: [],\n          id: cx.sess.next_node_id(),\n          node: item_,\n+         vis: ast::public,\n          span: dummy_sp()};\n     ret @item;\n }\n@@ -415,6 +417,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n          attrs: [],\n          id: cx.sess.next_node_id(),\n          node: item_,\n+         vis: ast::public,\n          span: dummy_sp()};\n     ret @item;\n }"}, {"sha": "426331b577c0b2b61ced62547bda9f8fab00b29a", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -454,7 +454,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n-                    }, privacy: ast::pub}];\n+                    }, vis: ast::public}];\n     }\n     @result\n }\n@@ -471,17 +471,17 @@ fn get_class_members(cdata: cmd, id: ast::node_id,\n           let name = item_name(an_item);\n           let did = class_member_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n-          result += [{ident: name, id: did, privacy:\n-                  family_to_privacy(f), mutability: mt}];\n+          result += [{ident: name, id: did, vis:\n+                  family_to_visibility(f), mutability: mt}];\n        }\n     }\n     result\n }\n \n-pure fn family_to_privacy(family: char) -> ast::privacy {\n+pure fn family_to_visibility(family: char) -> ast::visibility {\n     alt family {\n-      'g' { ast::pub }\n-      _   { ast::priv }\n+      'g' { ast::public }\n+      _   { ast::private }\n     }\n }\n "}, {"sha": "1aa14180002ad56e293dd7ef17483dd6084e2ff4", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -99,9 +99,9 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n fn encode_class_item_paths(ebml_w: ebml::writer,\n      items: [@class_member], path: [str], &index: [entry<str>]) {\n     for items.each {|it|\n-     alt ast_util::class_member_privacy(it) {\n-          priv { cont; }\n-          pub {\n+     alt ast_util::class_member_visibility(it) {\n+          private { cont; }\n+          public {\n               let (id, ident) = alt it.node {\n                  instance_var(v, _, _, vid, _) { (vid, v) }\n                  class_method(it) { (it.id, it.ident) }\n@@ -399,9 +399,10 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml_w.end_tag();\n }\n \n-fn encode_privacy(ebml_w: ebml::writer, privacy: privacy) {\n-    encode_family(ebml_w, alt privacy {\n-                pub { 'g' } priv { 'j' }});\n+fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n+    encode_family(ebml_w, alt visibility {\n+        public { 'g' } private { 'j' }\n+    });\n }\n \n /* Returns an index of items in this class */\n@@ -417,11 +418,11 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n       alt ci.node {\n-        instance_var(nm, _, mt, id, pr) {\n+        instance_var(nm, _, mt, id, vis) {\n           *index += [{val: id, pos: ebml_w.writer.tell()}];\n           ebml_w.start_tag(tag_items_data_item);\n           #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n-          encode_privacy(ebml_w, pr);\n+          encode_visibility(ebml_w, vis);\n           encode_name(ebml_w, nm);\n           encode_path(ebml_w, path, ast_map::path_name(nm));\n           encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n@@ -430,8 +431,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           ebml_w.end_tag();\n         }\n         class_method(m) {\n-           alt m.privacy {\n-              pub {\n+           alt m.vis {\n+              public {\n                 *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n                 /* Not sure whether we really need to have two indices,\n                    but it works for now -- tjc */\n@@ -625,15 +626,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let (fs,ms) = ast_util::split_class_items(items);\n         for fs.each {|f|\n            ebml_w.start_tag(tag_item_field);\n-           encode_privacy(ebml_w, f.privacy);\n+           encode_visibility(ebml_w, f.vis);\n            encode_name(ebml_w, f.ident);\n            encode_def_id(ebml_w, local_def(f.id));\n            ebml_w.end_tag();\n         }\n         for ms.each {|m|\n-           alt m.privacy {\n-              priv { /* do nothing */ }\n-              pub {\n+           alt m.vis {\n+              private { /* do nothing */ }\n+              public {\n                 /* Write the info that's needed when viewing this class\n                    as an iface */\n                 ebml_w.start_tag(tag_item_iface_method);\n@@ -648,7 +649,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 ebml_w.start_tag(tag_item_impl_method);\n                 ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n                 ebml_w.end_tag();\n-\n               }\n            }\n         }"}, {"sha": "4461da16a1b7635824cddd5539e741e1160d1618", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -1642,6 +1642,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                             id: ctor.node.id,\n                             node:\n                               item_fn(ctor.node.dec, tps, ctor.node.body),\n+                            vis: ast::public,\n                             span: ctor.node.body.span}));\n           }\n         }"}, {"sha": "fdbff9044077734737affb2f76797a941bdd8c88", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -165,7 +165,7 @@ type method = {ident: ast::ident,\n                tps: @[param_bounds],\n                fty: fn_ty,\n                purity: ast::purity,\n-               privacy: ast::privacy};\n+               vis: ast::visibility};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -181,7 +181,7 @@ enum vstore {\n type field_ty = {\n   ident: ident,\n   id: def_id,\n-  privacy: ast::privacy,\n+  vis: ast::visibility,\n   mutability: ast::class_mutability\n };\n \n@@ -2540,21 +2540,21 @@ fn lookup_public_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n }\n \n pure fn is_public(f: field_ty) -> bool {\n-  alt f.privacy {\n-       pub { true }\n-       priv { false }\n+  alt f.vis {\n+    public { true }\n+    private { false }\n   }\n }\n \n // Look up the list of method names and IDs for a given class\n // Fails if the id is not bound to a class.\n fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n-    : is_local(did) -> [{name: ident, id: node_id, privacy: privacy}] {\n+    : is_local(did) -> [{name: ident, id: node_id, vis: visibility}] {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(@{node: item_class(_,_,items,_,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n          vec::map(ms, {|m| {name: m.ident, id: m.id,\n-                         privacy: m.privacy}})\n+                            vis: m.vis}})\n        }\n        _ {\n            cx.sess.bug(\"lookup_class_method_ids: id not bound to a class\");\n@@ -2588,9 +2588,9 @@ fn class_field_tys(items: [@class_member]) -> [field_ty] {\n     let mut rslt = [];\n     for items.each {|it|\n        alt it.node {\n-          instance_var(nm, _, cm, id, privacy) {\n+          instance_var(nm, _, cm, id, vis) {\n               rslt += [{ident: nm, id: ast_util::local_def(id),\n-                          privacy: privacy, mutability: cm}];\n+                        vis: vis, mutability: cm}];\n           }\n           class_method(_) { }\n        }"}, {"sha": "7ff451a6658a66c9e433fdece306f041569263dc", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b619954457b9790de60cb09dc3953e9a4f630bed/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b619954457b9790de60cb09dc3953e9a4f630bed", "patch": "@@ -1176,7 +1176,7 @@ fn ty_of_method(ccx: @crate_ctxt,\n      fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n                         m.decl, none),\n      purity: m.decl.purity,\n-     privacy: m.privacy}\n+     vis: m.vis}\n }\n \n fn ty_of_ty_method(self: @crate_ctxt,\n@@ -1187,7 +1187,7 @@ fn ty_of_ty_method(self: @crate_ctxt,\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n                         m.decl, none),\n      // assume public, because this is only invoked on iface methods\n-     purity: m.decl.purity, privacy: ast::pub}\n+     purity: m.decl.purity, vis: ast::public}\n }\n \n // Functions that write types into the node type table\n@@ -2705,7 +2705,7 @@ impl methods for lookup {\n         for ms.each {|m|\n             if m.ident != self.m_name { cont; }\n \n-            if m.privacy == ast::priv && !self.include_private {\n+            if m.vis == ast::private && !self.include_private {\n                 self.tcx().sess.span_fatal(\n                     self.expr.span,\n                     \"Call to private method not allowed outside \\"}]}