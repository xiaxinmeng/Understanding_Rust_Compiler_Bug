{"sha": "81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "node_id": "C_kwDOAAsO6NoAKDgxYzAyZGE5NGU1ZjVlYzFlYzQ3MzJlNzUwNDljM2EzY2I0ZDZjN2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-11T14:48:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-11T14:48:58Z"}, "message": "Auto merge of #111958 - notriddle:notriddle/type-search-slice-array, r=GuillaumeGomez\n\nrustdoc: search for slices and arrays by type with `[]`\n\nThis feature extends rustdoc to support the syntax that most users will naturally attempt to use to search for slices and arrays. Part of #60485\n\nFunction signature searches already support arrays and slices. The explicit name `primitive:slice<u8>` and `primitive:array<u8>` can be used to match a slice or array of bytes, while square brackets `[u8]` will match either one. Empty square brackets, `[]`, will match any slice regardless of what it contains.\n\nPreview:\n\n* [`option -> []`](https://notriddle.com/rustdoc-demo-html-3/search-slice-array/std/index.html?search=option%20-%3E%20%5B%5D)\n* [`[u8] -> str`](https://notriddle.com/rustdoc-demo-html-3/search-slice-array/std/index.html?search=%5Bu8%5D%20-%3E%20str)\n* [`Box<[u8]> -> str`](https://notriddle.com/rustdoc-demo-html-3/search-slice-array/std/index.html?search=Box%3C%5Bu8%5D%3E%20-%3E%20str)\n\nMotivation:\n\nWhen type-based search was first landed, it was directly described as \"incomplete\". Here's [a comment] from the discussion thread:\n\n[a comment]: https://github.com/rust-lang/rust/pull/23289#issuecomment-79437386\n\n> This is looking really great, nice work! I can think of a number of cases that aren't quite covered by this, but I feel like this is a great improvement regardless and it can always be iterated on so I'm fine landing with a few known cases where it may not work :)\n\nFilling out the missing functionality is going to mean adding support for more of Rust's [type expression] syntax, such as slices (in this PR), tuples, references, raw pointers, function pointers, and generics.\n\n[type expression]: https://doc.rust-lang.org/reference/types.html#type-expressions\n\nThere does seem to be demand for this sort of thing, such as [this Discord message](https://discord.com/channels/442252698964721669/443150878111694848/1042145740065099796) expressing regret at rustdoc not supporting tuples in search queries.", "tree": {"sha": "b75fa323bca90f358829f4b42ecce4333417ce0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75fa323bca90f358829f4b42ecce4333417ce0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "html_url": "https://github.com/rust-lang/rust/commit/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b6093ee0805570d1af441673ebce409f8a14587", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b6093ee0805570d1af441673ebce409f8a14587", "html_url": "https://github.com/rust-lang/rust/commit/7b6093ee0805570d1af441673ebce409f8a14587"}, {"sha": "d3a4cd68130c8aaed7ce5a4d0a58861b66c72eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3a4cd68130c8aaed7ce5a4d0a58861b66c72eea", "html_url": "https://github.com/rust-lang/rust/commit/d3a4cd68130c8aaed7ce5a4d0a58861b66c72eea"}], "stats": {"total": 584, "additions": 502, "deletions": 82}, "files": [{"sha": "55cce8ab570807e9afa6d14487eecebce3b94b66", "filename": "src/doc/rustdoc/src/how-to-read-rustdoc.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -105,6 +105,11 @@ will match these queries:\n \n But it *does not* match `Result<Vec, u8>` or `Result<u8<Vec>>`.\n \n+Function signature searches also support arrays and slices. The explicit name\n+`primitive:slice<u8>` and `primitive:array<u8>` can be used to match a slice\n+or array of bytes, while square brackets `[u8]` will match either one. Empty\n+square brackets, `[]`, will match any slice regardless of what it contains.\n+\n ### Shortcuts\n \n Pressing `S` while focused elsewhere on the page will move focus to the"}, {"sha": "a184b7b705e961de36568c63c9c8ebeb6d2c322a", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -1077,6 +1077,10 @@ function preLoadCss(cssUrl) {\n              <code>-&gt; vec</code> or <code>String, enum:Cow -&gt; bool</code>)\",\n             \"You can look for items with an exact name by putting double quotes around \\\n              your request: <code>\\\"string\\\"</code>\",\n+             \"Look for functions that accept or return \\\n+              <a href=\\\"https://doc.rust-lang.org/std/primitive.slice.html\\\">slices</a> and \\\n+              <a href=\\\"https://doc.rust-lang.org/std/primitive.array.html\\\">arrays</a> by writing \\\n+              square brackets (e.g., <code>-&gt; [u8]</code> or <code>[] -&gt; Option</code>)\",\n             \"Look for items inside another one by searching for a path: <code>vec::Vec</code>\",\n         ].map(x => \"<p>\" + x + \"</p>\").join(\"\");\n         const div_infos = document.createElement(\"div\");"}, {"sha": "984358396ab2a4659de61929a2609618ed907178", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 151, "deletions": 82, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -208,6 +208,46 @@ function initSearch(rawSearchIndex) {\n     let typeNameIdMap;\n     const ALIASES = new Map();\n \n+    /**\n+     * Special type name IDs for searching by array.\n+     */\n+    let typeNameIdOfArray;\n+    /**\n+     * Special type name IDs for searching by slice.\n+     */\n+    let typeNameIdOfSlice;\n+    /**\n+     * Special type name IDs for searching by both array and slice (`[]` syntax).\n+     */\n+    let typeNameIdOfArrayOrSlice;\n+\n+    /**\n+     * Add an item to the type Name->ID map, or, if one already exists, use it.\n+     * Returns the number. If name is \"\" or null, return -1 (pure generic).\n+     *\n+     * This is effectively string interning, so that function matching can be\n+     * done more quickly. Two types with the same name but different item kinds\n+     * get the same ID.\n+     *\n+     * @param {string} name\n+     *\n+     * @returns {integer}\n+     */\n+    function buildTypeMapIndex(name) {\n+\n+        if (name === \"\" || name === null) {\n+            return -1;\n+        }\n+\n+        if (typeNameIdMap.has(name)) {\n+            return typeNameIdMap.get(name);\n+        } else {\n+            const id = typeNameIdMap.size;\n+            typeNameIdMap.set(name, id);\n+            return id;\n+        }\n+    }\n+\n     function isWhitespace(c) {\n         return \" \\t\\n\\r\".indexOf(c) !== -1;\n     }\n@@ -217,7 +257,7 @@ function initSearch(rawSearchIndex) {\n     }\n \n     function isEndCharacter(c) {\n-        return \",>-\".indexOf(c) !== -1;\n+        return \",>-]\".indexOf(c) !== -1;\n     }\n \n     function isStopCharacter(c) {\n@@ -466,35 +506,64 @@ function initSearch(rawSearchIndex) {\n \n         let start = parserState.pos;\n         let end;\n-        // We handle the strings on their own mostly to make code easier to follow.\n-        if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n-            start += 1;\n-            getStringElem(query, parserState, isInGenerics);\n-            end = parserState.pos - 1;\n+        if (parserState.userQuery[parserState.pos] === \"[\") {\n+            parserState.pos += 1;\n+            getItemsBefore(query, parserState, generics, \"]\");\n+            const typeFilter = parserState.typeFilter;\n+            if (typeFilter !== null && typeFilter !== \"primitive\") {\n+                throw [\n+                    \"Invalid search type: primitive \",\n+                    \"[]\",\n+                    \" and \",\n+                    typeFilter,\n+                    \" both specified\",\n+                ];\n+            }\n+            parserState.typeFilter = null;\n+            parserState.totalElems += 1;\n+            if (isInGenerics) {\n+                parserState.genericsElems += 1;\n+            }\n+            elems.push({\n+                name: \"[]\",\n+                id: -1,\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics,\n+                typeFilter: \"primitive\",\n+            });\n         } else {\n-            end = getIdentEndPosition(parserState);\n-        }\n-        if (parserState.pos < parserState.length &&\n-            parserState.userQuery[parserState.pos] === \"<\"\n-        ) {\n-            if (start >= end) {\n-                throw [\"Found generics without a path\"];\n+            // We handle the strings on their own mostly to make code easier to follow.\n+            if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n+                start += 1;\n+                getStringElem(query, parserState, isInGenerics);\n+                end = parserState.pos - 1;\n+            } else {\n+                end = getIdentEndPosition(parserState);\n             }\n-            parserState.pos += 1;\n-            getItemsBefore(query, parserState, generics, \">\");\n-        }\n-        if (start >= end && generics.length === 0) {\n-            return;\n+            if (parserState.pos < parserState.length &&\n+                parserState.userQuery[parserState.pos] === \"<\"\n+            ) {\n+                if (start >= end) {\n+                    throw [\"Found generics without a path\"];\n+                }\n+                parserState.pos += 1;\n+                getItemsBefore(query, parserState, generics, \">\");\n+            }\n+            if (start >= end && generics.length === 0) {\n+                return;\n+            }\n+            elems.push(\n+                createQueryElement(\n+                    query,\n+                    parserState,\n+                    parserState.userQuery.slice(start, end),\n+                    generics,\n+                    isInGenerics\n+                )\n+            );\n         }\n-        elems.push(\n-            createQueryElement(\n-                query,\n-                parserState,\n-                parserState.userQuery.slice(start, end),\n-                generics,\n-                isInGenerics\n-            )\n-        );\n     }\n \n     /**\n@@ -518,6 +587,17 @@ function initSearch(rawSearchIndex) {\n         const oldTypeFilter = parserState.typeFilter;\n         parserState.typeFilter = null;\n \n+        let extra = \"\";\n+        if (endChar === \">\") {\n+            extra = \"<\";\n+        } else if (endChar === \"]\") {\n+            extra = \"[\";\n+        } else if (endChar === \"\") {\n+            extra = \"->\";\n+        } else {\n+            extra = endChar;\n+        }\n+\n         while (parserState.pos < parserState.length) {\n             const c = parserState.userQuery[parserState.pos];\n             if (c === endChar) {\n@@ -547,14 +627,6 @@ function initSearch(rawSearchIndex) {\n                 foundStopChar = true;\n                 continue;\n             } else if (isEndCharacter(c)) {\n-                let extra = \"\";\n-                if (endChar === \">\") {\n-                    extra = \"<\";\n-                } else if (endChar === \"\") {\n-                    extra = \"->\";\n-                } else {\n-                    extra = endChar;\n-                }\n                 throw [\"Unexpected \", c, \" after \", extra];\n             }\n             if (!foundStopChar) {\n@@ -581,9 +653,9 @@ function initSearch(rawSearchIndex) {\n             }\n             const posBefore = parserState.pos;\n             start = parserState.pos;\n-            getNextElem(query, parserState, elems, endChar === \">\");\n+            getNextElem(query, parserState, elems, endChar !== \"\");\n             if (endChar !== \"\" && parserState.pos >= parserState.length) {\n-                throw [\"Unclosed \", \"<\"];\n+                throw [\"Unclosed \", extra];\n             }\n             // This case can be encountered if `getNextElem` encountered a \"stop character\" right\n             // from the start. For example if you have `,,` or `<>`. In this case, we simply move up\n@@ -594,7 +666,7 @@ function initSearch(rawSearchIndex) {\n             foundStopChar = false;\n         }\n         if (parserState.pos >= parserState.length && endChar !== \"\") {\n-            throw [\"Unclosed \", \"<\"];\n+            throw [\"Unclosed \", extra];\n         }\n         // We are either at the end of the string or on the `endChar` character, let's move forward\n         // in any case.\n@@ -779,7 +851,8 @@ function initSearch(rawSearchIndex) {\n      *\n      * ident = *(ALPHA / DIGIT / \"_\")\n      * path = ident *(DOUBLE-COLON ident) [!]\n-     * arg = [type-filter *WS COLON *WS] path [generics]\n+     * slice = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET\n+     * arg = [type-filter *WS COLON *WS] (path [generics] / slice)\n      * type-sep = COMMA/WS *(COMMA/WS)\n      * nonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep)\n      * generics = OPEN-ANGLE-BRACKET [ nonempty-arg-list ] *(type-sep)\n@@ -821,6 +894,8 @@ function initSearch(rawSearchIndex) {\n      *\n      * OPEN-ANGLE-BRACKET = \"<\"\n      * CLOSE-ANGLE-BRACKET = \">\"\n+     * OPEN-SQUARE-BRACKET = \"[\"\n+     * CLOSE-SQUARE-BRACKET = \"]\"\n      * COLON = \":\"\n      * DOUBLE-COLON = \"::\"\n      * QUOTE = %x22\n@@ -1170,7 +1245,22 @@ function initSearch(rawSearchIndex) {\n                 // ones with no type filter, which can match any entry regardless of its\n                 // own type.\n                 for (const generic of elem.generics) {\n-                    if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n+                    if (generic.typeFilter === TY_PRIMITIVE &&\n+                        generic.id === typeNameIdOfArrayOrSlice) {\n+                        const genericArray = {\n+                            id: typeNameIdOfArray,\n+                            typeFilter: TY_PRIMITIVE,\n+                            generics: generic.generics,\n+                        };\n+                        const genericSlice = {\n+                            id: typeNameIdOfSlice,\n+                            typeFilter: TY_PRIMITIVE,\n+                            generics: generic.generics,\n+                        };\n+                        if (!handleGeneric(genericArray) && !handleGeneric(genericSlice)) {\n+                            return false;\n+                        }\n+                    } else if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n                         return false;\n                     }\n                 }\n@@ -1217,7 +1307,12 @@ function initSearch(rawSearchIndex) {\n                 return row.generics.length > 0 ? checkIfInGenerics(row, elem) : false;\n             }\n \n-            if (row.id === elem.id && typePassesFilter(elem.typeFilter, row.ty)) {\n+            const matchesExact = row.id === elem.id;\n+            const matchesArrayOrSlice = elem.id === typeNameIdOfArrayOrSlice &&\n+                (row.id === typeNameIdOfSlice || row.id === typeNameIdOfArray);\n+\n+            if ((matchesExact || matchesArrayOrSlice) &&\n+                typePassesFilter(elem.typeFilter, row.ty)) {\n                 if (elem.generics.length > 0) {\n                     return checkGenerics(row, elem);\n                 }\n@@ -2082,34 +2177,6 @@ function initSearch(rawSearchIndex) {\n             filterCrates);\n     }\n \n-    /**\n-     * Add an item to the type Name->ID map, or, if one already exists, use it.\n-     * Returns the number. If name is \"\" or null, return -1 (pure generic).\n-     *\n-     * This is effectively string interning, so that function matching can be\n-     * done more quickly. Two types with the same name but different item kinds\n-     * get the same ID.\n-     *\n-     * @param {Map<string, integer>} typeNameIdMap\n-     * @param {string} name\n-     *\n-     * @returns {integer}\n-     */\n-    function buildTypeMapIndex(typeNameIdMap, name) {\n-\n-        if (name === \"\" || name === null) {\n-            return -1;\n-        }\n-\n-        if (typeNameIdMap.has(name)) {\n-            return typeNameIdMap.get(name);\n-        } else {\n-            const id = typeNameIdMap.size;\n-            typeNameIdMap.set(name, id);\n-            return id;\n-        }\n-    }\n-\n     /**\n      * Convert a list of RawFunctionType / ID to object-based FunctionType.\n      *\n@@ -2128,7 +2195,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {Array<FunctionSearchType>}\n      */\n-    function buildItemSearchTypeAll(types, lowercasePaths, typeNameIdMap) {\n+    function buildItemSearchTypeAll(types, lowercasePaths) {\n         const PATH_INDEX_DATA = 0;\n         const GENERICS_DATA = 1;\n         return types.map(type => {\n@@ -2140,15 +2207,14 @@ function initSearch(rawSearchIndex) {\n                 pathIndex = type[PATH_INDEX_DATA];\n                 generics = buildItemSearchTypeAll(\n                     type[GENERICS_DATA],\n-                    lowercasePaths,\n-                    typeNameIdMap\n+                    lowercasePaths\n                 );\n             }\n             return {\n                 // `0` is used as a sentinel because it's fewer bytes than `null`\n                 id: pathIndex === 0\n                     ? -1\n-                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                    : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: generics,\n             };\n@@ -2171,7 +2237,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {null|FunctionSearchType}\n      */\n-    function buildFunctionSearchType(functionSearchType, lowercasePaths, typeNameIdMap) {\n+    function buildFunctionSearchType(functionSearchType, lowercasePaths) {\n         const INPUTS_DATA = 0;\n         const OUTPUT_DATA = 1;\n         // `0` is used as a sentinel because it's fewer bytes than `null`\n@@ -2184,15 +2250,14 @@ function initSearch(rawSearchIndex) {\n             inputs = [{\n                 id: pathIndex === 0\n                     ? -1\n-                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                    : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: [],\n             }];\n         } else {\n             inputs = buildItemSearchTypeAll(\n                 functionSearchType[INPUTS_DATA],\n-                lowercasePaths,\n-                typeNameIdMap\n+                lowercasePaths\n             );\n         }\n         if (functionSearchType.length > 1) {\n@@ -2201,15 +2266,14 @@ function initSearch(rawSearchIndex) {\n                 output = [{\n                     id: pathIndex === 0\n                         ? -1\n-                        : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                        : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                     ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                     generics: [],\n                 }];\n             } else {\n                 output = buildItemSearchTypeAll(\n                     functionSearchType[OUTPUT_DATA],\n-                    lowercasePaths,\n-                    typeNameIdMap\n+                    lowercasePaths\n                 );\n             }\n         } else {\n@@ -2233,6 +2297,12 @@ function initSearch(rawSearchIndex) {\n         let currentIndex = 0;\n         let id = 0;\n \n+        // Initialize type map indexes for primitive list types\n+        // that can be searched using `[]` syntax.\n+        typeNameIdOfArray = buildTypeMapIndex(\"array\");\n+        typeNameIdOfSlice = buildTypeMapIndex(\"slice\");\n+        typeNameIdOfArrayOrSlice = buildTypeMapIndex(\"[]\");\n+\n         for (const crate in rawSearchIndex) {\n             if (!hasOwnPropertyRustdoc(rawSearchIndex, crate)) {\n                 continue;\n@@ -2363,8 +2433,7 @@ function initSearch(rawSearchIndex) {\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n                     type: buildFunctionSearchType(\n                         itemFunctionSearchTypes[i],\n-                        lowercasePaths,\n-                        typeNameIdMap\n+                        lowercasePaths\n                     ),\n                     id: id,\n                     normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),"}, {"sha": "25997850661458e44cc3e3188cfc37d381810744", "filename": "tests/rustdoc-js-std/option-type-signatures.js", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Foption-type-signatures.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -12,4 +12,11 @@ const EXPECTED = [\n             { 'path': 'std::option::Option', 'name': 'get_or_insert_default' },\n         ],\n     },\n+    {\n+        'query': 'option -> []',\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'as_slice' },\n+            { 'path': 'std::option::Option', 'name': 'as_mut_slice' },\n+        ],\n+    },\n ];"}, {"sha": "17bb602a502af9f8783ce4c1dccc0609fe081d9a", "filename": "tests/rustdoc-js-std/osstring-to-string.js", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Fosstring-to-string.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Fosstring-to-string.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fosstring-to-string.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -0,0 +1,9 @@\n+// exact-match\n+\n+// https://github.com/rust-lang/rust/issues/60485#issuecomment-663900624\n+const EXPECTED = {\n+    'query': 'OsString -> String',\n+    'others': [\n+        { 'path': 'std::ffi::OsString', 'name': 'into_string' },\n+    ]\n+};"}, {"sha": "f85dd199741881d948d9f216a2d185205730878a", "filename": "tests/rustdoc-js-std/parser-slice-array.js", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Fparser-slice-array.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js-std%2Fparser-slice-array.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-slice-array.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -0,0 +1,305 @@\n+const PARSED = [\n+    {\n+        query: '[[[D, []]]',\n+        elems: [],\n+        foundElems: 0,\n+        original: '[[[D, []]]',\n+        returned: [],\n+        userQuery: '[[[d, []]]',\n+        error: 'Unclosed `[`',\n+    },\n+    {\n+        query: '[[[D, []]]]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"[]\",\n+                        fullPath: [\"[]\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"[]\",\n+                        generics: [\n+                            {\n+                                name: \"[]\",\n+                                fullPath: [\"[]\"],\n+                                pathWithoutLast: [],\n+                                pathLast: \"[]\",\n+                                generics: [\n+                                    {\n+                                        name: \"d\",\n+                                        fullPath: [\"d\"],\n+                                        pathWithoutLast: [],\n+                                        pathLast: \"d\",\n+                                        generics: [],\n+                                        typeFilter: -1,\n+                                    },\n+                                    {\n+                                        name: \"[]\",\n+                                        fullPath: [\"[]\"],\n+                                        pathWithoutLast: [],\n+                                        pathLast: \"[]\",\n+                                        generics: [],\n+                                        typeFilter: 15,\n+                                    },\n+                                ],\n+                                typeFilter: 15,\n+                            },\n+                        ],\n+                        typeFilter: 15,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: '[[[D, []]]]',\n+        returned: [],\n+        userQuery: '[[[d, []]]]',\n+        error: null,\n+    },\n+    {\n+        query: '[] u8',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [],\n+                typeFilter: 15,\n+            },\n+            {\n+                name: \"u8\",\n+                fullPath: [\"u8\"],\n+                pathWithoutLast: [],\n+                pathLast: \"u8\",\n+                generics: [],\n+                typeFilter: -1,\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"[] u8\",\n+        returned: [],\n+        userQuery: \"[] u8\",\n+        error: null,\n+    },\n+    {\n+        query: '[u8]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8]\",\n+        returned: [],\n+        userQuery: \"[u8]\",\n+        error: null,\n+    },\n+    {\n+        query: '[u8,u8]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8,u8]\",\n+        returned: [],\n+        userQuery: \"[u8,u8]\",\n+        error: null,\n+    },\n+    {\n+        query: '[u8<u8>]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [\n+                            {\n+                                name: \"u8\",\n+                                fullPath: [\"u8\"],\n+                                pathWithoutLast: [],\n+                                pathLast: \"u8\",\n+                                generics: [],\n+                                typeFilter: -1,\n+                            },\n+                        ],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8<u8>]\",\n+        returned: [],\n+        userQuery: \"[u8<u8>]\",\n+        error: null,\n+    },\n+    {\n+        query: '[]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[]\",\n+        returned: [],\n+        userQuery: \"[]\",\n+        error: null,\n+    },\n+    {\n+        query: '[>',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[>\",\n+        returned: [],\n+        userQuery: \"[>\",\n+        error: \"Unexpected `>` after `[`\",\n+    },\n+    {\n+        query: '[<',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[<\",\n+        returned: [],\n+        userQuery: \"[<\",\n+        error: \"Found generics without a path\",\n+    },\n+    {\n+        query: '[a>',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a>\",\n+        returned: [],\n+        userQuery: \"[a>\",\n+        error: \"Unexpected `>` after `[`\",\n+    },\n+    {\n+        query: '[a<',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a<\",\n+        returned: [],\n+        userQuery: \"[a<\",\n+        error: \"Unclosed `<`\",\n+    },\n+    {\n+        query: '[a',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a\",\n+        returned: [],\n+        userQuery: \"[a\",\n+        error: \"Unclosed `[`\",\n+    },\n+    {\n+        query: '[',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[\",\n+        returned: [],\n+        userQuery: \"[\",\n+        error: \"Unclosed `[`\",\n+    },\n+    {\n+        query: ']',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"]\",\n+        returned: [],\n+        userQuery: \"]\",\n+        error: \"Unexpected `]`\",\n+    },\n+    {\n+        query: 'primitive:[u8]',\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"primitive:[u8]\",\n+        returned: [],\n+        userQuery: \"primitive:[u8]\",\n+        error: null,\n+    },\n+    {\n+        query: 'macro:[u8]',\n+        elems: [],\n+        foundElems: 0,\n+        original: \"macro:[u8]\",\n+        returned: [],\n+        userQuery: \"macro:[u8]\",\n+        error: \"Invalid search type: primitive `[]` and `macro` both specified\",\n+    },\n+];"}, {"sha": "d676d0577c583cd70cd586829376c4a572826694", "filename": "tests/rustdoc-js/slice-array.js", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js%2Fslice-array.js", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js%2Fslice-array.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fslice-array.js?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -51,4 +51,23 @@ const EXPECTED = [\n             { 'path': 'slice_array', 'name': 'gamma' },\n         ],\n     },\n+    {\n+        'query': '[TraitCat]',\n+        'in_args': [\n+            { 'path': 'slice_array', 'name': 'gamma' },\n+            { 'path': 'slice_array', 'name': 'epsilon' },\n+        ],\n+    },\n+    {\n+        'query': 'R<[Q]>',\n+        'returned': [\n+            { 'path': 'slice_array', 'name': 'bet' },\n+        ],\n+    },\n+    {\n+        'query': 'R<[P]>',\n+        'in_args': [\n+            { 'path': 'slice_array', 'name': 'alpha' },\n+        ],\n+    },\n ];"}, {"sha": "15ac4294f3d79ce01526efb089ad2842af11995a", "filename": "tests/rustdoc-js/slice-array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js%2Fslice-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a/tests%2Frustdoc-js%2Fslice-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fslice-array.rs?ref=81c02da94e5f5ec1ec4732e75049c3a3cb4d6c7a", "patch": "@@ -14,3 +14,5 @@ pub trait TraitCat {}\n pub trait TraitDog {}\n \n pub fn gamma<T: TraitCat + TraitDog>(t: [T; 32]) {}\n+\n+pub fn epsilon<T: TraitCat + TraitDog>(t: &[T]) {}"}]}