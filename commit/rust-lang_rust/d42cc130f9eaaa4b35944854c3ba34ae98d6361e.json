{"sha": "d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MmNjMTMwZjllYWFhNGIzNTk0NDg1NGMzYmEzNGFlOThkNjM2MWU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-02T21:51:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-10T00:46:27Z"}, "message": "std: Remove the as_utf16_p functions\n\nThese functions are all much better expressed via RAII using the to_utf16()\nmethod on strings. This refactoring also takes this opportunity to properly\nhandle when filenames aren't valid unicode when passed through to the windows\nI/O layer by properly returning I/O errors.\n\nAll previous users of the `as_utf16_p` or `as_utf16_mut_p` functions will need\nto convert their code to using `foo.to_utf16().append_one(0)` to get a\nnull-terminated utf16 string.\n\n[breaking-change]", "tree": {"sha": "02caa183a0848d2533948c9bb8a9fbf7f6b45677", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02caa183a0848d2533948c9bb8a9fbf7f6b45677"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "html_url": "https://github.com/rust-lang/rust/commit/d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ea7aa30cc864d00fc30b9ba610f2daefab4e850", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea7aa30cc864d00fc30b9ba610f2daefab4e850", "html_url": "https://github.com/rust-lang/rust/commit/0ea7aa30cc864d00fc30b9ba610f2daefab4e850"}], "stats": {"total": 361, "additions": 175, "deletions": 186}, "files": [{"sha": "1ec25933eec3c2ea1bfafc0cb2fe6156f7a51ca7", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -69,7 +69,6 @@ extern \"system\" {\n pub mod compat {\n     use std::intrinsics::{atomic_store_relaxed, transmute};\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-    use std::os::win32::as_utf16_p;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -80,12 +79,11 @@ pub mod compat {\n     // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n     // be any slower than a regular DLL call.\n     unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n-        as_utf16_p(module, |module| {\n-            symbol.with_c_str(|symbol| {\n-                let handle = GetModuleHandleW(module);\n-                let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n-                atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n-            })\n+        let module = module.to_utf16().append_one(0);\n+        symbol.with_c_str(|symbol| {\n+            let handle = GetModuleHandleW(module.as_ptr());\n+            let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n+            atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n         })\n     }\n "}, {"sha": "0e6c5c744f453f1fc457042bb1a63b3aaaf2e50d", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 62, "deletions": 52, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -15,7 +15,7 @@ use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n use std::mem;\n-use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+use std::os::win32::fill_utf16_buf_and_decode;\n use std::ptr;\n use std::rt::rtio;\n use std::rt::rtio::IoResult;\n@@ -253,6 +253,17 @@ impl Drop for Inner {\n     }\n }\n \n+pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n+    match s.as_str() {\n+        Some(s) => Ok(s.to_utf16().append_one(0)),\n+        None => Err(IoError {\n+            code: libc::ERROR_INVALID_NAME as uint,\n+            extra: 0,\n+            detail: Some(\"valid unicode input required\".to_str()),\n+        })\n+    }\n+}\n+\n pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n         -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n@@ -299,15 +310,16 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n     // Compat with unix, this allows opening directories (see libuv)\n     dwFlagsAndAttributes |= libc::FILE_FLAG_BACKUP_SEMANTICS;\n \n-    let handle = as_utf16_p(path.as_str().unwrap(), |buf| unsafe {\n-        libc::CreateFileW(buf,\n+    let path = try!(to_utf16(path));\n+    let handle = unsafe {\n+        libc::CreateFileW(path.as_ptr(),\n                           dwDesiredAccess,\n                           dwShareMode,\n                           ptr::mut_null(),\n                           dwCreationDisposition,\n                           dwFlagsAndAttributes,\n                           ptr::mut_null())\n-    });\n+    };\n     if handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n         Err(super::last_error())\n     } else {\n@@ -324,11 +336,10 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n }\n \n pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n+    let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n-        as_utf16_p(p.as_str().unwrap(), |buf| {\n-            libc::CreateDirectoryW(buf, ptr::mut_null())\n-        })\n+        libc::CreateDirectoryW(p.as_ptr(), ptr::mut_null())\n     })\n }\n \n@@ -351,9 +362,11 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     let star = Path::new(unsafe {\n         CString::new(p.with_ref(|p| p), false)\n     }).join(\"*\");\n-    as_utf16_p(star.as_str().unwrap(), |path_ptr| unsafe {\n+    let path = try!(to_utf16(&star.to_c_str()));\n+\n+    unsafe {\n         let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-        let find_handle = libc::FindFirstFileW(path_ptr, wfd_ptr as libc::HANDLE);\n+        let find_handle = libc::FindFirstFileW(path.as_ptr(), wfd_ptr as libc::HANDLE);\n         if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n             let mut paths = vec!();\n             let mut more_files = 1 as libc::c_int;\n@@ -377,37 +390,35 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         } else {\n             Err(super::last_error())\n         }\n-    })\n+    }\n }\n \n pub fn unlink(p: &CString) -> IoResult<()> {\n+    let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n-        as_utf16_p(p.as_str().unwrap(), |buf| {\n-            libc::DeleteFileW(buf)\n-        })\n+        libc::DeleteFileW(p.as_ptr())\n     })\n }\n \n pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    let old = try!(to_utf16(old));\n+    let new = try!(to_utf16(new));\n     super::mkerr_winbool(unsafe {\n-        as_utf16_p(old.as_str().unwrap(), |old| {\n-            as_utf16_p(new.as_str().unwrap(), |new| {\n-                libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-            })\n-        })\n+        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n+                          libc::MOVEFILE_REPLACE_EXISTING)\n     })\n }\n \n pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wchmod(p, mode as libc::c_int)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe {\n+        libc::wchmod(p.as_ptr(), mode.bits() as libc::c_int)\n+    })\n }\n \n pub fn rmdir(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wrmdir(p)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n }\n \n pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n@@ -418,16 +429,15 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n pub fn readlink(p: &CString) -> IoResult<CString> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n     use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n+    let p = try!(to_utf16(p));\n     let handle = unsafe {\n-        as_utf16_p(p.as_str().unwrap(), |p| {\n-            libc::CreateFileW(p,\n-                              libc::GENERIC_READ,\n-                              libc::FILE_SHARE_READ,\n-                              ptr::mut_null(),\n-                              libc::OPEN_EXISTING,\n-                              libc::FILE_ATTRIBUTE_NORMAL,\n-                              ptr::mut_null())\n-        })\n+        libc::CreateFileW(p.as_ptr(),\n+                          libc::GENERIC_READ,\n+                          libc::FILE_SHARE_READ,\n+                          ptr::mut_null(),\n+                          libc::OPEN_EXISTING,\n+                          libc::FILE_ATTRIBUTE_NORMAL,\n+                          ptr::mut_null())\n     };\n     if handle as int == libc::INVALID_HANDLE_VALUE as int {\n         return Err(super::last_error())\n@@ -453,19 +463,19 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n     use io::c::compat::kernel32::CreateSymbolicLinkW;\n-    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-        as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { CreateSymbolicLinkW(dst, src, 0) }\n-        }) as libc::BOOL\n-    }))\n+    let src = try!(to_utf16(src));\n+    let dst = try!(to_utf16(dst));\n+    super::mkerr_winbool(unsafe {\n+        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n+    })\n }\n \n pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-        as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-        })\n-    }))\n+    let src = try!(to_utf16(src));\n+    let dst = try!(to_utf16(dst));\n+    super::mkerr_winbool(unsafe {\n+        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::mut_null())\n+    })\n }\n \n fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n@@ -491,12 +501,11 @@ fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n \n pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    as_utf16_p(p.as_str().unwrap(), |up| {\n-        match unsafe { libc::wstat(up, &mut stat) } {\n-            0 => Ok(mkstat(&stat)),\n-            _ => Err(super::last_error()),\n-        }\n-    })\n+    let p = try!(to_utf16(p));\n+    match unsafe { libc::wstat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n }\n \n pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n@@ -509,7 +518,8 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n         actime: (atime / 1000) as libc::time64_t,\n         modtime: (mtime / 1000) as libc::time64_t,\n     };\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wutime(p, &buf)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe {\n+        libc::wutime(p.as_ptr(), &buf)\n+    })\n }"}, {"sha": "45b12aa7007ff307320d33bd8be67816c0c13ce4", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -88,7 +88,6 @@ use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n use std::mem;\n-use std::os::win32::as_utf16_p;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n@@ -98,6 +97,7 @@ use std::rt::mutex;\n \n use super::c;\n use super::util;\n+use super::file::to_utf16;\n \n struct Event(libc::HANDLE);\n \n@@ -261,67 +261,66 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        as_utf16_p(addr.as_str().unwrap(), |p| {\n-            let start = ::io::timer::now();\n-            loop {\n-                match UnixStream::try_connect(p) {\n-                    Some(handle) => {\n-                        let inner = Inner::new(handle);\n-                        let mut mode = libc::PIPE_TYPE_BYTE |\n-                                       libc::PIPE_READMODE_BYTE |\n-                                       libc::PIPE_WAIT;\n-                        let ret = unsafe {\n-                            libc::SetNamedPipeHandleState(inner.handle,\n-                                                          &mut mode,\n-                                                          ptr::mut_null(),\n-                                                          ptr::mut_null())\n-                        };\n-                        return if ret == 0 {\n-                            Err(super::last_error())\n-                        } else {\n-                            Ok(UnixStream {\n-                                inner: Arc::new(inner),\n-                                read: None,\n-                                write: None,\n-                                read_deadline: 0,\n-                                write_deadline: 0,\n-                            })\n-                        }\n+        let addr = try!(to_utf16(addr));\n+        let start = ::io::timer::now();\n+        loop {\n+            match UnixStream::try_connect(addr.as_ptr()) {\n+                Some(handle) => {\n+                    let inner = Inner::new(handle);\n+                    let mut mode = libc::PIPE_TYPE_BYTE |\n+                                   libc::PIPE_READMODE_BYTE |\n+                                   libc::PIPE_WAIT;\n+                    let ret = unsafe {\n+                        libc::SetNamedPipeHandleState(inner.handle,\n+                                                      &mut mode,\n+                                                      ptr::mut_null(),\n+                                                      ptr::mut_null())\n+                    };\n+                    return if ret == 0 {\n+                        Err(super::last_error())\n+                    } else {\n+                        Ok(UnixStream {\n+                            inner: Arc::new(inner),\n+                            read: None,\n+                            write: None,\n+                            read_deadline: 0,\n+                            write_deadline: 0,\n+                        })\n                     }\n-                    None => {}\n                 }\n+                None => {}\n+            }\n \n-                // On windows, if you fail to connect, you may need to call the\n-                // `WaitNamedPipe` function, and this is indicated with an error\n-                // code of ERROR_PIPE_BUSY.\n-                let code = unsafe { libc::GetLastError() };\n-                if code as int != libc::ERROR_PIPE_BUSY as int {\n-                    return Err(super::last_error())\n-                }\n+            // On windows, if you fail to connect, you may need to call the\n+            // `WaitNamedPipe` function, and this is indicated with an error\n+            // code of ERROR_PIPE_BUSY.\n+            let code = unsafe { libc::GetLastError() };\n+            if code as int != libc::ERROR_PIPE_BUSY as int {\n+                return Err(super::last_error())\n+            }\n \n-                match timeout {\n-                    Some(timeout) => {\n-                        let now = ::io::timer::now();\n-                        let timed_out = (now - start) >= timeout || unsafe {\n-                            let ms = (timeout - (now - start)) as libc::DWORD;\n-                            libc::WaitNamedPipeW(p, ms) == 0\n-                        };\n-                        if timed_out {\n-                            return Err(util::timeout(\"connect timed out\"))\n-                        }\n+            match timeout {\n+                Some(timeout) => {\n+                    let now = ::io::timer::now();\n+                    let timed_out = (now - start) >= timeout || unsafe {\n+                        let ms = (timeout - (now - start)) as libc::DWORD;\n+                        libc::WaitNamedPipeW(addr.as_ptr(), ms) == 0\n+                    };\n+                    if timed_out {\n+                        return Err(util::timeout(\"connect timed out\"))\n                     }\n+                }\n \n-                    // An example I found on microsoft's website used 20\n-                    // seconds, libuv uses 30 seconds, hence we make the\n-                    // obvious choice of waiting for 25 seconds.\n-                    None => {\n-                        if unsafe { libc::WaitNamedPipeW(p, 25000) } == 0 {\n-                            return Err(super::last_error())\n-                        }\n+                // An example I found on microsoft's website used 20\n+                // seconds, libuv uses 30 seconds, hence we make the\n+                // obvious choice of waiting for 25 seconds.\n+                None => {\n+                    if unsafe { libc::WaitNamedPipeW(addr.as_ptr(), 25000) } == 0 {\n+                        return Err(super::last_error())\n                     }\n                 }\n             }\n-        })\n+        }\n     }\n \n     fn handle(&self) -> libc::HANDLE { self.inner.handle }\n@@ -564,14 +563,13 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        as_utf16_p(addr.as_str().unwrap(), |p| {\n-            let ret = unsafe { pipe(p, true) };\n-            if ret == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n-                Err(super::last_error())\n-            } else {\n-                Ok(UnixListener { handle: ret, name: addr.clone() })\n-            }\n-        })\n+        let addr_v = try!(to_utf16(addr));\n+        let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n+        if ret == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+            Err(super::last_error())\n+        } else {\n+            Ok(UnixListener { handle: ret, name: addr.clone() })\n+        }\n     }\n \n     pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n@@ -639,6 +637,8 @@ impl UnixAcceptor {\n         // using the original server pipe.\n         let handle = self.listener.handle;\n \n+        let name = try!(to_utf16(&self.listener.name));\n+\n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n         // someone on the other end connects. This function can \"fail\" if a\n@@ -678,9 +678,7 @@ impl UnixAcceptor {\n         // Now that we've got a connected client to our handle, we need to\n         // create a second server pipe. If this fails, we disconnect the\n         // connected client and return an error (see comments above).\n-        let new_handle = as_utf16_p(self.listener.name.as_str().unwrap(), |p| {\n-            unsafe { pipe(p, false) }\n-        });\n+        let new_handle = unsafe { pipe(name.as_ptr(), false) };\n         if new_handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n             let ret = Err(super::last_error());\n             // If our disconnection fails, then there's not really a whole lot"}, {"sha": "97b227ae1d8d3b6ee14f1b4b3b56fab34b0bd7ce", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -296,16 +296,15 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     lpSecurityDescriptor: ptr::mut_null(),\n                     bInheritHandle: 1,\n                 };\n-                *slot = os::win32::as_utf16_p(\"NUL\", |filename| {\n-                    libc::CreateFileW(filename,\n-                                      access,\n-                                      libc::FILE_SHARE_READ |\n-                                          libc::FILE_SHARE_WRITE,\n-                                      &mut sa,\n-                                      libc::OPEN_EXISTING,\n-                                      0,\n-                                      ptr::mut_null())\n-                });\n+                let filename = \"NUL\".to_utf16().append_one(0);\n+                *slot = libc::CreateFileW(filename.as_ptr(),\n+                                          access,\n+                                          libc::FILE_SHARE_READ |\n+                                              libc::FILE_SHARE_WRITE,\n+                                          &mut sa,\n+                                          libc::OPEN_EXISTING,\n+                                          0,\n+                                          ptr::mut_null());\n                 if *slot == INVALID_HANDLE_VALUE as libc::HANDLE {\n                     return Err(super::last_error())\n                 }\n@@ -338,18 +337,17 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n-                os::win32::as_mut_utf16_p(cmd_str.as_slice(), |cmdp| {\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmdp,\n-                                                 ptr::mut_null(),\n-                                                 ptr::mut_null(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(super::last_error());\n-                    }\n-                })\n+                let mut cmd_str = cmd_str.to_utf16().append_one(0);\n+                let created = CreateProcessW(ptr::null(),\n+                                             cmd_str.as_mut_ptr(),\n+                                             ptr::mut_null(),\n+                                             ptr::mut_null(),\n+                                             TRUE,\n+                                             flags, envp, dirp,\n+                                             &mut si, &mut pi);\n+                if created == FALSE {\n+                    create_err = Some(super::last_error());\n+                }\n             })\n         });\n \n@@ -740,7 +738,8 @@ fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          os::win32::as_utf16_p(dir_str, cb)\n+          let dir_str = dir_str.to_utf16().append_one(0);\n+          cb(dir_str.as_ptr())\n       },\n       None => cb(ptr::null())\n     }"}, {"sha": "8ad10a686e677677778e4ce92efb73b5f6424094", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -135,7 +135,6 @@ mod imp {\n mod imp {\n     use libc;\n     use std::mem;\n-    use std::os::win32::as_utf16_p;\n     use std::os;\n     use std::ptr;\n \n@@ -162,8 +161,9 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let handle = as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-                libc::CreateFileW(p,\n+            let p_16 = p.as_str().unwrap().to_utf16().append_one(0);\n+            let handle = unsafe {\n+                libc::CreateFileW(p_16.as_ptr(),\n                                   libc::FILE_GENERIC_READ |\n                                     libc::FILE_GENERIC_WRITE,\n                                   libc::FILE_SHARE_READ |\n@@ -173,7 +173,7 @@ mod imp {\n                                   libc::CREATE_ALWAYS,\n                                   libc::FILE_ATTRIBUTE_NORMAL,\n                                   ptr::mut_null())\n-            });\n+            };\n             if handle as uint == libc::INVALID_HANDLE_VALUE as uint {\n                 fail!(\"create file error: {}\", os::last_os_error());\n             }"}, {"sha": "fa882e7d016fe21783efe91b2ed1cebd09c62af4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -133,7 +133,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use slice::{MutableVector, ImmutableVector};\n     use string::String;\n-    use str::{StrSlice, StrAllocating};\n+    use str::StrSlice;\n     use str;\n     use vec::Vec;\n \n@@ -171,17 +171,6 @@ pub mod win32 {\n             return res;\n         }\n     }\n-\n-    pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n-        as_mut_utf16_p(s, |t| { f(t as *u16) })\n-    }\n-\n-    pub fn as_mut_utf16_p<T>(s: &str, f: |*mut u16| -> T) -> T {\n-        let mut t = s.to_utf16();\n-        // Null terminate before passing on.\n-        t.push(0u16);\n-        f(t.as_mut_ptr())\n-    }\n }\n \n /*\n@@ -356,11 +345,10 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n-            use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-            as_utf16_p(n, |u| {\n-                fill_utf16_buf_and_decode(|buf, sz| {\n-                    libc::GetEnvironmentVariableW(u, buf, sz)\n-                })\n+            use os::win32::{fill_utf16_buf_and_decode};\n+            let n = n.to_utf16().append_one(0);\n+            fill_utf16_buf_and_decode(|buf, sz| {\n+                libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n             })\n         })\n     }\n@@ -398,14 +386,11 @@ pub fn setenv(n: &str, v: &str) {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    let n = n.to_utf16().append_one(0);\n+    let v = v.to_utf16().append_one(0);\n     unsafe {\n         with_env_lock(|| {\n-            use os::win32::as_utf16_p;\n-            as_utf16_p(n, |nbuf| {\n-                as_utf16_p(v, |vbuf| {\n-                    libc::SetEnvironmentVariableW(nbuf, vbuf);\n-                })\n-            })\n+            libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr());\n         })\n     }\n }\n@@ -428,12 +413,10 @@ pub fn unsetenv(n: &str) {\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n+        let n = n.to_utf16().append_one(0);\n         unsafe {\n             with_env_lock(|| {\n-                use os::win32::as_utf16_p;\n-                as_utf16_p(n, |nbuf| {\n-                    libc::SetEnvironmentVariableW(nbuf, ptr::null());\n-                })\n+                libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null());\n             })\n         }\n     }\n@@ -732,11 +715,12 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n+        let p = match p.as_str() {\n+            Some(s) => s.to_utf16().append_one(0),\n+            None => return false,\n+        };\n         unsafe {\n-            use os::win32::as_utf16_p;\n-            return as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n-            });\n+            libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL)\n         }\n     }\n "}, {"sha": "6980c5cc0c2c12511fc10b174510dfcdbdd5ff0f", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42cc130f9eaaa4b35944854c3ba34ae98d6361e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=d42cc130f9eaaa4b35944854c3ba34ae98d6361e", "patch": "@@ -272,21 +272,21 @@ pub mod dl {\n \n #[cfg(target_os = \"win32\")]\n pub mod dl {\n+    use c_str::ToCStr;\n     use libc;\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n-    use string::String;\n+    use str::StrAllocating;\n     use str;\n-    use c_str::ToCStr;\n+    use string::String;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         // Windows expects Unicode data\n         let filename_cstr = filename.to_c_str();\n         let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n-        os::win32::as_utf16_p(filename_str, |raw_name| {\n-            LoadLibraryW(raw_name as *libc::c_void) as *u8\n-        })\n+        let filename_str = filename_str.to_utf16().append_one(0);\n+        LoadLibraryW(filename_str.as_ptr() as *libc::c_void) as *u8\n     }\n \n     pub unsafe fn open_internal() -> *u8 {"}]}