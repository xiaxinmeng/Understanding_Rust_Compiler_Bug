{"sha": "addc653da5fa6d0541c445f32350d95d84f3de57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZGM2NTNkYTVmYTZkMDU0MWM0NDVmMzIzNTBkOTVkODRmM2RlNTc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-07T19:13:00Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-19T17:13:53Z"}, "message": "begin implementing mir-typeck", "tree": {"sha": "789a71ee8a985cfeb314bfdec80b4256ccf7aa87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/789a71ee8a985cfeb314bfdec80b4256ccf7aa87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/addc653da5fa6d0541c445f32350d95d84f3de57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/addc653da5fa6d0541c445f32350d95d84f3de57", "html_url": "https://github.com/rust-lang/rust/commit/addc653da5fa6d0541c445f32350d95d84f3de57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/addc653da5fa6d0541c445f32350d95d84f3de57/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15611f75ca49bd6c40ecbe84caa44cb74a9781f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/15611f75ca49bd6c40ecbe84caa44cb74a9781f4", "html_url": "https://github.com/rust-lang/rust/commit/15611f75ca49bd6c40ecbe84caa44cb74a9781f4"}], "stats": {"total": 431, "additions": 423, "deletions": 8}, "files": [{"sha": "2f24a1a8962de5f5f66ac4725c8f93f2c62f5267", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -45,6 +45,9 @@ pub struct Mir<'tcx> {\n     /// values in that it is possible to borrow them and mutate them\n     /// through the resulting reference.\n     pub temp_decls: Vec<TempDecl<'tcx>>,\n+\n+    /// A span representing this MIR, for error reporting\n+    pub span: Span,\n }\n \n /// where execution begins\n@@ -145,7 +148,7 @@ pub enum BorrowKind {\n \n /// A \"variable\" is a binding declared by the user as part of the fn\n /// decl, a let, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n@@ -154,7 +157,7 @@ pub struct VarDecl<'tcx> {\n \n /// A \"temp\" is a temporary that we place on the stack. They are\n /// anonymous, always mutable, and have only a type.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct TempDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -170,7 +173,7 @@ pub struct TempDecl<'tcx> {\n ///\n /// there is only one argument, of type `(i32, u32)`, but two bindings\n /// (`x` and `y`).\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }"}, {"sha": "e8b83962b521bd7cdb5acebe3b5879c747c07c3e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -14,7 +14,8 @@\n  */\n \n use mir::repr::*;\n-use middle::subst::Substs;\n+use middle::const_eval::ConstVal;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, AdtDef, Ty};\n use rustc_front::hir;\n \n@@ -150,6 +151,73 @@ impl<'tcx> Mir<'tcx> {\n                 self.lvalue_ty(tcx, &proj.base).projection_ty(tcx, &proj.elem)\n         }\n     }\n+\n+    pub fn rvalue_ty(&self,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     rvalue: &Rvalue<'tcx>)\n+                     -> Option<Ty<'tcx>>\n+    {\n+        match *rvalue {\n+            Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n+            Rvalue::Repeat(ref operand, ref count) => {\n+                if let ConstVal::Uint(u) = count.value {\n+                    let op_ty = self.operand_ty(tcx, operand);\n+                    Some(tcx.mk_array(op_ty, u as usize))\n+                } else {\n+                    None\n+                }\n+            }\n+            Rvalue::Ref(reg, bk, ref lv) => {\n+                let lv_ty = self.lvalue_ty(tcx, lv).to_ty(tcx);\n+                Some(tcx.mk_ref(\n+                    tcx.mk_region(reg),\n+                    ty::TypeAndMut {\n+                        ty: lv_ty,\n+                        mutbl: bk.to_mutbl_lossy()\n+                    }\n+                ))\n+            }\n+            Rvalue::Len(..) => Some(tcx.types.usize),\n+            Rvalue::Cast(_, _, ty) => Some(ty),\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = self.operand_ty(tcx, lhs);\n+                let rhs_ty = self.operand_ty(tcx, rhs);\n+                Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n+            }\n+            Rvalue::UnaryOp(_, ref operand) => {\n+                Some(self.operand_ty(tcx, operand))\n+            }\n+            Rvalue::Box(t) => {\n+                Some(tcx.mk_box(t))\n+            }\n+            Rvalue::Aggregate(ref ak, ref ops) => {\n+                match *ak {\n+                    AggregateKind::Vec => {\n+                        if let Some(operand) = ops.get(0) {\n+                            let ty = self.operand_ty(tcx, operand);\n+                            Some(tcx.mk_array(ty, ops.len()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    AggregateKind::Tuple => {\n+                        Some(tcx.mk_tup(\n+                            ops.iter().map(|op| self.operand_ty(tcx, op)).collect()\n+                        ))\n+                    }\n+                    AggregateKind::Adt(def, _, substs) => {\n+                        Some(def.type_scheme(tcx).ty.subst(tcx, substs))\n+                    }\n+                    AggregateKind::Closure(did, substs) => {\n+                        Some(tcx.mk_closure_from_closure_substs(\n+                            did, Box::new(substs.clone())))\n+                    }\n+                }\n+            }\n+            Rvalue::Slice { .. } => None,\n+            Rvalue::InlineAsm(..) => None\n+        }\n+    }\n }\n \n impl BorrowKind {"}, {"sha": "b83d0f6a9803a96c2990b61910367fcc36822b73", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -80,7 +80,7 @@ macro_rules! unpack {\n /// the main entry point for building MIR for a function\n \n pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n-                          _span: Span,\n+                          span: Span,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n                           explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                           argument_extent: CodeExtent,\n@@ -97,7 +97,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         temp_decls: vec![],\n         var_decls: vec![],\n         var_indices: FnvHashMap(),\n-        unit_temp: None\n+        unit_temp: None,\n     };\n \n     assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n@@ -119,6 +119,7 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         arg_decls: arg_decls,\n         temp_decls: builder.temp_decls,\n         return_ty: return_ty,\n+        span: span\n     }\n }\n "}, {"sha": "7a2b90fbbb31d9c0edfc0c5ceee09938031f225b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -22,7 +22,7 @@ extern crate rustc_front;\n use build;\n use graphviz;\n use pretty;\n-use transform::{simplify_cfg, no_landing_pads};\n+use transform::{simplify_cfg, type_check, no_landing_pads};\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -148,8 +148,9 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mut mir) => {\n-                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, self.tcx);\n                 simplify_cfg::SimplifyCfg::new().run_on_mir(&mut mir, self.tcx);\n+                type_check::TypeckMir::new(&infcx).run_on_mir(&mut mir, self.tcx);\n+                no_landing_pads::NoLandingPads.run_on_mir(&mut mir, self.tcx);\n \n                 let meta_item_list = self.attr\n                                          .iter()"}, {"sha": "64e188a3b558e91aa8fee9e9cc1954a3170400ad", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -11,4 +11,5 @@\n pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n+pub mod type_check;\n mod util;"}, {"sha": "3a891543e80130d405514e0fcf7c08f4c1396f33", "filename": "src/librustc_mir/transform/type_check.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/addc653da5fa6d0541c445f32350d95d84f3de57/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=addc653da5fa6d0541c445f32350d95d84f3de57", "patch": "@@ -0,0 +1,341 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass type-checks the MIR to ensure it is not broken.\n+\n+use rustc::middle::infer;\n+use rustc::middle::ty::{self, Ty};\n+use rustc::middle::ty::fold::TypeFoldable;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::MirPass;\n+use rustc::mir::visit::{self, Visitor};\n+\n+use syntax::codemap::{Span, DUMMY_SP};\n+use std::fmt;\n+\n+macro_rules! span_mirbug {\n+    ($context:expr, $elem:expr, $($message:tt)*) => ({\n+        $context.tcx().sess.span_warn(\n+            $context.last_span,\n+            &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n+        )\n+    })\n+}\n+\n+/// Verifies that MIR types are sane to not crash further\n+/// checks.\n+struct TypeVerifier<'a, 'tcx: 'a> {\n+    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    last_span: Span,\n+    errors_reported: bool\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'tcx> {\n+    fn visit_span(&mut self, span: &Span) {\n+        if *span != DUMMY_SP {\n+            self.last_span = *span;\n+        }\n+    }\n+\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: visit::LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+        let lv_ty = self.mir.lvalue_ty(self.tcx(), lvalue).to_ty(self.tcx());\n+        self.sanitize_type(lvalue, lv_ty);\n+    }\n+\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n+        self.super_constant(constant);\n+        self.sanitize_type(constant, constant.ty);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        self.super_rvalue(rvalue);\n+        if let Some(ty) = self.mir.rvalue_ty(self.tcx(), rvalue) {\n+            self.sanitize_type(rvalue, ty);\n+        }\n+    }\n+\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        if let ty::FnConverging(t) = mir.return_ty {\n+            self.sanitize_type(&\"return type\", t);\n+        }\n+        for var_decl in &mir.var_decls {\n+            self.sanitize_type(var_decl, var_decl.ty);\n+        }\n+        for (n, arg_decl) in mir.arg_decls.iter().enumerate() {\n+            self.sanitize_type(&(n, arg_decl), arg_decl.ty);\n+        }\n+        for (n, tmp_decl) in mir.temp_decls.iter().enumerate() {\n+            self.sanitize_type(&(n, tmp_decl), tmp_decl.ty);\n+        }\n+        self.super_mir(mir);\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeVerifier<'a, 'tcx> {\n+    fn new(infcx: &'a infer::InferCtxt<'a, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        TypeVerifier {\n+            infcx: infcx,\n+            mir: mir,\n+            last_span: mir.span,\n+            errors_reported: false\n+        }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn sanitize_type(&mut self, parent: &fmt::Debug, ty: Ty<'tcx>) {\n+        if !(ty.needs_infer() || ty.has_escaping_regions()) {\n+            return;\n+        }\n+        span_mirbug!(self, parent, \"bad type {:?}\", ty);\n+        self.errors_reported = true;\n+    }\n+}\n+\n+pub struct TypeckMir<'a, 'tcx: 'a> {\n+    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+    last_span: Span\n+}\n+\n+impl<'a, 'tcx> TypeckMir<'a, 'tcx> {\n+    pub fn new(infcx: &'a infer::InferCtxt<'a, 'tcx>) -> Self {\n+        TypeckMir {\n+            infcx: infcx,\n+            last_span: DUMMY_SP\n+        }\n+    }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>) {\n+        debug!(\"check_stmt: {:?}\", stmt);\n+        let tcx = self.tcx();\n+        match stmt.kind {\n+            StatementKind::Assign(ref lv, ref rv) => {\n+                match lv {\n+                    &Lvalue::ReturnPointer if mir.return_ty == ty::FnDiverging => {\n+                        // HACK: buggy writes\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n+\n+                let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n+                let rv_ty = mir.rvalue_ty(tcx, rv);\n+                if let Some(rv_ty) = rv_ty {\n+                    if let Err(terr) = infer::can_mk_subty(self.infcx, rv_ty, lv_ty) {\n+                        span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n+                                     lv_ty, rv_ty, terr);\n+                    }\n+                }\n+\n+                // FIXME: rvalue with undeterminable type - e.g. inline\n+                // asm.\n+            }\n+        }\n+    }\n+\n+    fn check_terminator(&self,\n+                        mir: &Mir<'tcx>,\n+                        term: &Terminator<'tcx>) {\n+        debug!(\"check_terminator: {:?}\", term);\n+        let tcx = self.tcx();\n+        match *term {\n+            Terminator::Goto { .. } |\n+            Terminator::Resume |\n+            Terminator::Return |\n+            Terminator::Drop { .. } => {}\n+            Terminator::If { ref cond, .. } => {\n+                let cond_ty = mir.operand_ty(tcx, cond);\n+                match cond_ty.sty {\n+                    ty::TyBool => {}\n+                    _ => {\n+                        span_mirbug!(self, term, \"bad If ({:?}, not bool\", cond_ty);\n+                    }\n+                }\n+            }\n+            Terminator::SwitchInt { ref discr, switch_ty, .. } => {\n+                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                if let Err(terr) = infer::can_mk_subty(self.infcx, discr_ty, switch_ty) {\n+                    span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n+                                 switch_ty, discr_ty, terr);\n+                }\n+            }\n+            Terminator::Switch { ref discr, adt_def, .. } => {\n+                let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n+                match discr_ty.sty {\n+                    ty::TyEnum(def, _) if def == adt_def => {},\n+                    _ => {\n+                        span_mirbug!(self, term, \"bad Switch ({:?} on {:?})\",\n+                                     adt_def, discr_ty);\n+                    }\n+                }\n+            }\n+            Terminator::Call { ref func, ref args, ref destination, .. } => {\n+                let func_ty = mir.operand_ty(tcx, func);\n+                debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n+                let func_ty = match func_ty.sty {\n+                    ty::TyBareFn(_, func_ty) => func_ty,\n+                    _ => {\n+                        span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n+                        return;\n+                    }\n+                };\n+                let sig = tcx.erase_late_bound_regions(&func_ty.sig);\n+                self.check_call_dest(mir, term, &sig, destination);\n+\n+                if self.is_box_free(func) {\n+                    self.check_box_free_inputs(mir, term, &sig, args);\n+                } else {\n+                    self.check_call_inputs(mir, term, &sig, args);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_call_dest(&self,\n+                       mir: &Mir<'tcx>,\n+                       term: &Terminator<'tcx>,\n+                       sig: &ty::FnSig<'tcx>,\n+                       destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n+        let tcx = self.tcx();\n+        match (destination, sig.output) {\n+            (&Some(..), ty::FnDiverging) => {\n+                span_mirbug!(self, term, \"call to diverging function {:?} with dest\", sig);\n+            }\n+            (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n+                let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                if let Err(terr) = infer::can_mk_subty(self.infcx, ty, dest_ty) {\n+                    span_mirbug!(self, term,\n+                                 \"call dest mismatch ({:?} <- {:?}): {:?}\",\n+                                 dest_ty, ty, terr);\n+                }\n+            }\n+            (&None, ty::FnDiverging) => {}\n+            (&None, ty::FnConverging(..)) => {\n+                span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n+             }\n+        }\n+    }\n+\n+    fn check_call_inputs(&self,\n+                         mir: &Mir<'tcx>,\n+                         term: &Terminator<'tcx>,\n+                         sig: &ty::FnSig<'tcx>,\n+                         args: &[Operand<'tcx>])\n+    {\n+        debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n+        if sig.inputs.len() > args.len() ||\n+           (sig.inputs.len() < args.len() && !sig.variadic) {\n+            span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n+        }\n+        for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n+            let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n+            if let Err(terr) = infer::can_mk_subty(self.infcx, op_arg_ty, fn_arg) {\n+                span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n+                             n, fn_arg, op_arg_ty, terr);\n+            }\n+        }\n+    }\n+\n+    fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n+        match operand {\n+            &Operand::Constant(Constant {\n+                literal: Literal::Item { def_id, .. }, ..\n+            }) => {\n+                Some(def_id) == self.tcx().lang_items.box_free_fn()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn check_box_free_inputs(&self,\n+                             mir: &Mir<'tcx>,\n+                             term: &Terminator<'tcx>,\n+                             sig: &ty::FnSig<'tcx>,\n+                             args: &[Operand<'tcx>])\n+    {\n+        debug!(\"check_box_free_inputs\");\n+\n+        // box_free takes a Box as a pointer. Allow for that.\n+\n+        if sig.inputs.len() != 1 {\n+            span_mirbug!(self, term, \"box_free should take 1 argument\");\n+            return;\n+        }\n+\n+        let pointee_ty = match sig.inputs[0].sty {\n+            ty::TyRawPtr(mt) => mt.ty,\n+            _ => {\n+                span_mirbug!(self, term, \"box_free should take a raw ptr\");\n+                return;\n+            }\n+        };\n+\n+        if args.len() != 1 {\n+            span_mirbug!(self, term, \"box_free called with wrong # of args\");\n+            return;\n+        }\n+\n+        let arg_ty = match mir.operand_ty(self.tcx(), &args[0]).sty {\n+            ty::TyRawPtr(mt) => mt.ty,\n+            ty::TyBox(ty) => ty,\n+            _ => {\n+                span_mirbug!(self, term, \"box_free called with bad arg ty\");\n+                return;\n+            }\n+        };\n+\n+        if let Err(terr) = infer::can_mk_subty(self.infcx, arg_ty, pointee_ty) {\n+            span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n+                         pointee_ty, arg_ty, terr);\n+        }\n+    }\n+\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+        self.last_span = mir.span;\n+        debug!(\"run_on_mir: {:?}\", mir.span);\n+        for block in &mir.basic_blocks {\n+            for stmt in &block.statements {\n+                if stmt.span != DUMMY_SP {\n+                    self.last_span = stmt.span;\n+                }\n+                self.check_stmt(mir, stmt);\n+            }\n+\n+            if let Some(ref terminator) = block.terminator {\n+                self.check_terminator(mir, terminator);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MirPass for TypeckMir<'a, 'tcx> {\n+    fn run_on_mir<'tcx_>(&mut self,\n+                         mir: &mut Mir<'tcx_>,\n+                         _tcx: &ty::ctxt<'tcx_>) {\n+        // FIXME: pass param_env to run_on_mir\n+        let mir: &mut Mir<'tcx> = unsafe { ::std::mem::transmute(mir) };\n+        let mut type_verifier = TypeVerifier::new(self.infcx, mir);\n+        type_verifier.visit_mir(mir);\n+\n+        if type_verifier.errors_reported {\n+            return;\n+        }\n+\n+        self.typeck_mir(mir);\n+    }\n+}"}]}