{"sha": "7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhM2ZkZmJmNjc0YTA4YjdmNmZkMzJjOTEyNGU1MjkyNGEyZjlhMWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-27T20:41:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-10T23:35:44Z"}, "message": "Remove morestack support\n\nThis commit removes all morestack support from the compiler which entails:\n\n* Segmented stacks are no longer emitted in codegen.\n* We no longer build or distribute libmorestack.a\n* The `stack_exhausted` lang item is no longer required\n\nThe only current use of the segmented stack support in LLVM is to detect stack\noverflow. This is no longer really required, however, because we already have\nguard pages for all threads and registered signal handlers watching for a\nsegfault on those pages (to print out a stack overflow message). Additionally,\nmajor platforms (aka Windows) already don't use morestack.\n\nThis means that Rust is by default less likely to catch stack overflows because\nif a function takes up more than one page of stack space it won't hit the guard\npage. This is what the purpose of morestack was (to catch this case), but it's\nbetter served with stack probes which have more cross platform support and no\nruntime support necessary. Until LLVM supports this for all platform it looks\nlike morestack isn't really buying us much.\n\ncc #16012 (still need stack probes)\nCloses #26458 (a drive-by fix to help diagnostics on stack overflow)", "tree": {"sha": "5553605e8d9ac7fc23cfec8f689f6c923e78abdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5553605e8d9ac7fc23cfec8f689f6c923e78abdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "html_url": "https://github.com/rust-lang/rust/commit/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03456183e85fe7bd465bbe7c8f67885a2528444", "url": "https://api.github.com/repos/rust-lang/rust/commits/d03456183e85fe7bd465bbe7c8f67885a2528444", "html_url": "https://github.com/rust-lang/rust/commit/d03456183e85fe7bd465bbe7c8f67885a2528444"}], "stats": {"total": 1820, "additions": 147, "deletions": 1673}, "files": [{"sha": "bb79e2186ae15ee27fa6029cbb6b69eb9940b2d3", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -101,7 +101,6 @@ define CLEAN_TARGET_STAGE_N\n clean$(1)_T_$(2)_H_$(3): \\\n \t    $$(foreach crate,$$(CRATES),clean$(1)_T_$(2)_H_$(3)-lib-$$(crate)) \\\n \t    $$(foreach tool,$$(TOOLS) $$(DEBUGGER_BIN_SCRIPTS_ALL),clean$(1)_T_$(2)_H_$(3)-tool-$$(tool))\n-\t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a\n \t$$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/librun_pass_stage* # For unix\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/run_pass_stage* # For windows"}, {"sha": "d7667bef788d820f98986bda52516d91793d71a4", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -65,7 +65,7 @@ DEPS_libc := core\n DEPS_rustc_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_std := core libc rand alloc collections rustc_unicode \\\n-\tnative:rust_builtin native:backtrace native:rustrt_native \\\n+\tnative:rust_builtin native:backtrace \\\n \trustc_bitflags\n DEPS_graphviz := std\n DEPS_syntax := std term serialize log fmt_macros arena libc"}, {"sha": "a65e09e15fd961214df54d0ad61a9eaa0c6b9273", "filename": "mk/main.mk", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -163,7 +163,7 @@ endif\n # that the snapshot will be generated with a statically linked rustc so we only\n # have to worry about the distribution of one file (with its native dynamic\n # dependencies)\n-RUSTFLAGS_STAGE0 += -C prefer-dynamic\n+RUSTFLAGS_STAGE0 += -C prefer-dynamic -C no-stack-check\n RUSTFLAGS_STAGE1 += -C prefer-dynamic\n RUST_LIB_FLAGS_ST2 += -C prefer-dynamic\n RUST_LIB_FLAGS_ST3 += -C prefer-dynamic\n@@ -400,6 +400,11 @@ TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(foreach obj,$$(INSTALLED_OBJECTS_$(2)),\\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj))\n \n+ifeq ($(1),0)\n+TSREQ$(1)_T_$(2)_H_$(3) += \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(call CFG_STATIC_LIB_NAME_$(2),morestack)\n+endif\n+\n # Prerequisites for a working stageN compiler and libraries, for a specific\n # target\n SREQ$(1)_T_$(2)_H_$(3) = \\"}, {"sha": "2802e5ee4a2196711a94522b38ce58ebcf5cae39", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -113,8 +113,7 @@ CFG_RLIB_GLOB=lib$(1)-*.rlib\n include $(wildcard $(CFG_SRC_DIR)mk/cfg/*.mk)\n \n define ADD_INSTALLED_OBJECTS\n-  INSTALLED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),morestack) \\\n-                            $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n+  INSTALLED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n endef\n \n $(foreach target,$(CFG_TARGET), \\"}, {"sha": "e505d78f0998e07cfbad3f08648e88ec331cb5c0", "filename": "mk/rt.mk", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -35,8 +35,8 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rust_builtin hoedown morestack miniz \\\n-\t\trustrt_native rust_test_helpers\n+NATIVE_LIBS := rust_builtin hoedown miniz \\\n+\t\trust_test_helpers morestack\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -53,10 +53,8 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n NATIVE_DEPS_miniz_$(1) = miniz.c\n NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n \t\t\trust_android_dummy.c\n-NATIVE_DEPS_rustrt_native_$(1) := arch/$$(HOST_$(1))/record_sp.S\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n-NATIVE_DEPS_morestack_$(1) := arch/$$(HOST_$(1))/morestack.S\n-\n+NATIVE_DEPS_morestack_$(1) := empty.c\n \n ################################################################################\n # You shouldn't find it that necessary to edit anything below this line."}, {"sha": "1af4a2f4694fecd461e88ed1869956bd5e055bb4", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -56,8 +56,7 @@ $(foreach host,$(CFG_HOST), \\\n #   1. The immediate dependencies are the rust source files\n #   2. Each rust crate dependency is listed (based on their stamp files),\n #      as well as all native dependencies (listed in RT_OUTPUT_DIR)\n-#   3. The stage (n-1) compiler is required through the TSREQ dependency, along\n-#      with the morestack library\n+#   3. The stage (n-1) compiler is required through the TSREQ dependency\n #   4. When actually executing the rule, the first thing we do is to clean out\n #      old libs and rlibs via the REMOVE_ALL_OLD_GLOB_MATCHES macro\n #   5. Finally, we get around to building the actual crate. It's just one"}, {"sha": "cd1cec7a5d0bae4d7155012552a86d1b81c53a01", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -51,7 +51,6 @@ fn main(argc: isize, argv: *const *const u8) -> isize {\n     0\n }\n \n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}"}, {"sha": "9abcd330989b4b85c12306356cdd79af5e442a0a", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -36,7 +36,6 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n // These functions and traits are used by the compiler, but not\n // for a bare-bones hello world. These are normally\n // provided by libstd.\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n@@ -61,7 +60,6 @@ pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n     0\n }\n \n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n@@ -73,18 +71,12 @@ The compiler currently makes a few assumptions about symbols which are available\n in the executable to call. Normally these functions are provided by the standard\n library, but without it you must define your own.\n \n-The first of these three functions, `stack_exhausted`, is invoked whenever stack\n-overflow is detected.  This function has a number of restrictions about how it\n-can be called and what it must do, but if the stack limit register is not being\n-maintained then a thread always has an \"infinite stack\" and this function\n-shouldn't get triggered.\n-\n-The second of these three functions, `eh_personality`, is used by the\n+The first of these two functions, `eh_personality`, is used by the\n failure mechanisms of the compiler. This is often mapped to GCC's\n personality function (see the\n [libstd implementation](../std/rt/unwind/index.html) for more\n information), but crates which do not trigger a panic can be assured\n-that this function is never called. The final function, `panic_fmt`, is\n+that this function is never called. The second function, `panic_fmt`, is\n also used by the failure mechanisms of the compiler.\n \n ## Using libcore\n@@ -150,7 +142,6 @@ extern fn panic_fmt(args: &core::fmt::Arguments,\n     loop {}\n }\n \n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }"}, {"sha": "78376779d5a8d3915f073d9b075c28df167913b4", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -347,7 +347,5 @@ lets_do_this! {\n \n     NonZeroItem,                     \"non_zero\",                non_zero;\n \n-    StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n-\n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n }"}, {"sha": "32b64f4c606ce5f863d4da1bbd866622539f109e", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -39,9 +39,6 @@ pub fn check_crate(krate: &ast::Crate,\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n     // so here.\n-    if items.stack_exhausted().is_none() {\n-        items.missing.push(lang_items::StackExhaustedLangItem);\n-    }\n     if items.eh_personality().is_none() {\n         items.missing.push(lang_items::EhPersonalityLangItem);\n     }\n@@ -124,7 +121,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n weak_lang_items! {\n     panic_fmt,          PanicFmtLangItem,           rust_begin_unwind;\n-    stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n     eh_unwind_resume,   EhUnwindResumeLangItem,     rust_eh_unwind_resume;\n }"}, {"sha": "a1cbf838d0af3df0f2d75f9aa9b784e599d0a0a6", "filename": "src/librustc_back/target/apple_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -19,7 +19,6 @@ pub fn opts() -> TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n         is_like_osx: true,\n-        morestack: true,\n         has_rpath: true,\n         dll_prefix: \"lib\".to_string(),\n         dll_suffix: \".dylib\".to_string(),"}, {"sha": "74c4183cfa3e63774da8cd15ed216cf83c1dce2e", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -87,14 +87,6 @@ pub fn opts(arch: Arch) -> TargetOptions {\n         cpu: target_cpu(arch),\n         dynamic_linking: false,\n         executables: true,\n-        // Although there is an experimental implementation of LLVM which\n-        // supports SS on armv7 it wasn't approved by Apple, see:\n-        // http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140505/216350.html\n-        // It looks like it might be never accepted to upstream LLVM.\n-        //\n-        // SS might be also enabled on Arm64 as it has builtin support in LLVM\n-        // but I haven't tested it through yet\n-        morestack: false,\n         pre_link_args: pre_link_args(arch),\n         .. super::apple_base::opts()\n     }"}, {"sha": "9e163f7b64f1624a68e9358d3b71c20eff64d97f", "filename": "src/librustc_back/target/bitrig_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fbitrig_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n         linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n-        morestack: false,\n         linker_is_gnu: true,\n         has_rpath: true,\n         position_independent_executables: true,"}, {"sha": "422aabd8c98539456a3fa9b95b91e38a636ec8ee", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n         linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n-        morestack: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!("}, {"sha": "28512ba08fa339ca9ad6a65f5b643c2b7d84eb7f", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n         linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n-        morestack: true,\n         has_rpath: true,\n         archive_format: \"gnu\".to_string(),\n "}, {"sha": "6b2d9b5053c4ae6ebff10b62b0ecbd16981ef790", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -14,7 +14,6 @@ pub fn target() -> Target {\n     let mut base = super::freebsd_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.pre_link_args.push(\"-m32\".to_string());\n-    base.morestack = false;\n \n     Target {\n         llvm_target: \"i686-unknown-freebsd\".to_string(),"}, {"sha": "a70cbc5797c68b8833f9135579527b69f77579ad", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -15,7 +15,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         dynamic_linking: true,\n         executables: true,\n-        morestack: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!["}, {"sha": "7ca46a1d169ca2ba3a40dad1f4c03c02840f3783", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -118,9 +118,6 @@ pub struct TargetOptions {\n     /// Whether executables are available on this target. iOS, for example, only allows static\n     /// libraries. Defaults to false.\n     pub executables: bool,\n-    /// Whether LLVM's segmented stack prelude is supported by whatever runtime is available.\n-    /// Will emit stack checks and calls to __morestack. Defaults to false.\n-    pub morestack: bool,\n     /// Relocation model to use in object file. Corresponds to `llc\n     /// -relocation-model=$relocation_model`. Defaults to \"pic\".\n     pub relocation_model: String,\n@@ -192,7 +189,6 @@ impl Default for TargetOptions {\n             features: \"\".to_string(),\n             dynamic_linking: false,\n             executables: false,\n-            morestack: false,\n             relocation_model: \"pic\".to_string(),\n             code_model: \"default\".to_string(),\n             disable_redzone: false,\n@@ -298,7 +294,6 @@ impl Target {\n         key!(data_layout);\n         key!(dynamic_linking, bool);\n         key!(executables, bool);\n-        key!(morestack, bool);\n         key!(disable_redzone, bool);\n         key!(eliminate_frame_pointer, bool);\n         key!(function_sections, bool);"}, {"sha": "575f5c08726e9f64f527f03cfe7db98157d8ca6b", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n         linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n-        morestack: false,\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!("}, {"sha": "361f71f69959197ddf580c0a6a64a6508c688571", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,7 +16,6 @@ pub fn opts() -> TargetOptions {\n         linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n-        morestack: false,\n         linker_is_gnu: true,\n         has_rpath: true,\n         pre_link_args: vec!("}, {"sha": "d2217f902eac8f3d14969b3ef3b39458182b3796", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -23,7 +23,6 @@ pub fn opts() -> TargetOptions {\n         exe_suffix: \".exe\".to_string(),\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n-        morestack: false,\n         is_like_windows: true,\n         archive_format: \"gnu\".to_string(),\n         pre_link_args: vec!("}, {"sha": "bdc60cbc1ba664449947177eb9e94fdf5df087ba", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -53,7 +53,6 @@ pub fn opts() -> TargetOptions {\n         exe_suffix: \".exe\".to_string(),\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n-        morestack: false,\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: vec!["}, {"sha": "3ab557bc1eb68cb3ba45eb2bc7f707c08fea812e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -759,9 +759,6 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n     if sess.target.target.options.is_like_osx && !ab.using_llvm() {\n         ab.build();\n     }\n-    if sess.target.target.options.morestack {\n-        ab.add_native_library(\"morestack\").unwrap();\n-    }\n     if !sess.target.target.options.no_compiler_rt {\n         ab.add_native_library(\"compiler-rt\").unwrap();\n     }\n@@ -905,26 +902,6 @@ fn link_args(cmd: &mut Linker,\n     }\n     cmd.output_filename(out_filename);\n \n-    // Stack growth requires statically linking a __morestack function. Note\n-    // that this is listed *before* all other libraries. Due to the usage of the\n-    // --as-needed flag below, the standard library may only be useful for its\n-    // rust_stack_exhausted function. In this case, we must ensure that the\n-    // libmorestack.a file appears *before* the standard library (so we put it\n-    // at the very front).\n-    //\n-    // Most of the time this is sufficient, except for when LLVM gets super\n-    // clever. If, for example, we have a main function `fn main() {}`, LLVM\n-    // will optimize out calls to `__morestack` entirely because the function\n-    // doesn't need any stack at all!\n-    //\n-    // To get around this snag, we specially tell the linker to always include\n-    // all contents of this library. This way we're guaranteed that the linker\n-    // will include the __morestack symbol 100% of the time, always resolving\n-    // references to it even if the object above didn't use it.\n-    if t.options.morestack {\n-        cmd.link_whole_staticlib(\"morestack\", &[lib_path]);\n-    }\n-\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here."}, {"sha": "8db271bfe0397e4f77759d222323dfdd7f6f8f58", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -23,19 +23,6 @@ use trans::context::CrateContext;\n use trans::machine;\n use trans::type_of;\n \n-/// Mark LLVM function to use split stack.\n-#[inline]\n-pub fn split_stack(val: ValueRef, set: bool) {\n-    unsafe {\n-        let attr = \"split-stack\\0\".as_ptr() as *const _;\n-        if set {\n-            llvm::LLVMAddFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n-        } else {\n-            llvm::LLVMRemoveFunctionAttrString(val, llvm::FunctionIndex as c_uint, attr);\n-        }\n-    }\n-}\n-\n /// Mark LLVM function to use provided inline heuristic.\n #[inline]\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n@@ -123,9 +110,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n     }\n \n     for attr in attrs {\n-        if attr.check_name(\"no_stack_check\") {\n-            split_stack(llfn, false);\n-        } else if attr.check_name(\"cold\") {\n+        if attr.check_name(\"cold\") {\n             unsafe {\n                 llvm::LLVMAddFunctionAttribute(llfn,\n                                                llvm::FunctionIndex as c_uint,"}, {"sha": "cb02b619056082a935692e27269be6978c19a3b8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -2173,17 +2173,8 @@ fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n \n-    // The stack exhaustion lang item shouldn't have a split stack because\n-    // otherwise it would continue to be exhausted (bad), and both it and the\n-    // eh_personality functions need to be externally linkable.\n+    // The eh_personality function need to be externally linkable.\n     let def = ast_util::local_def(node_id);\n-    if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n-        attributes::split_stack(llfn, false);\n-        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n-        if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-    }\n     if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n         if ccx.use_dll_storage_attrs() {\n@@ -2801,13 +2792,8 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n     });\n \n     // Make sure that some other crucial symbols are not eliminated from the\n-    // module. This includes the main function, the crate map (used for debug\n-    // log settings and I/O), and finally the curious rust_stack_exhausted\n-    // symbol. This symbol is required for use by the libmorestack library that\n-    // we link in, so we must ensure that this symbol is not internalized (if\n-    // defined in the crate).\n+    // module, including the main function.\n     reachable.push(\"main\".to_string());\n-    reachable.push(\"rust_stack_exhausted\".to_string());\n \n     // referenced from .eh_frame section on some platforms\n     reachable.push(\"rust_eh_personality\".to_string());"}, {"sha": "79f01c2f137f1f3cddd8e748b6e497a3c4f43177", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -570,11 +570,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn is_split_stack_supported(&self) -> bool {\n-        self.sess().target.target.options.morestack\n-    }\n-\n-\n     pub fn llmod(&self) -> ModuleRef {\n         self.local.llmod\n     }"}, {"sha": "ee1d4ed47d7c1b14ea8fcb8337895c0051d50b12", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -79,9 +79,6 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n     }\n \n-    if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {\n-        attributes::split_stack(llfn, true);\n-    }\n     llfn\n }\n "}, {"sha": "24a4575aa54138394176996f4bf97dd3e814bf04", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -23,7 +23,7 @@\n \n use prelude::v1::*;\n use sys;\n-use usize;\n+use thread;\n \n // Reexport some of our utilities which are expected by other crates.\n pub use self::util::min_stack;\n@@ -53,11 +53,6 @@ mod dwarf;\n /// of exiting cleanly.\n pub const DEFAULT_ERROR_CODE: isize = 101;\n \n-#[cfg(any(windows, android))]\n-const OS_DEFAULT_STACK_ESTIMATE: usize = 1 << 20;\n-#[cfg(all(unix, not(android)))]\n-const OS_DEFAULT_STACK_ESTIMATE: usize = 2 * (1 << 20);\n-\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n@@ -67,37 +62,9 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     use env;\n     use rt;\n     use sys_common::thread_info::{self, NewThread};\n-    use sys_common;\n     use thread::Thread;\n \n-    let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *const _ as *const isize;\n-    let my_stack_top = addr as usize;\n-\n-    // FIXME #11359 we just assume that this thread has a stack of a\n-    // certain size, and estimate that there's at most 20KB of stack\n-    // frames above our current position.\n-    const TWENTY_KB: usize = 20000;\n-\n-    // saturating-add to sidestep overflow\n-    let top_plus_spill = if usize::MAX - TWENTY_KB < my_stack_top {\n-        usize::MAX\n-    } else {\n-        my_stack_top + TWENTY_KB\n-    };\n-    // saturating-sub to sidestep underflow\n-    let my_stack_bottom = if top_plus_spill < OS_DEFAULT_STACK_ESTIMATE {\n-        0\n-    } else {\n-        top_plus_spill - OS_DEFAULT_STACK_ESTIMATE\n-    };\n-\n     let failed = unsafe {\n-        // First, make sure we don't trigger any __morestack overflow checks,\n-        // and next set up our stack to have a guard page and run through our\n-        // own fault handlers if we hit it.\n-        sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom,\n-                                                          my_stack_top);\n         let main_guard = sys::thread::guard::init();\n         sys::stack_overflow::init();\n \n@@ -129,10 +96,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         args::init(argc, argv);\n \n         // And finally, let's run some code!\n-        let res = unwind::try(|| {\n-            let main: fn() = mem::transmute(main);\n-            main();\n-        });\n+        let res = thread::catch_panic(mem::transmute::<_, fn()>(main));\n         cleanup();\n         res.is_err()\n     };"}, {"sha": "bb43eec8db1c94bc84969b2e525299a015d51a21", "filename": "src/libstd/rt/unwind/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -111,10 +111,6 @@ static CALLBACK_CNT: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n \n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n-#[link(name = \"rustrt_native\", kind = \"static\")]\n-#[cfg(not(test))]\n-extern {}\n-\n /// Invoke a closure, capturing the cause of panic if one occurs.\n ///\n /// This function will return `Ok(())` if the closure did not panic, and will"}, {"sha": "d63b66c42c7a85a457a3df084baeb8640b0fe8ca", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -21,7 +21,6 @@ pub mod io;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;\n-pub mod stack;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local;\n@@ -52,3 +51,7 @@ pub trait IntoInner<Inner> {\n pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n+\n+#[cfg(stage0)]\n+#[lang = \"stack_exhausted\"]\n+pub fn stack_exhausted() {}"}, {"sha": "41c8ac4aed30d1653b74f4acf3bcd9a5d1827022", "filename": "src/libstd/sys/common/stack.rs", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rust stack-limit management\n-//!\n-//! Currently Rust uses a segmented-stack-like scheme in order to detect stack\n-//! overflow for rust threads. In this scheme, the prologue of all functions are\n-//! preceded with a check to see whether the current stack limits are being\n-//! exceeded.\n-//!\n-//! This module provides the functionality necessary in order to manage these\n-//! stack limits (which are stored in platform-specific locations). The\n-//! functions here are used at the borders of the thread lifetime in order to\n-//! manage these limits.\n-//!\n-//! This function is an unstable module because this scheme for stack overflow\n-//! detection is not guaranteed to continue in the future. Usage of this module\n-//! is discouraged unless absolutely necessary.\n-\n-// iOS related notes\n-//\n-// It is possible to implement it using idea from\n-// http://www.opensource.apple.com/source/Libc/Libc-825.40.1/pthreads/pthread_machdep.h\n-//\n-// In short: _pthread_{get,set}_specific_direct allows extremely fast\n-// access, exactly what is required for segmented stack\n-// There is a pool of reserved slots for Apple internal use (0..119)\n-// First dynamic allocated pthread key starts with 257 (on iOS7)\n-// So using slot 149 should be pretty safe ASSUMING space is reserved\n-// for every key < first dynamic key\n-//\n-// There is also an opportunity to steal keys reserved for Garbage Collection\n-// ranges 80..89 and 110..119, especially considering the fact Garbage Collection\n-// never supposed to work on iOS. But as everybody knows it - there is a chance\n-// that those slots will be re-used, like it happened with key 95 (moved from\n-// JavaScriptCore to CoreText)\n-//\n-// Unfortunately Apple rejected patch to LLVM which generated\n-// corresponding prolog, decision was taken to disable segmented\n-// stack support on iOS.\n-\n-pub const RED_ZONE: usize = 20 * 1024;\n-\n-/// This function is invoked from rust's current __morestack function. Segmented\n-/// stacks are currently not enabled as segmented stacks, but rather one giant\n-/// stack segment. This means that whenever we run out of stack, we want to\n-/// truly consider it to be stack overflow rather than allocating a new stack.\n-#[cfg(not(test))] // in testing, use the original libstd's version\n-#[lang = \"stack_exhausted\"]\n-extern fn stack_exhausted() {\n-    use intrinsics;\n-\n-    unsafe {\n-        // We're calling this function because the stack just ran out. We need\n-        // to call some other rust functions, but if we invoke the functions\n-        // right now it'll just trigger this handler being called again. In\n-        // order to alleviate this, we move the stack limit to be inside of the\n-        // red zone that was allocated for exactly this reason.\n-        let limit = get_sp_limit();\n-        record_sp_limit(limit - RED_ZONE / 2);\n-\n-        // This probably isn't the best course of action. Ideally one would want\n-        // to unwind the stack here instead of just aborting the entire process.\n-        // This is a tricky problem, however. There's a few things which need to\n-        // be considered:\n-        //\n-        //  1. We're here because of a stack overflow, yet unwinding will run\n-        //     destructors and hence arbitrary code. What if that code overflows\n-        //     the stack? One possibility is to use the above allocation of an\n-        //     extra 10k to hope that we don't hit the limit, and if we do then\n-        //     abort the whole program. Not the best, but kind of hard to deal\n-        //     with unless we want to switch stacks.\n-        //\n-        //  2. LLVM will optimize functions based on whether they can unwind or\n-        //     not. It will flag functions with 'nounwind' if it believes that\n-        //     the function cannot trigger unwinding, but if we do unwind on\n-        //     stack overflow then it means that we could unwind in any function\n-        //     anywhere. We would have to make sure that LLVM only places the\n-        //     nounwind flag on functions which don't call any other functions.\n-        //\n-        //  3. The function that overflowed may have owned arguments. These\n-        //     arguments need to have their destructors run, but we haven't even\n-        //     begun executing the function yet, so unwinding will not run the\n-        //     any landing pads for these functions. If this is ignored, then\n-        //     the arguments will just be leaked.\n-        //\n-        // Exactly what to do here is a very delicate topic, and is possibly\n-        // still up in the air for what exactly to do. Some relevant issues:\n-        //\n-        //  #3555 - out-of-stack failure leaks arguments\n-        //  #3695 - should there be a stack limit?\n-        //  #9855 - possible strategies which could be taken\n-        //  #9854 - unwinding on windows through __morestack has never worked\n-        //  #2361 - possible implementation of not using landing pads\n-\n-        ::rt::util::report_overflow();\n-\n-        intrinsics::abort();\n-    }\n-}\n-\n-// Windows maintains a record of upper and lower stack bounds in the Thread Information\n-// Block (TIB), and some syscalls do check that addresses which are supposed to be in\n-// the stack, indeed lie between these two values.\n-// (See https://github.com/rust-lang/rust/issues/3445#issuecomment-26114839)\n-//\n-// When using Rust-managed stacks (libgreen), we must maintain these values accordingly.\n-// For OS-managed stacks (libnative), we let the OS manage them for us.\n-//\n-// On all other platforms both variants behave identically.\n-\n-#[inline(always)]\n-pub unsafe fn record_os_managed_stack_bounds(stack_lo: usize, _stack_hi: usize) {\n-    record_sp_limit(stack_lo + RED_ZONE);\n-}\n-\n-/// Records the current limit of the stack as specified by `end`.\n-///\n-/// This is stored in an OS-dependent location, likely inside of the thread\n-/// local storage. The location that the limit is stored is a pre-ordained\n-/// location because it's where LLVM has emitted code to check.\n-///\n-/// Note that this cannot be called under normal circumstances. This function is\n-/// changing the stack limit, so upon returning any further function calls will\n-/// possibly be triggering the morestack logic if you're not careful.\n-///\n-/// Also note that this and all of the inside functions are all flagged as\n-/// \"inline(always)\" because they're messing around with the stack limits.  This\n-/// would be unfortunate for the functions themselves to trigger a morestack\n-/// invocation (if they were an actual function call).\n-#[inline(always)]\n-pub unsafe fn record_sp_limit(limit: usize) {\n-    return target_record_sp_limit(limit);\n-\n-    #[cfg(all(target_arch = \"x86_64\",\n-              any(target_os = \"macos\", target_os = \"ios\")))]\n-    #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movq $$0x60+90*8, %rsi\n-              movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(_: usize) {\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))]\n-    #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movq $0, %fs:32\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-\n-    #[cfg(all(target_arch = \"x86\",\n-              any(target_os = \"macos\", target_os = \"ios\")))]\n-    #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movl $$0x48+90*4, %eax\n-              movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n-    }\n-    #[cfg(all(target_arch = \"x86\", target_os = \"linux\"))]\n-    #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n-    }\n-    #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(_: usize) {\n-    }\n-\n-    // mips, arm - The implementations are a bit big for inline asm!\n-    //             They can be found in src/rt/arch/$target_arch/record_sp.S\n-    #[cfg(any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n-    #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: usize) {\n-        use libc::c_void;\n-        return record_sp_limit(limit as *const c_void);\n-        extern {\n-            fn record_sp_limit(limit: *const c_void);\n-        }\n-    }\n-\n-    // aarch64 - FIXME(AARCH64): missing...\n-    // powerpc - FIXME(POWERPC): missing...\n-    // arm-ios - iOS segmented stack is disabled for now, see related notes\n-    // openbsd/bitrig/netbsd - no segmented stacks.\n-    // x86-freebsd - no segmented stacks.\n-    #[cfg(any(target_arch = \"aarch64\",\n-              target_arch = \"powerpc\",\n-              all(target_arch = \"arm\", target_os = \"ios\"),\n-              all(target_arch = \"x86\", target_os = \"freebsd\"),\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\"))]\n-    unsafe fn target_record_sp_limit(_: usize) {\n-    }\n-}\n-\n-/// The counterpart of the function above, this function will fetch the current\n-/// stack limit stored in TLS.\n-///\n-/// Note that all of these functions are meant to be exact counterparts of their\n-/// brethren above, except that the operands are reversed.\n-///\n-/// As with the setter, this function does not have a __morestack header and can\n-/// therefore be called in a \"we're out of stack\" situation.\n-#[inline(always)]\n-pub unsafe fn get_sp_limit() -> usize {\n-    return target_get_sp_limit();\n-\n-    #[cfg(all(target_arch = \"x86_64\",\n-              any(target_os = \"macos\", target_os = \"ios\")))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movq $$0x60+90*8, %rsi\n-              movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        return 1024;\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movq %fs:32, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-\n-    #[cfg(all(target_arch = \"x86\",\n-              any(target_os = \"macos\", target_os = \"ios\")))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movl $$0x48+90*4, %eax\n-              movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(all(target_arch = \"x86\", target_os = \"linux\"))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        let limit;\n-        asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n-        return limit;\n-    }\n-    #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        return 1024;\n-    }\n-\n-    // mips, arm - The implementations are a bit big for inline asm!\n-    //             They can be found in src/rt/arch/$target_arch/record_sp.S\n-    #[cfg(any(target_arch = \"mips\",\n-              target_arch = \"mipsel\",\n-              all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        use libc::c_void;\n-        return get_sp_limit() as usize;\n-        extern {\n-            fn get_sp_limit() -> *const c_void;\n-        }\n-    }\n-\n-    // aarch64 - FIXME(AARCH64): missing...\n-    // powerpc - FIXME(POWERPC): missing...\n-    // arm-ios - no segmented stacks.\n-    // openbsd/bitrig/netbsd - no segmented stacks.\n-    // x86-freebsd - no segmented stacks..\n-    //\n-    // This function might be called by runtime though\n-    // so it is unsafe to unreachable, let's return a fixed constant.\n-    #[cfg(any(target_arch = \"aarch64\",\n-              target_arch = \"powerpc\",\n-              all(target_arch = \"arm\", target_os = \"ios\"),\n-              all(target_arch = \"x86\", target_os = \"freebsd\"),\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\"))]\n-    #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> usize {\n-        1024\n-    }\n-}"}, {"sha": "16f4f01bf39fe9b058fb03817dac3821dd480b19", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -13,15 +13,8 @@ use prelude::v1::*;\n use alloc::boxed::FnBox;\n use libc;\n use sys::stack_overflow;\n-use sys_common::stack;\n-use usize;\n \n-#[no_stack_check]\n pub unsafe fn start_thread(main: *mut libc::c_void) {\n-    // First ensure that we don't trigger __morestack (also why this has a\n-    // no_stack_check annotation).\n-    stack::record_os_managed_stack_bounds(0, usize::MAX);\n-\n     // Next, set up our stack overflow handler which may get triggered if we run\n     // out of stack.\n     let _handler = stack_overflow::Handler::new();"}, {"sha": "4e4cf2b0ed1a077d4ff2716d2e229323efd60b59", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -40,72 +40,66 @@ impl Drop for Handler {\n           target_os = \"netbsd\",\n           target_os = \"openbsd\"))]\n mod imp {\n-    use sys_common::stack;\n-\n     use super::Handler;\n     use rt::util::report_overflow;\n     use mem;\n     use ptr;\n-    use intrinsics;\n     use sys::c::{siginfo, sigaction, SIGBUS, SIG_DFL,\n                  SA_SIGINFO, SA_ONSTACK, sigaltstack,\n-                 SIGSTKSZ, sighandler_t, raise};\n+                 SIGSTKSZ, sighandler_t};\n     use libc;\n     use libc::funcs::posix88::mman::{mmap, munmap};\n-    use libc::funcs::posix01::signal::signal;\n-    use libc::consts::os::posix88::{SIGSEGV,\n-                                    PROT_READ,\n-                                    PROT_WRITE,\n-                                    MAP_PRIVATE,\n-                                    MAP_ANON,\n-                                    MAP_FAILED};\n+    use libc::{SIGSEGV, PROT_READ, PROT_WRITE, MAP_PRIVATE, MAP_ANON};\n+    use libc::MAP_FAILED;\n \n     use sys_common::thread_info;\n \n \n     // This is initialized in init() and only read from after\n     static mut PAGE_SIZE: usize = 0;\n \n-    #[no_stack_check]\n+    // Signal handler for the SIGSEGV and SIGBUS handlers. We've got guard pages\n+    // (unmapped pages) at the end of every thread's stack, so if a thread ends\n+    // up running into the guard page it'll trigger this handler. We want to\n+    // detect these cases and print out a helpful error saying that the stack\n+    // has overflowed. All other signals, however, should go back to what they\n+    // were originally supposed to do.\n+    //\n+    // This handler currently exists purely to print an informative message\n+    // whenever a thread overflows its stack. When run the handler always\n+    // un-registers itself after running and then returns (to allow the original\n+    // signal to be delivered again). By returning we're ensuring that segfaults\n+    // do indeed look like segfaults.\n+    //\n+    // Returning from this kind of signal handler is technically not defined to\n+    // work when reading the POSIX spec strictly, but in practice it turns out\n+    // many large systems and all implementations allow returning from a signal\n+    // handler to work. For a more detailed explanation see the comments on\n+    // #26458.\n     unsafe extern fn signal_handler(signum: libc::c_int,\n-                                     info: *mut siginfo,\n-                                     _data: *mut libc::c_void) {\n-\n-        // We can not return from a SIGSEGV or SIGBUS signal.\n-        // See: https://www.gnu.org/software/libc/manual/html_node/Handler-Returns.html\n-\n-        unsafe fn term(signum: libc::c_int) -> ! {\n-            use core::mem::transmute;\n-\n-            signal(signum, transmute(SIG_DFL));\n-            raise(signum);\n-            intrinsics::abort();\n-        }\n-\n-        // We're calling into functions with stack checks\n-        stack::record_sp_limit(0);\n-\n+                                    info: *mut siginfo,\n+                                    _data: *mut libc::c_void) {\n         let guard = thread_info::stack_guard().unwrap_or(0);\n         let addr = (*info).si_addr as usize;\n \n-        if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n-            term(signum);\n+        // If the faulting address is within the guard page, then we print a\n+        // message saying so.\n+        if guard != 0 && guard - PAGE_SIZE <= addr && addr < guard {\n+            report_overflow();\n         }\n \n-        report_overflow();\n+        // Unregister ourselves by reverting back to the default behavior.\n+        let mut action: sigaction = mem::zeroed();\n+        action.sa_sigaction = SIG_DFL;\n+        sigaction(signum, &action, ptr::null_mut());\n \n-        intrinsics::abort()\n+        // See comment above for why this function returns.\n     }\n \n     static mut MAIN_ALTSTACK: *mut libc::c_void = 0 as *mut libc::c_void;\n \n     pub unsafe fn init() {\n-        let psize = libc::sysconf(libc::consts::os::sysconf::_SC_PAGESIZE);\n-        if psize == -1 {\n-            panic!(\"failed to get page size\");\n-        }\n-\n-        PAGE_SIZE = psize as usize;\n+        PAGE_SIZE = ::sys::os::page_size();\n \n         let mut action: sigaction = mem::zeroed();\n         action.sa_flags = SA_SIGINFO | SA_ONSTACK;"}, {"sha": "ea1bfbd9b7d71156d26449b9b2706b8af1b12642", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -23,7 +23,6 @@ use ptr;\n use sys::os;\n use time::Duration;\n \n-use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n \n pub struct Thread {\n@@ -43,8 +42,7 @@ impl Thread {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(pthread_attr_init(&mut attr), 0);\n \n-        // Reserve room for the red zone, the runtime's stack of last resort.\n-        let stack_size = cmp::max(stack, RED_ZONE + min_stack_size(&attr));\n+        let stack_size = cmp::max(stack, min_stack_size(&attr));\n         match pthread_attr_setstacksize(&mut attr, stack_size as libc::size_t) {\n             0 => {}\n             n => {\n@@ -72,7 +70,6 @@ impl Thread {\n             Ok(Thread { id: native })\n         };\n \n-        #[no_stack_check]\n         extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe { start_thread(main); }\n             0 as *mut _"}, {"sha": "8fb03ae79022d1127909dc989dd16c29b1d3b4a7", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -78,6 +78,10 @@ pub const PROGRESS_QUIET: libc::DWORD = 3;\n pub const TOKEN_ADJUST_PRIVILEGES: libc::DWORD = 0x0020;\n pub const SE_PRIVILEGE_ENABLED: libc::DWORD = 2;\n \n+pub const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n+pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n+pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -327,6 +331,24 @@ pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n     pub ReparseTarget: libc::WCHAR,\n }\n \n+#[repr(C)]\n+pub struct EXCEPTION_RECORD {\n+    pub ExceptionCode: DWORD,\n+    pub ExceptionFlags: DWORD,\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ExceptionAddress: LPVOID,\n+    pub NumberParameters: DWORD,\n+    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+}\n+\n+#[repr(C)]\n+pub struct EXCEPTION_POINTERS {\n+    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n+    pub ContextRecord: LPVOID\n+}\n+\n+pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n+        fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n \n #[link(name = \"ws2_32\")]\n #[link(name = \"userenv\")]\n@@ -487,6 +509,9 @@ extern \"system\" {\n                                  BufferLength: libc::DWORD,\n                                  PreviousState: PTOKEN_PRIVILEGES,\n                                  ReturnLength: *mut libc::DWORD) -> libc::BOOL;\n+    pub fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n+                                       VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n+                                       -> LPVOID;\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "f93f7c756deff5811005f0394e90d06026bae77d", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 19, "deletions": 83, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -8,108 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(stage0)]\n-use core::prelude::v1::*;\n-\n-use libc::types::os::arch::extra::{LPVOID, DWORD, LONG};\n-use libc;\n-use mem;\n-use ptr;\n+use libc::{self, LONG};\n use rt::util::report_overflow;\n use sys::c;\n-use sys_common::stack;\n \n-pub struct Handler {\n-    _data: *mut libc::c_void\n-}\n+pub struct Handler;\n \n impl Handler {\n     pub unsafe fn new() -> Handler {\n-        make_handler()\n+        // This API isn't available on XP, so don't panic in that case and just\n+        // pray it works out ok.\n+        if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+            if libc::GetLastError() as u32 != libc::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n+                panic!(\"failed to reserve stack space for exception handling\");\n+            }\n+        }\n+        Handler\n     }\n }\n \n-impl Drop for Handler {\n-    fn drop(&mut self) {}\n-}\n-\n-// This is initialized in init() and only read from after\n-static mut PAGE_SIZE: usize = 0;\n-\n-#[no_stack_check]\n-extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n+extern \"system\" fn vectored_handler(ExceptionInfo: *mut c::EXCEPTION_POINTERS)\n+                                    -> LONG {\n     unsafe {\n         let rec = &(*(*ExceptionInfo).ExceptionRecord);\n         let code = rec.ExceptionCode;\n \n-        if code != EXCEPTION_STACK_OVERFLOW {\n-            return EXCEPTION_CONTINUE_SEARCH;\n+        if code == c::EXCEPTION_STACK_OVERFLOW {\n+            report_overflow();\n         }\n-\n-        // We're calling into functions with stack checks,\n-        // however stack checks by limit should be disabled on Windows\n-        stack::record_sp_limit(0);\n-\n-        report_overflow();\n-\n-        EXCEPTION_CONTINUE_SEARCH\n+        c::EXCEPTION_CONTINUE_SEARCH\n     }\n }\n \n pub unsafe fn init() {\n-    let mut info = mem::zeroed();\n-    libc::GetSystemInfo(&mut info);\n-    PAGE_SIZE = info.dwPageSize as usize;\n-\n-    if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n+    if c::AddVectoredExceptionHandler(0, vectored_handler).is_null() {\n         panic!(\"failed to install exception handler\");\n     }\n-\n-    mem::forget(make_handler());\n-}\n-\n-pub unsafe fn cleanup() {\n-}\n-\n-pub unsafe fn make_handler() -> Handler {\n-    // This API isn't available on XP, so don't panic in that case and just pray\n-    // it works out ok.\n-    if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-        if libc::GetLastError() as u32 != libc::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n-            panic!(\"failed to reserve stack space for exception handling\");\n-        }\n-    }\n-\n-    Handler { _data: 0 as *mut libc::c_void }\n-}\n-\n-#[repr(C)]\n-pub struct EXCEPTION_RECORD {\n-    pub ExceptionCode: DWORD,\n-    pub ExceptionFlags: DWORD,\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ExceptionAddress: LPVOID,\n-    pub NumberParameters: DWORD,\n-    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS]\n+    // Set the thread stack guarantee for the main thread.\n+    let _h = Handler::new();\n }\n \n-#[repr(C)]\n-pub struct EXCEPTION_POINTERS {\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ContextRecord: LPVOID\n-}\n-\n-pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n-        fn(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG;\n-\n-pub type ULONG = libc::c_ulong;\n-\n-const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n-\n-extern \"system\" {\n-    fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n-                                   VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n-                                  -> LPVOID;\n-}\n+pub unsafe fn cleanup() {}"}, {"sha": "a9d094375b28f5087de725f5f20169d4d2913c8c", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -11,14 +11,12 @@\n use prelude::v1::*;\n \n use alloc::boxed::FnBox;\n-use cmp;\n use io;\n use libc::{self, c_void, DWORD};\n use mem;\n use ptr;\n use sys::c;\n use sys::handle::Handle;\n-use sys_common::stack::RED_ZONE;\n use sys_common::thread::*;\n use time::Duration;\n \n@@ -36,11 +34,9 @@ impl Thread {\n         // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n         // just that below a certain threshold you can't do anything useful.\n         // That threshold is application and architecture-specific, however.\n-        // For now, the only requirement is that it's big enough to hold the\n-        // red zone.  Round up to the next 64 kB because that's what the NT\n-        // kernel does, might as well make it explicit.  With the current\n-        // 20 kB red zone, that makes for a 64 kB minimum stack.\n-        let stack_size = (cmp::max(stack, RED_ZONE) + 0xfffe) & (-0xfffe - 1);\n+        // Round up to the next 64 kB because that's what the NT kernel does,\n+        // might as well make it explicit.\n+        let stack_size = (stack + 0xfffe) & (!0xfffe);\n         let ret = c::CreateThread(ptr::null_mut(), stack_size as libc::size_t,\n                                   thread_start, &*p as *const _ as *mut _,\n                                   0, ptr::null_mut());\n@@ -52,7 +48,6 @@ impl Thread {\n             Ok(Thread { handle: Handle::new(ret) })\n         };\n \n-        #[no_stack_check]\n         extern \"system\" fn thread_start(main: *mut libc::c_void) -> DWORD {\n             unsafe { start_thread(main); }\n             0"}, {"sha": "89a51391624689cc9d74c79028317b034c4963bc", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -171,7 +171,7 @@ use marker::PhantomData;\n use rt::{self, unwind};\n use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n-use sys_common::{stack, thread_info};\n+use sys_common::thread_info;\n use time::Duration;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -298,24 +298,11 @@ impl Builder {\n         let my_packet = Arc::new(UnsafeCell::new(None));\n         let their_packet = my_packet.clone();\n \n-        // Spawning a new OS thread guarantees that __morestack will never get\n-        // triggered, but we must manually set up the actual stack bounds once\n-        // this function starts executing. This raises the lower limit by a bit\n-        // because by the time that this function is executing we've already\n-        // consumed at least a little bit of stack (we don't know the exact byte\n-        // address at which our stack started).\n         let main = move || {\n-            let something_around_the_top_of_the_stack = 1;\n-            let addr = &something_around_the_top_of_the_stack as *const i32;\n-            let my_stack_top = addr as usize;\n-            let my_stack_bottom = my_stack_top - stack_size + 1024;\n-            stack::record_os_managed_stack_bounds(my_stack_bottom, my_stack_top);\n-\n             if let Some(name) = their_thread.name() {\n                 imp::Thread::set_name(name);\n             }\n             thread_info::set(imp::guard::current(), their_thread);\n-\n             let mut output = None;\n             let try_result = {\n                 let ptr = &mut output;"}, {"sha": "26349c69d3e76e71218a5faff84293f9accb8cb8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -222,6 +222,9 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"link_args\", Normal),\n     (\"macro_escape\", Normal),\n \n+    // Not used any more, but we can't feature gate it\n+    (\"no_stack_check\", Normal),\n+\n     (\"staged_api\", Gated(\"staged_api\",\n                          \"staged_api is for use by rustc only\")),\n     (\"plugin\", Gated(\"plugin\",\n@@ -276,7 +279,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"link_section\", Whitelisted),\n     (\"no_builtins\", Whitelisted),\n     (\"no_mangle\", Whitelisted),\n-    (\"no_stack_check\", Whitelisted),\n     (\"no_debug\", Whitelisted),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted),\n     (\"unsafe_no_drop_flag\", Gated(\"unsafe_no_drop_flag\","}, {"sha": "ae42a5d22433ce0b3c59e25aa43ab5f0aa70cbb5", "filename": "src/rt/arch/aarch64/macros.S", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Fmacros.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Fmacros.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Faarch64%2Fmacros.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,11 +0,0 @@\n-.macro\tfunc _name\n-\t.text\n-\t.align\t2\n-\t.globl\t\\_name\n-\t.type\t\\_name, %function\n-\\_name:\n-.endm\n-\n-.macro\tendfunc _name\n-\t.size\t\\_name, .-\\_name\n-.endm"}, {"sha": "8b7366ebed431e0bc16afe6a99f68a34126c2c67", "filename": "src/rt/arch/aarch64/morestack.S", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Faarch64%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,39 +0,0 @@\n-#include \"macros.S\"\n-\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-#if defined(__APPLE__)\n-#define MORESTACK ___morestack\n-#define STACK_EXHAUSTED _rust_stack_exhausted@plt\n-#else\n-#define MORESTACK __morestack\n-#define STACK_EXHAUSTED rust_stack_exhausted\n-#endif\n-\n-.global STACK_EXHAUSTED\n-\n-#if defined(__APPLE__)\n-.private_extern MORESTACK\n-#else\n-.hidden MORESTACK\n-#endif\n-\n-#if !defined(__APPLE__)\n-func MORESTACK\n-#endif\n-\n-// FIXME(AARCH64): this might not be perfectly right but works for now\n-MORESTACK:\n-\t.cfi_startproc\n-\tbl STACK_EXHAUSTED\n-\t// the above function ensures that it never returns\n-\t.cfi_endproc\n-\n-#if !defined(__APPLE__)\n-endfunc MORESTACK\n-#endif"}, {"sha": "115e286866e6ebaed0a6029d8a0c81d96d63bfc5", "filename": "src/rt/arch/aarch64/record_sp.S", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Faarch64%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Faarch64%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,6 +0,0 @@\n-#include \"macros.S\"\n-\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif"}, {"sha": "0b9012cc2a80a27a48cc7fd4b6d0531aae349196", "filename": "src/rt/arch/arm/morestack.S", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farm%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farm%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,70 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-.code 32\n-.arm\n-#if defined(__APPLE__)\n-.align 2\n-#else\n-.align\n-#endif\n-\n-#if defined(__APPLE__)\n-#define MORESTACK ___morestack\n-#define STACK_EXHAUSTED _rust_stack_exhausted\n-#else\n-#define MORESTACK __morestack\n-#define STACK_EXHAUSTED rust_stack_exhausted\n-#endif\n-\n-.global STACK_EXHAUSTED\n-.global MORESTACK\n-\n-// Unfortunately LLVM yet doesn't support emitting correct debug\n-// DWARF information for non-ELF targets so to make it compile\n-// on iOS all that directives are simply commented out\n-#if defined(__APPLE__)\n-#define UNWIND @\n-#else\n-#define UNWIND\n-#endif\n-\n-#if defined(__APPLE__)\n-.private_extern MORESTACK\n-#else\n-.hidden MORESTACK\n-#endif\n-\n-#if !defined(__APPLE__)\n-   .type MORESTACK,%function\n-#endif\n-\n-// r4 and r5 are scratch registers for __morestack due to llvm\n-// ARMFrameLowering::adjustForSegmentedStacks() implementation.\n-MORESTACK:\n-    UNWIND .fnstart\n-\n-    // Save frame pointer and return address\n-    UNWIND .save {r4, r5}\n-    UNWIND .save {lr}\n-    UNWIND .save {r6, fp, lr}\n-    push {r6, fp, lr}\n-\n-    UNWIND .movsp r6\n-    mov r6, sp\n-    UNWIND .setfp fp, sp, #4\n-    add fp, sp, #4\n-\n-    // Save argument registers of the original function\n-    push {r0, r1, r2, r3, lr}\n-\n-    // Create new stack\n-    bl STACK_EXHAUSTED@plt\n-\n-    // the above function ensures that it never returns\n-    UNWIND  .fnend"}, {"sha": "d0e9b81b95a9bfbe03a1268100afcfafd7afc2fb", "filename": "src/rt/arch/arm/record_sp.S", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farm%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farm%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,56 +0,0 @@\n-// Do not compile anything here for iOS because split stacks\n-// are disabled at all and do not need any runtime support.\n-//\n-// See also comments in librustrt/stack.rs about why it was\n-// disabled and how it could be implemented in case of need.\n-#if !defined(__APPLE__)\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-.text\n-.code 32\n-.arm\n-.align\n-\n-#define RECORD_SP_LIMIT record_sp_limit\n-#define GET_SP_LIMIT    get_sp_limit\n-\n-.globl \tRECORD_SP_LIMIT\n-.globl\tGET_SP_LIMIT\n-\n-RECORD_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif // ANDROID\n-\n-\tstr r0, [r3]\n-\tmov pc, lr\n-\n-GET_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif  // __ANDROID__\n-\n-\tldr r0, [r3]\n-\tmov pc, lr\n-#endif"}, {"sha": "0b9012cc2a80a27a48cc7fd4b6d0531aae349196", "filename": "src/rt/arch/armv7/morestack.S", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farmv7%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,70 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-.code 32\n-.arm\n-#if defined(__APPLE__)\n-.align 2\n-#else\n-.align\n-#endif\n-\n-#if defined(__APPLE__)\n-#define MORESTACK ___morestack\n-#define STACK_EXHAUSTED _rust_stack_exhausted\n-#else\n-#define MORESTACK __morestack\n-#define STACK_EXHAUSTED rust_stack_exhausted\n-#endif\n-\n-.global STACK_EXHAUSTED\n-.global MORESTACK\n-\n-// Unfortunately LLVM yet doesn't support emitting correct debug\n-// DWARF information for non-ELF targets so to make it compile\n-// on iOS all that directives are simply commented out\n-#if defined(__APPLE__)\n-#define UNWIND @\n-#else\n-#define UNWIND\n-#endif\n-\n-#if defined(__APPLE__)\n-.private_extern MORESTACK\n-#else\n-.hidden MORESTACK\n-#endif\n-\n-#if !defined(__APPLE__)\n-   .type MORESTACK,%function\n-#endif\n-\n-// r4 and r5 are scratch registers for __morestack due to llvm\n-// ARMFrameLowering::adjustForSegmentedStacks() implementation.\n-MORESTACK:\n-    UNWIND .fnstart\n-\n-    // Save frame pointer and return address\n-    UNWIND .save {r4, r5}\n-    UNWIND .save {lr}\n-    UNWIND .save {r6, fp, lr}\n-    push {r6, fp, lr}\n-\n-    UNWIND .movsp r6\n-    mov r6, sp\n-    UNWIND .setfp fp, sp, #4\n-    add fp, sp, #4\n-\n-    // Save argument registers of the original function\n-    push {r0, r1, r2, r3, lr}\n-\n-    // Create new stack\n-    bl STACK_EXHAUSTED@plt\n-\n-    // the above function ensures that it never returns\n-    UNWIND  .fnend"}, {"sha": "d0e9b81b95a9bfbe03a1268100afcfafd7afc2fb", "filename": "src/rt/arch/armv7/record_sp.S", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farmv7%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,56 +0,0 @@\n-// Do not compile anything here for iOS because split stacks\n-// are disabled at all and do not need any runtime support.\n-//\n-// See also comments in librustrt/stack.rs about why it was\n-// disabled and how it could be implemented in case of need.\n-#if !defined(__APPLE__)\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-.text\n-.code 32\n-.arm\n-.align\n-\n-#define RECORD_SP_LIMIT record_sp_limit\n-#define GET_SP_LIMIT    get_sp_limit\n-\n-.globl \tRECORD_SP_LIMIT\n-.globl\tGET_SP_LIMIT\n-\n-RECORD_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif // ANDROID\n-\n-\tstr r0, [r3]\n-\tmov pc, lr\n-\n-GET_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif  // __ANDROID__\n-\n-\tldr r0, [r3]\n-\tmov pc, lr\n-#endif"}, {"sha": "0b9012cc2a80a27a48cc7fd4b6d0531aae349196", "filename": "src/rt/arch/armv7s/morestack.S", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7s%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7s%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farmv7s%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,70 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-.code 32\n-.arm\n-#if defined(__APPLE__)\n-.align 2\n-#else\n-.align\n-#endif\n-\n-#if defined(__APPLE__)\n-#define MORESTACK ___morestack\n-#define STACK_EXHAUSTED _rust_stack_exhausted\n-#else\n-#define MORESTACK __morestack\n-#define STACK_EXHAUSTED rust_stack_exhausted\n-#endif\n-\n-.global STACK_EXHAUSTED\n-.global MORESTACK\n-\n-// Unfortunately LLVM yet doesn't support emitting correct debug\n-// DWARF information for non-ELF targets so to make it compile\n-// on iOS all that directives are simply commented out\n-#if defined(__APPLE__)\n-#define UNWIND @\n-#else\n-#define UNWIND\n-#endif\n-\n-#if defined(__APPLE__)\n-.private_extern MORESTACK\n-#else\n-.hidden MORESTACK\n-#endif\n-\n-#if !defined(__APPLE__)\n-   .type MORESTACK,%function\n-#endif\n-\n-// r4 and r5 are scratch registers for __morestack due to llvm\n-// ARMFrameLowering::adjustForSegmentedStacks() implementation.\n-MORESTACK:\n-    UNWIND .fnstart\n-\n-    // Save frame pointer and return address\n-    UNWIND .save {r4, r5}\n-    UNWIND .save {lr}\n-    UNWIND .save {r6, fp, lr}\n-    push {r6, fp, lr}\n-\n-    UNWIND .movsp r6\n-    mov r6, sp\n-    UNWIND .setfp fp, sp, #4\n-    add fp, sp, #4\n-\n-    // Save argument registers of the original function\n-    push {r0, r1, r2, r3, lr}\n-\n-    // Create new stack\n-    bl STACK_EXHAUSTED@plt\n-\n-    // the above function ensures that it never returns\n-    UNWIND  .fnend"}, {"sha": "d0e9b81b95a9bfbe03a1268100afcfafd7afc2fb", "filename": "src/rt/arch/armv7s/record_sp.S", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7s%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Farmv7s%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Farmv7s%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,56 +0,0 @@\n-// Do not compile anything here for iOS because split stacks\n-// are disabled at all and do not need any runtime support.\n-//\n-// See also comments in librustrt/stack.rs about why it was\n-// disabled and how it could be implemented in case of need.\n-#if !defined(__APPLE__)\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", %progbits\n-#endif\n-\n-.text\n-.code 32\n-.arm\n-.align\n-\n-#define RECORD_SP_LIMIT record_sp_limit\n-#define GET_SP_LIMIT    get_sp_limit\n-\n-.globl \tRECORD_SP_LIMIT\n-.globl\tGET_SP_LIMIT\n-\n-RECORD_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif // ANDROID\n-\n-\tstr r0, [r3]\n-\tmov pc, lr\n-\n-GET_SP_LIMIT:\n-\t// First, try to read TLS address from coprocessor\n-\tmrc p15, #0, r3, c13, c0, #3\n-\tcmp r3, #0\n-\t// Otherwise, try to read from magic address 0xFFFF0FF0\n-\tmvneq r3, #0xF000\n-\tldreq r3, [r3, #-15]\n-\n-#if __ANDROID__\n-\tadd r3, r3, #252\n-#elif __linux__\n-\tadd r3, r3, #4\n-#endif  // __ANDROID__\n-\n-\tldr r0, [r3]\n-\tmov pc, lr\n-#endif"}, {"sha": "98fdfdf3402efdf0735f244076843e3a582fead6", "filename": "src/rt/arch/i386/morestack.S", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,143 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/*\n-\t__morestack\n-\n-        This function is normally used to implement stack growth using the\n-        mechanism devised by Ian Lance Taylor for gccgo, described here:\n-\n-\thttp://gcc.gnu.org/wiki/SplitStacks\n-\n-        Each Rust function contains an LLVM-generated prologue that compares the\n-        stack space required for the current function to the space remaining in\n-        the current stack segment, maintained in a platform-specific TLS slot.\n-        The stack limit is strategically maintained by the Rust runtime so that\n-        it is always in place whenever a Rust function is running.\n-\n-        In Rust, however, we currently do not use __morestack for stack growth\n-        purposes.  Rather each task has one large stack segment. When this\n-        __morestack function is run, we interpret this as a \"stack overflow\"\n-        event rather than an event requiring an allocation of a new stack.\n-\n-        In the early days, this implementation did indeed have all of the fiddly\n-        bits in order to manage split stacks in the sense of always growing\n-        stacks. For posterity, the implementation can be found at commit\n-        c8e77d5586aed50821e0b9361b2e24c96ade816c if we ever need to refer back\n-        to it.\n-\n-\t-- The __morestack calling convention --\n-\n-\tFor reasons of efficiency the __morestack calling convention\n-\tis bizarre. The calling function does not attempt to align the\n-\tstack for the call, and on x86_64 the arguments to __morestack\n-\tare passed in scratch registers in order to preserve the\n-\toriginal function's arguments.\n-\n-\tOnce __morestack has switched to the new stack, instead of\n-\treturning, it then calls into the original function, resuming\n-\texecution at the instruction following the call to\n-\t__morestack. Thus, when the original function returns it\n-\tactually returns to __morestack, which then deallocates the\n-\tstack and returns again to the original function's caller.\n-\n-\t-- Unwinding --\n-\n-\tAll this trickery causes hell when it comes time for the\n-\tunwinder to navigate it's way through this function. What\n-\twill happen is the original function will be unwound first\n-\twithout any special effort, then the unwinder encounters\n-\tthe __morestack frame, which is sitting just above a\n-\ttiny fraction of a frame (containing just a return pointer\n-\tand, on 32-bit, the arguments to __morestack).\n-\n-\tWe deal with this by claiming that little bit of stack\n-\tis actually part of the __morestack frame, encoded as\n-\tDWARF call frame instructions (CFI) by .cfi assembler\n-\tpseudo-ops.\n-\n-\tOne final complication (that took me a week to figure out)\n-\tis that OS X 10.6+ uses its own 'compact unwind info',\n-\tan undocumented format generated by the linker from\n-\tthe DWARF CFI. This compact unwind info doesn't correctly\n-\tcapture the nuance of the __morestack frame, so we need to\n-\tprevent the linker from attempting to convert its DWARF unwind\n-\tinformation.\n-*/\n-\n-.text\n-\n-#if defined(__APPLE__)\n-#define MORESTACK               ___morestack\n-#define EXHAUSTED               _rust_stack_exhausted\n-#else\n-#if defined(__linux__) || defined(__FreeBSD__)\n-#define MORESTACK               __morestack\n-#define EXHAUSTED               rust_stack_exhausted@plt\n-#else\n-#define MORESTACK               ___morestack\n-#define EXHAUSTED               _rust_stack_exhausted\n-#endif\n-#endif\n-\n-.globl MORESTACK\n-\n-// FIXME: What about __WIN32__?\n-#if defined(__linux__) || defined(__FreeBSD__)\n-\t.hidden MORESTACK\n-#else\n-#if defined(__APPLE__)\n-\t.private_extern MORESTACK\n-#endif\n-#endif\n-\n-#ifdef __ELF__\n-\t.type MORESTACK,@function\n-#endif\n-\n-MORESTACK:\n-\t.cfi_startproc\n-\n-\t// This base pointer setup differs from most in that we are\n-\t// telling the unwinder to consider the Canonical Frame\n-\t// Address (CFA) for this frame to be the value of the stack\n-\t// pointer prior to entry to the original function, whereas\n-\t// the CFA would typically be the value of the stack\n-\t// pointer prior to entry to this function. This will allow\n-\t// the unwinder to understand how to skip the tiny partial\n-\t// frame that the original function created by calling\n-\t// __morestack.\n-\n-\t// In practical terms, our CFA is 12 bytes greater than it\n-\t// would normally be, accounting for the two arguments to\n-\t// __morestack, and an extra return address.\n-\n-        // FIXME(#9854) these cfi directives don't work on windows.\n-\n-\tpushl %ebp\n-\n-#if defined(__APPLE__)\n-\t// The pattern of the return address being saved twice to the same location\n-\t// tells the OS X linker that it should not attempt to convert the DWARF\n-\t// unwind information to the compact format.\n-\t.cfi_offset %eip, -4\n-\t.cfi_offset %eip, -4\n-#endif\n-\n-\t// The CFA is 20 bytes above the register that it is\n-\t// associated with for this frame (which will be %ebp)\n-\t.cfi_def_cfa_offset 20\n-\t// %ebp is -20 bytes from the CFA\n-\t.cfi_offset %ebp, -20\n-\tmovl %esp, %ebp\n-\t// Calculate the CFA as an offset from %ebp\n-\t.cfi_def_cfa_register %ebp\n-\n-        // re-align the stack\n-        subl $12,%esp\n-        call EXHAUSTED\n-        // the exhaustion function guarantees that it can't return\n-\n-\t.cfi_endproc"}, {"sha": "12d9a2b6456cacf36c3535f685e1f1f1257e573a", "filename": "src/rt/arch/i386/record_sp.S", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,4 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif"}, {"sha": "266933df8c51c94d595ec935c00ea746b1c1204e", "filename": "src/rt/arch/mips/morestack.S", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmips%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmips%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,43 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section        .note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-\n-.globl rust_stack_exhausted\n-.globl __morestack\n-\n-.hidden __morestack\n-\n-.cfi_startproc\n-.set nomips16\n-.ent __morestack\n-__morestack:\n-        .set noreorder\n-        .set nomacro\n-\n-        addiu $29, $29, -4\n-        sw $30, 0($29)\n-\n-        // 16 = 4 (current) + 12 (previous)\n-        .cfi_def_cfa_offset 16\n-        .cfi_offset 31, -4\n-        .cfi_offset 30, -16\n-\n-        move $30, $29\n-        .cfi_def_cfa_register 30\n-\n-        // O32 ABI always reserves 16 bytes for arguments\n-        addiu $29, $29, -16\n-\n-        lw $25, %call16(rust_stack_exhausted)($28)\n-        jalr $25\n-        nop\n-\n-        // the above function make sure that we never get here\n-\n-.end __morestack\n-.cfi_endproc"}, {"sha": "a6dfa04edbbd7e18f3c046ef1cffa53383a3b1f2", "filename": "src/rt/arch/mips/record_sp.S", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmips%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmips%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmips%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,40 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-.text\n-\n-.globl record_sp_limit\n-.align 2\n-.set nomips16\n-.ent record_sp_limit\n-record_sp_limit:\n-        .set noreorder\n-        .set nomacro\n-        .set push\n-        .set mips32r2\n-        rdhwr $3, $29\n-        .set pop\n-        addiu $3, $3, -0x7004\n-        sw $4, 0($3)\n-        jr $31\n-        nop\n-.end record_sp_limit\n-\n-.globl get_sp_limit\n-.align 2\n-.set nomips16\n-.ent get_sp_limit\n-get_sp_limit:\n-        .set noreorder\n-        .set nomacro\n-        .set push\n-        .set mips32r2\n-        rdhwr $3, $29\n-        .set pop\n-        addiu $3, $3, -0x7004\n-        lw $2, 0($3)\n-        jr $31\n-        nop\n-.end get_sp_limit"}, {"sha": "266933df8c51c94d595ec935c00ea746b1c1204e", "filename": "src/rt/arch/mipsel/morestack.S", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmipsel%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmipsel%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmipsel%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,43 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section        .note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-\n-.globl rust_stack_exhausted\n-.globl __morestack\n-\n-.hidden __morestack\n-\n-.cfi_startproc\n-.set nomips16\n-.ent __morestack\n-__morestack:\n-        .set noreorder\n-        .set nomacro\n-\n-        addiu $29, $29, -4\n-        sw $30, 0($29)\n-\n-        // 16 = 4 (current) + 12 (previous)\n-        .cfi_def_cfa_offset 16\n-        .cfi_offset 31, -4\n-        .cfi_offset 30, -16\n-\n-        move $30, $29\n-        .cfi_def_cfa_register 30\n-\n-        // O32 ABI always reserves 16 bytes for arguments\n-        addiu $29, $29, -16\n-\n-        lw $25, %call16(rust_stack_exhausted)($28)\n-        jalr $25\n-        nop\n-\n-        // the above function make sure that we never get here\n-\n-.end __morestack\n-.cfi_endproc"}, {"sha": "a6dfa04edbbd7e18f3c046ef1cffa53383a3b1f2", "filename": "src/rt/arch/mipsel/record_sp.S", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmipsel%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fmipsel%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fmipsel%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,40 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-.text\n-\n-.globl record_sp_limit\n-.align 2\n-.set nomips16\n-.ent record_sp_limit\n-record_sp_limit:\n-        .set noreorder\n-        .set nomacro\n-        .set push\n-        .set mips32r2\n-        rdhwr $3, $29\n-        .set pop\n-        addiu $3, $3, -0x7004\n-        sw $4, 0($3)\n-        jr $31\n-        nop\n-.end record_sp_limit\n-\n-.globl get_sp_limit\n-.align 2\n-.set nomips16\n-.ent get_sp_limit\n-get_sp_limit:\n-        .set noreorder\n-        .set nomacro\n-        .set push\n-        .set mips32r2\n-        rdhwr $3, $29\n-        .set pop\n-        addiu $3, $3, -0x7004\n-        lw $2, 0($3)\n-        jr $31\n-        nop\n-.end get_sp_limit"}, {"sha": "2502ac1eb48d62e24efe356f2e7145cf5f5897c8", "filename": "src/rt/arch/powerpc/morestack.S", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fpowerpc%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fpowerpc%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fpowerpc%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,18 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section       .note.GNU-stack, \"\", %progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.global rust_stack_exhausted\n-\n-.hidden __morestack\n-\n-// FIXME(POWERPC): this might not be perfectly right but works for now\n-__morestack:\n-       .cfi_startproc\n-       bl rust_stack_exhausted\n-       // the above function ensures that it never returns\n-       .cfi_endproc\n-.end  __morestack"}, {"sha": "e93a69a711b3e35a9b439e7871704c7bb2a522ce", "filename": "src/rt/arch/powerpc/record_sp.S", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fpowerpc%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fpowerpc%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fpowerpc%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,4 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section       .note.GNU-stack, \"\", %progbits\n-#endif"}, {"sha": "cf2b9b9f717c57ff13ff997c99a33e467cd26dd6", "filename": "src/rt/arch/x86_64/morestack.S", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,69 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif\n-\n-/* See i386/morestack.S for the lengthy, general explanation. */\n-\n-.text\n-\n-#if defined(__APPLE__)\n-#define MORESTACK               ___morestack\n-#else\n-#define MORESTACK               __morestack\n-#endif\n-\n-#if defined(__APPLE__)\n-#define EXHAUSTED               _rust_stack_exhausted\n-#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)\n-#define EXHAUSTED               rust_stack_exhausted@PLT\n-#else\n-#define EXHAUSTED               rust_stack_exhausted\n-#endif\n-\n-#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__Bitrig__)\n-\t.hidden MORESTACK\n-#else\n-#if defined(__APPLE__)\n-\t.private_extern MORESTACK\n-#endif\n-#endif\n-\n-#ifdef __ELF__\n-\t.type MORESTACK,@function\n-#endif\n-\n-.globl MORESTACK\n-MORESTACK:\n-\t.cfi_startproc\n-\n-\tpushq %rbp\n-\t// The CFA is 24 bytes above the register that it will\n-\t// be associated with for this frame (%rbp). That is 8\n-\t// bytes greater than a normal frame, to allow the unwinder\n-\t// to skip the partial frame of the original function.\n-\t.cfi_def_cfa_offset 24\n-\n-#if defined(__APPLE__)\n-\t// The pattern of the return address being saved twice to the same location\n-\t// tells the OS X linker that it should not attempt to convert the DWARF\n-\t// unwind information to the compact format.\n-\t.cfi_offset %rip, -8\n-\t.cfi_offset %rip, -8\n-#endif\n-\n-\t// %rbp is -24 bytes from the CFA\n-\t.cfi_offset %rbp, -24\n-\tmovq %rsp, %rbp\n-\t// Calculate the CFA as on offset from %ebp\n-\t.cfi_def_cfa_register %rbp\n-\n-        // re-align the stack\n-        subq $8, %rsp\n-\n-        // kill this program\n-        call EXHAUSTED\n-\n-        // the exhaustion function guarantees that it can't return\n-\n-\t.cfi_endproc"}, {"sha": "12d9a2b6456cacf36c3535f685e1f1f1257e573a", "filename": "src/rt/arch/x86_64/record_sp.S", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,4 +0,0 @@\n-// Mark stack as non-executable\n-#if defined(__linux__) && defined(__ELF__)\n-.section\t.note.GNU-stack, \"\", @progbits\n-#endif"}, {"sha": "6a54ed322de0ae3c4bd17a800fc5aa6f81125cbf", "filename": "src/rt/empty.c", "status": "renamed", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Frt%2Fempty.c", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Frt%2Fempty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fempty.c?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -7,18 +7,3 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-\n-#![crate_type=\"lib\"]\n-\n-extern {\n-    // Prevents optimizing away the stack buffer.\n-    // This symbol is undefined, but the code doesn't need to pass\n-    // the linker.\n-    fn black_box(ptr: *const u8);\n-}\n-\n-pub unsafe fn foo() {\n-    // Make sure we use the stack\n-    let x: [u8; 50] = [0; 50];\n-    black_box(x.as_ptr());\n-}", "previous_filename": "src/test/run-make/no-stack-check/flag.rs"}, {"sha": "8b01cac820ed08e07b846f5aafeb37360fb706e7", "filename": "src/rustllvm/ExecutionEngineWrapper.cpp", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FExecutionEngineWrapper.cpp?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -16,15 +16,6 @@ using namespace llvm;\n using namespace llvm::sys;\n using namespace llvm::object;\n \n-// libmorestack is not used on other platforms\n-#if defined(__linux__) || defined(__APPLE__)\n-extern \"C\" void __morestack(void);\n-\n-static void* morestack_addr() {\n-    return reinterpret_cast<void*>(__morestack);\n-}\n-#endif\n-\n class RustJITMemoryManager : public SectionMemoryManager\n {\n     typedef SectionMemoryManager Base;\n@@ -35,13 +26,6 @@ class RustJITMemoryManager : public SectionMemoryManager\n \n     uint64_t getSymbolAddress(const std::string &Name) override\n     {\n-#if defined(__linux__) || defined(__APPLE__)\n-        if (Name == \"__morestack\" || Name == \"___morestack\")\n-            return reinterpret_cast<uint64_t>(__morestack);\n-        if (Name == \"__morestack_addr\" || Name == \"___morestack_addr\")\n-            return reinterpret_cast<uint64_t>(morestack_addr);\n-#endif\n-\n         return Base::getSymbolAddress(Name);\n     }\n };"}, {"sha": "7d78c42628138f4e3ba9e59ad3dfe4bfcc57798e", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -15,9 +15,6 @@\n extern crate core;\n extern crate libc;\n \n-#[lang = \"stack_exhausted\"]\n-extern fn stack_exhausted() {}\n-\n #[lang = \"eh_personality\"]\n extern fn eh_personality() {}\n "}, {"sha": "39fec2ddfbdeab0ff2b5a7b23c5b4e6e67ff8454", "filename": "src/test/compile-fail/no_owned_box_lang_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_owned_box_lang_item.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -19,7 +19,6 @@ fn main() {\n     let x = box 1i32;\n }\n \n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }"}, {"sha": "e3a905c536b0298d2ecf8b51a2a75ecd1954e32d", "filename": "src/test/compile-fail/weak-lang-item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:weak-lang-items.rs\n // error-pattern: language item required, but not found: `panic_fmt`\n-// error-pattern: language item required, but not found: `stack_exhausted`\n // error-pattern: language item required, but not found: `eh_personality`\n \n #![feature(no_std)]"}, {"sha": "c7f184cb576723e332a48b20f0e1346c2d51fdf0", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -17,7 +17,6 @@ extern crate libc;\n #[no_mangle]\n pub extern fn bar() {}\n \n-#[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }"}, {"sha": "d8bd2bec2de986c940504f51298989e725ef51d7", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -17,7 +17,6 @@ extern crate libc;\n #[no_mangle]\n pub extern fn foo() {}\n \n-#[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }"}, {"sha": "a2e1fe5627186f3b42d4f6ec0e3389139ece0143", "filename": "src/test/run-make/no-stack-check/Makefile", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-stack-check%2FMakefile?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,25 +0,0 @@\n--include ../tools.mk\n-\n-\n-ifndef IS_WINDOWS\n-\n-SKIP_OS := 'OpenBSD Bitrig'\n-ifneq ($(UNAME),$(findstring $(UNAME),$(SKIP_OS)))\n-\n-all:\n-\t$(RUSTC) -O --emit asm attr.rs\n-\t! grep -q morestack $(TMPDIR)/attr.s\n-\t$(RUSTC) -O --emit asm flag.rs\n-\tgrep -q morestack $(TMPDIR)/flag.s\n-\t$(RUSTC) -O --emit asm -C no-stack-check flag.rs\n-\t! grep -q morestack $(TMPDIR)/flag.s\n-else\n-# On Bitrig/OpenBSD, morestack isn't used as the segmented stacks are disabled\n-all:\n-endif\n-\n-else\n-# On Windows we use __chkstk and it only appears in functions with large allocations,\n-# so this test wouldn't be reliable.\n-all:\n-endif"}, {"sha": "7d0fc2d7fe503e618f2e300873d10bd4b86d753d", "filename": "src/test/run-make/no-stack-check/attr.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-stack-check%2Fattr.rs?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_type=\"lib\"]\n-\n-extern {\n-    // Prevents optimizing away the stack buffer.\n-    // This symbol is undefined, but the code doesn't need to pass\n-    // the linker.\n-    fn black_box(ptr: *const u8);\n-}\n-\n-#[no_stack_check]\n-pub unsafe fn foo() {\n-    // Make sure we use the stack\n-    let x: [u8; 50] = [0; 50];\n-    black_box(x.as_ptr());\n-}"}, {"sha": "462665a9c82b9d5d8039a61d21c511203900b303", "filename": "src/test/run-make/target-specs/Makefile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -6,6 +6,3 @@ all:\n \t$(RUSTC) foo.rs --target=my-incomplete-platform.json 2>&1 | grep 'Field llvm-target'\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-awesome-platform --crate-type=lib --emit=asm\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=x86_64-unknown-linux-gnu --crate-type=lib --emit=asm\n-\t# The built-in target *should* override the one we have here, and thus we\n-\t# should have morestack\n-\tgrep -q morestack < $(TMPDIR)/foo.s"}, {"sha": "2c6e55b57b066a5be9c766243ec93ffff9d5b3a0", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android\n-// ignore-freebsd\n-// ignore-ios\n-// ignore-dragonfly\n-// ignore-bitrig\n-// ignore-musl\n-\n-#![feature(asm)]\n-\n-use std::process::Command;\n-use std::env;\n-use std::thread;\n-\n-// lifted from the test module\n-// Inlining to avoid llvm turning the recursive functions into tail calls,\n-// which doesn't consume stack.\n-#[inline(always)]\n-#[no_stack_check]\n-pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n-\n-#[no_stack_check]\n-fn recurse() {\n-    let buf = [0; 10];\n-    black_box(buf);\n-    recurse();\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"recurse\" {\n-        thread::spawn(recurse).join();\n-    } else {\n-        let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n-        assert!(!recurse.status.success());\n-        let error = String::from_utf8_lossy(&recurse.stderr);\n-        println!(\"wut\");\n-        println!(\"`{}`\", error);\n-        assert!(error.contains(\"has overflowed its stack\"));\n-    }\n-}"}, {"sha": "da7342d251e6e3e550caca73f4c77ed166cbfc90", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03456183e85fe7bd465bbe7c8f67885a2528444/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=d03456183e85fe7bd465bbe7c8f67885a2528444", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android\n-// ignore-linux\n-// ignore-freebsd\n-// ignore-ios\n-// ignore-dragonfly\n-// ignore-bitrig\n-\n-#![feature(asm)]\n-\n-use std::process::Command;\n-use std::env;\n-\n-// lifted from the test module\n-// Inlining to avoid llvm turning the recursive functions into tail calls,\n-// which doesn't consume stack.\n-#[inline(always)]\n-#[no_stack_check]\n-pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n-\n-#[no_stack_check]\n-fn recurse() {\n-    let buf = [0; 10];\n-    black_box(buf);\n-    recurse();\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    if args.len() > 1 && args[1] == \"recurse\" {\n-        recurse();\n-    } else {\n-        let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n-        assert!(!recurse.status.success());\n-        let error = String::from_utf8_lossy(&recurse.stderr);\n-        assert!(error.contains(\"has overflowed its stack\"));\n-    }\n-}"}, {"sha": "149de10ce02422dd46db9a0029d5f9c40063ab88", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -13,8 +13,9 @@\n \n #![feature(asm)]\n \n-use std::process::Command;\n use std::env;\n+use std::process::Command;\n+use std::thread;\n \n // lifted from the test module\n // Inlining to avoid llvm turning the recursive functions into tail calls,\n@@ -23,7 +24,7 @@ use std::env;\n pub fn black_box<T>(dummy: T) { unsafe { asm!(\"\" : : \"r\"(&dummy)) } }\n \n fn silent_recurse() {\n-    let buf = [0; 1000];\n+    let buf = [0u8; 1000];\n     black_box(buf);\n     silent_recurse();\n }\n@@ -40,15 +41,31 @@ fn main() {\n         silent_recurse();\n     } else if args.len() > 1 && args[1] == \"loud\" {\n         loud_recurse();\n+    } else if args.len() > 1 && args[1] == \"silent-thread\" {\n+        thread::spawn(silent_recurse).join();\n+    } else if args.len() > 1 && args[1] == \"loud-thread\" {\n+        thread::spawn(loud_recurse).join();\n     } else {\n-        let silent = Command::new(&args[0]).arg(\"silent\").output().unwrap();\n-        assert!(!silent.status.success());\n-        let error = String::from_utf8_lossy(&silent.stderr);\n-        assert!(error.contains(\"has overflowed its stack\"));\n-\n-        let loud = Command::new(&args[0]).arg(\"loud\").output().unwrap();\n-        assert!(!loud.status.success());\n-        let error = String::from_utf8_lossy(&silent.stderr);\n-        assert!(error.contains(\"has overflowed its stack\"));\n+        let mut modes = vec![\n+            \"silent-thread\",\n+            \"loud-thread\",\n+        ];\n+\n+        // On linux it looks like the main thread can sometimes grow its stack\n+        // basically without bounds, so we only test the child thread cases\n+        // there.\n+        if !cfg!(target_os = \"linux\") {\n+            modes.push(\"silent\");\n+            modes.push(\"loud\");\n+        }\n+        for mode in modes {\n+            println!(\"testing: {}\", mode);\n+\n+            let silent = Command::new(&args[0]).arg(mode).output().unwrap();\n+            assert!(!silent.status.success());\n+            let error = String::from_utf8_lossy(&silent.stderr);\n+            assert!(error.contains(\"has overflowed its stack\"),\n+                    \"missing overflow message: {}\", error);\n+        }\n     }\n }"}, {"sha": "6f5fc8e6b4e4eb5add4e0f8fa3a7453f7d999e14", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(libc)]\n \n-use std::process::Command;\n+extern crate libc;\n+\n+use std::process::{Command, ExitStatus};\n use std::env;\n \n fn main() {\n@@ -18,8 +21,12 @@ fn main() {\n         unsafe { *(0 as *mut isize) = 1 }; // trigger a segfault\n     } else {\n         let segfault = Command::new(&args[0]).arg(\"segfault\").output().unwrap();\n+        let stderr = String::from_utf8_lossy(&segfault.stderr);\n+        let stdout = String::from_utf8_lossy(&segfault.stdout);\n+        println!(\"stdout: {}\", stdout);\n+        println!(\"stderr: {}\", stderr);\n+        println!(\"status: {}\", segfault.status);\n         assert!(!segfault.status.success());\n-        let error = String::from_utf8_lossy(&segfault.stderr);\n-        assert!(!error.contains(\"has overflowed its stack\"));\n+        assert!(!stderr.contains(\"has overflowed its stack\"));\n     }\n }"}, {"sha": "5f35bd4f7d2e2170852905186de858a605a3870a", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=7a3fdfbf674a08b7f6fd32c9124e52924a2f9a1c", "patch": "@@ -20,13 +20,11 @@ extern crate libc;\n extern { fn puts(s: *const u8); }\n extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n \n #[start]\n-#[no_stack_check]\n fn main(_: isize, _: *const *const u8) -> isize {\n     unsafe {\n         let (ptr, _): (*const u8, usize) = transmute(\"Hello!\\0\");"}]}