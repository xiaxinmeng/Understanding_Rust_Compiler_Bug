{"sha": "55162239007a1514dd9c5fe99c377c1929be1039", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MTYyMjM5MDA3YTE1MTRkZDljNWZlOTljMzc3YzE5MjliZTEwMzk=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-19T02:13:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-19T02:13:47Z"}, "message": "Merge pull request #2542 from topecongiro/macro-2.0\n\nHandle macro arguments which exceeds max width", "tree": {"sha": "aacc7bf7b1c0200ad28289b5422977d328bbe021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aacc7bf7b1c0200ad28289b5422977d328bbe021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55162239007a1514dd9c5fe99c377c1929be1039", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJarxzbCRBK7hj4Ov3rIwAAdHIIAB6E1DuCpPddZKrQpb3GaAkB\n0Af5eXS2MJ1dv52MQ9TlsS5wMwowLbnXEDh7FE4mq9d8wJ0JHomGYuhmOBsDeeT4\nlPQRUdnWdOaJ5pOJ/encL0CqUAgJ7iSNzotQIOFNbvS+SEO3/8xLxAAI3h0uKr9b\nRvtzZW1BmyXVHR3JzmGkzitFY9qJ7Qd6Z8AooOhz6pQB+w1IyT/J4UDjwdGY0Qmk\nPbHTvtZYSs0lPXS5h0uGNgez/Sb2BYG3diT5KitTULRX8rHnjqnV5OKRQspu/NY9\nLu8DbWKMD11yCTZncA7bSlNtVA6LCB9U87x7FmygArjwlGEXVTRaWPZYClB/CFE=\n=B8RT\n-----END PGP SIGNATURE-----\n", "payload": "tree aacc7bf7b1c0200ad28289b5422977d328bbe021\nparent 56d2a08db0784659178fe13fbc767d8258a085f1\nparent adc257f4b3b2a9a971dfd19721d9ad97fae5d37a\nauthor Nick Cameron <nrc@ncameron.org> 1521425627 +1300\ncommitter GitHub <noreply@github.com> 1521425627 +1300\n\nMerge pull request #2542 from topecongiro/macro-2.0\n\nHandle macro arguments which exceeds max width"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55162239007a1514dd9c5fe99c377c1929be1039", "html_url": "https://github.com/rust-lang/rust/commit/55162239007a1514dd9c5fe99c377c1929be1039", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55162239007a1514dd9c5fe99c377c1929be1039/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56d2a08db0784659178fe13fbc767d8258a085f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/56d2a08db0784659178fe13fbc767d8258a085f1", "html_url": "https://github.com/rust-lang/rust/commit/56d2a08db0784659178fe13fbc767d8258a085f1"}, {"sha": "adc257f4b3b2a9a971dfd19721d9ad97fae5d37a", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc257f4b3b2a9a971dfd19721d9ad97fae5d37a", "html_url": "https://github.com/rust-lang/rust/commit/adc257f4b3b2a9a971dfd19721d9ad97fae5d37a"}], "stats": {"total": 678, "additions": 565, "deletions": 113}, "files": [{"sha": "784e6c5798bec15c13fef1ef119ffe687cc5a89f", "filename": "src/macros.rs", "status": "modified", "additions": 437, "deletions": 107, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/55162239007a1514dd9c5fe99c377c1929be1039/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55162239007a1514dd9c5fe99c377c1929be1039/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=55162239007a1514dd9c5fe99c377c1929be1039", "patch": "@@ -463,73 +463,453 @@ fn replace_names(input: &str) -> Option<(String, HashMap<String, String>)> {\n     Some((result, substs))\n }\n \n-// This is a bit sketchy. The token rules probably need tweaking, but it works\n-// for some common cases. I hope the basic logic is sufficient. Note that the\n-// meaning of some tokens is a bit different here from usual Rust, e.g., `*`\n-// and `(`/`)` have special meaning.\n-//\n-// We always try and format on one line.\n-// FIXME: Use multi-line when every thing does not fit on one line.\n-fn format_macro_args(toks: ThinTokenStream, shape: Shape) -> Option<String> {\n-    let mut result = String::with_capacity(128);\n-    let mut insert_space = SpaceState::Never;\n+#[derive(Debug, Clone)]\n+enum MacroArgKind {\n+    /// e.g. `$x: expr`.\n+    MetaVariable(ast::Ident, String),\n+    /// e.g. `$($foo: expr),*`\n+    Repeat(\n+        /// `()`, `[]` or `{}`.\n+        DelimToken,\n+        /// Inner arguments inside delimiters.\n+        Vec<ParsedMacroArg>,\n+        /// Something after the closing delimiter and the repeat token, if available.\n+        Option<Box<ParsedMacroArg>>,\n+        /// The repeat token. This could be one of `*`, `+` or `?`.\n+        Token,\n+    ),\n+    /// e.g. `[derive(Debug)]`\n+    Delimited(DelimToken, Vec<ParsedMacroArg>),\n+    /// A possible separator. e.g. `,` or `;`.\n+    Separator(String, String),\n+    /// Other random stuff that does not fit to other kinds.\n+    /// e.g. `== foo` in `($x: expr == foo)`.\n+    Other(String, String),\n+}\n+\n+fn delim_token_to_str(\n+    context: &RewriteContext,\n+    delim_token: &DelimToken,\n+    shape: Shape,\n+    use_multiple_lines: bool,\n+) -> (String, String) {\n+    let (lhs, rhs) = match *delim_token {\n+        DelimToken::Paren => (\"(\", \")\"),\n+        DelimToken::Bracket => (\"[\", \"]\"),\n+        DelimToken::Brace => (\"{ \", \" }\"),\n+        DelimToken::NoDelim => (\"\", \"\"),\n+    };\n+    if use_multiple_lines {\n+        let indent_str = shape.indent.to_string_with_newline(context.config);\n+        let nested_indent_str = shape\n+            .indent\n+            .block_indent(context.config)\n+            .to_string_with_newline(context.config);\n+        (\n+            format!(\"{}{}\", lhs, nested_indent_str),\n+            format!(\"{}{}\", indent_str, rhs),\n+        )\n+    } else {\n+        (lhs.to_owned(), rhs.to_owned())\n+    }\n+}\n+\n+impl MacroArgKind {\n+    fn starts_with_brace(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Repeat(DelimToken::Brace, _, _, _)\n+            | MacroArgKind::Delimited(DelimToken::Brace, _) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn starts_with_dollar(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Repeat(..) | MacroArgKind::MetaVariable(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn ends_with_space(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Separator(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn has_meta_var(&self) -> bool {\n+        match *self {\n+            MacroArgKind::MetaVariable(..) => true,\n+            MacroArgKind::Repeat(_, ref args, _, _) => args.iter().any(|a| a.kind.has_meta_var()),\n+            _ => false,\n+        }\n+    }\n+\n+    fn rewrite(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        use_multiple_lines: bool,\n+    ) -> Option<String> {\n+        let rewrite_delimited_inner = |delim_tok, args| -> Option<(String, String, String)> {\n+            let (lhs, rhs) = delim_token_to_str(context, delim_tok, shape, false);\n+            let inner = wrap_macro_args(context, args, shape)?;\n+            if lhs.len() + inner.len() + rhs.len() <= shape.width {\n+                return Some((lhs, inner, rhs));\n+            }\n+\n+            let (lhs, rhs) = delim_token_to_str(context, delim_tok, shape, true);\n+            let nested_shape = shape\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config);\n+            let inner = wrap_macro_args(context, args, nested_shape)?;\n+            Some((lhs, inner, rhs))\n+        };\n+\n+        match *self {\n+            MacroArgKind::MetaVariable(ty, ref name) => {\n+                Some(format!(\"${}: {}\", name, ty.name.as_str()))\n+            }\n+            MacroArgKind::Repeat(ref delim_tok, ref args, ref another, ref tok) => {\n+                let (lhs, inner, rhs) = rewrite_delimited_inner(delim_tok, args)?;\n+                let another = another\n+                    .as_ref()\n+                    .and_then(|a| a.rewrite(context, shape, use_multiple_lines))\n+                    .unwrap_or(\"\".to_owned());\n+                let repeat_tok = pprust::token_to_string(tok);\n+\n+                Some(format!(\"${}{}{}{}{}\", lhs, inner, rhs, another, repeat_tok))\n+            }\n+            MacroArgKind::Delimited(ref delim_tok, ref args) => {\n+                rewrite_delimited_inner(delim_tok, args)\n+                    .map(|(lhs, inner, rhs)| format!(\"{}{}{}\", lhs, inner, rhs))\n+            }\n+            MacroArgKind::Separator(ref sep, ref prefix) => Some(format!(\"{}{} \", prefix, sep)),\n+            MacroArgKind::Other(ref inner, ref prefix) => Some(format!(\"{}{}\", prefix, inner)),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct ParsedMacroArg {\n+    kind: MacroArgKind,\n+    span: Span,\n+}\n+\n+impl ParsedMacroArg {\n+    pub fn rewrite(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        use_multiple_lines: bool,\n+    ) -> Option<String> {\n+        self.kind.rewrite(context, shape, use_multiple_lines)\n+    }\n+}\n+\n+/// Parses macro arguments on macro def.\n+struct MacroArgParser {\n+    /// Holds either a name of the next metavariable, a separator or a junk.\n+    buf: String,\n+    /// The start position on the current buffer.\n+    lo: BytePos,\n+    /// The first token of the current buffer.\n+    start_tok: Token,\n+    /// Set to true if we are parsing a metavariable or a repeat.\n+    is_meta_var: bool,\n+    /// The position of the last token.\n+    hi: BytePos,\n+    /// The last token parsed.\n+    last_tok: Token,\n+    /// Holds the parsed arguments.\n+    result: Vec<ParsedMacroArg>,\n+}\n+\n+fn last_tok(tt: &TokenTree) -> Token {\n+    match *tt {\n+        TokenTree::Token(_, ref t) => t.clone(),\n+        TokenTree::Delimited(_, ref d) => d.close_token(),\n+    }\n+}\n+\n+impl MacroArgParser {\n+    pub fn new() -> MacroArgParser {\n+        MacroArgParser {\n+            lo: BytePos(0),\n+            hi: BytePos(0),\n+            buf: String::new(),\n+            is_meta_var: false,\n+            last_tok: Token::Eof,\n+            start_tok: Token::Eof,\n+            result: vec![],\n+        }\n+    }\n+\n+    fn set_last_tok(&mut self, tok: &TokenTree) {\n+        self.hi = tok.span().hi();\n+        self.last_tok = last_tok(tok);\n+    }\n+\n+    fn add_separator(&mut self) {\n+        let prefix = if self.need_space_prefix() {\n+            \" \".to_owned()\n+        } else {\n+            \"\".to_owned()\n+        };\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Separator(self.buf.clone(), prefix),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+        self.buf.clear();\n+    }\n+\n+    fn add_other(&mut self) {\n+        let prefix = if self.need_space_prefix() {\n+            \" \".to_owned()\n+        } else {\n+            \"\".to_owned()\n+        };\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Other(self.buf.clone(), prefix),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+        self.buf.clear();\n+    }\n+\n+    fn add_meta_variable(&mut self, iter: &mut Cursor) {\n+        match iter.next() {\n+            Some(TokenTree::Token(sp, Token::Ident(ref ident))) => {\n+                self.result.push(ParsedMacroArg {\n+                    kind: MacroArgKind::MetaVariable(ident.clone(), self.buf.clone()),\n+                    span: mk_sp(self.lo, sp.hi()),\n+                });\n+\n+                self.buf.clear();\n+                self.is_meta_var = false;\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken, span: Span) {\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Delimited(delim, inner),\n+            span,\n+        });\n+    }\n+\n+    // $($foo: expr),?\n+    fn add_repeat(\n+        &mut self,\n+        inner: Vec<ParsedMacroArg>,\n+        delim: DelimToken,\n+        iter: &mut Cursor,\n+        span: Span,\n+    ) {\n+        let mut buffer = String::new();\n+        let mut first = false;\n+        let mut lo = span.lo();\n+        let mut hi = span.hi();\n+\n+        // Parse '*', '+' or '?.\n+        while let Some(ref tok) = iter.next() {\n+            self.set_last_tok(tok);\n+            if first {\n+                first = false;\n+                lo = tok.span().lo();\n+            }\n \n-    for tok in (toks.into(): TokenStream).trees() {\n-        match tok {\n-            TokenTree::Token(_, t) => {\n-                if !result.is_empty() && force_space_before(&t) {\n-                    insert_space = SpaceState::Always;\n+            match tok {\n+                TokenTree::Token(_, Token::BinOp(BinOpToken::Plus))\n+                | TokenTree::Token(_, Token::Question)\n+                | TokenTree::Token(_, Token::BinOp(BinOpToken::Star)) => {\n+                    break;\n                 }\n-                if force_no_space_before(&t) {\n-                    insert_space = SpaceState::Never;\n+                TokenTree::Token(sp, ref t) => {\n+                    buffer.push_str(&pprust::token_to_string(t));\n+                    hi = sp.hi();\n                 }\n-                match (insert_space, ident_like(&t)) {\n-                    (SpaceState::Always, _)\n-                    | (SpaceState::Punctuation, false)\n-                    | (SpaceState::Ident, true) => {\n-                        result.push(' ');\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        // There could be some random stuff between ')' and '*', '+' or '?'.\n+        let another = if buffer.trim().is_empty() {\n+            None\n+        } else {\n+            Some(Box::new(ParsedMacroArg {\n+                kind: MacroArgKind::Other(buffer, \"\".to_owned()),\n+                span: mk_sp(lo, hi),\n+            }))\n+        };\n+\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Repeat(delim, inner, another, self.last_tok.clone()),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+    }\n+\n+    fn update_buffer(&mut self, lo: BytePos, t: &Token) {\n+        if self.buf.is_empty() {\n+            self.lo = lo;\n+            self.start_tok = t.clone();\n+        } else {\n+            let needs_space = match next_space(&self.last_tok) {\n+                SpaceState::Ident => ident_like(t),\n+                SpaceState::Punctuation => !ident_like(t),\n+                SpaceState::Always => true,\n+                SpaceState::Never => false,\n+            };\n+            if force_space_before(t) || needs_space {\n+                self.buf.push(' ');\n+            }\n+        }\n+\n+        self.buf.push_str(&pprust::token_to_string(t));\n+    }\n+\n+    fn need_space_prefix(&self) -> bool {\n+        if self.result.is_empty() {\n+            return false;\n+        }\n+\n+        let last_arg = self.result.last().unwrap();\n+        if let MacroArgKind::MetaVariable(..) = last_arg.kind {\n+            if ident_like(&self.start_tok) {\n+                return true;\n+            }\n+            if self.start_tok == Token::Colon {\n+                return true;\n+            }\n+        }\n+\n+        if force_space_before(&self.start_tok) {\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    /// Returns a collection of parsed macro def's arguments.\n+    pub fn parse(mut self, tokens: ThinTokenStream) -> Vec<ParsedMacroArg> {\n+        let mut iter = (tokens.into(): TokenStream).trees();\n+\n+        while let Some(ref tok) = iter.next() {\n+            match tok {\n+                TokenTree::Token(sp, Token::Dollar) => {\n+                    // We always want to add a separator before meta variables.\n+                    if !self.buf.is_empty() {\n+                        self.add_separator();\n                     }\n-                    _ => {}\n+\n+                    // Start keeping the name of this metavariable in the buffer.\n+                    self.is_meta_var = true;\n+                    self.lo = sp.lo();\n+                    self.start_tok = Token::Dollar;\n                 }\n-                result.push_str(&pprust::token_to_string(&t));\n-                insert_space = next_space(&t);\n-            }\n-            TokenTree::Delimited(_, d) => {\n-                if let SpaceState::Always = insert_space {\n-                    result.push(' ');\n+                TokenTree::Token(_, Token::Colon) if self.is_meta_var => {\n+                    self.add_meta_variable(&mut iter);\n                 }\n-                let formatted = format_macro_args(d.tts, shape)?;\n-                match d.delim {\n-                    DelimToken::Paren => {\n-                        result.push_str(&format!(\"({})\", formatted));\n-                        insert_space = SpaceState::Always;\n-                    }\n-                    DelimToken::Bracket => {\n-                        result.push_str(&format!(\"[{}]\", formatted));\n-                        insert_space = SpaceState::Always;\n-                    }\n-                    DelimToken::Brace => {\n-                        result.push_str(&format!(\" {{ {} }}\", formatted));\n-                        insert_space = SpaceState::Always;\n+                TokenTree::Token(sp, ref t) => self.update_buffer(sp.lo(), t),\n+                TokenTree::Delimited(sp, delimited) => {\n+                    if !self.buf.is_empty() {\n+                        if next_space(&self.last_tok) == SpaceState::Always {\n+                            self.add_separator();\n+                        } else {\n+                            self.add_other();\n+                        }\n                     }\n-                    DelimToken::NoDelim => {\n-                        result.push_str(&format!(\"{}\", formatted));\n-                        insert_space = SpaceState::Always;\n+\n+                    // Parse the stuff inside delimiters.\n+                    let mut parser = MacroArgParser::new();\n+                    parser.lo = sp.lo();\n+                    let delimited_arg = parser.parse(delimited.tts.clone());\n+\n+                    if self.is_meta_var {\n+                        self.add_repeat(delimited_arg, delimited.delim, &mut iter, *sp);\n+                    } else {\n+                        self.add_delimited(delimited_arg, delimited.delim, *sp);\n                     }\n                 }\n             }\n+\n+            self.set_last_tok(tok);\n+        }\n+\n+        // We are left with some stuff in the buffer. Since there is nothing\n+        // left to separate, add this as `Other`.\n+        if !self.buf.is_empty() {\n+            self.add_other();\n+        }\n+\n+        self.result\n+    }\n+}\n+\n+fn wrap_macro_args(\n+    context: &RewriteContext,\n+    args: &[ParsedMacroArg],\n+    shape: Shape,\n+) -> Option<String> {\n+    wrap_macro_args_inner(context, args, shape, false)\n+        .or_else(|| wrap_macro_args_inner(context, args, shape, true))\n+}\n+\n+fn wrap_macro_args_inner(\n+    context: &RewriteContext,\n+    args: &[ParsedMacroArg],\n+    shape: Shape,\n+    use_multiple_lines: bool,\n+) -> Option<String> {\n+    let mut result = String::with_capacity(128);\n+    let mut iter = args.iter().peekable();\n+    let indent_str = shape.indent.to_string_with_newline(context.config);\n+\n+    while let Some(ref arg) = iter.next() {\n+        result.push_str(&arg.rewrite(context, shape, use_multiple_lines)?);\n+\n+        if use_multiple_lines\n+            && (arg.kind.ends_with_space() || iter.peek().map_or(false, |a| a.kind.has_meta_var()))\n+        {\n+            if arg.kind.ends_with_space() {\n+                result.pop();\n+            }\n+            result.push_str(&indent_str);\n+        } else if let Some(ref next_arg) = iter.peek() {\n+            let space_before_dollar =\n+                !arg.kind.ends_with_space() && next_arg.kind.starts_with_dollar();\n+            let space_before_brace = next_arg.kind.starts_with_brace();\n+            if space_before_dollar || space_before_brace {\n+                result.push(' ');\n+            }\n         }\n     }\n \n-    if result.len() <= shape.width {\n-        Some(result)\n-    } else {\n+    if !use_multiple_lines && result.len() >= shape.width {\n         None\n+    } else {\n+        Some(result)\n     }\n }\n \n+// This is a bit sketchy. The token rules probably need tweaking, but it works\n+// for some common cases. I hope the basic logic is sufficient. Note that the\n+// meaning of some tokens is a bit different here from usual Rust, e.g., `*`\n+// and `(`/`)` have special meaning.\n+//\n+// We always try and format on one line.\n+// FIXME: Use multi-line when every thing does not fit on one line.\n+fn format_macro_args(\n+    context: &RewriteContext,\n+    toks: ThinTokenStream,\n+    shape: Shape,\n+) -> Option<String> {\n+    let parsed_args = MacroArgParser::new().parse(toks);\n+    wrap_macro_args(context, &parsed_args, shape)\n+}\n+\n // We should insert a space if the next token is a:\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n enum SpaceState {\n     Never,\n     Punctuation,\n@@ -538,6 +918,8 @@ enum SpaceState {\n }\n \n fn force_space_before(tok: &Token) -> bool {\n+    debug!(\"tok: force_space_before {:?}\", tok);\n+\n     match *tok {\n         Token::Eq\n         | Token::Lt\n@@ -555,20 +937,13 @@ fn force_space_before(tok: &Token) -> bool {\n         | Token::RArrow\n         | Token::LArrow\n         | Token::FatArrow\n+        | Token::BinOp(_)\n         | Token::Pound\n         | Token::Dollar => true,\n-        Token::BinOp(bot) => bot != BinOpToken::Star,\n         _ => false,\n     }\n }\n \n-fn force_no_space_before(tok: &Token) -> bool {\n-    match *tok {\n-        Token::Semi | Token::Comma | Token::Dot => true,\n-        Token::BinOp(bot) => bot == BinOpToken::Star,\n-        _ => false,\n-    }\n-}\n fn ident_like(tok: &Token) -> bool {\n     match *tok {\n         Token::Ident(_) | Token::Literal(..) | Token::Lifetime(_) => true,\n@@ -577,8 +952,11 @@ fn ident_like(tok: &Token) -> bool {\n }\n \n fn next_space(tok: &Token) -> SpaceState {\n+    debug!(\"next_space: {:?}\", tok);\n+\n     match *tok {\n         Token::Not\n+        | Token::BinOp(BinOpToken::And)\n         | Token::Tilde\n         | Token::At\n         | Token::Comma\n@@ -588,8 +966,7 @@ fn next_space(tok: &Token) -> SpaceState {\n         | Token::DotDotEq\n         | Token::DotEq\n         | Token::Question\n-        | Token::Underscore\n-        | Token::BinOp(_) => SpaceState::Punctuation,\n+        | Token::Underscore => SpaceState::Punctuation,\n \n         Token::ModSep\n         | Token::Pound\n@@ -804,7 +1181,7 @@ impl MacroBranch {\n         }\n \n         // 5 = \" => {\"\n-        let mut result = format_macro_args(self.args.clone(), shape.sub_width(5)?)?;\n+        let mut result = format_macro_args(context, self.args.clone(), shape.sub_width(5)?)?;\n \n         if multi_branch_style {\n             result += \" =>\";\n@@ -957,50 +1334,3 @@ fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream)\n \n     Some(result)\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use syntax;\n-    use syntax::parse::{parse_stream_from_source_str, ParseSess};\n-    use syntax::codemap::{FileName, FilePathMapping};\n-\n-    fn format_macro_args_str(s: &str) -> String {\n-        let mut result = String::new();\n-        syntax::with_globals(|| {\n-            let input = parse_stream_from_source_str(\n-                FileName::Custom(\"stdin\".to_owned()),\n-                s.to_owned(),\n-                &ParseSess::new(FilePathMapping::empty()),\n-                None,\n-            );\n-            let shape = Shape {\n-                width: 100,\n-                indent: Indent::empty(),\n-                offset: 0,\n-            };\n-            result = format_macro_args(input.into(), shape).unwrap();\n-        });\n-        result\n-    }\n-\n-    #[test]\n-    fn test_format_macro_args() {\n-        assert_eq!(format_macro_args_str(\"\"), \"\".to_owned());\n-        assert_eq!(format_macro_args_str(\"$ x : ident\"), \"$x: ident\".to_owned());\n-        assert_eq!(\n-            format_macro_args_str(\"$ m1 : ident , $ m2 : ident , $ x : ident\"),\n-            \"$m1: ident, $m2: ident, $x: ident\".to_owned()\n-        );\n-        assert_eq!(\n-            format_macro_args_str(\"$($beginning:ident),*;$middle:ident;$($end:ident),*\"),\n-            \"$($beginning: ident),*; $middle: ident; $($end: ident),*\".to_owned()\n-        );\n-        assert_eq!(\n-            format_macro_args_str(\n-                \"$ name : ident ( $ ( $ dol : tt $ var : ident ) * ) $ ( $ body : tt ) *\"\n-            ),\n-            \"$name: ident($($dol: tt $var: ident)*) $($body: tt)*\".to_owned()\n-        );\n-    }\n-}"}, {"sha": "f390b426317eabd5081ac2f6382599e69d56de2b", "filename": "tests/source/macro_rules.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/55162239007a1514dd9c5fe99c377c1929be1039/tests%2Fsource%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55162239007a1514dd9c5fe99c377c1929be1039/tests%2Fsource%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacro_rules.rs?ref=55162239007a1514dd9c5fe99c377c1929be1039", "patch": "@@ -1,5 +1,44 @@\n // rustfmt-error_on_line_overflow: false\n \n+macro_rules! m {\n+    () => ();\n+    ( $ x : ident ) => ();\n+    ( $ m1 : ident , $ m2 : ident , $ x : ident ) => ();\n+    ( $($beginning:ident),*;$middle:ident;$($end:ident),* ) => ();\n+    ( $($beginning: ident),*; $middle: ident; $($end: ident),*; $($beginning: ident),*; $middle: ident; $($end: ident),* ) => {};\n+    ( $ name : ident ( $ ( $ dol : tt $ var : ident ) * ) $ ( $ body : tt ) * ) => ();\n+    ( $( $ i : ident : $ ty : ty , $def : expr , $stb : expr , $ ( $ dstring : tt ) , + ) ; + $ ( ; ) *\n+      $( $ i : ident : $ ty : ty , $def : expr , $stb : expr , $ ( $ dstring : tt ) , + ) ; + $ ( ; ) *\n+    ) => {};\n+    ( $foo: tt foo [$ attr : meta] $name: ident ) => {};\n+    ( $foo: tt [$ attr: meta] $name: ident ) => {};\n+    ( $foo: tt &'a [$attr : meta] $name: ident ) => {};\n+    ( $foo: tt foo # [ $attr : meta] $name: ident ) => {};\n+    ( $foo: tt # [ $attr : meta] $name: ident) => {};\n+    ( $foo: tt &'a # [ $attr : meta] $name: ident ) => {};\n+    ( $ x : tt foo bar foo bar foo bar $ y : tt => x*y*z $ z : tt , $ ( $a: tt ) , * ) => {};\n+}\n+\n+\n+macro_rules! impl_a_method {\n+    ($n:ident ( $a:ident : $ta:ty ) -> $ret:ty { $body:expr }) => {\n+        fn $n($a:$ta) -> $ret { $body }\n+        macro_rules! $n { ($va:expr) => { $n($va) } }\n+    };\n+    ($n:ident ( $a:ident : $ta:ty, $b:ident : $tb:ty ) -> $ret:ty { $body:expr }) => {\n+        fn $n($a:$ta, $b:$tb) -> $ret { $body }\n+        macro_rules! $n { ($va:expr, $vb:expr) => { $n($va, $vb) } }\n+    };\n+    ($n:ident ( $a:ident : $ta:ty, $b:ident : $tb:ty, $c:ident : $tc:ty ) -> $ret:ty { $body:expr }) => {\n+        fn $n($a:$ta, $b:$tb, $c:$tc) -> $ret { $body }\n+        macro_rules! $n { ($va:expr, $vb:expr, $vc:expr) => { $n($va, $vb, $vc) } }\n+    };\n+    ($n:ident ( $a:ident : $ta:ty, $b:ident : $tb:ty, $c:ident : $tc:ty, $d:ident : $td:ty ) -> $ret:ty { $body:expr }) => {\n+        fn $n($a:$ta, $b:$tb, $c:$tc, $d:$td) -> $ret { $body }\n+        macro_rules! $n { ($va:expr, $vb:expr, $vc:expr, $vd:expr) => { $n($va, $vb, $vc, $vd) } }\n+    };\n+}\n+\n macro_rules! m {\n \t// a\n \t($expr :expr,  $( $func : ident    ) *   ) => {\n@@ -88,12 +127,7 @@ macro_rules! m {\n \n // #2439\n macro_rules! m {\n-    (\n-        $line0_xxxxxxxxxxxxxxxxx: expr,\n-        $line1_xxxxxxxxxxxxxxxxx: expr,\n-        $line2_xxxxxxxxxxxxxxxxx: expr,\n-        $line3_xxxxxxxxxxxxxxxxx: expr,\n-    ) => {};\n+    ($line0_xxxxxxxxxxxxxxxxx: expr, $line1_xxxxxxxxxxxxxxxxx: expr, $line2_xxxxxxxxxxxxxxxxx: expr, $line3_xxxxxxxxxxxxxxxxx: expr,) => {};\n }\n \n // #2466\n@@ -113,6 +147,12 @@ macro foo($type_name: ident, $docs: expr) {\n     pub struct $type_name;\n }\n \n+// #2534\n+macro_rules! foo {\n+    ($a:ident : $b:ty) => {};\n+    ($a:ident $b:ident $c:ident) => {};\n+}\n+\n // #2538\n macro_rules! add_message_to_notes {\n     ($msg:expr) => {{"}, {"sha": "793efcb6b0c2fc94f2040ee43170c5aa3c5d2c5f", "filename": "tests/target/macro_rules.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/55162239007a1514dd9c5fe99c377c1929be1039/tests%2Ftarget%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55162239007a1514dd9c5fe99c377c1929be1039/tests%2Ftarget%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacro_rules.rs?ref=55162239007a1514dd9c5fe99c377c1929be1039", "patch": "@@ -1,5 +1,81 @@\n // rustfmt-error_on_line_overflow: false\n \n+macro_rules! m {\n+    () => {};\n+    ($x: ident) => {};\n+    ($m1: ident, $m2: ident, $x: ident) => {};\n+    ($($beginning: ident),*; $middle: ident; $($end: ident),*) => {};\n+    (\n+        $($beginning: ident),*;\n+        $middle: ident;\n+        $($end: ident),*;\n+        $($beginning: ident),*;\n+        $middle: ident;\n+        $($end: ident),*\n+    ) => {};\n+    ($name: ident($($dol: tt $var: ident)*) $($body: tt)*) => {};\n+    (\n+        $($i: ident : $ty: ty, $def: expr, $stb: expr, $($dstring: tt),+);+ $(;)*\n+        $($i: ident : $ty: ty, $def: expr, $stb: expr, $($dstring: tt),+);+ $(;)*\n+    ) => {};\n+    ($foo: tt foo[$attr: meta] $name: ident) => {};\n+    ($foo: tt[$attr: meta] $name: ident) => {};\n+    ($foo: tt &'a[$attr: meta] $name: ident) => {};\n+    ($foo: tt foo #[$attr: meta] $name: ident) => {};\n+    ($foo: tt #[$attr: meta] $name: ident) => {};\n+    ($foo: tt &'a #[$attr: meta] $name: ident) => {};\n+    ($x: tt foo bar foo bar foo bar $y: tt => x * y * z $z: tt, $($a: tt),*) => {};\n+}\n+\n+macro_rules! impl_a_method {\n+    ($n: ident($a: ident : $ta: ty) -> $ret: ty { $body: expr }) => {\n+        fn $n($a: $ta) -> $ret {\n+            $body\n+        }\n+        macro_rules! $n {\n+            ($va: expr) => {\n+                $n($va)\n+            };\n+        }\n+    };\n+    ($n: ident($a: ident : $ta: ty, $b: ident : $tb: ty) -> $ret: ty { $body: expr }) => {\n+        fn $n($a: $ta, $b: $tb) -> $ret {\n+            $body\n+        }\n+        macro_rules! $n {\n+            ($va: expr,$vb: expr) => {\n+                $n($va, $vb)\n+            };\n+        }\n+    };\n+    (\n+        $n: ident($a: ident : $ta: ty, $b: ident : $tb: ty, $c: ident : $tc: ty) ->\n+        $ret: ty { $body: expr }\n+    ) => {\n+        fn $n($a: $ta, $b: $tb, $c: $tc) -> $ret {\n+            $body\n+        }\n+        macro_rules! $n {\n+            ($va: expr,$vb: expr,$vc: expr) => {\n+                $n($va, $vb, $vc)\n+            };\n+        }\n+    };\n+    (\n+        $n: ident($a: ident : $ta: ty, $b: ident : $tb: ty, $c: ident : $tc: ty, $d: ident : $td: ty) ->\n+        $ret: ty { $body: expr }\n+    ) => {\n+        fn $n($a: $ta, $b: $tb, $c: $tc, $d: $td) -> $ret {\n+            $body\n+        }\n+        macro_rules! $n {\n+            ($va: expr,$vb: expr,$vc: expr,$vd: expr) => {\n+                $n($va, $vb, $vc, $vd)\n+            };\n+        }\n+    };\n+}\n+\n macro_rules! m {\n     // a\n     ($expr: expr, $($func: ident)*) => {{\n@@ -104,6 +180,12 @@ macro foo($type_name: ident, $docs: expr) {\n     pub struct $type_name;\n }\n \n+// #2534\n+macro_rules! foo {\n+    ($a: ident : $b: ty) => {};\n+    ($a: ident $b: ident $c: ident) => {};\n+}\n+\n // #2538\n macro_rules! add_message_to_notes {\n     ($msg: expr) => {{"}]}