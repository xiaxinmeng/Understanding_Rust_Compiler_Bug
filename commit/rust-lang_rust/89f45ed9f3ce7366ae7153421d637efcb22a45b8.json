{"sha": "89f45ed9f3ce7366ae7153421d637efcb22a45b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZjQ1ZWQ5ZjNjZTczNjZhZTcxNTM0MjFkNjM3ZWZjYjIyYTQ1Yjg=", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2020-10-05T22:53:00Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2021-03-09T16:54:13Z"}, "message": "Update match branches\n\nThis updates all places where match branches check on StatementKind or UseContext.\nThis doesn't properly implement them, but adds TODOs where they are, and also adds some best\nguesses to what they should be in some cases.", "tree": {"sha": "56d6cb6111edb76012f1d660f935bcc1df776cb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56d6cb6111edb76012f1d660f935bcc1df776cb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89f45ed9f3ce7366ae7153421d637efcb22a45b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89f45ed9f3ce7366ae7153421d637efcb22a45b8", "html_url": "https://github.com/rust-lang/rust/commit/89f45ed9f3ce7366ae7153421d637efcb22a45b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89f45ed9f3ce7366ae7153421d637efcb22a45b8/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72c734d001a157e0fb38e1feebf6748189d3e1b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/72c734d001a157e0fb38e1feebf6748189d3e1b9", "html_url": "https://github.com/rust-lang/rust/commit/72c734d001a157e0fb38e1feebf6748189d3e1b9"}], "stats": {"total": 1370, "additions": 1346, "deletions": 24}, "files": [{"sha": "289629d921545b87bd0167257e0ae8b66d14ee58", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -293,17 +293,15 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 | MutatingUseContext::AsmOutput\n                 | MutatingUseContext::Borrow\n                 | MutatingUseContext::AddressOf\n-                | MutatingUseContext::Projection\n-                | MutatingUseContext::CopyNonOverlapping,\n+                | MutatingUseContext::Projection,\n             )\n             | PlaceContext::NonMutatingUse(\n                 NonMutatingUseContext::Inspect\n                 | NonMutatingUseContext::SharedBorrow\n                 | NonMutatingUseContext::UniqueBorrow\n                 | NonMutatingUseContext::ShallowBorrow\n                 | NonMutatingUseContext::AddressOf\n-                | NonMutatingUseContext::Projection\n-                | NonMutatingUseContext::CopyNonOverlapping,\n+                | NonMutatingUseContext::Projection,\n             ) => {\n                 self.not_ssa(local);\n             }"}, {"sha": "1dafc8cd2c16d24f3c8cc21814cf11ca9dc3337d", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -120,18 +120,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 ref dst,\n                 ref size,\n             }) => {\n-                let dst_val = self.codegen_place(&mut bx, dst.as_ref());\n-                let src_val = self.codegen_place(&mut bx, src.as_ref());\n+                let dst_val = self.codegen_operand(&mut bx, dst);\n+                let src_val = self.codegen_operand(&mut bx, src);\n                 let size_val = self.codegen_operand(&mut bx, size);\n                 let size = size_val.immediate_or_packed_pair(&mut bx);\n+                let dst = dst_val.immediate_or_packed_pair(&mut bx);\n+                let src = src_val.immediate_or_packed_pair(&mut bx);\n+                use crate::MemFlags;\n+                let flags =\n+                    (!MemFlags::UNALIGNED) & (!MemFlags::VOLATILE) & (!MemFlags::NONTEMPORAL);\n                 bx.memcpy(\n-                    dst_val.llval,\n-                    dst_val.align,\n-                    src_val.llval,\n-                    src_val.align,\n+                    dst,\n+                    dst_val.layout.layout.align.pref,\n+                    src,\n+                    src_val.layout.layout.align.pref,\n                     size,\n-                    // TODO probably want to have this change based on alignment above?\n-                    crate::MemFlags::empty(),\n+                    flags,\n                 );\n                 bx\n             }"}, {"sha": "dddda0f611229d005cf45d47521d174631a3f3af", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -1668,7 +1668,7 @@ impl Debug for Statement<'_> {\n                 ref src,\n                 ref dst,\n                 ref size,\n-            }) => write!(fmt, \"copy_nonoverlapping(src={:?}, dst={:?},bytes={:?})\", src, dst, size),\n+            }) => write!(fmt, \"copy_nonoverlapping(src={:?}, dst={:?}, size={:?})\", src, dst, size),\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -1682,8 +1682,8 @@ pub struct Coverage {\n \n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct CopyNonOverlapping<'tcx> {\n-    pub src: Place<'tcx>,\n-    pub dst: Place<'tcx>,\n+    pub src: Operand<'tcx>,\n+    pub dst: Operand<'tcx>,\n     pub size: Operand<'tcx>,\n }\n "}, {"sha": "7bd4b72cc1240414ed4d2717deee4aab1d489ad5", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -441,14 +441,12 @@ macro_rules! make_mir_visitor {\n                       ref $($mutability)? dst,\n                       ref $($mutability)? size,\n                     }) => {\n-                      self.visit_place(\n+                      self.visit_operand(\n                             src,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::CopyNonOverlapping),\n                             location\n                       );\n-                      self.visit_place(\n+                      self.visit_operand(\n                             dst,\n-                            PlaceContext::MutatingUse(MutatingUseContext::CopyNonOverlapping),\n                             location\n                       );\n                       self.visit_operand(size, location)\n@@ -1168,8 +1166,6 @@ pub enum NonMutatingUseContext {\n     ///     f(&x.y);\n     ///\n     Projection,\n-    /// Source from copy_nonoverlapping.\n-    CopyNonOverlapping,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -1199,8 +1195,6 @@ pub enum MutatingUseContext {\n     Projection,\n     /// Retagging, a \"Stacked Borrows\" shadow state operation\n     Retag,\n-    /// Memory written to in copy_nonoverlapping.\n-    CopyNonOverlapping,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}, {"sha": "276d9381e32ae337e86c6f2b0ee1f51544e4b86f", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -92,6 +92,21 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     self.consume_operand(location, input);\n                 }\n             }\n+            StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n+                ref src,\n+                ref dst,\n+                ref size,\n+            }) => {\n+                self.consume_operand(location, src);\n+                self.consume_operand(location, dst);\n+                self.consume_operand(location, size);\n+                match dst {\n+                    Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                        self.mutate_place(location, *place, Deep, JustWrite);\n+                    }\n+                    _ => {}\n+                }\n+            }\n             StatementKind::Nop\n             | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..)"}, {"sha": "539319ab9f25f265ea924892e2ecd148dcf3be01", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -626,6 +626,8 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n                     self.consume_operand(location, (input, span), flow_state);\n                 }\n             }\n+\n+            StatementKind::CopyNonOverlapping(..) => todo!(),\n             StatementKind::Nop\n             | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..)"}, {"sha": "74d7fd84c9e7269b655bf0fc70ed84c198d94f8f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -1520,6 +1520,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n+            StatementKind::CopyNonOverlapping(..) => todo!(),\n             StatementKind::FakeRead(..)\n             | StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)"}, {"sha": "ffa02f855c979032f42a21507544e73835c6a283", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -306,6 +306,8 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::Coverage(..)\n             | mir::StatementKind::Nop => {}\n+\n+            mir::StatementKind::CopyNonOverlapping(..) => todo!(),\n         }\n     }\n "}, {"sha": "e407f394c51ecd42802712133e2a9fa386a1e565", "filename": "compiler/rustc_mir/src/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -150,6 +150,8 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n             | StatementKind::Nop\n             | StatementKind::Retag(..)\n             | StatementKind::StorageLive(..) => {}\n+\n+            StatementKind::CopyNonOverlapping(..) => todo!(),\n         }\n     }\n "}, {"sha": "c14ac74ebadab7c6f72e4902e82ab14de3e7324a", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -319,6 +319,8 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Nop => {}\n+\n+            StatementKind::CopyNonOverlapping(..) => todo!(),\n         }\n     }\n "}, {"sha": "5a3fc9f51611d2281d6bebc362b8a01b3905cbbe", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -113,6 +113,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 M::retag(self, *kind, &dest)?;\n             }\n \n+            // Call CopyNonOverlapping\n+            CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { dst, src, size }) => {\n+                let size = self.eval_operand(size, None)?;\n+\n+                let dst = {\n+                    let dst = self.eval_operand(dst, None)?;\n+                    dst.assert_mem_place(self)\n+                };\n+                let src = {\n+                    let src = self.eval_operand(src, None)?;\n+                    src.assert_mem_place(self)\n+                };\n+                // Not sure how to convert an MPlaceTy<'_, <M as Machine<'_, '_>>::PointerTag>\n+                // to a pointer, or OpTy to a size\n+                self.memory.copy(src, dst, size, /*nonoverlapping*/ true)?;\n+            }\n+\n             // Statements we do not track.\n             AscribeUserType(..) => {}\n "}, {"sha": "1ad7b8fbbd5edde87dcb2e8cca714d6ba7e1bbe4", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -808,6 +808,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::CopyNonOverlapping(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "e7fdd5496cb4085a6201adbc1f1662383a062f52", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -115,6 +115,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::CopyNonOverlapping(..)\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }"}, {"sha": "6656deac967b696edc74d2b45bae2e8db5868f06", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -587,6 +587,7 @@ impl Conflicts<'a> {\n             | StatementKind::FakeRead(..)\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::CopyNonOverlapping(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "f299b6ecc28dc09ee56cfa2890e46795863b6b5b", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -1454,6 +1454,7 @@ impl Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n             | StatementKind::Retag(..)\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n+            | StatementKind::CopyNonOverlapping(..)\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "7125e1516e9fd072c18bc2ca67ad651ae9924247", "filename": "compiler/rustc_mir/src/transform/instrument_coverage.rs", "status": "added", "additions": 1272, "deletions": 0, "changes": 1272, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -0,0 +1,1272 @@\n+use crate::transform::MirPass;\n+use crate::util::pretty;\n+use crate::util::spanview::{self, SpanViewable};\n+\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::hir;\n+use rustc_middle::hir::map::blocks::FnLikeNode;\n+use rustc_middle::ich::StableHashingContext;\n+use rustc_middle::mir;\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::{\n+    AggregateKind, BasicBlock, BasicBlockData, Coverage, CoverageInfo, FakeReadCause, Location,\n+    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n+};\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::def_id::DefId;\n+use rustc_span::source_map::original_sp;\n+use rustc_span::{BytePos, CharPos, Pos, SourceFile, Span, Symbol, SyntaxContext};\n+\n+use std::cmp::Ordering;\n+\n+const ID_SEPARATOR: &str = \",\";\n+\n+/// Inserts `StatementKind::Coverage` statements that either instrument the binary with injected\n+/// counters, via intrinsic `llvm.instrprof.increment`, and/or inject metadata used during codegen\n+/// to construct the coverage map.\n+pub struct InstrumentCoverage;\n+\n+/// The `query` provider for `CoverageInfo`, requested by `codegen_coverage()` (to inject each\n+/// counter) and `FunctionCoverage::new()` (to extract the coverage map metadata from the MIR).\n+pub(crate) fn provide(providers: &mut Providers) {\n+    providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n+}\n+\n+/// The `num_counters` argument to `llvm.instrprof.increment` is the max counter_id + 1, or in\n+/// other words, the number of counter value references injected into the MIR (plus 1 for the\n+/// reserved `ZERO` counter, which uses counter ID `0` when included in an expression). Injected\n+/// counters have a counter ID from `1..num_counters-1`.\n+///\n+/// `num_expressions` is the number of counter expressions added to the MIR body.\n+///\n+/// Both `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n+/// code generate, to lookup counters and expressions by simple u32 indexes.\n+///\n+/// MIR optimization may split and duplicate some BasicBlock sequences, or optimize out some code\n+/// including injected counters. (It is OK if some counters are optimized out, but those counters\n+/// are still included in the total `num_counters` or `num_expressions`.) Simply counting the\n+/// calls may not work; but computing the number of counters or expressions by adding `1` to the\n+/// highest ID (for a given instrumented function) is valid.\n+struct CoverageVisitor {\n+    info: CoverageInfo,\n+}\n+\n+impl Visitor<'_> for CoverageVisitor {\n+    fn visit_coverage(&mut self, coverage: &Coverage, _location: Location) {\n+        match coverage.kind {\n+            CoverageKind::Counter { id, .. } => {\n+                let counter_id = u32::from(id);\n+                self.info.num_counters = std::cmp::max(self.info.num_counters, counter_id + 1);\n+            }\n+            CoverageKind::Expression { id, .. } => {\n+                let expression_index = u32::MAX - u32::from(id);\n+                self.info.num_expressions =\n+                    std::cmp::max(self.info.num_expressions, expression_index + 1);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> CoverageInfo {\n+    let mir_body = tcx.optimized_mir(def_id);\n+\n+    let mut coverage_visitor =\n+        CoverageVisitor { info: CoverageInfo { num_counters: 0, num_expressions: 0 } };\n+\n+    coverage_visitor.visit_body(mir_body);\n+    coverage_visitor.info\n+}\n+\n+impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n+        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+        if mir_body.source.promoted.is_some() {\n+            trace!(\n+                \"InstrumentCoverage skipped for {:?} (already promoted for Miri evaluation)\",\n+                mir_body.source.def_id()\n+            );\n+            return;\n+        }\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(mir_body.source.def_id().expect_local());\n+        let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n+\n+        // Only instrument functions, methods, and closures (not constants since they are evaluated\n+        // at compile time by Miri).\n+        // FIXME(#73156): Handle source code coverage in const eval\n+        if !is_fn_like {\n+            trace!(\n+                \"InstrumentCoverage skipped for {:?} (not an FnLikeNode)\",\n+                mir_body.source.def_id(),\n+            );\n+            return;\n+        }\n+        // FIXME(richkadel): By comparison, the MIR pass `ConstProp` includes associated constants,\n+        // with functions, methods, and closures. I assume Miri is used for associated constants as\n+        // well. If not, we may need to include them here too.\n+\n+        trace!(\"InstrumentCoverage starting for {:?}\", mir_body.source.def_id());\n+        Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n+        trace!(\"InstrumentCoverage starting for {:?}\", mir_body.source.def_id());\n+    }\n+}\n+\n+/// A BasicCoverageBlock (BCB) represents the maximal-length sequence of CFG (MIR) BasicBlocks\n+/// without conditional branches.\n+///\n+/// The BCB allows coverage analysis to be performed on a simplified projection of the underlying\n+/// MIR CFG, without altering the original CFG. Note that running the MIR `SimplifyCfg` transform,\n+/// is not sufficient, and therefore not necessary, since the BCB-based CFG projection is a more\n+/// aggressive simplification. For example:\n+///\n+///   * The BCB CFG projection ignores (trims) branches not relevant to coverage, such as unwind-\n+///     related code that is injected by the Rust compiler but has no physical source code to\n+///     count. This also means a BasicBlock with a `Call` terminator can be merged into its\n+///     primary successor target block, in the same BCB.\n+///   * Some BasicBlock terminators support Rust-specific concerns--like borrow-checking--that are\n+///     not relevant to coverage analysis. `FalseUnwind`, for example, can be treated the same as\n+///     a `Goto`, and merged with its successor into the same BCB.\n+///\n+/// Each BCB with at least one computed `CoverageSpan` will have no more than one `Counter`.\n+/// In some cases, a BCB's execution count can be computed by `CounterExpression`. Additional\n+/// disjoint `CoverageSpan`s in a BCB can also be counted by `CounterExpression` (by adding `ZERO`\n+/// to the BCB's primary counter or expression).\n+///\n+/// Dominator/dominated relationships (which are fundamental to the coverage analysis algorithm)\n+/// between two BCBs can be computed using the `mir::Body` `dominators()` with any `BasicBlock`\n+/// member of each BCB. (For consistency, BCB's use the first `BasicBlock`, also referred to as the\n+/// `bcb_leader_bb`.)\n+///\n+/// The BCB CFG projection is critical to simplifying the coverage analysis by ensuring graph\n+/// path-based queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch\n+/// (control flow) significance.\n+#[derive(Debug, Clone)]\n+struct BasicCoverageBlock {\n+    pub blocks: Vec<BasicBlock>,\n+}\n+\n+impl BasicCoverageBlock {\n+    pub fn leader_bb(&self) -> BasicBlock {\n+        self.blocks[0]\n+    }\n+\n+    pub fn id(&self) -> String {\n+        format!(\n+            \"@{}\",\n+            self.blocks\n+                .iter()\n+                .map(|bb| bb.index().to_string())\n+                .collect::<Vec<_>>()\n+                .join(ID_SEPARATOR)\n+        )\n+    }\n+}\n+\n+struct BasicCoverageBlocks {\n+    vec: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n+}\n+\n+impl BasicCoverageBlocks {\n+    pub fn from_mir(mir_body: &mir::Body<'tcx>) -> Self {\n+        let mut basic_coverage_blocks =\n+            BasicCoverageBlocks { vec: IndexVec::from_elem_n(None, mir_body.basic_blocks().len()) };\n+        basic_coverage_blocks.extract_from_mir(mir_body);\n+        basic_coverage_blocks\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = &BasicCoverageBlock> {\n+        self.vec.iter().filter_map(|option| option.as_ref())\n+    }\n+\n+    fn extract_from_mir(&mut self, mir_body: &mir::Body<'tcx>) {\n+        // Traverse the CFG but ignore anything following an `unwind`\n+        let cfg_without_unwind = ShortCircuitPreorder::new(mir_body, |term_kind| {\n+            let mut successors = term_kind.successors();\n+            match &term_kind {\n+                // SwitchInt successors are never unwind, and all of them should be traversed.\n+\n+                // NOTE: TerminatorKind::FalseEdge targets from SwitchInt don't appear to be\n+                // helpful in identifying unreachable code. I did test the theory, but the following\n+                // changes were not beneficial. (I assumed that replacing some constants with\n+                // non-deterministic variables might effect which blocks were targeted by a\n+                // `FalseEdge` `imaginary_target`. It did not.)\n+                //\n+                // Also note that, if there is a way to identify BasicBlocks that are part of the\n+                // MIR CFG, but not actually reachable, here are some other things to consider:\n+                //\n+                // Injecting unreachable code regions will probably require computing the set\n+                // difference between the basic blocks found without filtering out unreachable\n+                // blocks, and the basic blocks found with the filter; then computing the\n+                // `CoverageSpans` without the filter; and then injecting `Counter`s or\n+                // `CounterExpression`s for blocks that are not unreachable, or injecting\n+                // `Unreachable` code regions otherwise. This seems straightforward, but not\n+                // trivial.\n+                //\n+                // Alternatively, we might instead want to leave the unreachable blocks in\n+                // (bypass the filter here), and inject the counters. This will result in counter\n+                // values of zero (0) for unreachable code (and, notably, the code will be displayed\n+                // with a red background by `llvm-cov show`).\n+                //\n+                // TerminatorKind::SwitchInt { .. } => {\n+                //     let some_imaginary_target = successors.clone().find_map(|&successor| {\n+                //         let term = mir_body.basic_blocks()[successor].terminator();\n+                //         if let TerminatorKind::FalseEdge { imaginary_target, .. } = term.kind {\n+                //             if mir_body.predecessors()[imaginary_target].len() == 1 {\n+                //                 return Some(imaginary_target);\n+                //             }\n+                //         }\n+                //         None\n+                //     });\n+                //     if let Some(imaginary_target) = some_imaginary_target {\n+                //         box successors.filter(move |&&successor| successor != imaginary_target)\n+                //     } else {\n+                //         box successors\n+                //     }\n+                // }\n+                //\n+                // Note this also required changing the closure signature for the\n+                // `ShortCurcuitPreorder` to:\n+                //\n+                // F: Fn(&'tcx TerminatorKind<'tcx>) -> Box<dyn Iterator<Item = &BasicBlock> + 'a>,\n+                TerminatorKind::SwitchInt { .. } => successors,\n+\n+                // For all other kinds, return only the first successor, if any, and ignore unwinds\n+                _ => successors.next().into_iter().chain(&[]),\n+            }\n+        });\n+\n+        // Walk the CFG using a Preorder traversal, which starts from `START_BLOCK` and follows\n+        // each block terminator's `successors()`. Coverage spans must map to actual source code,\n+        // so compiler generated blocks and paths can be ignored. To that end the CFG traversal\n+        // intentionally omits unwind paths.\n+        let mut blocks = Vec::new();\n+        for (bb, data) in cfg_without_unwind {\n+            if let Some(last) = blocks.last() {\n+                let predecessors = &mir_body.predecessors()[bb];\n+                if predecessors.len() > 1 || !predecessors.contains(last) {\n+                    // The `bb` has more than one _incoming_ edge, and should start its own\n+                    // `BasicCoverageBlock`. (Note, the `blocks` vector does not yet include `bb`;\n+                    // it contains a sequence of one or more sequential blocks with no intermediate\n+                    // branches in or out. Save these as a new `BasicCoverageBlock` before starting\n+                    // the new one.)\n+                    self.add_basic_coverage_block(blocks.split_off(0));\n+                    debug!(\n+                        \"  because {}\",\n+                        if predecessors.len() > 1 {\n+                            \"predecessors.len() > 1\".to_owned()\n+                        } else {\n+                            format!(\"bb {} is not in precessors: {:?}\", bb.index(), predecessors)\n+                        }\n+                    );\n+                }\n+            }\n+            blocks.push(bb);\n+\n+            let term = data.terminator();\n+\n+            match term.kind {\n+                TerminatorKind::Return { .. }\n+                | TerminatorKind::Abort\n+                | TerminatorKind::Assert { .. }\n+                | TerminatorKind::Yield { .. }\n+                | TerminatorKind::SwitchInt { .. } => {\n+                    // The `bb` has more than one _outgoing_ edge, or exits the function. Save the\n+                    // current sequence of `blocks` gathered to this point, as a new\n+                    // `BasicCoverageBlock`.\n+                    self.add_basic_coverage_block(blocks.split_off(0));\n+                    debug!(\"  because term.kind = {:?}\", term.kind);\n+                    // Note that this condition is based on `TerminatorKind`, even though it\n+                    // theoretically boils down to `successors().len() != 1`; that is, either zero\n+                    // (e.g., `Return`, `Abort`) or multiple successors (e.g., `SwitchInt`), but\n+                    // since the Coverage graph (the BCB CFG projection) ignores things like unwind\n+                    // branches (which exist in the `Terminator`s `successors()` list) checking the\n+                    // number of successors won't work.\n+                }\n+                TerminatorKind::Goto { .. }\n+                | TerminatorKind::Resume\n+                | TerminatorKind::Unreachable\n+                | TerminatorKind::Drop { .. }\n+                | TerminatorKind::DropAndReplace { .. }\n+                | TerminatorKind::Call { .. }\n+                | TerminatorKind::GeneratorDrop\n+                | TerminatorKind::FalseEdge { .. }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::InlineAsm { .. } => {}\n+            }\n+        }\n+\n+        if !blocks.is_empty() {\n+            // process any remaining blocks into a final `BasicCoverageBlock`\n+            self.add_basic_coverage_block(blocks.split_off(0));\n+            debug!(\"  because the end of the CFG was reached while traversing\");\n+        }\n+    }\n+\n+    fn add_basic_coverage_block(&mut self, blocks: Vec<BasicBlock>) {\n+        let leader_bb = blocks[0];\n+        let bcb = BasicCoverageBlock { blocks };\n+        debug!(\"adding BCB: {:?}\", bcb);\n+        self.vec[leader_bb] = Some(bcb);\n+    }\n+}\n+\n+impl std::ops::Index<BasicBlock> for BasicCoverageBlocks {\n+    type Output = BasicCoverageBlock;\n+\n+    fn index(&self, index: BasicBlock) -> &Self::Output {\n+        self.vec[index].as_ref().expect(\"is_some if BasicBlock is a BasicCoverageBlock leader\")\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+enum CoverageStatement {\n+    Statement(BasicBlock, Span, usize),\n+    Terminator(BasicBlock, Span),\n+}\n+\n+impl CoverageStatement {\n+    pub fn format(&self, tcx: TyCtxt<'tcx>, mir_body: &'a mir::Body<'tcx>) -> String {\n+        match *self {\n+            Self::Statement(bb, span, stmt_index) => {\n+                let stmt = &mir_body.basic_blocks()[bb].statements[stmt_index];\n+                format!(\n+                    \"{}: @{}[{}]: {:?}\",\n+                    spanview::source_range_no_file(tcx, &span),\n+                    bb.index(),\n+                    stmt_index,\n+                    stmt\n+                )\n+            }\n+            Self::Terminator(bb, span) => {\n+                let term = mir_body.basic_blocks()[bb].terminator();\n+                format!(\n+                    \"{}: @{}.{}: {:?}\",\n+                    spanview::source_range_no_file(tcx, &span),\n+                    bb.index(),\n+                    term_type(&term.kind),\n+                    term.kind\n+                )\n+            }\n+        }\n+    }\n+\n+    pub fn span(&self) -> &Span {\n+        match self {\n+            Self::Statement(_, span, _) | Self::Terminator(_, span) => span,\n+        }\n+    }\n+}\n+\n+fn term_type(kind: &TerminatorKind<'tcx>) -> &'static str {\n+    match kind {\n+        TerminatorKind::Goto { .. } => \"Goto\",\n+        TerminatorKind::SwitchInt { .. } => \"SwitchInt\",\n+        TerminatorKind::Resume => \"Resume\",\n+        TerminatorKind::Abort => \"Abort\",\n+        TerminatorKind::Return => \"Return\",\n+        TerminatorKind::Unreachable => \"Unreachable\",\n+        TerminatorKind::Drop { .. } => \"Drop\",\n+        TerminatorKind::DropAndReplace { .. } => \"DropAndReplace\",\n+        TerminatorKind::Call { .. } => \"Call\",\n+        TerminatorKind::Assert { .. } => \"Assert\",\n+        TerminatorKind::Yield { .. } => \"Yield\",\n+        TerminatorKind::GeneratorDrop => \"GeneratorDrop\",\n+        TerminatorKind::FalseEdge { .. } => \"FalseEdge\",\n+        TerminatorKind::FalseUnwind { .. } => \"FalseUnwind\",\n+        TerminatorKind::InlineAsm { .. } => \"InlineAsm\",\n+    }\n+}\n+\n+/// A BCB is deconstructed into one or more `Span`s. Each `Span` maps to a `CoverageSpan` that\n+/// references the originating BCB and one or more MIR `Statement`s and/or `Terminator`s.\n+/// Initially, the `Span`s come from the `Statement`s and `Terminator`s, but subsequent\n+/// transforms can combine adjacent `Span`s and `CoverageSpan` from the same BCB, merging the\n+/// `CoverageStatement` vectors, and the `Span`s to cover the extent of the combined `Span`s.\n+///\n+/// Note: A `CoverageStatement` merged into another CoverageSpan may come from a `BasicBlock` that\n+/// is not part of the `CoverageSpan` bcb if the statement was included because it's `Span` matches\n+/// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n+/// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n+#[derive(Debug, Clone)]\n+struct CoverageSpan {\n+    span: Span,\n+    bcb_leader_bb: BasicBlock,\n+    coverage_statements: Vec<CoverageStatement>,\n+    is_closure: bool,\n+}\n+\n+impl CoverageSpan {\n+    pub fn for_statement(\n+        statement: &Statement<'tcx>,\n+        span: Span,\n+        bcb: &BasicCoverageBlock,\n+        bb: BasicBlock,\n+        stmt_index: usize,\n+    ) -> Self {\n+        let is_closure = match statement.kind {\n+            StatementKind::Assign(box (\n+                _,\n+                Rvalue::Aggregate(box AggregateKind::Closure(_, _), _),\n+            )) => true,\n+            _ => false,\n+        };\n+\n+        Self {\n+            span,\n+            bcb_leader_bb: bcb.leader_bb(),\n+            coverage_statements: vec![CoverageStatement::Statement(bb, span, stmt_index)],\n+            is_closure,\n+        }\n+    }\n+\n+    pub fn for_terminator(span: Span, bcb: &'a BasicCoverageBlock, bb: BasicBlock) -> Self {\n+        Self {\n+            span,\n+            bcb_leader_bb: bcb.leader_bb(),\n+            coverage_statements: vec![CoverageStatement::Terminator(bb, span)],\n+            is_closure: false,\n+        }\n+    }\n+\n+    pub fn merge_from(&mut self, mut other: CoverageSpan) {\n+        debug_assert!(self.is_mergeable(&other));\n+        self.span = self.span.to(other.span);\n+        if other.is_closure {\n+            self.is_closure = true;\n+        }\n+        self.coverage_statements.append(&mut other.coverage_statements);\n+    }\n+\n+    pub fn cutoff_statements_at(&mut self, cutoff_pos: BytePos) {\n+        self.coverage_statements.retain(|covstmt| covstmt.span().hi() <= cutoff_pos);\n+        if let Some(highest_covstmt) =\n+            self.coverage_statements.iter().max_by_key(|covstmt| covstmt.span().hi())\n+        {\n+            self.span = self.span.with_hi(highest_covstmt.span().hi());\n+        }\n+    }\n+\n+    pub fn is_dominated_by(\n+        &self,\n+        other: &CoverageSpan,\n+        dominators: &Dominators<BasicBlock>,\n+    ) -> bool {\n+        debug_assert!(!self.is_in_same_bcb(other));\n+        dominators.is_dominated_by(self.bcb_leader_bb, other.bcb_leader_bb)\n+    }\n+\n+    pub fn is_mergeable(&self, other: &Self) -> bool {\n+        self.is_in_same_bcb(other) && !(self.is_closure || other.is_closure)\n+    }\n+\n+    pub fn is_in_same_bcb(&self, other: &Self) -> bool {\n+        self.bcb_leader_bb == other.bcb_leader_bb\n+    }\n+}\n+\n+struct Instrumentor<'a, 'tcx> {\n+    pass_name: &'a str,\n+    tcx: TyCtxt<'tcx>,\n+    mir_body: &'a mut mir::Body<'tcx>,\n+    hir_body: &'tcx rustc_hir::Body<'tcx>,\n+    dominators: Option<Dominators<BasicBlock>>,\n+    basic_coverage_blocks: Option<BasicCoverageBlocks>,\n+    function_source_hash: Option<u64>,\n+    next_counter_id: u32,\n+    num_expressions: u32,\n+}\n+\n+impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n+    fn new(pass_name: &'a str, tcx: TyCtxt<'tcx>, mir_body: &'a mut mir::Body<'tcx>) -> Self {\n+        let hir_body = hir_body(tcx, mir_body.source.def_id());\n+        Self {\n+            pass_name,\n+            tcx,\n+            mir_body,\n+            hir_body,\n+            dominators: None,\n+            basic_coverage_blocks: None,\n+            function_source_hash: None,\n+            next_counter_id: CounterValueReference::START.as_u32(),\n+            num_expressions: 0,\n+        }\n+    }\n+\n+    /// Counter IDs start from one and go up.\n+    fn next_counter(&mut self) -> CounterValueReference {\n+        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n+        let next = self.next_counter_id;\n+        self.next_counter_id += 1;\n+        CounterValueReference::from(next)\n+    }\n+\n+    /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The counter\n+    /// expression operand IDs must be unique across both types.\n+    fn next_expression(&mut self) -> InjectedExpressionIndex {\n+        assert!(self.next_counter_id < u32::MAX - self.num_expressions);\n+        let next = u32::MAX - self.num_expressions;\n+        self.num_expressions += 1;\n+        InjectedExpressionIndex::from(next)\n+    }\n+\n+    fn dominators(&self) -> &Dominators<BasicBlock> {\n+        self.dominators.as_ref().expect(\"dominators must be initialized before calling\")\n+    }\n+\n+    fn basic_coverage_blocks(&self) -> &BasicCoverageBlocks {\n+        self.basic_coverage_blocks\n+            .as_ref()\n+            .expect(\"basic_coverage_blocks must be initialized before calling\")\n+    }\n+\n+    fn function_source_hash(&mut self) -> u64 {\n+        match self.function_source_hash {\n+            Some(hash) => hash,\n+            None => {\n+                let hash = hash_mir_source(self.tcx, self.hir_body);\n+                self.function_source_hash.replace(hash);\n+                hash\n+            }\n+        }\n+    }\n+\n+    fn inject_counters(&mut self) {\n+        let tcx = self.tcx;\n+        let source_map = tcx.sess.source_map();\n+        let def_id = self.mir_body.source.def_id();\n+        let mir_body = &self.mir_body;\n+        let body_span = self.body_span();\n+        let source_file = source_map.lookup_source_file(body_span.lo());\n+        let file_name = Symbol::intern(&source_file.name.to_string());\n+\n+        debug!(\"instrumenting {:?}, span: {}\", def_id, source_map.span_to_string(body_span));\n+\n+        self.dominators.replace(mir_body.dominators());\n+        self.basic_coverage_blocks.replace(BasicCoverageBlocks::from_mir(mir_body));\n+\n+        let coverage_spans = self.coverage_spans();\n+\n+        let span_viewables = if pretty::dump_enabled(tcx, self.pass_name, def_id) {\n+            Some(self.span_viewables(&coverage_spans))\n+        } else {\n+            None\n+        };\n+\n+        // Inject a counter for each `CoverageSpan`. There can be multiple `CoverageSpan`s for a\n+        // given BCB, but only one actual counter needs to be incremented per BCB. `bb_counters`\n+        // maps each `bcb_leader_bb` to its `Counter`, when injected. Subsequent `CoverageSpan`s\n+        // for a BCB that already has a `Counter` will inject a `CounterExpression` instead, and\n+        // compute its value by adding `ZERO` to the BCB `Counter` value.\n+        let mut bb_counters = IndexVec::from_elem_n(None, mir_body.basic_blocks().len());\n+        for CoverageSpan { span, bcb_leader_bb: bb, .. } in coverage_spans {\n+            if let Some(&counter_operand) = bb_counters[bb].as_ref() {\n+                let expression =\n+                    self.make_expression(counter_operand, Op::Add, ExpressionOperandId::ZERO);\n+                debug!(\n+                    \"Injecting counter expression {:?} at: {:?}:\\n{}\\n==========\",\n+                    expression,\n+                    span,\n+                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n+                );\n+                self.inject_statement(file_name, &source_file, expression, span, bb);\n+            } else {\n+                let counter = self.make_counter();\n+                debug!(\n+                    \"Injecting counter {:?} at: {:?}:\\n{}\\n==========\",\n+                    counter,\n+                    span,\n+                    source_map.span_to_snippet(span).expect(\"Error getting source for span\"),\n+                );\n+                let counter_operand = counter.as_operand_id();\n+                bb_counters[bb] = Some(counter_operand);\n+                self.inject_statement(file_name, &source_file, counter, span, bb);\n+            }\n+        }\n+\n+        if let Some(span_viewables) = span_viewables {\n+            let mut file = pretty::create_dump_file(\n+                tcx,\n+                \"html\",\n+                None,\n+                self.pass_name,\n+                &0,\n+                self.mir_body.source,\n+            )\n+            .expect(\"Unexpected error creating MIR spanview HTML file\");\n+            let crate_name = tcx.crate_name(def_id.krate);\n+            let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n+            let title = format!(\"{}.{} - Coverage Spans\", crate_name, item_name);\n+            spanview::write_document(tcx, def_id, span_viewables, &title, &mut file)\n+                .expect(\"Unexpected IO error dumping coverage spans as HTML\");\n+        }\n+    }\n+\n+    fn make_counter(&mut self) -> CoverageKind {\n+        CoverageKind::Counter {\n+            function_source_hash: self.function_source_hash(),\n+            id: self.next_counter(),\n+        }\n+    }\n+\n+    fn make_expression(\n+        &mut self,\n+        lhs: ExpressionOperandId,\n+        op: Op,\n+        rhs: ExpressionOperandId,\n+    ) -> CoverageKind {\n+        CoverageKind::Expression { id: self.next_expression(), lhs, op, rhs }\n+    }\n+\n+    fn inject_statement(\n+        &mut self,\n+        file_name: Symbol,\n+        source_file: &Lrc<SourceFile>,\n+        coverage_kind: CoverageKind,\n+        span: Span,\n+        block: BasicBlock,\n+    ) {\n+        let code_region = make_code_region(file_name, source_file, span);\n+        debug!(\"  injecting statement {:?} covering {:?}\", coverage_kind, code_region);\n+\n+        let data = &mut self.mir_body[block];\n+        let source_info = data.terminator().source_info;\n+        let statement = Statement {\n+            source_info,\n+            kind: StatementKind::Coverage(box Coverage { kind: coverage_kind, code_region }),\n+        };\n+        data.statements.push(statement);\n+    }\n+\n+    /// Converts the computed `BasicCoverageBlock`s into `SpanViewable`s.\n+    fn span_viewables(&self, coverage_spans: &Vec<CoverageSpan>) -> Vec<SpanViewable> {\n+        let tcx = self.tcx;\n+        let mir_body = &self.mir_body;\n+        let mut span_viewables = Vec::new();\n+        for coverage_span in coverage_spans {\n+            let bcb = self.bcb_from_coverage_span(coverage_span);\n+            let CoverageSpan { span, bcb_leader_bb: bb, coverage_statements, .. } = coverage_span;\n+            let id = bcb.id();\n+            let mut sorted_coverage_statements = coverage_statements.clone();\n+            sorted_coverage_statements.sort_unstable_by_key(|covstmt| match *covstmt {\n+                CoverageStatement::Statement(bb, _, index) => (bb, index),\n+                CoverageStatement::Terminator(bb, _) => (bb, usize::MAX),\n+            });\n+            let tooltip = sorted_coverage_statements\n+                .iter()\n+                .map(|covstmt| covstmt.format(tcx, mir_body))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            span_viewables.push(SpanViewable { bb: *bb, span: *span, id, tooltip });\n+        }\n+        span_viewables\n+    }\n+\n+    #[inline(always)]\n+    fn bcb_from_coverage_span(&self, coverage_span: &CoverageSpan) -> &BasicCoverageBlock {\n+        &self.basic_coverage_blocks()[coverage_span.bcb_leader_bb]\n+    }\n+\n+    #[inline(always)]\n+    fn body_span(&self) -> Span {\n+        self.hir_body.value.span\n+    }\n+\n+    // Generate a set of `CoverageSpan`s from the filtered set of `Statement`s and `Terminator`s of\n+    // the `BasicBlock`(s) in the given `BasicCoverageBlock`. One `CoverageSpan` is generated for\n+    // each `Statement` and `Terminator`. (Note that subsequent stages of coverage analysis will\n+    // merge some `CoverageSpan`s, at which point a `CoverageSpan` may represent multiple\n+    // `Statement`s and/or `Terminator`s.)\n+    fn extract_spans(&self, bcb: &'a BasicCoverageBlock) -> Vec<CoverageSpan> {\n+        let body_span = self.body_span();\n+        let mir_basic_blocks = self.mir_body.basic_blocks();\n+        bcb.blocks\n+            .iter()\n+            .map(|bbref| {\n+                let bb = *bbref;\n+                let data = &mir_basic_blocks[bb];\n+                data.statements\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(move |(index, statement)| {\n+                        filtered_statement_span(statement, body_span).map(|span| {\n+                            CoverageSpan::for_statement(statement, span, bcb, bb, index)\n+                        })\n+                    })\n+                    .chain(\n+                        filtered_terminator_span(data.terminator(), body_span)\n+                            .map(|span| CoverageSpan::for_terminator(span, bcb, bb)),\n+                    )\n+            })\n+            .flatten()\n+            .collect()\n+    }\n+\n+    /// Generate a minimal set of `CoverageSpan`s, each representing a contiguous code region to be\n+    /// counted.\n+    ///\n+    /// The basic steps are:\n+    ///\n+    /// 1. Extract an initial set of spans from the `Statement`s and `Terminator`s of each\n+    ///    `BasicCoverageBlock`.\n+    /// 2. Sort the spans by span.lo() (starting position). Spans that start at the same position\n+    ///    are sorted with longer spans before shorter spans; and equal spans are sorted\n+    ///    (deterministically) based on \"dominator\" relationship (if any).\n+    /// 3. Traverse the spans in sorted order to identify spans that can be dropped (for instance,\n+    ///    if another span or spans are already counting the same code region), or should be merged\n+    ///    into a broader combined span (because it represents a contiguous, non-branching, and\n+    ///    uninterrupted region of source code).\n+    ///\n+    ///    Closures are exposed in their enclosing functions as `Assign` `Rvalue`s, and since\n+    ///    closures have their own MIR, their `Span` in their enclosing function should be left\n+    ///    \"uncovered\".\n+    ///\n+    /// Note the resulting vector of `CoverageSpan`s does may not be fully sorted (and does not need\n+    /// to be).\n+    fn coverage_spans(&self) -> Vec<CoverageSpan> {\n+        let mut initial_spans =\n+            Vec::<CoverageSpan>::with_capacity(self.mir_body.basic_blocks().len() * 2);\n+        for bcb in self.basic_coverage_blocks().iter() {\n+            for coverage_span in self.extract_spans(bcb) {\n+                initial_spans.push(coverage_span);\n+            }\n+        }\n+\n+        if initial_spans.is_empty() {\n+            // This can happen if, for example, the function is unreachable (contains only a\n+            // `BasicBlock`(s) with an `Unreachable` terminator).\n+            return initial_spans;\n+        }\n+\n+        initial_spans.sort_unstable_by(|a, b| {\n+            if a.span.lo() == b.span.lo() {\n+                if a.span.hi() == b.span.hi() {\n+                    if a.is_in_same_bcb(b) {\n+                        Some(Ordering::Equal)\n+                    } else {\n+                        // Sort equal spans by dominator relationship, in reverse order (so\n+                        // dominators always come after the dominated equal spans). When later\n+                        // comparing two spans in order, the first will either dominate the second,\n+                        // or they will have no dominator relationship.\n+                        self.dominators().rank_partial_cmp(b.bcb_leader_bb, a.bcb_leader_bb)\n+                    }\n+                } else {\n+                    // Sort hi() in reverse order so shorter spans are attempted after longer spans.\n+                    // This guarantees that, if a `prev` span overlaps, and is not equal to, a `curr`\n+                    // span, the prev span either extends further left of the curr span, or they\n+                    // start at the same position and the prev span extends further right of the end\n+                    // of the curr span.\n+                    b.span.hi().partial_cmp(&a.span.hi())\n+                }\n+            } else {\n+                a.span.lo().partial_cmp(&b.span.lo())\n+            }\n+            .unwrap()\n+        });\n+\n+        let refinery = CoverageSpanRefinery::from_sorted_spans(initial_spans, self.dominators());\n+        refinery.to_refined_spans()\n+    }\n+}\n+\n+struct CoverageSpanRefinery<'a> {\n+    sorted_spans_iter: std::vec::IntoIter<CoverageSpan>,\n+    dominators: &'a Dominators<BasicBlock>,\n+    some_curr: Option<CoverageSpan>,\n+    curr_original_span: Span,\n+    some_prev: Option<CoverageSpan>,\n+    prev_original_span: Span,\n+    pending_dups: Vec<CoverageSpan>,\n+    refined_spans: Vec<CoverageSpan>,\n+}\n+\n+impl<'a> CoverageSpanRefinery<'a> {\n+    fn from_sorted_spans(\n+        sorted_spans: Vec<CoverageSpan>,\n+        dominators: &'a Dominators<BasicBlock>,\n+    ) -> Self {\n+        let refined_spans = Vec::with_capacity(sorted_spans.len());\n+        let mut sorted_spans_iter = sorted_spans.into_iter();\n+        let prev = sorted_spans_iter.next().expect(\"at least one span\");\n+        let prev_original_span = prev.span;\n+        Self {\n+            sorted_spans_iter,\n+            dominators,\n+            refined_spans,\n+            some_curr: None,\n+            curr_original_span: Span::with_root_ctxt(BytePos(0), BytePos(0)),\n+            some_prev: Some(prev),\n+            prev_original_span,\n+            pending_dups: Vec::new(),\n+        }\n+    }\n+\n+    /// Iterate through the sorted `CoverageSpan`s, and return the refined list of merged and\n+    /// de-duplicated `CoverageSpan`s.\n+    fn to_refined_spans(mut self) -> Vec<CoverageSpan> {\n+        while self.next_coverage_span() {\n+            if self.curr().is_mergeable(self.prev()) {\n+                debug!(\"  same bcb (and neither is a closure), merge with prev={:?}\", self.prev());\n+                let prev = self.take_prev();\n+                self.curr_mut().merge_from(prev);\n+            // Note that curr.span may now differ from curr_original_span\n+            } else if self.prev_ends_before_curr() {\n+                debug!(\n+                    \"  different bcbs and disjoint spans, so keep curr for next iter, and add \\\n+                    prev={:?}\",\n+                    self.prev()\n+                );\n+                let prev = self.take_prev();\n+                self.add_refined_span(prev);\n+            } else if self.prev().is_closure {\n+                // drop any equal or overlapping span (`curr`) and keep `prev` to test again in the\n+                // next iter\n+                debug!(\n+                    \"  curr overlaps a closure (prev). Drop curr and keep prev for next iter. \\\n+                    prev={:?}\",\n+                    self.prev()\n+                );\n+                self.discard_curr();\n+            } else if self.curr().is_closure {\n+                self.carve_out_span_for_closure();\n+            } else if self.prev_original_span == self.curr().span {\n+                self.hold_pending_dups_unless_dominated();\n+            } else {\n+                self.cutoff_prev_at_overlapping_curr();\n+            }\n+        }\n+        debug!(\"    AT END, adding last prev={:?}\", self.prev());\n+        let pending_dups = self.pending_dups.split_off(0);\n+        for dup in pending_dups.into_iter() {\n+            debug!(\"    ...adding at least one pending dup={:?}\", dup);\n+            self.add_refined_span(dup);\n+        }\n+        let prev = self.take_prev();\n+        self.add_refined_span(prev);\n+\n+        // FIXME(richkadel): Replace some counters with expressions if they can be calculated based\n+        // on branching. (For example, one branch of a SwitchInt can be computed from the counter\n+        // for the CoverageSpan just prior to the SwitchInt minus the sum of the counters of all\n+        // other branches).\n+\n+        self.to_refined_spans_without_closures()\n+    }\n+\n+    fn add_refined_span(&mut self, coverage_span: CoverageSpan) {\n+        self.refined_spans.push(coverage_span);\n+    }\n+\n+    /// Remove `CoverageSpan`s derived from closures, originally added to ensure the coverage\n+    /// regions for the current function leave room for the closure's own coverage regions\n+    /// (injected separately, from the closure's own MIR).\n+    fn to_refined_spans_without_closures(mut self) -> Vec<CoverageSpan> {\n+        self.refined_spans.retain(|covspan| !covspan.is_closure);\n+        self.refined_spans\n+    }\n+\n+    fn curr(&self) -> &CoverageSpan {\n+        self.some_curr\n+            .as_ref()\n+            .unwrap_or_else(|| bug!(\"invalid attempt to unwrap a None some_curr\"))\n+    }\n+\n+    fn curr_mut(&mut self) -> &mut CoverageSpan {\n+        self.some_curr\n+            .as_mut()\n+            .unwrap_or_else(|| bug!(\"invalid attempt to unwrap a None some_curr\"))\n+    }\n+\n+    fn prev(&self) -> &CoverageSpan {\n+        self.some_prev\n+            .as_ref()\n+            .unwrap_or_else(|| bug!(\"invalid attempt to unwrap a None some_prev\"))\n+    }\n+\n+    fn prev_mut(&mut self) -> &mut CoverageSpan {\n+        self.some_prev\n+            .as_mut()\n+            .unwrap_or_else(|| bug!(\"invalid attempt to unwrap a None some_prev\"))\n+    }\n+\n+    fn take_prev(&mut self) -> CoverageSpan {\n+        self.some_prev.take().unwrap_or_else(|| bug!(\"invalid attempt to unwrap a None some_prev\"))\n+    }\n+\n+    /// If there are `pending_dups` but `prev` is not a matching dup (`prev.span` doesn't match the\n+    /// `pending_dups` spans), then one of the following two things happened during the previous\n+    /// iteration:\n+    ///   * the `span` of prev was modified (by `curr_mut().merge_from(prev)`); or\n+    ///   * the `span` of prev advanced past the end of the span of pending_dups\n+    ///     (`prev().span.hi() <= curr().span.lo()`)\n+    /// In either case, no more spans will match the span of `pending_dups`, so\n+    /// add the `pending_dups` if they don't overlap `curr`, and clear the list.\n+    fn check_pending_dups(&mut self) {\n+        if let Some(dup) = self.pending_dups.last() {\n+            if dup.span != self.prev().span {\n+                debug!(\n+                    \"    SAME spans, but pending_dups are NOT THE SAME, so BCBs matched on \\\n+                    previous iteration, or prev started a new disjoint span\"\n+                );\n+                if dup.span.hi() <= self.curr().span.lo() {\n+                    let pending_dups = self.pending_dups.split_off(0);\n+                    for dup in pending_dups.into_iter() {\n+                        debug!(\"    ...adding at least one pending={:?}\", dup);\n+                        self.add_refined_span(dup);\n+                    }\n+                } else {\n+                    self.pending_dups.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Advance `prev` to `curr` (if any), and `curr` to the next `CoverageSpan` in sorted order.\n+    fn next_coverage_span(&mut self) -> bool {\n+        if let Some(curr) = self.some_curr.take() {\n+            self.some_prev = Some(curr);\n+            self.prev_original_span = self.curr_original_span;\n+        }\n+        while let Some(curr) = self.sorted_spans_iter.next() {\n+            debug!(\"FOR curr={:?}\", curr);\n+            if self.prev_starts_after_next(&curr) {\n+                debug!(\n+                    \"  prev.span starts after curr.span, so curr will be dropped (skipping past \\\n+                    closure?); prev={:?}\",\n+                    self.prev()\n+                );\n+            } else {\n+                // Save a copy of the original span for `curr` in case the `CoverageSpan` is changed\n+                // by `self.curr_mut().merge_from(prev)`.\n+                self.curr_original_span = curr.span;\n+                self.some_curr.replace(curr);\n+                self.check_pending_dups();\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// If called, then the next call to `next_coverage_span()` will *not* update `prev` with the\n+    /// `curr` coverage span.\n+    fn discard_curr(&mut self) {\n+        self.some_curr = None;\n+    }\n+\n+    /// Returns true if the curr span should be skipped because prev has already advanced beyond the\n+    /// end of curr. This can only happen if a prior iteration updated `prev` to skip past a region\n+    /// of code, such as skipping past a closure.\n+    fn prev_starts_after_next(&self, next_curr: &CoverageSpan) -> bool {\n+        self.prev().span.lo() > next_curr.span.lo()\n+    }\n+\n+    /// Returns true if the curr span starts past the end of the prev span, which means they don't\n+    /// overlap, so we now know the prev can be added to the refined coverage spans.\n+    fn prev_ends_before_curr(&self) -> bool {\n+        self.prev().span.hi() <= self.curr().span.lo()\n+    }\n+\n+    /// If `prev`s span extends left of the closure (`curr`), carve out the closure's\n+    /// span from `prev`'s span. (The closure's coverage counters will be injected when\n+    /// processing the closure's own MIR.) Add the portion of the span to the left of the\n+    /// closure; and if the span extends to the right of the closure, update `prev` to\n+    /// that portion of the span. For any `pending_dups`, repeat the same process.\n+    fn carve_out_span_for_closure(&mut self) {\n+        let curr_span = self.curr().span;\n+        let left_cutoff = curr_span.lo();\n+        let right_cutoff = curr_span.hi();\n+        let has_pre_closure_span = self.prev().span.lo() < right_cutoff;\n+        let has_post_closure_span = self.prev().span.hi() > right_cutoff;\n+        let mut pending_dups = self.pending_dups.split_off(0);\n+        if has_pre_closure_span {\n+            let mut pre_closure = self.prev().clone();\n+            pre_closure.span = pre_closure.span.with_hi(left_cutoff);\n+            debug!(\"  prev overlaps a closure. Adding span for pre_closure={:?}\", pre_closure);\n+            if !pending_dups.is_empty() {\n+                for mut dup in pending_dups.iter().cloned() {\n+                    dup.span = dup.span.with_hi(left_cutoff);\n+                    debug!(\"    ...and at least one pre_closure dup={:?}\", dup);\n+                    self.add_refined_span(dup);\n+                }\n+            }\n+            self.add_refined_span(pre_closure);\n+        }\n+        if has_post_closure_span {\n+            // Update prev.span to start after the closure (and discard curr)\n+            self.prev_mut().span = self.prev().span.with_lo(right_cutoff);\n+            self.prev_original_span = self.prev().span;\n+            for dup in pending_dups.iter_mut() {\n+                dup.span = dup.span.with_lo(right_cutoff);\n+            }\n+            self.pending_dups.append(&mut pending_dups);\n+            self.discard_curr(); // since self.prev() was already updated\n+        } else {\n+            pending_dups.clear();\n+        }\n+    }\n+\n+    /// When two `CoverageSpan`s have the same `Span`, dominated spans can be discarded; but if\n+    /// neither `CoverageSpan` dominates the other, both (or possibly more than two) are held,\n+    /// until their disposition is determined. In this latter case, the `prev` dup is moved into\n+    /// `pending_dups` so the new `curr` dup can be moved to `prev` for the next iteration.\n+    fn hold_pending_dups_unless_dominated(&mut self) {\n+        // equal coverage spans are ordered by dominators before dominated (if any)\n+        debug_assert!(!self.prev().is_dominated_by(self.curr(), self.dominators));\n+\n+        if self.curr().is_dominated_by(&self.prev(), self.dominators) {\n+            // If one span dominates the other, assocate the span with the dominator only.\n+            //\n+            // For example:\n+            //     match somenum {\n+            //         x if x < 1 => { ... }\n+            //     }...\n+            // The span for the first `x` is referenced by both the pattern block (every\n+            // time it is evaluated) and the arm code (only when matched). The counter\n+            // will be applied only to the dominator block.\n+            //\n+            // The dominator's (`prev`) execution count may be higher than the dominated\n+            // block's execution count, so drop `curr`.\n+            debug!(\n+                \"  different bcbs but SAME spans, and prev dominates curr. Drop curr and \\\n+                keep prev for next iter. prev={:?}\",\n+                self.prev()\n+            );\n+            self.discard_curr();\n+        } else {\n+            // Save `prev` in `pending_dups`. (`curr` will become `prev` in the next iteration.)\n+            // If the `curr` CoverageSpan is later discarded, `pending_dups` can be discarded as\n+            // well; but if `curr` is added to refined_spans, the `pending_dups` will also be added.\n+            debug!(\n+                \"  different bcbs but SAME spans, and neither dominates, so keep curr for \\\n+                next iter, and, pending upcoming spans (unless overlapping) add prev={:?}\",\n+                self.prev()\n+            );\n+            let prev = self.take_prev();\n+            self.pending_dups.push(prev);\n+        }\n+    }\n+\n+    /// `curr` overlaps `prev`. If `prev`s span extends left of `curr`s span, keep _only_\n+    /// statements that end before `curr.lo()` (if any), and add the portion of the\n+    /// combined span for those statements. Any other statements have overlapping spans\n+    /// that can be ignored because `curr` and/or other upcoming statements/spans inside\n+    /// the overlap area will produce their own counters. This disambiguation process\n+    /// avoids injecting multiple counters for overlapping spans, and the potential for\n+    /// double-counting.\n+    fn cutoff_prev_at_overlapping_curr(&mut self) {\n+        debug!(\n+            \"  different bcbs, overlapping spans, so ignore/drop pending and only add prev \\\n+            if it has statements that end before curr={:?}\",\n+            self.prev()\n+        );\n+        if self.pending_dups.is_empty() {\n+            let curr_span = self.curr().span;\n+            self.prev_mut().cutoff_statements_at(curr_span.lo());\n+            if self.prev().coverage_statements.is_empty() {\n+                debug!(\"  ... no non-overlapping statements to add\");\n+            } else {\n+                debug!(\"  ... adding modified prev={:?}\", self.prev());\n+                let prev = self.take_prev();\n+                self.add_refined_span(prev);\n+            }\n+        } else {\n+            // with `pending_dups`, `prev` cannot have any statements that don't overlap\n+            self.pending_dups.clear();\n+        }\n+    }\n+}\n+\n+fn filtered_statement_span(statement: &'a Statement<'tcx>, body_span: Span) -> Option<Span> {\n+    match statement.kind {\n+        // These statements have spans that are often outside the scope of the executed source code\n+        // for their parent `BasicBlock`.\n+        StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        // Coverage should not be encountered, but don't inject coverage coverage\n+        | StatementKind::Coverage(_)\n+        // Ignore `Nop`s\n+        | StatementKind::Nop => None,\n+\n+        // FIXME(richkadel): Look into a possible issue assigning the span to a\n+        // FakeReadCause::ForGuardBinding, in this example:\n+        //     match somenum {\n+        //         x if x < 1 => { ... }\n+        //     }...\n+        // The BasicBlock within the match arm code included one of these statements, but the span\n+        // for it covered the `1` in this source. The actual statements have nothing to do with that\n+        // source span:\n+        //     FakeRead(ForGuardBinding, _4);\n+        // where `_4` is:\n+        //     _4 = &_1; (at the span for the first `x`)\n+        // and `_1` is the `Place` for `somenum`.\n+        //\n+        // The arm code BasicBlock already has its own assignment for `x` itself, `_3 = 1`, and I've\n+        // decided it's reasonable for that span (even though outside the arm code) to be part of\n+        // the counted coverage of the arm code execution, but I can't justify including the literal\n+        // `1` in the arm code. I'm pretty sure that, if the `FakeRead(ForGuardBinding)` has a\n+        // purpose in codegen, it's probably in the right BasicBlock, but if so, the `Statement`s\n+        // `source_info.span` can't be right.\n+        //\n+        // Consider correcting the span assignment, assuming there is a better solution, and see if\n+        // the following pattern can be removed here:\n+        StatementKind::FakeRead(cause, _) if cause == FakeReadCause::ForGuardBinding => None,\n+\n+        // Retain spans from all other statements\n+        StatementKind::FakeRead(_, _) // Not including `ForGuardBinding`\n+        | StatementKind::CopyNonOverlapping(..)\n+        | StatementKind::Assign(_)\n+        | StatementKind::SetDiscriminant { .. }\n+        | StatementKind::LlvmInlineAsm(_)\n+        | StatementKind::Retag(_, _)\n+        | StatementKind::AscribeUserType(_, _) => {\n+            Some(source_info_span(&statement.source_info, body_span))\n+        }\n+    }\n+}\n+\n+fn filtered_terminator_span(terminator: &'a Terminator<'tcx>, body_span: Span) -> Option<Span> {\n+    match terminator.kind {\n+        // These terminators have spans that don't positively contribute to computing a reasonable\n+        // span of actually executed source code. (For example, SwitchInt terminators extracted from\n+        // an `if condition { block }` has a span that includes the executed block, if true,\n+        // but for coverage, the code region executed, up to *and* through the SwitchInt,\n+        // actually stops before the if's block.)\n+        TerminatorKind::Unreachable // Unreachable blocks are not connected to the CFG\n+        | TerminatorKind::Assert { .. }\n+        | TerminatorKind::Drop { .. }\n+        | TerminatorKind::DropAndReplace { .. }\n+        | TerminatorKind::SwitchInt { .. }\n+        | TerminatorKind::Goto { .. }\n+        // For `FalseEdge`, only the `real` branch is taken, so it is similar to a `Goto`.\n+        | TerminatorKind::FalseEdge { .. } => None,\n+\n+        // Retain spans from all other terminators\n+        TerminatorKind::Resume\n+        | TerminatorKind::Abort\n+        | TerminatorKind::Return\n+        | TerminatorKind::Call { .. }\n+        | TerminatorKind::Yield { .. }\n+        | TerminatorKind::GeneratorDrop\n+        | TerminatorKind::FalseUnwind { .. }\n+        | TerminatorKind::InlineAsm { .. } => {\n+            Some(source_info_span(&terminator.source_info, body_span))\n+        }\n+    }\n+}\n+\n+#[inline(always)]\n+fn source_info_span(source_info: &SourceInfo, body_span: Span) -> Span {\n+    let span = original_sp(source_info.span, body_span).with_ctxt(SyntaxContext::root());\n+    if body_span.contains(span) { span } else { body_span }\n+}\n+\n+/// Convert the Span into its file name, start line and column, and end line and column\n+fn make_code_region(file_name: Symbol, source_file: &Lrc<SourceFile>, span: Span) -> CodeRegion {\n+    let (start_line, mut start_col) = source_file.lookup_file_pos(span.lo());\n+    let (end_line, end_col) = if span.hi() == span.lo() {\n+        let (end_line, mut end_col) = (start_line, start_col);\n+        // Extend an empty span by one character so the region will be counted.\n+        let CharPos(char_pos) = start_col;\n+        if char_pos > 0 {\n+            start_col = CharPos(char_pos - 1);\n+        } else {\n+            end_col = CharPos(char_pos + 1);\n+        }\n+        (end_line, end_col)\n+    } else {\n+        source_file.lookup_file_pos(span.hi())\n+    };\n+    CodeRegion {\n+        file_name,\n+        start_line: start_line as u32,\n+        start_col: start_col.to_u32() + 1,\n+        end_line: end_line as u32,\n+        end_col: end_col.to_u32() + 1,\n+    }\n+}\n+\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n+    let mut hcx = tcx.create_no_span_stable_hashing_context();\n+    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n+}\n+\n+fn hash(\n+    hcx: &mut StableHashingContext<'tcx>,\n+    node: &impl HashStable<StableHashingContext<'tcx>>,\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    node.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}\n+\n+pub struct ShortCircuitPreorder<\n+    'a,\n+    'tcx,\n+    F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>,\n+> {\n+    body: &'a mir::Body<'tcx>,\n+    visited: BitSet<BasicBlock>,\n+    worklist: Vec<BasicBlock>,\n+    filtered_successors: F,\n+}\n+\n+impl<'a, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>>\n+    ShortCircuitPreorder<'a, 'tcx, F>\n+{\n+    pub fn new(\n+        body: &'a mir::Body<'tcx>,\n+        filtered_successors: F,\n+    ) -> ShortCircuitPreorder<'a, 'tcx, F> {\n+        let worklist = vec![mir::START_BLOCK];\n+\n+        ShortCircuitPreorder {\n+            body,\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            worklist,\n+            filtered_successors,\n+        }\n+    }\n+}\n+\n+impl<'a: 'tcx, 'tcx, F: Fn(&'tcx TerminatorKind<'tcx>) -> mir::Successors<'tcx>> Iterator\n+    for ShortCircuitPreorder<'a, 'tcx, F>\n+{\n+    type Item = (BasicBlock, &'a BasicBlockData<'tcx>);\n+\n+    fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n+        while let Some(idx) = self.worklist.pop() {\n+            if !self.visited.insert(idx) {\n+                continue;\n+            }\n+\n+            let data = &self.body[idx];\n+\n+            if let Some(ref term) = data.terminator {\n+                self.worklist.extend((self.filtered_successors)(&term.kind));\n+            }\n+\n+            return Some((idx, data));\n+        }\n+\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let size = self.body.basic_blocks().len() - self.visited.count();\n+        (size, Some(size))\n+    }\n+}"}, {"sha": "a37f5d4f329f38fa98f4d031a1b0cf60180be12f", "filename": "compiler/rustc_mir/src/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fremove_noop_landing_pads.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -39,6 +39,7 @@ impl RemoveNoopLandingPads {\n                 | StatementKind::StorageDead(_)\n                 | StatementKind::AscribeUserType(..)\n                 | StatementKind::Coverage(..)\n+                | StatementKind::CopyNonOverlapping(..)\n                 | StatementKind::Nop => {\n                     // These are all nops in a landing pad\n                 }"}, {"sha": "a9a30e407b4b091cc972b04d0d598387ea2f5492", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -245,6 +245,7 @@ pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n         Retag(..) => \"Retag\",\n         AscribeUserType(..) => \"AscribeUserType\",\n         Coverage(..) => \"Coverage\",\n+        CopyNonOverlapping(..) => \"CopyNonOverlapping\",\n         Nop => \"Nop\",\n     }\n }"}, {"sha": "53935f02a90e45f67e8140e5efb6717914188e74", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89f45ed9f3ce7366ae7153421d637efcb22a45b8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f45ed9f3ce7366ae7153421d637efcb22a45b8/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=89f45ed9f3ce7366ae7153421d637efcb22a45b8", "patch": "@@ -210,14 +210,21 @@ fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statemen\n         StatementKind::Assign(box (place, rval)) => {\n             check_place(tcx, *place, span, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n-        },\n+        }\n \n         StatementKind::FakeRead(_, place) |\n         // just an assignment\n         StatementKind::SetDiscriminant { place, .. } => check_place(tcx, **place, span, body),\n \n         StatementKind::LlvmInlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n \n+        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping{\n+          dst, src, size,\n+        }) => {\n+          check_operand(tcx, dst, span, body)?;\n+          check_operand(tcx, src, span, body)?;\n+          check_operand(tcx, size, span, body)\n+        },\n         // These are all NOPs\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)"}]}