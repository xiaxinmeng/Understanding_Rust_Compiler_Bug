{"sha": "4e49b2f73144460cde5ada8140964d96166f41fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNDliMmY3MzE0NDQ2MGNkZTVhZGE4MTQwOTY0ZDk2MTY2ZjQxZmQ=", "commit": {"author": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-10-13T18:48:08Z"}, "committer": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-10-13T18:48:08Z"}, "message": "Implement binary operator overloading type inference", "tree": {"sha": "cb776951da53e297e59ba4bf372aa9285573cd82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb776951da53e297e59ba4bf372aa9285573cd82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e49b2f73144460cde5ada8140964d96166f41fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e49b2f73144460cde5ada8140964d96166f41fd", "html_url": "https://github.com/rust-lang/rust/commit/4e49b2f73144460cde5ada8140964d96166f41fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e49b2f73144460cde5ada8140964d96166f41fd/comments", "author": null, "committer": null, "parents": [{"sha": "0fb069c5b02072239891ce564feaa7d1890c6d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb069c5b02072239891ce564feaa7d1890c6d6f", "html_url": "https://github.com/rust-lang/rust/commit/0fb069c5b02072239891ce564feaa7d1890c6d6f"}], "stats": {"total": 125, "additions": 120, "deletions": 5}, "files": [{"sha": "644ebd42d367ca2da82e40f05004ed17e19cb2b4", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=4e49b2f73144460cde5ada8140964d96166f41fd", "patch": "@@ -22,7 +22,7 @@ use arena::map::ArenaMap;\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n-    expr::{BindingAnnotation, ExprId, PatId},\n+    expr::{ArithOp, BinaryOp, BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n@@ -586,6 +586,28 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n+    fn resolve_binary_op_output(&self, bop: &BinaryOp) -> Option<TypeAliasId> {\n+        let lang_item = match bop {\n+            BinaryOp::ArithOp(aop) => match aop {\n+                ArithOp::Add => \"add\",\n+                ArithOp::Sub => \"sub\",\n+                ArithOp::Mul => \"mul\",\n+                ArithOp::Div => \"div\",\n+                ArithOp::Shl => \"shl\",\n+                ArithOp::Shr => \"shr\",\n+                ArithOp::Rem => \"rem\",\n+                ArithOp::BitXor => \"bitxor\",\n+                ArithOp::BitOr => \"bitor\",\n+                ArithOp::BitAnd => \"bitand\",\n+            },\n+            _ => return None,\n+        };\n+\n+        let trait_ = self.resolve_lang_item(lang_item)?.as_trait();\n+\n+        self.db.trait_data(trait_?).associated_type_by_name(&name![Output])\n+    }\n+\n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n         let struct_ = self.resolve_lang_item(\"owned_box\")?.as_struct()?;\n         Some(struct_.into())"}, {"sha": "8cc0d56d3004efd08b563bbc9f12e381ddf9e30d", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=4e49b2f73144460cde5ada8140964d96166f41fd", "patch": "@@ -531,13 +531,20 @@ impl<'a> InferenceContext<'a> {\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    // FIXME: find implementation of trait corresponding to operation\n-                    // symbol and resolve associated `Output` type\n                     let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty.clone());\n                     let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n \n-                    // FIXME: similar as above, return ty is often associated trait type\n-                    op::binary_op_return_ty(*op, lhs_ty, rhs_ty)\n+                    let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n+\n+                    if ret == Ty::Unknown {\n+                        self.resolve_associated_type_with_params(\n+                            lhs_ty,\n+                            self.resolve_binary_op_output(op),\n+                            &[rhs_ty],\n+                        )\n+                    } else {\n+                        ret\n+                    }\n                 }\n                 _ => Ty::Unknown,\n             },"}, {"sha": "a3ae304a1a91f5d05e0ecac2fced571c246bbfae", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e49b2f73144460cde5ada8140964d96166f41fd/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=4e49b2f73144460cde5ada8140964d96166f41fd", "patch": "@@ -2225,3 +2225,89 @@ fn generic_default_depending_on_other_type_arg_forward() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn infer_operator_overload() {\n+    check_infer(\n+        r#\"\n+        struct V2([f32; 2]);\n+\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            /// The resulting type after applying the `+` operator.\n+            type Output;\n+\n+            /// Performs the `+` operation.\n+            #[must_use]\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+\n+        impl Add<V2> for V2 {\n+            type Output = V2;\n+\n+            fn add(self, rhs: V2) -> V2 {\n+                let x = self.0[0] + rhs.0[0];\n+                let y = self.0[1] + rhs.0[1];\n+                V2([x, y])\n+            }\n+        }\n+\n+        fn test() {\n+            let va = V2([0.0, 1.0]);\n+            let vb = V2([0.0, 1.0]);\n+\n+            let r = va + vb;\n+        }\n+\n+        \"#,\n+        expect![[r#\"\n+            207..211 'self': Self\n+            213..216 'rhs': Rhs\n+            299..303 'self': V2\n+            305..308 'rhs': V2\n+            320..422 '{     ...     }': V2\n+            334..335 'x': f32\n+            338..342 'self': V2\n+            338..344 'self.0': [f32; _]\n+            338..347 'self.0[0]': {unknown}\n+            338..358 'self.0...s.0[0]': f32\n+            345..346 '0': i32\n+            350..353 'rhs': V2\n+            350..355 'rhs.0': [f32; _]\n+            350..358 'rhs.0[0]': {unknown}\n+            356..357 '0': i32\n+            372..373 'y': f32\n+            376..380 'self': V2\n+            376..382 'self.0': [f32; _]\n+            376..385 'self.0[1]': {unknown}\n+            376..396 'self.0...s.0[1]': f32\n+            383..384 '1': i32\n+            388..391 'rhs': V2\n+            388..393 'rhs.0': [f32; _]\n+            388..396 'rhs.0[1]': {unknown}\n+            394..395 '1': i32\n+            406..408 'V2': V2([f32; _]) -> V2\n+            406..416 'V2([x, y])': V2\n+            409..415 '[x, y]': [f32; _]\n+            410..411 'x': f32\n+            413..414 'y': f32\n+            436..519 '{     ... vb; }': ()\n+            446..448 'va': V2\n+            451..453 'V2': V2([f32; _]) -> V2\n+            451..465 'V2([0.0, 1.0])': V2\n+            454..464 '[0.0, 1.0]': [f32; _]\n+            455..458 '0.0': f32\n+            460..463 '1.0': f32\n+            475..477 'vb': V2\n+            480..482 'V2': V2([f32; _]) -> V2\n+            480..494 'V2([0.0, 1.0])': V2\n+            483..493 '[0.0, 1.0]': [f32; _]\n+            484..487 '0.0': f32\n+            489..492 '1.0': f32\n+            505..506 'r': V2\n+            509..511 'va': V2\n+            509..516 'va + vb': V2\n+            514..516 'vb': V2\n+        \"#]],\n+    );\n+}"}]}