{"sha": "8c0310d18caf38197f708a6e5a1c03b065373e6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDMxMGQxOGNhZjM4MTk3ZjcwOGE2ZTVhMWMwM2IwNjUzNzNlNmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-09T11:36:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-09T11:36:37Z"}, "message": "Rollup merge of #71508 - oli-obk:alloc_map_unlock, r=RalfJung\n\nSimplify the `tcx.alloc_map` API\n\nThis PR changes all functions that require manually locking the `alloc_map` to functions on `TyCtxt` that lock the map internally. In the same step we make the `TyCtxt::alloc_map` field private.\n\nr? @RalfJung", "tree": {"sha": "ac0f742f2538f6012c49330cc1214507025ec3fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac0f742f2538f6012c49330cc1214507025ec3fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c0310d18caf38197f708a6e5a1c03b065373e6c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetpXFCRBK7hj4Ov3rIwAAdHIIABHY7iwQ7LEOx8vvOn4qwLYG\nejYN9EUds4//JqySkk79Ecdxe7C5yDJ4yN1z1E51/+/QESugsC/5vz4vTOd0BAzp\nyHpzCiFPiJRGiy7x+lK/E2tXfKJ72QEWZ2TRUkw9+hX69tXopgBNVeDLG/sOVdSt\nkU06RyDwhMThrAj18oJ6I0619Rd4UJkRPc2mUGZvNZURgi1y2Ey2LpvHpCKV//k6\nwuWZNx/46j9MMJlbUArv3cY4ZRC0rYDJnxpCWAPZyABy4bIesbbMtz+bsys1T9Y5\nyBy3siEaiqeMdu3/hP3YjjRGllztHqp/Ef0wJ1Zc2GIJQzOH3EgB4+cTaLu29sk=\n=WJq+\n-----END PGP SIGNATURE-----\n", "payload": "tree ac0f742f2538f6012c49330cc1214507025ec3fa\nparent ce05553c62689bd58184970cf58e59a663cc4658\nparent b07a44d5c4f7f1a834c566e97911f35b01f671bf\nauthor Ralf Jung <post@ralfj.de> 1589024197 +0200\ncommitter GitHub <noreply@github.com> 1589024197 +0200\n\nRollup merge of #71508 - oli-obk:alloc_map_unlock, r=RalfJung\n\nSimplify the `tcx.alloc_map` API\n\nThis PR changes all functions that require manually locking the `alloc_map` to functions on `TyCtxt` that lock the map internally. In the same step we make the `TyCtxt::alloc_map` field private.\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c0310d18caf38197f708a6e5a1c03b065373e6c", "html_url": "https://github.com/rust-lang/rust/commit/8c0310d18caf38197f708a6e5a1c03b065373e6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c0310d18caf38197f708a6e5a1c03b065373e6c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce05553c62689bd58184970cf58e59a663cc4658", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce05553c62689bd58184970cf58e59a663cc4658", "html_url": "https://github.com/rust-lang/rust/commit/ce05553c62689bd58184970cf58e59a663cc4658"}, {"sha": "b07a44d5c4f7f1a834c566e97911f35b01f671bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b07a44d5c4f7f1a834c566e97911f35b01f671bf", "html_url": "https://github.com/rust-lang/rust/commit/b07a44d5c4f7f1a834c566e97911f35b01f671bf"}], "stats": {"total": 222, "additions": 115, "deletions": 107}, "files": [{"sha": "856f989bc10a12802f0a755315785704ab92fb46", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -244,9 +244,8 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n             Scalar::Ptr(ptr) => {\n-                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                let base_addr = match alloc_kind {\n-                    Some(GlobalAlloc::Memory(alloc)) => {\n+                let base_addr = match self.tcx.global_alloc(ptr.alloc_id) {\n+                    GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n@@ -257,12 +256,11 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         value\n                     }\n-                    Some(GlobalAlloc::Function(fn_instance)) => self.get_fn_addr(fn_instance),\n-                    Some(GlobalAlloc::Static(def_id)) => {\n+                    GlobalAlloc::Function(fn_instance) => self.get_fn_addr(fn_instance),\n+                    GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         self.get_static(def_id)\n                     }\n-                    None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n                 };\n                 let llval = unsafe {\n                     llvm::LLVMConstInBoundsGEP("}, {"sha": "937c7457c63bb29e874cdd1de751f0528b3b127f", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                     _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n                 };\n                 let a = Scalar::from(Pointer::new(\n-                    bx.tcx().alloc_map.lock().create_memory_alloc(data),\n+                    bx.tcx().create_memory_alloc(data),\n                     Size::from_bytes(start),\n                 ));\n                 let a_llval = bx.scalar_to_backend("}, {"sha": "377c8661cbd4169771bfb5dd18870d004f16f47f", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -136,8 +136,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            let alloc_kind = tcx.alloc_map.lock().get(*self);\n-            alloc_kind.hash_stable(hcx, hasher);\n+            tcx.get_global_alloc(*self).hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "b17a77e0f6fa79d8edb13303a16243b45c5ed53b", "filename": "src/librustc_middle/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Flib.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -42,6 +42,7 @@\n #![feature(or_patterns)]\n #![feature(range_is_empty)]\n #![feature(specialization)]\n+#![feature(track_caller)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "71adb2fa477ad00d1a5c3c4c8e88cd7db39bf1c2", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 70, "deletions": 46, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -197,9 +197,7 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for given alloc ID\");\n-    match alloc {\n+    match tcx.global_alloc(alloc_id) {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             AllocDiscriminant::Alloc.encode(encoder)?;\n@@ -294,7 +292,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n+                            let alloc_id = decoder.tcx().reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -338,23 +336,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n+                    let alloc_id = decoder.tcx().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n+                    let alloc_id = decoder.tcx().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n             }\n@@ -381,7 +379,29 @@ pub enum GlobalAlloc<'tcx> {\n     Memory(&'tcx Allocation),\n }\n \n-pub struct AllocMap<'tcx> {\n+impl GlobalAlloc<'tcx> {\n+    /// Panics if the `GlobalAlloc` does not refer to an `GlobalAlloc::Memory`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_memory(&self) -> &'tcx Allocation {\n+        match *self {\n+            GlobalAlloc::Memory(mem) => mem,\n+            _ => bug!(\"expected memory, got {:?}\", self),\n+        }\n+    }\n+\n+    /// Panics if the `GlobalAlloc` is not `GlobalAlloc::Function`\n+    #[track_caller]\n+    #[inline]\n+    pub fn unwrap_fn(&self) -> Instance<'tcx> {\n+        match *self {\n+            GlobalAlloc::Function(instance) => instance,\n+            _ => bug!(\"expected function, got {:?}\", self),\n+        }\n+    }\n+}\n+\n+crate struct AllocMap<'tcx> {\n     /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n@@ -397,16 +417,10 @@ pub struct AllocMap<'tcx> {\n }\n \n impl<'tcx> AllocMap<'tcx> {\n-    pub fn new() -> Self {\n+    crate fn new() -> Self {\n         AllocMap { alloc_map: Default::default(), dedup: Default::default(), next_id: AllocId(0) }\n     }\n-\n-    /// Obtains a new allocation ID that can be referenced but does not\n-    /// yet have an allocation backing it.\n-    ///\n-    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n-    /// an `AllocId` from a query.\n-    pub fn reserve(&mut self) -> AllocId {\n+    fn reserve(&mut self) -> AllocId {\n         let next = self.next_id;\n         self.next_id.0 = self.next_id.0.checked_add(1).expect(\n             \"You overflowed a u64 by incrementing by 1... \\\n@@ -415,34 +429,46 @@ impl<'tcx> AllocMap<'tcx> {\n         );\n         next\n     }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Obtains a new allocation ID that can be referenced but does not\n+    /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n+    /// an `AllocId` from a query.\n+    pub fn reserve_alloc_id(&self) -> AllocId {\n+        self.alloc_map.lock().reserve()\n+    }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n-    fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+    fn reserve_and_set_dedup(&self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+        let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n             GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n             GlobalAlloc::Memory(..) => bug!(\"Trying to dedup-reserve memory with real data!\"),\n         }\n-        if let Some(&alloc_id) = self.dedup.get(&alloc) {\n+        if let Some(&alloc_id) = alloc_map.dedup.get(&alloc) {\n             return alloc_id;\n         }\n-        let id = self.reserve();\n+        let id = alloc_map.reserve();\n         debug!(\"creating alloc {:?} with id {}\", alloc, id);\n-        self.alloc_map.insert(id, alloc.clone());\n-        self.dedup.insert(alloc, id);\n+        alloc_map.alloc_map.insert(id, alloc.clone());\n+        alloc_map.dedup.insert(alloc, id);\n         id\n     }\n \n     /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n-    pub fn create_static_alloc(&mut self, static_id: DefId) -> AllocId {\n+    pub fn create_static_alloc(&self, static_id: DefId) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n     /// Generates an `AllocId` for a function.  Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n+    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n         // duplicated across crates.\n@@ -456,8 +482,9 @@ impl<'tcx> AllocMap<'tcx> {\n         });\n         if is_generic {\n             // Get a fresh ID.\n-            let id = self.reserve();\n-            self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n+            let mut alloc_map = self.alloc_map.lock();\n+            let id = alloc_map.reserve();\n+            alloc_map.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n             // Deduplicate.\n@@ -470,8 +497,8 @@ impl<'tcx> AllocMap<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(&mut self, mem: &'tcx Allocation) -> AllocId {\n-        let id = self.reserve();\n+    pub fn create_memory_alloc(&self, mem: &'tcx Allocation) -> AllocId {\n+        let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n     }\n@@ -482,38 +509,35 @@ impl<'tcx> AllocMap<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n-        self.alloc_map.get(&id).cloned()\n-    }\n-\n-    /// Panics if the `AllocId` does not refer to an `Allocation`\n-    pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n-        match self.get(id) {\n-            Some(GlobalAlloc::Memory(mem)) => mem,\n-            _ => bug!(\"expected allocation ID {} to point to memory\", id),\n-        }\n+    pub fn get_global_alloc(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+        self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n-    /// Panics if the `AllocId` does not refer to a function\n-    pub fn unwrap_fn(&self, id: AllocId) -> Instance<'tcx> {\n-        match self.get(id) {\n-            Some(GlobalAlloc::Function(instance)) => instance,\n-            _ => bug!(\"expected allocation ID {} to point to a function\", id),\n+    #[inline]\n+    #[track_caller]\n+    /// Panics in case the `AllocId` is dangling. Since that is impossible for `AllocId`s in\n+    /// constants (as all constants must pass interning and validation that check for dangling\n+    /// ids), this function is frequently used throughout rustc, but should not be used within\n+    /// the miri engine.\n+    pub fn global_alloc(&self, id: AllocId) -> GlobalAlloc<'tcx> {\n+        match self.get_global_alloc(id) {\n+            Some(alloc) => alloc,\n+            None => bug!(\"could not find allocation for {}\", id),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n+    pub fn set_alloc_id_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n-        self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n+    fn set_alloc_id_same_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+        self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }\n "}, {"sha": "8eac43639416911becafb9a451c3a3b8e378aba4", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -2404,13 +2404,9 @@ pub struct Constant<'tcx> {\n impl Constant<'tcx> {\n     pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self.literal.val.try_to_scalar() {\n-            Some(Scalar::Ptr(ptr)) => match tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                Some(GlobalAlloc::Static(def_id)) => Some(def_id),\n-                Some(_) => None,\n-                None => {\n-                    tcx.sess.delay_span_bug(DUMMY_SP, \"MIR cannot contain dangling const pointers\");\n-                    None\n-                }\n+            Some(Scalar::Ptr(ptr)) => match tcx.global_alloc(ptr.alloc_id) {\n+                GlobalAlloc::Static(def_id) => Some(def_id),\n+                _ => None,\n             },\n             _ => None,\n         }"}, {"sha": "d2267bdfc13d236a84c6e393f65d6d0fe73a8a74", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -979,7 +979,7 @@ pub struct GlobalCtxt<'tcx> {\n     allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n     /// Stores memory for globals (statics/consts).\n-    pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n+    pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: ShardedHashMap<&'tcx Layout, ()>,\n \n@@ -1017,7 +1017,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n-        self.alloc_map.lock().create_memory_alloc(alloc)\n+        self.create_memory_alloc(alloc)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {"}, {"sha": "94384230a7860b8d84b543b7b005ee59c822d99a", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -956,9 +956,8 @@ pub trait PrettyPrinter<'tcx>:\n             ) => {\n                 let byte_str = self\n                     .tcx()\n-                    .alloc_map\n-                    .lock()\n-                    .unwrap_memory(ptr.alloc_id)\n+                    .global_alloc(ptr.alloc_id)\n+                    .unwrap_memory()\n                     .get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n                     .unwrap();\n                 p!(pretty_print_byte_str(byte_str));\n@@ -1021,10 +1020,7 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             (Scalar::Ptr(ptr), ty::FnPtr(_)) => {\n-                let instance = {\n-                    let alloc_map = self.tcx().alloc_map.lock();\n-                    alloc_map.unwrap_fn(ptr.alloc_id)\n-                };\n+                let instance = self.tcx().global_alloc(ptr.alloc_id).unwrap_fn();\n                 self = self.typed_value(\n                     |this| this.print_value_path(instance.def_id(), instance.substs),\n                     |this| this.print_type(ty),"}, {"sha": "9c198dd556ac3b8a70855de75d114a0b7b885e3d", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -549,9 +549,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                     if a_val == b_val {\n                         Ok(ConstValue::Scalar(a_val))\n                     } else if let ty::FnPtr(_) = a.ty.kind {\n-                        let alloc_map = tcx.alloc_map.lock();\n-                        let a_instance = alloc_map.unwrap_fn(a_val.assert_ptr().alloc_id);\n-                        let b_instance = alloc_map.unwrap_fn(b_val.assert_ptr().alloc_id);\n+                        let a_instance = tcx.global_alloc(a_val.assert_ptr().alloc_id).unwrap_fn();\n+                        let b_instance = tcx.global_alloc(b_val.assert_ptr().alloc_id).unwrap_fn();\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {"}, {"sha": "b6c635fb22ab5e674cd17cd332413e65effac7d5", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -130,7 +130,7 @@ pub(super) fn op_to_const<'tcx>(\n \n     let to_const_value = |mplace: MPlaceTy<'_>| match mplace.ptr {\n         Scalar::Ptr(ptr) => {\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n         Scalar::Raw { data, .. } => {\n@@ -155,7 +155,7 @@ pub(super) fn op_to_const<'tcx>(\n             Immediate::ScalarPair(a, b) => {\n                 let (data, start) = match a.not_undef().unwrap() {\n                     Scalar::Ptr(ptr) => {\n-                        (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                        (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }\n                     Scalar::Raw { .. } => (\n                         ecx.tcx\n@@ -203,7 +203,7 @@ fn validate_and_turn_into_const<'tcx>(\n         if is_static || cid.promoted.is_some() {\n             let ptr = mplace.ptr.assert_ptr();\n             Ok(ConstValue::ByRef {\n-                alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                alloc: ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(),\n                 offset: ptr.offset,\n             })\n         } else {"}, {"sha": "1c44101595d4f26f3c835d3c4fb59f1b09697ad1", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -91,7 +91,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             // If the pointer is dangling (neither in local nor global memory), we leave it\n             // to validation to error. The `delay_span_bug` ensures that we don't forget such\n             // a check in validation.\n-            if tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            if tcx.get_global_alloc(alloc_id).is_none() {\n                 tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n             }\n             // treat dangling pointers like other statics\n@@ -134,7 +134,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n-    tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+    tcx.set_alloc_id_memory(alloc_id, alloc);\n     Ok(None)\n }\n \n@@ -389,7 +389,7 @@ where\n                 }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n-            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            tcx.set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n                 if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n@@ -398,7 +398,7 @@ where\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n             throw_ub_format!(\"encountered dangling pointer in final constant\")\n-        } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+        } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n             // as dangling by local memory.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);"}, {"sha": "61c365644c7f2d10a09daf5caa73b116c03cefa6", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -153,10 +153,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n     ) -> Pointer<M::PointerTag> {\n         let id = match fn_val {\n-            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Instance(instance) => self.tcx.create_fn_alloc(instance),\n             FnVal::Other(extra) => {\n                 // FIXME(RalfJung): Should we have a cache here?\n-                let id = self.tcx.alloc_map.lock().reserve();\n+                let id = self.tcx.reserve_alloc_id();\n                 let old = self.extra_fn_ptr_map.insert(id, extra);\n                 assert!(old.is_none());\n                 id\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().reserve();\n+        let id = self.tcx.reserve_alloc_id();\n         debug_assert_ne!(\n             Some(kind),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n@@ -260,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating global memory -- always an error\n-                return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                return Err(match self.tcx.get_global_alloc(ptr.alloc_id) {\n                     Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n                     Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n                         err_ub_format!(\"deallocating static memory\")\n@@ -429,8 +429,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        let (alloc, def_id) = match alloc {\n+        let (alloc, def_id) = match tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -468,7 +467,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     })?;\n                 // Make sure we use the ID of the resolved memory, not the lazy one!\n                 let id = raw_const.alloc_id;\n-                let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+                let allocation = tcx.global_alloc(id).unwrap_memory();\n \n                 (allocation, Some(def_id))\n             }\n@@ -591,8 +590,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match self.tcx.get_global_alloc(id) {\n             Some(GlobalAlloc::Static(did)) => {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(did);\n@@ -627,7 +625,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n-            match self.tcx.alloc_map.lock().get(id) {\n+            match self.tcx.get_global_alloc(id) {\n                 Some(GlobalAlloc::Function(instance)) => Some(FnVal::Instance(instance)),\n                 _ => None,\n             }\n@@ -695,7 +693,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 None => {\n                     // global alloc\n-                    match self.tcx.alloc_map.lock().get(id) {\n+                    match self.tcx.get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             eprint!(\" (unchanged global, \");\n                             write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);"}, {"sha": "a3caa2048a1e74a0d9a3e6fc6021e858bf62ef83", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -549,7 +549,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n-                let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n+                let id = self.tcx.create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_global_base_pointer(Pointer::new(id, offset));\n@@ -560,7 +560,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen.\n                 let ptr = Pointer::new(\n-                    self.tcx.alloc_map.lock().create_memory_alloc(data),\n+                    self.tcx.create_memory_alloc(data),\n                     Size::from_bytes(start), // offset: `start`\n                 );\n                 Operand::Immediate(Immediate::new_slice("}, {"sha": "6dadb8e4c67f4204d311c6a2d903a4716f95682b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -1101,7 +1101,7 @@ where\n         raw: RawConst<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // This must be an allocation in `tcx`\n-        assert!(self.tcx.alloc_map.lock().get(raw.alloc_id).is_some());\n+        let _ = self.tcx.global_alloc(raw.alloc_id);\n         let ptr = self.tag_global_base_pointer(Pointer::from(raw.alloc_id));\n         let layout = self.layout_of(raw.ty)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))"}, {"sha": "4f90f83b735d1e8c50adf02415ed26c17ecf6b0e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -416,7 +416,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n-                let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     // See const_eval::machine::MemoryExtra::can_access_statics for why\n                     // this check is so important."}, {"sha": "4648100e3b701ac529ac6a772389655ba3d9e235", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -1136,30 +1136,28 @@ fn create_mono_items_for_default_impls<'tcx>(\n \n /// Scans the miri alloc in order to find function calls, closures, and drop-glue.\n fn collect_miri<'tcx>(tcx: TyCtxt<'tcx>, alloc_id: AllocId, output: &mut Vec<MonoItem<'tcx>>) {\n-    let alloc_kind = tcx.alloc_map.lock().get(alloc_id);\n-    match alloc_kind {\n-        Some(GlobalAlloc::Static(def_id)) => {\n+    match tcx.global_alloc(alloc_id) {\n+        GlobalAlloc::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n             if should_monomorphize_locally(tcx, &instance) {\n                 trace!(\"collecting static {:?}\", def_id);\n                 output.push(MonoItem::Static(def_id));\n             }\n         }\n-        Some(GlobalAlloc::Memory(alloc)) => {\n+        GlobalAlloc::Memory(alloc) => {\n             trace!(\"collecting {:?} with {:#?}\", alloc_id, alloc);\n             for &((), inner) in alloc.relocations().values() {\n                 rustc_data_structures::stack::ensure_sufficient_stack(|| {\n                     collect_miri(tcx, inner, output);\n                 });\n             }\n         }\n-        Some(GlobalAlloc::Function(fn_instance)) => {\n+        GlobalAlloc::Function(fn_instance) => {\n             if should_monomorphize_locally(tcx, &fn_instance) {\n                 trace!(\"collecting {:?} with {:#?}\", alloc_id, fn_instance);\n                 output.push(create_fn_mono_item(fn_instance));\n             }\n         }\n-        None => bug!(\"alloc id without corresponding allocation: {}\", alloc_id),\n     }\n }\n "}, {"sha": "ff386cb218304bd25460b6a163bec9336266b621", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -588,8 +588,7 @@ pub fn write_allocations<'tcx>(\n                 write_allocation(tcx, alloc, w)\n             };\n         write!(w, \"\\n{}\", id)?;\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        match alloc {\n+        match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,"}, {"sha": "8d572465d62c19f7fe8a3025ac7694bb69a7b69b", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -740,7 +740,7 @@ fn convert_path_expr<'a, 'tcx>(\n         // a constant reference (or constant raw pointer for `static mut`) in MIR\n         Res::Def(DefKind::Static, id) => {\n             let ty = cx.tcx.static_ptr_ty(id);\n-            let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n+            let ptr = cx.tcx.create_static_alloc(id);\n             let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n             ExprKind::Deref {\n                 arg: Expr {"}, {"sha": "f6941d3293b5c0bbfd35342a6508b35a3942e28b", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c0310d18caf38197f708a6e5a1c03b065373e6c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=8c0310d18caf38197f708a6e5a1c03b065373e6c", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(p), x, y) if x == y => {\n                 match p {\n                     Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n                         ConstValue::ByRef { alloc, offset: p.offset }\n                     }\n                     Scalar::Raw { .. } => {\n@@ -305,7 +305,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n                 ConstValue::Slice {\n-                    data: self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n                     start: p.offset.bytes().try_into().unwrap(),\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }"}]}