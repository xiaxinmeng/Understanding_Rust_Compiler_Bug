{"sha": "6e3dd69e36d42318f1c930de57858109bfc1730c", "node_id": "C_kwDOAAsO6NoAKDZlM2RkNjllMzZkNDIzMThmMWM5MzBkZTU3ODU4MTA5YmZjMTczMGM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-22T06:23:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-22T06:23:40Z"}, "message": "Rollup merge of #98868 - tmiasko:unreachable-coverage, r=wesleywiser\n\nFix unreachable coverage generation for inlined functions\n\nTo generate a function coverage we need at least one coverage counter,\nso a coverage from unreachable blocks is retained only when some live\ncounters remain.\n\nThe previous implementation incorrectly retained unreachable coverage,\nbecause it didn't account for the fact that those live counters can\nbelong to another function due to inlining.\n\nFixes #98833.", "tree": {"sha": "c881dc63e1b365cc1e0851a7150165599a9f4edf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c881dc63e1b365cc1e0851a7150165599a9f4edf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e3dd69e36d42318f1c930de57858109bfc1730c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi2kJsCRBK7hj4Ov3rIwAAC2oIAHDLrP3icJKCtGOoq+B+i/1+\nMpK/WNul8wgqz2r9b7Fx3sfdh11MZoFa4yrS9AM3E6G4JlFAQKDfTIxlHf1T7Ogj\nbF7KBtLwitrXPFYt+/RXfBjyQjtfMko+Nd6v2iXBGKN27FDNMpUY9wOe1mvlG/yV\nByLwphYjJ7S/Kn3Slu7DhViNtXYBfK5x+HsA697sVKtxvRJ57UvZdJ7rdCUCRmzz\nUMuW3gRRrvCxM8n4Pq8MEQ6CUioTlGaVZ/6IVZOFN2si8HHG4LSo4QBOXCP39h2e\nZnmzPvNz/km9eB1DgMg62RFPe0idPBRfaD5MCD8KJoIDynF4gG4HTi9lvN4H1yE=\n=iKTQ\n-----END PGP SIGNATURE-----\n", "payload": "tree c881dc63e1b365cc1e0851a7150165599a9f4edf\nparent ad31d5c6a5551c88e98dd35c70a7af18445dadd8\nparent 947314125370164f52feb221ef2f1aac0e420309\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1658471020 +0530\ncommitter GitHub <noreply@github.com> 1658471020 +0530\n\nRollup merge of #98868 - tmiasko:unreachable-coverage, r=wesleywiser\n\nFix unreachable coverage generation for inlined functions\n\nTo generate a function coverage we need at least one coverage counter,\nso a coverage from unreachable blocks is retained only when some live\ncounters remain.\n\nThe previous implementation incorrectly retained unreachable coverage,\nbecause it didn't account for the fact that those live counters can\nbelong to another function due to inlining.\n\nFixes #98833.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3dd69e36d42318f1c930de57858109bfc1730c", "html_url": "https://github.com/rust-lang/rust/commit/6e3dd69e36d42318f1c930de57858109bfc1730c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e3dd69e36d42318f1c930de57858109bfc1730c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad31d5c6a5551c88e98dd35c70a7af18445dadd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad31d5c6a5551c88e98dd35c70a7af18445dadd8", "html_url": "https://github.com/rust-lang/rust/commit/ad31d5c6a5551c88e98dd35c70a7af18445dadd8"}, {"sha": "947314125370164f52feb221ef2f1aac0e420309", "url": "https://api.github.com/repos/rust-lang/rust/commits/947314125370164f52feb221ef2f1aac0e420309", "html_url": "https://github.com/rust-lang/rust/commit/947314125370164f52feb221ef2f1aac0e420309"}], "stats": {"total": 154, "additions": 111, "deletions": 43}, "files": [{"sha": "f1fe495282abc45f56e38de8cda5bf1ea2adbc7d", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -9,11 +9,8 @@ use super::FunctionCx;\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage, scope: SourceScope) {\n         // Determine the instance that coverage data was originally generated for.\n-        let scope_data = &self.mir.source_scopes[scope];\n-        let instance = if let Some((inlined_instance, _)) = scope_data.inlined {\n-            self.monomorphize(inlined_instance)\n-        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n-            self.monomorphize(self.mir.source_scopes[inlined_scope].inlined.unwrap().0)\n+        let instance = if let Some(inlined) = scope.inlined_instance(&self.mir.source_scopes) {\n+            self.monomorphize(inlined)\n         } else {\n             self.instance\n         };"}, {"sha": "702cc48ff7bb3cc13b37b84af5c92fdc1c837221", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -1662,6 +1662,22 @@ impl SourceScope {\n             ClearCrossCrate::Clear => None,\n         }\n     }\n+\n+    /// The instance this source scope was inlined from, if any.\n+    #[inline]\n+    pub fn inlined_instance<'tcx>(\n+        self,\n+        source_scopes: &IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+    ) -> Option<ty::Instance<'tcx>> {\n+        let scope_data = &source_scopes[self];\n+        if let Some((inlined_instance, _)) = scope_data.inlined {\n+            Some(inlined_instance)\n+        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n+            Some(source_scopes[inlined_scope].inlined.unwrap().0)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]"}, {"sha": "d305960b4856d23540a251ba2689ccbf0d8a9c54", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -28,6 +28,7 @@\n //! return.\n \n use crate::MirPass;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -267,7 +268,8 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         return;\n     }\n \n-    let basic_blocks = body.basic_blocks_mut();\n+    let basic_blocks = body.basic_blocks.as_mut();\n+    let source_scopes = &body.source_scopes;\n     let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n     let mut used_blocks = 0;\n     for alive_index in reachable.iter() {\n@@ -282,7 +284,7 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     }\n \n     if tcx.sess.instrument_coverage() {\n-        save_unreachable_coverage(basic_blocks, used_blocks);\n+        save_unreachable_coverage(basic_blocks, source_scopes, used_blocks);\n     }\n \n     basic_blocks.raw.truncate(used_blocks);\n@@ -311,56 +313,62 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n /// `Unreachable` coverage statements. These are non-executable statements whose\n /// code regions are still recorded in the coverage map, representing regions\n /// with `0` executions.\n+///\n+/// If there are no live `Counter` `Coverage` statements remaining, we remove\n+/// dead `Coverage` statements along with the dead blocks. Since at least one\n+/// counter per function is required by LLVM (and necessary, to add the\n+/// `function_hash` to the counter's call to the LLVM intrinsic\n+/// `instrprof.increment()`).\n+///\n+/// The `generator::StateTransform` MIR pass and MIR inlining can create\n+/// atypical conditions, where all live `Counter`s are dropped from the MIR.\n+///\n+/// With MIR inlining we can have coverage counters belonging to different\n+/// instances in a single body, so the strategy described above is applied to\n+/// coverage counters from each instance individually.\n fn save_unreachable_coverage(\n     basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n     first_dead_block: usize,\n ) {\n-    let has_live_counters = basic_blocks.raw[0..first_dead_block].iter().any(|live_block| {\n-        live_block.statements.iter().any(|statement| {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                matches!(coverage.kind, CoverageKind::Counter { .. })\n-            } else {\n-                false\n-            }\n-        })\n-    });\n-    if !has_live_counters {\n-        // If there are no live `Counter` `Coverage` statements anymore, don't\n-        // move dead coverage to the `START_BLOCK`. Just allow the dead\n-        // `Coverage` statements to be dropped with the dead blocks.\n-        //\n-        // The `generator::StateTransform` MIR pass can create atypical\n-        // conditions, where all live `Counter`s are dropped from the MIR.\n-        //\n-        // At least one Counter per function is required by LLVM (and necessary,\n-        // to add the `function_hash` to the counter's call to the LLVM\n-        // intrinsic `instrprof.increment()`).\n+    // Identify instances that still have some live coverage counters left.\n+    let mut live = FxHashSet::default();\n+    for basic_block in &basic_blocks.raw[0..first_dead_block] {\n+        for statement in &basic_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let CoverageKind::Counter { .. } = coverage.kind else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            live.insert(instance);\n+        }\n+    }\n+\n+    if live.is_empty() {\n         return;\n     }\n \n-    // Retain coverage info for dead blocks, so coverage reports will still\n-    // report `0` executions for the uncovered code regions.\n-    let mut dropped_coverage = Vec::new();\n-    for dead_block in basic_blocks.raw[first_dead_block..].iter() {\n-        for statement in dead_block.statements.iter() {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                if let Some(code_region) = &coverage.code_region {\n-                    dropped_coverage.push((statement.source_info, code_region.clone()));\n-                }\n+    // Retain coverage for instances that still have some live counters left.\n+    let mut retained_coverage = Vec::new();\n+    for dead_block in &basic_blocks.raw[first_dead_block..] {\n+        for statement in &dead_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let Some(code_region) = &coverage.code_region else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            if live.contains(&instance) {\n+                retained_coverage.push((statement.source_info, code_region.clone()));\n             }\n         }\n     }\n \n     let start_block = &mut basic_blocks[START_BLOCK];\n-    for (source_info, code_region) in dropped_coverage {\n-        start_block.statements.push(Statement {\n+    start_block.statements.extend(retained_coverage.into_iter().map(\n+        |(source_info, code_region)| Statement {\n             source_info,\n             kind: StatementKind::Coverage(Box::new(Coverage {\n                 kind: CoverageKind::Unreachable,\n                 code_region: Some(code_region),\n             })),\n-        })\n-    }\n+        },\n+    ));\n }\n \n pub struct SimplifyLocals;"}, {"sha": "ff2d386932858d76af2afc08778da8832819ff75", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -98,6 +98,7 @@ mod merging;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n use rustc_hir::def_id::DefIdSet;\n+use rustc_middle::mir;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -479,9 +480,14 @@ fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSe\n                 if !visited.insert(did) {\n                     continue;\n                 }\n-                for scope in &tcx.instance_mir(instance.def).source_scopes {\n-                    if let Some((ref inlined, _)) = scope.inlined {\n-                        result.insert(inlined.def_id());\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d102d9ecf7d14f53b4cc970cc03903dfa4c830e1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline-dead.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -0,0 +1,21 @@\n+    1|       |// Regression test for issue #98833.\n+    2|       |// compile-flags: -Zinline-mir\n+    3|       |\n+    4|      1|fn main() {\n+    5|      1|    println!(\"{}\", live::<false>());\n+    6|      1|}\n+    7|       |\n+    8|       |#[inline]\n+    9|      1|fn live<const B: bool>() -> u32 {\n+   10|      1|    if B {\n+   11|      0|        dead()\n+   12|       |    } else {\n+   13|      1|        0\n+   14|       |    }\n+   15|      1|}\n+   16|       |\n+   17|       |#[inline]\n+   18|      0|fn dead() -> u32 {\n+   19|      0|    42\n+   20|      0|}\n+"}, {"sha": "cd1ae911a5f7e44dc8037a818862907dfb4e2277", "filename": "src/test/run-make-fulldeps/coverage/inline-dead.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6e3dd69e36d42318f1c930de57858109bfc1730c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3dd69e36d42318f1c930de57858109bfc1730c/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs?ref=6e3dd69e36d42318f1c930de57858109bfc1730c", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for issue #98833.\n+// compile-flags: -Zinline-mir\n+\n+fn main() {\n+    println!(\"{}\", live::<false>());\n+}\n+\n+#[inline]\n+fn live<const B: bool>() -> u32 {\n+    if B {\n+        dead()\n+    } else {\n+        0\n+    }\n+}\n+\n+#[inline]\n+fn dead() -> u32 {\n+    42\n+}"}]}