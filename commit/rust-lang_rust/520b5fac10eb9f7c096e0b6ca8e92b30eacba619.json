{"sha": "520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "node_id": "C_kwDOAAsO6NoAKDUyMGI1ZmFjMTBlYjlmN2MwOTZlMGI2Y2E4ZTkyYjMwZWFjYmE2MTk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-26T04:19:27Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-28T23:40:09Z"}, "message": "Rework hir Bounds collection", "tree": {"sha": "36fd826280bea70e6760977644fa14c30ea371df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36fd826280bea70e6760977644fa14c30ea371df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "html_url": "https://github.com/rust-lang/rust/commit/520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "270c94e484e19764a2832ef918c95224eb3f17c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/270c94e484e19764a2832ef918c95224eb3f17c7", "html_url": "https://github.com/rust-lang/rust/commit/270c94e484e19764a2832ef918c95224eb3f17c7"}], "stats": {"total": 234, "additions": 127, "deletions": 107}, "files": [{"sha": "5d38f9eaafae3080c3591d248c4be3c7bff8c758", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "patch": "@@ -682,7 +682,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::Binder::bind_with_vars(tcx.mk_trait_ref(trait_def_id, substs), bound_vars);\n \n         debug!(?poly_trait_ref, ?assoc_bindings);\n-        bounds.trait_bounds.push((poly_trait_ref, span, constness));\n+        bounds.push_trait_bound(tcx, poly_trait_ref, span, constness);\n \n         let mut dup_bindings = FxHashMap::default();\n         for binding in &assoc_bindings {\n@@ -853,18 +853,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Sets `implicitly_sized` to true on `Bounds` if necessary\n-    pub(crate) fn add_implicitly_sized<'hir>(\n+    pub(crate) fn add_implicitly_sized(\n         &self,\n-        bounds: &mut Bounds<'hir>,\n-        ast_bounds: &'hir [hir::GenericBound<'hir>],\n-        self_ty_where_predicates: Option<(LocalDefId, &'hir [hir::WherePredicate<'hir>])>,\n+        bounds: &mut Bounds<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        ast_bounds: &'tcx [hir::GenericBound<'tcx>],\n+        self_ty_where_predicates: Option<(LocalDefId, &'tcx [hir::WherePredicate<'tcx>])>,\n         span: Span,\n     ) {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n         let mut unbound = None;\n-        let mut search_bounds = |ast_bounds: &'hir [hir::GenericBound<'hir>]| {\n+        let mut search_bounds = |ast_bounds: &'tcx [hir::GenericBound<'tcx>]| {\n             for ab in ast_bounds {\n                 if let hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = ab {\n                     if unbound.is_none() {\n@@ -912,7 +913,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // No lang item for `Sized`, so we can't add it as a bound.\n             return;\n         }\n-        bounds.implicitly_sized = Some(span);\n+        bounds.push_sized(tcx, self_ty, span);\n     }\n \n     /// This helper takes a *converted* parameter type (`param_ty`)\n@@ -963,10 +964,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n                 hir::GenericBound::Outlives(lifetime) => {\n                     let region = self.ast_region_to_region(lifetime, None);\n-                    bounds.region_bounds.push((\n-                        ty::Binder::bind_with_vars(region, bound_vars),\n+                    bounds.push_region_bound(\n+                        self.tcx(),\n+                        ty::Binder::bind_with_vars(\n+                            ty::OutlivesPredicate(param_ty, region),\n+                            bound_vars,\n+                        ),\n                         lifetime.ident.span,\n-                    ));\n+                    );\n                 }\n             }\n         }\n@@ -1225,13 +1230,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         };\n                     }\n                 }\n-                bounds.projection_bounds.push((\n-                    projection_ty.map_bound(|projection_ty| ty::ProjectionPredicate {\n-                        projection_ty,\n-                        term: term,\n-                    }),\n+                bounds.push_projection_bound(\n+                    tcx,\n+                    projection_ty\n+                        .map_bound(|projection_ty| ty::ProjectionPredicate { projection_ty, term }),\n                     binding.span,\n-                ));\n+                );\n             }\n             ConvertedBindingKind::Constraint(ast_bounds) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item: Debug>` to\n@@ -1260,7 +1264,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn conv_object_ty_poly_trait_ref(\n         &self,\n         span: Span,\n-        trait_bounds: &[hir::PolyTraitRef<'_>],\n+        hir_trait_bounds: &[hir::PolyTraitRef<'_>],\n         lifetime: &hir::Lifetime,\n         borrowed: bool,\n         representation: DynKind,\n@@ -1270,7 +1274,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n-        for trait_bound in trait_bounds.iter().rev() {\n+        for trait_bound in hir_trait_bounds.iter().rev() {\n             if let GenericArgCountResult {\n                 correct:\n                     Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n@@ -1287,10 +1291,45 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n+        let mut trait_bounds = vec![];\n+        let mut projection_bounds = vec![];\n+        for (pred, span) in bounds.predicates() {\n+            let bound_pred = pred.kind();\n+            match bound_pred.skip_binder() {\n+                ty::PredicateKind::Clause(clause) => match clause {\n+                    ty::Clause::Trait(trait_pred) => {\n+                        assert_eq!(trait_pred.polarity, ty::ImplPolarity::Positive);\n+                        trait_bounds.push((\n+                            bound_pred.rebind(trait_pred.trait_ref),\n+                            span,\n+                            trait_pred.constness,\n+                        ));\n+                    }\n+                    ty::Clause::Projection(proj) => {\n+                        projection_bounds.push((bound_pred.rebind(proj), span));\n+                    }\n+                    ty::Clause::TypeOutlives(_) => {\n+                        // Do nothing, we deal with regions separately\n+                    }\n+                    ty::Clause::RegionOutlives(_) => bug!(),\n+                },\n+                ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(_, _, _)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n+                | ty::PredicateKind::ConstEvaluatable(_)\n+                | ty::PredicateKind::ConstEquate(_, _)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                | ty::PredicateKind::Ambiguous => bug!(),\n+            }\n+        }\n+\n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n         // is used and no 'maybe' bounds are used.\n         let expanded_traits =\n-            traits::expand_trait_aliases(tcx, bounds.trait_bounds.iter().map(|&(a, b, _)| (a, b)));\n+            traits::expand_trait_aliases(tcx, trait_bounds.iter().map(|&(a, b, _)| (a, b)));\n+\n         let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) = expanded_traits\n             .filter(|i| i.trait_ref().self_ty().skip_binder() == dummy_self)\n             .partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n@@ -1327,8 +1366,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {\n-            let trait_alias_span = bounds\n-                .trait_bounds\n+            let trait_alias_span = trait_bounds\n                 .iter()\n                 .map(|&(trait_ref, _, _)| trait_ref.def_id())\n                 .find(|&trait_ref| tcx.is_trait_alias(trait_ref))\n@@ -1359,8 +1397,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types: FxHashMap<Span, BTreeSet<DefId>> = FxHashMap::default();\n \n-        let regular_traits_refs_spans = bounds\n-            .trait_bounds\n+        let regular_traits_refs_spans = trait_bounds\n             .into_iter()\n             .filter(|(trait_ref, _, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n \n@@ -1414,15 +1451,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // the discussion in #56288 for alternatives.\n                         if !references_self {\n                             // Include projections defined on supertraits.\n-                            bounds.projection_bounds.push((pred, span));\n+                            projection_bounds.push((pred, span));\n                         }\n                     }\n                     _ => (),\n                 }\n             }\n         }\n \n-        for (projection_bound, _) in &bounds.projection_bounds {\n+        for (projection_bound, _) in &projection_bounds {\n             for def_ids in associated_types.values_mut() {\n                 def_ids.remove(&projection_bound.projection_def_id());\n             }\n@@ -1431,7 +1468,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.complain_about_missing_associated_types(\n             associated_types,\n             potential_assoc_types,\n-            trait_bounds,\n+            hir_trait_bounds,\n         );\n \n         // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n@@ -1473,7 +1510,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let substs = tcx.intern_substs(&substs[..]);\n \n                 let span = i.bottom().1;\n-                let empty_generic_args = trait_bounds.iter().any(|hir_bound| {\n+                let empty_generic_args = hir_trait_bounds.iter().any(|hir_bound| {\n                     hir_bound.trait_ref.path.res == Res::Def(DefKind::Trait, trait_ref.def_id)\n                         && hir_bound.span.contains(span)\n                 });\n@@ -1505,7 +1542,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n         });\n \n-        let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n+        let existential_projections = projection_bounds.iter().map(|(bound, _)| {\n             bound.map_bound(|mut b| {\n                 assert_eq!(b.projection_ty.self_ty(), dummy_self);\n "}, {"sha": "0880c8c15f2e0592ead59099fd535d25fc645c7d", "filename": "compiler/rustc_hir_analysis/src/bounds.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs?ref=520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "patch": "@@ -1,6 +1,7 @@\n //! Bounds are restrictions applied to some types after they've been converted into the\n //! `ty` form from the HIR.\n \n+use rustc_hir::LangItem;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n \n@@ -15,73 +16,53 @@ use rustc_span::Span;\n ///           ^^^^^^^^^ bounding the type parameter `T`\n ///\n /// impl dyn Bar + Baz\n-///          ^^^^^^^^^ bounding the forgotten dynamic type\n+///          ^^^^^^^^^ bounding the type-erased dynamic type\n /// ```\n ///\n /// Our representation is a bit mixed here -- in some cases, we\n /// include the self type (e.g., `trait_bounds`) but in others we do not\n #[derive(Default, PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    /// A list of region bounds on the (implicit) self type. So if you\n-    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n-    /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Binder<'tcx, ty::Region<'tcx>>, Span)>,\n-\n-    /// A list of trait bounds. So if you had `T: Debug` this would be\n-    /// `T: Debug`. Note that the self-type is explicit here.\n-    pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span, ty::BoundConstness)>,\n-\n-    /// A list of projection equality bounds. So if you had `T:\n-    /// Iterator<Item = u32>` this would include `<T as\n-    /// Iterator>::Item => u32`. Note that the self-type is explicit\n-    /// here.\n-    pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n-\n-    /// `Some` if there is *no* `?Sized` predicate. The `span`\n-    /// is the location in the source of the `T` declaration which can\n-    /// be cited as the source of the `T: Sized` requirement.\n-    pub implicitly_sized: Option<Span>,\n+    pub predicates: Vec<(ty::Predicate<'tcx>, Span)>,\n }\n \n impl<'tcx> Bounds<'tcx> {\n-    /// Converts a bounds list into a flat set of predicates (like\n-    /// where-clauses). Because some of our bounds listings (e.g.,\n-    /// regions) don't include the self-type, you must supply the\n-    /// self-type here (the `param_ty` parameter).\n-    pub fn predicates<'out, 's>(\n-        &'s self,\n+    pub fn push_region_bound(\n+        &mut self,\n         tcx: TyCtxt<'tcx>,\n-        param_ty: Ty<'tcx>,\n-        // the output must live shorter than the duration of the borrow of self and 'tcx.\n-    ) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> + 'out\n-    where\n-        'tcx: 'out,\n-        's: 'out,\n-    {\n-        // If it could be sized, and is, add the `Sized` predicate.\n-        let sized_predicate = self.implicitly_sized.and_then(|span| {\n-            // FIXME: use tcx.at(span).mk_trait_ref(LangItem::Sized) here? This may make no-core code harder to write.\n-            let sized = tcx.lang_items().sized_trait()?;\n-            let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized, [param_ty]));\n-            Some((trait_ref.without_const().to_predicate(tcx), span))\n-        });\n+        region: ty::PolyTypeOutlivesPredicate<'tcx>,\n+        span: Span,\n+    ) {\n+        self.predicates.push((region.to_predicate(tcx), span));\n+    }\n \n-        let region_preds = self.region_bounds.iter().map(move |&(region_bound, span)| {\n-            let pred = region_bound\n-                .map_bound(|region_bound| ty::OutlivesPredicate(param_ty, region_bound))\n-                .to_predicate(tcx);\n-            (pred, span)\n-        });\n-        let trait_bounds =\n-            self.trait_bounds.iter().map(move |&(bound_trait_ref, span, constness)| {\n-                let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);\n-                (predicate, span)\n-            });\n-        let projection_bounds = self\n-            .projection_bounds\n-            .iter()\n-            .map(move |&(projection, span)| (projection.to_predicate(tcx), span));\n+    pub fn push_trait_bound(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        span: Span,\n+        constness: ty::BoundConstness,\n+    ) {\n+        self.predicates.push((trait_ref.with_constness(constness).to_predicate(tcx), span));\n+    }\n+\n+    pub fn push_projection_bound(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        projection: ty::PolyProjectionPredicate<'tcx>,\n+        span: Span,\n+    ) {\n+        self.predicates.push((projection.to_predicate(tcx), span));\n+    }\n+\n+    pub fn push_sized(&mut self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) {\n+        let sized_def_id = tcx.require_lang_item(LangItem::Sized, Some(span));\n+        let trait_ref = ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [ty]));\n+        // Preferrable to put this obligation first, since we report better errors for sized ambiguity.\n+        self.predicates.insert(0, (trait_ref.without_const().to_predicate(tcx), span));\n+    }\n \n-        sized_predicate.into_iter().chain(region_preds).chain(trait_bounds).chain(projection_bounds)\n+    pub fn predicates(&self) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> + '_ {\n+        self.predicates.iter().cloned()\n     }\n }"}, {"sha": "093e9560ccdfedc408aff716744dca3c48cc909a", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "patch": "@@ -28,7 +28,7 @@ fn associated_type_bounds<'tcx>(\n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n     let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n+    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n \n     let trait_def_id = tcx.parent(assoc_item_def_id);\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -44,9 +44,7 @@ fn associated_type_bounds<'tcx>(\n         }\n     });\n \n-    let all_bounds = tcx\n-        .arena\n-        .alloc_from_iter(bounds.predicates(tcx, item_ty).into_iter().chain(bounds_from_parent));\n+    let all_bounds = tcx.arena.alloc_from_iter(bounds.predicates().chain(bounds_from_parent));\n     debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), all_bounds);\n     all_bounds\n }\n@@ -74,10 +72,10 @@ fn opaque_type_bounds<'tcx>(\n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n         let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n+        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n         debug!(?bounds);\n \n-        tcx.arena.alloc_from_iter(bounds.predicates(tcx, item_ty))\n+        tcx.arena.alloc_from_iter(bounds.predicates())\n     })\n }\n "}, {"sha": "024b3beada0523cbf05c1a6c83a930448a1a47ef", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "patch": "@@ -165,12 +165,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n                     &mut bounds,\n+                    param_ty,\n                     &[],\n                     Some((param.def_id, ast_generics.predicates)),\n                     param.span,\n                 );\n                 trace!(?bounds);\n-                predicates.extend(bounds.predicates(tcx, param_ty));\n+                predicates.extend(bounds.predicates());\n                 trace!(?predicates);\n             }\n             GenericParamKind::Const { .. } => {\n@@ -217,7 +218,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     &mut bounds,\n                     bound_vars,\n                 );\n-                predicates.extend(bounds.predicates(tcx, ty));\n+                predicates.extend(bounds.predicates());\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n@@ -536,7 +537,7 @@ pub(super) fn super_predicates_that_define_assoc_type(\n             <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n         };\n \n-        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+        let superbounds1 = superbounds1.predicates();\n \n         // Convert any explicit superbounds in the where-clause,\n         // e.g., `trait Foo where Self: Bar`.\n@@ -745,5 +746,5 @@ fn predicates_from_bound<'tcx>(\n ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n     let mut bounds = Bounds::default();\n     astconv.add_bounds(param_ty, [bound].into_iter(), &mut bounds, bound_vars);\n-    bounds.predicates(astconv.tcx(), param_ty).collect()\n+    bounds.predicates().collect()\n }"}, {"sha": "2438fce606c01d893317a0b4a9831d5e2cfdd658", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/520b5fac10eb9f7c096e0b6ca8e92b30eacba619/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=520b5fac10eb9f7c096e0b6ca8e92b30eacba619", "patch": "@@ -1223,19 +1223,22 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 self.tcx.types.never,\n             );\n \n-            for (trait_predicate, _, _) in bounds.trait_bounds {\n-                if self.visit_trait(trait_predicate.skip_binder()).is_break() {\n-                    return;\n-                }\n-            }\n-\n-            for (poly_predicate, _) in bounds.projection_bounds {\n-                let pred = poly_predicate.skip_binder();\n-                let poly_pred_term = self.visit(pred.term);\n-                if poly_pred_term.is_break()\n-                    || self.visit_projection_ty(pred.projection_ty).is_break()\n-                {\n-                    return;\n+            for (pred, _) in bounds.predicates() {\n+                match pred.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_predicate)) => {\n+                        if self.visit_trait(trait_predicate.trait_ref).is_break() {\n+                            return;\n+                        }\n+                    }\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) => {\n+                        let term = self.visit(proj_predicate.term);\n+                        if term.is_break()\n+                            || self.visit_projection_ty(proj_predicate.projection_ty).is_break()\n+                        {\n+                            return;\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n         }"}]}