{"sha": "a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzQ2ZTI5YmNkNGQ4YjFkY2JlYjlkZTQwZmI1YmM3YTI3NDdhZWM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-16T01:18:19Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-16T19:13:21Z"}, "message": "Don't put the target in the bind closure if it is statically known. Closes #177.", "tree": {"sha": "93d3cc4591a218f641722ce202801bfba992fbe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d3cc4591a218f641722ce202801bfba992fbe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec", "html_url": "https://github.com/rust-lang/rust/commit/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f61848b24bcb04f4eee3bd16851d3e654d66e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f61848b24bcb04f4eee3bd16851d3e654d66e20", "html_url": "https://github.com/rust-lang/rust/commit/2f61848b24bcb04f4eee3bd16851d3e654d66e20"}], "stats": {"total": 52, "additions": 33, "deletions": 19}, "files": [{"sha": "805d478e99f71d46db0372e70ebbe7046b96d61d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a9c46e29bcd4d8b1dcbeb9de40fb5bc7a2747aec", "patch": "@@ -4212,7 +4212,9 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n                     outgoing_fty: &ty::t, args: &[option::t[@ast::expr]],\n                     env_ty: &ty::t, bound_tys: &[ty::t],\n-                    ty_param_count: uint) -> {val: ValueRef, ty: TypeRef} {\n+                    ty_param_count: uint,\n+                    target_fn: &option::t[ValueRef]) ->\n+    {val: ValueRef, ty: TypeRef} {\n \n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n@@ -4270,16 +4272,22 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     // creating.  (In our running example, target is the function f.)  Pick\n     // out the pointer to the target function from the environment. The\n     // target function lives in the first binding spot.\n-    let lltarget =\n-        GEP_tup_like(bcx, closure_ty, llclosure,\n-                     ~[0, abi::box_rc_field_body,\n-                       abi::closure_elt_bindings, 0]);\n-    bcx = lltarget.bcx;\n+    let (lltarget, starting_idx) = alt target_fn {\n+      some(lltarget) { (lltarget, 0) }\n+      none. {\n+        let lltarget =\n+            GEP_tup_like(bcx, closure_ty, llclosure,\n+                         ~[0, abi::box_rc_field_body,\n+                           abi::closure_elt_bindings, 0]);\n+        bcx = lltarget.bcx;\n+        (lltarget.val, 1)\n+      }\n+    };\n \n     // And then, pick out the target function's own environment.  That's what\n     // we'll use as the environment the thunk gets.\n     let lltargetclosure =\n-        bcx.build.GEP(lltarget.val, ~[C_int(0), C_int(abi::fn_field_box)]);\n+        bcx.build.GEP(lltarget, ~[C_int(0), C_int(abi::fn_field_box)]);\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n \n     // Get f's return type, which will also be the return type of the entire\n@@ -4315,7 +4323,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     }\n \n     let a: uint = 3u; // retptr, task ptr, env come first\n-    let b: int = 1;\n+    let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n         type_of_explicit_args(cx.ccx, sp, outgoing_args);\n@@ -4377,7 +4385,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     }\n \n     let lltargetfn =\n-        bcx.build.GEP(lltarget.val, ~[C_int(0), C_int(abi::fn_field_code)]);\n+        bcx.build.GEP(lltarget, ~[C_int(0), C_int(abi::fn_field_code)]);\n \n     // Cast the outgoing function to the appropriate type.\n     // This is necessary because the type of the function that we have\n@@ -4427,16 +4435,21 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     }\n     let bcx = f_res.res.bcx;\n \n-    // Cast the function we are binding to be the type that the closure\n-    // will expect it to have. The type the closure knows about has the\n-    // type parameters substituted with the real types.\n-    let llclosurety = T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n-    let src_loc = bcx.build.PointerCast(f_res.res.val, llclosurety);\n-    let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n \n-    // Arrange for the bound function to live in the first binding spot.\n-    let bound_tys: [ty::t] = ~[outgoing_fty];\n-    let bound_vals: [lval_result] = ~[bound_f];\n+    // Arrange for the bound function to live in the first binding spot\n+    // if the function is not statically known.\n+    let (bound_tys, bound_vals, target_res) = if f_res.is_mem {\n+        // Cast the function we are binding to be the type that the closure\n+        // will expect it to have. The type the closure knows about has the\n+        // type parameters substituted with the real types.\n+        let llclosurety = T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n+        let src_loc = bcx.build.PointerCast(f_res.res.val, llclosurety);\n+        let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n+        (~[outgoing_fty], ~[bound_f], none)\n+    } else {\n+        (~[], ~[], some(f_res.res.val))\n+    };\n+\n     // Translate the bound expressions.\n     for e: @ast::expr in bound {\n         let lv = trans_lval(bcx, e);\n@@ -4455,7 +4468,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     let pair_ty = node_id_type(bcx_ccx(cx), id);\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real,\n-                         args, closure.ptrty, bound_tys, ty_param_count);\n+                         args, closure.ptrty, bound_tys, ty_param_count,\n+                         target_res);\n \n     // Construct the function pair\n     let pair_v = create_real_fn_pair(bcx, llthunk.ty, llthunk.val,"}]}