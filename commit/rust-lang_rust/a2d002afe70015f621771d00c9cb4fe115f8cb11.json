{"sha": "a2d002afe70015f621771d00c9cb4fe115f8cb11", "node_id": "C_kwDOAAsO6NoAKGEyZDAwMmFmZTcwMDE1ZjYyMTc3MWQwMGM5Y2I0ZmUxMTVmOGNiMTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T00:03:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T00:03:09Z"}, "message": "Auto merge of #107269 - bjorn3:sync_cg_clif-2023-01-24, r=bjorn3\n\nSync rustc_codegen_cranelift\n\nFor cg_clif itself there have been a couple of bug fixes since the last sync, a Cranelift update and implemented all remaining simd platform intrinsics used by `std::simd`. (`std::arch` still misses a lot though) Most of the diff is from reworking of the cg_clif build system though.\n\nr? `@ghost`\n\n`@rustbot` label +A-codegen +A-cranelift +T-compiler", "tree": {"sha": "74229ed29090d8ee41ed826ae61e610e727e2397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74229ed29090d8ee41ed826ae61e610e727e2397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2d002afe70015f621771d00c9cb4fe115f8cb11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d002afe70015f621771d00c9cb4fe115f8cb11", "html_url": "https://github.com/rust-lang/rust/commit/a2d002afe70015f621771d00c9cb4fe115f8cb11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2d002afe70015f621771d00c9cb4fe115f8cb11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7948c843de94245c794e8c63dd4301a78bb5ba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7948c843de94245c794e8c63dd4301a78bb5ba3", "html_url": "https://github.com/rust-lang/rust/commit/d7948c843de94245c794e8c63dd4301a78bb5ba3"}, {"sha": "3808bc4639468018b1e5c30e1cd2e6905485ce67", "url": "https://api.github.com/repos/rust-lang/rust/commits/3808bc4639468018b1e5c30e1cd2e6905485ce67", "html_url": "https://github.com/rust-lang/rust/commit/3808bc4639468018b1e5c30e1cd2e6905485ce67"}], "stats": {"total": 2494, "additions": 1388, "deletions": 1106}, "files": [{"sha": "7886cae42a15ab1902d7d79ce677e8c4dd0be075", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,23 +1,16 @@\n task:\n   name: freebsd\n   freebsd_instance:\n-    image: freebsd-12-1-release-amd64\n+    image: freebsd-13-1-release-amd64\n   setup_rust_script:\n     - pkg install -y curl git bash\n     - curl https://sh.rustup.rs -sSf --output rustup.sh\n     - sh rustup.sh --default-toolchain none -y --profile=minimal\n-  cargo_bin_cache:\n-    folder: ~/.cargo/bin\n   target_cache:\n     folder: target\n   prepare_script:\n     - . $HOME/.cargo/env\n     - ./y.rs prepare\n   test_script:\n     - . $HOME/.cargo/env\n-    - # Enable backtraces for easier debugging\n-    - export RUST_BACKTRACE=1\n-    - # Reduce amount of benchmark runs as they are slow\n-    - export COMPILE_RUNS=2\n-    - export RUN_RUNS=2\n     - ./y.rs test"}, {"sha": "c0daf69e98e912560c68b378f5c36bac6cf3004d", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 50, "deletions": 90, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -25,6 +25,10 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    defaults:\n+      run:\n+        shell: bash\n+\n     strategy:\n       fail-fast: false\n       matrix:\n@@ -46,36 +50,31 @@ jobs:\n           - os: ubuntu-latest\n             env:\n               TARGET_TRIPLE: s390x-unknown-linux-gnu\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n-        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.os == 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n \n     - name: Install MinGW toolchain and wine\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: |\n         sudo apt-get update\n         sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n-        rustup target add x86_64-pc-windows-gnu\n \n     - name: Install AArch64 toolchain and qemu\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'aarch64-unknown-linux-gnu'\n@@ -89,6 +88,13 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-s390x-linux-gnu qemu-user\n \n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n \n@@ -104,70 +110,54 @@ jobs:\n     - name: Test\n       env:\n         TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        # Enable extra checks\n-        export CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./y.rs test\n+      run: ./y.rs test\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz dist\n \n     - name: Upload prebuilt cg_clif\n-      if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v2\n+      if: matrix.os == 'windows-latest' || matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar.xz\n \n     - name: Upload prebuilt cg_clif (cross compile)\n-      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      if: matrix.os != 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n \n-  windows:\n+\n+  abi_cafe:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    defaults:\n+      run:\n+        shell: bash\n+\n     strategy:\n-      fail-fast: false\n+      fail-fast: true\n       matrix:\n         include:\n-          # Native Windows build with MSVC\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n           - os: windows-latest\n             env:\n               TARGET_TRIPLE: x86_64-pc-windows-msvc\n-          # cross-compile from Windows to Windows MinGW\n           - os: windows-latest\n             env:\n               TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n@@ -178,50 +168,20 @@ jobs:\n       if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: rustup set default-host x86_64-pc-windows-gnu\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global core.autocrlf false\n-        rustc y.rs -o y.exe -g\n-        ./y.exe prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Build without unstable features\n-      env:\n-        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      # This is the config rust-lang/rust uses for builds\n-      run: ./y.rs build --no-unstable-features\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n     - name: Build\n       run: ./y.rs build --sysroot none\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        $Env:RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        $Env:COMPILE_RUNS=2\n-        $Env:RUN_RUNS=2\n-\n-        # Enable extra checks\n-        $Env:CG_CLIF_ENABLE_VERIFIER=1\n-\n-        # WIP Disable some tests\n-\n-        # This fails due to some weird argument handling by hyperfine, not an actual regression\n-        # more of a build system issue\n-        (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n-\n-        # This fails with a different output than expected\n-        (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n-\n-        ./y.exe test\n-\n-    - name: Package prebuilt cg_clif\n-      # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n-      run: tar cvf cg_clif.tar dist\n-\n-    - name: Upload prebuilt cg_clif\n-      uses: actions/upload-artifact@v3\n-      with:\n-        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n-        path: cg_clif.tar\n+    - name: Test abi-cafe\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      run: ./y.rs abi-cafe"}, {"sha": "d0d58d2a7eacbd19a07442af167bdb0e2926274a", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/nightly-cranelift.yml", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d7948c843de94245c794e8c63dd4301a78bb5ba3/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/d7948c843de94245c794e8c63dd4301a78bb5ba3/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml?ref=d7948c843de94245c794e8c63dd4301a78bb5ba3", "patch": "@@ -1,59 +0,0 @@\n-name: Test nightly Cranelift\n-\n-on:\n-  push:\n-  schedule:\n-    - cron: '17 1 * * *' # At 01:17 UTC every day.\n-\n-jobs:\n-  build:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 60\n-\n-    steps:\n-    - uses: actions/checkout@v3\n-\n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ubuntu-latest-cargo-installed-crates\n-\n-    - name: Prepare dependencies\n-      run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n-\n-    - name: Patch Cranelift\n-      run: |\n-        sed -i 's/cranelift-codegen = { version = \"\\w*.\\w*.\\w*\", features = \\[\"unwind\", \"all-arch\"\\] }/cranelift-codegen = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", features = [\"unwind\", \"all-arch\"] }/' Cargo.toml\n-        sed -i 's/cranelift-frontend = \"\\w*.\\w*.\\w*\"/cranelift-frontend = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-module = \"\\w*.\\w*.\\w*\"/cranelift-module = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-native = \"\\w*.\\w*.\\w*\"/cranelift-native = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-jit = { version = \"\\w*.\\w*.\\w*\", optional = true }/cranelift-jit = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", optional = true }/' Cargo.toml\n-        sed -i 's/cranelift-object = \"\\w*.\\w*.\\w*\"/cranelift-object = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-\n-        sed -i 's/object = { version = \"0.27.0\"/object = { version = \"0.28.0\"/' Cargo.toml\n-\n-        cat Cargo.toml\n-\n-    - name: Build without unstable features\n-      # This is the config rust-lang/rust uses for builds\n-      run: ./y.rs build --no-unstable-features\n-\n-    - name: Build\n-      run: ./y.rs build --sysroot none\n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        # Enable extra checks\n-        export CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./test.sh"}, {"sha": "5faa8f0540451b848506fadd139fc6333429b230", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "modified", "additions": 18, "deletions": 46, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -10,73 +10,45 @@ jobs:\n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n-        ./scripts/test_bootstrap.sh\n+    - name: Test\n+      run: ./scripts/test_bootstrap.sh\n   rustc_test_suite:\n     runs-on: ubuntu-latest\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n-        ./scripts/test_rustc_tests.sh\n+    - name: Test\n+      run: ./scripts/test_rustc_tests.sh"}, {"sha": "8012e93f6a90ebdee2747548145a52b8f2e3f45c", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,4 +1,4 @@\n-target\n+/target\n **/*.rs.bk\n *.rlib\n *.o\n@@ -11,9 +11,6 @@ perf.data.old\n /y.exe\n /y.pdb\n /build\n-/build_sysroot/sysroot_src\n-/build_sysroot/compiler-builtins\n-/build_sysroot/rustc_version\n /dist\n /rust\n /download"}, {"sha": "7c8703cba505c6e221910aabcef2a5ea4f712a41", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,4 +1,6 @@\n {\n+    \"editor.formatOnSave\": true,\n+\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n     \"rust-analyzer.imports.granularity.enforce\": true,\n@@ -30,7 +32,7 @@\n             ]\n         },\n         {\n-            \"sysroot_src\": \"./build_sysroot/sysroot_src/library\",\n+            \"sysroot_src\": \"./download/sysroot/sysroot_src/library\",\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/std_example.rs\","}, {"sha": "50249ea1bdb493e08815b1f81c373c4a1d4937db", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -57,28 +57,28 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b62c772976416112fa4484cbd688cb6fb35fd430005c1c586224fc014018abad\"\n+checksum = \"2f3d54eab028f5805ae3b26fd60eca3f3a9cfb76b989d9bab173be3f61356cc3\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9b40ed2dd13c2ac7e24f88a3090c68ad3414eb1d066a95f8f1f7b3b819cb4e46\"\n+checksum = \"2be1d5f2c3cca1efb691844bc1988b89c77291f13f778499a3f3c0cf49c0ed61\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n- \"cranelift-egraph\",\n  \"cranelift-entity\",\n  \"cranelift-isle\",\n  \"gimli\",\n+ \"hashbrown\",\n  \"log\",\n  \"regalloc2\",\n  \"smallvec\",\n@@ -87,44 +87,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb927a8f1c27c34ee3759b6b0ffa528d2330405d5cc4511f0cab33fe2279f4b5\"\n+checksum = \"3f9b1b1089750ce4005893af7ee00bb08a2cf1c9779999c0f7164cbc8ad2e0d2\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43dfa417b884a9ab488d95fd6b93b25e959321fe7bfd7a0a960ba5d7fb7ab927\"\n-\n-[[package]]\n-name = \"cranelift-egraph\"\n-version = \"0.90.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a66b39785efd8513d2cca967ede56d6cc57c8d7986a595c7c47d0c78de8dce\"\n-dependencies = [\n- \"cranelift-entity\",\n- \"fxhash\",\n- \"hashbrown\",\n- \"indexmap\",\n- \"log\",\n- \"smallvec\",\n-]\n+checksum = \"cc5fbaec51de47297fd7304986fd53c8c0030abbe69728a60d72e1c63559318d\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0637ffde963cb5d759bc4d454cfa364b6509e6c74cdaa21298add0ed9276f346\"\n+checksum = \"dab984c94593f876090fae92e984bdcc74d9b1acf740ab5f79036001c65cba13\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fb72b8342685e850cb037350418f62cc4fc55d6c2eb9c7ca01b82f9f1a6f3d56\"\n+checksum = \"6e0cb3102d21a2fe5f3210af608748ddd0cd09825ac12d42dc56ed5ed8725fe0\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -134,15 +120,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"850579cb9e4b448f7c301f1e6e6cbad99abe3f1f1d878a4994cb66e33c6db8cd\"\n+checksum = \"72101dd1f441d629735143c41e00b3428f9267738176983ef588ff43382af0a0\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9add822ad66dcbe152b5ab57de10240a2df4505099f2f6c27159acb711890bd4\"\n+checksum = \"6557f8ce44d498777f2495aa58d9692a4a37d6f84aa445750d666cef770b6a5c\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -159,19 +145,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"406b772626fc2664864cf947f3895a23b619895c7fff635f3622e2d857f4492f\"\n+checksum = \"88807e1c0c47ec02fe433333ccbe56b480425418b1470e333205e11650697d72\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d0a279e5bcba3e0466c734d8d8eb6bfc1ad29e95c37f3e4955b492b5616335e\"\n+checksum = \"c22b0d9fcbe3fc5a1af9e7021b44ce42b930bcefac446ce22e02e8f9a0d67120\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -180,9 +166,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39793c550f0c1d7db96c2fc1324583670c8143befe6edbfbaf1c68aba53be983\"\n+checksum = \"341375758d7c3fedc0b5315f552e6f0feac46baf87c450a15e9455ef47c2b261\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -317,9 +303,9 @@ checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.4.2\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91b2eab54204ea0117fe9a060537e0b07a4e72f7c7d182361ecc346cab2240e5\"\n+checksum = \"300d4fbfb40c1c66a78ba3ddd41c1110247cf52f97b87d0f2fc9209bd49b030c\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -347,7 +333,6 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n- \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -396,9 +381,9 @@ checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"2.0.1\"\n+version = \"5.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6bbabb309c06cc238ee91b1455b748c45f0bdcab0dda2c2db85b0a1e69fcb66\"\n+checksum = \"08fcba5ebd96da2a9f0747ab6337fe9788adfb3f63fa2c180520d665562d257e\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -429,43 +414,57 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n+ \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n  \"windows_i686_gnu\",\n  \"windows_i686_msvc\",\n  \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\""}, {"sha": "34117c2886febae43ecebb4f93cc498b2555ed58", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -15,12 +15,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.90.1\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.90.1\"\n-cranelift-module = \"0.90.1\"\n-cranelift-native = \"0.90.1\"\n-cranelift-jit = { version = \"0.90.1\", optional = true }\n-cranelift-object = \"0.90.1\"\n+cranelift-codegen = { version = \"0.92\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.92\" }\n+cranelift-module = { version = \"0.92\" }\n+# NOTE vendored as src/cranelift_native.rs\n+# FIXME revert back to the external crate with Cranelift 0.93\n+#cranelift-native = { version = \"0.92\" }\n+cranelift-jit = { version = \"0.92\", optional = true }\n+cranelift-object = { version = \"0.92\" }\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }"}, {"sha": "b87a9dc51e8d0f3f956e5fc69acb701a2c8e1ad3", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -8,9 +8,9 @@ If not please open an issue.\n ## Building and testing\n \n ```bash\n-$ git clone https://github.com/bjorn3/rustc_codegen_cranelift.git\n+$ git clone https://github.com/bjorn3/rustc_codegen_cranelift\n $ cd rustc_codegen_cranelift\n-$ ./y.rs prepare # download and patch sysroot src and install hyperfine for benchmarking\n+$ ./y.rs prepare\n $ ./y.rs build\n ```\n \n@@ -20,13 +20,12 @@ To run the test suite replace the last command with:\n $ ./test.sh\n ```\n \n-This will implicitly build cg_clif too. Both `y.rs build` and `test.sh` accept a `--debug` argument to\n-build in debug mode.\n+For more docs on how to build and test see [build_system/usage.txt](build_system/usage.txt) or the help message of `./y.rs`.\n \n-Alternatively you can download a pre built version from [GHA]. It is listed in the artifacts section\n+Alternatively you can download a pre built version from [Github Actions]. It is listed in the artifacts section\n of workflow runs. Unfortunately due to GHA restrictions you need to be logged in to access it.\n \n-[GHA]: https://github.com/bjorn3/rustc_codegen_cranelift/actions?query=branch%3Amaster+event%3Apush+is%3Asuccess\n+[Github Actions]: https://github.com/bjorn3/rustc_codegen_cranelift/actions?query=branch%3Amaster+event%3Apush+is%3Asuccess\n \n ## Usage\n \n@@ -53,7 +52,8 @@ configuration options.\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n     * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n+* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), `std::simd` fully works, `std::arch` is partially supported)\n+* Unwinding on panics ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1677), `-Cpanic=abort` is enabled by default)\n \n ## License\n "}, {"sha": "24f15fc8521fee0dba322e556e6cbe49d3782238", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -34,9 +34,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.77\"\n+version = \"1.0.78\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n+checksum = \"a20104e2335ce8a659d6dd92a51a767a0c062599c73b343fd152cb401e828c3d\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.85\"\n+version = \"0.1.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n+checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -129,9 +129,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.138\"\n+version = \"0.2.139\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n+checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "dbee9be04eea6356920bbcde1c97583abb0c9cb7", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,7 +1,6 @@\n use std::path::Path;\n \n use super::build_sysroot;\n-use super::config;\n use super::path::Dirs;\n use super::prepare::GitRepo;\n use super::utils::{spawn_and_wait, CargoProject, Compiler};\n@@ -10,41 +9,31 @@ use super::SysrootKind;\n pub(crate) static ABI_CAFE_REPO: GitRepo =\n     GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n \n-static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n+pub(crate) static ABI_CAFE: CargoProject =\n+    CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n \n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     dirs: &Dirs,\n     cg_clif_dylib: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n ) {\n-    if !config::get_bool(\"testsuite.abi-cafe\") {\n-        eprintln!(\"[SKIP] abi-cafe\");\n-        return;\n-    }\n-\n-    if host_triple != target_triple {\n-        eprintln!(\"[SKIP] abi-cafe (cross-compilation not supported)\");\n-        return;\n-    }\n-\n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n         dirs,\n         channel,\n         sysroot_kind,\n         cg_clif_dylib,\n-        host_triple,\n-        target_triple,\n+        bootstrap_host_compiler,\n+        bootstrap_host_compiler.triple.clone(),\n     );\n \n     eprintln!(\"Running abi-cafe\");\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = ABI_CAFE.run(&Compiler::host(), dirs);\n+    let mut cmd = ABI_CAFE.run(bootstrap_host_compiler, dirs);\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);"}, {"sha": "01d44dafbdd17ac4e2c8b4412ecc695e318c1277", "filename": "compiler/rustc_codegen_cranelift/build_system/bench.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -0,0 +1,97 @@\n+use std::env;\n+use std::fs;\n+use std::path::Path;\n+\n+use super::path::{Dirs, RelPath};\n+use super::prepare::GitRepo;\n+use super::rustc_info::get_file_name;\n+use super::utils::{hyperfine_command, is_ci, spawn_and_wait, CargoProject, Compiler};\n+\n+pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n+\n+// Use a separate target dir for the initial LLVM build to reduce unnecessary recompiles\n+pub(crate) static SIMPLE_RAYTRACER_LLVM: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer_llvm\");\n+\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n+\n+pub(crate) fn benchmark(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n+    benchmark_simple_raytracer(dirs, bootstrap_host_compiler);\n+}\n+\n+fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n+    if std::process::Command::new(\"hyperfine\").output().is_err() {\n+        eprintln!(\"Hyperfine not installed\");\n+        eprintln!(\"Hint: Try `cargo install hyperfine` to install hyperfine\");\n+        std::process::exit(1);\n+    }\n+\n+    eprintln!(\"[LLVM BUILD] simple-raytracer\");\n+    let build_cmd = SIMPLE_RAYTRACER_LLVM.build(bootstrap_host_compiler, dirs);\n+    spawn_and_wait(build_cmd);\n+    fs::copy(\n+        SIMPLE_RAYTRACER_LLVM\n+            .target_dir(dirs)\n+            .join(&bootstrap_host_compiler.triple)\n+            .join(\"debug\")\n+            .join(get_file_name(\"main\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+    )\n+    .unwrap();\n+\n+    let run_runs = env::var(\"RUN_RUNS\")\n+        .unwrap_or(if is_ci() { \"2\" } else { \"10\" }.to_string())\n+        .parse()\n+        .unwrap();\n+\n+    eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+    let cargo_clif =\n+        RelPath::DIST.to_path(dirs).join(get_file_name(\"cargo_clif\", \"bin\").replace('_', \"-\"));\n+    let manifest_path = SIMPLE_RAYTRACER.manifest_path(dirs);\n+    let target_dir = SIMPLE_RAYTRACER.target_dir(dirs);\n+\n+    let clean_cmd = format!(\n+        \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+    let llvm_build_cmd = format!(\n+        \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+    let clif_build_cmd = format!(\n+        \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        cargo_clif = cargo_clif.display(),\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+\n+    let bench_compile =\n+        hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+\n+    spawn_and_wait(bench_compile);\n+\n+    eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+    fs::copy(\n+        target_dir.join(\"debug\").join(get_file_name(\"main\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_clif\", \"bin\")),\n+    )\n+    .unwrap();\n+\n+    let mut bench_run = hyperfine_command(\n+        0,\n+        run_runs,\n+        None,\n+        Path::new(\".\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")).to_str().unwrap(),\n+        Path::new(\".\").join(get_file_name(\"raytracer_cg_clif\", \"bin\")).to_str().unwrap(),\n+    );\n+    bench_run.current_dir(RelPath::BUILD.to_path(dirs));\n+    spawn_and_wait(bench_run);\n+}"}, {"sha": "514404305a3fa0416635e45dc7ad0b9a6a34357a", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -5,15 +5,15 @@ use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n use super::utils::{is_ci, CargoProject, Compiler};\n \n-static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n+pub(crate) static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n pub(crate) fn build_backend(\n     dirs: &Dirs,\n     channel: &str,\n-    host_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let mut cmd = CG_CLIF.build(&Compiler::host(), dirs);\n+    let mut cmd = CG_CLIF.build(&bootstrap_host_compiler, dirs);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -25,6 +25,8 @@ pub(crate) fn build_backend(\n \n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+\n+        cmd.env(\"CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS\", \"true\");\n     }\n \n     if use_unstable_features {\n@@ -46,7 +48,7 @@ pub(crate) fn build_backend(\n \n     CG_CLIF\n         .target_dir(dirs)\n-        .join(host_triple)\n+        .join(&bootstrap_host_compiler.triple)\n         .join(channel)\n         .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))\n }"}, {"sha": "bd04fdbe304a3031cf7995133a306a04744ff118", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 187, "deletions": 118, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,31 +1,32 @@\n use std::fs;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n+use super::rustc_info::{get_file_name, get_rustc_version, get_toolchain_name};\n+use super::utils::{remove_dir_if_exists, spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n static DIST_DIR: RelPath = RelPath::DIST;\n static BIN_DIR: RelPath = RelPath::DIST.join(\"bin\");\n static LIB_DIR: RelPath = RelPath::DIST.join(\"lib\");\n-static RUSTLIB_DIR: RelPath = LIB_DIR.join(\"rustlib\");\n \n pub(crate) fn build_sysroot(\n     dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     cg_clif_dylib_src: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n-) {\n+    bootstrap_host_compiler: &Compiler,\n+    target_triple: String,\n+) -> Compiler {\n     eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n \n     DIST_DIR.ensure_fresh(dirs);\n     BIN_DIR.ensure_exists(dirs);\n     LIB_DIR.ensure_exists(dirs);\n \n+    let is_native = bootstrap_host_compiler.triple == target_triple;\n+\n     // Copy the backend\n     let cg_clif_dylib_path = if cfg!(windows) {\n         // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n@@ -35,137 +36,177 @@ pub(crate) fn build_sysroot(\n         LIB_DIR\n     }\n     .to_path(dirs)\n-    .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    .join(cg_clif_dylib_src.file_name().unwrap());\n     try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n+    let wrapper_base_name = get_file_name(\"____\", \"bin\");\n+    let toolchain_name = get_toolchain_name();\n     for wrapper in [\"rustc-clif\", \"rustdoc-clif\", \"cargo-clif\"] {\n-        let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n+        let wrapper_name = wrapper_base_name.replace(\"____\", wrapper);\n \n-        let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n+        let mut build_cargo_wrapper_cmd = Command::new(&bootstrap_host_compiler.rustc);\n         build_cargo_wrapper_cmd\n+            .env(\"TOOLCHAIN_NAME\", toolchain_name.clone())\n             .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n             .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n-            .arg(\"-g\");\n+            .arg(\"-Cstrip=debuginfo\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }\n \n-    let default_sysroot = super::rustc_info::get_default_sysroot();\n+    let host = build_sysroot_for_triple(\n+        dirs,\n+        channel,\n+        bootstrap_host_compiler.clone(),\n+        &cg_clif_dylib_path,\n+        sysroot_kind,\n+    );\n+    host.install_into_sysroot(&DIST_DIR.to_path(dirs));\n \n-    let host_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(host_triple).join(\"lib\");\n-    let target_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(target_triple).join(\"lib\");\n-    fs::create_dir_all(&host_rustlib_lib).unwrap();\n-    fs::create_dir_all(&target_rustlib_lib).unwrap();\n+    if !is_native {\n+        build_sysroot_for_triple(\n+            dirs,\n+            channel,\n+            {\n+                let mut bootstrap_target_compiler = bootstrap_host_compiler.clone();\n+                bootstrap_target_compiler.triple = target_triple.clone();\n+                bootstrap_target_compiler.set_cross_linker_and_runner();\n+                bootstrap_target_compiler\n+            },\n+            &cg_clif_dylib_path,\n+            sysroot_kind,\n+        )\n+        .install_into_sysroot(&DIST_DIR.to_path(dirs));\n+    }\n \n-    if target_triple == \"x86_64-pc-windows-gnu\" {\n-        if !default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\").exists() {\n-            eprintln!(\n-                \"The x86_64-pc-windows-gnu target needs to be installed first before it is possible \\\n-                to compile a sysroot for it.\",\n-            );\n-            process::exit(1);\n+    // Copy std for the host to the lib dir. This is necessary for the jit mode to find\n+    // libstd.\n+    for lib in host.libs {\n+        let filename = lib.file_name().unwrap().to_str().unwrap();\n+        if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n+            try_hard_link(&lib, LIB_DIR.to_path(dirs).join(lib.file_name().unwrap()));\n         }\n-        for file in fs::read_dir(\n-            default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\"),\n-        )\n-        .unwrap()\n-        {\n-            let file = file.unwrap().path();\n-            if file.extension().map_or(true, |ext| ext.to_str().unwrap() != \"o\") {\n-                continue; // only copy object files\n-            }\n-            try_hard_link(&file, target_rustlib_lib.join(file.file_name().unwrap()));\n+    }\n+\n+    let mut target_compiler = {\n+        let dirs: &Dirs = &dirs;\n+        let rustc_clif =\n+            RelPath::DIST.to_path(&dirs).join(wrapper_base_name.replace(\"____\", \"rustc-clif\"));\n+        let rustdoc_clif =\n+            RelPath::DIST.to_path(&dirs).join(wrapper_base_name.replace(\"____\", \"rustdoc-clif\"));\n+\n+        Compiler {\n+            cargo: bootstrap_host_compiler.cargo.clone(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: target_triple,\n+            runner: vec![],\n         }\n+    };\n+    if !is_native {\n+        target_compiler.set_cross_linker_and_runner();\n     }\n+    target_compiler\n+}\n \n-    match sysroot_kind {\n-        SysrootKind::None => {} // Nothing to do\n-        SysrootKind::Llvm => {\n-            for file in fs::read_dir(\n-                default_sysroot.join(\"lib\").join(\"rustlib\").join(host_triple).join(\"lib\"),\n-            )\n-            .unwrap()\n-            {\n-                let file = file.unwrap().path();\n-                let file_name_str = file.file_name().unwrap().to_str().unwrap();\n-                if (file_name_str.contains(\"rustc_\")\n-                    && !file_name_str.contains(\"rustc_std_workspace_\")\n-                    && !file_name_str.contains(\"rustc_demangle\"))\n-                    || file_name_str.contains(\"chalk\")\n-                    || file_name_str.contains(\"tracing\")\n-                    || file_name_str.contains(\"regex\")\n-                {\n-                    // These are large crates that are part of the rustc-dev component and are not\n-                    // necessary to run regular programs.\n-                    continue;\n-                }\n-                try_hard_link(&file, host_rustlib_lib.join(file.file_name().unwrap()));\n-            }\n+struct SysrootTarget {\n+    triple: String,\n+    libs: Vec<PathBuf>,\n+}\n \n-            if target_triple != host_triple {\n-                for file in fs::read_dir(\n-                    default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\"),\n-                )\n-                .unwrap()\n-                {\n-                    let file = file.unwrap().path();\n-                    try_hard_link(&file, target_rustlib_lib.join(file.file_name().unwrap()));\n-                }\n-            }\n+impl SysrootTarget {\n+    fn install_into_sysroot(&self, sysroot: &Path) {\n+        if self.libs.is_empty() {\n+            return;\n         }\n-        SysrootKind::Clif => {\n-            build_clif_sysroot_for_triple(dirs, channel, host_triple, &cg_clif_dylib_path, None);\n-\n-            if host_triple != target_triple {\n-                // When cross-compiling it is often necessary to manually pick the right linker\n-                let linker = match target_triple {\n-                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu-gcc\"),\n-                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu-gcc\"),\n-                    _ => None,\n-                };\n-                build_clif_sysroot_for_triple(\n-                    dirs,\n-                    channel,\n-                    target_triple,\n-                    &cg_clif_dylib_path,\n-                    linker,\n-                );\n-            }\n \n-            // Copy std for the host to the lib dir. This is necessary for the jit mode to find\n-            // libstd.\n-            for file in fs::read_dir(host_rustlib_lib).unwrap() {\n-                let file = file.unwrap().path();\n-                let filename = file.file_name().unwrap().to_str().unwrap();\n-                if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n-                    try_hard_link(&file, LIB_DIR.to_path(dirs).join(file.file_name().unwrap()));\n-                }\n-            }\n+        let target_rustlib_lib = sysroot.join(\"lib\").join(\"rustlib\").join(&self.triple).join(\"lib\");\n+        fs::create_dir_all(&target_rustlib_lib).unwrap();\n+\n+        for lib in &self.libs {\n+            try_hard_link(lib, target_rustlib_lib.join(lib.file_name().unwrap()));\n         }\n     }\n }\n \n-// FIXME move to download/ or dist/\n-pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = RelPath::BUILD_SYSROOT.join(\"rustc_version\");\n-pub(crate) static SYSROOT_SRC: RelPath = RelPath::BUILD_SYSROOT.join(\"sysroot_src\");\n-static STANDARD_LIBRARY: CargoProject = CargoProject::new(&RelPath::BUILD_SYSROOT, \"build_sysroot\");\n+pub(crate) static ORIG_BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n+pub(crate) static BUILD_SYSROOT: RelPath = RelPath::DOWNLOAD.join(\"sysroot\");\n+pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = BUILD_SYSROOT.join(\"rustc_version\");\n+pub(crate) static SYSROOT_SRC: RelPath = BUILD_SYSROOT.join(\"sysroot_src\");\n+pub(crate) static STANDARD_LIBRARY: CargoProject =\n+    CargoProject::new(&BUILD_SYSROOT, \"build_sysroot\");\n+pub(crate) static RTSTARTUP_SYSROOT: RelPath = RelPath::BUILD.join(\"rtstartup\");\n \n+#[must_use]\n+fn build_sysroot_for_triple(\n+    dirs: &Dirs,\n+    channel: &str,\n+    compiler: Compiler,\n+    cg_clif_dylib_path: &Path,\n+    sysroot_kind: SysrootKind,\n+) -> SysrootTarget {\n+    match sysroot_kind {\n+        SysrootKind::None => build_rtstartup(dirs, &compiler)\n+            .unwrap_or(SysrootTarget { triple: compiler.triple, libs: vec![] }),\n+        SysrootKind::Llvm => build_llvm_sysroot_for_triple(compiler),\n+        SysrootKind::Clif => {\n+            build_clif_sysroot_for_triple(dirs, channel, compiler, &cg_clif_dylib_path)\n+        }\n+    }\n+}\n+\n+#[must_use]\n+fn build_llvm_sysroot_for_triple(compiler: Compiler) -> SysrootTarget {\n+    let default_sysroot = super::rustc_info::get_default_sysroot(&compiler.rustc);\n+\n+    let mut target_libs = SysrootTarget { triple: compiler.triple, libs: vec![] };\n+\n+    for entry in fs::read_dir(\n+        default_sysroot.join(\"lib\").join(\"rustlib\").join(&target_libs.triple).join(\"lib\"),\n+    )\n+    .unwrap()\n+    {\n+        let entry = entry.unwrap();\n+        if entry.file_type().unwrap().is_dir() {\n+            continue;\n+        }\n+        let file = entry.path();\n+        let file_name_str = file.file_name().unwrap().to_str().unwrap();\n+        if (file_name_str.contains(\"rustc_\")\n+            && !file_name_str.contains(\"rustc_std_workspace_\")\n+            && !file_name_str.contains(\"rustc_demangle\"))\n+            || file_name_str.contains(\"chalk\")\n+            || file_name_str.contains(\"tracing\")\n+            || file_name_str.contains(\"regex\")\n+        {\n+            // These are large crates that are part of the rustc-dev component and are not\n+            // necessary to run regular programs.\n+            continue;\n+        }\n+        target_libs.libs.push(file);\n+    }\n+\n+    target_libs\n+}\n+\n+#[must_use]\n fn build_clif_sysroot_for_triple(\n     dirs: &Dirs,\n     channel: &str,\n-    triple: &str,\n+    mut compiler: Compiler,\n     cg_clif_dylib_path: &Path,\n-    linker: Option<&str>,\n-) {\n+) -> SysrootTarget {\n     match fs::read_to_string(SYSROOT_RUSTC_VERSION.to_path(dirs)) {\n         Err(e) => {\n             eprintln!(\"Failed to get rustc version for patched sysroot source: {}\", e);\n             eprintln!(\"Hint: Try `./y.rs prepare` to patch the sysroot source\");\n             process::exit(1);\n         }\n         Ok(source_version) => {\n-            let rustc_version = get_rustc_version();\n+            let rustc_version = get_rustc_version(&compiler.rustc);\n             if source_version != rustc_version {\n                 eprintln!(\"The patched sysroot source is outdated\");\n                 eprintln!(\"Source version: {}\", source_version.trim());\n@@ -176,37 +217,39 @@ fn build_clif_sysroot_for_triple(\n         }\n     }\n \n-    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(triple).join(channel);\n+    let mut target_libs = SysrootTarget { triple: compiler.triple.clone(), libs: vec![] };\n+\n+    if let Some(rtstartup_target_libs) = build_rtstartup(dirs, &compiler) {\n+        rtstartup_target_libs.install_into_sysroot(&RTSTARTUP_SYSROOT.to_path(dirs));\n+\n+        target_libs.libs.extend(rtstartup_target_libs.libs);\n+    }\n+\n+    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(&compiler.triple).join(channel);\n \n     if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the deps dir, but keep build scripts and the incremental cache for faster\n         // recompilation as they are not affected by changes in cg_clif.\n-        if build_dir.join(\"deps\").exists() {\n-            fs::remove_dir_all(build_dir.join(\"deps\")).unwrap();\n-        }\n+        remove_dir_if_exists(&build_dir.join(\"deps\"));\n     }\n \n     // Build sysroot\n-    let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n+    let mut rustflags = \" -Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n-    rustflags.push_str(&format!(\" --sysroot={}\", DIST_DIR.to_path(dirs).to_str().unwrap()));\n+    // Necessary for MinGW to find rsbegin.o and rsend.o\n+    rustflags\n+        .push_str(&format!(\" --sysroot={}\", RTSTARTUP_SYSROOT.to_path(dirs).to_str().unwrap()));\n     if channel == \"release\" {\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n-    if let Some(linker) = linker {\n-        use std::fmt::Write;\n-        write!(rustflags, \" -Clinker={}\", linker).unwrap();\n-    }\n-    let mut compiler = Compiler::with_triple(triple.to_owned());\n-    compiler.rustflags = rustflags;\n+    compiler.rustflags += &rustflags;\n     let mut build_cmd = STANDARD_LIBRARY.build(&compiler, dirs);\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n-    // Copy all relevant files to the sysroot\n     for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n@@ -216,9 +259,35 @@ fn build_clif_sysroot_for_triple(\n         } else {\n             continue;\n         };\n-        try_hard_link(\n-            entry.path(),\n-            RUSTLIB_DIR.to_path(dirs).join(triple).join(\"lib\").join(entry.file_name()),\n-        );\n+        target_libs.libs.push(entry.path());\n+    }\n+\n+    target_libs\n+}\n+\n+fn build_rtstartup(dirs: &Dirs, compiler: &Compiler) -> Option<SysrootTarget> {\n+    if !compiler.triple.ends_with(\"windows-gnu\") {\n+        return None;\n     }\n+\n+    RTSTARTUP_SYSROOT.ensure_fresh(dirs);\n+\n+    let rtstartup_src = SYSROOT_SRC.to_path(dirs).join(\"library\").join(\"rtstartup\");\n+    let mut target_libs = SysrootTarget { triple: compiler.triple.clone(), libs: vec![] };\n+\n+    for file in [\"rsbegin\", \"rsend\"] {\n+        let obj = RTSTARTUP_SYSROOT.to_path(dirs).join(format!(\"{file}.o\"));\n+        let mut build_rtstartup_cmd = Command::new(&compiler.rustc);\n+        build_rtstartup_cmd\n+            .arg(\"--target\")\n+            .arg(&compiler.triple)\n+            .arg(\"--emit=obj\")\n+            .arg(\"-o\")\n+            .arg(&obj)\n+            .arg(rtstartup_src.join(format!(\"{file}.rs\")));\n+        spawn_and_wait(build_rtstartup_cmd);\n+        target_libs.libs.push(obj.clone());\n+    }\n+\n+    Some(target_libs)\n }"}, {"sha": "8dcbe8de189b25a0c31edb7a8fe5525a5826a359", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -2,9 +2,10 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n-use self::utils::is_ci;\n+use self::utils::{is_ci, Compiler};\n \n mod abi_cafe;\n+mod bench;\n mod build_backend;\n mod build_sysroot;\n mod config;\n@@ -14,31 +15,8 @@ mod rustc_info;\n mod tests;\n mod utils;\n \n-const USAGE: &str = r#\"The build system of cg_clif.\n-\n-USAGE:\n-    ./y.rs prepare [--out-dir DIR]\n-    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n-    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n-\n-OPTIONS:\n-    --sysroot none|clif|llvm\n-            Which sysroot libraries to use:\n-            `none` will not include any standard library in the sysroot.\n-            `clif` will build the standard library using Cranelift.\n-            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n-\n-    --out-dir DIR\n-            Specify the directory in which the download, build and dist directories are stored.\n-            By default this is the working directory.\n-\n-    --no-unstable-features\n-            fSome features are not yet ready for production usage. This option will disable these\n-            features. This includes the JIT mode and inline assembly support.\n-\"#;\n-\n fn usage() {\n-    eprintln!(\"{USAGE}\");\n+    eprintln!(\"{}\", include_str!(\"usage.txt\"));\n }\n \n macro_rules! arg_error {\n@@ -54,6 +32,8 @@ enum Command {\n     Prepare,\n     Build,\n     Test,\n+    AbiCafe,\n+    Bench,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -64,19 +44,26 @@ pub(crate) enum SysrootKind {\n }\n \n pub fn main() {\n-    env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n+    if env::var(\"RUST_BACKTRACE\").is_err() {\n+        env::set_var(\"RUST_BACKTRACE\", \"1\");\n+    }\n     env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n \n     if is_ci() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+\n+        // Enable the Cranelift verifier\n+        env::set_var(\"CG_CLIF_ENABLE_VERIFIER\", \"1\");\n     }\n \n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n         Some(\"prepare\") => Command::Prepare,\n         Some(\"build\") => Command::Build,\n         Some(\"test\") => Command::Test,\n+        Some(\"abi-cafe\") => Command::AbiCafe,\n+        Some(\"bench\") => Command::Bench,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n         Some(command) => arg_error!(\"Unknown command {}\", command),\n         None => {\n@@ -112,24 +99,16 @@ pub fn main() {\n         }\n     }\n \n-    let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n-        host_triple\n-    } else if let Some(host_triple) = config::get_value(\"host\") {\n-        host_triple\n-    } else {\n-        rustc_info::get_host_triple()\n-    };\n-    let target_triple = if let Ok(target_triple) = std::env::var(\"TARGET_TRIPLE\") {\n-        if target_triple != \"\" {\n-            target_triple\n-        } else {\n-            host_triple.clone() // Empty target triple can happen on GHA\n-        }\n-    } else if let Some(target_triple) = config::get_value(\"target\") {\n-        target_triple\n-    } else {\n-        host_triple.clone()\n-    };\n+    let bootstrap_host_compiler = Compiler::bootstrap_with_triple(\n+        std::env::var(\"HOST_TRIPLE\")\n+            .ok()\n+            .or_else(|| config::get_value(\"host\"))\n+            .unwrap_or_else(|| rustc_info::get_host_triple()),\n+    );\n+    let target_triple = std::env::var(\"TARGET_TRIPLE\")\n+        .ok()\n+        .or_else(|| config::get_value(\"target\"))\n+        .unwrap_or_else(|| bootstrap_host_compiler.triple.clone());\n \n     // FIXME allow changing the location of these dirs using cli arguments\n     let current_dir = std::env::current_dir().unwrap();\n@@ -157,8 +136,15 @@ pub fn main() {\n         process::exit(0);\n     }\n \n-    let cg_clif_dylib =\n-        build_backend::build_backend(&dirs, channel, &host_triple, use_unstable_features);\n+    env::set_var(\"RUSTC\", \"rustc_should_be_set_explicitly\");\n+    env::set_var(\"RUSTDOC\", \"rustdoc_should_be_set_explicitly\");\n+\n+    let cg_clif_dylib = build_backend::build_backend(\n+        &dirs,\n+        channel,\n+        &bootstrap_host_compiler,\n+        use_unstable_features,\n+    );\n     match command {\n         Command::Prepare => {\n             // Handled above\n@@ -169,28 +155,37 @@ pub fn main() {\n                 channel,\n                 sysroot_kind,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple.clone(),\n             );\n-\n-            abi_cafe::run(\n+        }\n+        Command::AbiCafe => {\n+            if bootstrap_host_compiler.triple != target_triple {\n+                eprintln!(\"Abi-cafe doesn't support cross-compilation\");\n+                process::exit(1);\n+            }\n+            abi_cafe::run(channel, sysroot_kind, &dirs, &cg_clif_dylib, &bootstrap_host_compiler);\n+        }\n+        Command::Build => {\n+            build_sysroot::build_sysroot(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &dirs,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple,\n             );\n         }\n-        Command::Build => {\n+        Command::Bench => {\n             build_sysroot::build_sysroot(\n                 &dirs,\n                 channel,\n                 sysroot_kind,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple,\n             );\n+            bench::benchmark(&dirs, &bootstrap_host_compiler);\n         }\n     }\n }"}, {"sha": "3290723005dd92b939486489e4acda090b0a8ac0", "filename": "compiler/rustc_codegen_cranelift/build_system/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,6 +1,8 @@\n use std::fs;\n use std::path::PathBuf;\n \n+use super::utils::remove_dir_if_exists;\n+\n #[derive(Debug, Clone)]\n pub(crate) struct Dirs {\n     pub(crate) source_dir: PathBuf,\n@@ -42,7 +44,6 @@ impl RelPath {\n     pub(crate) const DIST: RelPath = RelPath::Base(PathBase::Dist);\n \n     pub(crate) const SCRIPTS: RelPath = RelPath::SOURCE.join(\"scripts\");\n-    pub(crate) const BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n     pub(crate) const PATCHES: RelPath = RelPath::SOURCE.join(\"patches\");\n \n     pub(crate) const fn join(&'static self, suffix: &'static str) -> RelPath {\n@@ -62,9 +63,7 @@ impl RelPath {\n \n     pub(crate) fn ensure_fresh(&self, dirs: &Dirs) {\n         let path = self.to_path(dirs);\n-        if path.exists() {\n-            fs::remove_dir_all(&path).unwrap();\n-        }\n+        remove_dir_if_exists(&path);\n         fs::create_dir_all(path).unwrap();\n     }\n }"}, {"sha": "f25a81dc23459f8e93e4204eb32efb2c80df12e8", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 54, "deletions": 75, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -3,73 +3,55 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use super::build_sysroot::{SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n+use super::build_sysroot::{BUILD_SYSROOT, ORIG_BUILD_SYSROOT, SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n+use super::rustc_info::{get_default_sysroot, get_rustc_version};\n+use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spawn_and_wait};\n \n pub(crate) fn prepare(dirs: &Dirs) {\n-    if RelPath::DOWNLOAD.to_path(dirs).exists() {\n-        std::fs::remove_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n-    }\n-    std::fs::create_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n+    RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n-    prepare_sysroot(dirs);\n+    spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", dirs));\n \n-    // FIXME maybe install this only locally?\n-    eprintln!(\"[INSTALL] hyperfine\");\n-    Command::new(\"cargo\")\n-        .arg(\"install\")\n-        .arg(\"hyperfine\")\n-        .env_remove(\"CARGO_TARGET_DIR\")\n-        .spawn()\n-        .unwrap()\n-        .wait()\n-        .unwrap();\n+    prepare_sysroot(dirs);\n+    spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", dirs));\n \n     super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n+    spawn_and_wait(super::abi_cafe::ABI_CAFE.fetch(\"cargo\", dirs));\n     super::tests::RAND_REPO.fetch(dirs);\n+    spawn_and_wait(super::tests::RAND.fetch(\"cargo\", dirs));\n     super::tests::REGEX_REPO.fetch(dirs);\n+    spawn_and_wait(super::tests::REGEX.fetch(\"cargo\", dirs));\n     super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n-    super::tests::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n-\n-    eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let host_compiler = Compiler::host();\n-    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler, dirs);\n-    spawn_and_wait(build_cmd);\n-    fs::copy(\n-        super::tests::SIMPLE_RAYTRACER\n-            .target_dir(dirs)\n-            .join(&host_compiler.triple)\n-            .join(\"debug\")\n-            .join(get_file_name(\"main\", \"bin\")),\n-        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n-    )\n-    .unwrap();\n+    spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", dirs));\n+    super::bench::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n+    spawn_and_wait(super::bench::SIMPLE_RAYTRACER.fetch(\"cargo\", dirs));\n }\n \n fn prepare_sysroot(dirs: &Dirs) {\n-    let rustc_path = get_rustc_path();\n-    let sysroot_src_orig = rustc_path.parent().unwrap().join(\"../lib/rustlib/src/rust\");\n-    let sysroot_src = SYSROOT_SRC;\n-\n+    let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n     assert!(sysroot_src_orig.exists());\n \n-    sysroot_src.ensure_fresh(dirs);\n-    fs::create_dir_all(sysroot_src.to_path(dirs).join(\"library\")).unwrap();\n     eprintln!(\"[COPY] sysroot src\");\n+\n+    // FIXME ensure builds error out or update the copy if any of the files copied here change\n+    BUILD_SYSROOT.ensure_fresh(dirs);\n+    copy_dir_recursively(&ORIG_BUILD_SYSROOT.to_path(dirs), &BUILD_SYSROOT.to_path(dirs));\n+\n+    fs::create_dir_all(SYSROOT_SRC.to_path(dirs).join(\"library\")).unwrap();\n     copy_dir_recursively(\n         &sysroot_src_orig.join(\"library\"),\n-        &sysroot_src.to_path(dirs).join(\"library\"),\n+        &SYSROOT_SRC.to_path(dirs).join(\"library\"),\n     );\n \n-    let rustc_version = get_rustc_version();\n+    let rustc_version = get_rustc_version(Path::new(\"rustc\"));\n     fs::write(SYSROOT_RUSTC_VERSION.to_path(dirs), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n-    init_git_repo(&sysroot_src.to_path(dirs));\n+    init_git_repo(&SYSROOT_SRC.to_path(dirs));\n \n-    apply_patches(dirs, \"sysroot\", &sysroot_src.to_path(dirs));\n+    apply_patches(dirs, \"sysroot\", &SYSROOT_SRC.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {\n@@ -118,14 +100,14 @@ impl GitRepo {\n fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     eprintln!(\"[CLONE] {}\", repo);\n     // Ignore exit code as the repo may already have been checked out\n-    Command::new(\"git\").arg(\"clone\").arg(repo).arg(&download_dir).spawn().unwrap().wait().unwrap();\n+    git_command(None, \"clone\").arg(repo).arg(download_dir).spawn().unwrap().wait().unwrap();\n \n-    let mut clean_cmd = Command::new(\"git\");\n-    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(&download_dir);\n+    let mut clean_cmd = git_command(download_dir, \"checkout\");\n+    clean_cmd.arg(\"--\").arg(\".\");\n     spawn_and_wait(clean_cmd);\n \n-    let mut checkout_cmd = Command::new(\"git\");\n-    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(download_dir);\n+    let mut checkout_cmd = git_command(download_dir, \"checkout\");\n+    checkout_cmd.arg(\"-q\").arg(rev);\n     spawn_and_wait(checkout_cmd);\n }\n \n@@ -149,8 +131,22 @@ fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo:\n \n     // Download zip archive\n     let mut download_cmd = Command::new(\"curl\");\n-    download_cmd.arg(\"--location\").arg(\"--output\").arg(&archive_file).arg(archive_url);\n-    spawn_and_wait(download_cmd);\n+    download_cmd\n+        .arg(\"--max-time\")\n+        .arg(\"600\")\n+        .arg(\"-y\")\n+        .arg(\"30\")\n+        .arg(\"-Y\")\n+        .arg(\"10\")\n+        .arg(\"--connect-timeout\")\n+        .arg(\"30\")\n+        .arg(\"--continue-at\")\n+        .arg(\"-\")\n+        .arg(\"--location\")\n+        .arg(\"--output\")\n+        .arg(&archive_file)\n+        .arg(archive_url);\n+    retry_spawn_and_wait(5, download_cmd);\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n@@ -167,25 +163,16 @@ fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo:\n }\n \n fn init_git_repo(repo_dir: &Path) {\n-    let mut git_init_cmd = Command::new(\"git\");\n-    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(repo_dir);\n+    let mut git_init_cmd = git_command(repo_dir, \"init\");\n+    git_init_cmd.arg(\"-q\");\n     spawn_and_wait(git_init_cmd);\n \n-    let mut git_add_cmd = Command::new(\"git\");\n-    git_add_cmd.arg(\"add\").arg(\".\").current_dir(repo_dir);\n+    let mut git_add_cmd = git_command(repo_dir, \"add\");\n+    git_add_cmd.arg(\".\");\n     spawn_and_wait(git_add_cmd);\n \n-    let mut git_commit_cmd = Command::new(\"git\");\n-    git_commit_cmd\n-        .arg(\"-c\")\n-        .arg(\"user.name=Dummy\")\n-        .arg(\"-c\")\n-        .arg(\"user.email=dummy@example.com\")\n-        .arg(\"commit\")\n-        .arg(\"-m\")\n-        .arg(\"Initial commit\")\n-        .arg(\"-q\")\n-        .current_dir(repo_dir);\n+    let mut git_commit_cmd = git_command(repo_dir, \"commit\");\n+    git_commit_cmd.arg(\"-m\").arg(\"Initial commit\").arg(\"-q\");\n     spawn_and_wait(git_commit_cmd);\n }\n \n@@ -220,16 +207,8 @@ fn apply_patches(dirs: &Dirs, crate_name: &str, target_dir: &Path) {\n             target_dir.file_name().unwrap(),\n             patch.file_name().unwrap()\n         );\n-        let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd\n-            .arg(\"-c\")\n-            .arg(\"user.name=Dummy\")\n-            .arg(\"-c\")\n-            .arg(\"user.email=dummy@example.com\")\n-            .arg(\"am\")\n-            .arg(patch)\n-            .arg(\"-q\")\n-            .current_dir(target_dir);\n+        let mut apply_patch_cmd = git_command(target_dir, \"am\");\n+        apply_patch_cmd.arg(patch).arg(\"-q\");\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "a70453b4422898e31f0030f1613cf7877260e481", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,9 +1,9 @@\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n \n-pub(crate) fn get_rustc_version() -> String {\n+pub(crate) fn get_rustc_version(rustc: &Path) -> String {\n     let version_info =\n-        Command::new(\"rustc\").stderr(Stdio::inherit()).args(&[\"-V\"]).output().unwrap().stdout;\n+        Command::new(rustc).stderr(Stdio::inherit()).args(&[\"-V\"]).output().unwrap().stdout;\n     String::from_utf8(version_info).unwrap()\n }\n \n@@ -23,6 +23,16 @@ pub(crate) fn get_host_triple() -> String {\n         .to_owned()\n }\n \n+pub(crate) fn get_toolchain_name() -> String {\n+    let active_toolchain = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"show\", \"active-toolchain\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    String::from_utf8(active_toolchain).unwrap().trim().split_once(' ').unwrap().0.to_owned()\n+}\n+\n pub(crate) fn get_cargo_path() -> PathBuf {\n     let cargo_path = Command::new(\"rustup\")\n         .stderr(Stdio::inherit())\n@@ -53,8 +63,8 @@ pub(crate) fn get_rustdoc_path() -> PathBuf {\n     Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n }\n \n-pub(crate) fn get_default_sysroot() -> PathBuf {\n-    let default_sysroot = Command::new(\"rustc\")\n+pub(crate) fn get_default_sysroot(rustc: &Path) -> PathBuf {\n+    let default_sysroot = Command::new(rustc)\n         .stderr(Stdio::inherit())\n         .args(&[\"--print\", \"sysroot\"])\n         .output()\n@@ -83,12 +93,3 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n     assert!(file_name.contains(crate_name));\n     file_name\n }\n-\n-/// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n-/// underscores (`_`). This is specially made for the rustc and cargo wrappers\n-/// which have a dash in the name, and that is not allowed in a crate name.\n-pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n-    let crate_name = crate_name.replace('-', \"_\");\n-    let wrapper_name = get_file_name(&crate_name, crate_type);\n-    wrapper_name.replace('_', \"-\")\n-}"}, {"sha": "dcfadd737566e20d8a76f0fb8bf393e9b27eb654", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 183, "deletions": 393, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,11 +1,10 @@\n-use super::build_sysroot;\n+use super::bench::SIMPLE_RAYTRACER;\n+use super::build_sysroot::{self, SYSROOT_SRC};\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n-use super::rustc_info::{get_cargo_path, get_wrapper_file_name};\n-use super::utils::{\n-    hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n-};\n+use super::rustc_info::get_host_triple;\n+use super::utils::{spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler};\n use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n@@ -17,256 +16,111 @@ static BUILD_EXAMPLE_OUT_DIR: RelPath = RelPath::BUILD.join(\"example\");\n \n struct TestCase {\n     config: &'static str,\n-    func: &'static dyn Fn(&TestRunner),\n+    cmd: TestCaseCmd,\n+}\n+\n+enum TestCaseCmd {\n+    Custom { func: &'static dyn Fn(&TestRunner) },\n+    BuildLib { source: &'static str, crate_types: &'static str },\n+    BuildBinAndRun { source: &'static str, args: &'static [&'static str] },\n+    JitBin { source: &'static str, args: &'static str },\n }\n \n impl TestCase {\n-    const fn new(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n-        Self { config, func }\n+    // FIXME reduce usage of custom test case commands\n+    const fn custom(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n+        Self { config, cmd: TestCaseCmd::Custom { func } }\n+    }\n+\n+    const fn build_lib(\n+        config: &'static str,\n+        source: &'static str,\n+        crate_types: &'static str,\n+    ) -> Self {\n+        Self { config, cmd: TestCaseCmd::BuildLib { source, crate_types } }\n+    }\n+\n+    const fn build_bin_and_run(\n+        config: &'static str,\n+        source: &'static str,\n+        args: &'static [&'static str],\n+    ) -> Self {\n+        Self { config, cmd: TestCaseCmd::BuildBinAndRun { source, args } }\n+    }\n+\n+    const fn jit_bin(config: &'static str, source: &'static str, args: &'static str) -> Self {\n+        Self { config, cmd: TestCaseCmd::JitBin { source, args } }\n     }\n }\n \n const NO_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"build.mini_core\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mini_core.rs\",\n-            \"--crate-name\",\n-            \"mini_core\",\n-            \"--crate-type\",\n-            \"lib,dylib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"build.example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/example.rs\",\n-            \"--crate-type\",\n-            \"lib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n-        let mut jit_cmd = runner.rustc_command([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit\",\n-            \"-Cprefer-dynamic\",\n-            \"example/mini_core_hello_world.rs\",\n-            \"--cfg\",\n-            \"jit\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n-        spawn_and_wait(jit_cmd);\n-\n-        eprintln!(\"[JIT-lazy] mini_core_hello_world\");\n-        let mut jit_cmd = runner.rustc_command([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit-lazy\",\n-            \"-Cprefer-dynamic\",\n-            \"example/mini_core_hello_world.rs\",\n-            \"--cfg\",\n-            \"jit\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n-        spawn_and_wait(jit_cmd);\n-    }),\n-    TestCase::new(\"aot.mini_core_hello_world\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mini_core_hello_world.rs\",\n-            \"--crate-name\",\n-            \"mini_core_hello_world\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-g\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n-    }),\n+    TestCase::build_lib(\"build.mini_core\", \"example/mini_core.rs\", \"lib,dylib\"),\n+    TestCase::build_lib(\"build.example\", \"example/example.rs\", \"lib\"),\n+    TestCase::jit_bin(\"jit.mini_core_hello_world\", \"example/mini_core_hello_world.rs\", \"abc bcd\"),\n+    TestCase::build_bin_and_run(\n+        \"aot.mini_core_hello_world\",\n+        \"example/mini_core_hello_world.rs\",\n+        &[\"abc\", \"bcd\"],\n+    ),\n ];\n \n const BASE_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"aot.arbitrary_self_types_pointers_and_wrappers\", &|runner| {\n-        runner.run_rustc([\n-            \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n-            \"--crate-name\",\n-            \"arbitrary_self_types_pointers_and_wrappers\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n-    }),\n-    TestCase::new(\"aot.issue_91827_extern_types\", &|runner| {\n-        runner.run_rustc([\n-            \"example/issue-91827-extern-types.rs\",\n-            \"--crate-name\",\n-            \"issue_91827_extern_types\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"issue_91827_extern_types\", []);\n-    }),\n-    TestCase::new(\"build.alloc_system\", &|runner| {\n-        runner.run_rustc([\n-            \"example/alloc_system.rs\",\n-            \"--crate-type\",\n-            \"lib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"aot.alloc_example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/alloc_example.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"alloc_example\", []);\n-    }),\n-    TestCase::new(\"jit.std_example\", &|runner| {\n-        runner.run_rustc([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit\",\n-            \"-Cprefer-dynamic\",\n-            \"example/std_example.rs\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-\n-        eprintln!(\"[JIT-lazy] std_example\");\n-        runner.run_rustc([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit-lazy\",\n-            \"-Cprefer-dynamic\",\n-            \"example/std_example.rs\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"aot.std_example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/std_example.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"std_example\", [\"arg\"]);\n-    }),\n-    TestCase::new(\"aot.dst_field_align\", &|runner| {\n-        runner.run_rustc([\n-            \"example/dst-field-align.rs\",\n-            \"--crate-name\",\n-            \"dst_field_align\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"dst_field_align\", []);\n-    }),\n-    TestCase::new(\"aot.subslice-patterns-const-eval\", &|runner| {\n-        runner.run_rustc([\n-            \"example/subslice-patterns-const-eval.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"subslice-patterns-const-eval\", []);\n-    }),\n-    TestCase::new(\"aot.track-caller-attribute\", &|runner| {\n-        runner.run_rustc([\n-            \"example/track-caller-attribute.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"track-caller-attribute\", []);\n-    }),\n-    TestCase::new(\"aot.float-minmax-pass\", &|runner| {\n-        runner.run_rustc([\n-            \"example/float-minmax-pass.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"float-minmax-pass\", []);\n-    }),\n-    TestCase::new(\"aot.mod_bench\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mod_bench.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"mod_bench\", []);\n-    }),\n-    TestCase::new(\"aot.issue-72793\", &|runner| {\n-        runner.run_rustc([\n-            \"example/issue-72793.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"issue-72793\", []);\n-    }),\n+    TestCase::build_bin_and_run(\n+        \"aot.arbitrary_self_types_pointers_and_wrappers\",\n+        \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\n+        \"aot.issue_91827_extern_types\",\n+        \"example/issue-91827-extern-types.rs\",\n+        &[],\n+    ),\n+    TestCase::build_lib(\"build.alloc_system\", \"example/alloc_system.rs\", \"lib\"),\n+    TestCase::build_bin_and_run(\"aot.alloc_example\", \"example/alloc_example.rs\", &[]),\n+    TestCase::jit_bin(\"jit.std_example\", \"example/std_example.rs\", \"\"),\n+    TestCase::build_bin_and_run(\"aot.std_example\", \"example/std_example.rs\", &[\"arg\"]),\n+    TestCase::build_bin_and_run(\"aot.dst_field_align\", \"example/dst-field-align.rs\", &[]),\n+    TestCase::build_bin_and_run(\n+        \"aot.subslice-patterns-const-eval\",\n+        \"example/subslice-patterns-const-eval.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\n+        \"aot.track-caller-attribute\",\n+        \"example/track-caller-attribute.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\"aot.float-minmax-pass\", \"example/float-minmax-pass.rs\", &[]),\n+    TestCase::build_bin_and_run(\"aot.mod_bench\", \"example/mod_bench.rs\", &[]),\n+    TestCase::build_bin_and_run(\"aot.issue-72793\", \"example/issue-72793.rs\", &[]),\n ];\n \n pub(crate) static RAND_REPO: GitRepo =\n     GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n \n-static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n+pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n     GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n \n-static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n+pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"582239ac3b32007613df04d7ffa78dc30f4c5645\",\n     \"portable-simd\",\n );\n \n-static PORTABLE_SIMD: CargoProject =\n+pub(crate) static PORTABLE_SIMD: CargoProject =\n     CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n-pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n-    \"ebobby\",\n-    \"simple-raytracer\",\n-    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    \"<none>\",\n-);\n-\n-pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n-    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n-\n-static LIBCORE_TESTS: CargoProject =\n-    CargoProject::new(&RelPath::BUILD_SYSROOT.join(\"sysroot_src/library/core/tests\"), \"core_tests\");\n+pub(crate) static LIBCORE_TESTS: CargoProject =\n+    CargoProject::new(&SYSROOT_SRC.join(\"library/core/tests\"), \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.rust-random/rand\", &|runner| {\n+        RAND.clean(&runner.dirs);\n \n         if runner.is_native {\n             eprintln!(\"[TEST] rust-random/rand\");\n@@ -280,60 +134,12 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n-\n-        if runner.is_native {\n-            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-            let cargo_clif = RelPath::DIST\n-                .to_path(&runner.dirs)\n-                .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-            let manifest_path = SIMPLE_RAYTRACER.manifest_path(&runner.dirs);\n-            let target_dir = SIMPLE_RAYTRACER.target_dir(&runner.dirs);\n-\n-            let clean_cmd = format!(\n-                \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-            let llvm_build_cmd = format!(\n-                \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-            let clif_build_cmd = format!(\n-                \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                cargo_clif = cargo_clif.display(),\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-\n-            let bench_compile =\n-                hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n-\n-            spawn_and_wait(bench_compile);\n-\n-            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-            fs::copy(\n-                target_dir.join(\"debug\").join(\"main\"),\n-                RelPath::BUILD.to_path(&runner.dirs).join(\"raytracer_cg_clif\"),\n-            )\n-            .unwrap();\n-\n-            let mut bench_run =\n-                hyperfine_command(0, run_runs, None, \"./raytracer_cg_llvm\", \"./raytracer_cg_clif\");\n-            bench_run.current_dir(RelPath::BUILD.to_path(&runner.dirs));\n-            spawn_and_wait(bench_run);\n-        } else {\n-            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo, &runner.dirs));\n-            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n-            eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n-            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n-        }\n+    TestCase::custom(\"test.simple-raytracer\", &|runner| {\n+        SIMPLE_RAYTRACER.clean(&runner.dirs);\n+        spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n     }),\n-    TestCase::new(\"test.libcore\", &|runner| {\n-        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.libcore\", &|runner| {\n+        LIBCORE_TESTS.clean(&runner.dirs);\n \n         if runner.is_native {\n             spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n@@ -344,8 +150,8 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.regex-shootout-regex-dna\", &|runner| {\n+        REGEX.clean(&runner.dirs);\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n@@ -364,9 +170,10 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n                 REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n             )\n             .unwrap();\n-            let expected_path =\n-                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\");\n-            let expected = fs::read_to_string(&expected_path).unwrap();\n+            let expected = fs::read_to_string(\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\"),\n+            )\n+            .unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n             // Make sure `[codegen mono items] start` doesn't poison the diff\n@@ -379,27 +186,16 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n-                let res_path = REGEX.source_dir(&runner.dirs).join(\"res.txt\");\n-                fs::write(&res_path, &output).unwrap();\n-\n-                if cfg!(windows) {\n-                    println!(\"Output files don't match!\");\n-                    println!(\"Expected Output:\\n{}\", expected);\n-                    println!(\"Actual Output:\\n{}\", output);\n-                } else {\n-                    let mut diff = Command::new(\"diff\");\n-                    diff.arg(\"-u\");\n-                    diff.arg(res_path);\n-                    diff.arg(expected_path);\n-                    spawn_and_wait(diff);\n-                }\n+                println!(\"Output files don't match!\");\n+                println!(\"Expected Output:\\n{}\", expected);\n+                println!(\"Actual Output:\\n{}\", output);\n \n                 std::process::exit(1);\n             }\n         }\n     }),\n-    TestCase::new(\"test.regex\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.regex\", &|runner| {\n+        REGEX.clean(&runner.dirs);\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n@@ -425,8 +221,8 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"test.portable-simd\", &|runner| {\n-        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.portable-simd\", &|runner| {\n+        PORTABLE_SIMD.clean(&runner.dirs);\n \n         let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--all-targets\");\n@@ -445,21 +241,22 @@ pub(crate) fn run_tests(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     cg_clif_dylib: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n+    target_triple: String,\n ) {\n-    let runner = TestRunner::new(dirs.clone(), host_triple.to_string(), target_triple.to_string());\n-\n     if config::get_bool(\"testsuite.no_sysroot\") {\n-        build_sysroot::build_sysroot(\n+        let target_compiler = build_sysroot::build_sysroot(\n             dirs,\n             channel,\n             SysrootKind::None,\n             cg_clif_dylib,\n-            &host_triple,\n-            &target_triple,\n+            bootstrap_host_compiler,\n+            target_triple.clone(),\n         );\n \n+        let runner =\n+            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n+\n         BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n     } else {\n@@ -470,111 +267,64 @@ pub(crate) fn run_tests(\n     let run_extended_sysroot = config::get_bool(\"testsuite.extended_sysroot\");\n \n     if run_base_sysroot || run_extended_sysroot {\n-        build_sysroot::build_sysroot(\n+        let target_compiler = build_sysroot::build_sysroot(\n             dirs,\n             channel,\n             sysroot_kind,\n             cg_clif_dylib,\n-            &host_triple,\n-            &target_triple,\n+            bootstrap_host_compiler,\n+            target_triple.clone(),\n         );\n-    }\n \n-    if run_base_sysroot {\n-        runner.run_testsuite(BASE_SYSROOT_SUITE);\n-    } else {\n-        eprintln!(\"[SKIP] base_sysroot tests\");\n-    }\n+        let runner =\n+            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n \n-    if run_extended_sysroot {\n-        runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n-    } else {\n-        eprintln!(\"[SKIP] extended_sysroot tests\");\n+        if run_base_sysroot {\n+            runner.run_testsuite(BASE_SYSROOT_SUITE);\n+        } else {\n+            eprintln!(\"[SKIP] base_sysroot tests\");\n+        }\n+\n+        if run_extended_sysroot {\n+            runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n+        } else {\n+            eprintln!(\"[SKIP] extended_sysroot tests\");\n+        }\n     }\n }\n \n struct TestRunner {\n     is_native: bool,\n     jit_supported: bool,\n     dirs: Dirs,\n-    host_compiler: Compiler,\n     target_compiler: Compiler,\n }\n \n impl TestRunner {\n-    pub fn new(dirs: Dirs, host_triple: String, target_triple: String) -> Self {\n-        let is_native = host_triple == target_triple;\n-        let jit_supported =\n-            target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n-\n-        let rustc_clif =\n-            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-        let rustdoc_clif =\n-            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n-\n-        let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n-        let mut runner = vec![];\n-\n-        if !is_native {\n-            match target_triple.as_str() {\n-                \"aarch64-unknown-linux-gnu\" => {\n-                    // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-                    rustflags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rustflags);\n-                    runner = vec![\n-                        \"qemu-aarch64\".to_owned(),\n-                        \"-L\".to_owned(),\n-                        \"/usr/aarch64-linux-gnu\".to_owned(),\n-                    ];\n-                }\n-                \"s390x-unknown-linux-gnu\" => {\n-                    // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n-                    rustflags = format!(\"-Clinker=s390x-linux-gnu-gcc{}\", rustflags);\n-                    runner = vec![\n-                        \"qemu-s390x\".to_owned(),\n-                        \"-L\".to_owned(),\n-                        \"/usr/s390x-linux-gnu\".to_owned(),\n-                    ];\n-                }\n-                \"x86_64-pc-windows-gnu\" => {\n-                    // We are cross-compiling for Windows. Run tests in wine.\n-                    runner = vec![\"wine\".to_owned()];\n-                }\n-                _ => {\n-                    println!(\"Unknown non-native platform\");\n-                }\n-            }\n+    pub fn new(dirs: Dirs, mut target_compiler: Compiler, is_native: bool) -> Self {\n+        if let Ok(rustflags) = env::var(\"RUSTFLAGS\") {\n+            target_compiler.rustflags.push(' ');\n+            target_compiler.rustflags.push_str(&rustflags);\n+        }\n+        if let Ok(rustdocflags) = env::var(\"RUSTDOCFLAGS\") {\n+            target_compiler.rustdocflags.push(' ');\n+            target_compiler.rustdocflags.push_str(&rustdocflags);\n         }\n \n         // FIXME fix `#[linkage = \"extern_weak\"]` without this\n-        if target_triple.contains(\"darwin\") {\n-            rustflags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rustflags);\n+        if target_compiler.triple.contains(\"darwin\") {\n+            target_compiler.rustflags.push_str(\" -Clink-arg=-undefined -Clink-arg=dynamic_lookup\");\n         }\n \n-        let host_compiler = Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: rustc_clif.clone(),\n-            rustdoc: rustdoc_clif.clone(),\n-            rustflags: String::new(),\n-            rustdocflags: String::new(),\n-            triple: host_triple,\n-            runner: vec![],\n-        };\n-\n-        let target_compiler = Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: rustc_clif,\n-            rustdoc: rustdoc_clif,\n-            rustflags: rustflags.clone(),\n-            rustdocflags: rustflags,\n-            triple: target_triple,\n-            runner,\n-        };\n-\n-        Self { is_native, jit_supported, dirs, host_compiler, target_compiler }\n+        let jit_supported = is_native\n+            && target_compiler.triple.contains(\"x86_64\")\n+            && !target_compiler.triple.contains(\"windows\");\n+\n+        Self { is_native, jit_supported, dirs, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n-        for &TestCase { config, func } in tests {\n+        for TestCase { config, cmd } in tests {\n             let (tag, testname) = config.split_once('.').unwrap();\n             let tag = tag.to_uppercase();\n             let is_jit_test = tag == \"JIT\";\n@@ -586,7 +336,47 @@ impl TestRunner {\n                 eprintln!(\"[{tag}] {testname}\");\n             }\n \n-            func(self);\n+            match *cmd {\n+                TestCaseCmd::Custom { func } => func(self),\n+                TestCaseCmd::BuildLib { source, crate_types } => {\n+                    self.run_rustc([source, \"--crate-type\", crate_types]);\n+                }\n+                TestCaseCmd::BuildBinAndRun { source, args } => {\n+                    self.run_rustc([source]);\n+                    self.run_out_command(\n+                        source.split('/').last().unwrap().split('.').next().unwrap(),\n+                        args,\n+                    );\n+                }\n+                TestCaseCmd::JitBin { source, args } => {\n+                    let mut jit_cmd = self.rustc_command([\n+                        \"-Zunstable-options\",\n+                        \"-Cllvm-args=mode=jit\",\n+                        \"-Cprefer-dynamic\",\n+                        source,\n+                        \"--cfg\",\n+                        \"jit\",\n+                    ]);\n+                    if !args.is_empty() {\n+                        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", args);\n+                    }\n+                    spawn_and_wait(jit_cmd);\n+\n+                    eprintln!(\"[JIT-lazy] {testname}\");\n+                    let mut jit_cmd = self.rustc_command([\n+                        \"-Zunstable-options\",\n+                        \"-Cllvm-args=mode=jit-lazy\",\n+                        \"-Cprefer-dynamic\",\n+                        source,\n+                        \"--cfg\",\n+                        \"jit\",\n+                    ]);\n+                    if !args.is_empty() {\n+                        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", args);\n+                    }\n+                    spawn_and_wait(jit_cmd);\n+                }\n+            }\n         }\n     }\n \n@@ -603,6 +393,9 @@ impl TestRunner {\n         cmd.arg(\"--out-dir\");\n         cmd.arg(format!(\"{}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"-Cdebuginfo=2\");\n+        cmd.arg(\"--target\");\n+        cmd.arg(&self.target_compiler.triple);\n+        cmd.arg(\"-Cpanic=abort\");\n         cmd.args(args);\n         cmd\n     }\n@@ -615,10 +408,7 @@ impl TestRunner {\n         spawn_and_wait(self.rustc_command(args));\n     }\n \n-    fn run_out_command<'a, I>(&self, name: &str, args: I)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n+    fn run_out_command<'a>(&self, name: &str, args: &[&str]) {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's\n@@ -630,7 +420,7 @@ impl TestRunner {\n             BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).join(name).to_str().unwrap().to_string(),\n         );\n \n-        for arg in args.into_iter() {\n+        for arg in args {\n             full_cmd.push(arg.to_string());\n         }\n "}, {"sha": "ab98ccc35a58a595e0e0bc3ffc7621194ae7e27d", "filename": "compiler/rustc_codegen_cranelift/build_system/usage.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -0,0 +1,35 @@\n+The build system of cg_clif.\n+\n+USAGE:\n+    ./y.rs prepare [--out-dir DIR]\n+    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs abi-cafe [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs bench [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+\n+OPTIONS:\n+    --debug\n+            Build cg_clif and the standard library in debug mode rather than release mode.\n+            Warning: An unoptimized cg_clif is very slow.\n+\n+    --sysroot none|clif|llvm\n+            Which sysroot libraries to use:\n+            `none` will not include any standard library in the sysroot.\n+            `clif` will build the standard library using Cranelift.\n+            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n+\n+    --out-dir DIR\n+            Specify the directory in which the download, build and dist directories are stored.\n+            By default this is the working directory.\n+\n+    --no-unstable-features\n+            Some features are not yet ready for production usage. This option will disable these\n+            features. This includes the JIT mode and inline assembly support.\n+\n+REQUIREMENTS:\n+    * Rustup: The build system has a hard coded dependency on rustup to install the right nightly\n+      version and make sure it is used where necessary.\n+    * Git: `./y.rs prepare` uses git for applying patches and on Windows for downloading test repos.\n+    * Curl and tar (non-Windows only): Used by `./y.rs prepare` to download a single commit for\n+      repos. Git will be used to clone the whole repo when using Windows.\n+    * [Hyperfine](https://github.com/sharkdp/hyperfine/): Used for benchmarking with `./y.rs bench`."}, {"sha": "da2a94a0a4ff84a3b307c22213e1813fd03ca55f", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,12 +1,13 @@\n use std::env;\n use std::fs;\n-use std::io::Write;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n+use super::rustc_info::{get_cargo_path, get_rustc_path, get_rustdoc_path};\n \n+#[derive(Clone, Debug)]\n pub(crate) struct Compiler {\n     pub(crate) cargo: PathBuf,\n     pub(crate) rustc: PathBuf,\n@@ -18,27 +19,47 @@ pub(crate) struct Compiler {\n }\n \n impl Compiler {\n-    pub(crate) fn host() -> Compiler {\n+    pub(crate) fn bootstrap_with_triple(triple: String) -> Compiler {\n         Compiler {\n             cargo: get_cargo_path(),\n             rustc: get_rustc_path(),\n             rustdoc: get_rustdoc_path(),\n             rustflags: String::new(),\n             rustdocflags: String::new(),\n-            triple: get_host_triple(),\n+            triple,\n             runner: vec![],\n         }\n     }\n \n-    pub(crate) fn with_triple(triple: String) -> Compiler {\n-        Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: get_rustc_path(),\n-            rustdoc: get_rustdoc_path(),\n-            rustflags: String::new(),\n-            rustdocflags: String::new(),\n-            triple,\n-            runner: vec![],\n+    pub(crate) fn set_cross_linker_and_runner(&mut self) {\n+        match self.triple.as_str() {\n+            \"aarch64-unknown-linux-gnu\" => {\n+                // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+                self.rustflags += \" -Clinker=aarch64-linux-gnu-gcc\";\n+                self.rustdocflags += \" -Clinker=aarch64-linux-gnu-gcc\";\n+                self.runner = vec![\n+                    \"qemu-aarch64\".to_owned(),\n+                    \"-L\".to_owned(),\n+                    \"/usr/aarch64-linux-gnu\".to_owned(),\n+                ];\n+            }\n+            \"s390x-unknown-linux-gnu\" => {\n+                // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n+                self.rustflags += \" -Clinker=s390x-linux-gnu-gcc\";\n+                self.rustdocflags += \" -Clinker=s390x-linux-gnu-gcc\";\n+                self.runner = vec![\n+                    \"qemu-s390x\".to_owned(),\n+                    \"-L\".to_owned(),\n+                    \"/usr/s390x-linux-gnu\".to_owned(),\n+                ];\n+            }\n+            \"x86_64-pc-windows-gnu\" => {\n+                // We are cross-compiling for Windows. Run tests in wine.\n+                self.runner = vec![\"wine\".to_owned()];\n+            }\n+            _ => {\n+                println!(\"Unknown non-native platform\");\n+            }\n         }\n     }\n }\n@@ -65,18 +86,21 @@ impl CargoProject {\n         RelPath::BUILD.join(self.target).to_path(dirs)\n     }\n \n+    #[must_use]\n     fn base_cmd(&self, command: &str, cargo: &Path, dirs: &Dirs) -> Command {\n         let mut cmd = Command::new(cargo);\n \n         cmd.arg(command)\n             .arg(\"--manifest-path\")\n             .arg(self.manifest_path(dirs))\n             .arg(\"--target-dir\")\n-            .arg(self.target_dir(dirs));\n+            .arg(self.target_dir(dirs))\n+            .arg(\"--frozen\");\n \n         cmd\n     }\n \n+    #[must_use]\n     fn build_cmd(&self, command: &str, compiler: &Compiler, dirs: &Dirs) -> Command {\n         let mut cmd = self.base_cmd(command, &compiler.cargo, dirs);\n \n@@ -105,9 +129,8 @@ impl CargoProject {\n         cmd\n     }\n \n-    #[must_use]\n-    pub(crate) fn clean(&self, cargo: &Path, dirs: &Dirs) -> Command {\n-        self.base_cmd(\"clean\", cargo, dirs)\n+    pub(crate) fn clean(&self, dirs: &Dirs) {\n+        let _ = fs::remove_dir_all(self.target_dir(dirs));\n     }\n \n     #[must_use]\n@@ -153,6 +176,23 @@ pub(crate) fn hyperfine_command(\n     bench\n }\n \n+#[must_use]\n+pub(crate) fn git_command<'a>(repo_dir: impl Into<Option<&'a Path>>, cmd: &str) -> Command {\n+    let mut git_cmd = Command::new(\"git\");\n+    git_cmd\n+        .arg(\"-c\")\n+        .arg(\"user.name=Dummy\")\n+        .arg(\"-c\")\n+        .arg(\"user.email=dummy@example.com\")\n+        .arg(\"-c\")\n+        .arg(\"core.autocrlf=false\")\n+        .arg(cmd);\n+    if let Some(repo_dir) = repo_dir.into() {\n+        git_cmd.current_dir(repo_dir);\n+    }\n+    git_cmd\n+}\n+\n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n     let src = src.as_ref();\n@@ -169,6 +209,22 @@ pub(crate) fn spawn_and_wait(mut cmd: Command) {\n     }\n }\n \n+// Based on the retry function in rust's src/ci/shared.sh\n+#[track_caller]\n+pub(crate) fn retry_spawn_and_wait(tries: u64, mut cmd: Command) {\n+    for i in 1..tries + 1 {\n+        if i != 1 {\n+            println!(\"Command failed. Attempt {i}/{tries}:\");\n+        }\n+        if cmd.spawn().unwrap().wait().unwrap().success() {\n+            return;\n+        }\n+        std::thread::sleep(std::time::Duration::from_secs(i * 5));\n+    }\n+    println!(\"The command has failed after {tries} attempts.\");\n+    process::exit(1);\n+}\n+\n #[track_caller]\n pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> String {\n     let mut child = cmd\n@@ -190,6 +246,14 @@ pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> Stri\n     String::from_utf8(output.stdout).unwrap()\n }\n \n+pub(crate) fn remove_dir_if_exists(path: &Path) {\n+    match fs::remove_dir_all(&path) {\n+        Ok(()) => {}\n+        Err(err) if err.kind() == io::ErrorKind::NotFound => {}\n+        Err(err) => panic!(\"Failed to remove {path}: {err}\", path = path.display()),\n+    }\n+}\n+\n pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n     for entry in fs::read_dir(from).unwrap() {\n         let entry = entry.unwrap();"}, {"sha": "cdfc2e143e6748247d056e11488b5adae5ea21f7", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,10 +1,9 @@\n #!/usr/bin/env bash\n set -e\n \n-rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ build/ dist/ perf.data{,.old} y.bin\n-rm -rf download/\n+rm -rf target/ download/ build/ dist/ y.bin y.bin.dSYM y.exe y.pdb\n \n # Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh\n # FIXME remove at some point in the future\n rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/\n+rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}"}, {"sha": "d49cc90791a5d5fb01a81bbf7aeb905405681d55", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -44,10 +44,8 @@ aot.issue-72793\n \n testsuite.extended_sysroot\n test.rust-random/rand\n-bench.simple-raytracer\n+test.simple-raytracer\n test.libcore\n test.regex-shootout-regex-dna\n test.regex\n test.portable-simd\n-\n-testsuite.abi-cafe"}, {"sha": "89e2b61c1fc8553be9c7668525c66e97d5fdcd52", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d7948c843de94245c794e8c63dd4301a78bb5ba3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/d7948c843de94245c794e8c63dd4301a78bb5ba3/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=d7948c843de94245c794e8c63dd4301a78bb5ba3", "patch": "@@ -1,35 +0,0 @@\n-From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 18 Nov 2021 19:28:40 +0100\n-Subject: [PATCH] Disable unsupported tests\n-\n----\n- crates/core_simd/src/elements/int.rs     | 8 ++++++++\n- crates/core_simd/src/elements/uint.rs    | 4 ++++\n- crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n- crates/core_simd/src/vector.rs           | 2 ++\n- crates/core_simd/tests/masks.rs          | 3 ---\n- 5 files changed, 20 insertions(+), 3 deletions(-)\n-\n-diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index e8e8f68..7173c24 100644\n---- a/crates/core_simd/src/vector.rs\n-+++ b/crates/core_simd/src/vector.rs\n-@@ -250,6 +250,7 @@ where\n-         unsafe { intrinsics::simd_cast(self) }\n-     }\n- \n-+    /*\n-     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n-     ///\n-@@ -473,6 +474,7 @@ where\n-             // Cleared \u2622\ufe0f *mut T Zone\n-         }\n-     }\n-+    */\n- }\n- \n- impl<T, const LANES: usize> Copy for Simd<T, LANES>\n--- \n-2.25.1"}, {"sha": "865aa833a5eef4c01754916a1534d54c84ec175f", "filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,11 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -29,6 +29,7 @@ index 0000000..46fd999\n +path = \"lib.rs\"\n +\n +[dependencies]\n-+rand = \"0.7\"\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "77345b9a17c6edca7102326001fcef783e74a1c9", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-12-13\"\n+channel = \"nightly-2023-01-20\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "c993430b830b6ebe3d4c1fc919f50fd043f57311", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     env::set_var(\"RUSTDOCFLAGS\", env::var(\"RUSTDOCFLAGS\").unwrap_or(String::new()) + &rustflags);\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     let args: Vec<_> = match env::args().nth(1).as_deref() {\n         Some(\"jit\") => {"}, {"sha": "c187f54a60e775a0b2a5bca42406390035f6310d", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     }\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n     Command::new(\"rustc\").args(args).exec();"}, {"sha": "a6528ac41aee08f9f57ae4e396af40c99b239728", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     }\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n     Command::new(\"rustdoc\").args(args).exec();"}, {"sha": "34e3981b5381f5ceeb7e5df8d6a4f6d94ee87b06", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -17,10 +17,10 @@ case $1 in\n         done\n \n         ./clean_all.sh\n-        ./y.rs prepare\n \n-        (cd build_sysroot && cargo update)\n+        ./y.rs prepare\n \n+        (cd download/sysroot && cargo update && cargo fetch && cp Cargo.lock ../../build_sysroot/)\n         ;;\n     \"commit\")\n         git add rust-toolchain build_sysroot/Cargo.lock"}, {"sha": "a08e80dd19abc74bf93036d1707059325464b86e", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -10,7 +10,7 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n-git am ../patches/*-sysroot-*.patch\n+git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-sysroot-*.patch\n \n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n@@ -25,8 +25,8 @@ index d95b5b7f17f..00b6f0e3635 100644\n +compiler_builtins = { version = \"0.1.66\", features = ['rustc-dep-of-std', 'no-asm'] }\n \n  [dev-dependencies]\n- rand = \"0.7\"\n- rand_xorshift = \"0.2\"\n+ rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+ rand_xorshift = \"0.3.0\"\n EOF\n \n cat > config.toml <<EOF\n@@ -51,7 +51,7 @@ popd\n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n \n-export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd build_sysroot/sysroot_src; pwd)\"\n+export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd download/sysroot/sysroot_src; pwd)\"\n \n # Allow the testsuite to use llvm tools\n host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")"}, {"sha": "07c9ae6ee9ff2c1f4340ac0ead9c68879f82ba4e", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -11,7 +11,7 @@ pushd rust\n command -v rg >/dev/null 2>&1 || cargo install ripgrep\n \n rm -r tests/ui/{extern/,unsized-locals/,lto/,linkage*} || true\n-for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{ui,incremental}); do\n+for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{codegen-units,ui,incremental}); do\n   rm $test\n done\n \n@@ -32,20 +32,13 @@ rm tests/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort\n # requires compiling with -Cpanic=unwind\n rm -r tests/ui/macros/rfc-2011-nicer-assert-messages/\n rm -r tests/run-make/test-benches\n+rm tests/ui/test-attrs/test-type.rs\n \n # vendor intrinsics\n rm tests/ui/sse2.rs # cpuid not supported, so sse2 not detected\n rm tests/ui/intrinsics/const-eval-select-x86_64.rs # requires x86_64 vendor intrinsics\n rm tests/ui/simd/array-type.rs # \"Index argument for `simd_insert` is not a constant\"\n-rm tests/ui/simd/intrinsic/generic-bitmask-pass.rs # simd_bitmask unimplemented\n-rm tests/ui/simd/intrinsic/generic-as.rs # simd_as unimplemented\n-rm tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs # simd_saturating_add unimplemented\n rm tests/ui/simd/intrinsic/float-math-pass.rs # simd_fcos unimplemented\n-rm tests/ui/simd/intrinsic/generic-gather-pass.rs # simd_gather unimplemented\n-rm tests/ui/simd/intrinsic/generic-select-pass.rs # simd_select_bitmask unimplemented\n-rm tests/ui/simd/issue-85915-simd-ptrs.rs # simd_gather unimplemented\n-rm tests/ui/simd/issue-89193.rs # simd_gather unimplemented\n-rm tests/ui/simd/simd-bitmask.rs # simd_bitmask unimplemented\n \n # exotic linkages\n rm tests/ui/issues/issue-33992.rs # unsupported linkages\n@@ -64,10 +57,7 @@ rm tests/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and near\n rm tests/ui/target-feature/missing-plusminus.rs # error not implemented\n rm tests/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r tests/run-make/emit-named-files # requires full --emit support\n-rm tests/ui/abi/stack-probes.rs # stack probes not yet implemented\n-rm tests/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n rm -r tests/run-make/repr128-dwarf # debuginfo test\n-rm tests/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n \n # optimization tests\n # ==================\n@@ -88,6 +78,20 @@ rm tests/ui/mir/mir_raw_fat_ptr.rs # same\n rm tests/ui/consts/issue-33537.rs # same\n rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n+rm tests/ui/consts/issue-miri-1910.rs # different error message\n+rm tests/ui/consts/offset_ub.rs # same\n+rm tests/ui/intrinsics/panic-uninitialized-zeroed.rs # same\n+rm tests/ui/lint/lint-const-item-mutation.rs # same\n+rm tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs # same\n+rm tests/ui/suggestions/derive-trait-for-method-call.rs # same\n+rm tests/ui/typeck/issue-46112.rs # same\n+\n+rm tests/ui/proc-macro/crt-static.rs # extra warning about -Cpanic=abort for proc macros\n+rm tests/ui/proc-macro/proc-macro-deprecated-attr.rs # same\n+rm tests/ui/proc-macro/quote-debug.rs # same\n+rm tests/ui/proc-macro/no-missing-docs.rs # same\n+rm tests/ui/rust-2018/proc-macro-crate-in-paths.rs # same\n+\n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n@@ -102,23 +106,20 @@ rm -r tests/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to b\n # ============\n rm tests/incremental/spike-neg1.rs # errors out for some reason\n rm tests/incremental/spike-neg2.rs # same\n-rm tests/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n-rm tests/ui/mir/ssa-analysis-regression-50041.rs # produces ICE\n-rm tests/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n+rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type filed (#1318)\n+rm tests/ui/simd/simd-bitmask.rs # crash\n+\n+rm tests/ui/dyn-star/dyn-star-to-dyn.rs\n+rm tests/ui/dyn-star/dispatch-on-pin-mut.rs\n \n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning\n rm tests/ui/simple_global_asm.rs # TODO add needs-asm-support\n-rm tests/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n-# not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n-rm -r tests/run-make/native-link-modifier-bundle\n rm tests/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n-rm tests/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n \n rm tests/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n "}, {"sha": "3c34585d4191e6ef1eaa80b82dd06dc578972e9a", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -7,6 +7,7 @@ mod returning;\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n+use rustc_session::Session;\n use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n@@ -22,7 +23,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n     default_call_conv: CallConv,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let call_conv = conv_to_call_conv(fn_abi.conv, default_call_conv);\n+    let call_conv = conv_to_call_conv(tcx.sess, fn_abi.conv, default_call_conv);\n \n     let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n@@ -33,24 +34,32 @@ fn clif_sig_from_fn_abi<'tcx>(\n     Signature { params, returns, call_conv }\n }\n \n-pub(crate) fn conv_to_call_conv(c: Conv, default_call_conv: CallConv) -> CallConv {\n+pub(crate) fn conv_to_call_conv(sess: &Session, c: Conv, default_call_conv: CallConv) -> CallConv {\n     match c {\n         Conv::Rust | Conv::C => default_call_conv,\n         Conv::RustCold => CallConv::Cold,\n         Conv::X86_64SysV => CallConv::SystemV,\n         Conv::X86_64Win64 => CallConv::WindowsFastcall,\n-        Conv::ArmAapcs\n-        | Conv::CCmseNonSecureCall\n-        | Conv::Msp430Intr\n+\n+        // Should already get a back compat warning\n+        Conv::X86Fastcall | Conv::X86Stdcall | Conv::X86ThisCall | Conv::X86VectorCall => {\n+            default_call_conv\n+        }\n+\n+        Conv::X86Intr => sess.fatal(\"x86-interrupt call conv not yet implemented\"),\n+\n+        Conv::ArmAapcs => sess.fatal(\"aapcs call conv not yet implemented\"),\n+        Conv::CCmseNonSecureCall => {\n+            sess.fatal(\"C-cmse-nonsecure-call call conv is not yet implemented\");\n+        }\n+\n+        Conv::Msp430Intr\n         | Conv::PtxKernel\n-        | Conv::X86Fastcall\n-        | Conv::X86Intr\n-        | Conv::X86Stdcall\n-        | Conv::X86ThisCall\n-        | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", c),\n+        | Conv::AvrNonBlockingInterrupt => {\n+            unreachable!(\"tried to use {c:?} call conv which only exists on an unsupported target\");\n+        }\n     }\n }\n \n@@ -161,6 +170,12 @@ fn make_local_place<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n ) -> CPlace<'tcx> {\n+    if layout.is_unsized() {\n+        fx.tcx.sess.span_fatal(\n+            fx.mir.local_decls[local].source_info.span,\n+            \"unsized locals are not yet supported\",\n+        );\n+    }\n     let place = if is_ssa {\n         if let rustc_target::abi::Abi::ScalarPair(_, _) = layout.abi {\n             CPlace::new_var_pair(fx, local, layout)"}, {"sha": "d3a8c10657e8d5cdb78f40fdc10695d7685e9c50", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -113,6 +113,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     };\n \n     tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n+    fx.bcx.seal_all_blocks();\n+    fx.bcx.finalize();\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let symbol_name = fx.symbol_name;\n@@ -303,6 +305,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n         let source_info = bb_data.terminator().source_info;\n         fx.set_debug_loc(source_info);\n \n+        let _print_guard =\n+            crate::PrintOnPanic(|| format!(\"terminator {:?}\", bb_data.terminator().kind));\n+\n         match &bb_data.terminator().kind {\n             TerminatorKind::Goto { target } => {\n                 if let TerminatorKind::Return = fx.mir[*target].terminator().kind {\n@@ -464,7 +469,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                     *destination,\n                 );\n             }\n-            TerminatorKind::Resume | TerminatorKind::Abort => {\n+            TerminatorKind::Abort => {\n+                codegen_panic_cannot_unwind(fx, source_info);\n+            }\n+            TerminatorKind::Resume => {\n                 // FIXME implement unwinding\n                 fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n             }\n@@ -487,9 +495,6 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             }\n         };\n     }\n-\n-    fx.bcx.seal_all_blocks();\n-    fx.bcx.finalize();\n }\n \n fn codegen_stmt<'tcx>(\n@@ -932,7 +937,28 @@ pub(crate) fn codegen_panic<'tcx>(\n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, source_info.span);\n }\n \n-pub(crate) fn codegen_panic_inner<'tcx>(\n+pub(crate) fn codegen_panic_nounwind<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    msg_str: &str,\n+    source_info: mir::SourceInfo,\n+) {\n+    let msg_ptr = fx.anonymous_str(msg_str);\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let args = [msg_ptr, msg_len];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::PanicNounwind, &args, source_info.span);\n+}\n+\n+pub(crate) fn codegen_panic_cannot_unwind<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    source_info: mir::SourceInfo,\n+) {\n+    let args = [];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::PanicCannotUnwind, &args, source_info.span);\n+}\n+\n+fn codegen_panic_inner<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n@@ -949,11 +975,7 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![\n-            AbiParam::new(fx.pointer_type),\n-            AbiParam::new(fx.pointer_type),\n-            AbiParam::new(fx.pointer_type),\n-        ],\n+        args.iter().map(|&arg| AbiParam::new(fx.bcx.func.dfg.value_type(arg))).collect(),\n         vec![],\n         args,\n     );"}, {"sha": "f41af3a9e636631949be8a616b799a3dfc6644c8", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -168,6 +168,15 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n+pub(crate) fn codegen_bitcast(fx: &mut FunctionCx<'_, '_, '_>, dst_ty: Type, val: Value) -> Value {\n+    let mut flags = MemFlags::new();\n+    flags.set_endianness(match fx.tcx.data_layout.endian {\n+        rustc_target::abi::Endian::Big => cranelift_codegen::ir::Endianness::Big,\n+        rustc_target::abi::Endian::Little => cranelift_codegen::ir::Endianness::Little,\n+    });\n+    fx.bcx.ins().bitcast(dst_ty, flags, val)\n+}\n+\n pub(crate) fn type_zero_value(bcx: &mut FunctionBuilder<'_>, ty: Type) -> Value {\n     if ty == types::I128 {\n         let zero = bcx.ins().iconst(types::I64, 0);"}, {"sha": "6c4efca442448a700d77e946edb926ab02e8ced9", "filename": "compiler/rustc_codegen_cranelift/src/cranelift_native.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -0,0 +1,248 @@\n+// Vendored from https://github.com/bytecodealliance/wasmtime/blob/b58a197d33f044193c3d608010f5e6ec394ac07e/cranelift/native/src/lib.rs\n+// which is licensed as\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+// unlike rustc_codegen_cranelift itself. Also applies a small change to remove #![cfg_attr] that\n+// rust's CI complains about and to fix formatting to match rustc.\n+// FIXME revert back to the external crate with Cranelift 0.93\n+#![allow(warnings)]\n+\n+//! Performs autodetection of the host for the purposes of running\n+//! Cranelift to generate code to run on the same machine.\n+\n+#![deny(missing_docs, trivial_numeric_casts, unused_extern_crates, unstable_features)]\n+#![warn(unused_import_braces)]\n+\n+use cranelift_codegen::isa;\n+use target_lexicon::Triple;\n+\n+/// Return an `isa` builder configured for the current host\n+/// machine, or `Err(())` if the host machine is not supported\n+/// in the current configuration.\n+pub fn builder() -> Result<isa::Builder, &'static str> {\n+    builder_with_options(true)\n+}\n+\n+/// Return an `isa` builder configured for the current host\n+/// machine, or `Err(())` if the host machine is not supported\n+/// in the current configuration.\n+///\n+/// Selects the given backend variant specifically; this is\n+/// useful when more than oen backend exists for a given target\n+/// (e.g., on x86-64).\n+pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {\n+    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {\n+        isa::LookupError::SupportDisabled => \"support for architecture disabled at compile time\",\n+        isa::LookupError::Unsupported => \"unsupported architecture\",\n+    })?;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !std::is_x86_feature_detected!(\"sse2\") {\n+            return Err(\"x86 support requires SSE2\");\n+        }\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        // These are temporarily enabled by default (see #3810 for\n+        // more) so that a default-constructed `Flags` can work with\n+        // default Wasmtime features. Otherwise, the user must\n+        // explicitly use native flags or turn these on when on x86-64\n+        // platforms to avoid a configuration panic. In order for the\n+        // \"enable if detected\" logic below to work, we must turn them\n+        // *off* (differing from the default) and then re-enable below\n+        // if present.\n+        isa_builder.set(\"has_sse3\", \"false\").unwrap();\n+        isa_builder.set(\"has_ssse3\", \"false\").unwrap();\n+        isa_builder.set(\"has_sse41\", \"false\").unwrap();\n+        isa_builder.set(\"has_sse42\", \"false\").unwrap();\n+\n+        if std::is_x86_feature_detected!(\"sse3\") {\n+            isa_builder.enable(\"has_sse3\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"ssse3\") {\n+            isa_builder.enable(\"has_ssse3\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"sse4.1\") {\n+            isa_builder.enable(\"has_sse41\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"sse4.2\") {\n+            isa_builder.enable(\"has_sse42\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"popcnt\") {\n+            isa_builder.enable(\"has_popcnt\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx\") {\n+            isa_builder.enable(\"has_avx\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx2\") {\n+            isa_builder.enable(\"has_avx2\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"fma\") {\n+            isa_builder.enable(\"has_fma\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"bmi1\") {\n+            isa_builder.enable(\"has_bmi1\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"bmi2\") {\n+            isa_builder.enable(\"has_bmi2\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512bitalg\") {\n+            isa_builder.enable(\"has_avx512bitalg\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512dq\") {\n+            isa_builder.enable(\"has_avx512dq\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512f\") {\n+            isa_builder.enable(\"has_avx512f\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512vl\") {\n+            isa_builder.enable(\"has_avx512vl\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512vbmi\") {\n+            isa_builder.enable(\"has_avx512vbmi\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"lzcnt\") {\n+            isa_builder.enable(\"has_lzcnt\").unwrap();\n+        }\n+    }\n+\n+    #[cfg(target_arch = \"aarch64\")]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        if std::arch::is_aarch64_feature_detected!(\"lse\") {\n+            isa_builder.enable(\"has_lse\").unwrap();\n+        }\n+\n+        if std::arch::is_aarch64_feature_detected!(\"paca\") {\n+            isa_builder.enable(\"has_pauth\").unwrap();\n+        }\n+\n+        if cfg!(target_os = \"macos\") {\n+            // Pointer authentication is always available on Apple Silicon.\n+            isa_builder.enable(\"sign_return_address\").unwrap();\n+            // macOS enforces the use of the B key for return addresses.\n+            isa_builder.enable(\"sign_return_address_with_bkey\").unwrap();\n+        }\n+    }\n+\n+    // There is no is_s390x_feature_detected macro yet, so for now\n+    // we use getauxval from the libc crate directly.\n+    #[cfg(all(target_arch = \"s390x\", target_os = \"linux\"))]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n+        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;\n+        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {\n+            isa_builder.enable(\"has_vxrs_ext2\").unwrap();\n+            // There is no separate HWCAP bit for mie2, so assume\n+            // that any machine with vxrs_ext2 also has mie2.\n+            isa_builder.enable(\"has_mie2\").unwrap();\n+        }\n+    }\n+\n+    // `is_riscv_feature_detected` is nightly only for now, use\n+    // getauxval from the libc crate directly as a temporary measure.\n+    #[cfg(all(target_arch = \"riscv64\", target_os = \"linux\"))]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n+\n+        const HWCAP_RISCV_EXT_A: libc::c_ulong = 1 << (b'a' - b'a');\n+        const HWCAP_RISCV_EXT_C: libc::c_ulong = 1 << (b'c' - b'a');\n+        const HWCAP_RISCV_EXT_D: libc::c_ulong = 1 << (b'd' - b'a');\n+        const HWCAP_RISCV_EXT_F: libc::c_ulong = 1 << (b'f' - b'a');\n+        const HWCAP_RISCV_EXT_M: libc::c_ulong = 1 << (b'm' - b'a');\n+        const HWCAP_RISCV_EXT_V: libc::c_ulong = 1 << (b'v' - b'a');\n+\n+        if (v & HWCAP_RISCV_EXT_A) != 0 {\n+            isa_builder.enable(\"has_a\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_C) != 0 {\n+            isa_builder.enable(\"has_c\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_D) != 0 {\n+            isa_builder.enable(\"has_d\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_F) != 0 {\n+            isa_builder.enable(\"has_f\").unwrap();\n+\n+            // TODO: There doesn't seem to be a bit associated with this extension\n+            // rust enables it with the `f` extension:\n+            // https://github.com/rust-lang/stdarch/blob/790411f93c4b5eada3c23abb4c9a063fb0b24d99/crates/std_detect/src/detect/os/linux/riscv.rs#L43\n+            isa_builder.enable(\"has_zicsr\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_M) != 0 {\n+            isa_builder.enable(\"has_m\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_V) != 0 {\n+            isa_builder.enable(\"has_v\").unwrap();\n+        }\n+\n+        // TODO: ZiFencei does not have a bit associated with it\n+        // TODO: Zbkb does not have a bit associated with it\n+    }\n+\n+    // squelch warnings about unused mut/variables on some platforms.\n+    drop(&mut isa_builder);\n+    drop(infer_native_flags);\n+\n+    Ok(isa_builder)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::builder;\n+    use cranelift_codegen::isa::CallConv;\n+    use cranelift_codegen::settings;\n+\n+    #[test]\n+    fn test() {\n+        if let Ok(isa_builder) = builder() {\n+            let flag_builder = settings::builder();\n+            let isa = isa_builder.finish(settings::Flags::new(flag_builder)).unwrap();\n+\n+            if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n+                assert_eq!(isa.default_call_conv(), CallConv::AppleAarch64);\n+            } else if cfg!(any(unix, target_os = \"nebulet\")) {\n+                assert_eq!(isa.default_call_conv(), CallConv::SystemV);\n+            } else if cfg!(windows) {\n+                assert_eq!(isa.default_call_conv(), CallConv::WindowsFastcall);\n+            }\n+\n+            if cfg!(target_pointer_width = \"64\") {\n+                assert_eq!(isa.pointer_bits(), 64);\n+            } else if cfg!(target_pointer_width = \"32\") {\n+                assert_eq!(isa.pointer_bits(), 32);\n+            } else if cfg!(target_pointer_width = \"16\") {\n+                assert_eq!(isa.pointer_bits(), 16);\n+            }\n+        }\n+    }\n+}\n+\n+/// Version number of this crate.\n+pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");"}, {"sha": "3a7421d8b30d843354e3462d1fec296a7f957035", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -20,6 +20,14 @@ use indexmap::IndexSet;\n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n+pub(crate) fn producer() -> String {\n+    format!(\n+        \"cg_clif (rustc {}, cranelift {})\",\n+        rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n+        cranelift_codegen::VERSION,\n+    )\n+}\n+\n pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n@@ -57,11 +65,7 @@ impl DebugContext {\n \n         let mut dwarf = DwarfUnit::new(encoding);\n \n-        let producer = format!(\n-            \"cg_clif (rustc {}, cranelift {})\",\n-            rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n-            cranelift_codegen::VERSION,\n-        );\n+        let producer = producer();\n         let comp_dir = tcx\n             .sess\n             .opts"}, {"sha": "d4494a9e45de49981df3dcf679809e225132d054", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -108,6 +108,8 @@ impl OngoingCodegen {\n \n         self.concurrency_limiter.finished();\n \n+        sess.abort_if_errors();\n+\n         (\n             CodegenResults {\n                 modules,\n@@ -169,10 +171,22 @@ fn emit_cgu(\n fn emit_module(\n     output_filenames: &OutputFilenames,\n     prof: &SelfProfilerRef,\n-    object: cranelift_object::object::write::Object<'_>,\n+    mut object: cranelift_object::object::write::Object<'_>,\n     kind: ModuleKind,\n     name: String,\n ) -> Result<CompiledModule, String> {\n+    if object.format() == cranelift_object::object::BinaryFormat::Elf {\n+        let comment_section = object.add_section(\n+            Vec::new(),\n+            b\".comment\".to_vec(),\n+            cranelift_object::object::SectionKind::OtherString,\n+        );\n+        let mut producer = vec![0];\n+        producer.extend(crate::debuginfo::producer().as_bytes());\n+        producer.push(0);\n+        object.set_section_data(comment_section, producer, 1);\n+    }\n+\n     let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n     let mut file = match File::create(&tmp_file) {\n         Ok(file) => file,\n@@ -399,8 +413,6 @@ pub(crate) fn run_aot(\n             .collect::<Vec<_>>()\n     });\n \n-    tcx.sess.abort_if_errors();\n-\n     let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim ="}, {"sha": "d2ae6978ca2a8ee84e63410dd0d6d6aa1985461b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -33,8 +33,8 @@ pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n \n                 // cast float to int\n                 let a_lane = match lane_ty {\n-                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n-                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    types::F32 => codegen_bitcast(fx, types::I32, a_lane),\n+                    types::F64 => codegen_bitcast(fx, types::I64, a_lane),\n                     _ => a_lane,\n                 };\n "}, {"sha": "d561cf139b6c9bca3ac97f0d985f006383916322", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -201,7 +201,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n     let mut res = fx.bcx.ins().bmask(int_ty, val);\n \n     if ty.is_float() {\n-        res = fx.bcx.ins().bitcast(ty, res);\n+        res = codegen_bitcast(fx, ty, res);\n     }\n \n     res\n@@ -241,10 +241,9 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             substs,\n             args,\n             destination,\n+            target,\n             source_info.span,\n         );\n-        let ret_block = fx.get_block(target);\n-        fx.bcx.ins().jump(ret_block, &[]);\n     } else if codegen_float_intrinsic_call(fx, intrinsic, args, destination) {\n         let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n@@ -651,7 +650,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let layout = fx.layout_of(substs.type_at(0));\n             if layout.abi.is_uninhabited() {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n                         source_info,\n@@ -664,7 +663,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 && !fx.tcx.permits_zero_init(fx.param_env().and(layout))\n             {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\n                             \"attempted to zero-initialize type `{}`, which is invalid\",\n@@ -680,7 +679,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 && !fx.tcx.permits_uninit_init(fx.param_env().and(layout))\n             {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\n                             \"attempted to leave type `{}` uninitialized, which is invalid\","}, {"sha": "b33eb29754ab70e3fab43eeef4109e6962f99683", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 115, "deletions": 7, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -24,6 +24,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n+    target: BasicBlock,\n     span: Span,\n ) {\n     match intrinsic {\n@@ -277,16 +278,15 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n                 let trap_block = fx.bcx.create_block();\n-                let dummy_block = fx.bcx.create_block();\n                 let true_ = fx.bcx.ins().iconst(types::I8, 1);\n                 fx.bcx.ins().brnz(true_, trap_block, &[]);\n-                fx.bcx.ins().jump(dummy_block, &[]);\n+                let ret_block = fx.get_block(target);\n+                fx.bcx.ins().jump(ret_block, &[]);\n                 fx.bcx.switch_to_block(trap_block);\n                 crate::trap::trap_unimplemented(\n                     fx,\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n \n@@ -770,11 +770,119 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         }\n \n-        // simd_arith_offset\n-        // simd_scatter\n-        // simd_gather\n+        sym::simd_expose_addr | sym::simd_from_exposed_addr | sym::simd_cast_ptr => {\n+            intrinsic_args!(fx, args => (arg); intrinsic);\n+            ret.write_cvalue_transmute(fx, arg);\n+        }\n+\n+        sym::simd_arith_offset => {\n+            intrinsic_args!(fx, args => (ptr, offset); intrinsic);\n+\n+            let (lane_count, ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let pointee_ty = ptr_lane_ty.builtin_deref(true).unwrap().ty;\n+            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n+            assert_eq!(lane_count, ret_lane_count);\n+\n+            for lane_idx in 0..lane_count {\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let offset_lane = offset.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let ptr_diff = if pointee_size != 1 {\n+                    fx.bcx.ins().imul_imm(offset_lane, pointee_size as i64)\n+                } else {\n+                    offset_lane\n+                };\n+                let res_lane = fx.bcx.ins().iadd(ptr_lane, ptr_diff);\n+                let res_lane = CValue::by_val(res_lane, ret_lane_layout);\n+\n+                ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n+            }\n+        }\n+\n+        sym::simd_gather => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+            assert_eq!(val_lane_count, ret_lane_count);\n+\n+            let lane_clif_ty = fx.clif_type(val_lane_ty).unwrap();\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let if_disabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+                let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+                fx.bcx.seal_block(if_disabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                let res = fx.bcx.ins().load(lane_clif_ty, MemFlags::trusted(), ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[res]);\n+\n+                fx.bcx.switch_to_block(if_disabled);\n+                fx.bcx.ins().jump(next, &[val_lane]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+\n+                fx.bcx.ins().nop();\n+\n+                ret.place_lane(fx, lane_idx)\n+                    .write_cvalue(fx, CValue::by_val(res_lane, ret_lane_layout));\n+            }\n+        }\n+\n+        sym::simd_scatter => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, _val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                fx.bcx.ins().store(MemFlags::trusted(), val_lane, ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+            }\n+        }\n+\n         _ => {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            fx.tcx.sess.span_err(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            // Prevent verifier error\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n         }\n     }\n+    let ret_block = fx.get_block(target);\n+    fx.bcx.ins().jump(ret_block, &[]);\n }"}, {"sha": "d3868730557b7e1e4da40a9f684e78be375dcd49", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -57,6 +57,8 @@ mod compiler_builtins;\n mod concurrency_limiter;\n mod config;\n mod constant;\n+// FIXME revert back to the external crate with Cranelift 0.93\n+mod cranelift_native;\n mod debuginfo;\n mod discriminant;\n mod driver;\n@@ -278,12 +280,14 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n-    if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n+    if let target_lexicon::Architecture::Aarch64(_) | target_lexicon::Architecture::X86_64 =\n+        target_triple.architecture\n+    {\n         // Windows depends on stack probes to grow the committed part of the stack\n         flags_builder.enable(\"enable_probestack\").unwrap();\n         flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n     } else {\n-        // __cranelift_probestack is not provided and inline stack probes are only supported on x86_64\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on AArch64 and x86_64\n         flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n     }\n "}, {"sha": "fd45362548c0dcc1f5d88ddda1a83c7555e71d70", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -64,13 +64,20 @@ pub(crate) fn maybe_create_entry_wrapper(\n             ],\n             returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: crate::conv_to_call_conv(\n+                tcx.sess,\n                 tcx.sess.target.options.entry_abi,\n                 m.target_config().default_call_conv,\n             ),\n         };\n \n         let entry_name = tcx.sess.target.options.entry_name.as_ref();\n-        let cmain_func_id = m.declare_function(entry_name, Linkage::Export, &cmain_sig).unwrap();\n+        let cmain_func_id = match m.declare_function(entry_name, Linkage::Export, &cmain_sig) {\n+            Ok(func_id) => func_id,\n+            Err(err) => {\n+                tcx.sess\n+                    .fatal(&format!(\"entry symbol `{entry_name}` declared multiple times: {err}\"));\n+            }\n+        };\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n@@ -162,7 +169,11 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(cmain_func_id, &mut ctx).unwrap();\n+\n+        if let Err(err) = m.define_function(cmain_func_id, &mut ctx) {\n+            tcx.sess.fatal(&format!(\"entry symbol `{entry_name}` defined multiple times: {err}\"));\n+        }\n+\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "26327dca299b930da6a973b0683915c4634c78ae", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -7,7 +7,7 @@ use cranelift_frontend::FunctionBuilder;\n /// otherwise return the given value and false.\n pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-        match bcx.func.dfg[arg_inst] {\n+        match bcx.func.dfg.insts[arg_inst] {\n             // This is the lowering of `Rvalue::Not`\n             InstructionData::IntCompareImm {\n                 opcode: Opcode::IcmpImm,\n@@ -34,7 +34,7 @@ pub(crate) fn maybe_known_branch_taken(\n         return None;\n     };\n \n-    match bcx.func.dfg[arg_inst] {\n+    match bcx.func.dfg.insts[arg_inst] {\n         InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)"}, {"sha": "fa06d6c3ba7f3a2a27b9f14b73d8862cfac75d87", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -514,8 +514,8 @@ impl<'tcx> CPlace<'tcx> {\n                 (types::I32, types::F32)\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n-                | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n-                _ if src_ty.is_vector() && dst_ty.is_vector() => fx.bcx.ins().bitcast(dst_ty, data),\n+                | (types::F64, types::I64) => codegen_bitcast(fx, dst_ty, data),\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => codegen_bitcast(fx, dst_ty, data),\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {"}, {"sha": "fd825d02e355c0bfd3f58a6a8e99a33806ab33be", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -3,7 +3,7 @@\n # This block is ignored by rustc\n set -e\n echo \"[BUILD] y.rs\" 1>&2\n-rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021\n+rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021 -Cpanic=abort\n exec ${0/.rs/.bin} $@\n */\n "}, {"sha": "8ce19c8b5145b818342fa6b5e797ab825bb5bba8", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2d002afe70015f621771d00c9cb4fe115f8cb11/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d002afe70015f621771d00c9cb4fe115f8cb11/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a2d002afe70015f621771d00c9cb4fe115f8cb11", "patch": "@@ -59,7 +59,6 @@ const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n     (\"cranelift-codegen\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-codegen-meta\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-codegen-shared\", \"Apache-2.0 WITH LLVM-exception\"),\n-    (\"cranelift-egraph\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-entity\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-frontend\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-isle\", \"Apache-2.0 WITH LLVM-exception\"),\n@@ -286,7 +285,6 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"cranelift-codegen\",\n     \"cranelift-codegen-meta\",\n     \"cranelift-codegen-shared\",\n-    \"cranelift-egraph\",\n     \"cranelift-entity\",\n     \"cranelift-frontend\",\n     \"cranelift-isle\",\n@@ -321,10 +319,12 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-x86_64-pc-windows-gnu\",\n     \"windows-sys\",\n+    \"windows_aarch64_gnullvm\",\n     \"windows_aarch64_msvc\",\n     \"windows_i686_gnu\",\n     \"windows_i686_msvc\",\n     \"windows_x86_64_gnu\",\n+    \"windows_x86_64_gnullvm\",\n     \"windows_x86_64_msvc\",\n ];\n "}]}