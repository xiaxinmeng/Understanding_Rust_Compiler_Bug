{"sha": "e648c96c5f9b69022ae416040cf0558221a11d77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NDhjOTZjNWY5YjY5MDIyYWU0MTYwNDBjZjA1NTgyMjFhMTFkNzc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-29T00:19:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-11T01:20:42Z"}, "message": "trans: Stop informing LLVM about dllexport\n\nRust's current compilation model makes it impossible on Windows to generate one\nobject file with a complete and final set of dllexport annotations. This is\nbecause when an object is generated the compiler doesn't actually know if it\nwill later be included in a dynamic library or not. The compiler works around\nthis today by flagging *everything* as dllexport, but this has the drawback of\nexposing too much.\n\nThankfully there are alternate methods of specifying the exported surface area\nof a dll on Windows, one of which is passing a `*.def` file to the linker which\nlists all public symbols of the dynamic library. This commit removes all\nlocations that add `dllexport` to LLVM variables and instead dynamically\ngenerates a `*.def` file which is passed to the linker. This file will include\nall the public symbols of the current object file as well as all upstream\nlibraries, and the crucial aspect is that it's only used when generating a\ndynamic library. When generating an executable this file isn't generated, so all\nthe symbols aren't exported from an executable.\n\nTo ensure that statically included native libraries are reexported correctly,\nthe previously added support for the `#[linked_from]` attribute is used to\ndetermine the set of FFI symbols that are exported from a dynamic library, and\nthis is required to get the compiler to link correctly.", "tree": {"sha": "9a00b0e642a2dfe823f6ed89f4bd18027079d39c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a00b0e642a2dfe823f6ed89f4bd18027079d39c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e648c96c5f9b69022ae416040cf0558221a11d77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e648c96c5f9b69022ae416040cf0558221a11d77", "html_url": "https://github.com/rust-lang/rust/commit/e648c96c5f9b69022ae416040cf0558221a11d77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e648c96c5f9b69022ae416040cf0558221a11d77/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18607149fbb0836059a96981c78e10ca52d23cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/18607149fbb0836059a96981c78e10ca52d23cd5", "html_url": "https://github.com/rust-lang/rust/commit/18607149fbb0836059a96981c78e10ca52d23cd5"}], "stats": {"total": 318, "additions": 227, "deletions": 91}, "files": [{"sha": "082c0d526a0f0e7824720ff7c7215aa4c01c62a8", "filename": "mk/platform.mk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -277,10 +277,15 @@ $(foreach target,$(CFG_TARGET), \\\n # Fun times!\n #\n # [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n+#\n+# FIXME(stage0): remove this macro and the usage below (and the commments above)\n+# \t         when a new snapshot is available. Also remove the\n+# \t         RUSTFLAGS$(1)_.._T_ variable in mk/target.mk along with\n+# \t         CUSTOM_DEPS (as they were only added for this)\n define ADD_RUSTC_LLVM_DEF_TO_MSVC\n ifeq ($$(findstring msvc,$(1)),msvc)\n-RUSTFLAGS_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n-CUSTOM_DEPS_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n+RUSTFLAGS0_rustc_llvm_T_$(1) += -C link-args=\"-DEF:$(1)/rt/rustc_llvm.def\"\n+CUSTOM_DEPS0_rustc_llvm_T_$(1) += $(1)/rt/rustc_llvm.def\n \n $(1)/rt/rustc_llvm.def: $$(S)src/etc/mklldef.py $$(S)src/librustc_llvm/lib.rs\n \t$$(CFG_PYTHON) $$^ $$@ rustc_llvm-$$(CFG_FILENAME_EXTRA)"}, {"sha": "cd22a77bd22e11cb1960ed232e0a55ea43f4c999", "filename": "mk/target.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -40,7 +40,7 @@ CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4) := \\\n \t\t  $$(RT_OUTPUT_DIR_$(2))/$$(dep)) \\\n \t\t$$(foreach dep,$$(NATIVE_TOOL_DEPS_$(4)_T_$(2)), \\\n \t\t  $$(TBIN$(1)_T_$(3)_H_$(3))/$$(dep)) \\\n-\t\t$$(CUSTOM_DEPS_$(4)_T_$(2))\n+\t\t$$(CUSTOM_DEPS$(1)_$(4)_T_$(2))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -92,7 +92,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n \t\t$$(LLVM_STDCPP_RUSTFLAGS_$(2)) \\\n \t\t$$(RUSTFLAGS_$(4)) \\\n-\t\t$$(RUSTFLAGS_$(4)_T_$(2)) \\\n+\t\t$$(RUSTFLAGS$(1)_$(4)_T_$(2)) \\\n \t\t--out-dir $$(@D) \\\n \t\t-C extra-filename=-$$(CFG_FILENAME_EXTRA) \\\n \t\t$$<"}, {"sha": "878dc00e7b462bc77da43e61e13ebc27e863d251", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -26,8 +26,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Add the new dylib search path var\n     let var = DynamicLibrary::envvar();\n     let newpath = DynamicLibrary::create_path(&path);\n-    let newpath = newpath.to_str().unwrap().to_string();\n-    cmd.env(var, &newpath);\n+    cmd.env(var, newpath);\n }\n \n pub struct Result {pub status: ExitStatus, pub out: String, pub err: String}"}, {"sha": "abcff6e78e2c6fa0d60717210d19841039a32c82", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -205,8 +205,8 @@ pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n pub const tag_method_argument_names: usize = 0x85;\n pub const tag_method_argument_name: usize = 0x86;\n \n-pub const tag_reachable_extern_fns: usize = 0x10c; // top-level only\n-pub const tag_reachable_extern_fn_id: usize = 0x87;\n+pub const tag_reachable_ids: usize = 0x10c; // top-level only\n+pub const tag_reachable_id: usize = 0x87;\n \n pub const tag_items_data_item_stability: usize = 0x88;\n "}, {"sha": "2ade251018f2645f01eba362901fcc2973761d2f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -352,11 +352,11 @@ pub fn get_method_arg_names(cstore: &cstore::CStore, did: ast::DefId)\n     decoder::get_method_arg_names(&*cdata, did.node)\n }\n \n-pub fn get_reachable_extern_fns(cstore: &cstore::CStore, cnum: ast::CrateNum)\n+pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n     -> Vec<ast::DefId>\n {\n     let cdata = cstore.get_crate_data(cnum);\n-    decoder::get_reachable_extern_fns(&*cdata)\n+    decoder::get_reachable_ids(&*cdata)\n }\n \n pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n@@ -400,3 +400,9 @@ pub fn is_default_impl(cstore: &cstore::CStore, impl_did: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n     decoder::is_default_impl(&*cdata, impl_did.node)\n }\n+\n+pub fn is_extern_fn(cstore: &cstore::CStore, did: ast::DefId,\n+                    tcx: &ty::ctxt) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_extern_fn(&*cdata, did.node, tcx)\n+}"}, {"sha": "c6c18fa14a3404d63ab2b327d885c3bd5d6e6b57", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -45,6 +45,7 @@ use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n+use syntax::abi;\n use syntax::attr;\n use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n@@ -1418,10 +1419,10 @@ pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n     }\n }\n \n-pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n+pub fn get_reachable_ids(cdata: Cmd) -> Vec<ast::DefId> {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n-                                tag_reachable_extern_fns);\n-    reader::tagged_docs(items, tag_reachable_extern_fn_id).map(|doc| {\n+                                tag_reachable_ids);\n+    reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n         ast::DefId {\n             krate: cdata.cnum,\n             node: reader::doc_as_u32(doc),\n@@ -1543,3 +1544,21 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n         Decodable::decode(&mut decoder).unwrap()\n     }).collect()\n }\n+\n+pub fn is_extern_fn(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt) -> bool {\n+    let root_doc = rbml::Doc::new(cdata.data());\n+    let items = reader::get_doc(root_doc, tag_items);\n+    let item_doc = match maybe_find_item(id, items) {\n+        Some(doc) => doc,\n+        None => return false,\n+    };\n+    if let Fn = item_family(item_doc) {\n+        let ty::TypeScheme { generics, ty } = get_type(cdata, id, tcx);\n+        generics.types.is_empty() && match ty.sty {\n+            ty::TyBareFn(_, fn_ty) => fn_ty.abi != abi::Rust,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e0f35b6817b4f1f1429e88d53cc4ebbde4922069", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -1781,9 +1781,8 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     rbml_w.start_tag(tag_crate_deps);\n-    let r = get_ordered_deps(cstore);\n-    for dep in &r {\n-        encode_crate_dep(rbml_w, (*dep).clone());\n+    for dep in &get_ordered_deps(cstore) {\n+        encode_crate_dep(rbml_w, dep);\n     }\n     rbml_w.end_tag();\n }\n@@ -1971,24 +1970,22 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_reachable_extern_fns);\n-\n+// Encodes all reachable symbols in this crate into the metadata.\n+//\n+// This pass is seeded off the reachability list calculated in the\n+// middle::reachable module but filters out items that either don't have a\n+// symbol associated with them (they weren't translated) or if they're an FFI\n+// definition (as that's not defined in this crate).\n+fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n+    rbml_w.start_tag(tag_reachable_ids);\n     for id in ecx.reachable {\n-        if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n-            if let ast::ItemFn(_, _, _, abi, ref generics, _) = i.node {\n-                if abi != abi::Rust && !generics.is_type_parameterized() {\n-                    rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n-                }\n-            }\n-        }\n+        rbml_w.wr_tagged_u32(tag_reachable_id, *id);\n     }\n-\n     rbml_w.end_tag();\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: decoder::CrateDep) {\n+                    dep: &decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name);\n     rbml_w.wr_tagged_str(tag_crate_dep_hash, dep.hash.as_str());\n@@ -2170,7 +2167,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     // Encode miscellaneous info.\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_misc_info(&ecx, krate, &mut rbml_w);\n-    encode_reachable_extern_fns(&ecx, &mut rbml_w);\n+    encode_reachable(&ecx, &mut rbml_w);\n     stats.misc_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items."}, {"sha": "e0d585d6f5b52096378b7d9880f33d0426b2fd90", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -31,6 +31,7 @@\n #![feature(link_args)]\n #![feature(staged_api)]\n #![feature(vec_push_all)]\n+#![cfg_attr(not(stage0), feature(linked_from))]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;\n@@ -598,6 +599,7 @@ pub mod debuginfo {\n // automatically updated whenever LLVM is updated to include an up-to-date\n // set of the libraries we need to link to LLVM for.\n #[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg_attr(not(stage0), linked_from = \"rustllvm\")] // not quite true but good enough\n extern {\n     /* Create and destroy contexts. */\n     pub fn LLVMContextCreate() -> ContextRef;"}, {"sha": "46c7b80670f3c140a81d9fcc7449bf670a08ec4d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -902,6 +902,12 @@ fn link_args(cmd: &mut Linker,\n     }\n     cmd.output_filename(out_filename);\n \n+    // If we're building a dynamic library then some platforms need to make sure\n+    // that all symbols are exported correctly from the dynamic library.\n+    if dylib {\n+        cmd.export_symbols(sess, trans, tmpdir);\n+    }\n+\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here."}, {"sha": "8bd86a3a34a1927fbb09e05421efe18574fe56b8", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -9,14 +9,21 @@\n // except according to those terms.\n \n use std::ffi::OsString;\n+use std::fs::{self, File};\n+use std::io::{self, BufWriter};\n+use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::fs;\n \n use back::archive;\n+use metadata::csearch;\n+use metadata::cstore;\n use session::Session;\n-use session::config;\n use session::config::DebugInfoLevel::{NoDebugInfo, LimitedDebugInfo, FullDebugInfo};\n+use session::config::CrateTypeDylib;\n+use session::config;\n+use syntax::ast;\n+use trans::CrateTranslation;\n \n /// Linker abstraction used by back::link to build up the command to invoke a\n /// linker.\n@@ -48,6 +55,8 @@ pub trait Linker {\n     fn hint_dynamic(&mut self);\n     fn whole_archives(&mut self);\n     fn no_whole_archives(&mut self);\n+    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n+                      tmpdir: &Path);\n }\n \n pub struct GnuLinker<'a> {\n@@ -192,6 +201,10 @@ impl<'a> Linker for GnuLinker<'a> {\n         if !self.takes_hints() { return }\n         self.cmd.arg(\"-Wl,-Bdynamic\");\n     }\n+\n+    fn export_symbols(&mut self, _: &Session, _: &CrateTranslation, _: &Path) {\n+        // noop, visibility in object files takes care of this\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n@@ -301,4 +314,61 @@ impl<'a> Linker for MsvcLinker<'a> {\n     // we do on Unix platforms.\n     fn hint_static(&mut self) {}\n     fn hint_dynamic(&mut self) {}\n+\n+    // Currently the compiler doesn't use `dllexport` (an LLVM attribute) to\n+    // export symbols from a dynamic library. When building a dynamic library,\n+    // however, we're going to want some symbols exported, so this function\n+    // generates a DEF file which lists all the symbols.\n+    //\n+    // The linker will read this `*.def` file and export all the symbols from\n+    // the dynamic library. Note that this is not as simple as just exporting\n+    // all the symbols in the current crate (as specified by `trans.reachable`)\n+    // but rather we also need to possibly export the symbols of upstream\n+    // crates. Upstream rlibs may be linked statically to this dynamic library,\n+    // in which case they may continue to transitively be used and hence need\n+    // their symbols exported.\n+    fn export_symbols(&mut self, sess: &Session, trans: &CrateTranslation,\n+                      tmpdir: &Path) {\n+        let path = tmpdir.join(\"lib.def\");\n+        let res = (|| -> io::Result<()> {\n+            let mut f = BufWriter::new(try!(File::create(&path)));\n+\n+            // Start off with the standard module name header and then go\n+            // straight to exports.\n+            try!(writeln!(f, \"LIBRARY\"));\n+            try!(writeln!(f, \"EXPORTS\"));\n+\n+            // Write out all our local symbols\n+            for sym in trans.reachable.iter() {\n+                try!(writeln!(f, \"  {}\", sym));\n+            }\n+\n+            // Take a look at how all upstream crates are linked into this\n+            // dynamic library. For all statically linked libraries we take all\n+            // their reachable symbols and emit them as well.\n+            let cstore = &sess.cstore;\n+            let symbols = trans.crate_formats[&CrateTypeDylib].iter();\n+            let symbols = symbols.enumerate().filter_map(|(i, f)| {\n+                if let Some(cstore::RequireStatic) = *f {\n+                    Some((i + 1) as ast::CrateNum)\n+                } else {\n+                    None\n+                }\n+            }).flat_map(|cnum| {\n+                csearch::get_reachable_ids(cstore, cnum)\n+            }).map(|did| {\n+                csearch::get_symbol(cstore, did)\n+            });\n+            for symbol in symbols {\n+                try!(writeln!(f, \"  {}\", symbol));\n+            }\n+            Ok(())\n+        })();\n+        if let Err(e) = res {\n+            sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+        }\n+        let mut arg = OsString::from(\"/DEF:\");\n+        arg.push(path);\n+        self.cmd.arg(&arg);\n+    }\n }"}, {"sha": "716b12908172413cc91793545a449b3281917703", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 72, "deletions": 60, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -81,7 +81,7 @@ use trans::type_of::*;\n use trans::value::Value;\n use util::common::indenter;\n use util::sha2::Sha256;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use arena::TypedArena;\n use libc::c_uint;\n@@ -2007,17 +2007,11 @@ pub fn update_linkage(ccx: &CrateContext,\n     match id {\n         Some(id) if ccx.reachable().contains(&id) => {\n             llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-            if ccx.use_dll_storage_attrs() {\n-                llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n-            }\n         },\n         _ => {\n             // `id` does not refer to an item in `ccx.reachable`.\n             if ccx.sess().opts.cg.codegen_units > 1 {\n                 llvm::SetLinkage(llval, llvm::ExternalLinkage);\n-                if ccx.use_dll_storage_attrs() {\n-                    llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n-                }\n             } else {\n                 llvm::SetLinkage(llval, llvm::InternalLinkage);\n             }\n@@ -2158,28 +2152,12 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                                    ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n-    finish_register_fn(ccx, sym, node_id, llfn);\n+    finish_register_fn(ccx, sym, node_id);\n     llfn\n }\n \n-fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n-                      llfn: ValueRef) {\n+fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId) {\n     ccx.item_symbols().borrow_mut().insert(node_id, sym);\n-\n-    // The eh_personality function need to be externally linkable.\n-    let def = ast_util::local_def(node_id);\n-    if ccx.tcx().lang_items.eh_personality() == Some(def) {\n-        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n-        if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-    }\n-    if ccx.tcx().lang_items.eh_unwind_resume() == Some(def) {\n-        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n-        if ccx.use_dll_storage_attrs() {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-    }\n }\n \n fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2201,7 +2179,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n-    finish_register_fn(ccx, sym, node_id, llfn);\n+    finish_register_fn(ccx, sym, node_id);\n     llfn\n }\n \n@@ -2215,8 +2193,8 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n /// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n /// function.\n pub fn create_entry_wrapper(ccx: &CrateContext,\n-                           sp: Span,\n-                           main_llfn: ValueRef) {\n+                            sp: Span,\n+                            main_llfn: ValueRef) {\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n@@ -2242,12 +2220,6 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             panic!();\n         });\n \n-        // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n-        // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n-        if ccx.sess().target.target.options.is_like_windows {\n-            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n-        }\n-\n         let llbb = unsafe {\n             llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn,\n                                                 \"top\\0\".as_ptr() as *const _)\n@@ -2524,7 +2496,8 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n }\n \n pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>,\n-                                            ie: encoder::EncodeInlinedItem<'a>)\n+                                            ie: encoder::EncodeInlinedItem<'a>,\n+                                            reachable: &'a NodeSet)\n                                             -> encoder::EncodeParams<'a, 'tcx> {\n     encoder::EncodeParams {\n         diag: cx.sess().diagnostic(),\n@@ -2534,11 +2507,12 @@ pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'a, 'tcx>\n         link_meta: cx.link_meta(),\n         cstore: &cx.sess().cstore,\n         encode_inlined_item: ie,\n-        reachable: cx.reachable(),\n+        reachable: reachable,\n     }\n }\n \n-pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n+pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate,\n+                      reachable: &NodeSet) -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess().crate_types.borrow().iter().any(|ty| {\n@@ -2551,7 +2525,8 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_inlined_item: encoder::EncodeInlinedItem =\n         Box::new(|ecx, rbml_w, ii| astencode::encode_inlined_item(ecx, rbml_w, ii));\n \n-    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n+    let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item,\n+                                                  reachable);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let mut compressed = encoder::metadata_encoding_version.to_vec();\n     compressed.push_all(&flate::deflate_bytes(&metadata));\n@@ -2576,7 +2551,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n+fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<&str>) {\n     unsafe {\n         let mut declared = HashSet::new();\n \n@@ -2659,6 +2634,41 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n+/// The context provided lists a set of reachable ids as calculated by\n+/// middle::reachable, but this contains far more ids and symbols than we're\n+/// actually exposing from the object file. This function will filter the set in\n+/// the context to the set of ids which correspond to symbols that are exposed\n+/// from the object file being generated.\n+///\n+/// This list is later used by linkers to determine the set of symbols needed to\n+/// be exposed from a dynamic library and it's also encoded into the metadata.\n+pub fn filter_reachable_ids(ccx: &SharedCrateContext) -> NodeSet {\n+    ccx.reachable().iter().map(|x| *x).filter(|id| {\n+        // First, only worry about nodes which have a symbol name\n+        ccx.item_symbols().borrow().contains_key(id)\n+    }).filter(|&id| {\n+        // Next, we want to ignore some FFI functions that are not exposed from\n+        // this crate. Reachable FFI functions can be lumped into two\n+        // categories:\n+        //\n+        // 1. Those that are included statically via a static library\n+        // 2. Those included otherwise (e.g. dynamically or via a framework)\n+        //\n+        // Although our LLVM module is not literally emitting code for the\n+        // statically included symbols, it's an export of our library which\n+        // needs to be passed on to the linker and encoded in the metadata.\n+        //\n+        // As a result, if this id is an FFI item (foreign item) then we only\n+        // let it through if it's included statically.\n+        match ccx.tcx().map.get(id) {\n+            ast_map::NodeForeignItem(..) => {\n+                ccx.sess().cstore.is_statically_included_foreign_item(id)\n+            }\n+            _ => true,\n+        }\n+    }).collect()\n+}\n+\n pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslation {\n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n     let krate = tcx.map.krate();\n@@ -2734,8 +2744,10 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         }\n     }\n \n+    let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n+\n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, krate);\n+    let metadata = write_metadata(&shared_ccx, krate, &reachable_symbol_ids);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n@@ -2770,31 +2782,31 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         .map(|ccx| ModuleTranslation { llcx: ccx.llcx(), llmod: ccx.llmod() })\n         .collect();\n \n-    let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n-        shared_ccx.item_symbols().borrow().get(id).map(|s| s.to_string())\n-    }).collect();\n+    let sess = shared_ccx.sess();\n+    let mut reachable_symbols = reachable_symbol_ids.iter().map(|id| {\n+        shared_ccx.item_symbols().borrow()[id].to_string()\n+    }).collect::<Vec<_>>();\n+    if sess.entry_fn.borrow().is_some() {\n+        reachable_symbols.push(\"main\".to_string());\n+    }\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream\n     // reachable extern fns. These functions are all part of the public ABI of\n     // the final product, so LTO needs to preserve them.\n-    shared_ccx.sess().cstore.iter_crate_data(|cnum, _| {\n-        let syms = csearch::get_reachable_extern_fns(&shared_ccx.sess().cstore, cnum);\n-        reachable.extend(syms.into_iter().map(|did| {\n-            csearch::get_symbol(&shared_ccx.sess().cstore, did)\n-        }));\n-    });\n-\n-    // Make sure that some other crucial symbols are not eliminated from the\n-    // module, including the main function.\n-    reachable.push(\"main\".to_string());\n-\n-    // referenced from .eh_frame section on some platforms\n-    reachable.push(\"rust_eh_personality\".to_string());\n-    // referenced from rt/rust_try.ll\n-    reachable.push(\"rust_eh_personality_catch\".to_string());\n+    if sess.lto() {\n+        sess.cstore.iter_crate_data(|cnum, _| {\n+            let syms = csearch::get_reachable_ids(&sess.cstore, cnum);\n+            reachable_symbols.extend(syms.into_iter().filter(|did| {\n+                csearch::is_extern_fn(&sess.cstore, *did, shared_ccx.tcx())\n+            }).map(|did| {\n+                csearch::get_symbol(&sess.cstore, did)\n+            }));\n+        });\n+    }\n \n     if codegen_units > 1 {\n-        internalize_symbols(&shared_ccx, &reachable.iter().cloned().collect());\n+        internalize_symbols(&shared_ccx,\n+                            &reachable_symbols.iter().map(|x| &x[..]).collect());\n     }\n \n     let metadata_module = ModuleTranslation {\n@@ -2809,7 +2821,7 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n-        reachable: reachable,\n+        reachable: reachable_symbols,\n         crate_formats: formats,\n         no_builtins: no_builtins,\n     }"}, {"sha": "1ec29501b763cddd8a1c1e2b24bc22a5785b61cc", "filename": "src/test/auxiliary/issue-25185-1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-25185-1.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -10,9 +10,12 @@\n \n // no-prefer-dynamic\n \n+#![feature(linked_from)]\n+\n #![crate_type = \"rlib\"]\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n+#[linked_from = \"rust_test_helpers\"]\n extern {\n     pub fn rust_dbg_extern_identity_u32(u: u32) -> u32;\n }"}, {"sha": "8705684111eb46eb276401b9a22170e4a3a9a67e", "filename": "src/test/compile-fail/feature-gate-linked-from.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-linked-from.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[linked_from = \"foo\"] //~ ERROR experimental feature\n+extern {\n+    fn foo();\n+}\n+\n+fn main() {}"}, {"sha": "6351cc76a2e4c9f3e5cdc25f6d66705228cb15c1", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e648c96c5f9b69022ae416040cf0558221a11d77/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=e648c96c5f9b69022ae416040cf0558221a11d77", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-msvc -- sprintf isn't a symbol in msvcrt? maybe a #define?\n \n #![feature(libc, std_misc)]\n "}]}