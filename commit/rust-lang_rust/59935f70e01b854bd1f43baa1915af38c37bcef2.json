{"sha": "59935f70e01b854bd1f43baa1915af38c37bcef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OTM1ZjcwZTAxYjg1NGJkMWY0M2JhYTE5MTVhZjM4YzM3YmNlZjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-24T05:24:13Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-26T04:34:56Z"}, "message": "rustc: move some functions in middle::ty working on Ty to methods.", "tree": {"sha": "7e2e6bf7409e2da6f93b55f64a318fde8d6e3f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e2e6bf7409e2da6f93b55f64a318fde8d6e3f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59935f70e01b854bd1f43baa1915af38c37bcef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59935f70e01b854bd1f43baa1915af38c37bcef2", "html_url": "https://github.com/rust-lang/rust/commit/59935f70e01b854bd1f43baa1915af38c37bcef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59935f70e01b854bd1f43baa1915af38c37bcef2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa03871a6efd240c16eacf6f8e9a56d708a71b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa03871a6efd240c16eacf6f8e9a56d708a71b62", "html_url": "https://github.com/rust-lang/rust/commit/aa03871a6efd240c16eacf6f8e9a56d708a71b62"}], "stats": {"total": 834, "additions": 395, "deletions": 439}, "files": [{"sha": "ec1fd67616b81eb8cdeb2f797e3273409ab74586", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -66,8 +66,8 @@ impl<'tcx> CastTy<'tcx> {\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(..) if ty::type_is_c_like_enum(\n-                tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n+            ty::TyEnum(..) if t.is_c_like_enum(tcx) =>\n+                Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),\n             ty::TyBareFn(..) => Some(CastTy::FnPtr),"}, {"sha": "71c3ffb862840d58a8d3beadca9783f64d946250", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -411,14 +411,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n-        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n+        let fn_ty = match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n             None => ty::expr_ty_adjusted(self.tcx, func_or_rcvr)\n-        });\n+        };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        if return_ty.diverges() {\n+        if fn_ty.fn_ret().diverges() {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "1f137a22b1d2c3b101a6b243cf26c55bcc84bb73", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -656,7 +656,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = ty::pat_ty(cx.tcx, &*real_pat);\n \n         match real_pat.node {\n-            ast::PatIdent(ast::BindByRef(..), _, _) => ty::deref(left_ty, false).unwrap().ty,\n+            ast::PatIdent(ast::BindByRef(..), _, _) => {\n+                left_ty.builtin_deref(false).unwrap().ty\n+            }\n             _ => left_ty,\n         }\n     };"}, {"sha": "2b685f801d7f77de2223d4e572f73ce2f2545ecf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -821,7 +821,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                     // the method call infrastructure should have\n                     // replaced all late-bound regions with variables:\n-                    let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                    let self_ty = method_ty.fn_sig().input(0);\n                     let self_ty = ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap();\n \n                     let (m, r) = match self_ty.sty {"}, {"sha": "aa329d1fab6caf770f10eab8259872a0134e11cc", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -1137,9 +1137,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ast::ExprCall(ref f, ref args) => {\n-            let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f)).diverges()\n-            };\n+            let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n+                ty::expr_ty_adjusted(self.ir.tcx, &**f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n@@ -1152,8 +1151,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ast::ExprMethodCall(_, _, ref args) => {\n             let method_call = ty::MethodCall::expr(expr.id);\n             let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n-            let diverges = ty::ty_fn_ret(method_ty).diverges();\n-            let succ = if diverges {\n+            let succ = if method_ty.fn_ret().diverges() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1500,8 +1498,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match fn_ty.sty {\n             ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n-            _ =>\n-                ty::ty_fn_ret(fn_ty),\n+            _ => fn_ty.fn_ret()\n         }\n     }\n \n@@ -1523,7 +1520,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ty::FnConverging(t_ret)\n                 if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n \n-                if ty::type_is_nil(t_ret) {\n+                if t_ret.is_nil() {\n                     // for nil return types, it is ok to not return a value expl.\n                 } else {\n                     let ends_with_stmt = match body.expr {"}, {"sha": "6e3a36d85c6ae76aa12b988a0cb0961e09f8749f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -426,7 +426,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n-                match ty::deref(base_ty, false) {\n+                match base_ty.builtin_deref(false) {\n                     Some(t) => t.ty,\n                     None => { return Err(()); }\n                 }\n@@ -928,13 +928,13 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Some(method_ty) => {\n                 let ref_ty =\n                     ty::no_late_bound_regions(\n-                        self.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n+                        self.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n                 self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n             }\n             None => base_cmt\n         };\n         let base_cmt_ty = base_cmt.ty;\n-        match ty::deref(base_cmt_ty, true) {\n+        match base_cmt_ty.builtin_deref(true) {\n             Some(mt) => {\n                 let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n@@ -1023,11 +1023,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n \n                 // FIXME(#20649) -- why are we using the `self_ty` as the element type...?\n-                let self_ty = ty::ty_fn_sig(method_ty).input(0);\n+                let self_ty = method_ty.fn_sig().input(0);\n                 ty::no_late_bound_regions(self.tcx(), &self_ty).unwrap()\n             }\n             None => {\n-                match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n+                match base_cmt.ty.builtin_index() {\n                     Some(ty) => ty,\n                     None => {\n                         return Err(());\n@@ -1081,7 +1081,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n                     mutbl:m,\n-                    ty: match ty::deref(base_cmt.ty, false) {\n+                    ty: match base_cmt.ty.builtin_deref(false) {\n                         Some(mt) => mt.ty,\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n@@ -1375,7 +1375,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // types are generated by method resolution and always have\n         // all late-bound regions fully instantiated, so we just want\n         // to skip past the binder.\n-        ty::no_late_bound_regions(self.tcx(), &ty::ty_fn_ret(method_ty))\n+        ty::no_late_bound_regions(self.tcx(), &method_ty.fn_ret())\n            .unwrap()\n            .unwrap() // overloaded ops do not diverge, either\n     }"}, {"sha": "db7b91952a88545b8cd8a7769300d5024847fcd4", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -306,7 +306,7 @@ fn contains_illegal_self_type_reference<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n     let mut error = false;\n-    ty::maybe_walk_ty(ty, |ty| {\n+    ty.maybe_walk(|ty| {\n         match ty.sty {\n             ty::TyParam(ref param_ty) => {\n                 if param_ty.space == SelfSpace {"}, {"sha": "6af10f06a8015de7b4005d290496fc489764634c", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -773,7 +773,7 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let fn_type = selcx.infcx().shallow_resolve(fn_type);\n-    let sig = ty::ty_fn_sig(fn_type);\n+    let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }\n "}, {"sha": "5bac1811ee130cd284931bd98fefd247956d9b35", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -540,7 +540,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let input_types = stack.fresh_trait_ref.0.input_types();\n-        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_fresh(t));\n+        let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n@@ -2334,7 +2334,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // ok to skip binder; it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let sig = ty::ty_fn_sig(self_ty);\n+        let sig = self_ty.fn_sig();\n         let trait_ref =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),\n@@ -2536,15 +2536,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     return Err(Unimplemented);\n                 };\n                 let mut ty_params = vec![];\n-                ty::walk_ty(field, |ty| {\n+                for ty in field.walk() {\n                     if let ty::TyParam(p) = ty.sty {\n                         assert!(p.space == TypeSpace);\n                         let idx = p.idx as usize;\n                         if !ty_params.contains(&idx) {\n                             ty_params.push(idx);\n                         }\n                     }\n-                });\n+                }\n                 if ty_params.is_empty() {\n                     return Err(Unimplemented);\n                 }"}, {"sha": "8470d9d5f819e0f27709f9c1f7078c5838352f56", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 221, "deletions": 262, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -3541,28 +3541,20 @@ impl<'tcx> TyS<'tcx> {\n             _ => false,\n         }\n     }\n-}\n-\n-pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)\n-    where F: FnMut(Ty<'tcx>),\n-{\n-    for ty in ty_root.walk() {\n-        f(ty);\n-    }\n-}\n \n-/// Walks `ty` and any types appearing within `ty`, invoking the\n-/// callback `f` on each type. If the callback returns false, then the\n-/// children of the current type are ignored.\n-///\n-/// Note: prefer `ty.walk()` where possible.\n-pub fn maybe_walk_ty<'tcx,F>(ty_root: Ty<'tcx>, mut f: F)\n-    where F : FnMut(Ty<'tcx>) -> bool\n-{\n-    let mut walker = ty_root.walk();\n-    while let Some(ty) = walker.next() {\n-        if !f(ty) {\n-            walker.skip_current_subtree();\n+    /// Walks `ty` and any types appearing within `ty`, invoking the\n+    /// callback `f` on each type. If the callback returns false, then the\n+    /// children of the current type are ignored.\n+    ///\n+    /// Note: prefer `ty.walk()` where possible.\n+    pub fn maybe_walk<F>(&'tcx self, mut f: F)\n+        where F : FnMut(Ty<'tcx>) -> bool\n+    {\n+        let mut walker = self.walk();\n+        while let Some(ty) = walker.next() {\n+            if !f(ty) {\n+                walker.skip_current_subtree();\n+            }\n         }\n     }\n }\n@@ -3613,128 +3605,126 @@ impl<'tcx> ItemSubsts<'tcx> {\n }\n \n // Type utilities\n-\n-pub fn type_is_nil(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyTuple(ref tys) => tys.is_empty(),\n-        _ => false\n+impl<'tcx> TyS<'tcx> {\n+    pub fn is_nil(&self) -> bool {\n+        match self.sty {\n+            TyTuple(ref tys) => tys.is_empty(),\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_ty_var(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyInfer(TyVar(_)) => true,\n-        _ => false\n+    pub fn is_ty_var(&self) -> bool {\n+        match self.sty {\n+            TyInfer(TyVar(_)) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_bool(ty: Ty) -> bool { ty.sty == TyBool }\n+    pub fn is_bool(&self) -> bool { self.sty == TyBool }\n \n-pub fn type_is_self(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyParam(ref p) => p.space == subst::SelfSpace,\n-        _ => false\n+    pub fn is_self(&self) -> bool {\n+        match self.sty {\n+            TyParam(ref p) => p.space == subst::SelfSpace,\n+            _ => false\n+        }\n     }\n-}\n \n-fn type_is_slice(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n-            TySlice(_) | TyStr => true,\n-            _ => false,\n-        },\n-        _ => false\n+    fn is_slice(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+                TySlice(_) | TyStr => true,\n+                _ => false,\n+            },\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_structural(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyStruct(..) | TyTuple(_) | TyEnum(..) |\n-      TyArray(..) | TyClosure(..) => true,\n-      _ => type_is_slice(ty) | type_is_trait(ty)\n+    pub fn is_structural(&self) -> bool {\n+        match self.sty {\n+            TyStruct(..) | TyTuple(_) | TyEnum(..) |\n+            TyArray(..) | TyClosure(..) => true,\n+            _ => self.is_slice() | self.is_trait()\n+        }\n     }\n-}\n \n-pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n-    match ty.sty {\n-        TyStruct(did, _) => lookup_simd(cx, did),\n-        _ => false\n+    pub fn is_simd(&self, cx: &ctxt) -> bool {\n+        match self.sty {\n+            TyStruct(did, _) => lookup_simd(cx, did),\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        TyArray(ty, _) | TySlice(ty) => ty,\n-        TyStr => mk_mach_uint(cx, ast::TyU8),\n-        _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                  ty)),\n+    pub fn sequence_element_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => ty,\n+            TyStr => mk_mach_uint(cx, ast::TyU8),\n+            _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                      self)),\n+        }\n     }\n-}\n \n-pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        TyStruct(did, substs) => {\n-            let fields = lookup_struct_fields(cx, did);\n-            lookup_field_type(cx, did, fields[0].id, substs)\n+    pub fn simd_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyStruct(did, substs) => {\n+                let fields = lookup_struct_fields(cx, did);\n+                lookup_field_type(cx, did, fields[0].id, substs)\n+            }\n+            _ => panic!(\"simd_type called on invalid type\")\n         }\n-        _ => panic!(\"simd_type called on invalid type\")\n     }\n-}\n \n-pub fn simd_size(cx: &ctxt, ty: Ty) -> usize {\n-    match ty.sty {\n-        TyStruct(did, _) => {\n-            let fields = lookup_struct_fields(cx, did);\n-            fields.len()\n+    pub fn simd_size(&self, cx: &ctxt) -> usize {\n+        match self.sty {\n+            TyStruct(did, _) => {\n+                let fields = lookup_struct_fields(cx, did);\n+                fields.len()\n+            }\n+            _ => panic!(\"simd_size called on invalid type\")\n         }\n-        _ => panic!(\"simd_size called on invalid type\")\n     }\n-}\n \n-pub fn type_is_region_ptr(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyRef(..) => true,\n-        _ => false\n+    pub fn is_region_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRef(..) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_unsafe_ptr(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyRawPtr(_) => return true,\n-      _ => return false\n+    pub fn is_unsafe_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(_) => return true,\n+            _ => return false\n+        }\n     }\n-}\n \n-pub fn type_is_unique(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyBox(_) => true,\n-        _ => false\n+    pub fn is_unique(&self) -> bool {\n+        match self.sty {\n+            TyBox(_) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-/*\n- A scalar type is one that denotes an atomic datum, with no sub-components.\n- (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n- contents are abstract to rustc.)\n-*/\n-pub fn type_is_scalar(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n-      TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n-      TyBareFn(..) | TyRawPtr(_) => true,\n-      _ => false\n+    /*\n+     A scalar type is one that denotes an atomic datum, with no sub-components.\n+     (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+     contents are abstract to rustc.)\n+    */\n+    pub fn is_scalar(&self) -> bool {\n+        match self.sty {\n+            TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n+            TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n+            TyBareFn(..) | TyRawPtr(_) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-/// Returns true if this type is a floating point type and false otherwise.\n-pub fn type_is_floating_point(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyFloat(_) |\n-        TyInfer(FloatVar(_)) =>\n-            true,\n-\n-        _ =>\n-            false,\n+    /// Returns true if this type is a floating point type and false otherwise.\n+    pub fn is_floating_point(&self) -> bool {\n+        match self.sty {\n+            TyFloat(_) |\n+            TyInfer(FloatVar(_)) => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -4508,141 +4498,124 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n     r\n }\n \n-pub fn type_is_trait(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyTrait(..) => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn type_is_integral(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n-      _ => false\n+impl<'tcx> TyS<'tcx> {\n+    pub fn is_trait(&self) -> bool {\n+        match self.sty {\n+            TyTrait(..) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_fresh(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyInfer(FreshTy(_)) => true,\n-      TyInfer(FreshIntTy(_)) => true,\n-      TyInfer(FreshFloatTy(_)) => true,\n-      _ => false\n+    pub fn is_integral(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_uint(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n-      _ => false\n+    pub fn is_fresh(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FreshTy(_)) => true,\n+            TyInfer(FreshIntTy(_)) => true,\n+            TyInfer(FreshFloatTy(_)) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_char(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyChar => true,\n-        _ => false\n+    pub fn is_uint(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyUint(ast::TyUs) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_bare_fn(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyBareFn(..) => true,\n-        _ => false\n+    pub fn is_char(&self) -> bool {\n+        match self.sty {\n+            TyChar => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_bare_fn_item(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyBareFn(Some(_), _) => true,\n-        _ => false\n+    pub fn is_bare_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_fp(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyInfer(FloatVar(_)) | TyFloat(_) => true,\n-      _ => false\n+    pub fn is_bare_fn_item(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(Some(_), _) => true,\n+            _ => false\n+        }\n     }\n-}\n-\n-pub fn type_is_numeric(ty: Ty) -> bool {\n-    return type_is_integral(ty) || type_is_fp(ty);\n-}\n \n-pub fn type_is_signed(ty: Ty) -> bool {\n-    match ty.sty {\n-      TyInt(_) => true,\n-      _ => false\n+    pub fn is_fp(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FloatVar(_)) | TyFloat(_) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_is_machine(ty: Ty) -> bool {\n-    match ty.sty {\n-        TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n-        TyInt(..) | TyUint(..) | TyFloat(..) => true,\n-        _ => false\n+    pub fn is_numeric(&self) -> bool {\n+        self.is_integral() || self.is_fp()\n     }\n-}\n \n-// Whether a type is enum like, that is an enum type with only nullary\n-// constructors\n-pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n-    match ty.sty {\n-        TyEnum(did, _) => {\n-            let variants = enum_variants(cx, did);\n-            if variants.is_empty() {\n-                false\n-            } else {\n-                variants.iter().all(|v| v.args.is_empty())\n-            }\n+    pub fn is_signed(&self) -> bool {\n+        match self.sty {\n+            TyInt(_) => true,\n+            _ => false\n         }\n-        _ => false\n     }\n-}\n \n-// Returns the type and mutability of *ty.\n-//\n-// The parameter `explicit` indicates if this is an *explicit* dereference.\n-// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n-    match ty.sty {\n-        TyBox(ty) => {\n-            Some(mt {\n-                ty: ty,\n-                mutbl: ast::MutImmutable,\n-            })\n-        },\n-        TyRef(_, mt) => Some(mt),\n-        TyRawPtr(mt) if explicit => Some(mt),\n-        _ => None\n+    pub fn is_machine(&self) -> bool {\n+        match self.sty {\n+            TyInt(ast::TyIs) | TyUint(ast::TyUs) => false,\n+            TyInt(..) | TyUint(..) | TyFloat(..) => true,\n+            _ => false\n+        }\n     }\n-}\n \n-pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        TyBox(ty) => ty,\n-        TyRef(_, mt) | TyRawPtr(mt) => mt.ty,\n-        _ => ty\n+    // Whether a type is enum like, that is an enum type with only nullary\n+    // constructors\n+    pub fn is_c_like_enum(&self, cx: &ctxt) -> bool {\n+        match self.sty {\n+            TyEnum(did, _) => {\n+                let variants = enum_variants(cx, did);\n+                if variants.is_empty() {\n+                    false\n+                } else {\n+                    variants.iter().all(|v| v.args.is_empty())\n+                }\n+            }\n+            _ => false\n+        }\n     }\n-}\n \n-// Returns the type of ty[i]\n-pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    match ty.sty {\n-        TyArray(ty, _) | TySlice(ty) => Some(ty),\n-        _ => None\n+    // Returns the type and mutability of *ty.\n+    //\n+    // The parameter `explicit` indicates if this is an *explicit* dereference.\n+    // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    pub fn builtin_deref(&self, explicit: bool) -> Option<mt<'tcx>> {\n+        match self.sty {\n+            TyBox(ty) => {\n+                Some(mt {\n+                    ty: ty,\n+                    mutbl: ast::MutImmutable,\n+                })\n+            },\n+            TyRef(_, mt) => Some(mt),\n+            TyRawPtr(mt) if explicit => Some(mt),\n+            _ => None\n+        }\n     }\n-}\n \n-// Returns the type of elements contained within an 'array-like' type.\n-// This is exactly the same as the above, except it supports strings,\n-// which can't actually be indexed.\n-pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    match ty.sty {\n-        TyArray(ty, _) | TySlice(ty) => Some(ty),\n-        TyStr => Some(tcx.types.u8),\n-        _ => None\n+    // Returns the type of ty[i]\n+    pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => Some(ty),\n+            _ => None\n+        }\n     }\n }\n \n@@ -4725,50 +4698,36 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n     }\n }\n \n-pub fn fn_is_variadic(fty: Ty) -> bool {\n-    match fty.sty {\n-        TyBareFn(_, ref f) => f.sig.0.variadic,\n-        ref s => {\n-            panic!(\"fn_is_variadic() called on non-fn type: {:?}\", s)\n+impl<'tcx> TyS<'tcx> {\n+    pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n+        match self.sty {\n+            TyBareFn(_, ref f) => &f.sig,\n+            _ => panic!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }\n-}\n \n-pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n-    match fty.sty {\n-        TyBareFn(_, ref f) => &f.sig,\n-        ref s => {\n-            panic!(\"ty_fn_sig() called on non-fn type: {:?}\", s)\n+    /// Returns the ABI of the given function.\n+    pub fn fn_abi(&self) -> abi::Abi {\n+        match self.sty {\n+            TyBareFn(_, ref f) => f.abi,\n+            _ => panic!(\"Ty::fn_abi() called on non-fn type\"),\n         }\n     }\n-}\n \n-/// Returns the ABI of the given function.\n-pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n-    match fty.sty {\n-        TyBareFn(_, ref f) => f.abi,\n-        _ => panic!(\"ty_fn_abi() called on non-fn type\"),\n+    // Type accessors for substructures of types\n+    pub fn fn_args(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        self.fn_sig().inputs()\n     }\n-}\n-\n-// Type accessors for substructures of types\n-pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n-    ty_fn_sig(fty).inputs()\n-}\n \n-pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n-    match fty.sty {\n-        TyBareFn(_, ref f) => f.sig.output(),\n-        ref s => {\n-            panic!(\"ty_fn_ret() called on non-fn type: {:?}\", s)\n-        }\n+    pub fn fn_ret(&self) -> Binder<FnOutput<'tcx>> {\n+        self.fn_sig().output()\n     }\n-}\n \n-pub fn is_fn_ty(fty: Ty) -> bool {\n-    match fty.sty {\n-        TyBareFn(..) => true,\n-        _ => false\n+    pub fn is_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n     }\n }\n \n@@ -4935,12 +4894,12 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                     // regions fully instantiated and coverge.\n                                     let fn_ret =\n                                         ty::no_late_bound_regions(cx,\n-                                                                  &ty_fn_ret(method_ty)).unwrap();\n+                                                                  &method_ty.fn_ret()).unwrap();\n                                     adjusted_ty = fn_ret.unwrap();\n                                 }\n                                 None => {}\n                             }\n-                            match deref(adjusted_ty, true) {\n+                            match adjusted_ty.builtin_deref(true) {\n                                 Some(mt) => { adjusted_ty = mt.ty; }\n                                 None => {\n                                     cx.sess.span_bug(\n@@ -5578,7 +5537,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 let arg_tys = if !args.is_empty() {\n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n-                    ty::no_late_bound_regions(cx, &ty_fn_args(ctor_ty)).unwrap()\n+                    ty::no_late_bound_regions(cx, &ctor_ty.fn_args()).unwrap()\n                 } else {\n                     Vec::new()\n                 };\n@@ -6595,7 +6554,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 helper(tcx, output, svh, state);\n             }\n         };\n-        maybe_walk_ty(ty, |ty| {\n+        ty.maybe_walk(|ty| {\n             match ty.sty {\n                 TyBool => byte!(2),\n                 TyChar => byte!(3),\n@@ -6939,7 +6898,7 @@ pub enum ExplicitSelfCategory {\n /// types, nor does it resolve fictitious types.\n pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                                     ty: Ty) {\n-    walk_ty(ty, |ty| {\n+    for ty in ty.walk() {\n         match ty.sty {\n             TyRef(region, _) => {\n                 accumulator.push(*region)\n@@ -6972,7 +6931,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             TyError => {\n             }\n         }\n-    });\n+    }\n \n     fn accum_substs(accumulator: &mut Vec<Region>, substs: &Substs) {\n         match substs.regions {"}, {"sha": "71f3675aecee13711daf4b8f81171283d749732a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -51,7 +51,7 @@ fn fn_sig(f: &mut fmt::Formatter,\n \n     match output {\n         ty::FnConverging(ty) => {\n-            if !ty::type_is_nil(ty) {\n+            if !ty.is_nil() {\n                 try!(write!(f, \" -> {}\", ty));\n             }\n             Ok(())"}, {"sha": "dd47a3a8718420acfd6b3e72b4c3ee6bca12c8b7", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -662,7 +662,12 @@ fn bind_subslice_pat(bcx: Block,\n                      offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n+    let vec_ty_contents = match vec_ty.sty {\n+        ty::TyBox(ty) => ty,\n+        ty::TyRef(_, mt) | ty::TyRawPtr(mt) => mt.ty,\n+        _ => vec_ty\n+    };\n+    let unit_ty = vec_ty_contents.sequence_element_type(bcx.tcx());\n     let vec_datum = match_datum(val, vec_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n@@ -836,7 +841,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n-    if ty::type_is_scalar(rhs_t) {\n+    if rhs_t.is_scalar() {\n         let cmp = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n         return Result::new(cx, cmp);\n     }\n@@ -1140,7 +1145,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n-                kind = if ty::type_is_integral(left_ty) {\n+                kind = if left_ty.is_integral() {\n                     Switch\n                 } else {\n                     Compare"}, {"sha": "db29a43afce77f4fd3c342cb9021a69a2bff5c21", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -262,7 +262,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                     attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n                 } else {\n                     attrs.arg(idx, llvm::NonNullAttribute);\n-                    if ty::type_is_trait(inner) {\n+                    if inner.is_trait() {\n                         attrs.arg(idx + 1, llvm::NonNullAttribute);\n                     }\n                 }\n@@ -291,7 +291,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                     attrs.arg(idx, llvm::DereferenceableAttribute(llsz));\n                 } else {\n                     attrs.arg(idx, llvm::NonNullAttribute);\n-                    if ty::type_is_trait(mt.ty) {\n+                    if mt.ty.is_trait() {\n                         attrs.arg(idx + 1, llvm::NonNullAttribute);\n                     }\n                 }"}, {"sha": "81951600a3a3372c2c13b85de5c1faff575b3bb8", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -40,7 +40,7 @@ use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use middle::weak_lang_items;\n use middle::subst::Substs;\n-use middle::ty::{self, Ty, ClosureTyper, type_is_simd, simd_size, HasTypeFlags};\n+use middle::ty::{self, Ty, ClosureTyper, HasTypeFlags};\n use rustc::ast_map;\n use session::config::{self, NoDebugInfo};\n use session::Session;\n@@ -443,11 +443,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       ty::TyArray(_, n) => {\n         let (base, len) = tvec::get_fixed_base_and_len(cx, data_ptr, n);\n-        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let unit_ty = t.sequence_element_type(cx.tcx());\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n       ty::TySlice(_) | ty::TyStr => {\n-        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        let unit_ty = t.sequence_element_type(cx.tcx());\n         cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n       }\n       ty::TyTuple(ref args) => {\n@@ -626,9 +626,9 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n-        ty::TyStruct(_, _) if type_is_simd(cx.tcx(), rhs_t) => {\n+        ty::TyStruct(_, _) if rhs_t.is_simd(cx.tcx()) => {\n             let mut res = C_bool(cx.ccx(), false);\n-            for i in 0 .. simd_size(cx.tcx(), rhs_t) {\n+            for i in 0 .. rhs_t.simd_size(cx.tcx()) {\n                 res = Or(cx, res,\n                          IsNull(cx,\n                                 ExtractElement(cx, rhs, C_int(cx.ccx(), i as i64))), debug_loc);\n@@ -805,13 +805,13 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let val =  if ty::type_is_bool(t) {\n+    let val =  if t.is_bool() {\n         LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n-    } else if ty::type_is_char(t) {\n+    } else if t.is_char() {\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+    } else if (t.is_region_ptr() || t.is_unique())\n         && !common::type_is_fat_ptr(cx.tcx(), t) {\n             LoadNonNull(cx, ptr)\n     } else {\n@@ -839,15 +839,15 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n }\n \n pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty::type_is_bool(ty) {\n+    if ty.is_bool() {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty::type_is_bool(ty) {\n+    if ty.is_bool() {\n         Trunc(bcx, val, Type::i1(bcx.ccx()))\n     } else {\n         val\n@@ -953,7 +953,7 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n-    if ty::type_is_structural(t) {\n+    if t.is_structural() {\n         let llty = type_of::type_of(ccx, t);\n         let llsz = llsize_of(ccx, llty);\n         let llalign = type_of::align_of(ccx, t);\n@@ -1669,8 +1669,8 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_fn(param_substs={:?})\", param_substs);\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ty::node_id_to_type(ccx.tcx(), id);\n-    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fn_ty));\n-    let abi = ty::ty_fn_abi(fn_ty);\n+    let output_type = ty::erase_late_bound_regions(ccx.tcx(), &fn_ty.fn_ret());\n+    let abi = fn_ty.fn_abi();\n     trans_closure(ccx, decl, body, llfndecl, param_substs, id, attrs, output_type, abi,\n                   closure::ClosureEnv::NotClosure);\n }\n@@ -1800,7 +1800,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys =\n         ty::erase_late_bound_regions(\n-            ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n+            ccx.tcx(), &ctor_ty.fn_args());\n \n     let arg_datums = create_datums_for_fn_args(bcx, &arg_tys[..]);\n \n@@ -2334,7 +2334,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n                         // otherwise some LLVM optimization passes don't work as expected\n-                        let llty = if ty::type_is_bool(ty) {\n+                        let llty = if ty.is_bool() {\n                             llvm::LLVMInt8TypeInContext(ccx.llcx())\n                         } else {\n                             llvm::LLVMTypeOf(v)"}, {"sha": "3b7a92c09ec3f791f10bf51caee4b2a90ef80f53", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -917,7 +917,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n {\n     let args =\n         ty::erase_late_bound_regions(\n-            bcx.tcx(), &ty::ty_fn_args(fn_ty));\n+            bcx.tcx(), &fn_ty.fn_args());\n \n     // Translate the `self` argument first.\n     if !ignore_self {\n@@ -978,7 +978,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                               ignore_self: bool)\n                               -> Block<'blk, 'tcx> {\n     // Translate the `self` argument first.\n-    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &ty::ty_fn_args(fn_ty));\n+    let arg_tys = ty::erase_late_bound_regions(bcx.tcx(),  &fn_ty.fn_args());\n     if !ignore_self {\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         bcx = trans_arg_datum(bcx,\n@@ -1024,8 +1024,8 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n-    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &ty::ty_fn_args(fn_ty));\n-    let variadic = ty::fn_is_variadic(fn_ty);\n+    let arg_tys = ty::erase_late_bound_regions(cx.tcx(), &fn_ty.fn_args());\n+    let variadic = fn_ty.fn_sig().0.variadic;\n \n     let mut bcx = cx;\n "}, {"sha": "2aa12e088aa12ae4178f0067e17fcd7488214fc3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -155,7 +155,7 @@ pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<\n         }\n \n         let mut needs_unwind_cleanup = false;\n-        ty::maybe_walk_ty(ty, |ty| {\n+        ty.maybe_walk(|ty| {\n             needs_unwind_cleanup |= match ty.sty {\n                 ty::TyBool | ty::TyInt(_) | ty::TyUint(_) |\n                 ty::TyFloat(_) | ty::TyTuple(_) | ty::TyRawPtr(_) => false,\n@@ -234,10 +234,10 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     use trans::type_of::sizing_type_of;\n \n     let tcx = ccx.tcx();\n-    let simple = ty::type_is_scalar(ty) ||\n-        ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n+    let simple = ty.is_scalar() ||\n+        ty.is_unique() || ty.is_region_ptr() ||\n         type_is_newtype_immediate(ccx, ty) ||\n-        ty::type_is_simd(tcx, ty);\n+        ty.is_simd(tcx);\n     if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n@@ -267,7 +267,7 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n /// zero-size, but not all zero-size types use a `void` return type (in order to aid with C ABI\n /// compatibility).\n pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n-    ty::type_is_nil(ty) || ty::type_is_empty(ccx.tcx(), ty)\n+    ty.is_nil() || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create"}, {"sha": "30cb0680b6997f5e161a2cf6ff5d2a5ab113cf38", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -149,7 +149,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                          v: ValueRef,\n                          ty: Ty<'tcx>)\n                          -> (ValueRef, Ty<'tcx>) {\n-    match ty::deref(ty, true) {\n+    match ty.builtin_deref(true) {\n         Some(mt) => {\n             if type_is_sized(cx.tcx(), mt.ty) {\n                 (const_deref_ptr(cx, v), mt.ty)\n@@ -323,7 +323,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               param_substs,\n                                                               &target);\n \n-                let pointee_ty = ty::deref(ty, true)\n+                let pointee_ty = ty.builtin_deref(true)\n                     .expect(\"consts: unsizing got non-pointer type\").ty;\n                 let (base, old_info) = if !type_is_sized(cx.tcx(), pointee_ty) {\n                     // Normally, the source is a thin pointer and we are\n@@ -338,7 +338,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (llconst, None)\n                 };\n \n-                let unsized_ty = ty::deref(target, true)\n+                let unsized_ty = target.builtin_deref(true)\n                     .expect(\"consts: unsizing got non-pointer target type\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, unsized_ty).ptr_to();\n                 let base = ptrcast(base, ptr_ty);\n@@ -499,14 +499,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n-            let is_simd = ty::type_is_simd(cx.tcx(), ty);\n+            let is_simd = ty.is_simd(cx.tcx());\n             let intype = if is_simd {\n-                ty::simd_type(cx.tcx(), ty)\n+                ty.simd_type(cx.tcx())\n             } else {\n                 ty\n             };\n-            let is_float = ty::type_is_fp(intype);\n-            let signed = ty::type_is_signed(intype);\n+            let is_float = intype.is_fp();\n+            let signed = intype.is_signed();\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs, fn_args);\n \n@@ -572,7 +572,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             check_unary_expr_validity(cx, e, ty, te);\n \n-            let is_float = ty::type_is_fp(ty);\n+            let is_float = ty.is_fp();\n             match u {\n               ast::UnUniq | ast::UnDeref => {\n                 const_deref(cx, te, ty).0\n@@ -660,7 +660,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             if type_is_fat_ptr(cx.tcx(), t_expr) {\n                 // Fat pointer casts.\n-                let t_cast_inner = ty::deref(t_cast, true).expect(\"cast to non-pointer\").ty;\n+                let t_cast_inner = t_cast.builtin_deref(true).expect(\"cast to non-pointer\").ty;\n                 let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n                 let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n                                    ptr_ty);\n@@ -681,11 +681,11 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Int(_)) => {\n-                let s = ty::type_is_signed(t_expr) as Bool;\n+                let s = t_expr.is_signed() as Bool;\n                 llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n               (CastTy::Int(_), CastTy::Float) => {\n-                if ty::type_is_signed(t_expr) {\n+                if t_expr.is_signed() {\n                     llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n                     llvm::LLVMConstUIToFP(v, llty.to_ref())\n@@ -781,15 +781,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  if ty::type_is_simd(cx.tcx(), ety) {\n+                  if ety.is_simd(cx.tcx()) {\n                       C_vector(&cs[..])\n                   } else {\n                       adt::trans_const(cx, &*repr, discr, &cs[..])\n                   }\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n                               .collect::<Vec<_>>();\n@@ -801,7 +801,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = ty::eval_repeat_count(cx.tcx(), count);\n             let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n@@ -875,7 +875,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n                   }\n                   def::DefStruct(_) => {\n-                      if ty::type_is_simd(cx.tcx(), ety) {\n+                      if ety.is_simd(cx.tcx()) {\n                           C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);"}, {"sha": "d7083eb2d333623ab70953e028dd427637e77681", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -640,7 +640,7 @@ impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     }\n \n     pub fn to_llbool<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(ty::type_is_bool(self.ty));\n+        assert!(self.ty.is_bool());\n         self.to_llscalarish(bcx)\n     }\n }"}, {"sha": "95c18e6006384b798768fb2aaaa822c9a0173397", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -1192,7 +1192,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n             fields: fields,\n-            is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n+            is_simd: struct_type.is_simd(cx.tcx()),\n             span: span,\n         })\n     )"}, {"sha": "3c63f0fa30c1a57fa8ca0b27bb2933b0c5f098a3", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -416,7 +416,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let return_type = monomorphize::apply_param_substs(cx.tcx(),\n                                                            param_substs,\n                                                            &return_type);\n-        if ty::type_is_nil(return_type) {\n+        if return_type.is_nil() {\n             signature.push(ptr::null_mut())\n         } else {\n             signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));"}, {"sha": "4092ba8bfa55a40f4e25e8ed29225dc6f72b2624", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -144,7 +144,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(')');\n \n             match sig.output {\n-                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n                     push_debuginfo_type_name(cx, result_type, true, output);"}, {"sha": "9d30023cd189af39c99c26cd0af6fd81f391feee", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -252,7 +252,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llty = type_of::type_of(bcx.ccx(), const_ty);\n             // HACK(eddyb) get around issues with lifetime intrinsics.\n             let scratch = alloca_no_lifetime(bcx, llty, \"const\");\n-            let lldest = if !ty::type_is_structural(const_ty) {\n+            let lldest = if !const_ty.is_structural() {\n                 // Cast pointer to slot, because constants have different types.\n                 PointerCast(bcx, scratch, val_ty(global))\n             } else {\n@@ -790,8 +790,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let ref_ty = // invoked methods have LB regions instantiated:\n                 ty::no_late_bound_regions(\n-                    bcx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n-            let elt_ty = match ty::deref(ref_ty, true) {\n+                    bcx.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n+            let elt_ty = match ref_ty.builtin_deref(true) {\n                 None => {\n                     bcx.tcx().sess.span_bug(index_expr.span,\n                                             \"index method didn't return a \\\n@@ -835,7 +835,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                       ccx.int_type());\n             let ix_val = {\n                 if ix_size < int_size {\n-                    if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                    if expr_ty(bcx, idx).is_signed() {\n                         SExt(bcx, ix_val, ccx.int_type())\n                     } else { ZExt(bcx, ix_val, ccx.int_type()) }\n                 } else if ix_size > int_size {\n@@ -845,7 +845,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), base_datum.ty);\n+            let unit_ty = base_datum.ty.sequence_element_type(bcx.tcx());\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n@@ -1490,7 +1490,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    if ty::type_is_simd(bcx.tcx(), ty) {\n+    if ty.is_simd(bcx.tcx()) {\n         // Issue 23112: The original logic appeared vulnerable to same\n         // order-of-eval bug. But, SIMD values are tuple-structs;\n         // i.e. functional record update (FRU) syntax is unavailable.\n@@ -1626,11 +1626,11 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let val = datum.to_llscalarish(bcx);\n             let (bcx, llneg) = {\n-                if ty::type_is_fp(un_ty) {\n+                if un_ty.is_fp() {\n                     let result = FNeg(bcx, val, debug_loc);\n                     (bcx, result)\n                 } else {\n-                    let is_signed = ty::type_is_signed(un_ty);\n+                    let is_signed = un_ty.is_signed();\n                     let result = Neg(bcx, val, debug_loc);\n                     let bcx = if bcx.ccx().check_overflow() && is_signed {\n                         let (llty, min) = base::llty_and_min_for_signed_ty(bcx, un_ty);\n@@ -1735,14 +1735,14 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n-    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let is_simd = lhs_t.is_simd(tcx);\n     let intype = if is_simd {\n-        ty::simd_type(tcx, lhs_t)\n+        lhs_t.simd_type(tcx)\n     } else {\n         lhs_t\n     };\n-    let is_float = ty::type_is_fp(intype);\n-    let is_signed = ty::type_is_signed(intype);\n+    let is_float = intype.is_fp();\n+    let is_signed = intype.is_signed();\n     let info = expr_info(binop_expr);\n \n     let binop_debug_loc = binop_expr.debug_loc();\n@@ -1999,7 +1999,7 @@ pub fn cast_is_noop<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return true;\n     }\n \n-    match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n+    match (t_in.builtin_deref(true), t_out.builtin_deref(true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n         }\n@@ -2108,7 +2108,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ll_t_in = val_ty(discr);\n         (discr, adt::is_discr_signed(&*repr))\n     } else {\n-        (datum.to_llscalarish(bcx), ty::type_is_signed(t_in))\n+        (datum.to_llscalarish(bcx), t_in.is_signed())\n     };\n \n     let newval = match (r_t_in, r_t_out) {\n@@ -2242,7 +2242,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             let ref_ty = // invoked methods have their LB regions instantiated\n                 ty::no_late_bound_regions(\n-                    ccx.tcx(), &ty::ty_fn_ret(method_ty)).unwrap().unwrap();\n+                    ccx.tcx(), &method_ty.fn_ret()).unwrap().unwrap();\n             let scratch = rvalue_scratch_datum(bcx, ref_ty, \"overloaded_deref\");\n \n             unpack_result!(bcx, trans_overloaded_op(bcx, expr, method_call,\n@@ -2545,13 +2545,13 @@ fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n     let tcx = bcx.tcx();\n-    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let is_simd = lhs_t.is_simd(tcx);\n     let intype = if is_simd {\n-        ty::simd_type(tcx, lhs_t)\n+        lhs_t.simd_type(tcx)\n     } else {\n         lhs_t\n     };\n-    let is_signed = ty::type_is_signed(intype);\n+    let is_signed = intype.is_signed();\n     if is_signed {\n         AShr(bcx, lhs, rhs, binop_debug_loc)\n     } else {"}, {"sha": "2ac6b02445cceebeff8eb4275dd9d1b085b9f68a", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -324,7 +324,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            if ty::type_is_bool(passed_arg_tys[i]) {\n+            if passed_arg_tys[i].is_bool() {\n                 let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n@@ -450,7 +450,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n     if !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &ast::Ty, ty: ty::Ty| {\n-            if ty::type_is_simd(tcx, ty) {\n+            if ty.is_simd(tcx) {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n@@ -777,7 +777,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // pointer).  It makes adapting types easier, since we can\n             // always just bitcast pointers.\n             if !foreign_indirect {\n-                llforeign_arg = if ty::type_is_bool(rust_ty) {\n+                llforeign_arg = if rust_ty.is_bool() {\n                     let lltemp = builder.alloca(Type::bool(ccx), \"\");\n                     builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n                     lltemp\n@@ -799,7 +799,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let llrust_arg = if rust_indirect || type_is_fat_ptr(ccx.tcx(), rust_ty) {\n                 llforeign_arg\n             } else {\n-                if ty::type_is_bool(rust_ty) {\n+                if rust_ty.is_bool() {\n                     let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n                     builder.trunc(tmp, Type::i1(ccx))\n                 } else if type_of::type_of(ccx, rust_ty).is_aggregate() {"}, {"sha": "5e7f067a4b3b87d893436d8fbcd98a7cc448aa51", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -392,7 +392,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n-            assert!(!ty::type_is_simd(bcx.tcx(), t));\n+            assert!(!t.is_simd(bcx.tcx()));\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_of(ccx, &*repr, true);\n             let sized_size = C_uint(ccx, llsize_of_alloc(ccx, sizing_type));\n@@ -426,7 +426,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+            let unit_ty = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);"}, {"sha": "8b28d9c1250e78139a4b4fe8ef5a5b7db2dc6062", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -253,7 +253,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, vec_expr: &ast::Expr)\n                                    -> VecTypes<'tcx> {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n-    vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n+    vec_types(bcx, vec_ty.sequence_element_type(bcx.tcx()))\n }\n \n fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)"}, {"sha": "a27166844806c630255e57b4c25c5bb92a0710d3", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -222,9 +222,9 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyStruct(..) => {\n-            if ty::type_is_simd(cx.tcx(), t) {\n-                let llet = type_of(cx, ty::simd_type(cx.tcx(), t));\n-                let n = ty::simd_size(cx.tcx(), t) as u64;\n+            if t.is_simd(cx.tcx()) {\n+                let llet = type_of(cx, t.simd_type(cx.tcx()));\n+                let n = t.simd_size(cx.tcx()) as u64;\n                 ensure_array_fits_in_address_space(cx, llet, n, t);\n                 Type::vector(&llet, n)\n             } else {\n@@ -245,15 +245,15 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n }\n \n pub fn foreign_arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if ty::type_is_bool(t) {\n+    if t.is_bool() {\n         Type::i1(cx)\n     } else {\n         type_of(cx, t)\n     }\n }\n \n pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if ty::type_is_bool(t) {\n+    if t.is_bool() {\n         Type::i1(cx)\n     } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n@@ -402,9 +402,9 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::type_of(cx, &*repr)\n       }\n       ty::TyStruct(did, ref substs) => {\n-          if ty::type_is_simd(cx.tcx(), t) {\n-              let llet = in_memory_type_of(cx, ty::simd_type(cx.tcx(), t));\n-              let n = ty::simd_size(cx.tcx(), t) as u64;\n+          if t.is_simd(cx.tcx()) {\n+              let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n+              let n = t.simd_size(cx.tcx()) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n               Type::vector(&llet, n)\n           } else {\n@@ -434,7 +434,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n-                if !ty::type_is_simd(cx.tcx(), t) => {\n+                if !t.is_simd(cx.tcx()) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n         }"}, {"sha": "6b11efb478287d991d876567d95fa7751277fef3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -90,7 +90,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let rhs_ty = fcx.expr_ty(end);\n \n             // Check that both end-points are of numeric or char type.\n-            let numeric_or_char = |t| ty::type_is_numeric(t) || ty::type_is_char(t);\n+            let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n             let lhs_compat = numeric_or_char(lhs_ty);\n             let rhs_compat = numeric_or_char(rhs_ty);\n \n@@ -303,8 +303,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                         ty: inner_ty,\n-                        mutbl: ty::deref(expected_ty, true).map(|mt| mt.mutbl)\n-                                                           .unwrap_or(ast::MutImmutable)\n+                        mutbl: expected_ty.builtin_deref(true).map(|mt| mt.mutbl)\n+                                                              .unwrap_or(ast::MutImmutable)\n                     })\n                 }\n             };\n@@ -321,7 +321,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n             if let Some(ref slice) = *slice {\n                 let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                let mutbl = ty::deref(expected_ty, true)\n+                let mutbl = expected_ty.builtin_deref(true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n                 let slice_ty = ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n@@ -411,7 +411,7 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let tcx = pcx.fcx.ccx.tcx;\n     if pat_is_binding(&tcx.def_map, inner) {\n         let expected = fcx.infcx().shallow_resolve(expected);\n-        ty::deref(expected, true).map_or(true, |mt| match mt.ty.sty {\n+        expected.builtin_deref(true).map_or(true, |mt| match mt.ty.sty {\n             ty::TyTrait(_) => {\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n@@ -633,8 +633,8 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n     let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n-    let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n-        let fn_ret = ty::no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty)).unwrap();\n+    let path_scheme = if ctor_scheme.ty.is_fn() {\n+        let fn_ret = ty::no_late_bound_regions(tcx, &ctor_scheme.ty.fn_ret()).unwrap();\n         ty::TypeScheme {\n             ty: fn_ret.unwrap(),\n             generics: ctor_scheme.generics,"}, {"sha": "4951a9a6f2f162e64c1a87af7e7ebfd651df16eb", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -360,7 +360,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 // refactor it.)\n                 let method_sig =\n                     ty::no_late_bound_regions(fcx.tcx(),\n-                                              ty::ty_fn_sig(method_callee.ty)).unwrap();\n+                                              method_callee.ty.fn_sig()).unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={:?}\",\n                        method_callee);"}, {"sha": "1ff4c4eb0f455597078196e50d25f2836fa1f8a0", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> CastCheck<'tcx> {\n     fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n-        if ty::type_is_numeric(t_cast) && ty::type_is_numeric(t_expr) {\n+        if t_cast.is_numeric() && t_expr.is_numeric() {\n             fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                                     self.expr.id,\n                                     self.span,"}, {"sha": "a5b812ee80ee8066865a60c3588a5910e5260b94", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -536,8 +536,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 }\n                                 Some(ty::AutoPtr(_, _)) => {\n                                     (adr.autoderefs, adr.unsize.map(|target| {\n-                                        ty::deref(target, false)\n-                                            .expect(\"fixup: AutoPtr is not &T\").ty\n+                                        target.builtin_deref(false)\n+                                              .expect(\"fixup: AutoPtr is not &T\").ty\n                                     }))\n                                 }\n                                 Some(_) => {"}, {"sha": "de09a98b89e52059fe53834e11a1732e5988f3eb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -229,7 +229,7 @@ impl<'tcx> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.infcx().shallow_resolve(ety);\n-                if !ty::type_is_ty_var(ety) {\n+                if !ety.is_ty_var() {\n                     ExpectHasType(ety)\n                 } else {\n                     NoExpectation\n@@ -1146,7 +1146,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n             };\n-            if ty::type_is_trait(t_cast) {\n+            if t_cast.is_trait() {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n                         fcx.tcx().sess.span_suggestion(t_span,\n@@ -1948,7 +1948,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             UnresolvedTypeAction::Ignore => {\n                 // We can continue even when the type cannot be resolved\n-                // (i.e. it is an inference variable) because `ty::deref`\n+                // (i.e. it is an inference variable) because `Ty::builtin_deref`\n                 // and `try_overloaded_deref` both simply return `None`\n                 // in such a case without producing spurious errors.\n                 fcx.resolve_type_vars_if_possible(t)\n@@ -1964,7 +1964,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let mt = match ty::deref(resolved_t, false) {\n+        let mt = match resolved_t.builtin_deref(false) {\n             Some(mt) => Some(mt),\n             None => {\n                 let method_call =\n@@ -2045,15 +2045,15 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Some(method) => {\n             // extract method method return type, which will be &T;\n             // all LB regions should have been instantiated during method lookup\n-            let ret_ty = ty::ty_fn_ret(method.ty);\n+            let ret_ty = method.ty.fn_ret();\n             let ret_ty = ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap();\n \n             if let Some(method_call) = method_call {\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n             }\n \n             // method returns &T, but the type as visible to user is T, so deref\n-            ty::deref(ret_ty, true)\n+            ret_ty.builtin_deref(true)\n         }\n         None => None,\n     }\n@@ -2125,7 +2125,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let input_ty = fcx.infcx().next_ty_var();\n \n     // First, try built-in indexing.\n-    match (ty::index(adjusted_ty), &index_ty.sty) {\n+    match (adjusted_ty.builtin_index(), &index_ty.sty) {\n         (Some(ty), &ty::TyUint(ast::TyUs)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n@@ -3160,7 +3160,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 ast::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n-                    oprnd_t = match ty::deref(oprnd_t, true) {\n+                    oprnd_t = match oprnd_t.builtin_deref(true) {\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n@@ -3179,8 +3179,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n-                    if !(ty::type_is_integral(oprnd_t) ||\n-                         oprnd_t.sty == ty::TyBool) {\n+                    if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                         oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n                                                       tcx.lang_items.not_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n@@ -3189,8 +3188,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 ast::UnNeg => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n                                                          oprnd_t);\n-                    if !(ty::type_is_integral(oprnd_t) ||\n-                         ty::type_is_fp(oprnd_t)) {\n+                    if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                         oprnd_t = op::check_user_unop(fcx, \"-\", \"neg\",\n                                                       tcx.lang_items.neg_trait(),\n                                                       expr, &**oprnd, oprnd_t, unop);\n@@ -4201,7 +4199,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n-            if !ty::type_is_machine(e) {\n+            if !e.is_machine() {\n                 span_err!(tcx.sess, sp, E0077,\n                     \"SIMD vector element type should be machine type\");\n                 return;\n@@ -4870,11 +4868,11 @@ fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n {\n     let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n-    if ty::type_is_ty_var(ty) {\n+    if ty.is_ty_var() {\n         let alternative = f();\n \n         // If not, error.\n-        if ty::type_is_ty_var(alternative) || alternative.references_error() {\n+        if alternative.is_ty_var() || alternative.references_error() {\n             fcx.type_error_message(sp, |_actual| {\n                 \"the type of this value must be known in this context\".to_string()\n             }, ty, None);\n@@ -4933,15 +4931,12 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if tps.is_empty() { return; }\n     let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n-    ty::walk_ty(ty, |t| {\n-            match t.sty {\n-                ty::TyParam(ParamTy {idx, ..}) => {\n-                    debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx as usize] = true;\n-                }\n-                _ => ()\n-            }\n-        });\n+    for leaf_ty in ty.walk() {\n+        if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n+            debug!(\"Found use of ty param num {}\", idx);\n+            tps_used[idx as usize] = true;\n+        }\n+    }\n \n     for (i, b) in tps_used.iter().enumerate() {\n         if !*b {"}, {"sha": "48dc64e8c8b495356b0d387d48069b37c383f210", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -86,7 +86,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // traits, because their return type is not bool. Perhaps this\n     // should change, but for now if LHS is SIMD we go down a\n     // different path that bypassess all traits.\n-    if ty::type_is_simd(fcx.tcx(), lhs_ty) {\n+    if lhs_ty.is_simd(fcx.tcx()) {\n         check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n         let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n         let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -122,8 +122,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // can't pin this down to a specific impl.\n             let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n             if\n-                !ty::type_is_ty_var(lhs_ty) &&\n-                !ty::type_is_ty_var(rhs_ty) &&\n+                !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n                 is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op)\n             {\n                 let builtin_return_ty =\n@@ -157,7 +156,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         BinOpCategory::Shift => {\n             // For integers, the shift amount can be of any integral\n             // type. For simd, the type must match exactly.\n-            if ty::type_is_simd(tcx, lhs_ty) {\n+            if lhs_ty.is_simd(tcx) {\n                 demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n             }\n \n@@ -177,12 +176,12 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n \n             // if this is simd, result is same as lhs, else bool\n-            if ty::type_is_simd(tcx, lhs_ty) {\n-                let unit_ty = ty::simd_type(tcx, lhs_ty);\n+            if lhs_ty.is_simd(tcx) {\n+                let unit_ty = lhs_ty.simd_type(tcx);\n                 debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n                        lhs_ty,\n                        unit_ty);\n-                if !ty::type_is_integral(unit_ty) {\n+                if !unit_ty.is_integral() {\n                     tcx.sess.span_err(\n                         lhs_expr.span,\n                         &format!(\"binary comparison operation `{}` not supported \\\n@@ -335,7 +334,7 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n-            let ret_ty = ty::ty_fn_ret(method_ty);\n+            let ret_ty = method_ty.fn_ret();\n             Ok(ty::no_late_bound_regions(fcx.tcx(), &ret_ty).unwrap().unwrap())\n         }\n         None => {\n@@ -429,29 +428,29 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n \n         BinOpCategory::Shift => {\n             lhs.references_error() || rhs.references_error() ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n \n         BinOpCategory::Math => {\n             lhs.references_error() || rhs.references_error() ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_floating_point() && rhs.is_floating_point() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n \n         BinOpCategory::Bitwise => {\n             lhs.references_error() || rhs.references_error() ||\n-                ty::type_is_integral(lhs) && ty::type_is_integral(rhs) ||\n-                ty::type_is_floating_point(lhs) && ty::type_is_floating_point(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs) ||\n-                ty::type_is_bool(lhs) && ty::type_is_bool(rhs)\n+                lhs.is_integral() && rhs.is_integral() ||\n+                lhs.is_floating_point() && rhs.is_floating_point() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx) ||\n+                lhs.is_bool() && rhs.is_bool()\n         }\n \n         BinOpCategory::Comparison => {\n             lhs.references_error() || rhs.references_error() ||\n-                ty::type_is_scalar(lhs) && ty::type_is_scalar(rhs) ||\n-                ty::type_is_simd(cx, lhs) && ty::type_is_simd(cx, rhs)\n+                lhs.is_scalar() && rhs.is_scalar() ||\n+                lhs.is_simd(cx) && rhs.is_simd(cx)\n         }\n     }\n }"}, {"sha": "e06ebd0276ffd7122c6e64baf914405a6c238b5d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -662,7 +662,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        ty::no_late_bound_regions(rcx.tcx(), &ty::ty_fn_ret(method.ty)).unwrap();\n+                        ty::no_late_bound_regions(rcx.tcx(), &method.ty.fn_ret()).unwrap();\n                     fn_ret.unwrap()\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -891,7 +891,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n-                let fn_sig = ty::ty_fn_sig(method.ty);\n+                let fn_sig = method.ty.fn_sig();\n                 let fn_sig = // late-bound regions should have been instantiated\n                     ty::no_late_bound_regions(rcx.tcx(), fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n@@ -937,7 +937,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                             r_deref_expr, *r_ptr);\n         }\n \n-        match ty::deref(derefd_ty, true) {\n+        match derefd_ty.builtin_deref(true) {\n             Some(mt) => derefd_ty = mt.ty,\n             /* if this type can't be dereferenced, then there's already an error\n                in the session saying so. Just bail out for now */"}, {"sha": "aa6f533401dd62876a73134d3ca3e06a49ac7327", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -661,7 +661,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     // enum def'n, and hence will all be early bound\n                     let arg_tys =\n                         ty::no_late_bound_regions(\n-                            fcx.tcx(), &ty::ty_fn_args(ctor_ty)).unwrap();\n+                            fcx.tcx(), &ctor_ty.fn_args()).unwrap();\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "2bf8c5b5fafd355911b4c56d4782c32516b8fe4a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -95,7 +95,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let rhs_ty = self.fcx.node_ty(rhs.id);\n             let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n \n-            if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n+            if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                 self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n \n                 // weird but true: the by-ref binops put an"}, {"sha": "6c1235e5a7569dad40736ea5d39b9e2ad0243d79", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -1882,16 +1882,15 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n-            ty::walk_ty(ty, |t| {\n-                match t.sty {\n-                    ty::TyParam(p) => if p.idx > cur_idx {\n+            for leaf_ty in ty.walk() {\n+                if let ty::TyParam(p) = leaf_ty.sty {\n+                    if p.idx > cur_idx {\n                         span_err!(tcx.sess, path.span, E0128,\n                                   \"type parameters with a default cannot use \\\n                                    forward declared identifiers\");\n-                        },\n-                        _ => {}\n                     }\n-            });\n+                }\n+            }\n \n             Some(ty)\n         }"}, {"sha": "7844d71462cfccf93c2942ef5a1e3a779b8e84d3", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59935f70e01b854bd1f43baa1915af38c37bcef2/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=59935f70e01b854bd1f43baa1915af38c37bcef2", "patch": "@@ -24,7 +24,7 @@ pub enum Parameter {\n /// by `ty` (see RFC 447).\n pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n     let mut result = vec![];\n-    ty::maybe_walk_ty(ty, |t| {\n+    ty.maybe_walk(|t| {\n         if let ty::TyProjection(..) = t.sty {\n             false // projections are not injective.\n         } else {"}]}