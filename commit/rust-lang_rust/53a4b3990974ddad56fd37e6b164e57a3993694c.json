{"sha": "53a4b3990974ddad56fd37e6b164e57a3993694c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYTRiMzk5MDk3NGRkYWQ1NmZkMzdlNmIxNjRlNTdhMzk5MzY5NGM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-27T21:42:19Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-10-01T19:44:45Z"}, "message": "handle outlives predicates in trait evaluation\n\nFixes #54302.", "tree": {"sha": "0fbf5882823863331a67466cc8094ef11a0740a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fbf5882823863331a67466cc8094ef11a0740a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53a4b3990974ddad56fd37e6b164e57a3993694c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53a4b3990974ddad56fd37e6b164e57a3993694c", "html_url": "https://github.com/rust-lang/rust/commit/53a4b3990974ddad56fd37e6b164e57a3993694c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53a4b3990974ddad56fd37e6b164e57a3993694c/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb", "html_url": "https://github.com/rust-lang/rust/commit/de3d640f59c4fa4a09faf2a8d6b0a812aaa6d6cb"}], "stats": {"total": 282, "additions": 278, "deletions": 4}, "files": [{"sha": "8258b54104d97f5cd14bba2549ca955870a2b7e0", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -362,6 +362,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                         match binder.no_late_bound_regions() {\n                             // If so, this obligation is an error (for now). Eventually we should be\n                             // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+                            // NOTE: this is duplicate-implemented between here and fulfillment.\n                             None => {\n                                 ProcessResult::Error(CodeSelectionError(Unimplemented))\n                             }"}, {"sha": "0e087153673e7b6bf326d92aa10b3e5a831ea2b2", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -690,10 +690,76 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n-                // we do not consider region relationships when\n-                // evaluating trait matches\n-                Ok(EvaluatedToOk)\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                assert!(!binder.has_escaping_regions());\n+                // Check if the type has higher-ranked regions.\n+                if binder.skip_binder().0.has_escaping_regions() {\n+                    // If so, this obligation is an error (for now). Eventually we should be\n+                    // able to support additional cases here, like `for<'a> &'a str: 'a`.\n+\n+                    // NOTE: this hack is implemented in both trait fulfillment and\n+                    // evaluation. If you fix it in one place, make sure you fix it\n+                    // in the other.\n+\n+                    // We don't want to allow this sort of reasoning in intercrate\n+                    // mode, for backwards-compatibility reasons.\n+                    if self.intercrate.is_some() {\n+                        Ok(EvaluatedToAmbig)\n+                    } else {\n+                        Ok(EvaluatedToErr)\n+                    }\n+                } else {\n+                    // If the type has no late bound regions, then if we assign all\n+                    // the inference variables in it to be 'static, then the type\n+                    // will be 'static itself.\n+                    //\n+                    // Therefore, `staticize(T): 'a` holds for any `'a`, so this\n+                    // obligation is fulfilled. Because evaluation works with\n+                    // staticized types (yes I know this is involved with #21974),\n+                    // we are 100% OK here.\n+                    Ok(EvaluatedToOk)\n+                }\n+            }\n+\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                let ty::OutlivesPredicate(r_a, r_b) = binder.skip_binder();\n+\n+                if r_a == r_b {\n+                    // for<'a> 'a: 'a. OK\n+                    Ok(EvaluatedToOk)\n+                } else if r_a.is_late_bound() || r_b.is_late_bound() {\n+                    // There is no current way to prove `for<'a> 'a: 'x`\n+                    // unless `'a = 'x`, because there are no bounds involving\n+                    // lifetimes.\n+\n+                    // It is possible to solve `for<'a> 'x: 'a` where `'x`\n+                    // is a free region by forcing `'x = 'static`. However,\n+                    // fulfillment does not *quite* do this ATM (it calls\n+                    // `region_outlives_predicate`, which is OK if `'x` is\n+                    // literally ReStatic, but is *not* OK if `'x` is any\n+                    // sort of inference variable, even if it *is* equal\n+                    // to `'static`).\n+\n+                    // If we ever want to handle that sort of obligations,\n+                    // we need to make sure we are not confused by\n+                    // technically-allowed-by-RFC-447-but-probably-should-not-be\n+                    // impls such as\n+                    // ```Rust\n+                    // impl<'a, 's, T> X<'s> for T where T: Debug + 's, 'a: 's\n+                    // ```\n+\n+                    // We don't want to allow this sort of reasoning in intercrate\n+                    // mode, for backwards-compatibility reasons.\n+                    if self.intercrate.is_some() {\n+                        Ok(EvaluatedToAmbig)\n+                    } else {\n+                        Ok(EvaluatedToErr)\n+                    }\n+                } else {\n+                    // Relating 2 inference variable regions. These will\n+                    // always hold if our query is \"staticized\".\n+                    Ok(EvaluatedToOk)\n+                }\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n@@ -900,6 +966,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\",\n                    stack.fresh_trait_ref);\n+\n             let cycle = stack.iter().skip(1).take(rec_index + 1);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {"}, {"sha": "6d1c61c80f06e983d4224e20fb375f4bce55c4eb", "filename": "src/test/ui/issue-54302-cases.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302-cases.rs?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Mirror {\n+    type Image;\n+    fn coerce(self) -> Self::Image;\n+}\n+\n+impl<T> Mirror for T {\n+    type Image = T;\n+    fn coerce(self) -> Self { self }\n+}\n+\n+trait Foo<'x, T> {\n+    fn foo(self) -> &'x T;\n+}\n+\n+impl<'s, 'x, T: 'x> Foo<'x, T> for &'s T where &'s T: Foo2<'x, T> {\n+    fn foo(self) -> &'x T { self.foo2() }\n+}\n+\n+trait Foo2<'x, T> {\n+    fn foo2(self) -> &'x T;\n+}\n+\n+// example 1 - fails leak check\n+impl<'x> Foo2<'x, u32> for &'x u32\n+{\n+    fn foo2(self) -> &'x u32 { self }\n+}\n+\n+// example 2 - OK with this issue\n+impl<'x, 'a: 'x> Foo2<'x, i32> for &'a i32\n+{\n+    fn foo2(self) -> &'x i32 { self }\n+}\n+\n+// example 3 - fails due to issue #XYZ + Leak-check\n+impl<'x, T> Foo2<'x, u64> for T\n+    where T: Mirror<Image=&'x u64>\n+{\n+    fn foo2(self) -> &'x u64 { self.coerce() }\n+}\n+\n+// example 4 - fails due to issue #XYZ\n+impl<'x, 'a: 'x, T> Foo2<'x, i64> for T\n+    where T: Mirror<Image=&'a i64>\n+{\n+    fn foo2(self) -> &'x i64 { self.coerce() }\n+}\n+\n+\n+trait RefFoo<T> {\n+    fn ref_foo(&self) -> &'static T;\n+}\n+\n+impl<T> RefFoo<T> for T where for<'a> &'a T: Foo<'static, T> {\n+    fn ref_foo(&self) -> &'static T {\n+        self.foo()\n+    }\n+}\n+\n+\n+fn coerce_lifetime1(a: &u32) -> &'static u32\n+{\n+    <u32 as RefFoo<u32>>::ref_foo(a)\n+    //~^ ERROR the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+}\n+\n+fn coerce_lifetime2(a: &i32) -> &'static i32\n+{\n+    <i32 as RefFoo<i32>>::ref_foo(a)\n+    //~^ ERROR the requirement `for<'a> 'a : ` is not satisfied\n+}\n+\n+fn coerce_lifetime3(a: &u64) -> &'static u64\n+{\n+    <u64 as RefFoo<u64>>::ref_foo(a)\n+    //~^ ERROR type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+}\n+\n+fn coerce_lifetime4(a: &i64) -> &'static i64\n+{\n+    <i64 as RefFoo<i64>>::ref_foo(a)\n+    //~^ ERROR type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+}\n+\n+fn main() {}"}, {"sha": "9603f7a973c139e3422f833730f00204ca7e28bc", "filename": "src/test/ui/issue-54302-cases.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302-cases.stderr?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -0,0 +1,65 @@\n+error[E0277]: the trait bound `for<'a> &'a u32: Foo2<'_, u32>` is not satisfied\n+  --> $DIR/issue-54302-cases.rs:73:5\n+   |\n+LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a> Foo2<'_, u32>` is not implemented for `&'a u32`\n+   |\n+   = help: the following implementations were found:\n+             <&'x u32 as Foo2<'x, u32>>\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u32>` for `&'a u32`\n+   = note: required because of the requirements on the impl of `RefFoo<u32>` for `u32`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0279]: the requirement `for<'a> 'a : ` is not satisfied (`expected bound lifetime parameter 'a, found concrete lifetime`)\n+  --> $DIR/issue-54302-cases.rs:79:5\n+   |\n+LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i32>` for `&'a i32`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i32>` for `&'a i32`\n+   = note: required because of the requirements on the impl of `RefFoo<i32>` for `i32`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `for<'a> <&'a u64 as Mirror>::Image == &u64`\n+  --> $DIR/issue-54302-cases.rs:85:5\n+   |\n+LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, u64>` for `&'a u64`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, u64>` for `&'a u64`\n+   = note: required because of the requirements on the impl of `RefFoo<u64>` for `u64`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `for<'a> <&'a i64 as Mirror>::Image == &i64`\n+  --> $DIR/issue-54302-cases.rs:91:5\n+   |\n+LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |\n+   = note: required because of the requirements on the impl of `for<'a> Foo2<'_, i64>` for `&'a i64`\n+   = note: required because of the requirements on the impl of `for<'a> Foo<'static, i64>` for `&'a i64`\n+   = note: required because of the requirements on the impl of `RefFoo<i64>` for `i64`\n+note: required by `RefFoo::ref_foo`\n+  --> $DIR/issue-54302-cases.rs:61:5\n+   |\n+LL |     fn ref_foo(&self) -> &'static T;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors occurred: E0271, E0277, E0279.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "969d19cac2d76d57d86271784f2867a600cd85b9", "filename": "src/test/ui/issue-54302.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302.rs?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Deserialize<'de> {}\n+\n+trait DeserializeOwned: for<'de> Deserialize<'de> {}\n+impl<T> DeserializeOwned for T where T: for<'de> Deserialize<'de> {}\n+\n+// Based on this impl, `&'static str` only implements Deserialize<'static>.\n+// It does not implement for<'de> Deserialize<'de>.\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a str {}\n+\n+fn main() {\n+    // Then why does it implement DeserializeOwned? This compiles.\n+    fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+    assert_deserialize_owned::<&'static str>();\n+    //~^ ERROR the requirement `for<'de> 'de : ` is not satisfied\n+\n+    // It correctly does not implement for<'de> Deserialize<'de>.\n+    //fn assert_hrtb<T: for<'de> Deserialize<'de>>() {}\n+    //assert_hrtb::<&'static str>();\n+}"}, {"sha": "f122daeecf63a7cd4f2e4b58c715cf9b9ea904ea", "filename": "src/test/ui/issue-54302.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a4b3990974ddad56fd37e6b164e57a3993694c/src%2Ftest%2Fui%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54302.stderr?ref=53a4b3990974ddad56fd37e6b164e57a3993694c", "patch": "@@ -0,0 +1,17 @@\n+error[E0279]: the requirement `for<'de> 'de : ` is not satisfied (`expected bound lifetime parameter 'de, found concrete lifetime`)\n+  --> $DIR/issue-54302.rs:23:5\n+   |\n+LL |     assert_deserialize_owned::<&'static str>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'de> Deserialize<'de>` for `&'static str`\n+   = note: required because of the requirements on the impl of `DeserializeOwned` for `&'static str`\n+note: required by `main::assert_deserialize_owned`\n+  --> $DIR/issue-54302.rs:22:5\n+   |\n+LL |     fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0279`."}]}