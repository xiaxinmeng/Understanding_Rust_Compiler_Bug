{"sha": "43ce38375d95fcc33c550037bfb96ef2a75ce253", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzY2UzODM3NWQ5NWZjYzMzYzU1MDAzN2JmYjk2ZWYyYTc1Y2UyNTM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T08:53:37Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-03T10:34:12Z"}, "message": "Store item paths in ast_map, get rid of trans::local_ctxt\n\nThe direct motivation for this was that the monomorphizer needs to be\nable to generate sane symbols for random items. The typechecker can\nprobably also use this in the future to provide more useful error\nmessages.", "tree": {"sha": "a5a97ce956600bdabf764773cd1b94b1134238bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5a97ce956600bdabf764773cd1b94b1134238bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ce38375d95fcc33c550037bfb96ef2a75ce253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ce38375d95fcc33c550037bfb96ef2a75ce253", "html_url": "https://github.com/rust-lang/rust/commit/43ce38375d95fcc33c550037bfb96ef2a75ce253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ce38375d95fcc33c550037bfb96ef2a75ce253/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1b075d042cabb90f804f3d73e6a4f4b512aa697", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b075d042cabb90f804f3d73e6a4f4b512aa697", "html_url": "https://github.com/rust-lang/rust/commit/c1b075d042cabb90f804f3d73e6a4f4b512aa697"}], "stats": {"total": 783, "additions": 383, "deletions": 400}, "files": [{"sha": "eee0c60599f291be74e6661562d0a5fa580cbb9a", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -18,6 +18,7 @@ import syntax::ast;\n import syntax::print::pprust;\n import lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False};\n import util::filesearch;\n+import middle::ast_map::{path, path_mod, path_name};\n \n enum output_type {\n     output_type_none,\n@@ -514,25 +515,27 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n     ret hash;\n }\n \n-fn mangle(ss: [str]) -> str {\n+fn mangle(ss: path) -> str {\n     // Follow C++ namespace-mangling style\n \n     let n = \"_ZN\"; // Begin name-sequence.\n \n-    for s: str in ss { n += #fmt[\"%u%s\", str::byte_len(s), s]; }\n+    for s in ss {\n+        alt s { path_name(s) | path_mod(s) {\n+          n += #fmt[\"%u%s\", str::byte_len(s), s];\n+        } }\n+    }\n     n += \"E\"; // End name-sequence.\n-\n-    ret n;\n+    n\n }\n \n-fn exported_name(path: [str], hash: str, _vers: str) -> str {\n+fn exported_name(path: path, hash: str, _vers: str) -> str {\n     // FIXME: versioning isn't working yet\n-\n-    ret mangle(path + [hash]); //  + \"@\" + vers;\n+    ret mangle(path + [path_name(hash)]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(ccx: @crate_ctxt, path: [str], t: ty::t) -> str {\n+fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n@@ -541,15 +544,15 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n    str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    ret mangle([name, s, hash]);\n+    ret mangle([path_name(name), path_name(s), path_name(hash)]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: [str],\n+fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n                                         flav: str) -> str {\n-    ret mangle(path + [ccx.names(flav)]);\n+    ret mangle(path + [path_name(ccx.names(flav))]);\n }\n \n-fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: [str]) -> str {\n+fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> str {\n     ret mangle(path);\n }\n "}, {"sha": "8648d4878271074c8ba5a878a52ee4f4c9398d7d", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -447,11 +447,11 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     encode_info_for_mod(ecx, ebml_w, crate_mod, crate_node_id, \"\");\n     ecx.ccx.ast_map.items {|key, val|\n         alt val {\n-          middle::ast_map::node_item(i) {\n+          middle::ast_map::node_item(i, _) {\n             index += [{val: key, pos: ebml_w.writer.tell()}];\n             encode_info_for_item(ecx, ebml_w, i, index);\n           }\n-          middle::ast_map::node_native_item(i) {\n+          middle::ast_map::node_native_item(i, _) {\n             index += [{val: key, pos: ebml_w.writer.tell()}];\n             encode_info_for_native_item(ecx, ebml_w, i);\n           }"}, {"sha": "c47c0d9b9f42ebf862df447229336d7029a2a63d", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -4,10 +4,13 @@ import syntax::ast::*;\n import syntax::ast_util;\n import syntax::{visit, codemap};\n \n+enum path_elt { path_mod(str), path_name(str) }\n+type path = [path_elt];\n+\n enum ast_node {\n-    node_item(@item),\n-    node_native_item(@native_item),\n-    node_method(@method),\n+    node_item(@item, @path),\n+    node_native_item(@native_item, @path),\n+    node_method(@method, @path),\n     node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n     // order they are introduced.\n@@ -17,66 +20,78 @@ enum ast_node {\n }\n \n type map = std::map::map<node_id, ast_node>;\n-type ctx = @{map: map, mutable local_id: uint};\n+type ctx = {map: map, mutable path: path, mutable local_id: uint};\n+type vt = visit::vt<ctx>;\n \n fn map_crate(c: crate) -> map {\n-    let cx = @{map: std::map::new_int_hash(),\n-               mutable local_id: 0u};\n-\n-    let v_map = visit::mk_simple_visitor\n-        (@{visit_item: bind map_item(cx, _),\n-           visit_native_item: bind map_native_item(cx, _),\n-           visit_expr: bind map_expr(cx, _),\n-           visit_fn: bind map_fn(cx, _, _, _, _, _),\n-           visit_local: bind map_local(cx, _),\n-           visit_arm: bind map_arm(cx, _)\n-           with *visit::default_simple_visitor()});\n-    visit::visit_crate(c, (), v_map);\n+    let cx = {map: std::map::new_int_hash(),\n+              mutable path: [],\n+              mutable local_id: 0u};\n+    visit::visit_crate(c, cx, visit::mk_vt(@{\n+        visit_item: map_item,\n+        visit_native_item: map_native_item,\n+        visit_expr: map_expr,\n+        visit_fn: map_fn,\n+        visit_local: map_local,\n+        visit_arm: map_arm\n+        with *visit::default_visitor()\n+    }));\n     ret cx.map;\n }\n \n-fn map_fn(cx: ctx, _fk: visit::fn_kind, decl: fn_decl, _body: blk,\n-          _sp: codemap::span, _id: node_id) {\n+fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n+          sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for a in decl.inputs {\n         cx.map.insert(a.id, node_arg(a, cx.local_id));\n         cx.local_id += 1u;\n     }\n+    visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-fn map_local(cx: ctx, loc: @local) {\n+fn map_local(loc: @local, cx: ctx, v: vt) {\n     pat_util::pat_bindings(loc.node.pat) {|p_id, _s, _p|\n         cx.map.insert(p_id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };\n+    visit::visit_local(loc, cx, v);\n }\n \n-fn map_arm(cx: ctx, arm: arm) {\n+fn map_arm(arm: arm, cx: ctx, v: vt) {\n     pat_util::pat_bindings(arm.pats[0]) {|p_id, _s, _p|\n         cx.map.insert(p_id, node_local(cx.local_id));\n         cx.local_id += 1u;\n     };\n+    visit::visit_arm(arm, cx, v);\n }\n \n-fn map_item(cx: ctx, i: @item) {\n-    cx.map.insert(i.id, node_item(i));\n+fn map_item(i: @item, cx: ctx, v: vt) {\n+    cx.map.insert(i.id, node_item(i, @cx.path));\n     alt i.node {\n       item_impl(_, _, _, ms) {\n-        for m in ms { cx.map.insert(m.id, node_method(m)); }\n+        for m in ms { cx.map.insert(m.id, node_method(m, @cx.path)); }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n         cx.map.insert(ctor_id, node_res_ctor(i));\n-        cx.map.insert(dtor_id, node_item(i));\n+        cx.map.insert(dtor_id, node_item(i, @cx.path));\n       }\n       _ { }\n     }\n+    alt i.node {\n+      item_mod(_) | item_native_mod(_) { cx.path += [path_mod(i.ident)]; }\n+      _ { cx.path += [path_name(i.ident)]; }\n+    }\n+    visit::visit_item(i, cx, v);\n+    vec::pop(cx.path);\n }\n \n-fn map_native_item(cx: ctx, i: @native_item) {\n-    cx.map.insert(i.id, node_native_item(i));\n+fn map_native_item(i: @native_item, cx: ctx, v: vt) {\n+    cx.map.insert(i.id, node_native_item(i, @cx.path));\n+    visit::visit_native_item(i, cx, v);\n }\n \n-fn map_expr(cx: ctx, ex: @expr) {\n+fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     cx.map.insert(ex.id, node_expr(ex));\n+    visit::visit_expr(ex, cx, v);\n }\n \n // Local Variables:"}, {"sha": "187e0a88a7a2931f8b40c331086b71d43d5a3544", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -761,7 +761,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n     let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n-      ast_map::node_item(item) {\n+      ast_map::node_item(item, _) {\n         alt item.node {\n           ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {\n             (item.ident, decl.output, item.id)\n@@ -770,7 +770,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n                 bound to non-function\"); }\n         }\n       }\n-      ast_map::node_method(method) {\n+      ast_map::node_method(method, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_res_ctor(item) {\n@@ -808,7 +808,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n       option::none {}\n     }\n \n-    let path = str::connect(fcx.lcx.path + [ident], \"::\");\n+    let path = path_str(fcx.path);\n \n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        sp.lo);"}, {"sha": "4e4caa2848c74c2e546085f8eb6fc730ac5667a1", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -480,7 +480,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // is this a main fn declaration?\n     alt fk {\n       visit::fk_item_fn(nm, _) {\n-        if is_main_name([nm]) && !e.sess.building_library {\n+        if is_main_name([ast_map::path_name(nm)]) &&\n+           !e.sess.building_library {\n             // This is a main function -- set it in the session\n             // as the main ID\n             e.sess.main_fn = some((id, sp));"}, {"sha": "ef458a54f979ef02798fdd2ce880f625d2328ad5", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -470,15 +470,6 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n     ret s;\n }\n \n-//fn variant_names(ccx: @crate_ctxt, tag_id: ast::def_id) -> [str] {\n-//    assert ast::local_crate == tag_id.crate;\n-//    alt ccx.tcx.items.get(tag_id.node) {\n-//      ast_map::node_item(@{node: ast::item_tag(variants, _), _}) {\n-//        vec::map(variants) {|variant| variant.node.name}\n-//      }\n-//    }\n-//}\n-\n fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover"}, {"sha": "c2dddba4d5ab0bbe207e1ef51e5f0f62db490380", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -265,7 +265,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: @block_ctxt} {\n-    let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n+    let ccx = bcx.fcx.ccx, bcx = bcx;\n     // invariant:\n     // pat_id must have the same length ty_param_substs as vdefs?\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n@@ -412,7 +412,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     let vals_left =\n         vec::slice(vals, 0u, col) +\n             vec::slice(vals, col + 1u, vec::len(vals));\n-    let ccx = bcx.fcx.lcx.ccx;\n+    let ccx = bcx.fcx.ccx;\n     let pat_id = 0;\n     for br: match_branch in m {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -692,7 +692,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n     }\n \n     let exit_map = [];\n-    let t = base::node_id_type(cx.fcx.lcx.ccx, expr.id);\n+    let t = base::node_id_type(cx.fcx.ccx, expr.id);\n     let vr = base::spill_if_immediate(er.bcx, er.val, t);\n     compile_submatch(vr.bcx, match, [vr.val],\n                      bind mk_fail(alt_cx, expr.span, fail_cx), exit_map);\n@@ -719,7 +719,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> @block_ctxt {\n-    let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n+    let ccx = bcx.fcx.ccx, bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     alt normalize_pat(bcx_tcx(bcx), pat).node {"}, {"sha": "3332e06c841911b7eb14c2e7638de286b7fd20dc", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 217, "deletions": 248, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -24,6 +24,7 @@ import front::attr;\n import middle::freevars::*;\n import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};\n+import ast_util::local_def;\n import syntax::visit;\n import syntax::codemap::span;\n import syntax::print::pprust::{expr_to_str, stmt_to_str, path_to_str};\n@@ -44,6 +45,7 @@ import util::ppaux::{ty_to_str, ty_to_short_str};\n import shape::static_size_of_enum;\n import common::*;\n import build::*;\n+import ast_map::{path, path_mod, path_name};\n \n fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n     let cx = bcx_ccx(bcx);\n@@ -222,13 +224,12 @@ fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     }\n }\n \n-fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt,\n-                                 tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n-    let cx = lcx.ccx;\n+fn type_of_ty_param_bounds_and_ty\n+    (ccx: @crate_ctxt, tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let t = tpt.ty;\n-    alt ty::struct(cx.tcx, t) {\n+    alt ty::struct(ccx.tcx, t) {\n       ty::ty_fn(_) {\n-        ret type_of_fn_from_ty(cx, t, *tpt.bounds);\n+        ret type_of_fn_from_ty(ccx, t, *tpt.bounds);\n       }\n       _ {\n         // fall through\n@@ -237,8 +238,8 @@ fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt,\n     // FIXME: could have a precondition on tpt, but that\n     // doesn't work right now because one predicate can't imply\n     // another\n-    check (type_has_static_size(cx, t));\n-    type_of(cx, t)\n+    check type_has_static_size(ccx, t);\n+    type_of(ccx, t)\n }\n \n fn type_of_or_i8(bcx: @block_ctxt, typ: ty::t) -> TypeRef {\n@@ -329,7 +330,7 @@ fn get_simple_extern_fn(cx: @block_ctxt,\n                         externs: hashmap<str, ValueRef>,\n                         llmod: ModuleRef,\n                         name: str, n_args: int) -> ValueRef {\n-    let ccx = cx.fcx.lcx.ccx;\n+    let ccx = cx.fcx.ccx;\n     let inputs = vec::init_elt::<TypeRef>(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n     let t = T_fn(inputs, output);\n@@ -975,7 +976,7 @@ fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint])\n       some(info) { ret info; }\n       none {\n         bcx_ccx(cx).stats.n_static_tydescs += 1u;\n-        let info = declare_tydesc(cx.fcx.lcx, t, ty_params);\n+        let info = declare_tydesc(cx.fcx.ccx, t, ty_params);\n         bcx_ccx(cx).tydescs.insert(t, info);\n         ret info;\n       }\n@@ -1004,18 +1005,17 @@ fn set_custom_stack_growth_fn(f: ValueRef) {\n     llvm::LLVMAddFunctionAttr(f, 0u as c_uint, 1u as c_uint);\n }\n \n-fn set_glue_inlining(cx: @local_ctxt, f: ValueRef, t: ty::t) {\n-    if ty::type_is_structural(cx.ccx.tcx, t) {\n+fn set_glue_inlining(ccx: @crate_ctxt, f: ValueRef, t: ty::t) {\n+    if ty::type_is_structural(ccx.tcx, t) {\n         set_no_inline(f);\n     } else { set_always_inline(f); }\n }\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(cx: @local_ctxt, t: ty::t, ty_params: [uint])\n+fn declare_tydesc(ccx: @crate_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n-    log(debug, \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t));\n-    let ccx = cx.ccx;\n+    log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     let llsize;\n     let llalign;\n     if check type_has_static_size(ccx, t) {\n@@ -1030,63 +1030,59 @@ fn declare_tydesc(cx: @local_ctxt, t: ty::t, ty_params: [uint])\n         llalign = C_int(ccx, 0);\n     }\n     let name;\n-    if cx.ccx.sess.opts.debuginfo {\n-        name = mangle_internal_name_by_type_only(cx.ccx, t, \"tydesc\");\n+    if ccx.sess.opts.debuginfo {\n+        name = mangle_internal_name_by_type_only(ccx, t, \"tydesc\");\n         name = sanitize(name);\n-    } else { name = mangle_internal_name_by_seq(cx.ccx, \"tydesc\"); }\n-    let gvar =\n-        str::as_buf(name,\n-                    {|buf|\n-                        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n-                    });\n+    } else { name = mangle_internal_name_by_seq(ccx, \"tydesc\"); }\n+    let gvar = str::as_buf(name, {|buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n+    });\n     let info =\n         @{ty: t,\n           tydesc: gvar,\n           size: llsize,\n           align: llalign,\n-          mutable take_glue: none::<ValueRef>,\n-          mutable drop_glue: none::<ValueRef>,\n-          mutable free_glue: none::<ValueRef>,\n-          mutable cmp_glue: none::<ValueRef>,\n+          mutable take_glue: none,\n+          mutable drop_glue: none,\n+          mutable free_glue: none,\n+          mutable cmp_glue: none,\n           ty_params: ty_params};\n-    log(debug, \"--- declare_tydesc \" + ty_to_str(cx.ccx.tcx, t));\n+    log(debug, \"--- declare_tydesc \" + ty_to_str(ccx.tcx, t));\n     ret info;\n }\n \n type glue_helper = fn@(@block_ctxt, ValueRef, ty::t);\n \n-fn declare_generic_glue(cx: @local_ctxt, t: ty::t, llfnty: TypeRef, name: str)\n-   -> ValueRef {\n+fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n+                        name: str) -> ValueRef {\n     let name = name;\n     let fn_nm;\n-    if cx.ccx.sess.opts.debuginfo {\n-        fn_nm = mangle_internal_name_by_type_only(cx.ccx, t, \"glue_\" + name);\n+    if ccx.sess.opts.debuginfo {\n+        fn_nm = mangle_internal_name_by_type_only(ccx, t, \"glue_\" + name);\n         fn_nm = sanitize(fn_nm);\n-    } else { fn_nm = mangle_internal_name_by_seq(cx.ccx, \"glue_\" + name); }\n-    let llfn = decl_cdecl_fn(cx.ccx.llmod, fn_nm, llfnty);\n-    set_glue_inlining(cx, llfn, t);\n+    } else { fn_nm = mangle_internal_name_by_seq(ccx, \"glue_\" + name); }\n+    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n+    set_glue_inlining(ccx, llfn, t);\n     ret llfn;\n }\n \n // FIXME: was this causing the leak?\n-fn make_generic_glue_inner(cx: @local_ctxt, t: ty::t,\n+fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n-    let fcx = new_fn_ctxt(cx, llfn, none);\n+    let fcx = new_fn_ctxt(ccx, [], llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-    cx.ccx.stats.n_glues_created += 1u;\n+    ccx.stats.n_glues_created += 1u;\n     // Any nontrivial glue is with values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n     // passed by value.\n \n-    let ccx = cx.ccx;\n-    let llty =\n-        if check type_has_static_size(ccx, t) {\n-            T_ptr(type_of(ccx, t))\n-        } else { T_ptr(T_i8()) };\n+    let llty = if check type_has_static_size(ccx, t) {\n+        T_ptr(type_of(ccx, t))\n+    } else { T_ptr(T_i8()) };\n \n-    let ty_param_count = vec::len::<uint>(ty_params);\n+    let ty_param_count = vec::len(ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 2u as c_uint);\n     let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n     let lltydescs = [mutable];\n@@ -1109,17 +1105,17 @@ fn make_generic_glue_inner(cx: @local_ctxt, t: ty::t,\n     ret llfn;\n }\n \n-fn make_generic_glue(cx: @local_ctxt, t: ty::t, llfn: ValueRef,\n-                     helper: glue_helper, ty_params: [uint], name: str) ->\n-   ValueRef {\n-    if !cx.ccx.sess.opts.stats {\n-        ret make_generic_glue_inner(cx, t, llfn, helper, ty_params);\n+fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n+                     helper: glue_helper, ty_params: [uint], name: str)\n+    -> ValueRef {\n+    if !ccx.sess.opts.stats {\n+        ret make_generic_glue_inner(ccx, t, llfn, helper, ty_params);\n     }\n \n     let start = time::get_time();\n-    let llval = make_generic_glue_inner(cx, t, llfn, helper, ty_params);\n+    let llval = make_generic_glue_inner(ccx, t, llfn, helper, ty_params);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, \"glue \" + name + \" \" + ty_to_short_str(cx.ccx.tcx, t),\n+    log_fn_time(ccx, \"glue \" + name + \" \" + ty_to_short_str(ccx.tcx, t),\n                 start, end);\n     ret llval;\n }\n@@ -1646,6 +1642,7 @@ fn lazily_emit_all_generic_info_tydesc_glues(cx: @block_ctxt,\n \n fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                            static_ti: option<@tydesc_info>) {\n+    let ccx = cx.fcx.ccx;\n     alt static_ti {\n       none { }\n       some(ti) {\n@@ -1655,12 +1652,10 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n-                let lcx = cx.fcx.lcx;\n-                let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n-                                         \"take\");\n-                ti.take_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, ti.ty, glue_fn,\n+                let glue_fn = declare_generic_glue\n+                    (ccx, ti.ty, T_glue_fn(ccx), \"take\");\n+                ti.take_glue = some(glue_fn);\n+                make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_take_glue,\n                                   ti.ty_params, \"take\");\n                 #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n@@ -1673,12 +1668,10 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n-                let lcx = cx.fcx.lcx;\n                 let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n-                                         \"drop\");\n-                ti.drop_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, ti.ty, glue_fn,\n+                    declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"drop\");\n+                ti.drop_glue = some(glue_fn);\n+                make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_drop_glue,\n                                   ti.ty_params, \"drop\");\n                 #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n@@ -1691,12 +1684,10 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n               none {\n                 #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n-                let lcx = cx.fcx.lcx;\n                 let glue_fn =\n-                    declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n-                                         \"free\");\n-                ti.free_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, ti.ty, glue_fn,\n+                    declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), \"free\");\n+                ti.free_glue = some(glue_fn);\n+                make_generic_glue(ccx, ti.ty, glue_fn,\n                                   make_free_glue,\n                                   ti.ty_params, \"free\");\n                 #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n@@ -2541,10 +2532,10 @@ fn lval_no_env(bcx: @block_ctxt, val: ValueRef, kind: lval_kind)\n \n fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n                        tpt: ty::ty_param_bounds_and_ty) -> ValueRef {\n-    let lcx = cx.fcx.lcx;\n-    let name = csearch::get_symbol(lcx.ccx.sess.cstore, did);\n-    ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n-                         type_of_ty_param_bounds_and_ty(lcx, tpt));\n+    let ccx = cx.fcx.ccx;\n+    let name = csearch::get_symbol(ccx.sess.cstore, did);\n+    ret get_extern_const(ccx.externs, ccx.llmod, name,\n+                         type_of_ty_param_bounds_and_ty(ccx, tpt));\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n@@ -2580,19 +2571,18 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n \n-fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n-    let ccx = lcx.ccx;\n+fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n     alt ccx.discrims.find(vid) {\n       none {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n-        let sym = csearch::get_symbol(lcx.ccx.sess.cstore, vid);\n+        let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n         let gvar = str::as_buf(sym, {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n         lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n         llvm::LLVMSetGlobalConstant(gvar, True);\n-        lcx.ccx.discrims.insert(vid, gvar);\n+        ccx.discrims.insert(vid, gvar);\n         ret gvar;\n       }\n       some(llval) { ret llval; }\n@@ -2657,7 +2647,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n             let bcx = alloc_result.bcx;\n             let llenumptr = PointerCast(bcx, llenumblob, T_ptr(llenumty));\n             let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n-            let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n+            let lldiscrim_gv = lookup_discriminant(bcx.fcx.ccx, vid);\n             let lldiscrim = Load(bcx, lldiscrim_gv);\n             Store(bcx, lldiscrim, lldiscrimptr);\n             ret lval_no_env(bcx, llenumptr, temporary);\n@@ -3339,7 +3329,7 @@ fn trans_landing_pad(bcx: @block_ctxt,\n \n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n-    let t = node_id_type(bcx.fcx.lcx.ccx, id);\n+    let t = node_id_type(bcx.fcx.ccx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n       ignore {\n@@ -3728,27 +3718,28 @@ fn load_if_immediate(cx: @block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n }\n \n fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n-    let lcx = cx.fcx.lcx;\n-    let tcx = ccx.tcx;\n-    let modname = str::connect(lcx.module_path, \"::\");\n-\n+    let ccx = bcx_ccx(cx), tcx = ccx.tcx;\n     if ty::type_is_bot(tcx, ty::expr_ty(tcx, lvl)) {\n        ret trans_expr(cx, lvl, ignore);\n     }\n \n-    let global = if lcx.ccx.module_data.contains_key(modname) {\n-        lcx.ccx.module_data.get(modname)\n+    let modpath = vec::filter(cx.fcx.path, {|e|\n+        alt e { path_mod(_) { true } _ { false } }\n+    });\n+    let modname = path_str(modpath);\n+\n+    let global = if ccx.module_data.contains_key(modname) {\n+        ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n-            lcx.ccx, lcx.module_path, \"loglevel\");\n+            ccx, modpath, \"loglevel\");\n         let global = str::as_buf(s, {|buf|\n-            llvm::LLVMAddGlobal(lcx.ccx.llmod, T_i32(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n         });\n         llvm::LLVMSetGlobalConstant(global, False);\n         llvm::LLVMSetInitializer(global, C_null(T_i32()));\n         lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);\n-        lcx.ccx.module_data.insert(modname, global);\n+        ccx.module_data.insert(modname, global);\n         global\n     };\n     let level_cx = new_scope_block_ctxt(cx, \"level\");\n@@ -4033,7 +4024,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n                 }\n             }\n           }\n-          ast::decl_item(i) { trans_item(cx.fcx.lcx, *i); }\n+          ast::decl_item(i) { trans_item(cx.fcx.ccx, *i); }\n         }\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"stmt variant\"); }\n@@ -4047,9 +4038,8 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                   name: str, block_span: option<span>) -> @block_ctxt {\n     let s = \"\";\n-    if cx.lcx.ccx.sess.opts.save_temps ||\n-           cx.lcx.ccx.sess.opts.debuginfo {\n-        s = cx.lcx.ccx.names(name);\n+    if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n+        s = cx.ccx.names(name);\n     }\n     let llbb: BasicBlockRef =\n         str::as_buf(s, {|buf| llvm::LLVMAppendBasicBlock(cx.llfn, buf) });\n@@ -4278,14 +4268,6 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     ret rv;\n }\n \n-fn new_local_ctxt(ccx: @crate_ctxt) -> @local_ctxt {\n-    let pth: [str] = [];\n-    ret @{path: pth,\n-          module_path: [ccx.link_meta.name],\n-          ccx: ccx};\n-}\n-\n-\n // Creates the standard quartet of basic blocks: static allocas, copy args,\n // derived tydescs, and dynamic allocas.\n fn mk_standard_basic_blocks(llfn: ValueRef) ->\n@@ -4318,8 +4300,8 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n-                    id: ast::node_id, rstyle: ast::ret_style,\n+fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n+                    llfndecl: ValueRef, id: ast::node_id,\n                     sp: option<span>) -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n     ret @{llfn: llfndecl,\n@@ -4339,14 +4321,14 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n           mutable lltyparams: [],\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n-          ret_style: rstyle,\n           span: sp,\n-          lcx: cx};\n+          path: path,\n+          ccx: ccx};\n }\n \n-fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef, sp: option<span>)\n-    -> @fn_ctxt {\n-    ret new_fn_ctxt_w_id(cx, llfndecl, -1, ast::return_val, sp);\n+fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n+               sp: option<span>) -> @fn_ctxt {\n+    ret new_fn_ctxt_w_id(ccx, path, llfndecl, -1, sp);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4472,23 +4454,23 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n+fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf, some(body.span));\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, some(body.span));\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx = new_top_block_ctxt(fcx, some(body.span));\n     let lltop = bcx.llbb;\n-    let block_ty = node_id_type(cx.ccx, body.node.id);\n+    let block_ty = node_id_type(ccx, body.node.id);\n \n-    let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n+    let arg_tys = arg_tys_of_fn(fcx.ccx, id);\n     bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n \n     maybe_load_env(fcx);\n@@ -4498,8 +4480,8 @@ fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n     if option::is_none(body.node.expr) ||\n-       ty::type_is_bot(cx.ccx.tcx, block_ty) ||\n-       ty::type_is_nil(cx.ccx.tcx, block_ty) {\n+       ty::type_is_bot(ccx.tcx, block_ty) ||\n+       ty::type_is_nil(ccx.tcx, block_ty) {\n         bcx = trans_block(bcx, body);\n     } else {\n         bcx = trans_block_dps(bcx, body, save_in(fcx.llretptr));\n@@ -4514,35 +4496,33 @@ fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(cx: @local_ctxt, decl: ast::fn_decl, body: ast::blk,\n-            llfndecl: ValueRef, ty_self: self_arg, ty_params: [ast::ty_param],\n-            id: ast::node_id) {\n-    let do_time = cx.ccx.sess.opts.stats;\n+fn trans_fn(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n+            body: ast::blk, llfndecl: ValueRef, ty_self: self_arg,\n+            ty_params: [ast::ty_param], id: ast::node_id) {\n+    let do_time = ccx.sess.opts.stats;\n     let start = if do_time {\n                     time::get_time()\n                 } else {\n                     {sec: 0u32, usec: 0u32}\n                 };\n     let fcx = option::none;\n-    trans_closure(cx, decl, body, llfndecl, ty_self, ty_params, id,\n+    trans_closure(ccx, path, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n-    if cx.ccx.sess.opts.extra_debuginfo {\n+    if ccx.sess.opts.extra_debuginfo {\n         debuginfo::create_function(option::get(fcx));\n     }\n     if do_time {\n         let end = time::get_time();\n-        log_fn_time(cx.ccx, str::connect(cx.path, \"::\"), start, end);\n+        log_fn_time(ccx, path_str(path), start, end);\n     }\n }\n \n-fn trans_res_ctor(cx: @local_ctxt, dtor: ast::fn_decl,\n+fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n-    let ccx = cx.ccx;\n-\n     // Create a function for the constructor\n     let llctor_decl = ccx.item_ids.get(ctor_id);\n-    let fcx = new_fn_ctxt(cx, llctor_decl, none);\n-    let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n+    let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id, none);\n+    let ret_t = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n@@ -4574,42 +4554,37 @@ fn trans_res_ctor(cx: @local_ctxt, dtor: ast::fn_decl,\n }\n \n \n-fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n-                     variant: ast::variant, disr: int, is_degen: bool,\n-                     ty_params: [ast::ty_param]) {\n-    let ccx = cx.ccx;\n-\n-    if vec::len::<ast::variant_arg>(variant.node.args) == 0u {\n+fn trans_enum_variant(ccx: @crate_ctxt,\n+                      enum_id: ast::node_id,\n+                      variant: ast::variant, disr: int, is_degen: bool,\n+                      ty_params: [ast::ty_param]) {\n+    if vec::len(variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n-\n     }\n-    // Translate variant arguments to function arguments.\n \n-    let fn_args: [ast::arg] = [];\n-    let i = 0u;\n-    for varg: ast::variant_arg in variant.node.args {\n-        fn_args +=\n-            [{mode: ast::by_copy,\n-              ty: varg.ty,\n-              ident: \"arg\" + uint::to_str(i, 10u),\n-              id: varg.id}];\n+    // Translate variant arguments to function arguments.\n+    let fn_args = [], i = 0u;\n+    for varg in variant.node.args {\n+        fn_args += [{mode: ast::by_copy,\n+                     ty: varg.ty,\n+                     ident: \"arg\" + uint::to_str(i, 10u),\n+                     id: varg.id}];\n     }\n     assert (ccx.item_ids.contains_key(variant.node.id));\n     let llfndecl: ValueRef;\n     alt ccx.item_ids.find(variant.node.id) {\n       some(x) { llfndecl = x; }\n       _ {\n         ccx.sess.span_fatal(variant.span,\n-                               \"unbound variant id in trans_enum_variant\");\n+                            \"unbound variant id in trans_enum_variant\");\n       }\n     }\n-    let fcx = new_fn_ctxt(cx, llfndecl, none);\n+    let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n-    let ty_param_substs: [ty::t] = [];\n-    i = 0u;\n+    let ty_param_substs = [], i = 0u;\n     for tp: ast::ty_param in ty_params {\n         ty_param_substs += [ty::mk_param(ccx.tcx, i,\n-                                         ast_util::local_def(tp.id))];\n+                                         local_def(tp.id))];\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n@@ -4618,19 +4593,18 @@ fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n     // Cast the enum to a type we can GEP into.\n-    let llblobptr =\n-        if is_degen {\n-            fcx.llretptr\n-        } else {\n-            let llenumptr =\n-                PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n-            let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n-            Store(bcx, C_int(ccx, disr), lldiscrimptr);\n-            GEPi(bcx, llenumptr, [0, 1])\n-        };\n-    i = 0u;\n-    let t_id = ast_util::local_def(enum_id);\n-    let v_id = ast_util::local_def(variant.node.id);\n+    let llblobptr = if is_degen {\n+        fcx.llretptr\n+    } else {\n+        let llenumptr =\n+            PointerCast(bcx, fcx.llretptr, T_opaque_enum_ptr(ccx));\n+        let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n+        Store(bcx, C_int(ccx, disr), lldiscrimptr);\n+        GEPi(bcx, llenumptr, [0, 1])\n+    };\n+    let i = 0u;\n+    let t_id = local_def(enum_id);\n+    let v_id = local_def(variant.node.id);\n     for va: ast::variant_arg in variant.node.args {\n         check (valid_variant_index(i, bcx, t_id, v_id));\n         let rslt = GEP_enum(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n@@ -4813,14 +4787,13 @@ fn c_stack_tys(ccx: @crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n-                    abi: ast::native_abi) {\n-    fn build_shim_fn(lcx: @local_ctxt,\n+fn trans_native_mod(ccx: @crate_ctxt,\n+                    native_mod: ast::native_mod, abi: ast::native_abi) {\n+    fn build_shim_fn(ccx: @crate_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n         let lname = link_name(native_item);\n-        let ccx = lcx_ccx(lcx);\n \n         // Declare the \"prototype\" for the base function F:\n         let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n@@ -4831,7 +4804,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n             ccx.llmod, shim_name, tys.shim_fn_ty);\n \n         // Declare the body of the shim function:\n-        let fcx = new_fn_ctxt(lcx, llshimfn, none);\n+        let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n         let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n         let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n@@ -4862,13 +4835,12 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n         ret llshimfn;\n     }\n \n-    fn build_wrap_fn(lcx: @local_ctxt,\n+    fn build_wrap_fn(ccx: @crate_ctxt,\n                      tys: @c_stack_tys,\n                      num_tps: uint,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n-        let ccx = lcx_ccx(lcx);\n-        let fcx = new_fn_ctxt(lcx, llwrapfn, none);\n+        let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n         let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n \n@@ -4894,7 +4866,6 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n         finish_fn(fcx, lltop);\n     }\n \n-    let ccx = lcx_ccx(lcx);\n     let cc = lib::llvm::CCallConv;\n     alt abi {\n       ast::native_abi_rust_intrinsic { ret; }\n@@ -4909,10 +4880,9 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n           let tys = c_stack_tys(ccx, id);\n           alt ccx.item_ids.find(id) {\n             some(llwrapfn) {\n-              let llshimfn = build_shim_fn(lcx, native_item, tys, cc);\n-              build_wrap_fn(lcx, tys, vec::len(tps), llshimfn, llwrapfn);\n+              let llshimfn = build_shim_fn(ccx, native_item, tys, cc);\n+              build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n             }\n-\n             none {\n               ccx.sess.span_fatal(\n                   native_item.span,\n@@ -4924,63 +4894,61 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n     }\n }\n \n-fn trans_item(cx: @local_ctxt, item: ast::item) {\n+fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n+    let path = alt ccx.tcx.items.get(item.id) {\n+      ast_map::node_item(_, p) { p }\n+      _ { fail; }\n+    };\n     alt item.node {\n       ast::item_fn(decl, tps, body) {\n-        let sub_cx = extend_path(cx, item.ident);\n-        alt cx.ccx.item_ids.find(item.id) {\n+        alt ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n-            trans_fn(sub_cx, decl, body, llfndecl, no_self, tps,\n-                     item.id);\n+            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+                     llfndecl, no_self, tps, item.id);\n           }\n           _ {\n-            cx.ccx.sess.span_fatal(item.span,\n-                                   \"unbound function item in trans_item\");\n+            ccx.sess.span_fatal(item.span,\n+                                \"unbound function item in trans_item\");\n           }\n         }\n       }\n       ast::item_impl(tps, _, _, ms) {\n-        impl::trans_impl(cx, item.ident, ms, item.id, tps);\n+        impl::trans_impl(ccx, *path, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n-        trans_res_ctor(cx, decl, ctor_id, tps);\n+        trans_res_ctor(ccx, *path, decl, ctor_id, tps);\n \n         // Create a function for the destructor\n-        alt cx.ccx.item_ids.find(item.id) {\n+        alt ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n-            trans_fn(cx, decl, body, lldtor_decl, no_self,\n-                     tps, dtor_id);\n+            trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n+                     lldtor_decl, no_self, tps, dtor_id);\n           }\n           _ {\n-            cx.ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n+            ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n           }\n         }\n       }\n       ast::item_mod(m) {\n-        let sub_cx =\n-            @{path: cx.path + [item.ident],\n-              module_path: cx.module_path + [item.ident] with *cx};\n-        trans_mod(sub_cx, m);\n+        trans_mod(ccx, m);\n       }\n       ast::item_enum(variants, tps) {\n-        let sub_cx = extend_path(cx, item.ident);\n         let degen = vec::len(variants) == 1u;\n-        let vi = ty::enum_variants(cx.ccx.tcx, {crate: ast::local_crate,\n-                                               node: item.id});\n+        let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n         let i = 0;\n         for variant: ast::variant in variants {\n-            trans_enum_variant(sub_cx, item.id, variant,\n-                              vi[i].disr_val, degen, tps);\n+            trans_enum_variant(ccx, item.id, variant,\n+                               vi[i].disr_val, degen, tps);\n             i += 1;\n         }\n       }\n-      ast::item_const(_, expr) { trans_const(cx.ccx, expr, item.id); }\n+      ast::item_const(_, expr) { trans_const(ccx, expr, item.id); }\n       ast::item_native_mod(native_mod) {\n         let abi = alt attr::native_abi(item.attrs) {\n           either::right(abi_) { abi_ }\n-          either::left(msg) { cx.ccx.sess.span_fatal(item.span, msg) }\n+          either::left(msg) { ccx.sess.span_fatal(item.span, msg) }\n         };\n-        trans_native_mod(cx, native_mod, abi);\n+        trans_native_mod(ccx, native_mod, abi);\n       }\n       _ {/* fall through */ }\n     }\n@@ -4991,8 +4959,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-fn trans_mod(cx: @local_ctxt, m: ast::_mod) {\n-    for item: @ast::item in m.items { trans_item(cx, *item); }\n+fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n+    for item in m.items { trans_item(ccx, *item); }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -5001,7 +4969,7 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     ret struct_elt(llpairty, 0u);\n }\n \n-fn register_fn(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n+fn register_fn(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id) {\n     // FIXME: pull this out\n     let t = node_id_type(ccx, node_id);\n@@ -5013,19 +4981,18 @@ fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n     ccx.tcx.ty_param_bounds.get(tp.id)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n+fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n                     tps: [ast::ty_param], node_id: ast::node_id,\n                     node_type: ty::t)\n     : returns_non_ty_var(ccx, node_type) {\n-    let path = path;\n     let llfty = type_of_fn_from_ty(ccx, node_type,\n                                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n     ccx.item_symbols.insert(node_id, ps);\n \n-    let is_main: bool = is_main_name(path) && !ccx.sess.building_library;\n+    let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n }\n \n@@ -5061,7 +5028,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(new_local_ctxt(ccx), llfdecl, none);\n+        let fcx = new_fn_ctxt(ccx, [], llfdecl, none);\n \n         let bcx = new_top_block_ctxt(fcx, none);\n         let lltop = bcx.llbb;\n@@ -5115,9 +5082,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n // on the stack).\n fn create_real_fn_pair(cx: @block_ctxt, llfnty: TypeRef, llfn: ValueRef,\n                        llenvptr: ValueRef) -> ValueRef {\n-    let lcx = cx.fcx.lcx;\n-\n-    let pair = alloca(cx, T_fn_pair(lcx.ccx, llfnty));\n+    let pair = alloca(cx, T_fn_pair(bcx_ccx(cx), llfnty));\n     fill_fn_pair(cx, pair, llfn, llenvptr);\n     ret pair;\n }\n@@ -5137,9 +5102,10 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     let count;\n     let native_item =\n         // invariant?!\n-        alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i }\n-         _ { cx.sess.bug(\"native_fn_ty_param_count\\\n-                         given a non-native item\"); } };\n+        alt cx.ast_map.find(id) {\n+          some(ast_map::node_native_item(i, _)) { i }\n+         _ { cx.sess.bug(\"native_fn_ty_param_count \\\n+                          given a non-native item\"); } };\n     alt native_item.node {\n       ast::native_item_fn(_, tps) {\n         count = vec::len::<ast::ty_param>(tps);\n@@ -5177,9 +5143,7 @@ fn link_name(i: @ast::native_item) -> str {\n \n fn collect_native_item(ccx: @crate_ctxt,\n                        abi: @mutable option<ast::native_abi>,\n-                       i: @ast::native_item,\n-                       &&pt: [str],\n-                       _v: vt<[str]>) {\n+                       i: @ast::native_item) {\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n         let id = i.id;\n@@ -5217,24 +5181,31 @@ fn collect_native_item(ccx: @crate_ctxt,\n             // For true external functions: create a rust wrapper\n             // and link to that.  The rust wrapper will handle\n             // switching to the C stack.\n-            let new_pt = pt + [i.ident];\n-            register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n+            let path = *alt ccx.tcx.items.get(i.id) {\n+              ast_map::node_native_item(_, p) { p } _ { fail; }\n+            } + [path_name(i.ident)];\n+            register_fn(ccx, i.span, path, \"native fn\", tps, i.id);\n           }\n         }\n       }\n       _ { }\n     }\n }\n \n+fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n+    *alt ccx.tcx.items.get(i.id) {\n+      ast_map::node_item(_, p) { p } _ { fail; }\n+    } + [path_name(i.ident)]\n+}\n+\n fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n-                i: @ast::item, &&pt: [str], v: vt<[str]>) {\n-    let new_pt = pt + [i.ident];\n+                i: @ast::item) {\n+    let my_path = item_path(ccx, i);\n     alt i.node {\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n-        let s =\n-            mangle_exported_name(ccx, pt + [i.ident],\n-                                 node_id_type(ccx, i.id));\n+        let s = mangle_exported_name(ccx, my_path,\n+                                     node_id_type(ccx, i.id));\n         // FIXME: Could follow from a constraint on types of const\n         // items\n         let g = str::as_buf(s, {|buf|\n@@ -5248,66 +5219,65 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n         // Propagate the native ABI down to collect_native_item(),\n         alt attr::native_abi(i.attrs) {\n           either::left(msg) { ccx.sess.span_fatal(i.span, msg); }\n-          either::right(abi_) {\n-            *abi = option::some(abi_);\n-          }\n+          either::right(abi_) { *abi = option::some(abi_); }\n         }\n       }\n       ast::item_fn(_, tps, _) {\n-        register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n+        register_fn(ccx, i.span, my_path, \"fn\", tps,\n+                    i.id);\n       }\n       ast::item_impl(tps, _, _, methods) {\n-        let name = i.ident + int::str(i.id);\n+        let path = my_path + [path_name(int::str(i.id))];\n         for m in methods {\n-            register_fn(ccx, i.span, pt + [name, m.ident],\n+            register_fn(ccx, i.span,\n+                        path + [path_name(m.ident)],\n                         \"impl_method\", tps + m.tps, m.id);\n         }\n       }\n       ast::item_res(_, tps, _, dtor_id, ctor_id) {\n-        register_fn(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n+        register_fn(ccx, i.span, my_path, \"res_ctor\", tps, ctor_id);\n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = node_id_type(ccx, dtor_id);\n         // FIXME: how to get rid of this check?\n         check returns_non_ty_var(ccx, t);\n-        register_fn_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n+        register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n+                         \"res_dtor\", tps, i.id, t);\n       }\n       ast::item_enum(variants, tps) {\n         for variant in variants {\n             if vec::len(variant.node.args) != 0u {\n-                register_fn(ccx, i.span, new_pt + [variant.node.name],\n+                register_fn(ccx, i.span,\n+                            my_path + [path_name(variant.node.name)],\n                             \"enum\", tps, variant.node.id);\n             }\n         }\n       }\n       _ { }\n     }\n-    visit::visit_item(i, new_pt, v);\n }\n \n fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n     let abi = @mutable none::<ast::native_abi>;\n-    visit::visit_crate(*crate, [], visit::mk_vt(@{\n-        visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n-        visit_item: bind collect_item(ccx, abi, _, _, _)\n-        with *visit::default_visitor()\n+    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n+        visit_native_item: bind collect_native_item(ccx, abi, _),\n+        visit_item: bind collect_item(ccx, abi, _)\n+        with *visit::default_simple_visitor()\n     }));\n }\n \n // The constant translation pass.\n-fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n-                  v: vt<[str]>) {\n-    let new_pt = pt + [it.ident];\n-    visit::visit_item(it, new_pt, v);\n+fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n-                                            node: it.id});\n-        let i = 0;\n+                                             node: it.id});\n+        let i = 0, path = item_path(ccx, it);\n         for variant in variants {\n-            let p = new_pt + [variant.node.name, \"discrim\"];\n+            let p = path + [path_name(variant.node.name),\n+                            path_name(\"discrim\")];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n             let discrim_gvar = str::as_buf(s, {|buf|\n@@ -5316,27 +5286,27 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n             llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n             llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             ccx.discrims.insert(\n-                ast_util::local_def(variant.node.id), discrim_gvar);\n+                local_def(variant.node.id), discrim_gvar);\n             ccx.discrim_symbols.insert(variant.node.id, s);\n             i += 1;\n         }\n       }\n       ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {\n         let i_did = ast_util::def_id_of_def(ccx.tcx.def_map.get(id));\n-        impl::trans_impl_vtable(ccx, pt, i_did, ms, tps, it);\n+        impl::trans_impl_vtable(ccx, item_path(ccx, it), i_did, ms, tps, it);\n       }\n       ast::item_iface(_, _) {\n-        impl::trans_iface_vtable(ccx, pt, it);\n+        impl::trans_iface_vtable(ccx, item_path(ccx, it), it);\n       }\n       _ { }\n     }\n }\n \n fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let visitor =\n-        @{visit_item: bind trans_constant(ccx, _, _, _)\n-             with *visit::default_visitor()};\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor));\n+    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n+        visit_item: bind trans_constant(ccx, _)\n+        with *visit::default_simple_visitor()\n+    }));\n }\n \n fn vp2i(cx: @block_ctxt, v: ValueRef) -> ValueRef {\n@@ -5597,17 +5567,16 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n-    let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n     trans_constants(ccx, crate);\n-    trans_mod(cx, crate.node.module);\n+    trans_mod(ccx, crate.node.module);\n     fill_crate_map(ccx, crate_map);\n     emit_tydescs(ccx);\n     shape::gen_shape_tables(ccx);\n     write_abi_version(ccx);\n \n     // Translate the metadata.\n-    write_metadata(cx.ccx, crate);\n+    write_metadata(ccx, crate);\n     if ccx.sess.opts.stats {\n         #error(\"--- trans stats ---\");\n         #error(\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs);"}, {"sha": "dd3bf78f46d5bc5d883f3b13e5e914aea4549840", "filename": "src/comp/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbuild.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -11,7 +11,7 @@ import common::{block_ctxt, T_ptr, T_nil, T_i8, T_i1, T_void,\n                 T_fn, val_ty, bcx_ccx, C_i32, val_str};\n \n fn B(cx: @block_ctxt) -> BuilderRef {\n-    let b = *cx.fcx.lcx.ccx.builder;\n+    let b = *cx.fcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n     ret b;\n }\n@@ -312,7 +312,7 @@ fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n }\n \n fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.lcx.ccx;\n+    let ccx = cx.fcx.ccx;\n     if cx.unreachable {\n         let ty = val_ty(PointerVal);\n         let eltty = if llvm::LLVMGetTypeKind(ty) == 11 as c_int {\n@@ -511,7 +511,7 @@ fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n }\n \n fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.lcx.ccx;\n+    let ccx = cx.fcx.ccx;\n     let ty = val_ty(Fn);\n     let retty = if llvm::LLVMGetTypeKind(ty) == 8 as c_int {\n         llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n@@ -625,7 +625,7 @@ fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let ccx = cx.fcx.lcx.ccx;\n+    let ccx = cx.fcx.ccx;\n     if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n     ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }"}, {"sha": "4b4cde894864256f3bdf4bac59129a7d90526734", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -16,6 +16,7 @@ import back::link::{\n     mangle_internal_name_by_path_and_seq};\n import util::ppaux::ty_to_str;\n import shape::{size_of};\n+import ast_map::{path, path_mod, path_name};\n \n // ___Good to know (tm)__________________________________________________\n //\n@@ -458,16 +459,16 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty, []);\n-    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names(\"anon\"));\n-    let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n+    let sub_path = bcx.fcx.path + [path_name(\"anon\")];\n+    let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n-    register_fn(ccx, sp, sub_cx.path, \"anon fn\", [], id);\n+    register_fn(ccx, sp, sub_path, \"anon fn\", [], id);\n \n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|fcx|\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, cdata_ty, cap_vars, ck);\n         });\n         llbox\n@@ -479,7 +480,8 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         let closure = C_null(T_opaque_box_ptr(ccx));\n-        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|_fcx|});\n+        trans_closure(ccx, sub_path, decl, body, llfn, no_self, [], id,\n+                      {|_fcx|});\n         closure\n       }\n     };\n@@ -569,9 +571,9 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         ty::ck_box);\n \n     // Make thunk\n-    let llthunk =\n-        trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty_real, args,\n-                         cdata_ty, *param_bounds, target_res);\n+    let llthunk = trans_bind_thunk(\n+        cx.fcx.ccx, cx.fcx.path, pair_ty, outgoing_fty_real, args,\n+        cdata_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -727,7 +729,8 @@ fn make_opaque_cbox_free_glue(\n }\n \n // pth is cx.path\n-fn trans_bind_thunk(cx: @local_ctxt,\n+fn trans_bind_thunk(ccx: @crate_ctxt,\n+                    path: path,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n                     args: [option<@ast::expr>],\n@@ -743,8 +746,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n       type_has_static_size(ccx, incoming_fty) ->\n     */\n     // but since we don't, we have to do the checks at the beginning.\n-    let ccx = cx.ccx;\n-    let tcx = ccx_tcx(ccx);\n+    let tcx = ccx.tcx;\n     check type_has_static_size(ccx, incoming_fty);\n \n     #debug[\"trans_bind_thunk[incoming_fty=%s,outgoing_fty=%s,\\\n@@ -776,13 +778,13 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // construct and return that thunk.\n \n     // Give the thunk a name, type, and value.\n-    let s: str = mangle_internal_name_by_path_and_seq(ccx, cx.path, \"thunk\");\n-    let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, incoming_fty));\n-    let llthunk: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n+    let s = mangle_internal_name_by_path_and_seq(ccx, path, \"thunk\");\n+    let llthunk_ty = get_pair_fn_ty(type_of(ccx, incoming_fty));\n+    let llthunk = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n-    let fcx = new_fn_ctxt(cx, llthunk, none);\n+    let fcx = new_fn_ctxt(ccx, path, llthunk, none);\n     let bcx = new_top_block_ctxt(fcx, none);\n     let lltop = bcx.llbb;\n     // Since we might need to construct derived tydescs that depend on\n@@ -828,15 +830,14 @@ fn trans_bind_thunk(cx: @local_ctxt,\n \n     // Get f's return type, which will also be the return type of the entire\n     // bind expression.\n-    let outgoing_ret_ty = ty::ty_fn_ret(cx.ccx.tcx, outgoing_fty);\n+    let outgoing_ret_ty = ty::ty_fn_ret(ccx.tcx, outgoing_fty);\n \n     // Get the types of the arguments to f.\n-    let outgoing_args = ty::ty_fn_args(cx.ccx.tcx, outgoing_fty);\n+    let outgoing_args = ty::ty_fn_args(ccx.tcx, outgoing_fty);\n \n     // The 'llretptr' that will arrive in the thunk we're creating also needs\n     // to be the correct type.  Cast it to f's return type, if necessary.\n     let llretptr = fcx.llretptr;\n-    let ccx = cx.ccx;\n     if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n         check non_ty_var(ccx, outgoing_ret_ty);\n         let llretty = type_of_inner(ccx, outgoing_ret_ty);\n@@ -879,7 +880,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n-        type_of_explicit_args(cx.ccx, outgoing_args);\n+        type_of_explicit_args(ccx, outgoing_args);\n     for arg: option<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n@@ -903,7 +904,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n             }\n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n-            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n+            if ty::type_contains_params(ccx.tcx, out_arg.ty) {\n                 val = PointerCast(bcx, val, llout_arg_ty);\n             }\n             llargs += [val];\n@@ -913,7 +914,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n           // Arg will be provided when the thunk is invoked.\n           none {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a as c_uint);\n-            if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n+            if ty::type_contains_params(ccx.tcx, out_arg.ty) {\n                 arg = PointerCast(bcx, arg, llout_arg_ty);\n             }\n             llargs += [arg];\n@@ -927,8 +928,6 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // This is necessary because the type of the function that we have\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n-    let ccx = bcx_ccx(bcx);\n-\n     let lltargetty =\n         type_of_fn_from_ty(ccx, outgoing_fty, param_bounds);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));"}, {"sha": "1b7b73420a424d691b5067775b4f440443c3a32e", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -19,7 +19,8 @@ import lib::llvm::{llvm, target_data, type_names, associate_type,\n                    name_has_type};\n import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n-import metadata::{csearch};\n+import metadata::csearch;\n+import ast_map::path;\n \n // FIXME: These should probably be pulled in here too.\n import base::{type_of_fn, drop_ty};\n@@ -124,11 +125,6 @@ type crate_ctxt =\n      dbg_cx: option<@debuginfo::debug_ctxt>,\n      mutable do_not_commit_warning_issued: bool};\n \n-type local_ctxt =\n-    {path: [str],\n-     module_path: [str],\n-     ccx: @crate_ctxt};\n-\n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n \n@@ -239,9 +235,9 @@ type fn_ctxt =\n      mutable lltyparams: [fn_ty_param],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n-     ret_style: ast::ret_style,\n      span: option<span>,\n-     lcx: @local_ctxt};\n+     path: path,\n+     ccx: @crate_ctxt};\n \n fn warn_not_to_commit(ccx: @crate_ctxt, msg: str) {\n     if !ccx.do_not_commit_warning_issued {\n@@ -392,10 +388,6 @@ enum block_parent { parent_none, parent_some(@block_ctxt), }\n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n-fn extend_path(cx: @local_ctxt, name: str) -> @local_ctxt {\n-    ret @{path: cx.path + [name] with *cx};\n-}\n-\n fn rslt(bcx: @block_ctxt, val: ValueRef) -> result {\n     {bcx: bcx, val: val}\n }\n@@ -430,13 +422,11 @@ fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n // Accessors\n // TODO: When we have overloading, simplify these names!\n \n-pure fn bcx_tcx(bcx: @block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n-pure fn bcx_ccx(bcx: @block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n-pure fn bcx_lcx(bcx: @block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n+pure fn bcx_tcx(bcx: @block_ctxt) -> ty::ctxt { ret bcx.fcx.ccx.tcx; }\n+pure fn bcx_ccx(bcx: @block_ctxt) -> @crate_ctxt { ret bcx.fcx.ccx; }\n pure fn bcx_fcx(bcx: @block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n-pure fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.lcx.ccx; }\n-pure fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n-pure fn lcx_ccx(lcx: @local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n+pure fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.ccx; }\n+pure fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.ccx.tcx; }\n pure fn ccx_tcx(ccx: @crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n \n // LLVM type constructors.\n@@ -943,6 +933,18 @@ fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n     ret build::And(cx, bumped, build::Not(cx, mask));\n }\n \n+fn path_str(p: path) -> str {\n+    let r = \"\", first = true;\n+    for e in p {\n+        alt e { ast_map::path_name(s) | ast_map::path_mod(s) {\n+          if first { first = false; }\n+          else { r += \"::\"; }\n+          r += s;\n+        } }\n+    }\n+    r\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "531af92a93d6311461f82d80d9c4ebcc59efe3a9", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -10,6 +10,7 @@ import back::{link, abi};\n import lib::llvm::llvm;\n import lib::llvm::{ValueRef, TypeRef};\n import lib::llvm::llvm::LLVMGetParam;\n+import ast_map::{path, path_mod, path_name};\n \n // Translation functionality related to impls and ifaces\n //\n@@ -41,18 +42,19 @@ import lib::llvm::llvm::LLVMGetParam;\n // annotates notes with information about the methods and dicts that\n // are referenced (ccx.method_map and ccx.dict_map).\n \n-fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id, tps: [ast::ty_param]) {\n-    let sub_cx = extend_path(cx, name);\n+fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n+              methods: [@ast::method], id: ast::node_id,\n+              tps: [ast::ty_param]) {\n+    let sub_path = path + [path_name(name)];\n     for m in methods {\n-        alt cx.ccx.item_ids.find(m.id) {\n+        alt ccx.item_ids.find(m.id) {\n           some(llfn) {\n-            trans_fn(extend_path(sub_cx, m.ident), m.decl, m.body,\n-                     llfn, impl_self(ty::node_id_to_type(cx.ccx.tcx, id)),\n+            trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n+                     llfn, impl_self(ty::node_id_to_type(ccx.tcx, id)),\n                      tps + m.tps, m.id);\n           }\n           _ {\n-            cx.ccx.tcx.sess.bug(\"Unbound id in trans_impl\");\n+            ccx.tcx.sess.bug(\"Unbound id in trans_impl\");\n           }\n         }\n     }\n@@ -180,21 +182,20 @@ fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n     ccx.item_symbols.insert(id, name);\n }\n \n-fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident], llfty: TypeRef,\n+fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n                  fill: fn(ValueRef, @block_ctxt) -> @block_ctxt)\n     -> ValueRef {\n-    let lcx = @{path: pt, module_path: [], ccx: ccx};\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n-    let fcx = new_fn_ctxt(lcx, llfn, none);\n+    let fcx = new_fn_ctxt(ccx, [], llfn, none);\n     let bcx = new_top_block_ctxt(fcx, none), lltop = bcx.llbb;\n     let bcx = fill(llfn, bcx);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret llfn;\n }\n \n-fn trans_impl_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n+fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n                       extra_tps: [ty::param_bounds], real_fn: ValueRef)\n     -> ValueRef {\n     let {inputs: real_args, output: real_ret} =\n@@ -238,28 +239,31 @@ fn trans_impl_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n     })\n }\n \n-fn trans_impl_vtable(ccx: @crate_ctxt, pt: [ast::ident],\n+fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n                      iface_id: ast::def_id, ms: [@ast::method],\n                      tps: [ast::ty_param], it: @ast::item) {\n-    let new_pt = pt + [it.ident + int::str(it.id), \"wrap\"];\n+    let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n+                       path_name(\"wrap\")];\n     let extra_tps = vec::map(tps, {|p| param_bounds(ccx, p)});\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, iface_id), {|im|\n         alt vec::find(ms, {|m| m.ident == im.ident}) {\n           some(m) {\n             let target = ccx.item_ids.get(m.id);\n-            trans_impl_wrapper(ccx, new_pt + [m.ident], extra_tps, target)\n+            trans_impl_wrapper(ccx, new_pt + [path_name(m.ident)], extra_tps,\n+                               target)\n           }\n           _ {\n             ccx.tcx.sess.span_bug(it.span, \"No matching method \\\n                in trans_impl_vtable\");\n           }\n         }\n     });\n-    let s = link::mangle_internal_name_by_path(ccx, new_pt + [\"!vtable\"]);\n+    let s = link::mangle_internal_name_by_path(\n+        ccx, new_pt + [path_name(\"!vtable\")]);\n     trans_vtable(ccx, it.id, s, ptrs);\n }\n \n-fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n+fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n                        n: uint) -> ValueRef {\n     let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()), m);\n     trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n@@ -287,15 +291,16 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: [ast::ident], m: ty::method,\n     })\n }\n \n-fn trans_iface_vtable(ccx: @crate_ctxt, pt: [ast::ident], it: @ast::item) {\n-    let new_pt = pt + [it.ident + int::str(it.id)];\n+fn trans_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n+    let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id))];\n     let i_did = ast_util::local_def(it.id), i = 0u;\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n-        let w = trans_iface_wrapper(ccx, new_pt + [m.ident], m, i);\n+        let w = trans_iface_wrapper(ccx, new_pt + [path_name(m.ident)], m, i);\n         i += 1u;\n         w\n     });\n-    let s = link::mangle_internal_name_by_path(ccx, new_pt + [\"!vtable\"]);\n+    let s = link::mangle_internal_name_by_path(\n+        ccx, new_pt + [path_name(\"!vtable\")]);\n     trans_vtable(ccx, it.id, s, ptrs);\n }\n "}, {"sha": "7197ed26bad1614a5c328ba5455d73558a9d9913", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -2531,7 +2531,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n         // check the disr_expr if it exists), this code should likely be\n         // moved there to avoid having to call eval_const_expr twice.\n         alt cx.items.get(id.node) {\n-          ast_map::node_item(@{node: ast::item_enum(variants, _), _}) {\n+          ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) {\n             let disr_val = -1;\n             @vec::map(variants, {|variant|\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);"}, {"sha": "c073b969d888a80c579bb6ca1409a426ef3bbbe4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -245,10 +245,10 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             if id.crate != ast::local_crate { csearch::get_type(tcx, id) }\n             else {\n                 alt tcx.items.find(id.node) {\n-                  some(ast_map::node_item(item)) {\n+                  some(ast_map::node_item(item, _)) {\n                     ty_of_item(tcx, mode, item)\n                   }\n-                  some(ast_map::node_native_item(native_item)) {\n+                  some(ast_map::node_native_item(native_item, _)) {\n                     ty_of_native_item(tcx, mode, native_item)\n                   }\n                   _ {\n@@ -1415,7 +1415,7 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n     if did.crate == ast::local_crate {\n         alt tcx.items.get(did.node) {\n           ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n-                               _}) {\n+                               _}, _) {\n             {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n           }\n           an_item {\n@@ -1484,7 +1484,7 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n     fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n         if did.crate == ast::local_crate {\n             alt tcx.items.get(did.node) {\n-              ast_map::node_method(m) {\n+              ast_map::node_method(m, _) {\n                 let mt = ty_of_method(tcx, m_check, m);\n                 ty::mk_fn(tcx, mt.fty)\n               }"}, {"sha": "b96165fb4731092b7e59a9b5a7e3d0989b622ebd", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -89,12 +89,10 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n     alt l.node.init { some(i) { ret i.expr.span; } _ { ret def; } }\n }\n \n-fn is_main_name(path: [ast::ident]) -> bool {\n-    str::eq(option::get(vec::last(path)), \"main\")\n+fn is_main_name(path: middle::ast_map::path) -> bool {\n+    option::get(vec::last(path)) == middle::ast_map::path_name(\"main\")\n }\n \n-\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e95a256fe047623f08acd961c703acf2b60543fb", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -67,7 +67,7 @@ fn parse_item_attrs<T>(\n     parse_attrs: fn~([ast::attribute]) -> T) -> T {\n     astsrv::exec(srv) {|ctxt|\n         let attrs = alt ctxt.ast_map.get(id) {\n-          ast_map::node_item(item) { item.attrs }\n+          ast_map::node_item(item, _) { item.attrs }\n           _ {\n             fail \"parse_item_attrs: not an item\";\n           }\n@@ -246,7 +246,7 @@ fn fold_enum(\n                 alt ctxt.ast_map.get(doc.id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _), _\n-                  }) {\n+                  }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|\n                             v.node.name == variant.name\n@@ -351,14 +351,14 @@ fn merge_method_attrs(\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n-          }) {\n+          }, _) {\n             vec::map(methods) {|method|\n                 (method.ident, attr_parser::parse_method(method.attrs))\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n-          }) {\n+          }, _) {\n             vec::map(methods) {|method|\n                 (method.ident, attr_parser::parse_method(method.attrs))\n             }"}, {"sha": "41a035770b64bbd0899953eae096c7812f54f829", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -106,7 +106,7 @@ fn is_exported_from_mod(\n ) -> bool {\n     astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(mod_id) {\n-          ast_map::node_item(item) {\n+          ast_map::node_item(item, _) {\n             alt item.node {\n               ast::item_mod(m) {\n                 ast_util::is_exported(item_name, m)"}, {"sha": "58cbff8edb28aa99b426d623ab3a71ef0f4cf947", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ce38375d95fcc33c550037bfb96ef2a75ce253/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=43ce38375d95fcc33c550037bfb96ef2a75ce253", "patch": "@@ -49,7 +49,7 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           ast_map::node_item(@{\n             ident: ident,\n             node: ast::item_fn(decl, _, blk), _\n-          }) {\n+          }, _) {\n             some(pprust::fun_to_str(decl, ident, []))\n           }\n           _ {\n@@ -86,7 +86,7 @@ fn get_ret_ty(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n         alt ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             node: ast::item_fn(decl, _, _), _\n-          }) {\n+          }, _) {\n             ret_ty_to_str(decl)\n           }\n           _ { fail \"get_ret_ty: undocumented invariant\"; }\n@@ -136,10 +136,10 @@ fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n         alt ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             node: ast::item_fn(decl, _, _), _\n-          }) |\n+          }, _) |\n           ast_map::node_item(@{\n             node: ast::item_res(decl, _, _, _, _), _\n-          }) {\n+          }, _) {\n             decl_arg_tys(decl)\n           }\n           _ {\n@@ -174,7 +174,7 @@ fn fold_const(\n             alt ctxt.ast_map.get(doc.id) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n-              }) {\n+              }, _) {\n                 pprust::ty_to_str(ty)\n               }\n               _ {\n@@ -204,7 +204,7 @@ fn fold_enum(\n                 alt ctxt.ast_map.get(doc.id) {\n                   ast_map::node_item(@{\n                     node: ast::item_enum(ast_variants, _), _\n-                  }) {\n+                  }, _) {\n                     let ast_variant = option::get(\n                         vec::find(ast_variants) {|v|\n                             v.node.name == variant.name\n@@ -243,7 +243,7 @@ fn fold_res(\n             alt ctxt.ast_map.get(doc.id) {\n               ast_map::node_item(@{\n                 node: ast::item_res(decl, _, _, _, _), _\n-              }) {\n+              }, _) {\n                 pprust::res_to_str(decl, doc.name, [])\n               }\n               _ { fail \"fold_res: undocumented invariant\"; }\n@@ -324,7 +324,7 @@ fn get_method_ret_ty(\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -336,7 +336,7 @@ fn get_method_ret_ty(\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -360,7 +360,7 @@ fn get_method_sig(\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -372,7 +372,7 @@ fn get_method_sig(\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -412,7 +412,7 @@ fn get_method_arg_tys(\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -424,7 +424,7 @@ fn get_method_arg_tys(\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n-          }) {\n+          }, _) {\n             alt vec::find(methods) {|method|\n                 method.ident == method_name\n             } {\n@@ -476,7 +476,7 @@ fn fold_impl(\n         alt ctxt.ast_map.get(doc.id) {\n           ast_map::node_item(@{\n             node: ast::item_impl(_, iface_ty, self_ty, _), _\n-          }) {\n+          }, _) {\n             let iface_ty = option::map(iface_ty) {|iface_ty|\n                 pprust::ty_to_str(iface_ty)\n             };\n@@ -551,7 +551,7 @@ fn fold_type(\n               ast_map::node_item(@{\n                 ident: ident,\n                 node: ast::item_ty(ty, params), _\n-              }) {\n+              }, _) {\n                 some(#fmt(\n                     \"type %s%s = %s\",\n                     ident,"}]}