{"sha": "68948a56547fa4bbe7954935fe6296bcbe6dd90d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTQ4YTU2NTQ3ZmE0YmJlNzk1NDkzNWZlNjI5NmJjYmU2ZGQ5MGQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-10T13:30:28Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-07-16T17:34:38Z"}, "message": "Fix various needless_range_loop false positives", "tree": {"sha": "4eb4861107fa7fe9739379ffb66f63bae8a7d567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb4861107fa7fe9739379ffb66f63bae8a7d567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68948a56547fa4bbe7954935fe6296bcbe6dd90d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCABKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAllro64sHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MASs\nuA/6Aq9WRyb9lO+sxKcGtHuoHOuVUqh03hsmCU6nH2IJ3Nc/JEhdJnLFcQcD2f3A\nwIHJb3tyY4ajObMJXEPSDo1c+TU0jzp10KcY2556nNYp58xdHvbbum5X0qOB5Ld8\n4sN5Dp/OiPlmng3uJAeWrBc+qaLBPKr6vzfEDlugTfMNeQVFd01MRoBu/dYaPNC/\nGkg8WAu0kvALfnPK3RGq9PNVEsYmSN3m4+12ReJFEBM84v7NkIsjOAs6MjHYpVci\nvzmUFAYUY3YvH7sp5nRxRcJtlFXRq2+Bgk64+61ky8r0r7bQ/KitLn/ibiurdgJQ\ngqSmftVMq+Tq08PCSj+UsZBSzjj8XxgcbL8bJijEuJuvLN1hbnmfQBh9R81/L/0t\nHA3RRl8rMVBqQzzpyRXhPa9GsnFVUjSkF9CkdngBTNrEnFNuefBmA9Pc1n67JINF\nASciGcI9eD0RT5INSr9epvW7RqUbuiTos7xziZUlJZXqA/uwnAswfIhh8VgZ1OP2\no+MzQOr4zletHXyzCxub6UrEnZ/aHGDJ1wkczjAsl1I8CZ3Melui4ZWzJzRIcQIS\nJO96btFNJ4+Wl9Ht71YlLgDQGxNK/PcwEXkwvqn+ZtJjmIaD4Q1ajs14ECXtnyuS\n1A7GKM53gZ81ChOs8o0nMUoKOqnQzdXbee7tsgAbNzNqWyk=\n=r1rk\n-----END PGP SIGNATURE-----", "payload": "tree 4eb4861107fa7fe9739379ffb66f63bae8a7d567\nparent d24868d036e773b00db301152c39bd49f5df2d0d\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499693428 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1500226478 +0200\n\nFix various needless_range_loop false positives\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68948a56547fa4bbe7954935fe6296bcbe6dd90d", "html_url": "https://github.com/rust-lang/rust/commit/68948a56547fa4bbe7954935fe6296bcbe6dd90d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68948a56547fa4bbe7954935fe6296bcbe6dd90d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d24868d036e773b00db301152c39bd49f5df2d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d24868d036e773b00db301152c39bd49f5df2d0d", "html_url": "https://github.com/rust-lang/rust/commit/d24868d036e773b00db301152c39bd49f5df2d0d"}], "stats": {"total": 140, "additions": 96, "deletions": 44}, "files": [{"sha": "5b04a2322570102fbe3d9c59bd04bd47b84489b6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=68948a56547fa4bbe7954935fe6296bcbe6dd90d", "patch": "@@ -10,7 +10,7 @@ use rustc::middle::region::CodeExtent;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc_const_eval::ConstContext;\n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use syntax::ast;\n use utils::sugg;\n \n@@ -579,6 +579,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                 cx: cx,\n                 var: def_id,\n                 indexed: HashMap::new(),\n+                referenced: HashSet::new(),\n                 nonindex: false,\n             };\n             walk_expr(&mut visitor, body);\n@@ -588,7 +589,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                 let (indexed, indexed_extent) = visitor.indexed\n                     .into_iter()\n                     .next()\n-                    .unwrap_or_else(|| unreachable!() /* len == 1 */);\n+                    .expect(\"already checked that we have exactly 1 element\");\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -601,6 +602,11 @@ fn check_for_loop_range<'a, 'tcx>(\n                     }\n                 }\n \n+                // don't lint if the container that is indexed into is also used without indexing\n+                if visitor.referenced.contains(&indexed) {\n+                    return;\n+                }\n+\n                 let starts_at_zero = is_integer_literal(start, 0);\n \n                 let skip = if starts_at_zero {\n@@ -952,50 +958,70 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n }\n \n struct VarVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>, // context reference\n-    var: DefId, // var name to look for as index\n-    indexed: HashMap<Name, Option<CodeExtent>>, // indexed variables, the extent is None for global\n-    nonindex: bool, // has the var been used otherwise?\n+    /// context reference\n+    cx: &'a LateContext<'a, 'tcx>,\n+    /// var name to look for as index\n+    var: DefId,\n+    /// indexed variables, the extend is `None` for global\n+    indexed: HashMap<Name, Option<CodeExtent>>,\n+    /// Any names that are used outside an index operation.\n+    /// Used to detect things like `&mut vec` used together with `vec[i]`\n+    referenced: HashSet<Name>,\n+    /// has the loop variable been used in expressions other than the index of an index op?\n+    nonindex: bool,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if let ExprPath(ref qpath) = expr.node {\n-            if let QPath::Resolved(None, ref path) = *qpath {\n-                if path.segments.len() == 1 && self.cx.tables.qpath_def(qpath, expr.id).def_id() == self.var {\n-                    // we are referencing our variable! now check if it's as an index\n-                    if_let_chain! {[\n-                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                        let ExprPath(ref seqpath) = seqexpr.node,\n-                        let QPath::Resolved(None, ref seqvar) = *seqpath,\n-                        seqvar.segments.len() == 1\n-                    ], {\n-                        let def = self.cx.tables.qpath_def(seqpath, seqexpr.id);\n-                        match def {\n-                            Def::Local(..) | Def::Upvar(..) => {\n-                                let def_id = def.def_id();\n-                                let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n-\n-                                let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n-                                let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n-                                let extent = self.cx.tcx.region_maps(parent_def_id).var_scope(node_id);\n-                                self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                                return;  // no need to walk further\n-                            }\n-                            Def::Static(..) | Def::Const(..) => {\n-                                self.indexed.insert(seqvar.segments[0].name, None);\n-                                return;  // no need to walk further\n-                            }\n-                            _ => (),\n-                        }\n-                    }}\n-                    // we are not indexing anything, record that\n-                    self.nonindex = true;\n-                    return;\n+        if_let_chain! {[\n+            // an index op\n+            let ExprIndex(ref seqexpr, ref idx) = expr.node,\n+            // directly indexing a variable\n+            let ExprPath(ref qpath) = idx.node,\n+            let QPath::Resolved(None, ref path) = *qpath,\n+            path.segments.len() == 1,\n+            // our variable!\n+            self.cx.tables.qpath_def(qpath, expr.id).def_id() == self.var,\n+            // the indexed container is referenced by a name\n+            let ExprPath(ref seqpath) = seqexpr.node,\n+            let QPath::Resolved(None, ref seqvar) = *seqpath,\n+            seqvar.segments.len() == 1,\n+        ], {\n+            let def = self.cx.tables.qpath_def(seqpath, seqexpr.id);\n+            match def {\n+                Def::Local(..) | Def::Upvar(..) => {\n+                    let def_id = def.def_id();\n+                    let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n+\n+                    let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n+                    let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n+                    let extent = self.cx.tcx.region_maps(parent_def_id).var_scope(node_id);\n+                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                    return;  // no need to walk further\n                 }\n+                Def::Static(..) | Def::Const(..) => {\n+                    self.indexed.insert(seqvar.segments[0].name, None);\n+                    return;  // no need to walk further\n+                }\n+                _ => (),\n             }\n-        }\n+        }}\n+\n+        if_let_chain! {[\n+            // directly indexing a variable\n+            let ExprPath(ref qpath) = expr.node,\n+            let QPath::Resolved(None, ref path) = *qpath,\n+            path.segments.len() == 1,\n+        ], {\n+            if self.cx.tables.qpath_def(qpath, expr.id).def_id() == self.var {\n+                // we are not indexing anything, record that\n+                self.nonindex = true;\n+            } else {\n+                // not the correct variable, but still a variable\n+                self.referenced.insert(path.segments[0].name);\n+            }\n+        }}\n+\n         walk_expr(self, expr);\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {"}, {"sha": "1a4b97650630e03779b7ada93a4caf025954bed2", "filename": "clippy_tests/examples/for_loop.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_tests%2Fexamples%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_tests%2Fexamples%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Ffor_loop.rs?ref=68948a56547fa4bbe7954935fe6296bcbe6dd90d", "patch": "@@ -249,8 +249,8 @@ fn main() {\n     for _v in u.iter() { } // no error\n \n     let mut out = vec![];\n-    vec.iter().map(|x| out.push(x)).collect::<Vec<_>>();\n-    let _y = vec.iter().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n+    vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n+    let _y = vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>(); // this is fine\n \n     // Loop with explicit counter variable\n     let mut _index = 0;\n@@ -346,6 +346,18 @@ fn main() {\n     }\n \n     test_for_kv_map();\n+\n+    fn f<T>(_: &T, _: &T) -> bool { unimplemented!() }\n+    fn g<T>(_: &mut [T], _: usize, _: usize) { unimplemented!() }\n+    for i in 1..vec.len() {\n+        if f(&vec[i - 1], &vec[i]) {\n+            g(&mut vec, i - 1, i);\n+        }\n+    }\n+\n+    for mid in 1..vec.len() {\n+        let (_, _) = vec.split_at(mid);\n+    }\n }\n \n #[allow(used_underscore_binding)]\n@@ -358,3 +370,17 @@ fn test_for_kv_map() {\n         let _k = k;\n     }\n }\n+\n+#[allow(dead_code)]\n+fn partition<T:PartialOrd+Send>(v: &mut [T]) -> usize {\n+    let pivot = v.len() - 1;\n+    let mut i = 0;\n+    for j in 0..pivot {\n+        if v[j] <= v[pivot] {\n+            v.swap(i, j);\n+            i += 1;\n+        }\n+    }\n+    v.swap(i, pivot);\n+    i\n+}"}, {"sha": "06765f35779a2b452581f42388f435ca6e3b7f17", "filename": "clippy_tests/examples/for_loop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_tests%2Fexamples%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68948a56547fa4bbe7954935fe6296bcbe6dd90d/clippy_tests%2Fexamples%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Ffor_loop.stderr?ref=68948a56547fa4bbe7954935fe6296bcbe6dd90d", "patch": "@@ -419,8 +419,8 @@ error: you are iterating over `Iterator::next()` which is an Option; this will c\n error: you are collect()ing an iterator and throwing away the result. Consider using an explicit for loop to exhaust the iterator\n    --> for_loop.rs:252:5\n     |\n-252 |     vec.iter().map(|x| out.push(x)).collect::<Vec<_>>();\n-    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+252 |     vec.iter().cloned().map(|x| out.push(x)).collect::<Vec<_>>();\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D unused-collect` implied by `-D warnings`\n "}]}