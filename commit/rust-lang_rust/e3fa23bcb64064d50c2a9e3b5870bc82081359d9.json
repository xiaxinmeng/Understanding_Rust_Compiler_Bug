{"sha": "e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZmEyM2JjYjY0MDY0ZDUwYzJhOWUzYjU4NzBiYzgyMDgxMzU5ZDk=", "commit": {"author": {"name": "Joseph Crail", "email": "jbcrail@gmail.com", "date": "2014-07-03T01:27:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-03T19:54:51Z"}, "message": "Fix spelling errors.", "tree": {"sha": "55c7f812cc8393b3e2ac7deef52886e811c45ff9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55c7f812cc8393b3e2ac7deef52886e811c45ff9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "html_url": "https://github.com/rust-lang/rust/commit/e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/comments", "author": {"login": "jbcrail", "id": 6038, "node_id": "MDQ6VXNlcjYwMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/6038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbcrail", "html_url": "https://github.com/jbcrail", "followers_url": "https://api.github.com/users/jbcrail/followers", "following_url": "https://api.github.com/users/jbcrail/following{/other_user}", "gists_url": "https://api.github.com/users/jbcrail/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbcrail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbcrail/subscriptions", "organizations_url": "https://api.github.com/users/jbcrail/orgs", "repos_url": "https://api.github.com/users/jbcrail/repos", "events_url": "https://api.github.com/users/jbcrail/events{/privacy}", "received_events_url": "https://api.github.com/users/jbcrail/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8297edd54976d06f4753bc18684614516d156243", "url": "https://api.github.com/repos/rust-lang/rust/commits/8297edd54976d06f4753bc18684614516d156243", "html_url": "https://github.com/rust-lang/rust/commit/8297edd54976d06f4753bc18684614516d156243"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "9b4f879e61ea4a8474cc172002d31e021b4b6bd6", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -185,7 +185,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n         // deletion of the data. Because it is marked `Release`, the\n         // decreasing of the reference count synchronizes with this `Acquire`\n         // fence. This means that use of the data happens before decreasing\n-        // the refernce count, which happens before this fence, which\n+        // the reference count, which happens before this fence, which\n         // happens before the deletion of the data.\n         //\n         // As explained in the [Boost documentation][1],"}, {"sha": "5faa9cfe6f6a2bd0cbbb0c7d80cf95754de2331f", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -124,7 +124,7 @@ impl Drop for Stack {\n }\n \n pub struct StackPool {\n-    // Ideally this would be some datastructure that preserved ordering on\n+    // Ideally this would be some data structure that preserved ordering on\n     // Stack.min_size.\n     stacks: Vec<Stack>,\n }"}, {"sha": "17349f41b98f74889a1df242ddc81ea041e37b90", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -288,7 +288,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     unsafe { INIT.doit(init); }\n \n     // It's possible for many threads are in this function, only one of them\n-    // will peform the global initialization, but all of them will need to check\n+    // will perform the global initialization, but all of them will need to check\n     // again to whether they should really be here or not. Hence, despite this\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again."}, {"sha": "f052826d303861f8b24b60d3f83380ef839c91d6", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -877,7 +877,7 @@ pub fn write<T>(fd: sock_t,\n             }\n \n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforseen circumstances.\n+            // against unforeseen circumstances.\n             let _guard = lock();\n             let ptr = buf.slice_from(written).as_ptr();\n             let len = buf.len() - written;"}, {"sha": "e5e8cdeffd7e4c2249b44d5a7f1db0fa2fee47f7", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -376,7 +376,7 @@ impl rtio::RtioPipe for UnixStream {\n         if ret != 0 { return Ok(bytes_read as uint) }\n \n         // If our errno doesn't say that the I/O is pending, then we hit some\n-        // legitimate error and reeturn immediately.\n+        // legitimate error and return immediately.\n         if os::errno() != libc::ERROR_IO_PENDING as uint {\n             return Err(super::last_error())\n         }"}, {"sha": "4423ab62f0dcfc83c851edcf86102a0f924298b3", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -31,7 +31,7 @@\n #![no_std]\n #![experimental]\n \n-// This library is definining the builtin functions, so it would be a shame for\n+// This library defines the builtin functions, so it would be a shame for\n // LLVM to optimize these function calls to themselves!\n #![no_builtins]\n "}, {"sha": "a190d9309cc8df8612f6fbe85f5a8b76173be14f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -119,7 +119,7 @@ pub mod write {\n     // get all hardware potential via VFP3 (hardware floating point)\n     // and NEON (SIMD) instructions supported by LLVM.\n     // Note that without those flags various linking errors might\n-    // arise as some of intrinsicts are converted into function calls\n+    // arise as some of intrinsics are converted into function calls\n     // and nobody provides implementations those functions\n     fn target_feature<'a>(sess: &'a Session) -> &'a str {\n         match sess.targ_cfg.os {"}, {"sha": "a8f778934ae47e21c28b9b3c016d5326598bd1ea", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -985,7 +985,7 @@ impl UnnecessaryParens {\n             _ => {}\n         }\n \n-        /// Expressions that syntatically contain an \"exterior\" struct\n+        /// Expressions that syntactically contain an \"exterior\" struct\n         /// literal i.e. not surrounded by any parens or other\n         /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n         /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {"}, {"sha": "54cca082e0de86950a10f7c26aeb8672369b6ae4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -383,7 +383,7 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AutoObject(..) => {\n-                        // Implicity cast a concrete object to trait object.\n+                        // Implicitly cast a concrete object to trait object.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))"}, {"sha": "76e962a3bc4da6a1894def5f64c29b5c0b374072", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -1267,7 +1267,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             // error messages without (too many) false positives\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n-            // publically visible.\n+            // publicly visible.\n             ast::ItemImpl(ref g, ref trait_ref, self_, ref methods) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;"}, {"sha": "bdb7d30339d66f010f0ba8e170dffe17dcaafe4b", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -484,7 +484,7 @@ impl <'l> DxrVisitor<'l> {\n     {\n         let qualname = self.analysis.ty_cx.map.path_to_str(item.id);\n \n-        // If the variable is immutable, save the initialising expresion.\n+        // If the variable is immutable, save the initialising expression.\n         let value = match mt {\n             ast::MutMutable => String::from_str(\"<mutable>\"),\n             ast::MutImmutable => self.span.snippet(expr.span),\n@@ -845,7 +845,7 @@ impl <'l> DxrVisitor<'l> {\n                 let decl_id = ty::trait_method_of_method(&self.analysis.ty_cx, def_id);\n \n                 // This incantation is required if the method referenced is a trait's\n-                // defailt implementation.\n+                // default implementation.\n                 let def_id = ty::method(&self.analysis.ty_cx, def_id).provided_source\n                                     .unwrap_or(def_id);\n                 (Some(def_id), decl_id)\n@@ -1403,7 +1403,7 @@ pub fn process_crate(sess: &Session,\n         info!(\"Writing output to {}\", disp);\n     }\n \n-    // Create ouput file.\n+    // Create output file.\n     let mut out_name = cratename.clone();\n     out_name.push_str(\".csv\");\n     root_path.push(out_name);"}, {"sha": "44afc04d3f0efc3984c432dbe6d077e2e835148e", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -93,7 +93,7 @@ pub struct UnificationTable<K,V> {\n \n /**\n  * At any time, users may snapshot a unification table.  The changes\n- * made during the snapshot may either be *commited* or *rolled back*.\n+ * made during the snapshot may either be *committed* or *rolled back*.\n  */\n pub struct Snapshot<K> {\n     // Ensure that this snapshot is keyed to the table type.\n@@ -152,7 +152,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n \n     /**\n      * Starts a new snapshot. Each snapshot must be either\n-     * rolled back or commited in a \"LIFO\" (stack) order.\n+     * rolled back or committed in a \"LIFO\" (stack) order.\n      */\n     pub fn snapshot(&mut self) -> Snapshot<K> {\n         let length = self.undo_log.len();\n@@ -188,12 +188,12 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n             match self.undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n                     // This indicates a failure to obey the stack discipline.\n-                    tcx.sess.bug(\"Cannot rollback an uncommited snapshot\");\n+                    tcx.sess.bug(\"Cannot rollback an uncommitted snapshot\");\n                 }\n \n                 CommittedSnapshot => {\n                     // This occurs when there are nested snapshots and\n-                    // the inner is commited but outer is rolled back.\n+                    // the inner is committed but outer is rolled back.\n                 }\n \n                 NewVar(i) => {"}, {"sha": "d0873d4c66afc9ac9310355b71d55fd506717fe9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -1737,7 +1737,7 @@ pub struct ViewItem {\n \n impl Clean<Vec<Item>> for ast::ViewItem {\n     fn clean(&self) -> Vec<Item> {\n-        // We consider inlining the documentation of `pub use` statments, but we\n+        // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {"}, {"sha": "161d3ed5e65e1cf70b259481e2321f7b2ebbb754", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -376,7 +376,7 @@ pub trait ToCStr {\n // (without forcing an additional & around &str). So we are instead\n // temporarily adding an instance for ~str and String, so that we can\n // take ToCStr as owned. When DST lands, the string instances should\n-// be revisted, and arguments bound by ToCStr should be passed by\n+// be revisited, and arguments bound by ToCStr should be passed by\n // reference.\n \n impl<'a> ToCStr for &'a str {"}, {"sha": "f018b3fc16b3b63a8b26145731084f6df32af474", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -97,7 +97,7 @@ extern {}\n \n extern \"C\" {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n-    // agains corresponding routine (..._SjLj_...)\n+    // against corresponding routine (..._SjLj_...)\n     #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)\n                                   -> _Unwind_Reason_Code;"}, {"sha": "59401a8b66604f0568c80a293bf0421e9ed1ecee", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -170,7 +170,7 @@ impl Task {\n     /// This function can be used as an emulated \"try/catch\" to interoperate\n     /// with the rust runtime at the outermost boundary. It is not possible to\n     /// use this function in a nested fashion (a try/catch inside of another\n-    /// try/catch). Invoking this funciton is quite cheap.\n+    /// try/catch). Invoking this function is quite cheap.\n     ///\n     /// If the closure `f` succeeds, then the returned task can be used again\n     /// for another invocation of `run`. If the closure `f` fails then `self`\n@@ -276,7 +276,7 @@ impl Task {\n         // 1. If TLD destruction fails, heap destruction will be attempted.\n         //    There is a test for this at fail-during-tld-destroy.rs. Sadly the\n         //    other way can't be tested due to point 2 above. Note that we must\n-        //    immortalize the heap first becuase if any deallocations are\n+        //    immortalize the heap first because if any deallocations are\n         //    attempted while TLD is being dropped it will attempt to free the\n         //    allocation from the wrong heap (because the current one has been\n         //    replaced)."}, {"sha": "59784328cdb50c02448a3893b1a4776e947415e3", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -243,7 +243,7 @@ mod imp {\n                 // EINVAL means |stack_size| is either too small or not a\n                 // multiple of the system page size.  Because it's definitely\n                 // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the neareast page and try again.\n+                // Round up to the nearest page and try again.\n                 let page_size = libc::sysconf(libc::_SC_PAGESIZE) as uint;\n                 let stack_size = (stack_size + page_size - 1) &\n                                  (-(page_size as int - 1) as uint - 1);"}, {"sha": "a1712394634b8c2d52d7e0cf50ab48c41661228d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -234,7 +234,7 @@ impl ForbidUnwind {\n impl Drop for ForbidUnwind {\n     fn drop(&mut self) {\n         assert!(self.failing_before == task::failing(),\n-                \"didnt want an unwind during: {}\", self.msg);\n+                \"didn't want an unwind during: {}\", self.msg);\n     }\n }\n "}, {"sha": "875c2dee46b4f874f9cf84a8d293c594558f563b", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -87,7 +87,7 @@ impl StreamWatcher {\n         // immediately as part of the call to alloc_cb. What this means is that\n         // we must be ready for this to happen (by setting the data in the uv\n         // handle). In theory this otherwise doesn't need to happen until after\n-        // the read is succesfully started.\n+        // the read is successfully started.\n         unsafe { uvll::set_data_for_uv_handle(self.handle, &mut rcx) }\n \n         // Send off the read request, but don't block until we're sure that the"}, {"sha": "f6c1cdd2977549f9a5ca7ebd36092fa85872b4cf", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -77,7 +77,7 @@ impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n         // As with all of the below functions, we must be extra careful when\n         // destroying the previous action. If the previous action was a channel,\n-        // destroying it could invoke a context switch. For these situtations,\n+        // destroying it could invoke a context switch. For these situations,\n         // we must temporarily un-home ourselves, then destroy the action, and\n         // then re-home again.\n         let missile = self.fire_homing_missile();"}, {"sha": "ca59849202b08677e03943747fb2617d6eb6a687", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -410,7 +410,7 @@ mod test {\n         // colon after v4\n         let none: Option<IpAddr> = FromStr::from_str(\"::127.0.0.1:\");\n         assert_eq!(None, none);\n-        // not enought groups\n+        // not enough groups\n         let none: Option<IpAddr> = FromStr::from_str(\"1.2.3.4.5:127.0.0.1\");\n         assert_eq!(None, none);\n         // too many groups"}, {"sha": "4388de43f209d280b8c4944576b7cc96a2e550b9", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -469,7 +469,7 @@ pub fn unsetenv(n: &str) {\n ///             println!(\"'{}'\", path.display());\n ///         }\n ///     }\n-///     None => println!(\"{} is not defined in the environnement.\", key)\n+///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {"}, {"sha": "2e0dcdd8eb69f83588a353615eba5a3cb8f7e344", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -266,7 +266,7 @@ mod imp {\n         }\n \n         // while it doesn't requires lock for work as everything is\n-        // local, it still displays much nicier backtraces when a\n+        // local, it still displays much nicer backtraces when a\n         // couple of tasks fail simultaneously\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n         let _g = unsafe { LOCK.lock() };"}, {"sha": "742686069e283531461e68cd7852e9f6d88bbc58", "filename": "src/libsync/comm/oneshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Foneshot.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -354,7 +354,7 @@ impl<T: Send> Packet<T> {\n             }\n \n             // We woke ourselves up from select. Assert that the task should be\n-            // trashed and returne that we don't have any data.\n+            // trashed and returned that we don't have any data.\n             n => {\n                 let t = unsafe { BlockedTask::cast_from_uint(n) };\n                 t.trash();"}, {"sha": "5ad4dea5d2a89bc52df8a319d19cdecb1703ca94", "filename": "src/libsync/comm/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fshared.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -81,7 +81,7 @@ impl<T: Send> Packet<T> {\n \n     // This function should be used after newly created Packet\n     // was wrapped with an Arc\n-    // In other case mutex data will be duplicated while clonning\n+    // In other case mutex data will be duplicated while cloning\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n     pub fn postinit_lock(&mut self) {\n@@ -140,7 +140,7 @@ impl<T: Send> Packet<T> {\n         // See Port::drop for what's going on\n         if self.port_dropped.load(atomics::SeqCst) { return Err(t) }\n \n-        // Note that the multiple sender case is a little tricker\n+        // Note that the multiple sender case is a little trickier\n         // semantically than the single sender case. The logic for\n         // incrementing is \"add and if disconnected store disconnected\".\n         // This could end up leading some senders to believe that there"}, {"sha": "a10ec7458690abcbf20e68bd12c2e4730dea4f76", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -215,7 +215,7 @@ impl StaticMutex {\n             None => {}\n         }\n \n-        // After we've failed the fast path, then we delegate to the differnet\n+        // After we've failed the fast path, then we delegate to the different\n         // locking protocols for green/native tasks. This will select two tasks\n         // to continue further (one native, one green).\n         let t: Box<Task> = Local::take();"}, {"sha": "ab5d70217469c0ab3b9efa9d53e8c9aef8961e8b", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -472,7 +472,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n-    /// `span_err` should be strongly prefered where-ever possible:\n+    /// `span_err` should be strongly preferred where-ever possible:\n     /// this should *only* be used when\n     /// - continuing has a high risk of flow-on errors (e.g. errors in\n     ///   declaring a macro would cause all uses of that macro to"}, {"sha": "157b64fb47c0a7fa3d699681bb0d223d7a718f46", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -834,7 +834,7 @@ impl<'a> MethodDef<'a> {\n                                 generic `deriving`\");\n             }\n \n-            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+            // `ref` inside let matches is buggy. Causes havoc with rusc.\n             // let (variant_index, ref self_vec) = matches_so_far[0];\n             let (variant, self_vec) = match matches_so_far.get(0) {\n                 &(_, v, ref s) => (v, s)"}, {"sha": "c3413293e52ae4b1ac664de13b7246ccffdd5070", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fa23bcb64064d50c2a9e3b5870bc82081359d9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e3fa23bcb64064d50c2a9e3b5870bc82081359d9", "patch": "@@ -1295,7 +1295,7 @@ mod test {\n     }\n \n     // create a really evil test case where a $x appears inside a binding of $x\n-    // but *shouldnt* bind because it was inserted by a different macro....\n+    // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n     // FIXME #9383 : lambda var hygiene"}]}