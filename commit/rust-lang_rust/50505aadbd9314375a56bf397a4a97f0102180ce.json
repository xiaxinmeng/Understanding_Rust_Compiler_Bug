{"sha": "50505aadbd9314375a56bf397a4a97f0102180ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNTA1YWFkYmQ5MzE0Mzc1YTU2YmYzOTdhNGE5N2YwMTAyMTgwY2U=", "commit": {"author": {"name": "Federico Mena Quintero", "email": "federico@gnome.org", "date": "2017-10-02T19:16:37Z"}, "committer": {"name": "Federico Mena Quintero", "email": "federico@gnome.org", "date": "2017-10-02T19:16:37Z"}, "message": "Clarify the ffi module's toplevel docs, per @clarcharr's comments", "tree": {"sha": "809823275d2bb204070a7d51620df1c5dbad7404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/809823275d2bb204070a7d51620df1c5dbad7404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50505aadbd9314375a56bf397a4a97f0102180ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50505aadbd9314375a56bf397a4a97f0102180ce", "html_url": "https://github.com/rust-lang/rust/commit/50505aadbd9314375a56bf397a4a97f0102180ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50505aadbd9314375a56bf397a4a97f0102180ce/comments", "author": {"login": "federicomenaquintero", "id": 7617, "node_id": "MDQ6VXNlcjc2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/federicomenaquintero", "html_url": "https://github.com/federicomenaquintero", "followers_url": "https://api.github.com/users/federicomenaquintero/followers", "following_url": "https://api.github.com/users/federicomenaquintero/following{/other_user}", "gists_url": "https://api.github.com/users/federicomenaquintero/gists{/gist_id}", "starred_url": "https://api.github.com/users/federicomenaquintero/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/federicomenaquintero/subscriptions", "organizations_url": "https://api.github.com/users/federicomenaquintero/orgs", "repos_url": "https://api.github.com/users/federicomenaquintero/repos", "events_url": "https://api.github.com/users/federicomenaquintero/events{/privacy}", "received_events_url": "https://api.github.com/users/federicomenaquintero/received_events", "type": "User", "site_admin": false}, "committer": {"login": "federicomenaquintero", "id": 7617, "node_id": "MDQ6VXNlcjc2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/federicomenaquintero", "html_url": "https://github.com/federicomenaquintero", "followers_url": "https://api.github.com/users/federicomenaquintero/followers", "following_url": "https://api.github.com/users/federicomenaquintero/following{/other_user}", "gists_url": "https://api.github.com/users/federicomenaquintero/gists{/gist_id}", "starred_url": "https://api.github.com/users/federicomenaquintero/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/federicomenaquintero/subscriptions", "organizations_url": "https://api.github.com/users/federicomenaquintero/orgs", "repos_url": "https://api.github.com/users/federicomenaquintero/repos", "events_url": "https://api.github.com/users/federicomenaquintero/events{/privacy}", "received_events_url": "https://api.github.com/users/federicomenaquintero/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9854e836a35c3114c81b8102d3468ff9071b4141", "url": "https://api.github.com/repos/rust-lang/rust/commits/9854e836a35c3114c81b8102d3468ff9071b4141", "html_url": "https://github.com/rust-lang/rust/commit/9854e836a35c3114c81b8102d3468ff9071b4141"}], "stats": {"total": 119, "additions": 65, "deletions": 54}, "files": [{"sha": "f8a4a904fc55ec7e04e7abb50bbd0b22ae79e81b", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 65, "deletions": 54, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/50505aadbd9314375a56bf397a4a97f0102180ce/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50505aadbd9314375a56bf397a4a97f0102180ce/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=50505aadbd9314375a56bf397a4a97f0102180ce", "patch": "@@ -8,78 +8,86 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module provides utilities to handle C-like strings.  It is\n-//! mainly of use for FFI (Foreign Function Interface) bindings and\n-//! code that needs to exchange C-like strings with other languages.\n+//! This module provides utilities to handle data across non-Rust\n+//! interfaces, like other programming languages and the underlying\n+//! operating system.  It is mainly of use for FFI (Foreign Function\n+//! Interface) bindings and code that needs to exchange C-like strings\n+//! with other languages.\n //!\n //! # Overview\n //!\n //! Rust represents owned strings with the [`String`] type, and\n //! borrowed slices of strings with the [`str`] primitive.  Both are\n //! always in UTF-8 encoding, and may contain nul bytes in the middle,\n //! i.e. if you look at the bytes that make up the string, there may\n-//! be a `0` among them.  Both `String` and `str` know their length;\n-//! there are no nul terminators at the end of strings like in C.\n+//! be a `\\0` among them.  Both `String` and `str` store their length\n+//! explicitly; there are no nul terminators at the end of strings\n+//! like in C.\n //!\n //! C strings are different from Rust strings:\n //!\n-//! * **Encodings** - C strings may have different encodings.  If\n-//! you are bringing in strings from C APIs, you should check what\n-//! encoding you are getting.  Rust strings are always UTF-8.\n+//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n+//! other encodings.  If you are using a string from C, you should\n+//! check its encoding explicitly, rather than just assuming that it\n+//! is UTF-8 like you can do in Rust.\n //!\n-//! * **Character width** - C strings may use \"normal\" or \"wide\"\n-//! characters, i.e. `char` or `wchar_t`, respectively.  The C\n-//! standard leaves the actual sizes of those types open to\n+//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n+//! characters; please **note** that C's `char` is different from Rust's.\n+//! The C standard leaves the actual sizes of those types open to\n //! interpretation, but defines different APIs for strings made up of\n //! each character type.  Rust strings are always UTF-8, so different\n //! Unicode characters will be encoded in a variable number of bytes\n-//! each.  The Rust type [`char`] represents a '[Unicode\n-//! scalar value]', which is similar to, but not the same as, a\n-//! '[Unicode code point]'.\n+//! each.  The Rust type [`char`] represents a '[Unicode scalar\n+//! value]', which is similar to, but not the same as, a '[Unicode\n+//! code point]'.\n //!\n //! * **Nul terminators and implicit string lengths** - Often, C\n-//! strings are nul-terminated, i.e. they have a `0` character at the\n-//! end.  The length of a string buffer is not known *a priori*;\n-//! instead, to compute the length of a string, C code must manually\n-//! call a function like `strlen()` for `char`-based strings, or\n-//! `wcslen()` for `wchar_t`-based ones.  Those functions return the\n-//! number of characters in the string excluding the nul terminator,\n-//! so the buffer length is really `len+1` characters.  Rust strings\n-//! don't have a nul terminator, and they always know their length.\n-//!\n-//! * **No nul characters in the middle of the string** - When C\n-//! strings have a nul terminator character, this usually means that\n-//! they cannot have nul characters in the middle \u2014 a nul character\n-//! would essentially truncate the string.  Rust strings *can* have\n-//! nul characters in the middle, since they don't use nul\n-//! terminators.\n+//! strings are nul-terminated, i.e. they have a `\\0` character at the\n+//! end.  The length of a string buffer is not stored, but has to be\n+//! calculated; to compute the length of a string, C code must\n+//! manually call a function like `strlen()` for `char`-based strings,\n+//! or `wcslen()` for `wchar_t`-based ones.  Those functions return\n+//! the number of characters in the string excluding the nul\n+//! terminator, so the buffer length is really `len+1` characters.\n+//! Rust strings don't have a nul terminator; their length is always\n+//! stored and does not need to be calculated.  While in Rust\n+//! accessing a string's length is a O(1) operation (becasue the\n+//! length is stored); in C it is an O(length) operation because the\n+//! length needs to be computed by scanning the string for the nul\n+//! terminator.\n+//!\n+//! * **Internal nul characters** - When C strings have a nul\n+//! terminator character, this usually means that they cannot have nul\n+//! characters in the middle \u2014 a nul character would essentially\n+//! truncate the string.  Rust strings *can* have nul characters in\n+//! the middle, because nul does not have to mark the end of the\n+//! string in Rust.\n //!\n //! # Representations of non-Rust strings\n //!\n //! [`CString`] and [`CStr`] are useful when you need to transfer\n-//! UTF-8 strings to and from C, respectively:\n+//! UTF-8 strings to and from languages with a C ABI, like Python.\n //!\n //! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n-//! UTF-8 string:  it is valid UTF-8, it is nul-terminated, and has no\n-//! nul characters in the middle.  Rust code can create a `CString`\n-//! out of a normal string (provided that the string doesn't have nul\n-//! characters in the middle), and then use a variety of methods to\n-//! obtain a raw `*mut u8` that can then be passed as an argument to C\n-//! functions.\n+//! string: it is nul-terminated, and has no internal nul characters.\n+//! Rust code can create a `CString` out of a normal string (provided\n+//! that the string doesn't have nul characters in the middle), and\n+//! then use a variety of methods to obtain a raw `*mut u8` that can\n+//! then be passed as an argument to functions which use the C\n+//! conventions for strings.\n //!\n //! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n //! is what you would use to wrap a raw `*const u8` that you got from\n-//! a C function.  A `CStr` is just guaranteed to be a nul-terminated\n-//! array of bytes; the UTF-8 validation step only happens when you\n-//! request to convert it to a `&str`.\n+//! a C function.  A `CStr` is guaranteed to be a nul-terminated array\n+//! of bytes.  Once you have a `CStr`, you can convert it to a Rust\n+//! `&str` if it's valid UTF-8, or lossily convert it by adding\n+//! replacement characters.\n //!\n //! [`OsString`] and [`OsStr`] are useful when you need to transfer\n-//! strings to and from operating system calls.  If you need Rust\n-//! strings out of them, they can take care of conversion to and from\n-//! the operating system's preferred form for strings \u2014 of course, it\n-//! may not be possible to convert all valid operating system strings\n-//! into valid UTF-8; the `OsString` and `OsStr` functions let you know\n-//! when this is the case.\n+//! strings to and from the operating system itself, or when capturing\n+//! the output of external commands.  Conversions between `OsString`,\n+//! `OsStr` and Rust strings work similarly to those for [`CString`]\n+//! and [`CStr`].\n //!\n //! * [`OsString`] represents an owned string in whatever\n //! representation the operating system prefers.  In the Rust standard\n@@ -101,9 +109,10 @@\n //!\n //! ## On Unix\n //!\n-//! On Unix, [`OsStr`] implements the `std::os::unix:ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n-//! augments it with two methods, [`from_bytes`] and [`as_bytes`].  These do inexpensive conversions\n-//! from and to UTF-8 byte slices.\n+//! On Unix, [`OsStr`] implements the\n+//! `std::os::unix:ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n+//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n+//! These do inexpensive conversions from and to UTF-8 byte slices.\n //!\n //! Additionally, on Unix [`OsString`] implements the\n //! `std::os::unix:ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n@@ -112,14 +121,16 @@\n //!\n //! ## On Windows\n //!\n-//! On Windows, [`OsStr`] implements the `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt]\n-//! trait, which provides an [`encode_wide`] method.  This provides an iterator that can be\n-//! [`collect`]ed into a vector of [`u16`].\n+//! On Windows, [`OsStr`] implements the\n+//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n+//! which provides an [`encode_wide`] method.  This provides an\n+//! iterator that can be [`collect`]ed into a vector of [`u16`].\n //!\n //! Additionally, on Windows [`OsString`] implements the\n-//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt] trait, which provides a\n-//! [`from_wide`] method.  The result of this method is an `OsString` which can be round-tripped to\n-//! a Windows string losslessly.\n+//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n+//! trait, which provides a [`from_wide`] method.  The result of this\n+//! method is an `OsString` which can be round-tripped to a Windows\n+//! string losslessly.\n //!\n //! [`String`]: ../string/struct.String.html\n //! [`str`]: ../primitive.str.html"}]}