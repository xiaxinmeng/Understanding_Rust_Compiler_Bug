{"sha": "6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NzBhNjNmNjI4MzZkYmI0NDI3OGVmNWQ3YzIzYmMzZTczYzcyY2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-15T01:22:51Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-15T01:22:51Z"}, "message": "llvmext: Add Mach-O object file reading support to LLVM's BFD workalike", "tree": {"sha": "6cb8c0a164113a144746cc78eee1776589e0f3f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb8c0a164113a144746cc78eee1776589e0f3f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "html_url": "https://github.com/rust-lang/rust/commit/6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6670a63f62836dbb44278ef5d7c23bc3e73c72cf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bbd741c2e0e9c17bb1a6406be37e6991b6d14cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbd741c2e0e9c17bb1a6406be37e6991b6d14cd", "html_url": "https://github.com/rust-lang/rust/commit/3bbd741c2e0e9c17bb1a6406be37e6991b6d14cd"}], "stats": {"total": 332, "additions": 331, "deletions": 1}, "files": [{"sha": "ccf9ab0e5ce88eb9e95de0ac900d07ef8321e106", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6670a63f62836dbb44278ef5d7c23bc3e73c72cf/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6670a63f62836dbb44278ef5d7c23bc3e73c72cf/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "patch": "@@ -311,7 +311,7 @@ RUNTIME_HDR := rt/globals.h \\\n RUNTIME_INCS := -Irt/isaac -Irt/uthash\n RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n \n-SUPPORT_CS := llvmext/Object.cpp\n+SUPPORT_CS := llvmext/MachOObjectFile.cpp llvmext/Object.cpp\n \n SUPPORT_HDR := llvmext/include/llvm-c/Object.h\n "}, {"sha": "4a003249191e29d07f6c830847ba928fa81b64f6", "filename": "src/llvmext/MachOObjectFile.cpp", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/6670a63f62836dbb44278ef5d7c23bc3e73c72cf/src%2Fllvmext%2FMachOObjectFile.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6670a63f62836dbb44278ef5d7c23bc3e73c72cf/src%2Fllvmext%2FMachOObjectFile.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvmext%2FMachOObjectFile.cpp?ref=6670a63f62836dbb44278ef5d7c23bc3e73c72cf", "patch": "@@ -0,0 +1,330 @@\n+//===- MachOObjectFile.cpp - Mach-O object file binding ---------*- C++ -*-===//\n+//\n+//                     The LLVM Compiler Infrastructure\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines the MachOObjectFile class, which binds the MachOObject\n+// class to the generic ObjectFile wrapper.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"llvm/ADT/Triple.h\"\n+#include \"llvm/Object/MachOFormat.h\"\n+#include \"llvm/Object/MachOObject.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n+#include \"llvm/Support/MemoryBuffer.h\"\n+\n+#include <cctype>\n+#include <cstring>\n+#include <limits>\n+\n+using namespace llvm;\n+using namespace object;\n+\n+namespace llvm {\n+\n+typedef MachOObject::LoadCommandInfo LoadCommandInfo;\n+\n+class MachOObjectFile : public ObjectFile {\n+public:\n+  MachOObjectFile(MemoryBuffer *Object, MachOObject *MOO)\n+    : ObjectFile(Object),\n+      MachOObj(MOO),\n+      RegisteredStringTable(std::numeric_limits<uint32_t>::max()) {}\n+\n+  virtual symbol_iterator begin_symbols() const;\n+  virtual symbol_iterator end_symbols() const;\n+  virtual section_iterator begin_sections() const;\n+  virtual section_iterator end_sections() const;\n+\n+  virtual uint8_t getBytesInAddress() const;\n+  virtual StringRef getFileFormatName() const;\n+  virtual unsigned getArch() const;\n+\n+protected:\n+  virtual SymbolRef getSymbolNext(DataRefImpl Symb) const;\n+  virtual StringRef getSymbolName(DataRefImpl Symb) const;\n+  virtual uint64_t  getSymbolAddress(DataRefImpl Symb) const;\n+  virtual uint64_t  getSymbolSize(DataRefImpl Symb) const;\n+  virtual char      getSymbolNMTypeChar(DataRefImpl Symb) const;\n+  virtual bool      isSymbolInternal(DataRefImpl Symb) const;\n+\n+  virtual SectionRef getSectionNext(DataRefImpl Sec) const;\n+  virtual StringRef  getSectionName(DataRefImpl Sec) const;\n+  virtual uint64_t   getSectionAddress(DataRefImpl Sec) const;\n+  virtual uint64_t   getSectionSize(DataRefImpl Sec) const;\n+  virtual StringRef  getSectionContents(DataRefImpl Sec) const;\n+  virtual bool       isSectionText(DataRefImpl Sec) const;\n+\n+private:\n+  MachOObject *MachOObj;\n+  mutable uint32_t RegisteredStringTable;\n+\n+  void moveToNextSection(DataRefImpl &DRI) const;\n+  void getSymbolTableEntry(DataRefImpl DRI,\n+                           InMemoryStruct<macho::SymbolTableEntry> &Res) const;\n+  void moveToNextSymbol(DataRefImpl &DRI) const;\n+  void getSection(DataRefImpl DRI, InMemoryStruct<macho::Section> &Res) const;\n+};\n+\n+ObjectFile *ObjectFile::createMachOObjectFile(MemoryBuffer *Buffer) {\n+  std::string Err;\n+  MachOObject *MachOObj = MachOObject::LoadFromBuffer(Buffer, &Err);\n+  if (!MachOObj)\n+    return NULL;\n+  return new MachOObjectFile(Buffer, MachOObj);\n+}\n+\n+/*===-- Symbols -----------------------------------------------------------===*/\n+\n+void MachOObjectFile::moveToNextSymbol(DataRefImpl &DRI) const {\n+  uint32_t LoadCommandCount = MachOObj->getHeader().NumLoadCommands;\n+  while (DRI.d.a < LoadCommandCount) {\n+    LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+    if (LCI.Command.Type == macho::LCT_Symtab) {\n+      InMemoryStruct<macho::SymtabLoadCommand> SymtabLoadCmd;\n+      MachOObj->ReadSymtabLoadCommand(LCI, SymtabLoadCmd);\n+      if (DRI.d.b < SymtabLoadCmd->NumSymbolTableEntries)\n+        return;\n+    }\n+\n+    DRI.d.a++;\n+    DRI.d.b = 0;\n+  }\n+}\n+\n+void MachOObjectFile::getSymbolTableEntry(DataRefImpl DRI,\n+    InMemoryStruct<macho::SymbolTableEntry> &Res) const {\n+  InMemoryStruct<macho::SymtabLoadCommand> SymtabLoadCmd;\n+  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+  MachOObj->ReadSymtabLoadCommand(LCI, SymtabLoadCmd);\n+\n+  if (RegisteredStringTable != DRI.d.a) {\n+    MachOObj->RegisterStringTable(*SymtabLoadCmd);\n+    RegisteredStringTable = DRI.d.a;\n+  }\n+\n+  MachOObj->ReadSymbolTableEntry(SymtabLoadCmd->SymbolTableOffset, DRI.d.b,\n+                                 Res);\n+}\n+\n+\n+SymbolRef MachOObjectFile::getSymbolNext(DataRefImpl DRI) const {\n+  DRI.d.b++;\n+  moveToNextSymbol(DRI);\n+  return SymbolRef(DRI, this);\n+}\n+\n+StringRef MachOObjectFile::getSymbolName(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SymbolTableEntry> Entry;\n+  getSymbolTableEntry(DRI, Entry);\n+  return MachOObj->getStringAtIndex(Entry->StringIndex);\n+}\n+\n+uint64_t MachOObjectFile::getSymbolAddress(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SymbolTableEntry> Entry;\n+  getSymbolTableEntry(DRI, Entry);\n+  return Entry->Value;\n+}\n+\n+uint64_t MachOObjectFile::getSymbolSize(DataRefImpl DRI) const {\n+  return UnknownAddressOrSize;\n+}\n+\n+char MachOObjectFile::getSymbolNMTypeChar(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SymbolTableEntry> Entry;\n+  getSymbolTableEntry(DRI, Entry);\n+\n+  char Char;\n+  switch (Entry->Type & macho::STF_TypeMask) {\n+    case macho::STT_Undefined:\n+      Char = 'u';\n+      break;\n+    case macho::STT_Absolute:\n+    case macho::STT_Section:\n+      Char = 's';\n+      break;\n+    default:\n+      Char = '?';\n+      break;\n+  }\n+\n+  if (Entry->Flags & (macho::STF_External | macho::STF_PrivateExtern))\n+    Char = toupper(Char);\n+  return Char;\n+}\n+\n+bool MachOObjectFile::isSymbolInternal(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SymbolTableEntry> Entry;\n+  getSymbolTableEntry(DRI, Entry);\n+  return Entry->Flags & macho::STF_StabsEntryMask;\n+}\n+\n+ObjectFile::symbol_iterator MachOObjectFile::begin_symbols() const {\n+  // DRI.d.a = segment number; DRI.d.b = symbol index.\n+  DataRefImpl DRI;\n+  DRI.d.a = DRI.d.b = 0;\n+  moveToNextSymbol(DRI);\n+  return symbol_iterator(SymbolRef(DRI, this));\n+}\n+\n+ObjectFile::symbol_iterator MachOObjectFile::end_symbols() const {\n+  DataRefImpl DRI;\n+  DRI.d.a = MachOObj->getHeader().NumLoadCommands;\n+  DRI.d.b = 0;\n+  return symbol_iterator(SymbolRef(DRI, this));\n+}\n+\n+\n+/*===-- Sections ----------------------------------------------------------===*/\n+\n+void MachOObjectFile::moveToNextSection(DataRefImpl &DRI) const {\n+  uint32_t LoadCommandCount = MachOObj->getHeader().NumLoadCommands;\n+  while (DRI.d.a < LoadCommandCount) {\n+    LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+    if (LCI.Command.Type == macho::LCT_Segment) {\n+      InMemoryStruct<macho::SegmentLoadCommand> SegmentLoadCmd;\n+      MachOObj->ReadSegmentLoadCommand(LCI, SegmentLoadCmd);\n+      if (DRI.d.b < SegmentLoadCmd->NumSections)\n+        return;\n+    } else if (LCI.Command.Type == macho::LCT_Segment64) {\n+      InMemoryStruct<macho::Segment64LoadCommand> Segment64LoadCmd;\n+      MachOObj->ReadSegment64LoadCommand(LCI, Segment64LoadCmd);\n+      if (DRI.d.b < Segment64LoadCmd->NumSections)\n+        return;\n+    }\n+\n+    DRI.d.a++;\n+    DRI.d.b = 0;\n+  }\n+}\n+\n+SectionRef MachOObjectFile::getSectionNext(DataRefImpl DRI) const {\n+  DRI.d.b++;\n+  moveToNextSection(DRI);\n+  return SectionRef(DRI, this);\n+}\n+\n+void\n+MachOObjectFile::getSection(DataRefImpl DRI,\n+                            InMemoryStruct<macho::Section> &Res) const {\n+  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n+  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n+  MachOObj->ReadSection(LCI, DRI.d.b, Res);\n+}\n+\n+StringRef MachOObjectFile::getSectionName(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n+  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n+  InMemoryStruct<macho::Section> Sect;\n+  MachOObj->ReadSection(LCI, DRI.d.b, Sect);\n+\n+  static char Result[34];\n+  strcpy(Result, SLC->Name);\n+  strcat(Result, \",\");\n+  strcat(Result, Sect->Name);\n+  return StringRef(Result);\n+}\n+\n+uint64_t MachOObjectFile::getSectionAddress(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::Section> Sect;\n+  getSection(DRI, Sect);\n+  return Sect->Address;\n+}\n+\n+uint64_t MachOObjectFile::getSectionSize(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::Section> Sect;\n+  getSection(DRI, Sect);\n+  return Sect->Size;\n+}\n+\n+StringRef MachOObjectFile::getSectionContents(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::Section> Sect;\n+  getSection(DRI, Sect);\n+  return MachOObj->getData(Sect->Offset, Sect->Size);\n+}\n+\n+bool MachOObjectFile::isSectionText(DataRefImpl DRI) const {\n+  InMemoryStruct<macho::SegmentLoadCommand> SLC;\n+  LoadCommandInfo LCI = MachOObj->getLoadCommandInfo(DRI.d.a);\n+  MachOObj->ReadSegmentLoadCommand(LCI, SLC);\n+  return !strcmp(SLC->Name, \"__TEXT\");\n+}\n+\n+ObjectFile::section_iterator MachOObjectFile::begin_sections() const {\n+  DataRefImpl DRI;\n+  DRI.d.a = DRI.d.b = 0;\n+  moveToNextSection(DRI);\n+  return section_iterator(SectionRef(DRI, this));\n+}\n+\n+ObjectFile::section_iterator MachOObjectFile::end_sections() const {\n+  DataRefImpl DRI;\n+  DRI.d.a = MachOObj->getHeader().NumLoadCommands;\n+  DRI.d.b = 0;\n+  return section_iterator(SectionRef(DRI, this));\n+}\n+\n+/*===-- Miscellaneous -----------------------------------------------------===*/\n+\n+uint8_t MachOObjectFile::getBytesInAddress() const {\n+  return MachOObj->is64Bit() ? 8 : 4;\n+}\n+\n+StringRef MachOObjectFile::getFileFormatName() const {\n+  if (!MachOObj->is64Bit()) {\n+    switch (MachOObj->getHeader().CPUType) {\n+    case 0x00000007:\n+      return \"MACHO32-i386\";\n+    case 0x01000007:\n+      return \"MACHO32-x86-64\";\n+    case 0x0000000c:\n+      return \"MACHO32-arm\";\n+    case 0x00000012:\n+      return \"MACHO32-ppc\";\n+    case 0x01000012:\n+      return \"MACHO32-ppc64\";\n+    }\n+  }\n+\n+  switch (MachOObj->getHeader().CPUType) {\n+  case 0x00000007:\n+    return \"MACHO64-i386\";\n+  case 0x01000007:\n+    return \"MACHO64-x86-64\";\n+  case 0x0000000c:\n+    return \"MACHO64-arm\";\n+  case 0x00000012:\n+    return \"MACHO64-ppc\";\n+  case 0x01000012:\n+    return \"MACHO64-ppc64\";\n+  default:\n+    return \"MACHO64-unknown\";\n+  }\n+}\n+\n+unsigned MachOObjectFile::getArch() const {\n+  switch (MachOObj->getHeader().CPUType) {\n+  case 0x00000007:\n+    return Triple::x86;\n+  case 0x01000007:\n+    return Triple::x86_64;\n+  case 0x0000000c:\n+    return Triple::arm;\n+  case 0x00000012:\n+    return Triple::ppc;\n+  case 0x01000012:\n+    return Triple::ppc64;\n+  default:\n+    return Triple::UnknownArch;\n+  }\n+}\n+\n+} // end namespace llvm\n+"}]}