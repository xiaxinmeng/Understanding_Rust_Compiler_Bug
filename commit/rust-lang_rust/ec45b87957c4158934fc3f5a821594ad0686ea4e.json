{"sha": "ec45b87957c4158934fc3f5a821594ad0686ea4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDViODc5NTdjNDE1ODkzNGZjM2Y1YTgyMTU5NGFkMDY4NmVhNGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-24T18:12:13Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-26T21:31:55Z"}, "message": "resolve: Block expansion of a derive container until all its derives are resolved\n\nAlso mark derive helpers as known as a part of the derive container's expansion instead of expansion of the derives themselves which may happen too late.", "tree": {"sha": "59abaac544f9b95b121f12537476e11b62f7d8b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59abaac544f9b95b121f12537476e11b62f7d8b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec45b87957c4158934fc3f5a821594ad0686ea4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec45b87957c4158934fc3f5a821594ad0686ea4e", "html_url": "https://github.com/rust-lang/rust/commit/ec45b87957c4158934fc3f5a821594ad0686ea4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec45b87957c4158934fc3f5a821594ad0686ea4e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06", "html_url": "https://github.com/rust-lang/rust/commit/9b91b9c10e3c87ed333a1e34c4f46ed68f1eee06"}], "stats": {"total": 348, "additions": 195, "deletions": 153}, "files": [{"sha": "7d2414f9a1dfa502868746a27ca87d3bf6affeb1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -538,9 +538,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                        client, attrs: helper_attrs.clone()\n-                    })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n                     helper_attrs,\n                 )\n             }"}, {"sha": "20418633dc6827bdf250428bcd453464bce30c2e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -13,7 +13,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n-use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n+use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n@@ -142,7 +142,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n+    ) -> Result<InvocationRes, Indeterminate> {\n         let invoc_id = invoc.expansion_data.id;\n         let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n             Some(parent_scope) => *parent_scope,\n@@ -165,25 +165,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n-                // Block expansion of derives in the container until we know whether one of them\n-                // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n-                // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n-                // will automatically knows about itself.\n-                let mut result = Ok(None);\n-                if derives.len() > 1 {\n-                    for path in derives {\n-                        match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n-                            Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n-                                self.add_derives(invoc_id, SpecialDerives::COPY);\n-                                return Ok(None);\n-                            }\n-                            Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n-                            _ => {}\n-                        }\n-                    }\n+                // Block expansion of the container until we resolve all derives in it.\n+                // This is required for two reasons:\n+                // - Derive helper attributes are in scope for the item to which the `#[derive]`\n+                //   is applied, so they have to be produced by the container's expansion rather\n+                //   than by individual derives.\n+                // - Derives in the container need to know whether one of them is a built-in `Copy`.\n+                // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n+                let mut exts = Vec::new();\n+                for path in derives {\n+                    exts.push(match self.resolve_macro_path(\n+                        path, Some(MacroKind::Derive), &parent_scope, true, force\n+                    ) {\n+                        Ok((Some(ext), _)) => ext,\n+                        Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                        Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+                    })\n                 }\n-                return result;\n+                return Ok(InvocationRes::DeriveContainer(exts));\n             }\n         };\n \n@@ -203,7 +202,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        Ok(Some(ext))\n+        Ok(InvocationRes::Single(ext))\n     }\n \n     fn check_unused_macros(&self) {"}, {"sha": "f0397558a1d607adbad9bd2085af1e4d361a433c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -11,6 +11,7 @@ use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n+use crate::visit::Visitor;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n@@ -72,6 +73,17 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n+        match self {\n+            Annotatable::Item(item) => visitor.visit_item(item),\n+            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n+            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n+            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n+            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -637,6 +649,12 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Result of resolving a macro invocation.\n+pub enum InvocationRes {\n+    Single(Lrc<SyntaxExtension>),\n+    DeriveContainer(Vec<Lrc<SyntaxExtension>>),\n+}\n+\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n@@ -664,7 +682,7 @@ pub trait Resolver {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n+    ) -> Result<InvocationRes, Indeterminate>;\n \n     fn check_unused_macros(&self);\n "}, {"sha": "7b4a516744642075301dec2c73e4cb21aacb85e6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::proc_macro::collect_derives;\n+use crate::ext::proc_macro::{collect_derives, MarkAttrs};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -307,10 +307,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let eager_expansion_root =\n                 if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let ext = match self.cx.resolver.resolve_macro_invocation(\n+            let res = match self.cx.resolver.resolve_macro_invocation(\n                 &invoc, eager_expansion_root, force\n             ) {\n-                Ok(ext) => ext,\n+                Ok(res) => res,\n                 Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n@@ -322,54 +322,72 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let fragment = self.expand_invoc(invoc, &ext.kind);\n-                self.collect_invocations(fragment, &[])\n-            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n-                if !item.derive_allowed() {\n-                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                        .expect(\"`derive` attribute should exist\");\n-                    let span = attr.span;\n-                    let mut err = self.cx.mut_span_err(span,\n-                                                        \"`derive` may only be applied to \\\n-                                                        structs, enums and unions\");\n-                    if let ast::AttrStyle::Inner = attr.style {\n-                        let trait_list = traits.iter()\n-                            .map(|t| t.to_string()).collect::<Vec<_>>();\n-                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                        err.span_suggestion(\n-                            span, \"try an outer attribute\", suggestion,\n-                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                            Applicability::MaybeIncorrect\n-                        );\n-                    }\n-                    err.emit();\n+            let (expanded_fragment, new_invocations) = match res {\n+                InvocationRes::Single(ext) => {\n+                    let fragment = self.expand_invoc(invoc, &ext.kind);\n+                    self.collect_invocations(fragment, &[])\n                 }\n+                InvocationRes::DeriveContainer(exts) => {\n+                    let (derives, item) = match invoc.kind {\n+                        InvocationKind::DeriveContainer { derives, item } => (derives, item),\n+                        _ => unreachable!(),\n+                    };\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                            .expect(\"`derive` attribute should exist\");\n+                        let span = attr.span;\n+                        let mut err = self.cx.mut_span_err(span,\n+                            \"`derive` may only be applied to structs, enums and unions\");\n+                        if let ast::AttrStyle::Inner = attr.style {\n+                            let trait_list = derives.iter()\n+                                .map(|t| t.to_string()).collect::<Vec<_>>();\n+                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                            err.span_suggestion(\n+                                span, \"try an outer attribute\", suggestion,\n+                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                                Applicability::MaybeIncorrect\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n \n-                let mut item = self.fully_configure(item);\n-                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derive_placeholders =\n-                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n-\n-                derive_placeholders.reserve(traits.len());\n-                invocations.reserve(traits.len());\n-                for path in traits {\n-                    let expn_id = ExpnId::fresh(None);\n-                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                    invocations.push(Invocation {\n-                        kind: InvocationKind::Derive { path, item: item.clone() },\n-                        fragment_kind: invoc.fragment_kind,\n-                        expansion_data: ExpansionData {\n-                            id: expn_id,\n-                            ..invoc.expansion_data.clone()\n-                        },\n-                    });\n+                    let mut item = self.fully_configure(item);\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                    let mut helper_attrs = Vec::new();\n+                    let mut has_copy = false;\n+                    for ext in exts {\n+                        helper_attrs.extend(&ext.helper_attrs);\n+                        has_copy |= ext.is_derive_copy;\n+                    }\n+                    // Mark derive helpers inside this item as known and used.\n+                    // FIXME: This is a hack, derive helpers should be integrated with regular name\n+                    // resolution instead. For example, helpers introduced by a derive container\n+                    // can be in scope for all code produced by that container's expansion.\n+                    item.visit_with(&mut MarkAttrs(&helper_attrs));\n+                    if has_copy {\n+                        self.cx.resolver.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                    }\n+\n+                    let derive_placeholders =\n+                        all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n+                    derive_placeholders.reserve(derives.len());\n+                    invocations.reserve(derives.len());\n+                    for path in derives {\n+                        let expn_id = ExpnId::fresh(None);\n+                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n+                        invocations.push(Invocation {\n+                            kind: InvocationKind::Derive { path, item: item.clone() },\n+                            fragment_kind: invoc.fragment_kind,\n+                            expansion_data: ExpansionData {\n+                                id: expn_id,\n+                                ..invoc.expansion_data.clone()\n+                            },\n+                        });\n+                    }\n+                    let fragment = invoc.fragment_kind\n+                        .expect_from_annotatables(::std::iter::once(item));\n+                    self.collect_invocations(fragment, derive_placeholders)\n                 }\n-                let fragment = invoc.fragment_kind\n-                    .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derive_placeholders)\n-            } else {\n-                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {"}, {"sha": "4a44c9a9f1f312d7e690a37780dfea2ebb76a02e", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -78,7 +78,6 @@ pub struct ProcMacroDerive {\n     pub client: proc_macro::bridge::client::Client<\n         fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n-    pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -111,9 +110,6 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n         let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n         let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n \n@@ -164,7 +160,7 @@ impl MultiItemModifier for ProcMacroDerive {\n     }\n }\n \n-struct MarkAttrs<'a>(&'a [ast::Name]);\n+crate struct MarkAttrs<'a>(crate &'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {"}, {"sha": "b18df3511817db7400d45c8e70fd84eb7546880b", "filename": "src/test/ui/derives/deriving-bounds.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,15 +1,3 @@\n-error: cannot find derive macro `Send` in this scope\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-   |\n-note: unsafe traits like `Send` should be implemented explicitly\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-\n error: cannot find derive macro `Sync` in this scope\n   --> $DIR/deriving-bounds.rs:5:10\n    |\n@@ -22,5 +10,17 @@ note: unsafe traits like `Sync` should be implemented explicitly\n LL | #[derive(Sync)]\n    |          ^^^^\n \n+error: cannot find derive macro `Send` in this scope\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Send` should be implemented explicitly\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+\n error: aborting due to 2 previous errors\n "}, {"sha": "f14591c85e62e3a16bbf2ed6e4af74ab02bec521", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,5 +1,5 @@\n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^\n@@ -11,7 +11,7 @@ LL |     #[derive(x3300)]\n    |              ^^^^^\n \n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^"}, {"sha": "c5d9e0db4d389a7acae0dc43eb38e2018ed33662", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,9 +1,6 @@\n // `#![derive]` raises errors when it occurs at contexts other than ADT\n // definitions.\n \n-#![derive(Debug)]\n-//~^ ERROR `derive` may only be applied to structs, enums and unions\n-\n #[derive(Debug)]\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n mod derive {"}, {"sha": "db29a2bddd35c5b7a62c0d2a1962f5fb6eaa4064", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,38 +1,32 @@\n error: `derive` may only be applied to structs, enums and unions\n   --> $DIR/issue-43106-gating-of-derive.rs:4:1\n    |\n-LL | #![derive(Debug)]\n-   | ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n-\n-error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:7:1\n-   |\n LL | #[derive(Debug)]\n    | ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:10:17\n+  --> $DIR/issue-43106-gating-of-derive.rs:7:17\n    |\n LL |     mod inner { #![derive(Debug)] }\n    |                 ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:13:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:10:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:26:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:23:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:30:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:27:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "1102f3c4640a188a3b0adb5785b4a11cc25cdb60", "filename": "src/test/ui/issues/issue-36617.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,3 +1,4 @@\n #![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n \n fn main() {}"}, {"sha": "b5db98f306bd32e10e3e6dc6a04a80e1dd92a14b", "filename": "src/test/ui/issues/issue-36617.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -4,5 +4,13 @@ error: `derive` may only be applied to structs, enums and unions\n LL | #![derive(Copy)]\n    | ^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Copy)]`\n \n-error: aborting due to previous error\n+error: cannot determine resolution for the derive macro `Copy`\n+  --> $DIR/issue-36617.rs:1:11\n+   |\n+LL | #![derive(Copy)]\n+   |           ^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "243cf685e8145649517c8ec07247a751f956867a", "filename": "src/test/ui/proc-macro/derive-helper-configured.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -0,0 +1,18 @@\n+// Derive helpers are resolved successfully inside `cfg_attr`.\n+\n+// check-pass\n+// compile-flats:--cfg TRUE\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[cfg_attr(TRUE, empty_helper)]\n+#[derive(Empty)]\n+#[cfg_attr(TRUE, empty_helper)]\n+struct S {\n+    #[cfg_attr(TRUE, empty_helper)]\n+    field: u8,\n+}\n+\n+fn main() {}"}, {"sha": "21af4093a037de46f187556cfdd07ff63ad53d33", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -19,7 +19,8 @@ struct S {\n         struct U;\n \n         mod inner {\n-            #[empty_helper] //~ ERROR cannot find attribute macro `empty_helper` in this scope\n+            // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n+            #[empty_helper]\n             struct V;\n         }\n "}, {"sha": "2ba517ce29ee743520506c0507dcbb58bfa6dd12", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,9 +1,3 @@\n-error: cannot find attribute macro `empty_helper` in this scope\n-  --> $DIR/derive-helper-shadowing.rs:22:15\n-   |\n-LL |             #[empty_helper]\n-   |               ^^^^^^^^^^^^\n-\n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:8:3\n    |\n@@ -22,6 +16,6 @@ LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "2a5f2b883813d48f71777fb6798be15ce5d0001a", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec45b87957c4158934fc3f5a821594ad0686ea4e/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=ec45b87957c4158934fc3f5a821594ad0686ea4e", "patch": "@@ -1,62 +1,62 @@\n-error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:22:10\n-   |\n-LL | #[derive(FooWithLongNan)]\n-   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n-\n-error: cannot find attribute macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:27:3\n+error: cannot find macro `bang_proc_macrp!` in this scope\n+  --> $DIR/resolve-error.rs:56:5\n    |\n-LL | #[attr_proc_macra]\n-   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+LL |     bang_proc_macrp!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n \n-error: cannot find attribute macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:31:3\n+error: cannot find macro `Dlona!` in this scope\n+  --> $DIR/resolve-error.rs:53:5\n    |\n-LL | #[FooWithLongNan]\n-   |   ^^^^^^^^^^^^^^\n+LL |     Dlona!();\n+   |     ^^^^^\n \n-error: cannot find derive macro `Dlone` in this scope\n-  --> $DIR/resolve-error.rs:34:10\n+error: cannot find macro `attr_proc_macra!` in this scope\n+  --> $DIR/resolve-error.rs:50:5\n    |\n-LL | #[derive(Dlone)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n+LL |     attr_proc_macra!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n \n-error: cannot find derive macro `Dlona` in this scope\n-  --> $DIR/resolve-error.rs:38:10\n+error: cannot find macro `FooWithLongNama!` in this scope\n+  --> $DIR/resolve-error.rs:47:5\n    |\n-LL | #[derive(Dlona)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n+LL |     FooWithLongNama!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:42:10\n    |\n LL | #[derive(attr_proc_macra)]\n    |          ^^^^^^^^^^^^^^^\n \n-error: cannot find macro `FooWithLongNama!` in this scope\n-  --> $DIR/resolve-error.rs:47:5\n+error: cannot find derive macro `Dlona` in this scope\n+  --> $DIR/resolve-error.rs:38:10\n    |\n-LL |     FooWithLongNama!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n+LL | #[derive(Dlona)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n \n-error: cannot find macro `attr_proc_macra!` in this scope\n-  --> $DIR/resolve-error.rs:50:5\n+error: cannot find derive macro `Dlone` in this scope\n+  --> $DIR/resolve-error.rs:34:10\n    |\n-LL |     attr_proc_macra!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n+LL | #[derive(Dlone)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n \n-error: cannot find macro `Dlona!` in this scope\n-  --> $DIR/resolve-error.rs:53:5\n+error: cannot find attribute macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:31:3\n    |\n-LL |     Dlona!();\n-   |     ^^^^^\n+LL | #[FooWithLongNan]\n+   |   ^^^^^^^^^^^^^^\n \n-error: cannot find macro `bang_proc_macrp!` in this scope\n-  --> $DIR/resolve-error.rs:56:5\n+error: cannot find attribute macro `attr_proc_macra` in this scope\n+  --> $DIR/resolve-error.rs:27:3\n    |\n-LL |     bang_proc_macrp!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n+LL | #[attr_proc_macra]\n+   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+\n+error: cannot find derive macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:22:10\n+   |\n+LL | #[derive(FooWithLongNan)]\n+   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n \n error: aborting due to 10 previous errors\n "}]}