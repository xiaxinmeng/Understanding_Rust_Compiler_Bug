{"sha": "1d5108c264bef944c435d4184dfdeb048e6acc2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNTEwOGMyNjRiZWY5NDRjNDM1ZDQxODRkZmRlYjA0OGU2YWNjMmU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T15:04:11Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-21T15:04:11Z"}, "message": "Merge #3437\n\n3437: issue #3318 Run trivially_copy_pass_by_ref for traits r=flip1995 a=waynr\n\nAddresses #3318 \n\nCo-authored-by: Wayne Warren <wayne.warren.s@gmail.com>\nCo-authored-by: Philipp Krones <hello@philkrones.com>", "tree": {"sha": "770f159c9a934163b7b468ac4beea06fae56f1ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/770f159c9a934163b7b468ac4beea06fae56f1ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d5108c264bef944c435d4184dfdeb048e6acc2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5108c264bef944c435d4184dfdeb048e6acc2e", "html_url": "https://github.com/rust-lang/rust/commit/1d5108c264bef944c435d4184dfdeb048e6acc2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d5108c264bef944c435d4184dfdeb048e6acc2e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "dfbc926b704b40011dfd3abe2a29665993a969ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbc926b704b40011dfd3abe2a29665993a969ac", "html_url": "https://github.com/rust-lang/rust/commit/dfbc926b704b40011dfd3abe2a29665993a969ac"}, {"sha": "1fed72bad4a7740cab5b5f607018a089f6d0132a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fed72bad4a7740cab5b5f607018a089f6d0132a", "html_url": "https://github.com/rust-lang/rust/commit/1fed72bad4a7740cab5b5f607018a089f6d0132a"}], "stats": {"total": 217, "additions": 149, "deletions": 68}, "files": [{"sha": "2929752bbb2d13ab22ffe3eaa3dc4f94c6689068", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 91, "deletions": 41, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/1d5108c264bef944c435d4184dfdeb048e6acc2e/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5108c264bef944c435d4184dfdeb048e6acc2e/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=1d5108c264bef944c435d4184dfdeb048e6acc2e", "patch": "@@ -18,12 +18,13 @@ use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use if_chain::if_chain;\n use crate::rustc::ty::TyKind;\n+use crate::rustc::ty::FnSig;\n use crate::rustc::session::config::Config as SessionConfig;\n use crate::rustc_target::spec::abi::Abi;\n use crate::rustc_target::abi::LayoutOf;\n use crate::syntax::ast::NodeId;\n use crate::syntax_pos::Span;\n-use crate::utils::{in_macro, is_copy, is_self, span_lint_and_sugg, snippet};\n+use crate::utils::{in_macro, is_copy, is_self_ty, span_lint_and_sugg, snippet};\n \n /// **What it does:** Checks for functions taking arguments by reference, where\n /// the argument type is `Copy` and small enough to be more efficient to always\n@@ -67,7 +68,7 @@ pub struct TriviallyCopyPassByRef {\n     limit: u64,\n }\n \n-impl TriviallyCopyPassByRef {\n+impl<'a, 'tcx> TriviallyCopyPassByRef {\n     pub fn new(limit: Option<u64>, target: &SessionConfig) -> Self {\n         let limit = limit.unwrap_or_else(|| {\n             let bit_width = target.usize_ty.bit_width().expect(\"usize should have a width\") as u64;\n@@ -80,6 +81,83 @@ impl TriviallyCopyPassByRef {\n         });\n         Self { limit }\n     }\n+\n+    fn check_trait_method(\n+        &mut self,\n+        cx: &LateContext<'_, 'tcx>,\n+        item: &TraitItemRef\n+    ) {\n+        let method_def_id = cx.tcx.hir.local_def_id(item.id.node_id);\n+        let method_sig = cx.tcx.fn_sig(method_def_id);\n+        let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+        let decl = match cx.tcx.hir.fn_decl(item.id.node_id) {\n+            Some(b) => b,\n+            None => return,\n+        };\n+\n+        self.check_poly_fn(cx, &decl, &method_sig, None);\n+    }\n+\n+    fn check_poly_fn(\n+        &mut self,\n+        cx: &LateContext<'_, 'tcx>,\n+        decl: &FnDecl,\n+        sig: &FnSig<'tcx>,\n+        span: Option<Span>,\n+    ) {\n+        // Use lifetimes to determine if we're returning a reference to the\n+        // argument. In that case we can't switch to pass-by-value as the\n+        // argument will not live long enough.\n+        let output_lts = match sig.output().sty {\n+            TyKind::Ref(output_lt, _, _) => vec![output_lt],\n+            TyKind::Adt(_, substs) => substs.regions().collect(),\n+            _ => vec![],\n+        };\n+\n+        for (input, &ty) in decl.inputs.iter().zip(sig.inputs()) {\n+            // All spans generated from a proc-macro invocation are the same...\n+            match span {\n+                Some(s) if s == input.span => return,\n+                _ => (),\n+            }\n+\n+            if_chain! {\n+                if let TyKind::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if !output_lts.contains(&input_lt);\n+                if is_copy(cx, ty);\n+                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                if size <= self.limit;\n+                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n+                then {\n+                    let value_type = if is_self_ty(decl_ty) {\n+                        \"self\".into()\n+                    } else {\n+                        snippet(cx, decl_ty.span, \"_\").into()\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TRIVIALLY_COPY_PASS_BY_REF,\n+                        input.span,\n+                        \"this argument is passed by reference, but would be more efficient if passed by value\",\n+                        \"consider passing by value instead\",\n+                        value_type);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_trait_items(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        trait_items: &[TraitItemRef]\n+    ) {\n+        for item in trait_items {\n+            if let AssociatedItemKind::Method{..} = item.kind {\n+                self.check_trait_method(cx, item);\n+            }\n+        }\n+    }\n }\n \n impl LintPass for TriviallyCopyPassByRef {\n@@ -89,12 +167,21 @@ impl LintPass for TriviallyCopyPassByRef {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if in_macro(item.span) {\n+            return;\n+        }\n+        if let ItemKind::Trait(_, _, _, _, ref trait_items) = item.node {\n+            self.check_trait_items(cx, trait_items);\n+        }\n+    }\n+\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        body: &'tcx Body,\n+        _body: &'tcx Body,\n         span: Span,\n         node_id: NodeId,\n     ) {\n@@ -131,43 +218,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n-        // Use lifetimes to determine if we're returning a reference to the\n-        // argument. In that case we can't switch to pass-by-value as the\n-        // argument will not live long enough.\n-        let output_lts = match fn_sig.output().sty {\n-            TyKind::Ref(output_lt, _, _) => vec![output_lt],\n-            TyKind::Adt(_, substs) => substs.regions().collect(),\n-            _ => vec![],\n-        };\n-\n-        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n-            // All spans generated from a proc-macro invocation are the same...\n-            if span == input.span {\n-                return;\n-            }\n-\n-            if_chain! {\n-                if let TyKind::Ref(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n-                if !output_lts.contains(&input_lt);\n-                if is_copy(cx, ty);\n-                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n-                if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.node;\n-                then {\n-                    let value_type = if is_self(arg) {\n-                        \"self\".into()\n-                    } else {\n-                        snippet(cx, decl_ty.span, \"_\").into()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TRIVIALLY_COPY_PASS_BY_REF,\n-                        input.span,\n-                        \"this argument is passed by reference, but would be more efficient if passed by value\",\n-                        \"consider passing by value instead\",\n-                        value_type);\n-                }\n-            }\n-        }\n+        self.check_poly_fn(cx, decl, &fn_sig, Some(span));\n     }\n }"}, {"sha": "2a0dc22bfef30705af7142772320dbfacfc497e2", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d5108c264bef944c435d4184dfdeb048e6acc2e/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5108c264bef944c435d4184dfdeb048e6acc2e/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=1d5108c264bef944c435d4184dfdeb048e6acc2e", "patch": "@@ -18,6 +18,11 @@ struct Foo(u32);\n #[derive(Copy, Clone)]\n struct Bar([u8; 24]);\n \n+#[derive(Copy, Clone)]\n+pub struct Color {\n+    pub r: u8, pub g: u8, pub b: u8, pub a: u8,\n+}\n+\n struct FooRef<'a> {\n     foo: &'a Foo,\n }\n@@ -80,6 +85,20 @@ impl Bar {\n     }\n }\n \n+trait MyTrait {\n+    fn trait_method(&self, _foo: &Foo);\n+}\n+\n+pub trait MyTrait2 {\n+    fn trait_method2(&self, _color: &Color);\n+}\n+\n+impl MyTrait for Foo {\n+    fn trait_method(&self, _foo: &Foo) {\n+        unimplemented!()\n+    }\n+}\n+\n fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);"}, {"sha": "3fb577d3edbb4cadedb0b9cfbbd517f934f0f16e", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1d5108c264bef944c435d4184dfdeb048e6acc2e/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d5108c264bef944c435d4184dfdeb048e6acc2e/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=1d5108c264bef944c435d4184dfdeb048e6acc2e", "patch": "@@ -1,82 +1,94 @@\n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:52:11\n+  --> $DIR/trivially_copy_pass_by_ref.rs:57:11\n    |\n-52 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+57 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |           ^^^^ help: consider passing by value instead: `u32`\n    |\n    = note: `-D clippy::trivially-copy-pass-by-ref` implied by `-D warnings`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:52:20\n+  --> $DIR/trivially_copy_pass_by_ref.rs:57:20\n    |\n-52 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+57 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                    ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:52:29\n+  --> $DIR/trivially_copy_pass_by_ref.rs:57:29\n    |\n-52 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+57 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                             ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:62:12\n+  --> $DIR/trivially_copy_pass_by_ref.rs:67:12\n    |\n-62 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+67 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |            ^^^^^ help: consider passing by value instead: `self`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:62:22\n+  --> $DIR/trivially_copy_pass_by_ref.rs:67:22\n    |\n-62 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+67 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                      ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:62:31\n+  --> $DIR/trivially_copy_pass_by_ref.rs:67:31\n    |\n-62 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+67 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                               ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:62:40\n+  --> $DIR/trivially_copy_pass_by_ref.rs:67:40\n    |\n-62 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+67 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                                        ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:65:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:16\n    |\n-65 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+70 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:65:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:25\n    |\n-65 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+70 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:65:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:70:34\n    |\n-65 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+70 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:79:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:84:16\n    |\n-79 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+84 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:79:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:84:25\n    |\n-79 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+84 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:79:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:84:34\n    |\n-79 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+84 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n-error: aborting due to 13 previous errors\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:89:34\n+   |\n+89 |     fn trait_method(&self, _foo: &Foo);\n+   |                                  ^^^^ help: consider passing by value instead: `Foo`\n+\n+error: this argument is passed by reference, but would be more efficient if passed by value\n+  --> $DIR/trivially_copy_pass_by_ref.rs:93:37\n+   |\n+93 |     fn trait_method2(&self, _color: &Color);\n+   |                                     ^^^^^^ help: consider passing by value instead: `Color`\n+\n+error: aborting due to 15 previous errors\n "}]}