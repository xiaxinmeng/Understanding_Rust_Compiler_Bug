{"sha": "233ed35e8491c2c08e7320fba3f3bd5519daf58d", "node_id": "C_kwDOAAsO6NoAKDIzM2VkMzVlODQ5MWMyYzA4ZTczMjBmYmEzZjNiZDU1MTlkYWY1OGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-10T18:59:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-10T18:59:18Z"}, "message": "Rollup merge of #108828 - compiler-errors:new-solver-alias-eq-on-num-var, r=lcnr\n\nEmit alias-eq when equating numeric var and projection\n\nThis doesn't fix everything having to do with projections and infer vars, but it does fix a common case I saw in HIR typeck.\n\nr? `@lcnr`", "tree": {"sha": "0426a5625f713a7a03dea598ec42edc3d71398c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0426a5625f713a7a03dea598ec42edc3d71398c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/233ed35e8491c2c08e7320fba3f3bd5519daf58d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkC34GCRBK7hj4Ov3rIwAA05kIAKOL2M6xVVfrYiGWUqOkQLVC\nWp3TPGwiz2+F9ZU81S9pG4QALiMg0fJ3pGvxOHSymynwu/5h82WRGHiE3RZAlK0V\nei7IoQ/6f5Ivj6uh5DsxDVH7FAnhKZg40im5nsZzgG0ljBeIK36m0Zj5ydY0/B0A\nkStsRYpNf0bItlvhpbjveQKKpfTHLSRx+Lg9qOC0drwSBz6E7M7zLGQ8p/wFGW+7\nR7L22yKVUW5H8lkhSPG0EY4qMEuN7aVOqeFk9GOTDMvyQkbXpFkCjBFdhnmr+ZTu\nAGjm1Nu7+uaCSIZTHEA5dpE9WDy3JsC+qUGjAtbPF9GRvadHHV+LcfSr9vlgcbs=\n=fDhJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 0426a5625f713a7a03dea598ec42edc3d71398c5\nparent b90277e37b0ef43b8a3755f027ae29c991172fd0\nparent d4b59a0da25ab72014ee0aaf7f7e647f1682e083\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678474758 +0100\ncommitter GitHub <noreply@github.com> 1678474758 +0100\n\nRollup merge of #108828 - compiler-errors:new-solver-alias-eq-on-num-var, r=lcnr\n\nEmit alias-eq when equating numeric var and projection\n\nThis doesn't fix everything having to do with projections and infer vars, but it does fix a common case I saw in HIR typeck.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/233ed35e8491c2c08e7320fba3f3bd5519daf58d", "html_url": "https://github.com/rust-lang/rust/commit/233ed35e8491c2c08e7320fba3f3bd5519daf58d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/233ed35e8491c2c08e7320fba3f3bd5519daf58d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b90277e37b0ef43b8a3755f027ae29c991172fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90277e37b0ef43b8a3755f027ae29c991172fd0", "html_url": "https://github.com/rust-lang/rust/commit/b90277e37b0ef43b8a3755f027ae29c991172fd0"}, {"sha": "d4b59a0da25ab72014ee0aaf7f7e647f1682e083", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4b59a0da25ab72014ee0aaf7f7e647f1682e083", "html_url": "https://github.com/rust-lang/rust/commit/d4b59a0da25ab72014ee0aaf7f7e647f1682e083"}], "stats": {"total": 183, "additions": 143, "deletions": 40}, "files": [{"sha": "37783bc91bb8c821420e7a73909b2141bb7c858f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -148,10 +148,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_ty,\n                         op,\n                     );\n-                    self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n+                    self.demand_eqtype(expr.span, builtin_return_ty, return_ty);\n+                    builtin_return_ty\n+                } else {\n+                    return_ty\n                 }\n-\n-                return_ty\n             }\n         }\n     }"}, {"sha": "8ac82653c0ee80294cfe7c757793eb6e1ba0b36a", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -411,15 +411,28 @@ impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n-                t,\n-            ),\n-\n-            ty::Infer(ty::FloatVar(_)) => self.canonicalize_ty_var(\n-                CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n-                t,\n-            ),\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Int) },\n+                        t,\n+                    )\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    self.canonicalize_ty_var(\n+                        CanonicalVarInfo { kind: CanonicalVarKind::Ty(CanonicalTyVarKind::Float) },\n+                        t,\n+                    )\n+                }\n+            }\n \n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"encountered a fresh type during canonicalization\")"}, {"sha": "b0613abeb484aea44ad6f1a9bac6664271c77bb5", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -119,20 +119,30 @@ impl<'tcx> InferCtxt<'tcx> {\n                 self.unify_float_variable(!a_is_expected, v_id, v)\n             }\n \n-            // All other cases of inference are errors\n-            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            // We don't expect `TyVar` or `Fresh*` vars at this point with lazy norm.\n+            (\n+                ty::Alias(AliasKind::Projection, _),\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+            )\n+            | (\n+                ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)),\n+                ty::Alias(AliasKind::Projection, _),\n+            ) if self.tcx.trait_solver_next() => {\n+                bug!()\n             }\n \n-            (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n+            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+                if self.tcx.trait_solver_next() =>\n+            {\n                 relation.register_type_equate_obligation(a, b);\n-                Ok(b)\n-            }\n-            (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n-                relation.register_type_equate_obligation(b, a);\n                 Ok(a)\n             }\n \n+            // All other cases of inference are errors\n+            (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n+            }\n+\n             _ => ty::relate::super_relate_tys(relation, a, b),\n         }\n     }"}, {"sha": "4a834957959dbef27b8df1247ed235c198fd1d9f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -1363,6 +1363,28 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow_mut().const_unification_table().find(var)\n     }\n \n+    /// Resolves an int var to a rigid int type, if it was constrained to one,\n+    /// or else the root int var in the unification table.\n+    pub fn opportunistic_resolve_int_var(&self, vid: ty::IntVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.int_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_int_var(inner.int_unification_table().find(vid))\n+        }\n+    }\n+\n+    /// Resolves a float var to a rigid int type, if it was constrained to one,\n+    /// or else the root float var in the unification table.\n+    pub fn opportunistic_resolve_float_var(&self, vid: ty::FloatVid) -> Ty<'tcx> {\n+        let mut inner = self.inner.borrow_mut();\n+        if let Some(value) = inner.float_unification_table().probe_value(vid) {\n+            value.to_type(self.tcx)\n+        } else {\n+            self.tcx.mk_float_var(inner.float_unification_table().find(vid))\n+        }\n+    }\n+\n     /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n     /// are unaffected. If a type/const variable has not been unified, it"}, {"sha": "d9bfacd6e3cf35cf11945661f77d14ab139041f2", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> Term<'tcx> {\n \n     pub fn is_infer(&self) -> bool {\n         match self.unpack() {\n-            TermKind::Ty(ty) => ty.is_ty_or_numeric_infer(),\n+            TermKind::Ty(ty) => ty.is_ty_var(),\n             TermKind::Const(ct) => ct.is_ct_infer(),\n         }\n     }"}, {"sha": "7ee4f33230630d0a55a93f0000985a8301708aa9", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -278,16 +278,16 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                     Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n                 }\n             }\n-            ty::Infer(ty::IntVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::IntVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_int_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {\n                     CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n                 }\n             }\n-            ty::Infer(ty::FloatVar(_)) => {\n-                let nt = self.infcx.shallow_resolve(t);\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                let nt = self.infcx.opportunistic_resolve_float_var(vid);\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {"}, {"sha": "b4f09fbbb04d03806cbc890c692cdb00d1690f3c", "filename": "tests/ui/issues/issue-66667-function-cmp-cycle.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -1,16 +1,19 @@\n fn first() {\n     second == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn second() {\n     first == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn bar() {\n     bar == 1 //~ ERROR binary operation\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "d9a960ce197305ff313fa7b4dc309b1a7675bbc0", "filename": "tests/ui/issues/issue-66667-function-cmp-cycle.stderr", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -15,41 +15,65 @@ LL |     second == 1\n    = note: expected fn item `fn() {second}`\n                  found type `{integer}`\n \n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:2:5\n+   |\n+LL | fn first() {\n+   |            - help: try adding a return type: `-> bool`\n+LL |     second == 1\n+   |     ^^^^^^^^^^^ expected `()`, found `bool`\n+\n error[E0369]: binary operation `==` cannot be applied to type `fn() {first}`\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:7:11\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:11\n    |\n LL |     first == 1\n    |     ----- ^^ - {integer}\n    |     |\n    |     fn() {first}\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:7:14\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:14\n    |\n LL |     first == 1\n    |              ^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() {first}`\n                  found type `{integer}`\n \n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:8:5\n+   |\n+LL | fn second() {\n+   |             - help: try adding a return type: `-> bool`\n+LL |     first == 1\n+   |     ^^^^^^^^^^ expected `()`, found `bool`\n+\n error[E0369]: binary operation `==` cannot be applied to type `fn() {bar}`\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:12:9\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:9\n    |\n LL |     bar == 1\n    |     --- ^^ - {integer}\n    |     |\n    |     fn() {bar}\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-66667-function-cmp-cycle.rs:12:12\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:12\n    |\n LL |     bar == 1\n    |            ^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() {bar}`\n                  found type `{integer}`\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:14:5\n+   |\n+LL | fn bar() {\n+   |          - help: try adding a return type: `-> bool`\n+LL |     bar == 1\n+   |     ^^^^^^^^ expected `()`, found `bool`\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0308, E0369.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "3f7316a2279d3e8ab2cf66b3c8625cef0b34c67b", "filename": "tests/ui/traits/new-solver/canonical-int-var-eq-in-response.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcanonical-int-var-eq-in-response.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+trait Mirror {\n+    type Assoc;\n+}\n+\n+impl<T> Mirror for T {\n+    type Assoc = T;\n+}\n+\n+trait Test {}\n+impl Test for i64 {}\n+impl Test for u64 {}\n+\n+fn mirror_me<T: Mirror>(t: T, s: <T as Mirror>::Assoc) where <T as Mirror>::Assoc: Test {}\n+\n+fn main() {\n+    let mut x = 0;\n+    mirror_me(x, 1);\n+    x = 1i64;\n+}"}, {"sha": "2da387db4a99f9171a120045994bdf4b21ad805c", "filename": "tests/ui/traits/new-solver/int-var-alias-eq.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fint-var-alias-eq.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+// HIR typeck ends up equating `<_#0i as Add>::Output == _#0i`.\n+// Want to make sure that we emit an alias-eq goal for this,\n+// instead of treating it as a type error and bailing.\n+\n+fn test() {\n+    // fallback\n+    let x = 1 + 2;\n+}\n+\n+fn test2() -> u32 {\n+    // expectation from return ty\n+    1 + 2\n+}\n+\n+fn main() {}"}, {"sha": "3b261062f782e6c1d227379a4fbb14d6a566d0b4", "filename": "tests/ui/typeck/lazy-norm/cast-checks-handling-projections.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/233ed35e8491c2c08e7320fba3f3bd5519daf58d/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.rs?ref=233ed35e8491c2c08e7320fba3f3bd5519daf58d", "patch": "@@ -1,5 +1,5 @@\n // compile-flags: -Ztrait-solver=next\n-// known-bug: unknown\n+// check-pass\n \n fn main() {\n     (0u8 + 0u8) as char;"}, {"sha": "6b09ccd52140def0329639a2f6ad5889d8193cbf", "filename": "tests/ui/typeck/lazy-norm/cast-checks-handling-projections.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b90277e37b0ef43b8a3755f027ae29c991172fd0/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b90277e37b0ef43b8a3755f027ae29c991172fd0/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Flazy-norm%2Fcast-checks-handling-projections.stderr?ref=b90277e37b0ef43b8a3755f027ae29c991172fd0", "patch": "@@ -1,9 +0,0 @@\n-error[E0271]: type mismatch resolving `char == <u8 as Add>::Output`\n-  --> $DIR/cast-checks-handling-projections.rs:5:5\n-   |\n-LL |     (0u8 + 0u8) as char;\n-   |     ^^^^^^^^^^^ types differ\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}]}