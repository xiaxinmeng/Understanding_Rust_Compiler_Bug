{"sha": "89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZWVmMGIxMzlmMGQxNjg0NDE1NTQyOWE2NWZjMWFjMmVhNGNkOWY=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-23T23:03:59Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-06-24T04:04:00Z"}, "message": "Create a Digest trait for common methods on digests and convert the SHA-1 implementation to use it.\n\nThe DigestUtil trait was created for helper methods since default methods still have issues.", "tree": {"sha": "facda9cc65eac8682c58e92dfdf484ef80862436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/facda9cc65eac8682c58e92dfdf484ef80862436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "html_url": "https://github.com/rust-lang/rust/commit/89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/comments", "author": null, "committer": null, "parents": [{"sha": "e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb", "html_url": "https://github.com/rust-lang/rust/commit/e1b8c6758099b634ea9033f97ddcd3fa88b5abeb"}], "stats": {"total": 156, "additions": 119, "deletions": 37}, "files": [{"sha": "8fd44bfc9abc46c17c942cb736f8c1faf8179bb4", "filename": "src/libextra/crypto/digest.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::uint;\n+use core::vec;\n+\n+/**\n+ * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+ * family of digest functions.\n+ */\n+pub trait Digest {\n+    /**\n+     * Provide message data.\n+     *\n+     * # Arguments\n+     *\n+     * * input - A vector of message data\n+     */\n+    fn input(&mut self, input: &[u8]);\n+\n+    /**\n+     * Retrieve the digest result. This method may be called multiple times.\n+     */\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /**\n+     * Reset the digest. This method must be called after result() and before supplying more\n+     * data.\n+     */\n+    fn reset(&mut self);\n+\n+    /**\n+     * Get the output size in bits.\n+     */\n+    fn output_bits(&self) -> uint;\n+}\n+\n+fn to_hex(rr: &[u8]) -> ~str {\n+    let mut s = ~\"\";\n+    for rr.iter().advance() |b| {\n+        let hex = uint::to_str_radix(*b as uint, 16u);\n+        if hex.len() == 1 {\n+            s += \"0\";\n+        }\n+        s += hex;\n+    }\n+    return s;\n+}\n+\n+/// Contains utility methods for Digests.\n+/// FIXME: #7339: Convert to default methods when issues with them are resolved.\n+pub trait DigestUtil {\n+    /**\n+     * Convenience functon that feeds a string into a digest\n+     *\n+     * # Arguments\n+     *\n+     * * in The string to feed into the digest\n+     */\n+    fn input_str(&mut self, in: &str);\n+\n+    /**\n+     * Convenience functon that retrieves the result of a digest as a\n+     * ~str in hexadecimal format.\n+     */\n+    fn result_str(&mut self) -> ~str;\n+}\n+\n+impl<D: Digest> DigestUtil for D {\n+    fn input_str(&mut self, in: &str) {\n+        self.input(in.as_bytes());\n+    }\n+\n+    fn result_str(&mut self) -> ~str {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        return to_hex(buf);\n+    }\n+}"}, {"sha": "5a67e08c1900814b6f0b8d2207af2dbd0a7135c2", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "patch": "@@ -24,7 +24,7 @@\n \n use core::prelude::*;\n \n-use core::uint;\n+use digest::Digest;\n \n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n@@ -148,18 +148,17 @@ fn circular_shift(bits: u32, word: u32) -> u32 {\n     return word << bits | word >> 32u32 - bits;\n }\n \n-fn mk_result(st: &mut Sha1) -> ~[u8] {\n+fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n     if !st.computed { pad_msg(st); st.computed = true; }\n-    let mut rs: ~[u8] = ~[];\n+    let mut i = 0;\n     for st.h.mut_iter().advance |ptr_hpart| {\n         let hpart = *ptr_hpart;\n-        let a = (hpart >> 24u32 & 0xFFu32) as u8;\n-        let b = (hpart >> 16u32 & 0xFFu32) as u8;\n-        let c = (hpart >> 8u32 & 0xFFu32) as u8;\n-        let d = (hpart & 0xFFu32) as u8;\n-        rs = vec::append(copy rs, [a, b, c, d]);\n+        rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n+        rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n+        rs[i+2] = (hpart >> 8u32 & 0xFFu32) as u8;\n+        rs[i+3] = (hpart & 0xFFu32) as u8;\n+        i += 4;\n     }\n-    return rs;\n }\n \n /*\n@@ -221,6 +220,9 @@ impl Sha1 {\n         st.reset();\n         return st;\n     }\n+}\n+\n+impl Digest for Sha1 {\n     pub fn reset(&mut self) {\n         self.len_low = 0;\n         self.len_high = 0;\n@@ -233,28 +235,15 @@ impl Sha1 {\n         self.computed = false;\n     }\n     pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n-    pub fn input_str(&mut self, msg: &str) {\n-        add_input(self, msg.as_bytes());\n-    }\n-    pub fn result(&mut self) -> ~[u8] { return mk_result(self); }\n-    pub fn result_str(&mut self) -> ~str {\n-        let rr = mk_result(self);\n-        let mut s = ~\"\";\n-        for rr.iter().advance() |b| {\n-            let hex = uint::to_str_radix(*b as uint, 16u);\n-            if hex.len() == 1 {\n-                s += \"0\";\n-            }\n-            s += hex;\n-        }\n-        return s;\n-    }\n+    pub fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n+    pub fn output_bits(&self) -> uint { 160 }\n }\n \n #[cfg(test)]\n mod tests {\n     use core::vec;\n \n+    use digest::{Digest, DigestUtil};\n     use sha1::Sha1;\n \n     #[test]\n@@ -343,13 +332,15 @@ mod tests {\n \n         // Test that it works when accepting the message all at once\n \n+        let mut out = [0u8, ..20];\n+\n         let mut sh = ~Sha1::new();\n         for tests.iter().advance |t| {\n-            sh.input_str(t.input);\n-            let out = sh.result();\n+            (*sh).input_str(t.input);\n+            sh.result(out);\n             assert!(vec::eq(t.output, out));\n \n-            let out_str = sh.result_str();\n+            let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);\n             assert!(out_str == t.output_str);\n \n@@ -363,13 +354,13 @@ mod tests {\n             let mut left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n+                (*sh).input_str(t.input.slice(len - left, take + len - left));\n                 left = left - take;\n             }\n-            let out = sh.result();\n+            sh.result(out);\n             assert!(vec::eq(t.output, out));\n \n-            let out_str = sh.result_str();\n+            let out_str = (*sh).result_str();\n             assert_eq!(out_str.len(), 40);\n             assert!(out_str == t.output_str);\n "}, {"sha": "dbc3095ae2758ef6f1756cd26407aa93af519f94", "filename": "src/libextra/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "patch": "@@ -87,6 +87,8 @@ pub mod dlist;\n pub mod treemap;\n \n // Crypto\n+#[path=\"crypto/digest.rs\"]\n+pub mod digest;\n #[path=\"crypto/sha1.rs\"]\n pub mod sha1;\n "}, {"sha": "ed675bf99e9dd72dd0da3446c2b729dfc5fea77d", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89eef0b139f0d16844155429a65fc1ac2ea4cd9f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=89eef0b139f0d16844155429a65fc1ac2ea4cd9f", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n \n+use digest::DigestUtil;\n use json;\n use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n@@ -248,16 +249,16 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let mut sha = Sha1::new();\n-    sha.input_str(json_encode(t));\n-    sha.result_str()\n+    let mut sha = ~Sha1::new();\n+    (*sha).input_str(json_encode(t));\n+    (*sha).result_str()\n }\n \n fn digest_file(path: &Path) -> ~str {\n-    let mut sha = Sha1::new();\n+    let mut sha = ~Sha1::new();\n     let s = io::read_whole_file_str(path);\n-    sha.input_str(*s.get_ref());\n-    sha.result_str()\n+    (*sha).input_str(*s.get_ref());\n+    (*sha).result_str()\n }\n \n impl Context {"}]}