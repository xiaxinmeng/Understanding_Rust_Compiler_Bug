{"sha": "37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Y2ZhNzVkNDNjZWNkNWM4MWNiOWQ0YWRiNzc3MTllYTc5NzhhYzQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-09-16T18:40:38Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-09-16T21:55:33Z"}, "message": "Add error codes for librustc_borrowck", "tree": {"sha": "776ee115321563144327d984cbf344fa207cdb40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/776ee115321563144327d984cbf344fa207cdb40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "html_url": "https://github.com/rust-lang/rust/commit/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dfb89067a57949e9b74f6ed4a409d728c1240a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dfb89067a57949e9b74f6ed4a409d728c1240a5", "html_url": "https://github.com/rust-lang/rust/commit/8dfb89067a57949e9b74f6ed4a409d728c1240a5"}], "stats": {"total": 135, "additions": 81, "deletions": 54}, "files": [{"sha": "43e9cdd73c43349237e2d884fa80b0e9fe3b4206", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "patch": "@@ -464,40 +464,36 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as mutable \\\n-                                more than once at a time\",\n-                                nl, new_loan_msg))\n+                    span_err!(self.bccx, new_loan.span, E0499,\n+                              \"cannot borrow `{}`{} as mutable \\\n+                               more than once at a time\",\n+                              nl, new_loan_msg);\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"closure requires unique access to `{}` \\\n-                                but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg));\n+                    span_err!(self.bccx, new_loan.span, E0500,\n+                              \"closure requires unique access to `{}` \\\n+                               but {} is already borrowed{}\",\n+                              nl, ol_pronoun, old_loan_msg);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as {} because \\\n-                                previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()));\n+                    span_err!(self.bccx, new_loan.span, E0501,\n+                              \"cannot borrow `{}`{} as {} because \\\n+                               previous closure requires unique access\",\n+                              nl, new_loan_msg, new_loan.kind.to_user_str());\n                 }\n \n                 (_, _) => {\n-                    self.bccx.span_err(\n-                        new_loan.span,\n-                        &format!(\"cannot borrow `{}`{} as {} because \\\n-                                {} is also borrowed as {}{}\",\n-                                nl,\n-                                new_loan_msg,\n-                                new_loan.kind.to_user_str(),\n-                                ol_pronoun,\n-                                old_loan.kind.to_user_str(),\n-                                old_loan_msg));\n+                    span_err!(self.bccx, new_loan.span, E0502,\n+                              \"cannot borrow `{}`{} as {} because \\\n+                               {} is also borrowed as {}{}\",\n+                              nl,\n+                              new_loan_msg,\n+                              new_loan.kind.to_user_str(),\n+                              ol_pronoun,\n+                              old_loan.kind.to_user_str(),\n+                              old_loan_msg);\n                 }\n             }\n \n@@ -617,11 +613,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                self.bccx.span_err(\n-                    span,\n-                    &format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            &self.bccx.loan_path_to_string(copy_path))\n-                    );\n+                span_err!(self.bccx, span, E0503,\n+                          \"cannot use `{}` because it was mutably borrowed\",\n+                          &self.bccx.loan_path_to_string(copy_path));\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n@@ -642,18 +636,19 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         match self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow) {\n             UseOk => { }\n             UseWhileBorrowed(loan_path, loan_span) => {\n-                let err_message = match move_kind {\n+                match move_kind {\n                     move_data::Captured =>\n-                        format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)),\n+                        span_err!(self.bccx, span, E0504,\n+                                  \"cannot move `{}` into closure because it is borrowed\",\n+                                  &self.bccx.loan_path_to_string(move_path)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n-                        format!(\"cannot move out of `{}` because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path))\n+                        span_err!(self.bccx, span, E0505,\n+                                  \"cannot move out of `{}` because it is borrowed\",\n+                                  &self.bccx.loan_path_to_string(move_path))\n                 };\n \n-                self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n@@ -820,10 +815,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    loan_path: &LoanPath<'tcx>,\n                                    loan: &Loan) {\n-        self.bccx.span_err(\n-            span,\n-            &format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)));\n+        span_err!(self.bccx, span, E0506,\n+                  \"cannot assign to `{}` because it is borrowed\",\n+                  self.bccx.loan_path_to_string(loan_path));\n         self.bccx.span_note(\n             loan.span,\n             &format!(\"borrow of `{}` occurs here\","}, {"sha": "bbcf51933422ea41b9036e6a5b8215f1c7f2abd6", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "patch": "@@ -119,18 +119,18 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n         mc::cat_static_item => {\n-            bccx.span_err(move_from.span,\n-                          &format!(\"cannot move out of {}\",\n-                                  move_from.descriptive_string(bccx.tcx)));\n+            span_err!(bccx, move_from.span, E0507,\n+                      \"cannot move out of {}\",\n+                      move_from.descriptive_string(bccx.tcx));\n         }\n \n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n             let expr = bccx.tcx.map.expect_expr(move_from.id);\n             if let hir::ExprIndex(..) = expr.node {\n-                bccx.span_err(move_from.span,\n-                              &format!(\"cannot move out of type `{}`, \\\n-                                        a non-copy fixed-size array\",\n-                                       b.ty));\n+                span_err!(bccx, move_from.span, E0508,\n+                          \"cannot move out of type `{}`, \\\n+                           a non-copy fixed-size array\",\n+                          b.ty);\n             }\n         }\n \n@@ -139,11 +139,10 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n                 ty::TyEnum(def, _) if def.has_dtor() => {\n-                    bccx.span_err(\n-                        move_from.span,\n-                        &format!(\"cannot move out of type `{}`, \\\n-                                 which defines the `Drop` trait\",\n-                                b.ty));\n+                    span_err!(bccx, move_from.span, E0509,\n+                              \"cannot move out of type `{}`, \\\n+                               which defines the `Drop` trait\",\n+                              b.ty);\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")"}, {"sha": "ede1bb58ce682696729bb4e0e263a34a697ad65b", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cfa75d43cecd5c81cb9d4adb77719ea7978ac4/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=37cfa75d43cecd5c81cb9d4adb77719ea7978ac4", "patch": "@@ -263,12 +263,46 @@ fn mutable() {\n You can read more about cell types in the API documentation:\n \n https://doc.rust-lang.org/std/cell/\n-\"##\n+\"##,\n+\n+E0499: r##\"\n+A variable was borrowed as mutable more than once. Erroneous code example:\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can have as many reference on a variable as you\n+want, but only one can be mutable. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &i;\n+let mut b = &i;\n+let mut c = &i;\n+// ...\n+```\n+\"##,\n \n }\n \n register_diagnostics! {\n     E0385, // {} in an aliasable location\n     E0388, // {} in a static location\n-    E0389  // {} in a `&` reference\n+    E0389, // {} in a `&` reference\n+    E0500, // closure requires unique access to `..` but .. is already borrowed\n+    E0501, // cannot borrow `..`.. as .. because previous closure requires unique access\n+    E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n+    E0503, // cannot use `..` because it was mutably borrowed\n+    E0504, // cannot move `..` into closure because it is borrowed\n+    E0505, // cannot move out of `..` because it is borrowed\n+    E0506, // cannot assign to `..` because it is borrowed\n+    E0507, // cannot move out of ..\n+    E0508, // cannot move out of type `..`, a non-copy fixed-size array\n+    E0509, // cannot move out of type `..`, which defines the `Drop` trait\n }"}]}