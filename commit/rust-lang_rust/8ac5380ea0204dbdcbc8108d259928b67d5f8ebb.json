{"sha": "8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzUzODBlYTAyMDRkYmRjYmM4MTA4ZDI1OTkyOGI2N2Q1ZjhlYmI=", "commit": {"author": {"name": "Konrad Borowski", "email": "konrad@borowski.pw", "date": "2018-12-23T15:47:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-23T15:47:11Z"}, "message": "Merge branch 'master' into copied", "tree": {"sha": "174d912756fc2678af50d46ff457f7504750a975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/174d912756fc2678af50d46ff457f7504750a975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcH63/CRBK7hj4Ov3rIwAAdHIIAArHMVLbf1bdNB18XJKd4R/5\nYD0fWnfk1BHEHumRuZXDgxj6lSqOzKEnkEIBUdUPaA3Od4lkzFcL843LfpVVB7bt\nOUdmU4S2MU2bmDyfltsA17k9qfOWP6FDh5GLRXGS9D/RrGH48B8VxI144B+lcIqz\nzmOPGM08A636cBosxMpIHYubhjYEkUHdoaP1Hv59mnPEgSSf6RHBtER+8SRXFlJN\n5yCEtlvUWrD9UYd3tNwZaddQxDNxH6hVG7sph5s96MXVQA1I7jb6YrQwhsyxg7MR\nMVh0DAp4YoTj2ZlJhAtp0lg1Ja2eGvrYeCa6czAvqB0RDb/TL2TCX5OuI5D955Y=\n=qdIR\n-----END PGP SIGNATURE-----\n", "payload": "tree 174d912756fc2678af50d46ff457f7504750a975\nparent b4a306c1e648c84f289c63e984941b7faad10af1\nparent ddab10a692aab2e2984b5c826ed9d78a57e94851\nauthor Konrad Borowski <konrad@borowski.pw> 1545580031 +0100\ncommitter GitHub <noreply@github.com> 1545580031 +0100\n\nMerge branch 'master' into copied"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "html_url": "https://github.com/rust-lang/rust/commit/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/comments", "author": {"login": "xfix", "id": 1297598, "node_id": "MDQ6VXNlcjEyOTc1OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1297598?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xfix", "html_url": "https://github.com/xfix", "followers_url": "https://api.github.com/users/xfix/followers", "following_url": "https://api.github.com/users/xfix/following{/other_user}", "gists_url": "https://api.github.com/users/xfix/gists{/gist_id}", "starred_url": "https://api.github.com/users/xfix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xfix/subscriptions", "organizations_url": "https://api.github.com/users/xfix/orgs", "repos_url": "https://api.github.com/users/xfix/repos", "events_url": "https://api.github.com/users/xfix/events{/privacy}", "received_events_url": "https://api.github.com/users/xfix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4a306c1e648c84f289c63e984941b7faad10af1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a306c1e648c84f289c63e984941b7faad10af1", "html_url": "https://github.com/rust-lang/rust/commit/b4a306c1e648c84f289c63e984941b7faad10af1"}, {"sha": "ddab10a692aab2e2984b5c826ed9d78a57e94851", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddab10a692aab2e2984b5c826ed9d78a57e94851", "html_url": "https://github.com/rust-lang/rust/commit/ddab10a692aab2e2984b5c826ed9d78a57e94851"}], "stats": {"total": 37344, "additions": 24994, "deletions": 12350}, "files": [{"sha": "70164d48a307bb88bdadb1464ab578ee7836b50d", "filename": ".gitmodules", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -5,9 +5,6 @@\n [submodule \"src/rust-installer\"]\n \tpath = src/tools/rust-installer\n \turl = https://github.com/rust-lang/rust-installer.git\n-[submodule \"src/liblibc\"]\n-\tpath = src/liblibc\n-\turl = https://github.com/rust-lang/libc.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n \turl = https://github.com/rust-lang-nursery/nomicon.git\n@@ -23,9 +20,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang-nursery/rls.git\n-[submodule \"src/libcompiler_builtins\"]\n-\tpath = src/libcompiler_builtins\n-\turl = https://github.com/rust-lang-nursery/compiler-builtins.git\n [submodule \"src/tools/clippy\"]\n \tpath = src/tools/clippy\n \turl = https://github.com/rust-lang-nursery/rust-clippy.git\n@@ -35,9 +29,6 @@\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/solson/miri.git\n-[submodule \"src/dlmalloc\"]\n-\tpath = src/dlmalloc\n-\turl = https://github.com/alexcrichton/dlmalloc-rs.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example.git\n@@ -61,7 +52,6 @@\n \tpath = src/tools/clang\n \turl = https://github.com/rust-lang-nursery/clang.git\n \tbranch = rust-release-80-v2\n-\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git"}, {"sha": "9e46e6b8ef6b15a39e7d2b472befb604b5ad2e06", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,7 +16,7 @@ matrix:\n   fast_finish: true\n   include:\n     # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-5.0 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-gnu-llvm-6.0 RUST_BACKTRACE=1\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1"}, {"sha": "65cdfe67b5b08a83dead3ea6b2da7ebd1a80df14", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -39,7 +39,7 @@ don't know about, so please report liberally. If you're not sure if something\n is a bug or not, feel free to file a bug anyway.\n \n **If you believe reporting your bug publicly represents a security risk to Rust users,\n-please follow our [instructions for reporting security vulnerabilities](https://www.rust-lang.org/security.html)**.\n+please follow our [instructions for reporting security vulnerabilities](https://www.rust-lang.org/policies/security)**.\n \n If you have the chance, before reporting a bug, please [search existing\n issues](https://github.com/rust-lang/rust/search?q=&type=Issues&utf8=%E2%9C%93),"}, {"sha": "365d14c579bdb2463345152758cd2da5e4ab7c90", "filename": "Cargo.lock", "status": "modified", "additions": 782, "deletions": 669, "changes": 1451, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb"}, {"sha": "667c55791bd171dbe31735a7af288a6eba308563", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -65,6 +65,10 @@ rustfmt-nightly = { path = \"src/tools/rustfmt\" }\n # here\n rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n \n+# See comments in `tools/rustc-std-workspace-core/README.md` for what's going on\n+# here\n+rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n+\n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }\n rustc_tools_util = { path = \"src/tools/clippy/rustc_tools_util\" }"}, {"sha": "dc013a1ad2be66985b47fc5d0a8313cdd1169bed", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,7 +10,7 @@ standard library, and documentation.\n \n Read [\"Installation\"] from [The Book].\n \n-[\"Installation\"]: https://doc.rust-lang.org/book/second-edition/ch01-01-installation.html\n+[\"Installation\"]: https://doc.rust-lang.org/book/ch01-01-installation.html\n [The Book]: https://doc.rust-lang.org/book/index.html\n \n ## Building from Source"}, {"sha": "7022a86a45c5b611fa3c9f1671fca5d8084c7ee5", "filename": "RELEASES.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1,3 +1,14 @@\n+Version 1.31.1 (2018-12-20)\n+===========================\n+\n+- [Fix Rust failing to build on `powerpc-unknown-netbsd`][56562]\n+- [Fix broken go-to-definition in RLS][rls/1171]\n+- [Fix infinite loop on hover in RLS][rls/1170]\n+\n+[56562]: https://github.com/rust-lang/rust/pull/56562\n+[rls/1171]: https://github.com/rust-lang/rls/issues/1171\n+[rls/1170]: https://github.com/rust-lang/rls/pull/1170\n+\n Version 1.31.0 (2018-12-06)\n ==========================\n "}, {"sha": "0f7b6c22e1cc52ff8632881b195b831f8d4d3aca", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"bootstrap\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"bootstrap\""}, {"sha": "09c87fdd1a84c7fd90e29eb9c34b5532126f961b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -678,10 +678,10 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         print(\"Updating submodule\", module)\n \n-        run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n+        run([\"git\", \"submodule\", \"-q\", \"sync\", \"--progress\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"submodule\", \"update\",\n-            \"--init\", \"--recursive\", module],\n+            \"--init\", \"--recursive\", \"--progress\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)"}, {"sha": "405fc871eef76e6f22763c3b510261a9d134f80d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,20 +21,20 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n-use cache::{Cache, Interned, INTERNER};\n-use check;\n-use compile;\n-use dist;\n-use doc;\n-use flags::Subcommand;\n-use install;\n-use native;\n-use test;\n-use tool;\n-use util::{add_lib_path, exe, libdir};\n-use {Build, DocTests, Mode, GitRepo};\n-\n-pub use Compiler;\n+use crate::cache::{Cache, Interned, INTERNER};\n+use crate::check;\n+use crate::compile;\n+use crate::dist;\n+use crate::doc;\n+use crate::flags::Subcommand;\n+use crate::install;\n+use crate::native;\n+use crate::test;\n+use crate::tool;\n+use crate::util::{add_lib_path, exe, libdir};\n+use crate::{Build, DocTests, Mode, GitRepo};\n+\n+pub use crate::Compiler;\n \n use petgraph::graph::NodeIndex;\n use petgraph::Graph;\n@@ -389,7 +389,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::RunPassFullDeps,\n                 test::RunFailFullDeps,\n-                test::CompileFailFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n                 test::RunPassPretty,\n@@ -417,6 +416,7 @@ impl<'a> Builder<'a> {\n                 test::Rustfmt,\n                 test::Miri,\n                 test::Clippy,\n+                test::CompiletestTest,\n                 test::RustdocJS,\n                 test::RustdocTheme,\n                 // Run bootstrap close to the end as it's unlikely to fail\n@@ -685,6 +685,11 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n             .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n             .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+\n+        // Remove make-related flags that can cause jobserver problems.\n+        cmd.env_remove(\"MAKEFLAGS\");\n+        cmd.env_remove(\"MFLAGS\");\n+\n         if let Some(linker) = self.linker(host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n@@ -793,7 +798,7 @@ impl<'a> Builder<'a> {\n         }\n \n         // Set a flag for `check` so that certain build scripts can do less work\n-        // (e.g. not building/requiring LLVM).\n+        // (e.g., not building/requiring LLVM).\n         if cmd == \"check\" {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n@@ -923,12 +928,12 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n-            // then other crates can depend on the compiler (e.g. proc-macro\n+            // then other crates can depend on the compiler (e.g., proc-macro\n             // crates). Let's say, for example that rustc itself depends on the\n             // bitflags crate. If an external crate then depends on the\n             // bitflags crate as well, we need to make sure they don't\n             // conflict, even if they pick the same version of bitflags. We'll\n-            // want to make sure that e.g. a plugin and rustc each get their\n+            // want to make sure that e.g., a plugin and rustc each get their\n             // own copy of bitflags.\n \n             // Cargo ensures that this works in general through the -C metadata\n@@ -1247,7 +1252,7 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod __test {\n     use super::*;\n-    use config::Config;\n+    use crate::config::Config;\n     use std::thread;\n \n     fn configure(host: &[&str], target: &[&str]) -> Config {"}, {"sha": "165cffa4587d370bbddf7567c5509c566e480605", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -23,7 +23,7 @@ use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n use std::cmp::{PartialOrd, Ord, Ordering};\n \n-use builder::Step;\n+use crate::builder::Step;\n \n pub struct Interned<T>(usize, PhantomData<*const T>);\n "}, {"sha": "3307d9d3573c2b52670c73e1f369ae0fe51d2e75", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -39,9 +39,9 @@ use std::process::Command;\n use build_helper::output;\n use cc;\n \n-use {Build, GitRepo};\n-use config::Target;\n-use cache::Interned;\n+use crate::{Build, GitRepo};\n+use crate::config::Target;\n+use crate::cache::Interned;\n \n // The `cc` crate doesn't provide a way to obtain a path to the detected archiver,\n // so use some simplified logic here. First we respect the environment variable `AR`, then\n@@ -143,7 +143,10 @@ fn set_compiler(cfg: &mut cc::Build,\n         // compiler already takes into account the triple in question.\n         t if t.contains(\"android\") => {\n             if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n-                let target = target.replace(\"armv7\", \"arm\");\n+                let target = target.replace(\"armv7neon\", \"arm\")\n+                                   .replace(\"armv7\", \"arm\")\n+                                   .replace(\"thumbv7neon\", \"arm\")\n+                                   .replace(\"thumbv7\", \"arm\");\n                 let compiler = format!(\"{}-{}\", target, compiler.clang());\n                 cfg.compiler(ndk.join(\"bin\").join(compiler));\n             }"}, {"sha": "8756ec944c25704da8a5dc9e3a3a00aa6c61e7b6", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -20,11 +20,11 @@ use std::process::Command;\n \n use build_helper::output;\n \n-use Build;\n-use config::Config;\n+use crate::Build;\n+use crate::config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.32.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.33.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "84e7c40e4559e479a94d2b71257ea0bc9fdff3c3", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,11 +10,12 @@\n \n //! Implementation of compiling the compiler and standard library, in \"check\" mode.\n \n-use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env, add_to_sysroot};\n-use builder::{RunConfig, Builder, ShouldRun, Step};\n-use tool::{prepare_tool_cargo, SourceType};\n-use {Compiler, Mode};\n-use cache::{INTERNER, Interned};\n+use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n+                     add_to_sysroot};\n+use crate::builder::{RunConfig, Builder, ShouldRun, Step};\n+use crate::tool::{prepare_tool_cargo, SourceType};\n+use crate::{Compiler, Mode};\n+use crate::cache::{INTERNER, Interned};\n use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "dc42159d068b1e6bff46bfed57290fc5fc716d15", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,7 +19,7 @@ use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n-use Build;\n+use crate::Build;\n \n pub fn clean(build: &Build, all: bool) {\n     rm_rf(\"tmp\".as_ref());"}, {"sha": "61a04b97206029fbb3679f7e17358dc893456bb5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,7 +18,7 @@\n \n use std::borrow::Cow;\n use std::env;\n-use std::fs::{self, File};\n+use std::fs;\n use std::io::BufReader;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n@@ -29,12 +29,12 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib};\n-use {Compiler, Mode, GitRepo};\n-use native;\n+use crate::util::{exe, libdir, is_dylib};\n+use crate::{Compiler, Mode, GitRepo};\n+use crate::native;\n \n-use cache::{INTERNER, Interned};\n-use builder::{Step, RunConfig, ShouldRun, Builder};\n+use crate::cache::{INTERNER, Interned};\n+use crate::builder::{Step, RunConfig, ShouldRun, Builder};\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n@@ -152,11 +152,12 @@ pub fn std_cargo(builder: &Builder,\n \n     if builder.no_std(target) == Some(true) {\n         // for no-std targets we only compile a few no_std crates\n-        cargo.arg(\"--features\").arg(\"c mem\")\n+        cargo\n             .args(&[\"-p\", \"alloc\"])\n-            .args(&[\"-p\", \"compiler_builtins\"])\n             .arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/liballoc/Cargo.toml\"))\n+            .arg(\"--features\")\n+            .arg(\"compiler-builtins-mem\");\n     } else {\n         let features = builder.std_features();\n \n@@ -707,7 +708,7 @@ impl Step for CodegenBackend {\n         }\n         let stamp = codegen_backend_stamp(builder, compiler, target, backend);\n         let codegen_backend = codegen_backend.to_str().unwrap();\n-        t!(t!(File::create(&stamp)).write_all(codegen_backend.as_bytes()));\n+        t!(fs::write(&stamp, &codegen_backend));\n     }\n }\n \n@@ -796,8 +797,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n \n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(builder, compiler, target, *backend);\n-        let mut dylib = String::new();\n-        t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n+        let dylib = t!(fs::read_to_string(&stamp));\n         let file = Path::new(&dylib);\n         let filename = file.file_name().unwrap().to_str().unwrap();\n         // change `librustc_codegen_llvm-xxxxxx.so` to `librustc_codegen_llvm-llvm.so`\n@@ -1137,10 +1137,7 @@ pub fn run_cargo(builder: &Builder,\n     // contents (the list of files to copy) is different or if any dep's mtime\n     // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let mut stamp_contents = Vec::new();\n-    if let Ok(mut f) = File::open(stamp) {\n-        t!(f.read_to_end(&mut stamp_contents));\n-    }\n+    let stamp_contents = fs::read(stamp);\n     let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n     let mut max = None;\n@@ -1156,7 +1153,10 @@ pub fn run_cargo(builder: &Builder,\n     }\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n-    if stamp_contents == new_contents && max <= stamp_mtime {\n+    let contents_equal = stamp_contents\n+        .map(|contents| contents == new_contents)\n+        .unwrap_or_default();\n+    if contents_equal && max <= stamp_mtime {\n         builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n         return deps\n@@ -1166,7 +1166,7 @@ pub fn run_cargo(builder: &Builder,\n     } else {\n         builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n-    t!(t!(File::create(stamp)).write_all(&new_contents));\n+    t!(fs::write(&stamp, &new_contents));\n     deps\n }\n "}, {"sha": "2ae9da9c085d4397811f30051d9cd8ee5879d26e", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,17 +15,16 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n use num_cpus;\n use toml;\n-use cache::{INTERNER, Interned};\n-use flags::Flags;\n-pub use flags::Subcommand;\n+use crate::cache::{INTERNER, Interned};\n+use crate::flags::Flags;\n+pub use crate::flags::Subcommand;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -416,9 +415,7 @@ impl Config {\n         config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n         let toml = file.map(|file| {\n-            let mut f = t!(File::open(&file));\n-            let mut contents = String::new();\n-            t!(f.read_to_string(&mut contents));\n+            let contents = t!(fs::read_to_string(&file));\n             match toml::from_str(&contents) {\n                 Ok(table) => table,\n                 Err(err) => {"}, {"sha": "f2473cb9eda6bdab99b3fb04e78019a531ebaa8b", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -107,6 +107,8 @@ def v(*args):\n   \"arm-linux-androideabi NDK standalone path\")\n v(\"armv7-linux-androideabi-ndk\", \"target.armv7-linux-androideabi.android-ndk\",\n   \"armv7-linux-androideabi NDK standalone path\")\n+v(\"thumbv7neon-linux-androideabi-ndk\", \"target.thumbv7neon-linux-androideabi.android-ndk\",\n+  \"thumbv7neon-linux-androideabi NDK standalone path\")\n v(\"aarch64-linux-android-ndk\", \"target.aarch64-linux-android.android-ndk\",\n   \"aarch64-linux-android NDK standalone path\")\n v(\"x86_64-linux-android-ndk\", \"target.x86_64-linux-android.android-ndk\","}, {"sha": "927f9bf8ddbca36ce57320793902ae916c95b518", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,20 +19,20 @@\n //! pieces of `rustup.rs`!\n \n use std::env;\n-use std::fs::{self, File};\n-use std::io::{Read, Write};\n+use std::fs;\n+use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n-use {Compiler, Mode, LLVM_TOOLS};\n-use channel;\n-use util::{libdir, is_dylib, exe};\n-use builder::{Builder, RunConfig, ShouldRun, Step};\n-use compile;\n-use tool::{self, Tool};\n-use cache::{INTERNER, Interned};\n+use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::channel;\n+use crate::util::{libdir, is_dylib, exe};\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::compile;\n+use crate::tool::{self, Tool};\n+use crate::cache::{INTERNER, Interned};\n use time;\n \n pub fn pkgname(builder: &Builder, component: &str) -> String {\n@@ -353,7 +353,7 @@ impl Step for Mingw {\n     /// Build the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n-    /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n+    /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let host = self.host;\n \n@@ -857,12 +857,9 @@ impl Step for Src {\n         // (essentially libstd and all of its path dependencies)\n         let std_src_dirs = [\n             \"src/build_helper\",\n-            \"src/dlmalloc\",\n             \"src/liballoc\",\n             \"src/libbacktrace\",\n-            \"src/libcompiler_builtins\",\n             \"src/libcore\",\n-            \"src/liblibc\",\n             \"src/libpanic_abort\",\n             \"src/libpanic_unwind\",\n             \"src/librustc_asan\",\n@@ -871,20 +868,15 @@ impl Step for Src {\n             \"src/librustc_tsan\",\n             \"src/libstd\",\n             \"src/libunwind\",\n-            \"src/rustc/compiler_builtins_shim\",\n-            \"src/rustc/libc_shim\",\n-            \"src/rustc/dlmalloc_shim\",\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/libprofiler_builtins\",\n             \"src/stdsimd\",\n             \"src/libproc_macro\",\n-        ];\n-        let std_src_dirs_exclude = [\n-            \"src/libcompiler_builtins/compiler-rt/test\",\n+            \"src/tools/rustc-std-workspace-core\",\n         ];\n \n-        copy_src_dirs(builder, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n+        copy_src_dirs(builder, &std_src_dirs[..], &[], &dst_src);\n         for file in src_files.iter() {\n             builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }\n@@ -908,7 +900,7 @@ impl Step for Src {\n     }\n }\n \n-const CARGO_VENDOR_VERSION: &str = \"0.1.19\";\n+const CARGO_VENDOR_VERSION: &str = \"0.1.22\";\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n@@ -1510,8 +1502,7 @@ impl Step for Extended {\n         }\n \n         let xform = |p: &Path| {\n-            let mut contents = String::new();\n-            t!(t!(File::open(p)).read_to_string(&mut contents));\n+            let mut contents = t!(fs::read_to_string(p));\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n@@ -1522,8 +1513,8 @@ impl Step for Extended {\n                 contents = filter(&contents, \"rustfmt\");\n             }\n             let ret = tmp.join(p.file_name().unwrap());\n-            t!(t!(File::create(&ret)).write_all(contents.as_bytes()));\n-            return ret\n+            t!(fs::write(&ret, &contents));\n+            ret\n         };\n \n         if target.contains(\"apple-darwin\") {\n@@ -1868,8 +1859,7 @@ impl Step for HashSign {\n         let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n         });\n-        let mut pass = String::new();\n-        t!(t!(File::open(&file)).read_to_string(&mut pass));\n+        let pass = t!(fs::read_to_string(&file));\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n "}, {"sha": "217328adfbf66403925f23a05a112ef6916a0667", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,20 +18,19 @@\n //! `rustdoc`.\n \n use std::collections::HashSet;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use Mode;\n+use crate::Mode;\n use build_helper::up_to_date;\n \n-use util::symlink_dir;\n-use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n-use tool::{self, prepare_tool_cargo, Tool, SourceType};\n-use compile;\n-use cache::{INTERNER, Interned};\n-use config::Config;\n+use crate::util::symlink_dir;\n+use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n+use crate::tool::{self, prepare_tool_cargo, Tool, SourceType};\n+use crate::compile;\n+use crate::cache::{INTERNER, Interned};\n+use crate::config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -379,12 +378,11 @@ impl Step for Standalone {\n         let version_info = out.join(\"version_info.html\");\n \n         if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n-            let mut info = String::new();\n-            t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-            let info = info.replace(\"VERSION\", &builder.rust_release())\n-                           .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n-                           .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n-            t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n+            let info = t!(fs::read_to_string(&version_input))\n+                .replace(\"VERSION\", &builder.rust_release())\n+                .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n+                .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n+            t!(fs::write(&version_info, &info));\n         }\n \n         for file in t!(fs::read_dir(builder.src.join(\"src/doc\"))) {\n@@ -697,9 +695,6 @@ impl Step for Rustc {\n             return;\n         }\n \n-        // Build libstd docs so that we generate relative links.\n-        builder.ensure(Std { stage, target });\n-\n         // Build rustc.\n         builder.ensure(compile::Rustc { compiler, target });\n \n@@ -718,12 +713,16 @@ impl Step for Rustc {\n \n         // Find dependencies for top level crates.\n         let mut compiler_crates = HashSet::new();\n-        for root_crate in &[\"rustc\", \"rustc_driver\", \"rustc_codegen_llvm\"] {\n+        for root_crate in &[\"rustc_driver\", \"rustc_codegen_llvm\", \"rustc_codegen_ssa\"] {\n             let interned_root_crate = INTERNER.intern_str(root_crate);\n             find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n         }\n \n         for krate in &compiler_crates {\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n@@ -797,8 +796,8 @@ impl Step for Rustdoc {\n             return;\n         }\n \n-        // Build libstd docs so that we generate relative links.\n-        builder.ensure(Std { stage, target });\n+        // Build rustc docs so that we generate relative links.\n+        builder.ensure(Rustc { stage, target });\n \n         // Build rustdoc.\n         builder.ensure(tool::Rustdoc { host: compiler.host });\n@@ -822,6 +821,10 @@ impl Step for Rustdoc {\n             &[]\n         );\n \n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+        cargo.arg(\"-p\").arg(\"rustdoc\");\n+\n         cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         builder.run(&mut cargo);\n     }"}, {"sha": "14e2f69432dac21d96753c6e1eeb1d78cb0b1591", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,12 +19,12 @@ use std::process;\n \n use getopts::Options;\n \n-use builder::Builder;\n-use config::Config;\n-use metadata;\n-use {Build, DocTests};\n+use crate::builder::Builder;\n+use crate::config::Config;\n+use crate::metadata;\n+use crate::{Build, DocTests};\n \n-use cache::{Interned, INTERNER};\n+use crate::cache::{Interned, INTERNER};\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n@@ -121,11 +121,11 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\",\n-            \"stage to build (indicates compiler to use/test, e.g. stage 0 uses the \\\n+            \"stage to build (indicates compiler to use/test, e.g., stage 0 uses the \\\n              bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n             \"N\");\n         opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling \\\n-            (pass multiple times to keep e.g. both stages 0 and 1)\", \"N\");\n+            (pass multiple times to keep e.g., both stages 0 and 1)\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");"}, {"sha": "aebcfb4519543abbea8e271b402f66a807c3fbb9", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,11 +18,11 @@ use std::fs;\n use std::path::{Path, PathBuf, Component};\n use std::process::Command;\n \n-use dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n \n-use builder::{Builder, RunConfig, ShouldRun, Step};\n-use cache::Interned;\n-use config::Config;\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::cache::Interned;\n+use crate::config::Config;\n \n pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));"}, {"sha": "a9da2c491da53992774affa8f2c2d63660e027ca", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,7 +10,7 @@\n \n //! Job management on Windows for bootstrapping\n //!\n-//! Most of the time when you're running a build system (e.g. make) you expect\n+//! Most of the time when you're running a build system (e.g., make) you expect\n //! Ctrl-C or abnormal termination to actually terminate the entire tree of\n //! process in play, not just the one at the top. This currently works \"by\n //! default\" on Unix platforms because Ctrl-C actually sends a signal to the\n@@ -42,7 +42,7 @@\n use std::env;\n use std::io;\n use std::mem;\n-use Build;\n+use crate::Build;\n \n type HANDLE = *mut u8;\n type BOOL = i32;\n@@ -162,11 +162,11 @@ pub unsafe fn setup(build: &mut Build) {\n         return\n     }\n \n-    // If we've got a parent process (e.g. the python script that called us)\n+    // If we've got a parent process (e.g., the python script that called us)\n     // then move ownership of this job object up to them. That way if the python\n-    // script is killed (e.g. via ctrl-c) then we'll all be torn down.\n+    // script is killed (e.g., via ctrl-c) then we'll all be torn down.\n     //\n-    // If we don't have a parent (e.g. this was run directly) then we\n+    // If we don't have a parent (e.g., this was run directly) then we\n     // intentionally leak the job object handle. When our process exits\n     // (normally or abnormally) it will close the handle implicitly, causing all\n     // processes in the job to be cleaned up.\n@@ -184,7 +184,7 @@ pub unsafe fn setup(build: &mut Build) {\n \n     // If this failed, well at least we tried! An example of DuplicateHandle\n     // failing in the past has been when the wrong python2 package spawned this\n-    // build system (e.g. the `python2` package in MSYS instead of\n+    // build system (e.g., the `python2` package in MSYS instead of\n     // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n     // mode\" here is that we only clean everything up when the build system\n     // dies, not when the python parent does, so not too bad."}, {"sha": "c5b8f19eee6fb0b27a41c2c010cffaf7729b52b1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -38,7 +38,7 @@\n //! However, compiletest itself tries to avoid running tests when the artifacts\n //! that are involved (mainly the compiler) haven't changed.\n //!\n-//! When you execute `x.py build`, the steps which are executed are:\n+//! When you execute `x.py build`, the steps executed are:\n //!\n //! * First, the python script is run. This will automatically download the\n //!   stage0 rustc and cargo according to `src/stage0.txt`, or use the cached\n@@ -159,7 +159,7 @@ use std::os::windows::fs::symlink_file;\n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n use filetime::FileTime;\n \n-use util::{exe, libdir, OutputFolder, CiEnv};\n+use crate::util::{exe, libdir, OutputFolder, CiEnv};\n \n mod cc_detect;\n mod channel;\n@@ -188,7 +188,7 @@ mod job;\n mod job {\n     use libc;\n \n-    pub unsafe fn setup(build: &mut ::Build) {\n+    pub unsafe fn setup(build: &mut crate::Build) {\n         if build.config.low_priority {\n             libc::setpriority(libc::PRIO_PGRP as _, 0, 10);\n         }\n@@ -197,14 +197,14 @@ mod job {\n \n #[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n mod job {\n-    pub unsafe fn setup(_build: &mut ::Build) {\n+    pub unsafe fn setup(_build: &mut crate::Build) {\n     }\n }\n \n-pub use config::Config;\n-use flags::Subcommand;\n-use cache::{Interned, INTERNER};\n-use toolstate::ToolState;\n+pub use crate::config::Config;\n+use crate::flags::Subcommand;\n+use crate::cache::{Interned, INTERNER};\n+use crate::toolstate::ToolState;\n \n const LLVM_TOOLS: &[&str] = &[\n     \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n@@ -1067,9 +1067,8 @@ impl Build {\n \n     /// Returns the `a.b.c` version that the given package is at.\n     fn release_num(&self, package: &str) -> String {\n-        let mut toml = String::new();\n         let toml_file_name = self.src.join(&format!(\"src/tools/{}/Cargo.toml\", package));\n-        t!(t!(File::open(toml_file_name)).read_to_string(&mut toml));\n+        let toml = t!(fs::read_to_string(&toml_file_name));\n         for line in toml.lines() {\n             let prefix = \"version = \\\"\";\n             let suffix = \"\\\"\";\n@@ -1135,10 +1134,10 @@ impl Build {\n             let krate = &self.crates[&krate];\n             if krate.is_local(self) {\n                 ret.push(krate);\n-                for dep in &krate.deps {\n-                    if visited.insert(dep) && dep != \"build_helper\" {\n-                        list.push(*dep);\n-                    }\n+            }\n+            for dep in &krate.deps {\n+                if visited.insert(dep) && dep != \"build_helper\" {\n+                    list.push(*dep);\n                 }\n             }\n         }\n@@ -1151,8 +1150,7 @@ impl Build {\n         }\n \n         let mut paths = Vec::new();\n-        let mut contents = Vec::new();\n-        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        let contents = t!(fs::read(stamp));\n         // This is the method we use for extracting paths from the stamp file passed to us. See\n         // run_cargo for more information (in compile.rs).\n         for part in contents.split(|b| *b == 0) {"}, {"sha": "bb503e8b8d3d1bf8d6bb1bd145297312af3903a2", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,8 +16,8 @@ use std::collections::HashSet;\n use build_helper::output;\n use serde_json;\n \n-use {Build, Crate};\n-use cache::INTERNER;\n+use crate::{Build, Crate};\n+use crate::cache::INTERNER;\n \n #[derive(Deserialize)]\n struct Output {"}, {"sha": "d9f51f6fd3d070315eb47323809d89fc9dd16c58", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,19 +21,18 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n-use std::io::{Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::output;\n use cmake;\n use cc;\n \n-use util::{self, exe};\n+use crate::util::{self, exe};\n use build_helper::up_to_date;\n-use builder::{Builder, RunConfig, ShouldRun, Step};\n-use cache::Interned;\n-use GitRepo;\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::cache::Interned;\n+use crate::GitRepo;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n@@ -75,8 +74,7 @@ impl Step for Llvm {\n         }\n \n         let rebuild_trigger = builder.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n-        let mut rebuild_trigger_contents = String::new();\n-        t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n+        let rebuild_trigger_contents = t!(fs::read_to_string(&rebuild_trigger));\n \n         let (out_dir, llvm_config_ret_dir) = if emscripten {\n             let dir = builder.emscripten_llvm_out(target);\n@@ -93,8 +91,7 @@ impl Step for Llvm {\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         if done_stamp.exists() {\n-            let mut done_contents = String::new();\n-            t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n+            let done_contents = t!(fs::read_to_string(&done_stamp));\n \n             // If LLVM was already built previously and contents of the rebuild-trigger file\n             // didn't change from the previous build, then no action is required.\n@@ -251,7 +248,7 @@ impl Step for Llvm {\n         configure_cmake(builder, target, &mut cfg, false);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n-        //        libraries here, e.g. we just want a few components and a few\n+        //        libraries here, e.g., we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n \n@@ -261,7 +258,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n+        t!(fs::write(&done_stamp, &rebuild_trigger_contents));\n \n         build_llvm_config\n     }\n@@ -281,11 +278,11 @@ fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n     let mut parts = version.split('.').take(2)\n         .filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 5 {\n+        if major >= 6 {\n             return\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=5.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=6.0\\n\\n\", version)\n }\n \n fn configure_cmake(builder: &Builder,"}, {"sha": "f585495b0aa947f573a11ccc16875411032b5d80", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,14 +21,13 @@\n use std::collections::HashMap;\n use std::env;\n use std::ffi::{OsString, OsStr};\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs;\n use std::path::PathBuf;\n use std::process::Command;\n \n use build_helper::output;\n \n-use Build;\n+use crate::Build;\n \n struct Finder {\n     cache: HashMap<OsString, Option<PathBuf>>,\n@@ -235,9 +234,7 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     }\n \n     if build.config.channel == \"stable\" {\n-        let mut stage0 = String::new();\n-        t!(t!(File::open(build.src.join(\"src/stage0.txt\")))\n-            .read_to_string(&mut stage0));\n+        let stage0 = t!(fs::read_to_string(build.src.join(\"src/stage0.txt\")));\n         if stage0.contains(\"\\ndev:\") {\n             panic!(\"bootstrapping from a dev compiler in a stable release, but \\\n                     should only be bootstrapping from a released compiler!\");"}, {"sha": "11932d58ceac623011357f60652b4a15f26a2cea", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,25 +16,24 @@\n use std::env;\n use std::ffi::OsString;\n use std::fmt;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::{self, output};\n \n-use builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n-use cache::{Interned, INTERNER};\n-use compile;\n-use dist;\n-use flags::Subcommand;\n-use native;\n-use tool::{self, Tool, SourceType};\n-use toolstate::ToolState;\n-use util::{self, dylib_path, dylib_path_var};\n-use Crate as CargoCrate;\n-use {DocTests, Mode, GitRepo};\n+use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n+use crate::cache::{Interned, INTERNER};\n+use crate::compile;\n+use crate::dist;\n+use crate::flags::Subcommand;\n+use crate::native;\n+use crate::tool::{self, Tool, SourceType};\n+use crate::toolstate::ToolState;\n+use crate::util::{self, dylib_path, dylib_path_var};\n+use crate::Crate as CargoCrate;\n+use crate::{DocTests, Mode, GitRepo};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -430,6 +429,45 @@ impl Step for Miri {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CompiletestTest {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for CompiletestTest {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/compiletest\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(CompiletestTest {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for compiletest.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolBootstrap,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/compiletest\",\n+                                                 SourceType::InTree,\n+                                                 &[]);\n+\n+        try_run(builder, &mut cargo);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Clippy {\n     stage: u32,\n@@ -578,7 +616,7 @@ impl Step for RustdocJS {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n-            builder.ensure(::doc::Std {\n+            builder.ensure(crate::doc::Std {\n                 target: self.target,\n                 stage: builder.top_stage,\n             });\n@@ -833,12 +871,6 @@ host_test!(RunFailFullDeps {\n     suite: \"run-fail-fulldeps\"\n });\n \n-host_test!(CompileFailFullDeps {\n-    path: \"src/test/compile-fail-fulldeps\",\n-    mode: \"compile-fail\",\n-    suite: \"compile-fail-fulldeps\"\n-});\n-\n host_test!(Rustdoc {\n     path: \"src/test/rustdoc\",\n     mode: \"rustdoc\",\n@@ -971,7 +1003,7 @@ impl Step for Compiletest {\n         }\n \n         if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g. thumb*),\n+            // for no_std run-make (e.g., thumb*),\n             // we need a host compiler which is called by cargo.\n             builder.ensure(compile::Std { compiler, target: compiler.host });\n         }\n@@ -1277,7 +1309,7 @@ impl Step for DocTest {\n \n     /// Run `rustdoc --test` for all documentation in `src/doc`.\n     ///\n-    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n     /// `compiler`.\n     fn run(self, builder: &Builder) {\n@@ -1427,10 +1459,8 @@ impl Step for ErrorIndex {\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n-    match File::open(markdown) {\n-        Ok(mut file) => {\n-            let mut contents = String::new();\n-            t!(file.read_to_string(&mut contents));\n+    match fs::read_to_string(markdown) {\n+        Ok(contents) => {\n             if !contents.contains(\"```\") {\n                 return true;\n             }\n@@ -1567,10 +1597,7 @@ impl Step for Crate {\n         let builder = run.builder;\n         run = run.krate(\"test\");\n         for krate in run.builder.in_tree_crates(\"std\") {\n-            if krate.is_local(&run.builder)\n-                && !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\"))\n-                && krate.name != \"dlmalloc\"\n-            {\n+            if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n         }"}, {"sha": "4335359e11589c7295c18e2f4832f615d61d7b2e", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,16 +15,16 @@ use std::path::PathBuf;\n use std::process::{Command, exit};\n use std::collections::HashSet;\n \n-use Mode;\n-use Compiler;\n-use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{exe, add_lib_path};\n-use compile;\n-use native;\n-use channel::GitInfo;\n-use channel;\n-use cache::Interned;\n-use toolstate::ToolState;\n+use crate::Mode;\n+use crate::Compiler;\n+use crate::builder::{Step, RunConfig, ShouldRun, Builder};\n+use crate::util::{exe, add_lib_path};\n+use crate::compile;\n+use crate::native;\n+use crate::channel::GitInfo;\n+use crate::channel;\n+use crate::cache::Interned;\n+use crate::toolstate::ToolState;\n \n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub enum SourceType {\n@@ -646,7 +646,7 @@ impl<'a> Builder<'a> {\n             self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n         ];\n \n-        // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n+        // On MSVC a tool may invoke a C compiler (e.g., compiletest in run-make\n         // mode) and that C compiler may need some extra PATH modification. Do\n         // so here.\n         if compiler.host.contains(\"msvc\") {"}, {"sha": "b18e38e471efff47672d499e91ce736aca49c1c2", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,8 +21,8 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use config::Config;\n-use builder::Builder;\n+use crate::config::Config;\n+use crate::builder::Builder;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {"}, {"sha": "a580a874b3341ac699088ea495b847263ab96c80", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -224,14 +224,12 @@ impl Drop for NativeLibBoilerplate {\n // Timestamps are created automatically when the result of `native_lib_boilerplate` goes out\n // of scope, so all the build actions should be completed until then.\n pub fn native_lib_boilerplate(\n-    src_name: &str,\n+    src_dir: &Path,\n     out_name: &str,\n     link_name: &str,\n     search_subdir: &str,\n ) -> Result<NativeLibBoilerplate, ()> {\n-    let current_dir = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n-    let src_dir = current_dir.join(\"..\").join(src_name);\n-    rerun_if_changed_anything_in_dir(&src_dir);\n+    rerun_if_changed_anything_in_dir(src_dir);\n \n     let out_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or_else(||\n         env::var_os(\"OUT_DIR\").unwrap());\n@@ -248,9 +246,9 @@ pub fn native_lib_boilerplate(\n     );\n \n     let timestamp = out_dir.join(\"rustbuild.timestamp\");\n-    if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(&src_dir, &timestamp) {\n+    if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n         Ok(NativeLibBoilerplate {\n-            src_dir: src_dir,\n+            src_dir: src_dir.to_path_buf(),\n             out_dir: out_dir,\n         })\n     } else {\n@@ -279,8 +277,11 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n     } else {\n         format!(\"static={}\", link_name)\n     };\n+    // The source for `compiler-rt` comes from the `compiler-builtins` crate, so\n+    // load our env var set by cargo to find the source code.\n+    let dir = env::var_os(\"DEP_COMPILER_RT_COMPILER_RT\").unwrap();\n     let lib = native_lib_boilerplate(\n-        \"libcompiler_builtins/compiler-rt\",\n+        dir.as_ref(),\n         sanitizer_name,\n         &to_link,\n         search_path,"}, {"sha": "a54a2d003b649b9a778cafaf22c0fb40ef8ca098", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,6 +16,7 @@ RUN . /scripts/android-ndk.sh && \\\n # env\n ENV TARGETS=arm-linux-androideabi\n ENV TARGETS=$TARGETS,armv7-linux-androideabi\n+ENV TARGETS=$TARGETS,thumbv7neon-linux-androideabi\n ENV TARGETS=$TARGETS,i686-linux-android\n ENV TARGETS=$TARGETS,aarch64-linux-android\n ENV TARGETS=$TARGETS,x86_64-linux-android\n@@ -24,6 +25,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n+      --thumbv7neon-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --i686-linux-android-ndk=/android/ndk/x86-14 \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\"}, {"sha": "4f8a3c0240e1a19b50938da2acf7b5f5e2740b97", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -52,8 +52,8 @@ RUN env \\\n     CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n     bash musl.sh arm && \\\n     env \\\n-    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv6 -marm\" \\\n-    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n+    CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n+    CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n     bash musl.sh armhf && \\\n     env \\\n     CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\"}, {"sha": "a7a8719b5357ea4191a2a8fbe7f092832193f23c", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,31 +13,28 @@ set -ex\n \n source shared.sh\n \n-LLVM=7.0.0\n+# Currently these commits are all tip-of-tree as of 2018-12-16, used to pick up\n+# a fix for rust-lang/rust#56849\n+LLVM=032b00a5404865765cda7db3039f39d54964d8b0\n+LLD=3e4aa4e8671523321af51449e0569f455ef3ad43\n+CLANG=a6b9739069763243020f4ea6fe586bc135fde1f9\n \n mkdir clang\n cd clang\n \n-curl https://releases.llvm.org/$LLVM/llvm-$LLVM.src.tar.xz | \\\n-  xz -d | \\\n-  tar xf -\n-\n-cd llvm-$LLVM.src\n+curl -L https://github.com/llvm-mirror/llvm/archive/$LLVM.tar.gz | \\\n+  tar xzf - --strip-components=1\n \n mkdir -p tools/clang\n-\n-curl https://releases.llvm.org/$LLVM/cfe-$LLVM.src.tar.xz | \\\n-  xz -d | \\\n-  tar xf - -C tools/clang --strip-components=1\n+curl -L https://github.com/llvm-mirror/clang/archive/$CLANG.tar.gz | \\\n+  tar xzf - --strip-components=1 -C tools/clang\n \n mkdir -p tools/lld\n+curl -L https://github.com/llvm-mirror/lld/archive/$LLD.tar.gz | \\\n+  tar zxf - --strip-components=1 -C tools/lld\n \n-curl https://releases.llvm.org/$LLVM/lld-$LLVM.src.tar.xz | \\\n-  xz -d | \\\n-  tar xf - -C tools/lld --strip-components=1\n-\n-mkdir ../clang-build\n-cd ../clang-build\n+mkdir clang-build\n+cd clang-build\n \n # For whatever reason the default set of include paths for clang is different\n # than that of gcc. As a result we need to manually include our sysroot's\n@@ -55,7 +52,7 @@ INC=\"$INC:/rustroot/lib/gcc/x86_64-unknown-linux-gnu/4.8.5/include-fixed\"\n INC=\"$INC:/usr/include\"\n \n hide_output \\\n-    cmake ../llvm-$LLVM.src \\\n+    cmake .. \\\n       -DCMAKE_C_COMPILER=/rustroot/bin/gcc \\\n       -DCMAKE_CXX_COMPILER=/rustroot/bin/g++ \\\n       -DCMAKE_BUILD_TYPE=Release \\"}, {"sha": "10aedf6a60e109ecb8f4204386cd70b671a8efb5", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -20,4 +20,5 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu\n+ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n+           python2.7 ../x.py build --stage 0 src/tools/build-manifest"}, {"sha": "160b23e0b00d176672d8f17f350a91412fa49052", "filename": "src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -11,7 +11,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  llvm-5.0-tools \\\n+  llvm-6.0-tools \\\n   libedit-dev \\\n   zlib1g-dev \\\n   xz-utils\n@@ -22,6 +22,6 @@ RUN sh /scripts/sccache.sh\n # using llvm-link-shared due to libffi issues -- see #34486\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-5.0 \\\n+      --llvm-root=/usr/lib/llvm-6.0 \\\n       --enable-llvm-link-shared\n ENV RUST_CHECK_TARGET check", "previous_filename": "src/ci/docker/x86_64-gnu-llvm-5.0/Dockerfile"}, {"sha": "c99638dc2ecfc750cc1656f6edb2bd062c1e0981", "filename": "src/dlmalloc", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=b4a306c1e648c84f289c63e984941b7faad10af1", "patch": "@@ -1 +0,0 @@\n-Subproject commit c99638dc2ecfc750cc1656f6edb2bd062c1e0981"}, {"sha": "74d81d80052cb88925f0e73b12fbd0b73ab7b5a0", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1 +1 @@\n-Subproject commit 616fe4172b688393aeee5f34935cc25733c9c062\n+Subproject commit 74d81d80052cb88925f0e73b12fbd0b73ab7b5a0"}, {"sha": "94f21042c8fdd86ffcd30fe8e8d7f8e6205a07d4", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -22,6 +22,13 @@ This flag lets you append a single extra argument to the linker invocation.\n This flag lets you append multiple extra arguments to the linker invocation. The\n options should be separated by spaces.\n \n+## linker-flavor\n+\n+This flag lets you control the linker flavor used by `rustc`. If a linker is given with the\n+`-C linker` flag described above then the linker flavor is inferred from the value provided. If no\n+linker is given then the linker flavor is used to determine the linker to use. Every `rustc` target\n+defaults to some linker flavor.\n+\n ## link-dead-code\n \n Normally, the linker will remove dead code. This flag disables this behavior."}, {"sha": "2e94ebe345adbbb791cb9d66bf18786c015f45fa", "filename": "src/doc/rustc/src/targets/built-in.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -6,5 +6,5 @@ the team is supporting directly.\n \n To see the list of built-in targets, you can run `rustc --print target-list`,\n or look at [the API\n-docs](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_back/target/#modules).\n+docs](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/index.html#modules).\n Each module there defines a builder for a particular target.\n\\ No newline at end of file"}, {"sha": "3d63d072befe0ae46979c8d8ffcc5b90d8dc325a", "filename": "src/doc/rustc/src/targets/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -4,7 +4,7 @@\n architecture. The list of *targets* are the possible architectures that you can build for.\n \n To see all the options that you can set with a target, see the docs\n-[here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_back/target/struct.Target.html).\n+[here](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/struct.Target.html).\n \n To compile to a particular target, use the `--target` flag:\n "}, {"sha": "905b06465340a7845e4b445adc67b0cb94fbc475", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -402,3 +402,18 @@ Using `index-page` option enables `enable-index-page` option as well.\n ### `--enable-index-page`: generate a default index page for docs\n \n This feature allows the generation of a default index-page which lists the generated crates.\n+\n+### `--static-root-path`: control how static files are loaded in HTML output\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --static-root-path '/cache/'\n+```\n+\n+This flag controls how rustdoc links to its static files on HTML pages. If you're hosting a lot of\n+crates' docs generated by the same version of rustdoc, you can use this flag to cache rustdoc's CSS,\n+JavaScript, and font files in a single location, rather than duplicating it once per \"doc root\"\n+(grouping of crate docs generated into the same output directory, like with `cargo doc`). Per-crate\n+files like the search index will still load from the documentation root, but anything that gets\n+renamed with `--resource-suffix` will load from the given path."}, {"sha": "39659602e015c4d4b6ced94ae80458d5ce5399ad", "filename": "src/doc/unstable-book/src/compiler-flags/linker-flavor.md", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b4a306c1e648c84f289c63e984941b7faad10af1/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flinker-flavor.md", "raw_url": "https://github.com/rust-lang/rust/raw/b4a306c1e648c84f289c63e984941b7faad10af1/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flinker-flavor.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flinker-flavor.md?ref=b4a306c1e648c84f289c63e984941b7faad10af1", "patch": "@@ -1,61 +0,0 @@\n-# `linker-flavor`\n-\n-The tracking issue for this feature is: None\n-\n-------------------------\n-\n-Every `rustc` target defaults to some linker. For example, Linux targets default\n-to gcc. In some cases, you may want to override the default; you can do that\n-with the unstable CLI argument: `-Z linker-flavor`.\n-\n-Here how you would use this flag to link a Rust binary for the\n-`thumbv7m-none-eabi` using LLD instead of GCC.\n-\n-``` text\n-$ xargo rustc --target thumbv7m-none-eabi -- \\\n-    -C linker=ld.lld \\\n-    -Z linker-flavor=ld \\\n-    -Z print-link-args | tr ' ' '\\n'\n-\"ld.lld\"\n-\"-L\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps/app-512e9dbf385f233c.0.o\"\n-\"-o\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps/app-512e9dbf385f233c\"\n-\"--gc-sections\"\n-\"-L\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps\"\n-\"-L\"\n-\"$PWD/target/debug/deps\"\n-\"-L\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib\"\n-\"-Bstatic\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib/libcore-e1ccb7dfb1cb9ebb.rlib\"\n-\"-Bdynamic\"\n-```\n-\n-Whereas the default is:\n-\n-``` text\n-$ xargo rustc --target thumbv7m-none-eabi -- \\\n-    -C link-arg=-nostartfiles \\\n-    -Z print-link-args | tr ' ' '\\n'\n-\"arm-none-eabi-gcc\"\n-\"-L\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps/app-961e39416baa38d9.0.o\"\n-\"-o\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps/app-961e39416baa38d9\"\n-\"-Wl,--gc-sections\"\n-\"-nodefaultlibs\"\n-\"-L\"\n-\"$PWD/target/thumbv7m-none-eabi/debug/deps\"\n-\"-L\"\n-\"$PWD/target/debug/deps\"\n-\"-L\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib\"\n-\"-Wl,-Bstatic\"\n-\"$SYSROOT/lib/rustlib/thumbv7m-none-eabi/lib/libcore-e1ccb7dfb1cb9ebb.rlib\"\n-\"-nostartfiles\"\n-\"-Wl,-Bdynamic\"\n-```"}, {"sha": "968534e58bd9ebe943565a7452ab29a9ace3fa68", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -149,7 +149,7 @@ closure-like semantics. Namely:\n * Whenever a generator is dropped it will drop all captured environment\n   variables.\n \n-Note that unlike closures generators at this time cannot take any arguments.\n+Note that unlike closures, generators at this time cannot take any arguments.\n That is, generators must always look like `|| { ... }`. This restriction may be\n lifted at a future date, the design is ongoing!\n "}, {"sha": "2dd763d04b0abf6e03e00eb075200a24931f7875", "filename": "src/doc/unstable-book/src/language-features/repr-packed.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4a306c1e648c84f289c63e984941b7faad10af1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "raw_url": "https://github.com/rust-lang/rust/raw/b4a306c1e648c84f289c63e984941b7faad10af1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md?ref=b4a306c1e648c84f289c63e984941b7faad10af1", "patch": "@@ -1,8 +0,0 @@\n-# `repr_packed`\n-\n-The tracking issue for this feature is [#33158]\n-\n-[#33158]: https://github.com/rust-lang/rust/issues/33158\n-\n-------------------------\n-"}, {"sha": "edc039f896b2c528318706b233dde801c8214806", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,7 +8,7 @@ The tracking issue for this feature is: [#48055]\n \n This implements [RFC1909]. When turned on, you can have unsized arguments and locals:\n \n-[RFC1909]: https://github.com/rust-lang/rfcs/blob/master/text/1909-coercions.md\n+[RFC1909]: https://github.com/rust-lang/rfcs/blob/master/text/1909-unsized-rvalues.md\n \n ```rust\n #![feature(unsized_locals)]"}, {"sha": "f02c7d87590acdbc1d3818c023d71ff80820e64c", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -9,6 +9,7 @@\n # except according to those terms.\n \n import gdb\n+import re\n import sys\n import debugger_pretty_printers_common as rustpp\n \n@@ -20,6 +21,16 @@\n \n rust_enabled = 'set language rust' in gdb.execute('complete set language ru', to_string = True)\n \n+# The btree pretty-printers fail in a confusing way unless\n+# https://sourceware.org/bugzilla/show_bug.cgi?id=21763 is fixed.\n+# This fix went in 8.1, so check for that.\n+# See https://github.com/rust-lang/rust/issues/56730\n+gdb_81 = False\n+_match = re.match('([0-9]+)\\\\.([0-9]+)', gdb.VERSION)\n+if _match:\n+    if int(_match.group(1)) > 8 or (int(_match.group(1)) == 8 and int(_match.group(2)) >= 1):\n+        gdb_81 = True\n+\n #===============================================================================\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n@@ -110,10 +121,10 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n         return RustStdVecDequePrinter(val)\n \n-    if type_kind == rustpp.TYPE_KIND_STD_BTREESET:\n+    if type_kind == rustpp.TYPE_KIND_STD_BTREESET and gdb_81:\n         return RustStdBTreeSetPrinter(val)\n \n-    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP:\n+    if type_kind == rustpp.TYPE_KIND_STD_BTREEMAP and gdb_81:\n         return RustStdBTreeMapPrinter(val)\n \n     if type_kind == rustpp.TYPE_KIND_STD_STRING:"}, {"sha": "8ea1cb26dc0c7f0239dac52fa1f67ef48165042d", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -741,14 +741,14 @@ fn_anon_params\n ;\n \n fn_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n ;\n \n fn_anon_params_with_self\n-: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfLower\", 3, $2, $4, $5); }\n | '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n | '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n | '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }"}, {"sha": "b2eb3566c04a7285ce117e509d9c804d884ef108", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -11,10 +11,10 @@ path = \"lib.rs\"\n \n [dependencies]\n core = { path = \"../libcore\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+compiler_builtins = { version = \"0.1.0\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n-rand = \"0.5\"\n+rand = \"0.6\"\n \n [[test]]\n name = \"collectionstests\"\n@@ -28,3 +28,6 @@ path = \"../liballoc/benches/lib.rs\"\n name = \"vec_deque_append_bench\"\n path = \"../liballoc/benches/vec_deque_append.rs\"\n harness = false\n+\n+[features]\n+compiler-builtins-mem = ['compiler_builtins/mem']"}, {"sha": "f1581310b48fcfbf192568ca428fe7b8620f1748", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -77,7 +77,9 @@ use core::iter::{Iterator, FromIterator, FusedIterator};\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::pin::Pin;\n-use core::ops::{CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Generator, GeneratorState};\n+use core::ops::{\n+    CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n+};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{LocalWaker, Poll};\n \n@@ -583,6 +585,9 @@ impl<T: ?Sized> DerefMut for Box<T> {\n     }\n }\n \n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<T: ?Sized> Receiver for Box<T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator + ?Sized> Iterator for Box<I> {\n     type Item = I::Item;\n@@ -801,7 +806,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n  *        safe.)\n  *      - It is in practice very useful to have Box<T> be unconditionally\n  *        Unpin because of trait objects, for which the structural auto\n- *        trait functionality does not apply (e.g. Box<dyn Foo> would\n+ *        trait functionality does not apply (e.g., Box<dyn Foo> would\n  *        otherwise not be Unpin).\n  *\n  *  Another type with the same semantics as Box but only a conditional"}, {"sha": "5dd0ea7d431a719879bb2c6d1cefbb3c940d3b55", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -858,7 +858,7 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n }\n \n-/// Hole represents a hole in a slice i.e. an index without valid value\n+/// Hole represents a hole in a slice i.e., an index without valid value\n /// (because it was moved from or duplicated).\n /// In drop, `Hole` will restore the slice by filling the hole\n /// position with the value that was originally removed."}, {"sha": "a2d2d3c74be9dd261813b56a42eaa19f8527df2a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 117, "deletions": 57, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -58,9 +58,34 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n /// case.\n ///\n-/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n-/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n-/// prevent them from being reordered.\n+/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n+/// order to statically allocate a single dummy node to avoid allocations. This struct is\n+/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// by `as_header`.)\n+/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// because the size of `NodeHeader` depends on its alignment!\n+#[repr(C)]\n+struct NodeHeader<K, V, K2 = ()> {\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n+    parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is non-null.\n+    parent_idx: MaybeUninit<u16>,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n+    len: u16,\n+\n+    /// See `into_key_slice`.\n+    keys_start: [K2; 0],\n+}\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -98,24 +123,25 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+}\n \n+impl<K, V> NodeHeader<K, V> {\n     fn is_shared_root(&self) -> bool {\n         ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n \n // We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for LeafNode<(), ()> {}\n+unsafe impl Sync for NodeHeader<(), ()> {}\n \n // An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use () in order to save space, since no operation on an empty tree will\n+// We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n     parent_idx: MaybeUninit::uninitialized(),\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys_start: [],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -281,7 +307,7 @@ impl<K, V> Root<K, V> {\n                                     .node)\n         };\n         self.height -= 1;\n-        self.as_mut().as_leaf_mut().parent = ptr::null();\n+        unsafe { (*self.as_mut().as_leaf_mut()).parent = ptr::null(); }\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -306,6 +332,11 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n+///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n+///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n+///   pointing to the shared root is UB.\n+///   Turning this into a `NodeHeader` is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n@@ -352,7 +383,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n-        self.as_leaf().len as usize\n+        self.as_header().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -382,14 +413,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf(&self) -> &LeafNode<K, V> {\n+    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        self.node.as_ref()\n+    }\n+\n+    fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe {\n-            self.node.as_ref()\n+            &*(self.node.as_ptr() as *const NodeHeader<K, V>)\n         }\n     }\n \n     pub fn is_shared_root(&self) -> bool {\n-        self.as_leaf().is_shared_root()\n+        self.as_header().is_shared_root()\n     }\n \n     pub fn keys(&self) -> &[K] {\n@@ -418,7 +454,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -427,7 +463,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -534,10 +570,10 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n-        unsafe {\n-            self.node.as_mut()\n-        }\n+    /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n+        // We are mutable, so we cannot be the root, so accessing this as a leaf is okay.\n+        self.node.as_ptr()\n     }\n \n     fn keys_mut(&mut self) -> &mut [K] {\n@@ -551,28 +587,50 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        // When taking a pointer to the keys, if our key has a stricter\n-        // alignment requirement than the shared root does, then the pointer\n-        // would be out of bounds, which LLVM assumes will not happen. If the\n-        // alignment is more strict, we need to make an empty slice that doesn't\n-        // use an out of bounds pointer.\n+        // We have to be careful here because we might be pointing to the shared root.\n+        // In that case, we must not create an `&LeafNode`.  We could just return\n+        // an empty slice whenever the length is 0 (this includes the shared root),\n+        // but we want to avoid that run-time check.\n+        // Instead, we create a slice pointing into the node whenever possible.\n+        // We can sometimes do this even for the shared root, as the slice will be\n+        // empty.  We cannot *always* do this because if the type is too highly\n+        // aligned, the offset of `keys` in a \"full node\" might be outside the bounds\n+        // of the header!  So we do an alignment check first, that will be\n+        // evaluated at compile-time, and only do any run-time check in the rare case\n+        // that the alignment is very big.\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &[]\n         } else {\n-            // Here either it's not the root, or the alignment is less strict,\n-            // in which case the keys pointer will point \"one-past-the-end\" of\n-            // the node, which is allowed by LLVM.\n+            // Thanks to the alignment check above, we know that `keys` will be\n+            // in-bounds of some allocation even if this is the shared root!\n+            // (We might be one-past-the-end, but that is allowed by LLVM.)\n+            // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n+            // field because we want its size to not depend on the alignment of `K`\n+            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // because we might be the shared root.\n+            // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n+            // and hence just adds a size-0-align-1 field, not affecting layout).\n+            // We know that we can transmute `NodeHeader<K, V, ()>` to `NodeHeader<K, V, K>`\n+            // because we did the alignment check above, and hence `NodeHeader<K, V, K>`\n+            // is not bigger than `NodeHeader<K, V, ()>`!  Then we can use `NodeHeader<K, V, K>`\n+            // to compute the pointer where the keys start.\n+            // This entire hack will become unnecessary once\n+            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n+            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n+\n+            // This is a non-debug-assert because it can be completely compile-time evaluated.\n+            assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n+            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n+            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n             unsafe {\n-                slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n-                    self.len()\n-                )\n+                slice::from_raw_parts(keys, self.len())\n             }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n+        // We cannot be the root, so `as_leaf` is okay\n         unsafe {\n             slice::from_raw_parts(\n                 self.as_leaf().vals.as_ptr() as *const V,\n@@ -602,7 +660,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    self.as_leaf_mut().keys.as_mut_ptr() as *mut K,\n+                    (*self.as_leaf_mut()).keys.as_mut_ptr() as *mut K,\n                     self.len()\n                 )\n             }\n@@ -613,7 +671,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                self.as_leaf_mut().vals.as_mut_ptr() as *mut V,\n+                (*self.as_leaf_mut()).vals.as_mut_ptr() as *mut V,\n                 self.len()\n             )\n         }\n@@ -637,9 +695,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n@@ -651,9 +709,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n }\n \n@@ -672,7 +730,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n             ptr::write(self.as_internal_mut().edges.get_unchecked_mut(idx + 1), edge.node);\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n@@ -708,7 +766,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 edge.node\n             );\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             self.correct_all_childrens_parent_links();\n         }\n@@ -732,12 +790,12 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(internal) => {\n                     let edge = ptr::read(internal.as_internal().edges.get_unchecked(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -765,7 +823,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -775,7 +833,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n \n             (key, val, edge)\n         }\n@@ -966,7 +1024,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n-            self.node.as_leaf_mut().len += 1;\n+            (*self.node.as_leaf_mut()).len += 1;\n \n             self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n@@ -1009,8 +1067,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n-        child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.set(idx);\n+        unsafe {\n+            (*child.as_leaf_mut()).parent = ptr;\n+            (*child.as_leaf_mut()).parent_idx.set(idx);\n+        }\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n@@ -1158,7 +1218,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n                 new_len\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n \n             (\n@@ -1180,7 +1240,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n             (self.left_edge(), k, v)\n         }\n     }\n@@ -1221,7 +1281,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 new_len + 1\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.data.len = new_len as u16;\n \n             let mut new_root = Root {\n@@ -1295,9 +1355,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             for i in self.idx+1..self.node.len() {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n \n-            left_node.as_leaf_mut().len += right_len as u16 + 1;\n+            (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n@@ -1407,8 +1467,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len += count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1468,8 +1528,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                           new_right_len);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len += count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1560,8 +1620,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n             move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            left_node.reborrow_mut().as_leaf_mut().len = left_new_len as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len = right_new_len as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(right)) => {"}, {"sha": "fa74dce2f1f4a2c45df841078c157bc837bb9bab", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -258,7 +258,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the difference,\n-    /// i.e. the values that are in `self` but not in `other`,\n+    /// i.e., the values that are in `self` but not in `other`,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -286,7 +286,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the symmetric difference,\n-    /// i.e. the values that are in `self` or in `other` but not in both,\n+    /// i.e., the values that are in `self` or in `other` but not in both,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -316,7 +316,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the intersection,\n-    /// i.e. the values that are both in `self` and `other`,\n+    /// i.e., the values that are both in `self` and `other`,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -344,7 +344,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Visits the values representing the union,\n-    /// i.e. all the values in `self` or `other`, without duplicates,\n+    /// i.e., all the values in `self` or `other`, without duplicates,\n     /// in ascending order.\n     ///\n     /// # Examples\n@@ -455,7 +455,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Returns `true` if the set is a subset of another,\n-    /// i.e. `other` contains at least all the values in `self`.\n+    /// i.e., `other` contains at least all the values in `self`.\n     ///\n     /// # Examples\n     ///\n@@ -498,7 +498,7 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Returns `true` if the set is a superset of another,\n-    /// i.e. `self` contains at least all the values in `other`.\n+    /// i.e., `self` contains at least all the values in `other`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "ba46fafaf169f6d09bb46a700773dab490639811", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -627,7 +627,9 @@ impl<T> LinkedList<T> {\n         self.pop_front_node().map(Node::into_element)\n     }\n \n-    /// Appends an element to the back of a list\n+    /// Appends an element to the back of a list.\n+    ///\n+    /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -647,6 +649,8 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n+    /// This operation should compute in O(1) time.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "553c6d7291a9de64bd7694cd3812edc0609c585a", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 126, "deletions": 13, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1026,7 +1026,10 @@ impl<T> VecDeque<T> {\n             iter: Iter {\n                 tail: drain_tail,\n                 head: drain_head,\n-                ring: unsafe { self.buffer_as_mut_slice() },\n+                // Crucially, we only create shared references from `self` here and read from\n+                // it.  We do not write to `self` nor reborrow to a mutable reference.\n+                // Hence the raw pointer we created above, for `deque`, remains valid.\n+                ring: unsafe { self.buffer_as_slice() },\n             },\n         }\n     }\n@@ -1894,8 +1897,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vec_resize_with)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1914,7 +1915,7 @@ impl<T> VecDeque<T> {\n     /// buf.resize_with(5, || { state += 1; state });\n     /// assert_eq!(buf, [5, 10, 101, 102, 103]);\n     /// ```\n-    #[unstable(feature = \"vec_resize_with\", issue = \"41758\")]\n+    #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut()->T) {\n         let len = self.len();\n \n@@ -1924,6 +1925,118 @@ impl<T> VecDeque<T> {\n             self.truncate(new_len);\n         }\n     }\n+\n+    /// Rotates the double-ended queue `mid` places to the left.\n+    ///\n+    /// Equivalently,\n+    /// - Rotates item `mid` into the first position.\n+    /// - Pops the first `mid` items and pushes them to the end.\n+    /// - Rotates `len() - mid` places to the right.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `mid` is greater than `len()`.  Note that `mid == len()`\n+    /// does _not_ panic and is a no-op rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes `O(min(mid, len() - mid))` time and no extra space.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_rotate)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf: VecDeque<_> = (0..10).collect();\n+    ///\n+    /// buf.rotate_left(3);\n+    /// assert_eq!(buf, [3, 4, 5, 6, 7, 8, 9, 0, 1, 2]);\n+    ///\n+    /// for i in 1..10 {\n+    ///     assert_eq!(i * 3 % 10, buf[0]);\n+    ///     buf.rotate_left(3);\n+    /// }\n+    /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    pub fn rotate_left(&mut self, mid: usize) {\n+        assert!(mid <= self.len());\n+        let k = self.len() - mid;\n+        if mid <= k {\n+            unsafe { self.rotate_left_inner(mid) }\n+        } else {\n+            unsafe { self.rotate_right_inner(k) }\n+        }\n+    }\n+\n+    /// Rotates the double-ended queue `k` places to the right.\n+    ///\n+    /// Equivalently,\n+    /// - Rotates the first item into position `k`.\n+    /// - Pops the last `k` items and pushes them to the front.\n+    /// - Rotates `len() - k` places to the left.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `k` is greater than `len()`.  Note that `k == len()`\n+    /// does _not_ panic and is a no-op rotation.\n+    ///\n+    /// # Complexity\n+    ///\n+    /// Takes `O(min(k, len() - k))` time and no extra space.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_rotate)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf: VecDeque<_> = (0..10).collect();\n+    ///\n+    /// buf.rotate_right(3);\n+    /// assert_eq!(buf, [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]);\n+    ///\n+    /// for i in 1..10 {\n+    ///     assert_eq!(0, buf[i * 3 % 10]);\n+    ///     buf.rotate_right(3);\n+    /// }\n+    /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    pub fn rotate_right(&mut self, k: usize) {\n+        assert!(k <= self.len());\n+        let mid = self.len() - k;\n+        if k <= mid {\n+            unsafe { self.rotate_right_inner(k) }\n+        } else {\n+            unsafe { self.rotate_left_inner(mid) }\n+        }\n+    }\n+\n+    // Safety: the following two methods require that the rotation amount\n+    // be less than half the length of the deque.\n+    //\n+    // `wrap_copy` requres that `min(x, cap() - x) + copy_len <= cap()`,\n+    // but than `min` is never more than half the capacity, regardless of x,\n+    // so it's sound to call here because we're calling with something\n+    // less than half the length, which is never above half the capacity.\n+\n+    unsafe fn rotate_left_inner(&mut self, mid: usize) {\n+        debug_assert!(mid * 2 <= self.len());\n+        self.wrap_copy(self.head, self.tail, mid);\n+        self.head = self.wrap_add(self.head, mid);\n+        self.tail = self.wrap_add(self.tail, mid);\n+    }\n+\n+    unsafe fn rotate_right_inner(&mut self, k: usize) {\n+        debug_assert!(k * 2 <= self.len());\n+        self.head = self.wrap_sub(self.head, k);\n+        self.tail = self.wrap_sub(self.tail, k);\n+        self.wrap_copy(self.tail, self.head, k);\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {\n@@ -2795,7 +2908,7 @@ mod tests {\n             // 0, 1, 2, .., len - 1\n             let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n-                for to_remove in 0..len + 1 {\n+                for to_remove in 0..=len {\n                     tester.tail = tail_pos;\n                     tester.head = tail_pos;\n                     for i in 0..len {\n@@ -2821,10 +2934,10 @@ mod tests {\n         let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n \n         let cap = tester.capacity();\n-        for len in 0..cap + 1 {\n-            for tail in 0..cap + 1 {\n-                for drain_start in 0..len + 1 {\n-                    for drain_end in drain_start..len + 1 {\n+        for len in 0..=cap {\n+            for tail in 0..=cap {\n+                for drain_start in 0..=len {\n+                    for drain_end in drain_start..=len {\n                         tester.tail = tail;\n                         tester.head = tail;\n                         for i in 0..len {\n@@ -2866,10 +2979,10 @@ mod tests {\n         tester.reserve(63);\n         let max_cap = tester.capacity();\n \n-        for len in 0..cap + 1 {\n+        for len in 0..=cap {\n             // 0, 1, 2, .., len - 1\n             let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..max_cap + 1 {\n+            for tail_pos in 0..=max_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n                 tester.reserve(63);\n@@ -2899,7 +3012,7 @@ mod tests {\n         // len is the length *before* splitting\n         for len in 0..cap {\n             // index to split at\n-            for at in 0..len + 1 {\n+            for at in 0..=len {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n                 let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n                 // at, at + 1, .., len - 1 (may be empty)\n@@ -2927,7 +3040,7 @@ mod tests {\n     fn test_from_vec() {\n         use vec::Vec;\n         for cap in 0..35 {\n-            for len in 0..cap + 1 {\n+            for len in 0..=cap {\n                 let mut vec = Vec::with_capacity(cap);\n                 vec.extend(0..len);\n "}, {"sha": "afa7a6f919d26d9210687cfd759a1b5261617f0a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -72,6 +72,8 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n #![needs_allocator]\n+\n+#![deny(intra_doc_link_resolution_failure)]\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(not(test), feature(fn_traits))]\n@@ -104,6 +106,7 @@\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n+#![feature(receiver_trait)]\n #![feature(specialization)]\n #![feature(split_ascii_whitespace)]\n #![feature(staged_api)]"}, {"sha": "f4674b327695e834e900d8231a005f1b9fee03f6", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -739,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g. PAE or x32\n+// all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {"}, {"sha": "65a610b9d1e92b42bafe31dac319746fceb5f4d2", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 100, "deletions": 9, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -253,7 +253,7 @@ use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n-use core::ops::Deref;\n+use core::ops::{Deref, Receiver};\n use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -276,7 +276,7 @@ struct RcBox<T: ?Sized> {\n /// See the [module-level documentation](./index.html) for more details.\n ///\n /// The inherent methods of `Rc` are all associated functions, which means\n-/// that you have to call them as e.g. [`Rc::get_mut(&mut value)`][get_mut] instead of\n+/// that you have to call them as e.g., [`Rc::get_mut(&mut value)`][get_mut] instead of\n /// `value.get_mut()`. This avoids conflicts with methods of the inner\n /// type `T`.\n ///\n@@ -813,6 +813,9 @@ impl<T: ?Sized> Deref for Rc<T> {\n     }\n }\n \n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<T: ?Sized> Receiver for Rc<T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc`.\n@@ -840,6 +843,8 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n+    ///\n+    /// [`Weak`]: ../../std/rc/struct.Weak.html\n     fn drop(&mut self) {\n         unsafe {\n             self.dec_strong();\n@@ -900,12 +905,47 @@ impl<T: Default> Default for Rc<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+trait RcEqIdent<T: ?Sized + PartialEq> {\n+    fn eq(&self, other: &Rc<T>) -> bool;\n+    fn ne(&self, other: &Rc<T>) -> bool;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n+    #[inline]\n+    default fn eq(&self, other: &Rc<T>) -> bool {\n+        **self == **other\n+    }\n+\n+    #[inline]\n+    default fn ne(&self, other: &Rc<T>) -> bool {\n+        **self != **other\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n+    #[inline]\n+    fn eq(&self, other: &Rc<T>) -> bool {\n+        Rc::ptr_eq(self, other) || **self == **other\n+    }\n+\n+    #[inline]\n+    fn ne(&self, other: &Rc<T>) -> bool {\n+        !Rc::ptr_eq(self, other) && **self != **other\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n     /// Two `Rc`s are equal if their inner values are equal.\n     ///\n+    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// always equal.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -915,15 +955,18 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// assert!(five == Rc::new(5));\n     /// ```\n-    #[inline(always)]\n+    #[inline]\n     fn eq(&self, other: &Rc<T>) -> bool {\n-        **self == **other\n+        RcEqIdent::eq(self, other)\n     }\n \n     /// Inequality for two `Rc`s.\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n+    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// never unequal.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -933,9 +976,9 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// assert!(five != Rc::new(6));\n     /// ```\n-    #[inline(always)]\n+    #[inline]\n     fn ne(&self, other: &Rc<T>) -> bool {\n-        **self != **other\n+        RcEqIdent::ne(self, other)\n     }\n }\n \n@@ -1187,8 +1230,9 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n-    /// Calling [`upgrade`][Weak::upgrade] on the return value always gives [`None`].\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n+    /// [`upgrade`]: #method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n@@ -1251,7 +1295,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e. this `Weak` was created by `Weak::new`\n+    /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {\n@@ -1260,6 +1304,52 @@ impl<T: ?Sized> Weak<T> {\n             Some(unsafe { self.ptr.as_ref() })\n         }\n     }\n+\n+    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// that compare as equal).\n+    ///\n+    /// # Notes\n+    ///\n+    /// Since this compares pointers it means that `Weak::new()` will equal each\n+    /// other, even though they don't point to any value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_ptr_eq)]\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let first_rc = Rc::new(5);\n+    /// let first = Rc::downgrade(&first_rc);\n+    /// let second = Rc::downgrade(&first_rc);\n+    ///\n+    /// assert!(Weak::ptr_eq(&first, &second));\n+    ///\n+    /// let third_rc = Rc::new(5);\n+    /// let third = Rc::downgrade(&third_rc);\n+    ///\n+    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// ```\n+    ///\n+    /// Comparing `Weak::new`.\n+    ///\n+    /// ```\n+    /// #![feature(weak_ptr_eq)]\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let first = Weak::new();\n+    /// let second = Weak::new();\n+    /// assert!(Weak::ptr_eq(&first, &second));\n+    ///\n+    /// let third_rc = Rc::new(());\n+    /// let third = Rc::downgrade(&third_rc);\n+    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    }\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1334,9 +1424,10 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n     /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`][Weak::upgrade] on the return value always gives [`None`].\n+    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html\n+    /// [`upgrade`]: ../../std/rc/struct.Weak.html#method.upgrade\n     ///\n     /// # Examples\n     ///"}, {"sha": "510b4b06e407c591aa7b6e8aa9d73b3e65a6758a", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -177,7 +177,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -211,7 +211,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -264,7 +264,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n log(m n))`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n@@ -301,10 +301,10 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e. does not reorder equal elements) and `O(m n + n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n-    /// For simple key functions (e.g. functions that are property accesses or\n+    /// For simple key functions (e.g., functions that are property accesses or\n     /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n     /// faster.\n     ///\n@@ -589,7 +589,7 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n     type Output = Vec<T>;\n \n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n+        let size = self.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n             result.extend_from_slice(v.borrow())\n@@ -603,8 +603,8 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n-        let mut result = Vec::with_capacity(size + self.len());\n+        let size = self.iter().map(|slice| slice.borrow().len()).sum::<usize>() + self.len() - 1;\n+        let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n         for v in iter {"}, {"sha": "4652c0e7efa706ef397ee419c3ae18b2c94a9a8e", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -577,7 +577,7 @@ impl String {\n             return Cow::Borrowed(\"\");\n         };\n \n-        const REPLACEMENT: &'static str = \"\\u{FFFD}\";\n+        const REPLACEMENT: &str = \"\\u{FFFD}\";\n \n         let mut res = String::with_capacity(v.len());\n         res.push_str(first_valid);\n@@ -1732,18 +1732,37 @@ impl<'a> FromIterator<&'a str> for String {\n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl FromIterator<String> for String {\n     fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n-        let mut buf = String::new();\n-        buf.extend(iter);\n-        buf\n+        let mut iterator = iter.into_iter();\n+\n+        // Because we're iterating over `String`s, we can avoid at least\n+        // one allocation by getting the first string from the iterator\n+        // and appending to it all the subsequent strings.\n+        match iterator.next() {\n+            None => String::new(),\n+            Some(mut buf) => {\n+                buf.extend(iterator);\n+                buf\n+            }\n+        }\n     }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> FromIterator<Cow<'a, str>> for String {\n     fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n-        let mut buf = String::new();\n-        buf.extend(iter);\n-        buf\n+        let mut iterator = iter.into_iter();\n+\n+        // Because we're iterating over CoWs, we can (potentially) avoid at least\n+        // one allocation by getting the first item and appending to it all the\n+        // subsequent items.\n+        match iterator.next() {\n+            None => String::new(),\n+            Some(cow) => {\n+                let mut buf = cow.into_owned();\n+                buf.extend(iterator);\n+                buf\n+            }\n+        }\n     }\n }\n \n@@ -1753,9 +1772,7 @@ impl Extend<char> for String {\n         let iterator = iter.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n-        for ch in iterator {\n-            self.push(ch)\n-        }\n+        iterator.for_each(move |c| self.push(c));\n     }\n }\n \n@@ -1769,27 +1786,21 @@ impl<'a> Extend<&'a char> for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(s));\n     }\n }\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(&s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n-        for s in iter {\n-            self.push_str(&s)\n-        }\n+        iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n }\n \n@@ -2158,7 +2169,7 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n         use core::fmt::Write;\n         let mut buf = String::new();\n         buf.write_fmt(format_args!(\"{}\", self))\n-           .expect(\"a Display implementation return an error unexpectedly\");\n+           .expect(\"a Display implementation returned an error unexpectedly\");\n         buf.shrink_to_fit();\n         buf\n     }"}, {"sha": "948c36117a301414abf6c3496bf5d164150964c7", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 98, "deletions": 5, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -24,7 +24,7 @@ use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n-use core::ops::Deref;\n+use core::ops::{Deref, Receiver};\n use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -767,6 +767,9 @@ impl<T: ?Sized> Deref for Arc<T> {\n     }\n }\n \n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<T: ?Sized> Receiver for Arc<T> {}\n+\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n@@ -952,6 +955,8 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     /// drop(foo);    // Doesn't print anything\n     /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n+    ///\n+    /// [`Weak`]: ../../std/sync/struct.Weak.html\n     #[inline]\n     fn drop(&mut self) {\n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n@@ -1121,7 +1126,7 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e. this `Weak` was created by `Weak::new`\n+    /// i.e., this `Weak` was created by `Weak::new`\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {\n@@ -1130,6 +1135,53 @@ impl<T: ?Sized> Weak<T> {\n             Some(unsafe { self.ptr.as_ref() })\n         }\n     }\n+\n+    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// that compare as equal).\n+    ///\n+    /// # Notes\n+    ///\n+    /// Since this compares pointers it means that `Weak::new()` will equal each\n+    /// other, even though they don't point to any value.\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_ptr_eq)]\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let first_rc = Arc::new(5);\n+    /// let first = Arc::downgrade(&first_rc);\n+    /// let second = Arc::downgrade(&first_rc);\n+    ///\n+    /// assert!(Weak::ptr_eq(&first, &second));\n+    ///\n+    /// let third_rc = Arc::new(5);\n+    /// let third = Arc::downgrade(&third_rc);\n+    ///\n+    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// ```\n+    ///\n+    /// Comparing `Weak::new`.\n+    ///\n+    /// ```\n+    /// #![feature(weak_ptr_eq)]\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let first = Weak::new();\n+    /// let second = Weak::new();\n+    /// assert!(Weak::ptr_eq(&first, &second));\n+    ///\n+    /// let third_rc = Arc::new(());\n+    /// let third = Arc::downgrade(&third_rc);\n+    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -1172,10 +1224,11 @@ impl<T: ?Sized> Clone for Weak<T> {\n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating memory.\n-    /// Calling [`upgrade`][Weak::upgrade] on the return value always\n+    /// Calling [`upgrade`] on the return value always\n     /// gives [`None`].\n     ///\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`upgrade`]: ../../std/sync/struct.Weak.html#method.upgrade\n     ///\n     /// # Examples\n     ///\n@@ -1240,12 +1293,46 @@ impl<T: ?Sized> Drop for Weak<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+trait ArcEqIdent<T: ?Sized + PartialEq> {\n+    fn eq(&self, other: &Arc<T>) -> bool;\n+    fn ne(&self, other: &Arc<T>) -> bool;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n+    #[inline]\n+    default fn eq(&self, other: &Arc<T>) -> bool {\n+        **self == **other\n+    }\n+    #[inline]\n+    default fn ne(&self, other: &Arc<T>) -> bool {\n+        **self != **other\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n+    #[inline]\n+    fn eq(&self, other: &Arc<T>) -> bool {\n+        Arc::ptr_eq(self, other) || **self == **other\n+    }\n+\n+    #[inline]\n+    fn ne(&self, other: &Arc<T>) -> bool {\n+        !Arc::ptr_eq(self, other) && **self != **other\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n     /// Two `Arc`s are equal if their inner values are equal.\n     ///\n+    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n+    /// always equal.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1255,14 +1342,18 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// assert!(five == Arc::new(5));\n     /// ```\n+    #[inline]\n     fn eq(&self, other: &Arc<T>) -> bool {\n-        *(*self) == *(*other)\n+        ArcEqIdent::eq(self, other)\n     }\n \n     /// Inequality for two `Arc`s.\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n+    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n+    /// never unequal.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1272,10 +1363,12 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// assert!(five != Arc::new(6));\n     /// ```\n+    #[inline]\n     fn ne(&self, other: &Arc<T>) -> bool {\n-        *(*self) != *(*other)\n+        ArcEqIdent::ne(self, other)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     /// Partial comparison for two `Arc`s."}, {"sha": "ec589710216c3b048e416412d36563f338eeb11a", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,6 +10,8 @@\n \n use std::any::Any;\n use std::sync::{Arc, Weak};\n+use std::cell::RefCell;\n+use std::cmp::PartialEq;\n \n #[test]\n fn uninhabited() {\n@@ -53,3 +55,43 @@ fn trait_object() {\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n+\n+#[test]\n+fn float_nan_ne() {\n+    let x = Arc::new(std::f32::NAN);\n+    assert!(x != x);\n+    assert!(!(x == x));\n+}\n+\n+#[test]\n+fn partial_eq() {\n+    struct TestPEq (RefCell<usize>);\n+    impl PartialEq for TestPEq {\n+        fn eq(&self, other: &TestPEq) -> bool {\n+            *self.0.borrow_mut() += 1;\n+            *other.0.borrow_mut() += 1;\n+            true\n+        }\n+    }\n+    let x = Arc::new(TestPEq(RefCell::new(0)));\n+    assert!(x == x);\n+    assert!(!(x != x));\n+    assert_eq!(*x.0.borrow(), 4);\n+}\n+\n+#[test]\n+fn eq() {\n+    #[derive(Eq)]\n+    struct TestEq (RefCell<usize>);\n+    impl PartialEq for TestEq {\n+        fn eq(&self, other: &TestEq) -> bool {\n+            *self.0.borrow_mut() += 1;\n+            *other.0.borrow_mut() += 1;\n+            true\n+        }\n+    }\n+    let x = Arc::new(TestEq(RefCell::new(0)));\n+    assert!(x == x);\n+    assert!(!(x != x));\n+    assert_eq!(*x.0.borrow(), 0);\n+}"}, {"sha": "536291de8f0066b13041bbbb9d8d2c53e3705fdf", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -14,7 +14,7 @@ use std::collections::binary_heap::{Drain, PeekMut};\n use std::panic::{self, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-use rand::{thread_rng, Rng};\n+use rand::{thread_rng, seq::SliceRandom};\n \n #[test]\n fn test_iterator() {\n@@ -318,11 +318,11 @@ fn panic_safe() {\n     const NTEST: usize = 10;\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n-    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+    let data = (1..=DATASZ).collect::<Vec<_>>();\n \n     // since it's a fuzzy test, run several tries.\n     for _ in 0..NTEST {\n-        for i in 1..DATASZ + 1 {\n+        for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n \n             let mut panic_ords: Vec<_> = data.iter()\n@@ -332,7 +332,7 @@ fn panic_safe() {\n             let panic_item = PanicOrd(i, true);\n \n             // heapify the sane items\n-            rng.shuffle(&mut panic_ords);\n+            panic_ords.shuffle(&mut rng);\n             let mut heap = BinaryHeap::from(panic_ords);\n             let inner_data;\n "}, {"sha": "33ef13ab811ce80ee6c951375faa3c34b9007a5b", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -302,7 +302,7 @@ fn test_range() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range((Included(&i), Included(&j))).map(|(&k, &v)| (k, v));\n-            let mut pairs = (i..j + 1).map(|i| (i, i));\n+            let mut pairs = (i..=j).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);\n@@ -321,7 +321,7 @@ fn test_range_mut() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range_mut((Included(&i), Included(&j))).map(|(&k, &mut v)| (k, v));\n-            let mut pairs = (i..j + 1).map(|i| (i, i));\n+            let mut pairs = (i..=j).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);"}, {"sha": "146abd1b7508aa21acce24c74fdf590644c4cd6d", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,11 +13,12 @@\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n+#![feature(repeat_generic_slice)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(repeat_generic_slice)]\n+#![feature(vecdeque_rotate)]\n \n extern crate core;\n extern crate rand;"}, {"sha": "02e1dfe13bb360aab42e0d41ca1549a3feb62414", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,6 +10,8 @@\n \n use std::any::Any;\n use std::rc::{Rc, Weak};\n+use std::cell::RefCell;\n+use std::cmp::PartialEq;\n \n #[test]\n fn uninhabited() {\n@@ -53,3 +55,43 @@ fn trait_object() {\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n+\n+#[test]\n+fn float_nan_ne() {\n+    let x = Rc::new(std::f32::NAN);\n+    assert!(x != x);\n+    assert!(!(x == x));\n+}\n+\n+#[test]\n+fn partial_eq() {\n+    struct TestPEq (RefCell<usize>);\n+    impl PartialEq for TestPEq {\n+        fn eq(&self, other: &TestPEq) -> bool {\n+            *self.0.borrow_mut() += 1;\n+            *other.0.borrow_mut() += 1;\n+            true\n+        }\n+    }\n+    let x = Rc::new(TestPEq(RefCell::new(0)));\n+    assert!(x == x);\n+    assert!(!(x != x));\n+    assert_eq!(*x.0.borrow(), 4);\n+}\n+\n+#[test]\n+fn eq() {\n+    #[derive(Eq)]\n+    struct TestEq (RefCell<usize>);\n+    impl PartialEq for TestEq {\n+        fn eq(&self, other: &TestEq) -> bool {\n+            *self.0.borrow_mut() += 1;\n+            *other.0.borrow_mut() += 1;\n+            true\n+        }\n+    }\n+    let x = Rc::new(TestEq(RefCell::new(0)));\n+    assert!(x == x);\n+    assert!(!(x != x));\n+    assert_eq!(*x.0.borrow(), 0);\n+}"}, {"sha": "6f31e6ca1a1bdfe433ba5dfb6c5668bdf5fb9408", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,7 +18,7 @@ use std::sync::atomic::Ordering::Relaxed;\n use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n use std::thread;\n \n-use rand::{Rng, RngCore, thread_rng};\n+use rand::{Rng, RngCore, thread_rng, seq::SliceRandom};\n use rand::distributions::Standard;\n \n fn square(n: usize) -> usize {\n@@ -459,7 +459,7 @@ fn test_sort() {\n     for i in 0..v.len() {\n         v[i] = i as i32;\n     }\n-    v.sort_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n     v.sort();\n     for i in 0..v.len() {\n         assert_eq!(v[i], i as i32);\n@@ -484,7 +484,7 @@ fn test_sort_stability() {\n             // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n             // where the first item of each tuple is random, but\n             // the second item represents which occurrence of that\n-            // number this element is, i.e. the second elements\n+            // number this element is, i.e., the second elements\n             // will occur in sorted order.\n             let mut orig: Vec<_> = (0..len)\n                 .map(|_| {\n@@ -502,7 +502,7 @@ fn test_sort_stability() {\n             // This comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n             // will need to be ordered with increasing\n-            // counts... i.e. exactly asserting that this sort is\n+            // counts... i.e., exactly asserting that this sort is\n             // stable.\n             assert!(v.windows(2).all(|w| w[0] <= w[1]));\n \n@@ -1579,7 +1579,7 @@ macro_rules! test {\n             }).join();\n \n             // Check that the number of things dropped is exactly\n-            // what we expect (i.e. the contents of `v`).\n+            // what we expect (i.e., the contents of `v`).\n             for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n                 let count = c.load(Relaxed);\n                 assert!(count == 1,"}, {"sha": "9ad8ad1fc0775931341ea624b866536c63fe11ec", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1005,7 +1005,7 @@ fn test_escape_debug() {\n     // Note that there are subtleties with the number of backslashes\n     // on the left- and right-hand sides. In particular, Unicode code points\n     // are usually escaped with two backslashes on the right-hand side, as\n-    // they are escaped. However, when the character is unescaped (e.g. for\n+    // they are escaped. However, when the character is unescaped (e.g., for\n     // printable characters), only a single backslash appears (as the character\n     // itself appears in the debug string).\n     assert_eq!(\"abc\".escape_debug(), \"abc\");\n@@ -1378,7 +1378,7 @@ fn test_bool_from_str() {\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n-        for j in i+1..s.len() + 1 {\n+        for j in i+1..=s.len() {\n             assert!(s.contains(&s[i..j]));\n         }\n     }\n@@ -1514,19 +1514,19 @@ fn contains_weird_cases() {\n \n #[test]\n fn trim_ws() {\n-    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n                     \"a \\t  \");\n-    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n                \" \\t  a\");\n     assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n                     \"a \\t  \");\n     assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n                \" \\t  a\");\n     assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n                     \"a\");\n-    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n                          \"\");\n-    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n                \"\");\n     assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n                          \"\");"}, {"sha": "509195cd047d4846427df0efa53cc7ed9c29124e", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -79,6 +79,11 @@ fn test_reserve() {\n     assert!(v.capacity() >= 33)\n }\n \n+#[test]\n+fn test_zst_capacity() {\n+    assert_eq!(Vec::<()>::new().capacity(), usize::max_value());\n+}\n+\n #[test]\n fn test_extend() {\n     let mut v = Vec::new();"}, {"sha": "c8a6d86413ad6535a4ea8571908bf08e8e9da8cd", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 138, "deletions": 4, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -861,15 +861,15 @@ fn test_as_slices() {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_slices();\n-        let expected: Vec<_> = (0..i + 1).collect();\n+        let expected: Vec<_> = (0..=i).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_slices();\n-        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n+        let expected_left: Vec<_> = (-last..=j).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);\n@@ -889,15 +889,15 @@ fn test_as_mut_slices() {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_mut_slices();\n-        let expected: Vec<_> = (0..i + 1).collect();\n+        let expected: Vec<_> = (0..=i).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_mut_slices();\n-        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n+        let expected_left: Vec<_> = (-last..=j).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);\n@@ -1309,3 +1309,137 @@ fn test_try_reserve_exact() {\n     }\n \n }\n+\n+#[test]\n+fn test_rotate_nop() {\n+    let mut v: VecDeque<_> = (0..10).collect();\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(0);\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(10);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(0);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(10);\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(3);\n+    v.rotate_right(3);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(3);\n+    v.rotate_left(3);\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(6);\n+    v.rotate_right(6);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(6);\n+    v.rotate_left(6);\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(3);\n+    v.rotate_left(7);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(4);\n+    v.rotate_right(6);\n+    assert_unchanged(&v);\n+\n+    v.rotate_left(1);\n+    v.rotate_left(2);\n+    v.rotate_left(3);\n+    v.rotate_left(4);\n+    assert_unchanged(&v);\n+\n+    v.rotate_right(1);\n+    v.rotate_right(2);\n+    v.rotate_right(3);\n+    v.rotate_right(4);\n+    assert_unchanged(&v);\n+\n+    fn assert_unchanged(v: &VecDeque<i32>) {\n+        assert_eq!(v, &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+    }\n+}\n+\n+#[test]\n+fn test_rotate_left_parts() {\n+    let mut v: VecDeque<_> = (1..=7).collect();\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[3, 4, 5, 6, 7, 1][..], &[2][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[5, 6, 7, 1][..], &[2, 3, 4][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[7, 1][..], &[2, 3, 4, 5, 6][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[2, 3, 4, 5, 6, 7, 1][..], &[][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[4, 5, 6, 7, 1, 2][..], &[3][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[6, 7, 1, 2][..], &[3, 4, 5][..]));\n+    v.rotate_left(2);\n+    assert_eq!(v.as_slices(), (&[1, 2][..], &[3, 4, 5, 6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rotate_right_parts() {\n+    let mut v: VecDeque<_> = (1..=7).collect();\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[6, 7][..], &[1, 2, 3, 4, 5][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[4, 5, 6, 7][..], &[1, 2, 3][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[2, 3, 4, 5, 6, 7][..], &[1][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[7, 1, 2, 3, 4, 5, 6][..], &[][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[5, 6][..], &[7, 1, 2, 3, 4][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[3, 4, 5, 6][..], &[7, 1, 2][..]));\n+    v.rotate_right(2);\n+    assert_eq!(v.as_slices(), (&[1, 2, 3, 4, 5, 6][..], &[7][..]));\n+}\n+\n+#[test]\n+fn test_rotate_left_random() {\n+    let shifts = [\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n+        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n+        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+    ];\n+    let n = 12;\n+    let mut v: VecDeque<_> = (0..n).collect();\n+    let mut total_shift = 0;\n+    for shift in shifts.iter().cloned() {\n+        v.rotate_left(shift);\n+        total_shift += shift;\n+        for i in 0..n {\n+            assert_eq!(v[i], (i + total_shift) % n);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_rotate_right_random() {\n+    let shifts = [\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n+        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n+        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+    ];\n+    let n = 12;\n+    let mut v: VecDeque<_> = (0..n).collect();\n+    let mut total_shift = 0;\n+    for shift in shifts.iter().cloned() {\n+        v.rotate_right(shift);\n+        total_shift += shift;\n+        for i in 0..n {\n+            assert_eq!(v[(i + total_shift) % n], i);\n+        }\n+    }\n+}"}, {"sha": "b78e71331a97f66457351516e6b579863137f4d7", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -213,7 +213,7 @@ use raw_vec::RawVec;\n /// about its design. This ensures that it's as low-overhead as possible in\n /// the general case, and can be correctly manipulated in primitive ways\n /// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n-/// If additional type parameters are added (e.g. to support custom allocators),\n+/// If additional type parameters are added (e.g., to support custom allocators),\n /// overriding their defaults may change the behavior.\n ///\n /// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n@@ -1241,8 +1241,6 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vec_resize_with)]\n-    ///\n     /// let mut vec = vec![1, 2, 3];\n     /// vec.resize_with(5, Default::default);\n     /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n@@ -1255,7 +1253,7 @@ impl<T> Vec<T> {\n     ///\n     /// [`resize`]: #method.resize\n     /// [`Clone`]: ../../std/clone/trait.Clone.html\n-    #[unstable(feature = \"vec_resize_with\", issue = \"41758\")]\n+    #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n     pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n         where F: FnMut() -> T\n     {"}, {"sha": "fe74674f6e4be76d47b66f67d529ebf4186f4eb1", "filename": "src/libcompiler_builtins", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=b4a306c1e648c84f289c63e984941b7faad10af1", "patch": "@@ -1 +0,0 @@\n-Subproject commit fe74674f6e4be76d47b66f67d529ebf4186f4eb1"}, {"sha": "fa2ab11243b6ce723a4e0a72f74f6d8fe43d84cc", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -20,7 +20,7 @@ name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n \n [dev-dependencies]\n-rand = \"0.5\"\n+rand = \"0.6\"\n \n [features]\n # Make panics and failed asserts immediately abort without formatting any message"}, {"sha": "8db7d33bdecaa1a3490b2c490b24ff73d4c6f639", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -69,7 +69,7 @@ impl Layout {\n     /// * `align` must be a power of two,\n     ///\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n-    ///    must not overflow (i.e. the rounded value must be less than\n+    ///    must not overflow (i.e., the rounded value must be less than\n     ///    `usize::MAX`).\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n@@ -177,7 +177,7 @@ impl Layout {\n     /// to ensure that the following address will satisfy `align`\n     /// (measured in bytes).\n     ///\n-    /// E.g. if `self.size()` is 9, then `self.padding_needed_for(4)`\n+    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n     /// returns 3, because that is the minimum number of bytes of\n     /// padding required to get a 4-aligned address (assuming that the\n     /// corresponding memory block starts at a 4-aligned address).\n@@ -455,7 +455,7 @@ pub unsafe trait GlobalAlloc {\n     /// if the caller does not ensure that `layout` has non-zero size.\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// The allocated block of memory may or may not be initialized.\n@@ -550,10 +550,10 @@ pub unsafe trait GlobalAlloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n@@ -616,7 +616,7 @@ pub unsafe trait GlobalAlloc {\n ///   whether to return `Err`, or to return `Ok` with some pointer.\n ///\n /// * If an `Alloc` implementation chooses to return `Ok` in this\n-///   case (i.e. the pointer denotes a zero-sized inaccessible block)\n+///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n ///   then that returned pointer must be considered \"currently\n ///   allocated\". On such an allocator, *all* methods that take\n ///   currently-allocated pointers as inputs must accept these\n@@ -651,7 +651,7 @@ pub unsafe trait GlobalAlloc {\n ///\n ///  * if a layout `k` fits a memory block (denoted by `ptr`)\n ///    currently allocated via an allocator `a`, then it is legal to\n-///    use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.\n+///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n ///\n /// # Unsafety\n ///\n@@ -673,7 +673,7 @@ pub unsafe trait Alloc {\n \n     // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n-    // e.g. in C, `malloc` of 0 will either return a null pointer or a\n+    // e.g., in C, `malloc` of 0 will either return a null pointer or a\n     // unique pointer, but will not have arbitrary undefined\n     // behavior.\n     // However in jemalloc for example,\n@@ -688,7 +688,7 @@ pub unsafe trait Alloc {\n     ///\n     /// The returned block of storage may or may not have its contents\n     /// initialized. (Extension subtraits might restrict this\n-    /// behavior, e.g. to ensure initialization to particular sets of\n+    /// behavior, e.g., to ensure initialization to particular sets of\n     /// bit patterns.)\n     ///\n     /// # Safety\n@@ -697,7 +697,7 @@ pub unsafe trait Alloc {\n     /// if the caller does not ensure that `layout` has non-zero size.\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n@@ -803,10 +803,10 @@ pub unsafe trait Alloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors"}, {"sha": "f521ab994cd9fefbafb8575409a3b5c92992df03", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -126,7 +126,7 @@ impl fmt::Debug for dyn Any {\n     }\n }\n \n-// Ensure that the result of e.g. joining a thread can be printed and\n+// Ensure that the result of e.g., joining a thread can be printed and\n // hence used with `unwrap`. May eventually no longer be needed if\n // dispatch works with upcasting.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b0aca658343702fb67cf6da3dc65494fa8654621", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -282,6 +282,12 @@ bench_sums! {\n     (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n }\n \n+bench_sums! {\n+    bench_cycle_take_sum,\n+    bench_cycle_take_ref_sum,\n+    (0i64..10000).cycle().take(1000000)\n+}\n+\n // Checks whether Skip<Zip<A,B>> is as fast as Zip<Skip<A>, Skip<B>>, from\n // https://users.rust-lang.org/t/performance-difference-between-iterator-zip-and-skip-order/15743\n #[bench]"}, {"sha": "0a16c92928d444c46fcec8752b652d9d29f22603", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -97,7 +97,7 @@\n //! ## Implementation details of logically-immutable methods\n //!\n //! Occasionally it may be desirable not to expose in an API that there is mutation happening\n-//! \"under the hood\". This may be because logically the operation is immutable, but e.g. caching\n+//! \"under the hood\". This may be because logically the operation is immutable, but e.g., caching\n //! forces the implementation to perform mutation; or because you must employ mutation to implement\n //! a trait method that was originally defined to take `&self`.\n //!\n@@ -1227,7 +1227,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum\n+    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail."}, {"sha": "e07a0f5d712b03cf75332e53925cdbbc4ac2657a", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -131,7 +131,7 @@ pub struct EscapeUnicode {\n     state: EscapeUnicodeState,\n \n     // The index of the next hex digit to be printed (0 if none),\n-    // i.e. the number of remaining hex digits to be printed;\n+    // i.e., the number of remaining hex digits to be printed;\n     // increasing from the least significant digit: 0x543210\n     hex_digit_idx: usize,\n }"}, {"sha": "225ea3de9cd686f5f40fa6e8898156218dbb05f4", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,7 +13,7 @@\n //! In Rust, some simple types are \"implicitly copyable\" and when you\n //! assign them or pass them as arguments, the receiver will get a copy,\n //! leaving the original value in place. These types do not require\n-//! allocation to copy and do not have finalizers (i.e. they do not\n+//! allocation to copy and do not have finalizers (i.e., they do not\n //! contain owned boxes or implement [`Drop`]), so the compiler considers\n //! them cheap and safe to copy. For other types copies must be made\n //! explicitly, by convention implementing the [`Clone`] trait and calling\n@@ -93,10 +93,10 @@\n /// In addition to the [implementors listed below][impls],\n /// the following types also implement `Clone`:\n ///\n-/// * Function item types (i.e. the distinct types defined for each function)\n-/// * Function pointer types (e.g. `fn() -> i32`)\n-/// * Array types, for all sizes, if the item type also implements `Clone` (e.g. `[i32; 123456]`)\n-/// * Tuple types, if each component also implements `Clone` (e.g. `()`, `(i32, bool)`)\n+/// * Function item types (i.e., the distinct types defined for each function)\n+/// * Function pointer types (e.g., `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Clone` (e.g., `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Clone` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Clone` themselves.\n ///   Note that variables captured by shared reference always implement `Clone`"}, {"sha": "2d4813718f41a0f92d97eb57cc538e4131186fba", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -327,7 +327,8 @@ pub trait Into<T>: Sized {\n /// An example usage for error handling:\n ///\n /// ```\n-/// use std::io::{self, Read};\n+/// use std::fs;\n+/// use std::io;\n /// use std::num;\n ///\n /// enum CliError {\n@@ -348,9 +349,7 @@ pub trait Into<T>: Sized {\n /// }\n ///\n /// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n-///     let mut file = std::fs::File::open(\"test\")?;\n-///     let mut contents = String::new();\n-///     file.read_to_string(&mut contents)?;\n+///     let mut contents = fs::read_to_string(&file_name)?;\n ///     let num: i32 = contents.trim().parse()?;\n ///     Ok(num)\n /// }"}, {"sha": "899fae909467a29783bf6ef78846742baee5a5d8", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1,7 +1,6 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n \n #![allow(non_camel_case_types)]\n-#![cfg_attr(stage0, allow(dead_code))]\n \n //! Utilities related to FFI bindings.\n \n@@ -18,7 +17,7 @@ use ::fmt;\n ///\n /// [`!`]: ../../std/primitive.never.html\n /// [pointer]: ../../std/primitive.pointer.html\n-// NB: For LLVM to recognize the void pointer type and by extension\n+// N.B., for LLVM to recognize the void pointer type and by extension\n //     functions like malloc(), we need to have it represented as i8* in\n //     LLVM bitcode. The enum used here ensures this and prevents misuse\n //     of the \"raw\" type by only having private variants.. We need two\n@@ -45,6 +44,7 @@ impl fmt::Debug for c_void {\n /// Basic implementation of a `va_list`.\n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n               not(target_arch = \"x86_64\")),\n+          all(target_arch = \"aarch4\", target_os = \"ios\"),\n           windows))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n@@ -122,7 +122,6 @@ struct VaListImpl {\n                      all supported platforms\",\n            issue = \"27745\")]\n #[repr(transparent)]\n-#[cfg(not(stage0))]\n pub struct VaList<'a>(&'a mut VaListImpl);\n \n // The VaArgSafe trait needs to be used in public interfaces, however, the trait\n@@ -172,7 +171,6 @@ impl<T> sealed_trait::VaArgSafe for *mut T {}\n            issue = \"27745\")]\n impl<T> sealed_trait::VaArgSafe for *const T {}\n \n-#[cfg(not(stage0))]\n impl<'a> VaList<'a> {\n     /// Advance to the next arg.\n     #[unstable(feature = \"c_variadic\",\n@@ -192,6 +190,7 @@ impl<'a> VaList<'a> {\n             where F: for<'copy> FnOnce(VaList<'copy>) -> R {\n         #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                       not(target_arch = \"x86_64\")),\n+                  all(target_arch = \"aarch4\", target_os = \"ios\"),\n                   windows))]\n         let mut ap = va_copy(self);\n         #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n@@ -206,7 +205,6 @@ impl<'a> VaList<'a> {\n     }\n }\n \n-#[cfg(not(stage0))]\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`."}, {"sha": "8e0caa5ae330deb3f771b2055bae935b0aec9542", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -609,10 +609,15 @@ pub trait Debug {\n /// println!(\"The origin is: {}\", origin);\n /// ```\n #[rustc_on_unimplemented(\n+    on(\n+        _Self=\"std::path::Path\",\n+        label=\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n+        note=\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n+              as they may contain non-Unicode data\"\n+    ),\n     message=\"`{Self}` doesn't implement `{Display}`\",\n     label=\"`{Self}` cannot be formatted with the default formatter\",\n-    note=\"in format strings you may be able to use `{{:?}}` \\\n-          (or {{:#?}} for pretty-print) instead\",\n+    note=\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\",\n )]\n #[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1381,7 +1386,7 @@ impl<'a> Formatter<'a> {\n         for part in formatted.parts {\n             match *part {\n                 flt2dec::Part::Zero(mut nzeroes) => {\n-                    const ZEROES: &'static str = // 64 zeroes\n+                    const ZEROES: &str = // 64 zeroes\n                         \"0000000000000000000000000000000000000000000000000000000000000000\";\n                     while nzeroes > ZEROES.len() {\n                         self.buf.write_str(ZEROES)?;"}, {"sha": "5dee1d6dd3a39dcb66115401481d41e23eb7341c", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -33,6 +33,7 @@ use task::{Poll, LocalWaker};\n ///\n /// When using a future, you generally won't call `poll` directly, but instead\n /// `await!` the value.\n+#[must_use]\n pub trait Future {\n     /// The result of the `Future`.\n     type Output;"}, {"sha": "3e59ee1f8e5f5efdc243fc4afe5c1d3586cd9c1d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -408,7 +408,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n \n /// A trait for creating instances of [`Hasher`].\n ///\n-/// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create\n+/// A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create\n /// [`Hasher`]s for each key such that they are hashed independently of one\n /// another, since [`Hasher`]s contain state.\n ///"}, {"sha": "0bfdd937abd630c1431100f9aa5139b7b6be8b0c", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -24,7 +24,7 @@ use intrinsics;\n /// therefore will eliminate all branches that reach to a call to\n /// `unreachable_unchecked()`.\n ///\n-/// Like all instances of UB, if this assumption turns out to be wrong, i.e. the\n+/// Like all instances of UB, if this assumption turns out to be wrong, i.e., the\n /// `unreachable_unchecked()` call is actually reachable among all possible\n /// control flow, the compiler will apply the wrong optimization strategy, and\n /// may sometimes even corrupt seemingly unrelated code, causing"}, {"sha": "b94d5b4adcf0986cb4cf6d763638fe11f7d894f4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -52,7 +52,7 @@\n pub use ptr::drop_in_place;\n \n extern \"rust-intrinsic\" {\n-    // NB: These intrinsics take raw pointers because they mutate aliased\n+    // N.B., these intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -635,7 +635,7 @@ extern \"rust-intrinsic\" {\n     /// Tells LLVM that this point in the code is not reachable, enabling\n     /// further optimizations.\n     ///\n-    /// NB: This is very different from the `unreachable!()` macro: Unlike the\n+    /// N.B., this is very different from the `unreachable!()` macro: Unlike the\n     /// macro, which panics when it is executed, it is *undefined behavior* to\n     /// reach code marked with this function.\n     ///\n@@ -718,7 +718,6 @@ extern \"rust-intrinsic\" {\n     pub fn uninit<T>() -> T;\n \n     /// Moves a value out of scope without running drop glue.\n-    #[cfg(not(stage0))]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1476,14 +1475,12 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_left` method. For example,\n     /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n-    #[cfg(not(stage0))]\n     pub fn rotate_left<T>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `rotate_right` method. For example,\n     /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n-    #[cfg(not(stage0))]\n     pub fn rotate_right<T>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits."}, {"sha": "d0b0fd1ab31715b9aedd5e2f4787bff25f8eebbc", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -87,7 +87,7 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n     on(\n         _Self=\"[]\",\n         label=\"borrow the array with `&` or call `.iter()` on it to iterate over it\",\n-        note=\"arrays are not an iterators, but slices like the following are: `&[1, 2, 3]`\"\n+        note=\"arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\"\n     ),\n     on(\n         _Self=\"{integral}\",\n@@ -98,6 +98,7 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item=()>) {}\n     message=\"`{Self}` is not an iterator\"\n )]\n #[doc(spotlight)]\n+#[must_use]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -154,7 +155,7 @@ pub trait Iterator {\n     ///\n     /// `size_hint()` is primarily intended to be used for optimizations such as\n     /// reserving space for the elements of the iterator, but must not be\n-    /// trusted to e.g. omit bounds checks in unsafe code. An incorrect\n+    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n     /// implementation of `size_hint()` should not lead to memory safety\n     /// violations.\n     ///"}, {"sha": "aa130754f83042e3260e52e617ca879d9e28a024", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -429,6 +429,9 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth_back(n) }\n+\n     fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -461,6 +464,9 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n \n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> { self.iter.nth(n) }\n+\n     fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n@@ -702,7 +708,9 @@ unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n     }\n \n     #[inline]\n-    fn may_have_side_effect() -> bool { false }\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n@@ -1953,18 +1961,11 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // FIXME(#43234): merge these when borrow-checking gets better.\n-        if n == 0 {\n-            match self.peeked.take() {\n-                Some(v) => v,\n-                None => self.iter.nth(n),\n-            }\n-        } else {\n-            match self.peeked.take() {\n-                Some(None) => None,\n-                Some(Some(_)) => self.iter.nth(n - 1),\n-                None => self.iter.nth(n),\n-            }\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n         }\n     }\n \n@@ -2063,14 +2064,8 @@ impl<I: Iterator> Peekable<I> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&mut self) -> Option<&I::Item> {\n-        if self.peeked.is_none() {\n-            self.peeked = Some(self.iter.next());\n-        }\n-        match self.peeked {\n-            Some(Some(ref value)) => Some(value),\n-            Some(None) => None,\n-            _ => unreachable!(),\n-        }\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n     }\n }\n \n@@ -2207,8 +2202,12 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n     }\n \n     #[inline]\n@@ -2419,6 +2418,10 @@ impl<I> Iterator for Take<I> where I: Iterator{\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = cmp::min(lower, self.n);"}, {"sha": "727a60e3596944d0294acb80952268f948c6d7fe", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -427,6 +427,62 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n+    /// Returns the `n`th element from the end of the iterator.\n+    ///\n+    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n+    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n+    /// the end, `nth_back(1)` the second, and so on.\n+    ///\n+    /// Note that all elements between the end and the returned element will be\n+    /// consumed, including the returned element. This also means that calling\n+    /// `nth_back(0)` multiple times on the same iterator will return different\n+    /// elements.\n+    ///\n+    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n+    /// iterator.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n+    /// ```\n+    ///\n+    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth_back(1), Some(&2));\n+    /// assert_eq!(iter.nth_back(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n + 1` elements:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(10), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_nth_back\", issue = \"56995\")]\n+    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n+        for x in self.rev() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n     /// This is the reverse version of [`try_fold()`]: it takes elements\n     /// starting from the back of the iterator.\n     ///\n@@ -461,8 +517,11 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok=B>\n     {\n         let mut accum = init;\n         while let Some(x) = self.next_back() {\n@@ -524,8 +583,10 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B where\n-        Self: Sized, F: FnMut(B, Self::Item) -> B,\n+    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n     {\n         self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n     }\n@@ -574,7 +635,8 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n@@ -587,7 +649,12 @@ pub trait DoubleEndedIterator: Iterator {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n-    fn next_back(&mut self) -> Option<I::Item> { (**self).next_back() }\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        (**self).next_back()\n+    }\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        (**self).nth_back(n)\n+    }\n }\n \n /// An iterator that knows its exact length.\n@@ -770,7 +837,7 @@ pub trait Product<A = Self>: Sized {\n     fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n }\n \n-// NB: explicitly use Add and Mul here to inherit overflow checks\n+// N.B., explicitly use Add and Mul here to inherit overflow checks\n macro_rules! integer_sum_product {\n     (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n         #[$attr]"}, {"sha": "2124458dc559720b90457b8c1d62cafe64c15b86", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -71,6 +71,7 @@\n \n #![no_core]\n #![deny(missing_docs)]\n+#![deny(intra_doc_link_resolution_failure)]\n #![deny(missing_debug_implementations)]\n \n #![feature(allow_internal_unstable)]\n@@ -92,6 +93,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(bind_by_move_pattern_guards)]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n@@ -120,7 +122,6 @@\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n-#![feature(const_let)]\n #![feature(const_int_rotate)]\n #![feature(const_int_wrapping)]\n #![feature(const_int_sign)]\n@@ -250,9 +251,7 @@ macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*)\n #[path = \"../stdsimd/coresimd/mod.rs\"]\n #[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n-#[cfg(not(stage0))] // allow changes to how stdsimd works in stage0\n mod coresimd;\n \n #[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n-#[cfg(not(stage0))]\n pub use coresimd::arch;"}, {"sha": "5ba0e949483ae91593a434d19a893c4f9d9f4d2f", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -238,6 +238,10 @@ macro_rules! debug_assert_ne {\n /// with converting downstream errors.\n ///\n /// The `?` operator was added to replace `try!` and should be used instead.\n+/// Furthermore, `try` is a reserved word in Rust 2018, so if you must use\n+/// it, you will need to use the [raw-identifier syntax][ris]: `r#try`.\n+///\n+/// [ris]: https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html\n ///\n /// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n /// expression has the value of the wrapped value."}, {"sha": "d3d16127ed5fe117a42b78e8982cd2122defaa89", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -274,10 +274,10 @@ pub trait Unsize<T: ?Sized> {\n /// In addition to the [implementors listed below][impls],\n /// the following types also implement `Copy`:\n ///\n-/// * Function item types (i.e. the distinct types defined for each function)\n-/// * Function pointer types (e.g. `fn() -> i32`)\n-/// * Array types, for all sizes, if the item type also implements `Copy` (e.g. `[i32; 123456]`)\n-/// * Tuple types, if each component also implements `Copy` (e.g. `()`, `(i32, bool)`)\n+/// * Function item types (i.e., the distinct types defined for each function)\n+/// * Function pointer types (e.g., `fn() -> i32`)\n+/// * Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)\n+/// * Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)\n /// * Closure types, if they capture no value from the environment\n ///   or if all such captured values implement `Copy` themselves.\n ///   Note that variables captured by shared reference always implement `Copy`\n@@ -596,7 +596,7 @@ mod impls {\n /// This affects, for example, whether a `static` of that type is\n /// placed in read-only static memory or writable static memory.\n #[lang = \"freeze\"]\n-unsafe auto trait Freeze {}\n+pub(crate) unsafe auto trait Freeze {}\n \n impl<T: ?Sized> !Freeze for UnsafeCell<T> {}\n unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n@@ -640,15 +640,15 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub auto trait Unpin {}\n \n-/// A type which does not implement `Unpin`.\n+/// A marker type which does not implement `Unpin`.\n ///\n-/// If a type contains a `Pinned`, it will not implement `Unpin` by default.\n+/// If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-pub struct Pinned;\n+pub struct PhantomPinned;\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl !Unpin for Pinned {}\n+impl !Unpin for PhantomPinned {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<'a, T: ?Sized + 'a> Unpin for &'a T {}"}, {"sha": "87dde9066019cae96b8aca6cc763fa4257e8d9ff", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -149,7 +149,6 @@ pub fn forget<T>(t: T) {\n ///\n /// [`forget`]: fn.forget.html\n #[inline]\n-#[cfg(not(stage0))]\n #[unstable(feature = \"forget_unsized\", issue = \"0\")]\n pub fn forget_unsized<T: ?Sized>(t: T) {\n     unsafe { intrinsics::forget(t) }\n@@ -305,7 +304,7 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n+/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n@@ -531,6 +530,12 @@ pub unsafe fn zeroed<T>() -> T {\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n+/// If you partially initialize an array, you may need to use\n+/// [`ptr::drop_in_place`][drop_in_place] to remove the elements you have fully\n+/// initialized followed by [`mem::forget`][mem_forget] to prevent drop running\n+/// on the array. If a partially allocated array is dropped this will lead to\n+/// undefined behaviour.\n+///\n /// # Examples\n ///\n /// Here's how to safely initialize an array of [`Vec`]s.\n@@ -584,11 +589,44 @@ pub unsafe fn zeroed<T>() -> T {\n /// println!(\"{:?}\", &data[0]);\n /// ```\n ///\n+/// This example shows how to handle partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+/// let mut data: [String; 1000];\n+///\n+/// unsafe {\n+///     data = mem::uninitialized();\n+///\n+///     for elem in &mut data[0..500] {\n+///         ptr::write(elem, String::from(\"hello\"));\n+///         data_len += 1;\n+///     }\n+///\n+///     // For each item in the array, drop if we allocated it.\n+///     for i in &mut data[0..data_len] {\n+///         ptr::drop_in_place(i);\n+///     }\n+/// }\n+/// // Forget the data. If this is allowed to drop, you may see a crash such as:\n+/// // 'mem_uninit_test(2457,0x7fffb55dd380) malloc: *** error for object\n+/// // 0x7ff3b8402920: pointer being freed was not allocated'\n+/// mem::forget(data);\n+/// ```\n+///\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n /// [`vec!`]: ../../std/macro.vec.html\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n /// [write]: ../ptr/fn.write.html\n+/// [drop_in_place]: ../ptr/fn.drop_in_place.html\n+/// [mem_zeroed]: fn.zeroed.html\n+/// [mem_forget]: fn.forget.html\n /// [copy]: ../intrinsics/fn.copy.html\n /// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n /// [`Drop`]: ../ops/trait.Drop.html\n@@ -985,6 +1023,9 @@ impl<T> ManuallyDrop<T> {\n     ///\n     /// This function semantically moves out the contained value without preventing further usage.\n     /// It is up to the user of this method to ensure that this container is not used again.\n+    ///\n+    /// [`ManuallyDrop::drop`]: #method.drop\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n     #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n     #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n     #[inline]\n@@ -1119,7 +1160,7 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n-    // to uninitialized data (e.g. in `libcore/fmt/float.rs`).  We should make\n+    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]"}, {"sha": "a89c6ca60cbea434f1eb023d4b525db292f215dc", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -11,14 +11,23 @@\n //! Exposes the NonZero lang item which provides optimization hints.\n \n use ops::{CoerceUnsized, DispatchFromDyn};\n+use marker::Freeze;\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n #[rustc_layout_scalar_valid_range_start(1)]\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[derive(Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n-pub(crate) struct NonZero<T>(pub(crate) T);\n+pub(crate) struct NonZero<T: Freeze>(pub(crate) T);\n \n-impl<T: CoerceUnsized<U>, U> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+// Do not call `T::clone` as theoretically it could turn the field into `0`\n+// invalidating `NonZero`'s invariant.\n+impl<T: Copy + Freeze> Clone for NonZero<T> {\n+    fn clone(&self) -> Self {\n+        unsafe { NonZero(self.0) }\n+    }\n+}\n \n-impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<NonZero<U>> for NonZero<T> {}\n+impl<T: CoerceUnsized<U> + Freeze, U: Freeze> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+\n+impl<T: DispatchFromDyn<U> + Freeze, U: Freeze> DispatchFromDyn<NonZero<U>> for NonZero<T> {}"}, {"sha": "2bfb49c0682bb1b62df46ac3a51d5d294f930207", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -183,7 +183,7 @@ macro_rules! define_bignum {\n                 let nonzero = &digits[..end];\n \n                 if nonzero.is_empty() {\n-                    // There are no non-zero digits, i.e. the number is zero.\n+                    // There are no non-zero digits, i.e., the number is zero.\n                     return 0;\n                 }\n                 // This could be optimized with leading_zeros() and bit shifts, but that's"}, {"sha": "c3a983d0f0e5b188408cfdb92bfc4a90204fe9ad", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -61,9 +61,9 @@ mod fpu_precision {\n     ///\n     /// The only field which is relevant for the following code is PC, Precision Control. This\n     /// field determines the precision of the operations performed by the  FPU. It can be set to:\n-    ///  - 0b00, single precision i.e. 32-bits\n-    ///  - 0b10, double precision i.e. 64-bits\n-    ///  - 0b11, double extended precision i.e. 80-bits (default state)\n+    ///  - 0b00, single precision i.e., 32-bits\n+    ///  - 0b10, double precision i.e., 64-bits\n+    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n     /// The 0b01 value is reserved and should not be used.\n     pub struct FPUControlWord(u16);\n "}, {"sha": "18c30e29c796743e999be3b59e1e6bd3a55766b1", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -349,7 +349,7 @@ pub fn prev_float<T: RawFloat>(x: T) -> T {\n }\n \n // Find the smallest floating point number strictly larger than the argument.\n-// This operation is saturating, i.e. next_float(inf) == inf.\n+// This operation is saturating, i.e., next_float(inf) == inf.\n // Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n // However, like all other code here, it does not deal with NaN and negative numbers.\n pub fn next_float<T: RawFloat>(x: T) -> T {"}, {"sha": "097240e58ae50b6574f87a31911009bc0f462d42", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -23,7 +23,7 @@ representation `V = 0.d[0..n-1] * 10^k` such that:\n - `d[0]` is non-zero.\n \n - It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n-  Furthermore it is shortest such one, i.e. there is no representation\n+  Furthermore it is shortest such one, i.e., there is no representation\n   with less than `n` digits that is correctly rounded.\n \n - It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n@@ -398,7 +398,7 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n-/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_shortest` should be the underlying digit-generation function.\n@@ -591,7 +591,7 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// given number of fractional digits. The result is stored to the supplied parts\n /// array while utilizing given byte buffer as a scratch. `upper` is currently\n /// unused but left for the future decision to change the case of non-finite values,\n-/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n /// (which can be an empty string if no sign is rendered).\n ///\n /// `format_exact` should be the underlying digit-generation function."}, {"sha": "cda0773afbd5b810da08ce6b8f928457189db848", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -81,11 +81,11 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n     // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n     //\n     // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n-    // also we assume that at least one digit is generated, i.e. `mant` cannot be zero too.\n+    // also we assume that at least one digit is generated, i.e., `mant` cannot be zero too.\n     //\n     // this also means that any number between `low = (mant - minus) * 2^exp` and\n     // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n-    // with bounds included when the original mantissa was even (i.e. `!mant_was_odd`).\n+    // with bounds included when the original mantissa was even (i.e., `!mant_was_odd`).\n \n     assert!(d.mant > 0);\n     assert!(d.minus > 0);\n@@ -172,7 +172,7 @@ pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp\n         // - `high - v = plus / scale * 10^(k-n)`\n         //\n         // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n-        // i.e. `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n+        // i.e., `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n         // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n         // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n         //\n@@ -304,7 +304,7 @@ pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usi\n \n     // rounding up if we stop in the middle of digits\n     // if the following digits are exactly 5000..., check the prior digit and try to\n-    // round to even (i.e. avoid rounding up when the prior digit is even).\n+    // round to even (i.e., avoid rounding up when the prior digit is even).\n     let order = mant.cmp(scale.mul_small(5));\n     if order == Ordering::Greater || (order == Ordering::Equal &&\n                                       (len == 0 || buf[len-1] & 1 == 1)) {"}, {"sha": "3e76feca885bc1bfdaefd8aefd21609a0dd1cc0b", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -242,7 +242,7 @@ pub fn format_shortest_opt(d: &Decoded,\n     //\n     // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n     // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n-    // (e.g. `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n+    // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n     // the algorithm relies on the later verification phase to exclude `y`.\n     let delta1 = plus1 - minus1;\n //  let delta1int = (delta1 >> e) as usize; // only for explanation\n@@ -362,19 +362,19 @@ pub fn format_shortest_opt(d: &Decoded,\n             // proceed, but we then have at least one valid representation known to be closest to\n             // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n             //\n-            // TC1: `w(n) <= v + 1 ulp`, i.e. this is the last repr that can be the closest one.\n+            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n             // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n             // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n             // overflow on the calculation of `plus1w(n)`.\n             //\n-            // TC2: `w(n+1) < minus1`, i.e. the next repr definitely does not round to `v`.\n+            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n             // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n             // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n             // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n             // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n             // `threshold - plus1w(n) < 10^kappa` instead.\n             //\n-            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e. the next repr is\n+            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n             // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n             // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n             // `z(n) > 0`. we have two cases to consider:\n@@ -384,7 +384,7 @@ pub fn format_shortest_opt(d: &Decoded,\n             // - when `z(n+1) < 0`:\n             //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n             //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n-            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e. `plus1v_up - plus1w(n) >=\n+            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n             //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n             //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n             //     combined with TC3a.\n@@ -414,7 +414,7 @@ pub fn format_shortest_opt(d: &Decoded,\n \n         // now we have the closest representation to `v` between `plus1` and `minus1`.\n         // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n-        // i.e. `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n+        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n         // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n         if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp {\n             Some((buf.len(), exp))\n@@ -675,7 +675,7 @@ pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n             return Some((len, exp));\n         }\n \n-        // otherwise we are doomed (i.e. some values between `v - 1 ulp` and `v + 1 ulp` are\n+        // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n         // rounding down and others are rounding up) and give up.\n         None\n     }"}, {"sha": "7ffb81901c619d87d88f13407978431782b5b096", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 106, "deletions": 107, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -78,7 +78,7 @@ assert_eq!(size_of::<Option<std::num::\", stringify!($Ty), \">>(), size_of::<\", st\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n-                        Some($Ty(NonZero(n)))\n+                        Some($Ty(unsafe { NonZero(n) }))\n                     } else {\n                         None\n                     }\n@@ -673,7 +673,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`,\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n returning `None` if `rhs == 0` or the division results in overflow.\n \n # Examples\n@@ -683,17 +683,17 @@ Basic usage:\n ```\n #![feature(euclidean_division)]\n assert_eq!((\", stringify!($SelfT),\n-\"::min_value() + 1).checked_div_euc(-1), Some(\", stringify!($Max), \"));\n-assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euc(-1), None);\n-assert_eq!((1\", stringify!($SelfT), \").checked_div_euc(0), None);\n+\"::min_value() + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\n+assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n+assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n-                    Some(self.div_euc(rhs))\n+                    Some(self.div_euclid(rhs))\n                 }\n             }\n         }\n@@ -726,8 +726,8 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None` if\n-`rhs == 0` or the division results in overflow.\n+            concat!(\"Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n+if `rhs == 0` or the division results in overflow.\n \n # Examples\n \n@@ -737,17 +737,17 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n-assert_eq!(\", stringify!($SelfT), \"::MIN.checked_mod_euc(-1), None);\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n+assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                     None\n                 } else {\n-                    Some(self.mod_euc(rhs))\n+                    Some(self.rem_euclid(rhs))\n                 }\n             }\n         }\n@@ -1089,7 +1089,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`,\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n wrapping around at the boundary of the type.\n \n Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n@@ -1106,13 +1106,13 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n-assert_eq!((-128i8).wrapping_div_euc(-1), -128);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n+assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n-                self.overflowing_div_euc(rhs).0\n+            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_div_euclid(rhs).0\n             }\n         }\n \n@@ -1145,8 +1145,8 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`, wrapping around at the\n-boundary of the type.\n+            concat!(\"Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n+at the boundary of the type.\n \n Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n for the type). In this case, this method returns 0.\n@@ -1161,13 +1161,13 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n-assert_eq!((-128i8).wrapping_mod_euc(-1), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n+assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n-                self.overflowing_mod_euc(rhs).0\n+            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n+                self.overflowing_rem_euclid(rhs).0\n             }\n         }\n \n@@ -1442,7 +1442,7 @@ $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n \n Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n occur. If an overflow would occur then `self` is returned.\n@@ -1459,17 +1459,17 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euc(-1), (\", stringify!($SelfT),\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT),\n \"::MIN, true));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n                 } else {\n-                    (self.div_euc(rhs), false)\n+                    (self.div_euclid(rhs), false)\n                 }\n             }\n         }\n@@ -1508,7 +1508,7 @@ $EndFeature, \"\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+            concat!(\"Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n \n Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n@@ -1525,16 +1525,16 @@ Basic usage:\n #![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n-assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n-assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n+assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n                 } else {\n-                    (self.mod_euc(rhs), false)\n+                    (self.rem_euclid(rhs), false)\n                 }\n             }\n         }\n@@ -1544,7 +1544,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_mod_euc(-1), (0, true));\n             concat!(\"Negates self, overflowing if this is equal to the minimum value.\n \n Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n-happened. If `self` is the minimum value (e.g. `i32::MIN` for values of type `i32`), then the\n+happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n minimum value will be returned again and `true` will be returned for an overflow happening.\n \n # Examples\n@@ -1621,7 +1621,7 @@ $EndFeature, \"\n             concat!(\"Computes the absolute value of `self`.\n \n Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n-happened. If self is the minimum value (e.g. \", stringify!($SelfT), \"::MIN for values of type\n+happened. If self is the minimum value (e.g., \", stringify!($SelfT), \"::MIN for values of type\n  \", stringify!($SelfT), \"), then the minimum value will be returned again and true will be returned\n for an overflow happening.\n \n@@ -1739,9 +1739,13 @@ $EndFeature, \"\n         doc_comment! {\n             concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n \n-This computes the integer `n` such that `self = n * rhs + self.mod_euc(rhs)`.\n+This computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`,\n+with `0 <= self.rem_euclid(rhs) < rhs`.\n+\n In other words, the result is `self / rhs` rounded to the integer `n`\n such that `self >= n * rhs`.\n+If `self > 0`, this is equal to round towards zero (the default in Rust);\n+if `self < 0`, this is equal to round towards +/- infinity.\n \n # Panics\n \n@@ -1756,15 +1760,15 @@ Basic usage:\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n-assert_eq!(a.div_euc(b), 1); // 7 >= 4 * 1\n-assert_eq!(a.div_euc(-b), -1); // 7 >= -4 * -1\n-assert_eq!((-a).div_euc(b), -2); // -7 >= 4 * -2\n-assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\n+assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n+assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n+assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n+assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euc(self, rhs: Self) -> Self {\n+            pub fn div_euclid(self, rhs: Self) -> Self {\n                 let q = self / rhs;\n                 if self % rhs < 0 {\n                     return if rhs > 0 { q - 1 } else { q + 1 }\n@@ -1775,9 +1779,11 @@ assert_eq!((-a).div_euc(-b), 2); // -7 >= -4 * 2\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+            concat!(\"Calculates the least nonnegative remainder of `self (mod rhs)`.\n \n-In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+This is done as if by the Euclidean division algorithm -- given\n+`r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and\n+`0 <= r < abs(rhs)`.\n \n # Panics\n \n@@ -1792,15 +1798,15 @@ Basic usage:\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n-assert_eq!(a.mod_euc(b), 3);\n-assert_eq!((-a).mod_euc(b), 1);\n-assert_eq!(a.mod_euc(-b), 3);\n-assert_eq!((-a).mod_euc(-b), 1);\n+assert_eq!(a.rem_euclid(b), 3);\n+assert_eq!((-a).rem_euclid(b), 1);\n+assert_eq!(a.rem_euclid(-b), 3);\n+assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn mod_euc(self, rhs: Self) -> Self {\n+            pub fn rem_euclid(self, rhs: Self) -> Self {\n                 let r = self % rhs;\n                 if r < 0 {\n                     if rhs < 0 {\n@@ -2150,19 +2156,6 @@ impl isize {\n          \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n-// Emits the correct `cttz` call, depending on the size of the type.\n-macro_rules! uint_cttz_call {\n-    // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-    // emits two conditional moves on x86_64. By promoting the value to\n-    // u16 and setting bit 8, we get better code without any conditional\n-    // operations.\n-    // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-    // pending, remove this workaround once LLVM generates better code\n-    // for cttz8.\n-    ($value:expr, 8) => { intrinsics::cttz($value as u16 | 0x100) };\n-    ($value:expr, $_BITS:expr) => { intrinsics::cttz($value) }\n-}\n-\n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n@@ -2306,7 +2299,7 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n-                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n+                unsafe { intrinsics::cttz(self) as u32 }\n             }\n         }\n \n@@ -2330,12 +2323,7 @@ assert_eq!(n.rotate_left(\", $rot, \"), m);\n             #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n-                #[cfg(not(stage0))] {\n-                    unsafe { intrinsics::rotate_left(self, n as $SelfT) }\n-                }\n-                #[cfg(stage0)] {\n-                    (self << (n % $BITS)) | (self >> (($BITS - (n % $BITS)) % $BITS))\n-                }\n+                unsafe { intrinsics::rotate_left(self, n as $SelfT) }\n             }\n         }\n \n@@ -2360,12 +2348,7 @@ assert_eq!(n.rotate_right(\", $rot, \"), m);\n             #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n-                #[cfg(not(stage0))] {\n-                    unsafe { intrinsics::rotate_right(self, n as $SelfT) }\n-                }\n-                #[cfg(stage0)] {\n-                    (self >> (n % $BITS)) | (self << (($BITS - (n % $BITS)) % $BITS))\n-                }\n+                unsafe { intrinsics::rotate_right(self, n as $SelfT) }\n             }\n         }\n \n@@ -2634,7 +2617,7 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean division. Computes `self.div_euc(rhs)`, returning `None`\n+            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n if `rhs == 0`.\n \n # Examples\n@@ -2643,16 +2626,16 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\n-assert_eq!(1\", stringify!($SelfT), \".checked_div_euc(0), None);\n+assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n+assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_div_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n-                    Some(self.div_euc(rhs))\n+                    Some(self.div_euclid(rhs))\n                 }\n             }\n         }\n@@ -2682,7 +2665,7 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n         }\n \n         doc_comment! {\n-            concat!(\"Checked Euclidean modulo. Computes `self.mod_euc(rhs)`, returning `None`\n+            concat!(\"Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n if `rhs == 0`.\n \n # Examples\n@@ -2691,16 +2674,16 @@ Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(2), Some(1));\n-assert_eq!(5\", stringify!($SelfT), \".checked_mod_euc(0), None);\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n+assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn checked_mod_euc(self, rhs: Self) -> Option<Self> {\n+            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n                     None\n                 } else {\n-                    Some(self.mod_euc(rhs))\n+                    Some(self.rem_euclid(rhs))\n                 }\n             }\n         }\n@@ -2988,23 +2971,26 @@ Basic usage:\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean division. Computes `self.div_euc(rhs)`.\n+            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n Wrapped division on unsigned types is just normal division.\n There's no way wrapping could ever happen.\n This function exists, so that all operations\n are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_div(rhs)`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euc(10), 10);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_div_euc(self, rhs: Self) -> Self {\n+            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n@@ -3032,24 +3018,27 @@ Basic usage:\n         }\n \n         doc_comment! {\n-            concat!(\"Wrapping Euclidean modulo. Computes `self.mod_euc(rhs)`.\n+            concat!(\"Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n Wrapped modulo calculation on unsigned types is\n just the regular remainder calculation.\n There's no way wrapping could ever happen.\n This function exists, so that all operations\n are accounted for in the wrapping operations.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.wrapping_rem(rhs)`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n+assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n-            pub fn wrapping_mod_euc(self, rhs: Self) -> Self {\n+            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3293,12 +3282,15 @@ Basic usage\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the quotient of Euclidean division `self.div_euc(rhs)`.\n+            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n \n Returns a tuple of the divisor along with a boolean indicating\n whether an arithmetic overflow would occur. Note that for unsigned\n integers overflow never occurs, so the second value is always\n `false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self.overflowing_div(rhs)`.\n \n # Panics\n \n@@ -3310,11 +3302,11 @@ Basic usage\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euc(2), (2, false));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_div_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n         }\n@@ -3346,12 +3338,15 @@ Basic usage\n         }\n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self.mod_euc(rhs)` by Euclidean division.\n+            concat!(\"Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n \n Returns a tuple of the modulo after dividing along with a boolean\n indicating whether an arithmetic overflow would occur. Note that for\n unsigned integers overflow never occurs, so the second value is\n always `false`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this operation\n+is exactly equal to `self.overflowing_rem(rhs)`.\n \n # Panics\n \n@@ -3363,11 +3358,11 @@ Basic usage\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(5\", stringify!($SelfT), \".overflowing_mod_euc(2), (1, false));\n+assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n-            pub fn overflowing_mod_euc(self, rhs: Self) -> (Self, bool) {\n+            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n         }\n@@ -3534,42 +3529,46 @@ Basic usage:\n             doc_comment! {\n             concat!(\"Performs Euclidean division.\n \n-For unsigned types, this is just the same as `self / rhs`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self / rhs`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(7\", stringify!($SelfT), \".div_euc(4), 1); // or any other integer type\n+assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn div_euc(self, rhs: Self) -> Self {\n+            pub fn div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n             }\n         }\n \n \n         doc_comment! {\n-            concat!(\"Calculates the remainder `self mod rhs` by Euclidean division.\n+            concat!(\"Calculates the least remainder of `self (mod rhs)`.\n \n-For unsigned types, this is just the same as `self % rhs`.\n+Since, for the positive integers, all common\n+definitions of division are equal, this\n+is exactly equal to `self % rhs`.\n \n # Examples\n \n Basic usage:\n \n ```\n #![feature(euclidean_division)]\n-assert_eq!(7\", stringify!($SelfT), \".mod_euc(4), 3); // or any other integer type\n+assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn mod_euc(self, rhs: Self) -> Self {\n+            pub fn rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n             }\n         }\n@@ -3617,7 +3616,7 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         doc_comment! {\n             concat!(\"Returns the smallest power of two greater than or equal to `self`.\n \n-When return value overflows (i.e. `self > (1 << (N-1))` for type\n+When return value overflows (i.e., `self > (1 << (N-1))` for type\n `uN`), it panics in debug mode and return value is wrapped to 0 in\n release mode (the only situation in which method can return 0).\n \n@@ -4827,7 +4826,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, Par\n /// # Potential causes\n ///\n /// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n-/// in the string e.g. when it is obtained from the standard input.\n+/// in the string e.g., when it is obtained from the standard input.\n /// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n ///\n /// [`str.trim()`]: ../../std/primitive.str.html#method.trim"}, {"sha": "94dd657ec97c5e5295822c15b9be4b871234eb2f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -865,7 +865,7 @@ assert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\n             doc_comment! {\n                 concat!(\"Returns the smallest power of two greater than or equal to `self`.\n \n-When return value overflows (i.e. `self > (1 << (N-1))` for type\n+When return value overflows (i.e., `self > (1 << (N-1))` for type\n `uN`), overflows to `2^N = 0`.\n \n # Examples"}, {"sha": "ff836f4aa69a678793288708fdf02653616acea7", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -177,3 +177,19 @@ pub trait DerefMut: Deref {\n impl<T: ?Sized> DerefMut for &mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n+\n+/// Indicates that a struct can be used as a method receiver, without the\n+/// `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n+/// `Rc<T>`, `&T`, and `Pin<P>`.\n+#[cfg_attr(not(stage0), lang = \"receiver\")]\n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+#[doc(hidden)]\n+pub trait Receiver {\n+    // Empty.\n+}\n+\n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<T: ?Sized> Receiver for &T {}\n+\n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<T: ?Sized> Receiver for &mut T {}"}, {"sha": "3b356b9a1e7b4ee73206f66895da7c99ee7fc041", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -26,7 +26,7 @@\n /// is expected.\n ///\n /// Use `Fn` as a bound when you want to accept a parameter of function-like\n-/// type and need to call it repeatedly and without mutating state (e.g. when\n+/// type and need to call it repeatedly and without mutating state (e.g., when\n /// calling it concurrently). If you do not need such strict requirements, use\n /// [`FnMut`] or [`FnOnce`] as bounds.\n ///\n@@ -72,6 +72,7 @@\n     label=\"expected an `Fn<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use]\n pub trait Fn<Args> : FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -84,7 +85,7 @@ pub trait Fn<Args> : FnMut<Args> {\n ///\n /// `FnMut` is implemented automatically by closures which take mutable\n /// references to captured variables, as well as all types that implement\n-/// [`Fn`], e.g. (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`], e.g., (safe) [function pointers][] (since `FnMut` is a supertrait of\n /// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n /// implements `FnMut`, too.\n ///\n@@ -150,6 +151,7 @@ pub trait Fn<Args> : FnMut<Args> {\n     label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use]\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -163,7 +165,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n /// implements `FnOnce`, it can only be called once.\n ///\n /// `FnOnce` is implemented automatically by closure that might consume captured\n-/// variables, as well as all types that implement [`FnMut`], e.g. (safe)\n+/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n /// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n ///\n /// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n@@ -228,6 +230,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n     label=\"expected an `FnOnce<{Args}>` closure, found `{Self}`\",\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use]\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]"}, {"sha": "06740d2e4cd7038137130727c2fe34196c7121cf", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -27,7 +27,7 @@\n //! should have some resemblance to multiplication (and share expected\n //! properties like associativity).\n //!\n-//! Note that the `&&` and `||` operators short-circuit, i.e. they only\n+//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n //! evaluate their second operand if it contributes to the result. Since this\n //! behavior is not enforceable by traits, `&&` and `||` are not supported as\n //! overloadable operators.\n@@ -178,6 +178,9 @@ pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssig\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::deref::{Deref, DerefMut};\n \n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+pub use self::deref::Receiver;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::drop::Drop;\n "}, {"sha": "e86a392a2c828ffe6faeb90ccec3735e20e0483c", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -93,7 +93,7 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n /// {}\n /// ```\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n-#[cfg_attr(not(stage0), lang = \"dispatch_from_dyn\")]\n+#[lang = \"dispatch_from_dyn\"]\n pub trait DispatchFromDyn<T> {\n     // Empty.\n }"}, {"sha": "3147b21f86b633bff682486d5e69b0a1e137b70d", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -62,7 +62,7 @@\n //! The following example uses [`Option`] to create an optional box of\n //! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n //! `check_optional` function needs to use pattern matching to\n-//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n+//! determine whether the box has a value (i.e., it is [`Some(...)`][`Some`]) or\n //! not ([`None`]).\n //!\n //! ```"}, {"sha": "521ce9b5f6b698f56efa51bc4a28d6a794f0b117", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -7,23 +7,33 @@\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n-//! In order to prevent objects from moving, they must be pinned\n-//! by wrapping a pointer to the data in the [`Pin`] type. A pointer wrapped\n-//! in a `Pin` is otherwise equivalent to its normal version, e.g. `Pin<Box<T>>`\n-//! and `Box<T>` work the same way except that the first is pinning the value\n-//! of `T` in place.\n+//! By default, all types in Rust are movable. Rust allows passing all types by-value,\n+//! and common smart-pointer types such as `Box`, `Rc`, and `&mut` allow replacing and\n+//! moving the values they contain. In order to prevent objects from moving, they must\n+//! be pinned by wrapping a pointer to the data in the [`Pin`] type.\n+//! Doing this prohibits moving the value behind the pointer.\n+//! For example, `Pin<Box<T>>` functions much like a regular `Box<T>`,\n+//! but doesn't allow moving `T`. The pointer value itself (the `Box`) can still be moved,\n+//! but the value behind it cannot.\n //!\n-//! First of all, these are pointer types because pinned data mustn't be passed around by value\n-//! (that would change its location in memory).\n-//! Secondly, since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n-//! which causes their contents to swap places in memory,\n-//! we need dedicated types that prohibit such operations.\n+//! Since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n+//! changing the location of the underlying data, [`Pin`] prohibits accessing the\n+//! underlying pointer type (the `&mut` or `Box`) directly, and provides its own set of\n+//! APIs for accessing and using the value. [`Pin`] also guarantees that no other\n+//! functions will move the pointed-to value. This allows for the creation of\n+//! self-references and other special behaviors that are only possible for unmovable\n+//! values.\n //!\n-//! However, these restrictions are usually not necessary,\n-//! so most types implement the [`Unpin`] auto-trait,\n-//! which indicates that the type can be moved out safely.\n-//! Doing so removes the limitations of pinning types,\n-//! making them the same as their non-pinning counterparts.\n+//! However, these restrictions are usually not necessary. Many types are always freely\n+//! movable. These types implement the [`Unpin`] auto-trait, which nullifies the affect\n+//! of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function identically, as do\n+//! `Pin<&mut T>` and `&mut T`.\n+//!\n+//! Note that pinning and `Unpin` only affect the pointed-to type. For example, whether\n+//! or not `Box<T>` is `Unpin` has no affect on the behavior of `Pin<Box<T>>`. Similarly,\n+//! `Pin<Box<T>>` and `Pin<&mut T>` are always `Unpin` themselves, even though the\n+//! `T` underneath them isn't, because the pointers in `Pin<Box<_>>` and `Pin<&mut _>`\n+//! are always freely movable, even if the data they point to isn't.\n //!\n //! [`Pin`]: struct.Pin.html\n //! [`Unpin`]: trait.Unpin.html\n@@ -36,7 +46,7 @@\n //! #![feature(pin)]\n //!\n //! use std::pin::Pin;\n-//! use std::marker::Pinned;\n+//! use std::marker::PhantomPinned;\n //! use std::ptr::NonNull;\n //!\n //! // This is a self-referential struct since the slice field points to the data field.\n@@ -47,7 +57,7 @@\n //! struct Unmovable {\n //!     data: String,\n //!     slice: NonNull<String>,\n-//!     _pin: Pinned,\n+//!     _pin: PhantomPinned,\n //! }\n //!\n //! impl Unmovable {\n@@ -60,7 +70,7 @@\n //!             // we only create the pointer once the data is in place\n //!             // otherwise it will have already moved before we even started\n //!             slice: NonNull::dangling(),\n-//!             _pin: Pinned,\n+//!             _pin: PhantomPinned,\n //!         };\n //!         let mut boxed = Box::pinned(res);\n //!\n@@ -91,7 +101,7 @@\n \n use fmt;\n use marker::Sized;\n-use ops::{Deref, DerefMut, CoerceUnsized, DispatchFromDyn};\n+use ops::{Deref, DerefMut, Receiver, CoerceUnsized, DispatchFromDyn};\n \n #[doc(inline)]\n pub use marker::Unpin;\n@@ -292,6 +302,9 @@ where\n     }\n }\n \n+#[unstable(feature = \"receiver_trait\", issue = \"0\")]\n+impl<P: Receiver> Receiver for Pin<P> {}\n+\n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "b3c93ae1fa7b24b5a25f862ccb38ec987e75f925", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -103,7 +103,7 @@ pub use intrinsics::write_bytes;\n ///   dropped normally.\n ///\n /// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n-///   dropping manually allocated memory (e.g. when writing Box/Rc/Vec),\n+///   dropping manually allocated memory (e.g., when writing Box/Rc/Vec),\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n@@ -836,7 +836,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -913,7 +913,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -1035,7 +1035,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1089,7 +1089,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1253,7 +1253,7 @@ impl<T: ?Sized> *const T {\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1310,7 +1310,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer (convenience for\n     /// `.offset((count as isize).wrapping_neg())`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1367,7 +1367,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset(count as isize)`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1408,7 +1408,7 @@ impl<T: ?Sized> *const T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1655,7 +1655,7 @@ impl<T: ?Sized> *mut T {\n \n     /// Calculates the offset from a pointer.\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1708,7 +1708,7 @@ impl<T: ?Sized> *mut T {\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1891,7 +1891,7 @@ impl<T: ?Sized> *mut T {\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -1948,7 +1948,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer (convenience for\n     /// `.offset((count as isize).wrapping_neg())`).\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2005,7 +2005,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset(count as isize)`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2046,7 +2046,7 @@ impl<T: ?Sized> *mut T {\n     /// Calculates the offset from a pointer using wrapping arithmetic.\n     /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n     ///\n-    /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n+    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n     /// offset of `3 * size_of::<T>()` bytes.\n     ///\n     /// # Safety\n@@ -2375,7 +2375,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n-        /// Note, that this table does not contain values where inverse does not exist (i.e. for\n+        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n         /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n         const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n@@ -2398,7 +2398,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n                 // y = y * (2 - xy) mod n\n                 //\n                 // Note, that we use wrapping operations here intentionally \u2013 the original formula\n-                // uses e.g. subtraction `mod n`. It is entirely fine to do them `mod\n+                // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n                 // usize::max_value()` instead, because we take the result `mod n` at the end\n                 // anyway.\n                 inverse = inverse.wrapping_mul(\n@@ -2516,6 +2516,39 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n     a == b\n }\n \n+/// Hash a raw pointer.\n+///\n+/// This can be used to hash a `&T` reference (which coerces to `*const T` implicitly)\n+/// by its address rather than the value it points to\n+/// (which is what the `Hash for &T` implementation does).\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(ptr_hash)]\n+/// use std::collections::hash_map::DefaultHasher;\n+/// use std::hash::{Hash, Hasher};\n+/// use std::ptr;\n+///\n+/// let five = 5;\n+/// let five_ref = &five;\n+///\n+/// let mut hasher = DefaultHasher::new();\n+/// ptr::hash(five_ref, &mut hasher);\n+/// let actual = hasher.finish();\n+///\n+/// let mut hasher = DefaultHasher::new();\n+/// (five_ref as *const i32).hash(&mut hasher);\n+/// let expected = hasher.finish();\n+///\n+/// assert_eq!(actual, expected);\n+/// ```\n+#[unstable(feature = \"ptr_hash\", reason = \"newly added\", issue = \"56286\")]\n+pub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n+    use hash::Hash;\n+    hashee.hash(into);\n+}\n+\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n@@ -2759,7 +2792,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique` if `ptr` is non-null.\n     pub fn new(ptr: *mut T) -> Option<Self> {\n         if !ptr.is_null() {\n-            Some(Unique { pointer: NonZero(ptr as _), _marker: PhantomData })\n+            Some(Unique { pointer: unsafe { NonZero(ptr as _) }, _marker: PhantomData })\n         } else {\n             None\n         }\n@@ -2815,14 +2848,14 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n+        Unique { pointer: unsafe { NonZero(reference as *mut T) }, _marker: PhantomData }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n-        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n+        Unique { pointer: unsafe { NonZero(reference as *const T) }, _marker: PhantomData }\n     }\n }\n \n@@ -2857,12 +2890,12 @@ pub struct NonNull<T: ?Sized> {\n }\n \n /// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n-// NB: This impl is unnecessary, but should provide better error messages.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> !Send for NonNull<T> { }\n \n /// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n-// NB: This impl is unnecessary, but should provide better error messages.\n+// N.B., this impl is unnecessary, but should provide better error messages.\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> !Sync for NonNull<T> { }\n \n@@ -2903,7 +2936,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n         if !ptr.is_null() {\n-            Some(NonNull { pointer: NonZero(ptr as _) })\n+            Some(unsafe { Self::new_unchecked(ptr) })\n         } else {\n             None\n         }\n@@ -3025,14 +3058,14 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &'a mut T) -> Self {\n-        NonNull { pointer: NonZero(reference as _) }\n+        NonNull { pointer: unsafe { NonZero(reference as *mut T) } }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &'a T) -> Self {\n-        NonNull { pointer: NonZero(reference as _) }\n+        NonNull { pointer: unsafe { NonZero(reference as *const T) } }\n     }\n }"}, {"sha": "4f1af8bf110e4c12987c0e326c27c768694728d1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -24,7 +24,7 @@\n /// `Box<dyn AnotherTrait>`.\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n-/// type of trait objects (e.g. the fields are not directly accessible\n+/// type of trait objects (e.g., the fields are not directly accessible\n /// on a `&SomeTrait`) nor does it control that layout (changing the\n /// definition will not change the layout of a `&SomeTrait`). It is\n /// only designed to be used by unsafe code that needs to manipulate"}, {"sha": "193061457b5cd8617dab130ca60576f6849a67c4", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Slice management and manipulation\n+//! Slice management and manipulation.\n //!\n //! For more details see [`std::slice`].\n //!\n@@ -702,8 +702,7 @@ impl<T> [T] {\n     /// resulting code better than in the case of [`chunks`].\n     ///\n     /// See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n-    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice of\n-    /// the slice.\n+    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.\n     ///\n     /// # Panics\n     ///\n@@ -878,6 +877,7 @@ impl<T> [T] {\n     /// assert_eq!(iter.remainder(), &['l']);\n     /// ```\n     ///\n+    /// [`chunks`]: #method.chunks\n     /// [`rchunks`]: #method.rchunks\n     /// [`chunks_exact`]: #method.chunks_exact\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -922,6 +922,7 @@ impl<T> [T] {\n     /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n     /// ```\n     ///\n+    /// [`chunks_mut`]: #method.chunks_mut\n     /// [`rchunks_mut`]: #method.rchunks_mut\n     /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -1152,7 +1153,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n+    /// Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`,\n     /// `[20, 60, 50]`):\n     ///\n     /// ```\n@@ -1216,7 +1217,7 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// Print the slice split once, starting from the end, by numbers divisible\n-    /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n+    /// by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n@@ -1472,8 +1473,8 @@ impl<T> [T] {\n \n     /// Sorts the slice, but may not preserve the order of equal elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n     ///\n     /// # Current implementation\n     ///\n@@ -1483,7 +1484,7 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1507,8 +1508,8 @@ impl<T> [T] {\n     /// Sorts the slice with a comparator function, but may not preserve the order of equal\n     /// elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(n log n)` worst-case.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -1534,7 +1535,7 @@ impl<T> [T] {\n     /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n     /// deterministic behavior.\n     ///\n-    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1561,8 +1562,9 @@ impl<T> [T] {\n     /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n     /// elements.\n     ///\n-    /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n-    /// and `O(m n log(m n))` worst-case, where the key function is `O(m)`.\n+    /// This sort is unstable (i.e., may reorder equal elements), in-place\n+    /// (i.e., does not allocate), and `O(m n log(m n))` worst-case, where the key function is\n+    /// `O(m)`.\n     ///\n     /// # Current implementation\n     ///\n@@ -2459,13 +2461,13 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &T {\n-        // NB: use intrinsic indexing\n+        // N.B., use intrinsic indexing\n         &(*slice)[self]\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut T {\n-        // NB: use intrinsic indexing\n+        // N.B., use intrinsic indexing\n         &mut (*slice)[self]\n     }\n }"}, {"sha": "4a22d929fede0e3db0721dad190da09780b11c0a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -482,7 +482,7 @@ fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u3\n #[inline]\n fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n \n-/// Checks whether the byte is a UTF-8 continuation byte (i.e. starts with the\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n /// bits `10`).\n #[inline]\n fn utf8_is_cont_byte(byte: u8) -> bool { (byte & !CONT_MASK) == TAG_CONT_U8 }\n@@ -536,10 +536,9 @@ fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n     where I: DoubleEndedIterator<Item = &'a u8>,\n {\n     // Decode UTF-8\n-    let w = match bytes.next_back() {\n-        None => return None,\n-        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n-        Some(&back_byte) => back_byte,\n+    let w = match *bytes.next_back()? {\n+        next_byte if next_byte < 128 => return Some(next_byte as u32),\n+        back_byte => back_byte,\n     };\n \n     // Multibyte case follows"}, {"sha": "2059160ddfe67f914a6bc8a9100efb67e9010751", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -397,7 +397,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                     let found_char = index - shift;\n                     if let Some(slice) = haystack.get(found_char..(found_char + self.utf8_size)) {\n                         if slice == &self.utf8_encoded[0..self.utf8_size] {\n-                            // move finger to before the character found (i.e. at its start index)\n+                            // move finger to before the character found (i.e., at its start index)\n                             self.finger_back = found_char;\n                             return Some((self.finger_back, self.finger_back + self.utf8_size));\n                         }\n@@ -1016,7 +1016,7 @@ struct TwoWaySearcher {\n     It can be proven that the following is an equivalent definition of a local period\n     for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n     all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n-    defined. (i.e. i > 0 and i + r < |x|).\n+    defined. (i.e., i > 0 and i + r < |x|).\n \n     Using the above reformulation, it is easy to prove that\n "}, {"sha": "70d940e2b5529ea1eb63e462ca571f8612795484", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -188,7 +188,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// [Ordering::Relaxed]: #variant.Relaxed\n /// [Ordering::SeqCst]: #variant.SeqCst\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n #[non_exhaustive]\n pub enum Ordering {\n     /// No ordering constraints, only atomic operations.\n@@ -1072,6 +1072,15 @@ impl<T> AtomicPtr<T> {\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n+    /// Converts a `bool` into an `AtomicBool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicBool;\n+    /// let atomic_bool = AtomicBool::from(true);\n+    /// assert_eq!(format!(\"{:?}\", atomic_bool), \"true\")\n+    /// ```\n     #[inline]\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n@@ -1126,8 +1135,12 @@ macro_rules! atomic_int {\n \n         #[$stable_from]\n         impl From<$int_type> for $atomic_type {\n-            #[inline]\n-            fn from(v: $int_type) -> Self { Self::new(v) }\n+            doc_comment! {\n+                concat!(\n+\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\"),\n+                #[inline]\n+                fn from(v: $int_type) -> Self { Self::new(v) }\n+            }\n         }\n \n         #[$stable_debug]\n@@ -1940,7 +1953,7 @@ atomic_int! {\n     8,\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(all(not(stage0), target_has_atomic = \"128\"))]\n+#[cfg(target_has_atomic = \"128\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1954,7 +1967,7 @@ atomic_int! {\n     16,\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(all(not(stage0), target_has_atomic = \"128\"))]\n+#[cfg(target_has_atomic = \"128\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),"}, {"sha": "8ea7abce67bfafaf810a0ba6a03d269a4c4cb66f", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -227,7 +227,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn clone_raw(&self) -> Waker;\n \n     /// Drops this instance of `UnsafeWake`, deallocating resources\n@@ -249,7 +249,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn drop_raw(&self);\n \n     /// Indicates that the associated task is ready to make progress and should\n@@ -266,7 +266,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped.\n+    /// value is in a consistent state, i.e., hasn't been dropped.\n     unsafe fn wake(&self);\n \n     /// Indicates that the associated task is ready to make progress and should\n@@ -286,7 +286,7 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// # Unsafety\n     ///\n     /// This function is unsafe to call because it's asserting the `UnsafeWake`\n-    /// value is in a consistent state, i.e. hasn't been dropped, and that the\n+    /// value is in a consistent state, i.e., hasn't been dropped, and that the\n     /// `UnsafeWake` hasn't moved from the thread on which it was created.\n     unsafe fn wake_local(&self) {\n         self.wake()"}, {"sha": "44899c3f41244d7141419c88f2381e50d4e1f36d", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1001,6 +1001,10 @@ fn test_cycle() {\n     let mut it = (0..).step_by(1).take(0).cycle();\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert_eq!(it.next(), None);\n+\n+    assert_eq!(empty::<i32>().cycle().fold(0, |acc, x| acc + x), 0);\n+\n+    assert_eq!(once(1).cycle().skip(1).take(4).fold(0, |acc, x| acc + x), 4);\n }\n \n #[test]\n@@ -1012,6 +1016,33 @@ fn test_iterator_nth() {\n     assert_eq!(v.iter().nth(v.len()), None);\n }\n \n+#[test]\n+fn test_iterator_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().nth_back(i).unwrap(), &v[v.len() - 1 - i]);\n+    }\n+    assert_eq!(v.iter().nth_back(v.len()), None);\n+}\n+\n+#[test]\n+fn test_iterator_rev_nth_back() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().rev().nth_back(i).unwrap(), &v[i]);\n+    }\n+    assert_eq!(v.iter().rev().nth_back(v.len()), None);\n+}\n+\n+#[test]\n+fn test_iterator_rev_nth() {\n+    let v: &[_] = &[0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(v.iter().rev().nth(i).unwrap(), &v[v.len() - 1 - i]);\n+    }\n+    assert_eq!(v.iter().rev().nth(v.len()), None);\n+}\n+\n #[test]\n fn test_iterator_last() {\n     let v: &[_] = &[0, 1, 2, 3, 4];\n@@ -1266,6 +1297,23 @@ fn test_cloned() {\n     assert_eq!(it.next_back(), None);\n }\n \n+#[test]\n+fn test_cloned_side_effects() {\n+    let mut count = 0;\n+    {\n+        let iter = [1, 2, 3]\n+            .iter()\n+            .map(|x| {\n+                count += 1;\n+                x\n+            })\n+            .cloned()\n+            .zip(&[1]);\n+        for _ in iter {}\n+    }\n+    assert_eq!(count, 2);\n+}\n+\n #[test]\n fn test_double_ended_map() {\n     let xs = [1, 2, 3, 4, 5, 6];"}, {"sha": "400a86d2ffe0e35414c1fd372f334f0bb3897f75", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,6 +21,7 @@\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n #![feature(iter_copied)]\n+#![feature(iter_nth_back)]\n #![feature(iter_unfold)]\n #![feature(pattern)]\n #![feature(range_is_empty)]"}, {"sha": "879a41b4b770d911072a5012f534a07b98a44f12", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -17,7 +17,7 @@ mod rawfp;\n \n // Take a float literal, turn it into a string in various ways (that are all trusted\n // to be correct) and see if those strings are parsed back to the value of the literal.\n-// Requires a *polymorphic literal*, i.e. one that can serve as f64 as well as f32.\n+// Requires a *polymorphic literal*, i.e., one that can serve as f64 as well as f32.\n macro_rules! test_literal {\n     ($x: expr) => ({\n         let x32: f32 = $x;"}, {"sha": "21a7c9fc6b3374e0c575634ba172d9a190f2ae75", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,7 +18,8 @@ use core::num::flt2dec::strategy::grisu::format_exact_opt;\n use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n \n-use rand::{FromEntropy, XorShiftRng};\n+use rand::FromEntropy;\n+use rand::rngs::SmallRng;\n use rand::distributions::{Distribution, Uniform};\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n@@ -71,7 +72,10 @@ fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V\n pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n         where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n               G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng = XorShiftRng::from_entropy();\n+    if cfg!(target_os = \"emscripten\") {\n+        return // using rng pulls in i128 support, which doesn't work\n+    }\n+    let mut rng = SmallRng::from_entropy();\n     let f32_range = Uniform::new(0x0000_0001u32, 0x7f80_0000);\n     iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f32::from_bits(f32_range.sample(&mut rng));\n@@ -82,7 +86,10 @@ pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n         where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n               G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng = XorShiftRng::from_entropy();\n+    if cfg!(target_os = \"emscripten\") {\n+        return // using rng pulls in i128 support, which doesn't work\n+    }\n+    let mut rng = SmallRng::from_entropy();\n     let f64_range = Uniform::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n     iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n         let x = f64::from_bits(f64_range.sample(&mut rng));\n@@ -99,7 +106,7 @@ pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n     // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n     // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n \n-    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n+    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e., all finite ranges\n     let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n                                       k, 0x7f7f_ffff, f, g, |i: usize| {\n "}, {"sha": "8b04f84007fa7365133840887a06a9ba13f8241a", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -31,8 +31,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mod_euc() {\n-        assert!((-1 as $T).mod_euc(MIN) == MAX);\n+    fn test_rem_euclid() {\n+        assert!((-1 as $T).rem_euclid(MIN) == MAX);\n     }\n \n     #[test]"}, {"sha": "e1648db5e8ed2db699d4864a1ac793a7ece300fd", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -694,23 +694,23 @@ macro_rules! test_float {\n             assert!(($nan as $fty).max($nan).is_nan());\n         }\n         #[test]\n-        fn mod_euc() {\n+        fn rem_euclid() {\n             let a: $fty = 42.0;\n-            assert!($inf.mod_euc(a).is_nan());\n-            assert_eq!(a.mod_euc($inf), a);\n-            assert!(a.mod_euc($nan).is_nan());\n-            assert!($inf.mod_euc($inf).is_nan());\n-            assert!($inf.mod_euc($nan).is_nan());\n-            assert!($nan.mod_euc($inf).is_nan());\n+            assert!($inf.rem_euclid(a).is_nan());\n+            assert_eq!(a.rem_euclid($inf), a);\n+            assert!(a.rem_euclid($nan).is_nan());\n+            assert!($inf.rem_euclid($inf).is_nan());\n+            assert!($inf.rem_euclid($nan).is_nan());\n+            assert!($nan.rem_euclid($inf).is_nan());\n         }\n         #[test]\n-        fn div_euc() {\n+        fn div_euclid() {\n             let a: $fty = 42.0;\n-            assert_eq!(a.div_euc($inf), 0.0);\n-            assert!(a.div_euc($nan).is_nan());\n-            assert!($inf.div_euc($inf).is_nan());\n-            assert!($inf.div_euc($nan).is_nan());\n-            assert!($nan.div_euc($inf).is_nan());\n+            assert_eq!(a.div_euclid($inf), 0.0);\n+            assert!(a.div_euclid($nan).is_nan());\n+            assert!($inf.div_euclid($inf).is_nan());\n+            assert!($inf.div_euclid($nan).is_nan());\n+            assert!($nan.div_euclid($inf).is_nan());\n         }\n     } }\n }"}, {"sha": "4f00ebee1d227159bf10da311e99afb393f95000", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1024,11 +1024,11 @@ fn test_rotate_right() {\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n-    use rand::{FromEntropy, Rng, XorShiftRng};\n+    use rand::{FromEntropy, Rng, rngs::SmallRng, seq::SliceRandom};\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n-    let mut rng = XorShiftRng::from_entropy();\n+    let mut rng = SmallRng::from_entropy();\n \n     for len in (2..25).chain(500..510) {\n         let v = &mut v[0..len];\n@@ -1073,7 +1073,7 @@ fn sort_unstable() {\n     for i in 0..v.len() {\n         v[i] = i as i32;\n     }\n-    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable_by(|_, _| *[Less, Equal, Greater].choose(&mut rng).unwrap());\n     v.sort_unstable();\n     for i in 0..v.len() {\n         assert_eq!(v[i], i as i32);"}, {"sha": "475bb721f23f70092c75e8159cb6f5a3c8a5f331", "filename": "src/libcore/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -216,7 +216,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by milliseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one thousand).\n+    /// fractional portion of a second (i.e., it is less than one thousand).\n     ///\n     /// # Examples\n     ///\n@@ -235,7 +235,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by microseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one million).\n+    /// fractional portion of a second (i.e., it is less than one million).\n     ///\n     /// # Examples\n     ///\n@@ -254,7 +254,7 @@ impl Duration {\n     ///\n     /// This method does **not** return the length of the duration when\n     /// represented by nanoseconds. The returned number always represents a\n-    /// fractional portion of a second (i.e. it is less than one billion).\n+    /// fractional portion of a second (i.e., it is less than one billion).\n     ///\n     /// # Examples\n     ///"}, {"sha": "32e4b6b0fa512e7eb3618c56eeb52ebf06078df8", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -80,7 +80,7 @@ pub(crate) fn is_printable(x: char) -> bool {\n     }\n }\n \n-const SINGLETONS0U: &'static [(u8, u8)] = &[\n+const SINGLETONS0U: &[(u8, u8)] = &[\n     (0x00, 1),\n     (0x03, 5),\n     (0x05, 6),\n@@ -122,7 +122,7 @@ const SINGLETONS0U: &'static [(u8, u8)] = &[\n     (0xfe, 3),\n     (0xff, 9),\n ];\n-const SINGLETONS0L: &'static [u8] = &[\n+const SINGLETONS0L: &[u8] = &[\n     0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n     0x58, 0x8b, 0x8c, 0x90, 0x1c, 0x1d, 0xdd, 0x0e,\n     0x0f, 0x4b, 0x4c, 0xfb, 0xfc, 0x2e, 0x2f, 0x3f,\n@@ -162,7 +162,7 @@ const SINGLETONS0L: &'static [u8] = &[\n     0x91, 0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9,\n     0xd0, 0xd1, 0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n ];\n-const SINGLETONS1U: &'static [(u8, u8)] = &[\n+const SINGLETONS1U: &[(u8, u8)] = &[\n     (0x00, 6),\n     (0x01, 1),\n     (0x03, 1),\n@@ -197,7 +197,7 @@ const SINGLETONS1U: &'static [(u8, u8)] = &[\n     (0xf0, 4),\n     (0xf9, 4),\n ];\n-const SINGLETONS1L: &'static [u8] = &[\n+const SINGLETONS1L: &[u8] = &[\n     0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n     0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n     0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x36,\n@@ -219,7 +219,7 @@ const SINGLETONS1L: &'static [u8] = &[\n     0x78, 0x7d, 0x7f, 0x8a, 0xa4, 0xaa, 0xaf, 0xb0,\n     0xc0, 0xd0, 0x3f, 0x71, 0x72, 0x7b,\n ];\n-const NORMAL0: &'static [u8] = &[\n+const NORMAL0: &[u8] = &[\n     0x00, 0x20,\n     0x5f, 0x22,\n     0x82, 0xdf, 0x04,\n@@ -363,7 +363,7 @@ const NORMAL0: &'static [u8] = &[\n     0x1b, 0x03,\n     0x0f, 0x0d,\n ];\n-const NORMAL1: &'static [u8] = &[\n+const NORMAL1: &[u8] = &[\n     0x5e, 0x22,\n     0x7b, 0x05,\n     0x03, 0x04,"}, {"sha": "e3cf959beb8e5e019ca47919190ffce7d6515f2d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,7 +10,7 @@\n \n //! Generate files suitable for use with [Graphviz](http://www.graphviz.org/)\n //!\n-//! The `render` function generates output (e.g. an `output.dot` file) for\n+//! The `render` function generates output (e.g., an `output.dot` file) for\n //! use with [Graphviz](http://www.graphviz.org/) by walking a labeled\n //! graph. (Graphviz can then automatically lay out the nodes and edges\n //! of the graph, and also optionally render the graph as an image or\n@@ -25,7 +25,7 @@\n //! expressiveness of the [DOT language](\n //! http://www.graphviz.org/doc/info/lang.html). For example, there are\n //! many [attributes](http://www.graphviz.org/content/attrs) related to\n-//! providing layout hints (e.g. left-to-right versus top-down, which\n+//! providing layout hints (e.g., left-to-right versus top-down, which\n //! algorithm to use, etc). The current intention of this library is to\n //! emit a human-readable .dot file with very regular structure suitable\n //! for easy post-processing.\n@@ -373,7 +373,7 @@ impl Style {\n // implement a Labelling service) that I have encountered is that it\n // makes it impossible to use types outside of the current crate\n // directly as Nodes/Edges; you need to wrap them in newtype'd\n-// structs. See e.g. the `No` and `Ed` structs in the examples. (In\n+// structs. See e.g., the `No` and `Ed` structs in the examples. (In\n // practice clients using a graph in some other crate would need to\n // provide some sort of adapter shim over the graph anyway to\n // interface with this library).\n@@ -400,7 +400,7 @@ impl<'a> Id<'a> {\n     /// The caller must ensure that the input conforms to an\n     /// identifier format: it must be a non-empty string made up of\n     /// alphanumeric or underscore characters, not beginning with a\n-    /// digit (i.e. the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n+    /// digit (i.e., the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n     ///\n     /// (Note: this format is a strict subset of the `ID` format\n     /// defined by the DOT language.  This function may change in the"}, {"sha": "c75ca6465a139704e00295be355b1f067af2f535", "filename": "src/liblibc", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=b4a306c1e648c84f289c63e984941b7faad10af1", "patch": "@@ -1 +0,0 @@\n-Subproject commit c75ca6465a139704e00295be355b1f067af2f535"}, {"sha": "e304e61c32936f0cab3b383f920c91efe918da29", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -11,5 +11,5 @@ doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }\n-libc = { path = \"../rustc/libc_shim\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+libc = { version = \"0.2\", default-features = false }\n+compiler_builtins = \"0.1.0\""}, {"sha": "95c3514185e2f87cce797e4f5a70e47643e12a8a", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -66,6 +66,12 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }\n+\n+    #[cfg(target_env=\"sgx\")]\n+    unsafe fn abort() -> ! {\n+        extern \"C\" { pub fn panic_exit() -> !; }\n+        panic_exit();\n+    }\n }\n \n // This... is a bit of an oddity. The tl;dr; is that this is required to link"}, {"sha": "c9fce621608a24cb8155f2a2d6256434b8459292", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -12,6 +12,6 @@ doc = false\n [dependencies]\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n-libc = { path = \"../rustc/libc_shim\" }\n+libc = { version = \"0.2\", default-features = false }\n unwind = { path = \"../libunwind\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+compiler_builtins = \"0.1.0\""}, {"sha": "c9ae87ade283db3f0582980581434636afbdb906", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -32,7 +32,7 @@ impl DwarfReader {\n         DwarfReader { ptr }\n     }\n \n-    // DWARF streams are packed, so e.g. a u32 would not necessarily be aligned\n+    // DWARF streams are packed, so e.g., a u32 would not necessarily be aligned\n     // on a 4-byte boundary. This may cause problems on platforms with strict\n     // alignment requirements. By wrapping data in a \"packed\" struct, we are\n     // telling the backend to generate \"misalignment-safe\" code."}, {"sha": "441058c8d74ca7316a106e965391c199bc11e4eb", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -25,7 +25,7 @@\n //!\n //! In both phases the unwinder walks stack frames from top to bottom using\n //! information from the stack frame unwind sections of the current process's\n-//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! modules (\"module\" here refers to an OS module, i.e., an executable or a\n //! dynamic library).\n //!\n //! For each stack frame, it invokes the associated \"personality routine\", whose\n@@ -296,7 +296,7 @@ unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n // Each module's image contains a frame unwind info section (usually\n // \".eh_frame\").  When a module is loaded/unloaded into the process, the\n // unwinder must be informed about the location of this section in memory. The\n-// methods of achieving that vary by the platform.  On some (e.g. Linux), the\n+// methods of achieving that vary by the platform.  On some (e.g., Linux), the\n // unwinder can discover unwind info sections on its own (by dynamically\n // enumerating currently loaded modules via the dl_iterate_phdr() API and\n // finding their \".eh_frame\" sections); Others, like Windows, require modules"}, {"sha": "9d24079d91e2df6f9db584faea1e4b9fc5f45734", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -12,7 +12,7 @@\n //!\n //! On Windows (currently only on MSVC), the default exception handling\n //! mechanism is Structured Exception Handling (SEH). This is quite different\n-//! than Dwarf-based exception handling (e.g. what other unix platforms use) in\n+//! than Dwarf-based exception handling (e.g., what other unix platforms use) in\n //! terms of compiler internals, so LLVM is required to have a good deal of\n //! extra support for SEH.\n //!\n@@ -304,7 +304,7 @@ pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n     })\n }\n \n-// This is required by the compiler to exist (e.g. it's a lang item), but\n+// This is required by the compiler to exist (e.g., it's a lang item), but\n // it's never actually called by the compiler because __C_specific_handler\n // or _except_handler3 is the personality function that is always used.\n // Hence this is just an aborting stub."}, {"sha": "f5e12713e4e72f50100b8924dda12f56b4be3509", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -262,7 +262,7 @@ enum BridgeState<'a> {\n     Connected(Bridge<'a>),\n \n     /// Access to the bridge is being exclusively acquired\n-    /// (e.g. during `BridgeState::with`).\n+    /// (e.g., during `BridgeState::with`).\n     InUse,\n }\n \n@@ -283,7 +283,7 @@ impl BridgeState<'_> {\n     /// The state will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n     ///\n-    /// NB: while `f` is running, the thread-local state\n+    /// N.B., while `f` is running, the thread-local state\n     /// is `BridgeState::InUse`.\n     fn with<R>(f: impl FnOnce(&mut BridgeState) -> R) -> R {\n         BRIDGE_STATE.with(|state| {\n@@ -333,7 +333,7 @@ impl Bridge<'_> {\n /// which may be using a different `proc_macro` from the one\n /// used by the server, but can be interacted with compatibly.\n ///\n-/// NB: `F` must have FFI-friendly memory layout (e.g. a pointer).\n+/// N.B., `F` must have FFI-friendly memory layout (e.g., a pointer).\n /// The call ABI of function pointers used for `F` doesn't\n /// need to match between server and client, since it's only\n /// passed between them and (eventually) called by the client."}, {"sha": "edb4d3fbdaabb6208c1e0695eb1f728d19263bd0", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -14,7 +14,7 @@\n //! Serialization (with C ABI buffers) and unique integer handles are employed\n //! to allow safely interfacing between two copies of `proc_macro` built\n //! (from the same source) by different compilers with potentially mismatching\n-//! Rust ABIs (e.g. stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n+//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n \n #![deny(unsafe_code)]\n "}, {"sha": "c86d5fc309a39d491087c1a1acf5feee0c343ce1", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,7 +19,7 @@ pub trait ApplyL<'a> {\n     type Out;\n }\n \n-/// Type lambda taking a lifetime, i.e. `Lifetime -> Type`.\n+/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n pub trait LambdaL: for<'a> ApplyL<'a> {}\n \n impl<T: for<'a> ApplyL<'a>> LambdaL for T {}"}, {"sha": "0c1d4f7cc5069b45002a0c18bfedeab89f352001", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,7 +16,7 @@ use super::*;\n use super::client::HandleStore;\n \n /// Declare an associated item of one of the traits below, optionally\n-/// adjusting it (i.e. adding bounds to types and default bodies to methods).\n+/// adjusting it (i.e., adding bounds to types and default bodies to methods).\n macro_rules! associated_item {\n     (type TokenStream) =>\n         (type TokenStream: 'static + Clone;);"}, {"sha": "ebba5c81fe077d455a931def3bb59bb53556591c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -110,7 +110,7 @@ impl FromStr for TokenStream {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for TokenStream {\n@@ -196,7 +196,7 @@ pub mod token_stream {\n     use {bridge, Group, Ident, Literal, Punct, TokenTree, TokenStream};\n \n     /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n     /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n@@ -426,7 +426,7 @@ impl PartialEq for SourceFile {\n #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n impl Eq for SourceFile {}\n \n-/// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n+/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n #[derive(Clone)]\n pub enum TokenTree {\n@@ -533,7 +533,7 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for TokenTree {\n@@ -663,7 +663,7 @@ impl Group {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Group {\n@@ -711,10 +711,10 @@ impl !Sync for Punct {}\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub enum Spacing {\n-    /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n+    /// e.g., `+` is `Alone` in `+ =`, `+ident` or `+()`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Alone,\n-    /// E.g. `+` is `Joint` in `+=` or `'#`.\n+    /// e.g., `+` is `Joint` in `+=` or `'#`.\n     /// Additionally, single quote `'` can join with identifiers to form lifetimes `'ident`.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     Joint,\n@@ -729,11 +729,6 @@ impl Punct {\n     /// which can be further configured with the `set_span` method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n-                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch)\n-        }\n         Punct(bridge::client::Punct::new(ch, spacing))\n     }\n \n@@ -765,7 +760,7 @@ impl Punct {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Punct {\n@@ -800,16 +795,6 @@ impl fmt::Debug for Punct {\n pub struct Ident(bridge::client::Ident);\n \n impl Ident {\n-    fn is_valid(string: &str) -> bool {\n-        let mut chars = string.chars();\n-        if let Some(start) = chars.next() {\n-            (start == '_' || start.is_xid_start())\n-                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n@@ -831,18 +816,12 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, false))\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro_raw_ident\", issue = \"54723\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, true))\n     }\n \n@@ -860,7 +839,7 @@ impl Ident {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Ident {\n@@ -1110,7 +1089,7 @@ impl Literal {\n     }\n }\n \n-// NB: the bridge only provides `to_string`, implement `fmt::Display`\n+// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n // based on it (the reverse of the usual relationship between the two).\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl ToString for Literal {"}, {"sha": "7c95cf0a0542a5532f76816d1bec75459dc27866", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,7 +13,7 @@ doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+compiler_builtins = { version = \"0.1.0\", features = ['rustc-dep-of-std'] }\n \n [build-dependencies]\n cc = \"1.0.1\""}, {"sha": "db72ce77e720bd6a60f28195d6eb85dacef036d5", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -56,9 +56,15 @@ fn main() {\n         cfg.define(\"COMPILER_RT_HAS_UNAME\", Some(\"1\"));\n     }\n \n+    // The source for `compiler-rt` comes from the `compiler-builtins` crate, so\n+    // load our env var set by cargo to find the source code.\n+    let root = env::var_os(\"DEP_COMPILER_RT_COMPILER_RT\").unwrap();\n+    let root = Path::new(&root);\n+\n     for src in profile_sources {\n-        cfg.file(Path::new(\"../libcompiler_builtins/compiler-rt/lib/profile\").join(src));\n+        cfg.file(root.join(\"lib\").join(\"profile\").join(src));\n     }\n \n+    cfg.warnings(false);\n     cfg.compile(\"profiler-rt\");\n }"}, {"sha": "a572b6bf919e1bbf378d5bfa0e9ceb7d3278c2ef", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -32,7 +32,7 @@ parking_lot = \"0.6\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n chalk-engine = { version = \"0.8.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n \n # Note that these dependencies are a lie, they're just here to get linkage to\n # work."}, {"sha": "4881f10fac25e33b123e378ed6118e96da8ed844", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -53,7 +53,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let body_exit;\n \n     // Find the tables for this body.\n-    let owner_def_id = tcx.hir.local_def_id(tcx.hir.body_owner(body.id()));\n+    let owner_def_id = tcx.hir().local_def_id(tcx.hir().body_owner(body.id()));\n     let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let hir_id = self.tcx.hir().node_to_hir_id(stmt.node.id());\n         match stmt.node {\n             hir::StmtKind::Decl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) => { // NB: && and || handled earlier\n+            hir::ExprKind::Binary(_, ref l, ref r) => { // N.B., && and || handled earlier\n                 self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n@@ -415,8 +415,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        // FIXME(canndrew): This is_never should probably be an is_uninhabited.\n-        if self.tables.expr_ty(call_expr).is_never() {\n+        let m = self.tcx.hir().get_module_parent(call_expr.id);\n+        if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {\n             ret\n@@ -588,9 +588,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match destination.target_id {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                    if b.block_expr_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {\n@@ -600,9 +600,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     }\n                 }\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                    if l.loop_id == self.tcx.hir().node_to_hir_id(loop_id).local_id {\n                         let scope = region::Scope {\n-                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            id: self.tcx.hir().node_to_hir_id(loop_id).local_id,\n                             data: region::ScopeData::Node\n                         };\n                         return (scope, match scope_cf_kind {"}, {"sha": "39810691df85527b059f1f0190b9e642c5c29cdd", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -32,11 +32,11 @@ pub struct LabelledCFG<'a, 'tcx: 'a> {\n impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n     fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n         assert!(self.cfg.owner_def_id.is_local());\n-        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n-            owner: self.tcx.hir.def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n+        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n+            owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n             local_id\n         });\n-        let s = self.tcx.hir.node_to_string(node_id);\n+        let s = self.tcx.hir().node_to_string(node_id);\n \n         // Replacing newlines with \\\\l causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions."}, {"sha": "f4d7ef59404cca050ad4beda0002d6aab48636b5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -17,7 +17,7 @@\n //! fully identify a dependency node, even across multiple compilation sessions.\n //! In other words, the value of the fingerprint does not depend on anything\n //! that is specific to a given compilation session, like an unpredictable\n-//! interning key (e.g. NodeId, DefId, Symbol) or the numeric value of a\n+//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n //! pointer. The concept behind this could be compared to how git commit hashes\n //! uniquely identify a given commit and has a few advantages:\n //!\n@@ -28,7 +28,7 @@\n //! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n //!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n //! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n-//!   memory without any post-processing (e.g. \"abomination-style\" pointer\n+//!   memory without any post-processing (e.g., \"abomination-style\" pointer\n //!   reconstruction).\n //! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n //!   refer to things that do not exist anymore. In previous implementations\n@@ -81,7 +81,7 @@ use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n-// is repeated (i.e. which sub-expression of the macro we are in) but don't need\n+// is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n macro_rules! erase {\n     ($x:tt) => ({})\n@@ -162,7 +162,9 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            // FIXME: Make `is_anon`, `is_input`, `is_eval_always` and `has_params` properties\n+            // of queries\n+            #[inline(always)]\n             pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n@@ -171,7 +173,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            #[inline(always)]\n             pub fn is_input(&self) -> bool {\n                 match *self {\n                     $(\n@@ -180,7 +182,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[inline]\n+            #[inline(always)]\n             pub fn is_eval_always(&self) -> bool {\n                 match *self {\n                     $(\n@@ -190,7 +192,7 @@ macro_rules! define_dep_nodes {\n             }\n \n             #[allow(unreachable_code)]\n-            #[inline]\n+            #[inline(always)]\n             pub fn has_params(&self) -> bool {\n                 match *self {\n                     $(\n@@ -230,6 +232,7 @@ macro_rules! define_dep_nodes {\n \n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n+            #[inline(always)]\n             pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        dep: DepConstructor<'gcx>)\n                                        -> DepNode\n@@ -299,11 +302,11 @@ macro_rules! define_dep_nodes {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            #[inline]\n+            #[inline(always)]\n             pub fn from_def_path_hash(kind: DepKind,\n                                       def_path_hash: DefPathHash)\n                                       -> DepNode {\n-                assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: def_path_hash.0,\n@@ -313,9 +316,9 @@ macro_rules! define_dep_nodes {\n             /// Create a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n-            #[inline]\n+            #[inline(always)]\n             pub fn new_no_params(kind: DepKind) -> DepNode {\n-                assert!(!kind.has_params());\n+                debug_assert!(!kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: Fingerprint::ZERO,\n@@ -381,7 +384,7 @@ macro_rules! define_dep_nodes {\n         #[allow(dead_code, non_upper_case_globals)]\n         pub mod label_strs {\n            $(\n-                pub const $variant: &'static str = stringify!($variant);\n+                pub const $variant: &str = stringify!($variant);\n             )*\n         }\n     );\n@@ -418,14 +421,14 @@ impl fmt::Debug for DepNode {\n \n \n impl DefPathHash {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, self)\n     }\n }\n \n impl DefId {\n-    #[inline]\n+    #[inline(always)]\n     pub fn to_dep_node(self, tcx: TyCtxt<'_, '_, '_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }\n@@ -449,10 +452,10 @@ define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n     // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.hir.krate()`), we will have to assume that any change\n+    // `tcx.hir().krate()`), we will have to assume that any change\n     // means that you need to be recompiled. This is because the\n     // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.hir.krate()`; instead, prefer\n+    // this fate, do not call `tcx.hir().krate()`; instead, prefer\n     // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n@@ -666,6 +669,7 @@ define_dep_nodes!( <'tcx>\n     [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n+    [] MethodAutoderefSteps(CanonicalTyGoal<'tcx>),\n \n     [input] TargetFeaturesWhitelist,\n \n@@ -733,7 +737,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n-        tcx.hir.definitions().def_path_hash(*self).0\n+        tcx.hir().definitions().def_path_hash(*self).0\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {"}, {"sha": "da7dabf6e1839f4a6bb6493a8e0c0d3d514ae253", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -65,7 +65,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// ```\n     /// fn type_of_item(..., item: &hir::Item) -> Ty<'tcx> {\n-    ///     let item_def_id = ccx.tcx.hir.local_def_id(it.id);\n+    ///     let item_def_id = ccx.tcx.hir().local_def_id(it.id);\n     ///     ccx.tcx.item_types.memoized(item_def_id, || {\n     ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n     ///         compute_type_of_item(ccx, item)"}, {"sha": "3dc6f761ec96141f8452938a97d0ed3e8e7b1d2b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -47,7 +47,7 @@ trait Foo where Self: Sized {\n We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n `Self` would not be `Sized`.\n \n-Generally, `Self : Sized` is used to indicate that the trait should not be used\n+Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n this restriction.\n \n@@ -217,9 +217,9 @@ trait Trait {\n ```\n \n If this is not an option, consider replacing the type parameter with another\n-trait object (e.g. if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the number\n-of types you intend to feed to this method is limited, consider manually listing\n-out the methods of different types.\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+number of types you intend to feed to this method is limited, consider manually\n+listing out the methods of different types.\n \n ### Method has no receiver\n \n@@ -642,7 +642,7 @@ struct Foo; // error: duplicate lang item found: `arc`\n ```\n \n Lang items are already implemented in the standard library. Unless you are\n-writing a free-standing application (e.g. a kernel), you do not need to provide\n+writing a free-standing application (e.g., a kernel), you do not need to provide\n them yourself.\n \n You can build a free-standing crate by adding `#![no_std]` to the crate\n@@ -699,7 +699,7 @@ This error appears when the curly braces contain an identifier which doesn't\n match with any of the type parameters or the string `Self`. This might happen\n if you misspelled a type parameter, or if you intended to use literal curly\n braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g. a literal `{` is `{{`.\n+of the same type; e.g., a literal `{` is `{{`.\n \"##,\n \n E0231: r##\"\n@@ -832,7 +832,7 @@ extern \"C\" {\n \n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n-trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n and another type `U` that is required to be equal to `T::Bar`, but is not.\n Examples follow.\n \n@@ -1622,7 +1622,7 @@ representation of enums isn't strictly defined in Rust, and this attribute\n won't work on enums.\n \n `#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n-types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n+types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n SIMD. This doesn't make much sense for enums since they don't consist of a\n single list of data.\n \"##,"}, {"sha": "5ff533fe34b2d91f327b57ebfc4dad4bcb343bb6", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir.local_def_id(item.id));\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n         } else if let Some(a) = item.attrs.iter().find(|a| a.check_name(\"target_feature\")) {\n             self.tcx.sess.struct_span_err(a.span, \"attribute should be applied to a function\")\n                 .span_label(item.span, \"not a function\")\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut checker = CheckAttrVisitor { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {"}, {"sha": "fb3c3dec7c2bec8f570c51b940a8ace3fae17be4", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -46,7 +46,7 @@ pub enum NonMacroAttrKind {\n pub enum Def {\n     // Type namespace\n     Mod(DefId),\n-    Struct(DefId), // DefId refers to NodeId of the struct itself\n+    Struct(DefId), // `DefId` refers to `NodeId` of the struct itself\n     Union(DefId),\n     Enum(DefId),\n     Variant(DefId),\n@@ -63,27 +63,27 @@ pub enum Def {\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n-    ToolMod, // e.g. `rustfmt` in `#[rustfmt::skip]`\n+    ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n     Fn(DefId),\n     Const(DefId),\n     Static(DefId, bool /* is_mutbl */),\n-    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n-    VariantCtor(DefId, CtorKind), // DefId refers to the enum variant\n-    SelfCtor(DefId /* impl */),  // DefId refers to the impl\n+    StructCtor(DefId, CtorKind), // `DefId` refers to `NodeId` of the struct's constructor\n+    VariantCtor(DefId, CtorKind), // `DefId` refers to the enum variant\n+    SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Method(DefId),\n     AssociatedConst(DefId),\n \n     Local(ast::NodeId),\n-    Upvar(ast::NodeId,  // node id of closed over local\n-          usize,        // index in the freevars list of the closure\n+    Upvar(ast::NodeId,  // `NodeId` of closed over local\n+          usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n     // Macro namespace\n     Macro(DefId, MacroKind),\n-    NonMacroAttr(NonMacroAttrKind), // e.g. `#[inline]` or `#[rustfmt::skip]`\n+    NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // Both namespaces\n     Err,\n@@ -170,6 +170,7 @@ impl<T> PerNS<T> {\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n     type Output = T;\n+\n     fn index(&self, ns: Namespace) -> &T {\n         match ns {\n             ValueNS => &self.value_ns,\n@@ -238,6 +239,7 @@ impl CtorKind {\n             ast::VariantData::Struct(..) => CtorKind::Fictive,\n         }\n     }\n+\n     pub fn from_hir(vdata: &hir::VariantData) -> CtorKind {\n         match *vdata {\n             hir::VariantData::Tuple(..) => CtorKind::Fn,"}, {"sha": "f7e2c7036f6f8c43721280425cde7b61b96aecaf", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -131,7 +131,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// Each method of the Visitor trait is a hook to be potentially\n /// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n-/// e.g. the `visit_mod` method by default calls `intravisit::walk_mod`.\n+/// e.g., the `visit_mod` method by default calls `intravisit::walk_mod`.\n ///\n /// Note that this visitor does NOT visit nested items by default\n /// (this is why the module is called `intravisit`, to distinguish it\n@@ -493,7 +493,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              item.id)\n         }\n         ItemKind::Mod(ref module) => {\n-            // visit_mod() takes care of visiting the Item's NodeId\n+            // `visit_mod()` takes care of visiting the `Item`'s `NodeId`.\n             visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemKind::ForeignMod(ref foreign_module) => {\n@@ -518,7 +518,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n-            // visit_enum_def() takes care of visiting the Item's NodeId\n+            // `visit_enum_def()` takes care of visiting the `Item`'s `NodeId`.\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n         ItemKind::Impl(\n@@ -877,7 +877,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref: &'v TraitItemRef) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let TraitItemRef { id, ident, ref kind, span: _, ref defaultness } = *trait_item_ref;\n     visitor.visit_nested_trait_item(id);\n     visitor.visit_ident(ident);\n@@ -886,7 +886,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n         id: _,\n         hir_id: _,\n@@ -932,7 +932,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n }\n \n pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n-    // NB: Deliberately force a compilation error if/when new fields are added.\n+    // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n     visitor.visit_ident(ident);"}, {"sha": "f8bc764572f02b11a7cc0d3093fed33f66355412", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,7 +19,7 @@ use super::intravisit::Visitor;\n ///\n /// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n ///    - Example: find all items with a `#[foo]` attribute on them.\n-///    - How: Implement `ItemLikeVisitor` and call `tcx.hir.krate().visit_all_item_likes()`.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.hir().krate().visit_all_item_likes()`.\n ///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n ///    - Con: Don't get information about nesting\n ///    - Con: Don't have methods for specific bits of HIR, like \"on\n@@ -29,7 +29,7 @@ use super::intravisit::Visitor;\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n ///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.hir.krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n+///      `tcx.hir().krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n ///      your `intravisit::Visitor` impl, implement methods like\n ///      `visit_expr()`; don't forget to invoke\n ///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n@@ -43,7 +43,7 @@ use super::intravisit::Visitor;\n ///    - How: Implement `intravisit::Visitor` and override the\n ///      `nested_visit_map()` methods to return\n ///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.hir.krate()`.\n+///      `intravisit::walk_crate()` invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}, {"sha": "6958801d865bfe3c8a3ca64299f0ed8c6be9ace4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 82, "deletions": 83, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -72,7 +72,7 @@ use syntax::ptr::P;\n use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{keywords, Symbol};\n-use syntax::tokenstream::{Delimited, TokenStream, TokenTree};\n+use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, MultiSpan};\n@@ -82,7 +82,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n \n-    // Use to assign ids to hir nodes that do not directly correspond to an ast node\n+    // Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -114,10 +114,10 @@ pub struct LoweringContext<'a> {\n     anonymous_lifetime_mode: AnonymousLifetimeMode,\n \n     // Used to create lifetime definitions from in-band lifetime usages.\n-    // e.g. `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n+    // e.g., `fn foo(x: &'x u8) -> &'x u8` to `fn foo<'x>(x: &'x u8) -> &'x u8`\n     // When a named lifetime is encountered in a function or impl header and\n     // has not been defined\n-    // (i.e. it doesn't appear in the in_scope_lifetimes list), it is added\n+    // (i.e., it doesn't appear in the in_scope_lifetimes list), it is added\n     // to this list. The results of this list are then added to the list of\n     // lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n@@ -149,7 +149,7 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a node id\n+    /// Obtain the resolution for a node-id.\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n     /// Obtain the possible resolutions for the given `use` statement.\n@@ -159,8 +159,8 @@ pub trait Resolver {\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n \n-    /// Given suffix [\"b\",\"c\",\"d\"], creates a HIR path for `[::crate_root]::b::c::d` and resolves\n-    /// it based on `is_value`.\n+    /// Given suffix `[\"b\", \"c\", \"d\"]`, creates a HIR path for `[::crate_root]::b::c::d` and\n+    /// resolves it based on `is_value`.\n     fn resolve_str_path(\n         &mut self,\n         span: Span,\n@@ -185,7 +185,7 @@ enum ImplTraitContext<'a> {\n     ///\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n     /// information later. It is `None` when no information about the context should be stored,\n-    /// e.g. for consts and statics.\n+    /// e.g., for consts and statics.\n     Existential(Option<DefId>),\n \n     /// `impl Trait` is not accepted in this position.\n@@ -358,8 +358,8 @@ impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n         /// `LoweringContext` any information that may be\n-        /// needed from arbitrary locations in the crate.\n-        /// E.g. The number of lifetime generic parameters\n+        /// needed from arbitrary locations in the crate,\n+        /// e.g., the number of lifetime generic parameters\n         /// declared for every type and trait definition.\n         struct MiscCollector<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n@@ -512,7 +512,7 @@ impl<'a> LoweringContext<'a> {\n                 debug\n             );\n         }\n-        // Always allocate the first HirId for the owner itself\n+        // Always allocate the first `HirId` for the owner itself.\n         self.lower_node_id_with_owner(owner, owner)\n     }\n \n@@ -536,7 +536,7 @@ impl<'a> LoweringContext<'a> {\n         let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n \n         if existing_hir_id == hir::DUMMY_HIR_ID {\n-            // Generate a new HirId\n+            // Generate a new `HirId`.\n             let hir_id = alloc_hir_id(self);\n             self.node_id_to_hir_id[ast_node_id] = hir_id;\n             LoweredNodeId {\n@@ -573,12 +573,12 @@ impl<'a> LoweringContext<'a> {\n         ret\n     }\n \n-    /// This method allocates a new HirId for the given NodeId and stores it in\n-    /// the LoweringContext's NodeId => HirId map.\n-    /// Take care not to call this method if the resulting HirId is then not\n+    /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n+    /// the `LoweringContext`'s `NodeId => HirId` map.\n+    /// Take care not to call this method if the resulting `HirId` is then not\n     /// actually used in the HIR, as that would trigger an assertion in the\n-    /// HirIdValidator later on, which makes sure that all NodeIds got mapped\n-    /// properly. Calling the method twice with the same NodeId is fine though.\n+    /// `HirIdValidator` later on, which makes sure that all `NodeId`s got mapped\n+    /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let &mut (def_index, ref mut local_id_counter) =\n@@ -743,7 +743,7 @@ impl<'a> LoweringContext<'a> {\n                     ),\n                 };\n \n-                // Add a definition for the in-band lifetime def\n+                // Add a definition for the in-band lifetime def.\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n@@ -1067,7 +1067,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n-        // the HirIds. We don't actually need HIR version of attributes anyway.\n+        // the `HirId`s. We don't actually need HIR version of attributes anyway.\n         Attribute {\n             id: attr.id,\n             style: attr.style,\n@@ -1088,12 +1088,10 @@ impl<'a> LoweringContext<'a> {\n     fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n         match tree {\n             TokenTree::Token(span, token) => self.lower_token(token, span),\n-            TokenTree::Delimited(span, delimited) => TokenTree::Delimited(\n+            TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n                 span,\n-                Delimited {\n-                    delim: delimited.delim,\n-                    tts: self.lower_token_stream(delimited.tts.into()).into(),\n-                },\n+                delim,\n+                self.lower_token_stream(tts.into()).into(),\n             ).into(),\n         }\n     }\n@@ -1201,7 +1199,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfUpper.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -1246,7 +1244,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         self.lower_node_id(def_node_id);\n-                        // Add a definition for the in-band Param\n+                        // Add a definition for the in-band `Param`.\n                         let def_index = self\n                             .resolver\n                             .definitions()\n@@ -1257,7 +1255,7 @@ impl<'a> LoweringContext<'a> {\n                             bounds,\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n-                        // Set the name to `impl Bound1 + Bound2`\n+                        // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n@@ -1365,7 +1363,7 @@ impl<'a> LoweringContext<'a> {\n                 impl_trait_fn: fn_def_id,\n             });\n             let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-            // Generate an `existential type Foo: Trait;` declaration\n+            // Generate an `existential type Foo: Trait;` declaration.\n             trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n \n             trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n@@ -1384,7 +1382,7 @@ impl<'a> LoweringContext<'a> {\n             // does not actually exist in the AST.\n             lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n \n-            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n+            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n             hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n         })\n     }\n@@ -1397,7 +1395,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n         // This visitor walks over impl trait bounds and creates defs for all lifetimes which\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n-        // e.g. 'a, 'b, but not 'c in `impl for<'c> SomeTrait<'a, 'b, 'c>`\n+        // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n         struct ImplTraitLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n             parent: DefIndex,\n@@ -1429,7 +1427,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let hir::TyKind::BareFn(_) = t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n@@ -1459,10 +1457,10 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n-                // Record the introduction of 'a in `for<'a> ...`\n+                // Record the introduction of 'a in `for<'a> ...`.\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n-                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n                     let lt_name = hir::LifetimeName::Param(param.name);\n                     self.currently_bound_lifetimes.push(lt_name);\n                 }\n@@ -1475,7 +1473,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n                         if self.collect_elided_lifetimes {\n                             // Use `'_` for both implicit and underscore lifetimes in\n-                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n+                            // `abstract type Foo<'_>: SomeTrait<'_>;`.\n                             hir::LifetimeName::Underscore\n                         } else {\n                             return;\n@@ -1648,7 +1646,7 @@ impl<'a> LoweringContext<'a> {\n                         {\n                             ParenthesizedGenericArgs::Ok\n                         }\n-                        // Avoid duplicated errors\n+                        // Avoid duplicated errors.\n                         Def::Err => ParenthesizedGenericArgs::Ok,\n                         // An error\n                         Def::Struct(..)\n@@ -1689,27 +1687,27 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         // Simple case, either no projections, or only fully-qualified.\n-        // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n         if resolution.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n         // Create the innermost type that we're projecting from.\n         let mut ty = if path.segments.is_empty() {\n             // If the base path is empty that means there exists a\n-            // syntactical `Self`, e.g. `&i32` in `<&i32>::clone`.\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n             qself.expect(\"missing QSelf for <T>::...\")\n         } else {\n             // Otherwise, the base path is an implicit `Self` type path,\n-            // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n             let new_id = self.next_id();\n             P(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n         // out of which all but the last one are associated types,\n-        // e.g. for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n         // * base path is `std::vec::Vec<T>`\n         // * \"extensions\" are `IntoIter`, `Item` and `clone`\n         // * type nodes are:\n@@ -1739,7 +1737,7 @@ impl<'a> LoweringContext<'a> {\n             ty = P(self.ty_path(new_id, p.span, qpath));\n         }\n \n-        // Should've returned in the for loop above.\n+        // We should've returned in the for loop above.\n         span_bug!(\n             p.span,\n             \"lower_qpath: no final extension segment in {}..{}\",\n@@ -1838,11 +1836,11 @@ impl<'a> LoweringContext<'a> {\n                 let no_bindings = generic_args.bindings.is_empty();\n                 let (incl_angl_brckt, insertion_span, suggestion) = if no_ty_args && no_bindings {\n                     // If there are no (non-implicit) generic args or associated-type\n-                    // bindings, our suggestion includes the angle brackets\n+                    // bindings, our suggestion includes the angle brackets.\n                     (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n                 } else {\n                     // Otherwise\u2014sorry, this is kind of gross\u2014we need to infer the\n-                    // place to splice in the `'_, ` from the generics that do exist\n+                    // place to splice in the `'_, ` from the generics that do exist.\n                     let first_generic_span = first_generic_span\n                         .expect(\"already checked that type args or bindings exist\");\n                     (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n@@ -2096,14 +2094,15 @@ impl<'a> LoweringContext<'a> {\n         return_impl_trait_id: NodeId,\n     ) -> hir::FunctionRetTy {\n         // Get lifetimes used in the input arguments to the function. Our output type must also\n-        // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n-        // because `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither\n-        // is a subset of the other. We really want some new lifetime that is a subset of all input\n-        // lifetimes, but that doesn't exist at the moment.\n+        // have the same lifetime.\n+        // FIXME(cramertj): multiple different lifetimes are not allowed because\n+        // `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither is a subset\n+        // of the other. We really want some new lifetime that is a subset of all input lifetimes,\n+        // but that doesn't exist at the moment.\n \n         struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n             context: &'r mut LoweringContext<'a>,\n-            // Lifetimes bound by HRTB\n+            // Lifetimes bound by HRTB.\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             // Whether to count elided lifetimes.\n             // Disabled inside of `Fn` or `fn` syntax.\n@@ -2133,7 +2132,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_ty(&mut self, t: &'v hir::Ty) {\n-                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let &hir::TyKind::BareFn(_) = &t.node {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n                     self.collect_elided_lifetimes = false;\n@@ -2424,8 +2423,8 @@ impl<'a> LoweringContext<'a> {\n             GenericParamKind::Type { ref default, .. } => {\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                let ident = if param.ident.name == keywords::SelfType.name() {\n+                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n+                let ident = if param.ident.name == keywords::SelfUpper.name() {\n                     param.ident.gensym()\n                 } else {\n                     param.ident\n@@ -2467,7 +2466,7 @@ impl<'a> LoweringContext<'a> {\n         -> hir::Generics\n     {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: This could probably be done with less rightward drift. Also looks like two control\n+        // FIXME: this could probably be done with less rightward drift. Also looks like two control\n         //        paths where report_error is called are also the only paths that advance to after\n         //        the match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n@@ -2563,7 +2562,7 @@ impl<'a> LoweringContext<'a> {\n                                 .iter()\n                                 .filter_map(|bound| match *bound {\n                                     // Ignore `?Trait` bounds.\n-                                    // Tthey were copied into type parameters already.\n+                                    // They were copied into type parameters already.\n                                     GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n                                     _ => Some(this.lower_param_bound(\n                                         bound,\n@@ -2662,7 +2661,7 @@ impl<'a> LoweringContext<'a> {\n             id: self.lower_node_id(f.id).node_id,\n             ident: match f.ident {\n                 Some(ident) => ident,\n-                // FIXME(jseyfried) positional field hygiene\n+                // FIXME(jseyfried): positional field hygiene\n                 None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n@@ -2946,7 +2945,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n-        //     not cause an assertion failure inside the `lower_defaultness` function\n+        //     not cause an assertion failure inside the `lower_defaultness` function.\n     }\n \n     fn lower_use_tree(\n@@ -2981,7 +2980,7 @@ impl<'a> LoweringContext<'a> {\n \n                 // Correctly resolve `self` imports\n                 if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == keywords::SelfValue.name()\n+                    && path.segments.last().unwrap().ident.name == keywords::SelfLower.name()\n                 {\n                     let _ = path.segments.pop();\n                     if rename.is_none() {\n@@ -3190,7 +3189,7 @@ impl<'a> LoweringContext<'a> {\n \n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// node-ids. (See e.g. #56128.)\n+    /// node-ids. (See e.g., #56128.)\n     fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();\n@@ -3780,7 +3779,7 @@ impl<'a> LoweringContext<'a> {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprKind::IfLet(..) => {\n-                            // wrap the if-let expr in a block\n+                            // Wrap the `if let` expr in a block.\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n                             let LoweredNodeId { node_id, hir_id } = self.next_id();\n@@ -3871,7 +3870,7 @@ impl<'a> LoweringContext<'a> {\n                     let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n-                        // FIXME(cramertj) allow `async` non-`move` closures with\n+                        // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n                         if capture_clause == CaptureBy::Ref &&\n                             !decl.inputs.is_empty()\n                         {\n@@ -3883,13 +3882,13 @@ impl<'a> LoweringContext<'a> {\n                                 are not currently supported\",\n                             )\n                                 .help(\"consider using `let` statements to manually capture \\\n-                                        variables by reference before entering an \\\n-                                        `async move` closure\")\n+                                       variables by reference before entering an \\\n+                                       `async move` closure\")\n                                 .emit();\n                         }\n \n                         // Transform `async |x: u8| -> X { ... }` into\n-                        // `|x: u8| future_from_generator(|| -> X { ... })`\n+                        // `|x: u8| future_from_generator(|| -> X { ... })`.\n                         let body_id = this.lower_body(Some(&outer_decl), |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n                                 Some(&**ty)\n@@ -3972,7 +3971,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n-            // Desugar `<start>..=<end>` to `std::ops::RangeInclusive::new(<start>, <end>)`\n+            // Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n@@ -4106,11 +4105,11 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ExprKind::Paren(ref ex) => {\n                 let mut ex = self.lower_expr(ex);\n-                // include parens in span, but only if it is a super-span.\n+                // Include parens in span, but only if it is a super-span.\n                 if e.span.contains(ex.span) {\n                     ex.span = e.span;\n                 }\n-                // merge attributes into the inner expression.\n+                // Merge attributes into the inner expression.\n                 let mut attrs = e.attrs.clone();\n                 attrs.extend::<Vec<_>>(ex.attrs.into());\n                 ex.attrs = attrs;\n@@ -4128,8 +4127,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Yield(P(expr))\n             }\n \n-            // Desugar ExprIfLet\n-            // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n+            // Desugar `ExprIfLet`\n+            // from: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n             ExprKind::IfLet(ref pats, ref sub_expr, ref body, ref else_opt) => {\n                 // to:\n                 //\n@@ -4173,8 +4172,8 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n \n-            // Desugar ExprWhileLet\n-            // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+            // Desugar `ExprWhileLet`\n+            // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n             ExprKind::WhileLet(ref pats, ref sub_expr, ref body, opt_label) => {\n                 // to:\n                 //\n@@ -4223,12 +4222,12 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_label(opt_label),\n                     hir::LoopSource::WhileLet,\n                 );\n-                // add attributes to the outer returned expr node\n+                // Add attributes to the outer returned expr node.\n                 loop_expr\n             }\n \n-            // Desugar ExprForLoop\n-            // From: `[opt_ident]: for <pat> in <head> <body>`\n+            // Desugar `ExprForLoop`\n+            // from: `[opt_ident]: for <pat> in <head> <body>`\n             ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n                 // to:\n                 //\n@@ -4386,21 +4385,21 @@ impl<'a> LoweringContext<'a> {\n                 ));\n \n                 // `{ let _result = ...; _result }`\n-                // underscore prevents an unused_variables lint if the head diverges\n+                // Underscore prevents an `unused_variables` lint if the head diverges.\n                 let result_ident = self.str_to_ident(\"_result\");\n                 let (let_stmt, let_stmt_binding) =\n                     self.stmt_let(e.span, false, result_ident, match_expr);\n \n                 let result = P(self.expr_ident(e.span, result_ident, let_stmt_binding));\n                 let block = P(self.block_all(e.span, hir_vec![let_stmt], Some(result)));\n-                // add the attributes to the outer returned expr node\n+                // Add the attributes to the outer returned expr node.\n                 return self.expr_block(block, e.attrs.clone());\n             }\n \n-            // Desugar ExprKind::Try\n-            // From: `<expr>?`\n+            // Desugar `ExprKind::Try`\n+            // from: `<expr>?`\n             ExprKind::Try(ref sub_expr) => {\n-                // to:\n+                // into:\n                 //\n                 // match Try::into_result(<expr>) {\n                 //     Ok(val) => #[allow(unreachable_code)] val,\n@@ -4414,7 +4413,7 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span =\n                     self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n \n-                // Try::into_result(<expr>)\n+                // `Try::into_result(<expr>)`\n                 let discr = {\n                     // expand <expr>\n                     let sub_expr = self.lower_expr(sub_expr);\n@@ -4425,9 +4424,9 @@ impl<'a> LoweringContext<'a> {\n                     P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                 };\n \n-                // #[allow(unreachable_code)]\n+                // `#[allow(unreachable_code)]`\n                 let attr = {\n-                    // allow(unreachable_code)\n+                    // `allow(unreachable_code)`\n                     let allow = {\n                         let allow_ident = Ident::from_str(\"allow\").with_span_pos(e.span);\n                         let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n@@ -4438,7 +4437,7 @@ impl<'a> LoweringContext<'a> {\n                 };\n                 let attrs = vec![attr];\n \n-                // Ok(val) => #[allow(unreachable_code)] val,\n+                // `Ok(val) => #[allow(unreachable_code)] val,`\n                 let ok_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n                     let val_pat = self.pat_ident(e.span, val_ident);\n@@ -4453,8 +4452,8 @@ impl<'a> LoweringContext<'a> {\n                     self.arm(hir_vec![ok_pat], val_expr)\n                 };\n \n-                // Err(err) => #[allow(unreachable_code)]\n-                //             return Try::from_error(From::from(err)),\n+                // `Err(err) => #[allow(unreachable_code)]\n+                //              return Try::from_error(From::from(err)),`\n                 let err_arm = {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let err_local = self.pat_ident(e.span, err_ident);\n@@ -5014,7 +5013,7 @@ impl<'a> LoweringContext<'a> {\n     /// error, depending on the mode.\n     fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n         match self.anonymous_lifetime_mode {\n-            // NB. We intentionally ignore the create-parameter mode here\n+            // N.B., We intentionally ignore the create-parameter mode here\n             // and instead \"pass through\" to resolve-lifetimes, which will then\n             // report an error. This is because we don't want to support\n             // impl elision for deprecated forms like"}, {"sha": "40904eaa5db62905b76d2866f0f8e7f8162431fb", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,7 +13,7 @@\n //! it captures a common set of attributes that all \"function-like\n //! things\" (represented by `FnLike` instances) share.  For example,\n //! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred).  And all `FnLike` instances have a body, i.e. the code\n+//! inferred).  And all `FnLike` instances have a body, i.e., the code\n //! that is run when the function-like thing it represents is invoked.\n //!\n //! With the above abstraction in place, one can treat the program\n@@ -34,7 +34,7 @@ use syntax_pos::Span;\n /// More specifically, it is one of either:\n ///\n ///   - A function item,\n-///   - A closure expr (i.e. an ExprKind::Closure), or\n+///   - A closure expr (i.e., an ExprKind::Closure), or\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function."}, {"sha": "d5031efae576b86a1708926aed3dceb35632e090", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -150,10 +150,9 @@ impl Decodable for DefPathTable {\n     }\n }\n \n-\n /// The definition table containing node definitions.\n-/// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n-/// mapping from NodeIds to local DefIds.\n+/// It holds the `DefPathTable` for local `DefId`s/`DefPath`s and it also stores a\n+/// mapping from `NodeId`s to local `DefId`s.\n #[derive(Clone, Default)]\n pub struct Definitions {\n     table: DefPathTable,"}, {"sha": "58d1a780f129c9f841823d5be6774fa36106ab23", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n-            let missing: Vec<_> = (0 .. max as u32 + 1)\n+            let missing: Vec<_> = (0 ..= max as u32)\n               .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId::from_u32(i)))\n               .collect();\n "}, {"sha": "de8a375ca6ddec46489d1b9e354f9c011f45ad11", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -159,6 +159,13 @@ impl Forest {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n+\n+    /// This is internally in the depedency tracking system.\n+    /// Use the `krate` method to ensure your dependency on the\n+    /// crate is tracked.\n+    pub fn untracked_krate<'hir>(&'hir self) -> &'hir Crate {\n+        &self.krate\n+    }\n }\n \n /// Represents a mapping from Node IDs to AST elements and their parent\n@@ -286,9 +293,7 @@ impl<'hir> Map<'hir> {\n \n         match node {\n             Node::Item(item) => {\n-                let def_id = || {\n-                    self.local_def_id(item.id)\n-                };\n+                let def_id = || self.local_def_id(item.id);\n \n                 match item.node {\n                     ItemKind::Static(_, m, _) => Some(Def::Static(def_id(), m == MutMutable)),\n@@ -383,23 +388,23 @@ impl<'hir> Map<'hir> {\n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body {\n         self.read(id.node_id);\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.body(id)\n     }\n@@ -413,7 +418,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the `NodeId` that corresponds to the definition of\n-    /// which this is the body of, i.e. a `fn`, `const` or `static`\n+    /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n@@ -475,7 +480,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfType.name(),\n+            Node::Item(&Item { node: ItemKind::Trait(..), .. }) => keywords::SelfUpper.name(),\n             Node::GenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n@@ -484,15 +489,15 @@ impl<'hir> Map<'hir> {\n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_auto_impl(&self, trait_did: DefId) -> Option<NodeId> {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_auto_impl.get(&trait_did).cloned()\n     }\n@@ -565,14 +570,14 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    /// Similar to get_parent, returns the parent node id or id if there is no\n-    /// parent. Note that the parent may be CRATE_NODE_ID, which is not itself\n+    /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n+    /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n     /// present in the map -- so passing the return value of get_parent_node to\n     /// get may actually panic.\n     /// This function returns the immediate parent in the AST, whereas get_parent\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n-    /// never appear as the parent_node. So you can always walk the parent_nodes\n+    /// never appear as the parent_node. So you can always walk the `parent_nodes`\n     /// from a node to the root of the ast (unless you get the same id back here\n     /// that can happen if the id is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n@@ -608,7 +613,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good node id we found. Note that reaching the crate root (id == 0),\n+    /// last good node id we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -644,7 +649,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the NodeId for `id`'s enclosing method, unless there's a\n+    /// Retrieve the `NodeId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n@@ -691,7 +696,7 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieve the NodeId for `id`'s parent item, or `id` itself if no\n+    /// Retrieve the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n@@ -708,13 +713,13 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the DefId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         self.local_def_id(self.get_module_parent_node(id))\n     }\n \n-    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n@@ -727,7 +732,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n-    /// FIXME it is not clear to me that all items qualify as scopes - statics\n+    /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n@@ -1258,8 +1263,8 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n }\n \n pub fn describe_def(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<Def> {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        tcx.hir.describe_def(node_id)\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        tcx.hir().describe_def(node_id)\n     } else {\n         bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n              def_id)"}, {"sha": "156d55b9e2fe61de4a2e97f9747fba2ed6217357", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// The Rust HIR.\n+// HIR datatypes. See the [rustc guide] for more info.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n@@ -71,7 +73,7 @@ pub mod print;\n \n /// A HirId uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the DefIndex of the directly enclosing\n-/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n+/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n@@ -181,7 +183,7 @@ pub enum ParamName {\n     Plain(Ident),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n-    /// e.g. the lifetimes in cases like these:\n+    /// e.g., the lifetimes in cases like these:\n     ///\n     ///     impl Foo for &u32\n     ///     impl Foo<'_> for u32\n@@ -197,7 +199,7 @@ pub enum ParamName {\n \n     /// Indicates an illegal name was given and an error has been\n     /// repored (so we should squelch other derived errors). Occurs\n-    /// when e.g. `'_` is used in the wrong place.\n+    /// when e.g., `'_` is used in the wrong place.\n     Error,\n }\n \n@@ -222,7 +224,7 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n \n-    /// User typed nothing. e.g. the lifetime in `&u32`.\n+    /// User typed nothing. e.g., the lifetime in `&u32`.\n     Implicit,\n \n     /// Indicates an error during lowering (usually `'_` in wrong place)\n@@ -311,7 +313,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::PathRoot.name()\n     }\n }\n \n@@ -351,7 +353,7 @@ pub struct PathSegment {\n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n     /// out of those only the segments with no type parameters\n-    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    /// to begin with, e.g., `Vec::new` is `<Vec<..>>::new::<..>`.\n     pub infer_types: bool,\n }\n \n@@ -388,7 +390,7 @@ impl PathSegment {\n     }\n \n     // FIXME: hack required because you can't create a static\n-    // GenericArgs, so you can't just return a &GenericArgs.\n+    // `GenericArgs`, so you can't just return a `&GenericArgs`.\n     pub fn with_generic_args<F, R>(&self, f: F) -> R\n         where F: FnOnce(&GenericArgs) -> R\n     {\n@@ -514,17 +516,17 @@ pub type GenericBounds = HirVec<GenericBound>;\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub enum LifetimeParamKind {\n-    // Indicates that the lifetime definition was explicitly declared, like:\n-    // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`\n+    // Indicates that the lifetime definition was explicitly declared (e.g., in\n+    // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n     Explicit,\n \n     // Indicates that the lifetime definition was synthetically added\n-    // as a result of an in-band lifetime usage like:\n-    // `fn foo(x: &'a u8) -> &'a u8 { x }`\n+    // as a result of an in-band lifetime usage (e.g., in\n+    // `fn foo(x: &'a u8) -> &'a u8 { x }`).\n     InBand,\n \n-    // Indication that the lifetime was elided like both cases here:\n-    // `fn foo(x: &u8) -> &'_ u8 { x }`\n+    // Indication that the lifetime was elided (e.g., in both cases in\n+    // `fn foo(x: &u8) -> &'_ u8 { x }`).\n     Elided,\n \n     // Indication that the lifetime name was somehow in error.\n@@ -533,7 +535,7 @@ pub enum LifetimeParamKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericParamKind {\n-    /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n+    /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n         kind: LifetimeParamKind,\n     },\n@@ -637,11 +639,11 @@ impl WhereClause {\n /// A single predicate in a `where` clause\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum WherePredicate {\n-    /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+    /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n-    /// A lifetime predicate, e.g. `'a: 'b+'c`\n+    /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n     RegionPredicate(WhereRegionPredicate),\n-    /// An equality predicate (unsupported)\n+    /// An equality predicate (unsupported).\n     EqPredicate(WhereEqPredicate),\n }\n \n@@ -667,15 +669,15 @@ pub struct WhereBoundPredicate {\n     pub bounds: GenericBounds,\n }\n \n-/// A lifetime predicate, e.g. `'a: 'b+'c`\n+/// A lifetime predicate, e.g., `'a: 'b+'c`\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n-/// An equality predicate (unsupported), e.g. `T=int`\n+/// An equality predicate (unsupported), e.g., `T=int`\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -697,7 +699,7 @@ pub struct Crate {\n     pub span: Span,\n     pub exported_macros: HirVec<MacroDef>,\n \n-    // NB: We use a BTreeMap here so that `visit_all_items` iterates\n+    // N.B., we use a BTreeMap here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n@@ -932,11 +934,11 @@ pub enum PatKind {\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `NodeId` is the canonical ID for the variable being bound,\n-    /// e.g. in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n     /// which is the pattern ID of the first `x`.\n     Binding(BindingAnnotation, NodeId, Ident, Option<P<Pat>>),\n \n-    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n+    /// A struct or struct variant pattern, e.g., `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n@@ -954,11 +956,11 @@ pub enum PatKind {\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n     /// A `box` pattern\n     Box(P<Pat>),\n-    /// A reference pattern, e.g. `&mut (a, b)`\n+    /// A reference pattern, e.g., `&mut (a, b)`\n     Ref(P<Pat>, Mutability),\n     /// A literal\n     Lit(P<Expr>),\n-    /// A range pattern, e.g. `1...2` or `1..2`\n+    /// A range pattern, e.g., `1...2` or `1..2`\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n@@ -1319,8 +1321,8 @@ pub enum BodyOwnerKind {\n \n /// A constant (expression) that's not an item or associated item,\n /// but needs its own `DefId` for type-checking, const-eval, etc.\n-/// These are usually found nested inside types (e.g. array lengths)\n-/// or expressions (e.g. repeat counts), and also used to define\n+/// These are usually found nested inside types (e.g., array lengths)\n+/// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct AnonConst {\n@@ -1541,12 +1543,12 @@ pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n-    /// E.g. an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// e.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n     Resolved(Option<P<Ty>>, P<Path>),\n \n-    /// Type-related paths, e.g. `<T>::default` or `<T>::Output`.\n+    /// Type-related paths, e.g., `<T>::default` or `<T>::Output`.\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n@@ -1633,7 +1635,7 @@ pub enum CaptureClause {\n     CaptureByRef,\n }\n \n-// NB: If you change this, you'll probably want to change the corresponding\n+// N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MutTy {\n@@ -1792,14 +1794,14 @@ pub enum TyKind {\n     Ptr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n     Rptr(Lifetime, MutTy),\n-    /// A bare function (e.g. `fn(usize) -> bool`)\n+    /// A bare function (e.g., `fn(usize) -> bool`)\n     BareFn(P<BareFnTy>),\n     /// The never type (`!`)\n     Never,\n     /// A tuple (`(A, B, C, D,...)`)\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n-    /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n+    /// associated type, e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n@@ -1814,7 +1816,7 @@ pub enum TyKind {\n     TraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// Unused for now\n     Typeof(AnonConst),\n-    /// TyKind::Infer means the type should be inferred instead of it having been\n+    /// `TyKind::Infer` means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n     /// Placeholder for a type that has failed to be defined.\n@@ -2017,23 +2019,23 @@ pub struct VariantKind {\n     pub name: Name,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n-    /// Explicit discriminant, eg `Foo = 1`\n+    /// Explicit discriminant, e.g., `Foo = 1`\n     pub disr_expr: Option<AnonConst>,\n }\n \n pub type Variant = Spanned<VariantKind>;\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseKind {\n-    /// One import, e.g. `use foo::bar` or `use foo::bar as baz`.\n+    /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n     // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n     Single,\n \n-    /// Glob import, e.g. `use foo::*`.\n+    /// Glob import, e.g., `use foo::*`.\n     Glob,\n \n-    /// Degenerate list import, e.g. `use foo::{a, b}` produces\n+    /// Degenerate list import, e.g., `use foo::{a, b}` produces\n     /// an additional `use foo::{}` for performing checks such as\n     /// unstable feature gating. May be removed in the future.\n     ListStem,\n@@ -2196,7 +2198,7 @@ pub struct FnHeader {\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n+    /// e.g., `extern crate foo` or `extern crate foo_bar as foo`\n     ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2218,15 +2220,15 @@ pub enum ItemKind {\n     ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from global_asm!)\n     GlobalAsm(P<GlobalAsm>),\n-    /// A type alias, e.g. `type Foo = Bar<u8>`\n+    /// A type alias, e.g., `type Foo = Bar<u8>`\n     Ty(P<Ty>, Generics),\n-    /// An existential type definition, e.g. `existential type Foo: Bar;`\n+    /// An existential type definition, e.g., `existential type Foo: Bar;`\n     Existential(ExistTy),\n-    /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n+    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n     Enum(EnumDef, Generics),\n-    /// A struct definition, e.g. `struct Foo<A> {x: A}`\n+    /// A struct definition, e.g., `struct Foo<A> {x: A}`\n     Struct(VariantData, Generics),\n-    /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n     Union(VariantData, Generics),\n     /// Represents a Trait Declaration\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),"}, {"sha": "d6816d3b81bf79fc2f93e8d5df0ee524532ca29f", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -101,7 +101,7 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n+    /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n         let mut contains_bindings = false;\n         self.walk(|p| {\n@@ -116,7 +116,7 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+    /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n         let mut contains_bindings = false;\n         self.walk(|p| {"}, {"sha": "5c6845181afd19725f6f7132cfc58455dbefd8d6", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -65,7 +65,7 @@ pub trait PpAnn {\n \n pub struct NoAnn;\n impl PpAnn for NoAnn {}\n-pub const NO_ANN: &'static dyn PpAnn = &NoAnn;\n+pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n     fn try_fetch_item(&self, item: ast::NodeId) -> Option<&hir::Item> {\n@@ -1622,8 +1622,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::CrateRoot.name() &&\n-               segment.ident.name != keywords::DollarCrate.name() {\n+            if segment.ident.name != keywords::PathRoot.name() {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n                    self.print_generic_args(generic_args, segment.infer_types,\n@@ -1636,8 +1635,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::CrateRoot.name() &&\n-           segment.ident.name != keywords::DollarCrate.name() {\n+        if segment.ident.name != keywords::PathRoot.name() {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n                self.print_generic_args(generic_args, segment.infer_types, false)\n@@ -1664,8 +1662,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::CrateRoot.name() &&\n-                       segment.ident.name != keywords::DollarCrate.name() {\n+                    if segment.ident.name != keywords::PathRoot.name() {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,\n@@ -2448,8 +2445,8 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n     }\n }\n \n-/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n-/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+/// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n     match value.node {"}, {"sha": "799c2df8a53c5d3775763165184daa5b26ee06e9", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -45,7 +45,7 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n /// This is the context state available during incr. comp. hashing. It contains\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n-/// things (e.g. each DefId/DefPath is only hashed once).\n+/// things (e.g., each DefId/DefPath is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n     sess: &'a Session,\n@@ -86,6 +86,7 @@ impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n+    #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n                definitions: &'a Definitions,"}, {"sha": "d82020f59a10ecbd4be52055b5fef06fb306d77d", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 15, "deletions": 46, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -46,7 +46,8 @@ impl_stable_hash_for!(enum mir::BorrowKind {\n \n impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n     General,\n-    MinConstFn,\n+    GeneralAndConstFn,\n+    GatedConstFnCall,\n     ExternStatic(lint_node_id),\n     BorrowPacked(lint_node_id),\n });\n@@ -193,52 +194,19 @@ for mir::TerminatorKind<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for mir::StatementKind<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::StatementKind::Assign(ref place, ref rvalue) => {\n-                place.hash_stable(hcx, hasher);\n-                rvalue.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::FakeRead(ref cause, ref place) => {\n-                cause.hash_stable(hcx, hasher);\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::SetDiscriminant { ref place, variant_index } => {\n-                place.hash_stable(hcx, hasher);\n-                variant_index.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::StorageLive(ref place) |\n-            mir::StatementKind::StorageDead(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::EscapeToRaw(ref place) => {\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::Retag { fn_entry, ref place } => {\n-                fn_entry.hash_stable(hcx, hasher);\n-                place.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::AscribeUserType(ref place, ref variance, ref c_ty) => {\n-                place.hash_stable(hcx, hasher);\n-                variance.hash_stable(hcx, hasher);\n-                c_ty.hash_stable(hcx, hasher);\n-            }\n-            mir::StatementKind::Nop => {}\n-            mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                asm.hash_stable(hcx, hasher);\n-                outputs.hash_stable(hcx, hasher);\n-                inputs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n+impl_stable_hash_for!(impl<'gcx> for enum mir::StatementKind<'gcx> [ mir::StatementKind ] {\n+    Assign(place, rvalue),\n+    FakeRead(cause, place),\n+    SetDiscriminant { place, variant_index },\n+    StorageLive(place),\n+    StorageDead(place),\n+    Retag(retag_kind, place),\n+    AscribeUserType(place, variance, c_ty),\n+    Nop,\n+    InlineAsm { asm, outputs, inputs },\n+});\n \n+impl_stable_hash_for!(enum mir::RetagKind { FnEntry, TwoPhase, Raw, Default });\n impl_stable_hash_for!(enum mir::FakeReadCause { ForMatchGuard, ForMatchedPlace, ForLet });\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n@@ -503,6 +471,7 @@ impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n \n impl_stable_hash_for!(enum mir::ConstraintCategory {\n     Return,\n+    Yield,\n     UseAsConst,\n     UseAsStatic,\n     TypeAnnotation,"}, {"sha": "3211937d3ddc712b1e7f5eac06282ec996a01ccd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -134,14 +134,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     const_stability\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::syntax::edition::Edition {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(enum ::syntax::edition::Edition {\n+    Edition2015,\n+    Edition2018,\n+});\n \n impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n@@ -269,10 +265,10 @@ for tokenstream::TokenTree {\n                 span.hash_stable(hcx, hasher);\n                 hash_token(token, hcx, hasher);\n             }\n-            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+            tokenstream::TokenTree::Delimited(span, delim, ref tts) => {\n                 span.hash_stable(hcx, hasher);\n-                std_hash::Hash::hash(&delimited.delim, hasher);\n-                for sub_tt in delimited.stream().trees() {\n+                std_hash::Hash::hash(&delim, hasher);\n+                for sub_tt in tts.stream().trees() {\n                     sub_tt.hash_stable(hcx, hasher);\n                 }\n             }\n@@ -417,13 +413,14 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Real(pb),\n     Macros(s),\n-    QuoteExpansion,\n-    Anon,\n-    MacroExpansion,\n-    ProcMacroSourceCode,\n-    CliCrateAttr,\n-    CfgSpec,\n-    Custom(s)\n+    QuoteExpansion(s),\n+    Anon(s),\n+    MacroExpansion(s),\n+    ProcMacroSourceCode(s),\n+    CliCrateAttr(s),\n+    CfgSpec(s),\n+    Custom(s),\n+    DocTest(pb, line),\n });\n \n impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {"}, {"sha": "56da6b719f4a7287f7b3d749105162a85606cb96", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -338,7 +338,7 @@ impl_stable_hash_for!(\n );\n \n impl_stable_hash_for!(\n-    impl<'tcx, M> for enum mir::interpret::AllocType<'tcx, M> [ mir::interpret::AllocType ] {\n+    impl<'tcx> for enum mir::interpret::AllocKind<'tcx> [ mir::interpret::AllocKind ] {\n         Function(instance),\n         Static(def_id),\n         Memory(mem),"}, {"sha": "fc2f1ee6ff892d4f241616e1afd05bf29c6fe083", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -24,15 +24,15 @@ mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n \n-pub const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n-pub const ATTR_CLEAN: &'static str = \"rustc_clean\";\n-pub const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n-pub const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n-pub const ATTR_PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n-pub const ATTR_PARTITION_CODEGENED: &'static str = \"rustc_partition_codegened\";\n-pub const ATTR_EXPECTED_CGU_REUSE: &'static str = \"rustc_expected_cgu_reuse\";\n+pub const ATTR_DIRTY: &str = \"rustc_dirty\";\n+pub const ATTR_CLEAN: &str = \"rustc_clean\";\n+pub const ATTR_IF_THIS_CHANGED: &str = \"rustc_if_this_changed\";\n+pub const ATTR_THEN_THIS_WOULD_NEED: &str = \"rustc_then_this_would_need\";\n+pub const ATTR_PARTITION_REUSED: &str = \"rustc_partition_reused\";\n+pub const ATTR_PARTITION_CODEGENED: &str = \"rustc_partition_codegened\";\n+pub const ATTR_EXPECTED_CGU_REUSE: &str = \"rustc_expected_cgu_reuse\";\n \n-pub const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n+pub const IGNORED_ATTRIBUTES: &[&str] = &[\n     \"cfg\",\n     ATTR_IF_THIS_CHANGED,\n     ATTR_THEN_THIS_WOULD_NEED,"}, {"sha": "2a8a340ab545280717bbe2a67817fd396f36cdf1", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -36,6 +36,7 @@ use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n use ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -116,6 +117,31 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         Ok(Lrc::new(canonical_result))\n     }\n \n+    /// A version of `make_canonicalized_query_response` that does\n+    /// not pack in obligations, for contexts that want to drop\n+    /// pending obligations instead of treating them as an ambiguity (e.g.\n+    /// typeck \"probing\" contexts).\n+    ///\n+    /// If you DO want to keep track of pending obligations (which\n+    /// include all region obligations, so this includes all cases\n+    /// that care about regions) with this function, you have to\n+    /// do it yourself, by e.g. having them be a part of the answer.\n+    pub fn make_query_response_ignoring_pending_obligations<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T\n+    ) -> Canonical<'gcx, QueryResponse<'gcx, <T as Lift<'gcx>>::Lifted>>\n+    where\n+        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+    {\n+        self.canonicalize_response(&QueryResponse {\n+            var_values: inference_vars,\n+            region_constraints: vec![],\n+            certainty: Certainty::Proven, // Ambiguities are OK!\n+            value: answer,\n+        })\n+    }\n+\n     /// Helper for `make_canonicalized_query_response` that does\n     /// everything up until the final canonicalization.\n     fn make_query_response<T>(\n@@ -527,32 +553,30 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n-        Box::new(\n-            unsubstituted_region_constraints\n-                .iter()\n-                .map(move |constraint| {\n-                    let constraint = substitute_value(self.tcx, result_subst, constraint);\n-                    let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n-\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        match k1.unpack() {\n-                            UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n-                                ty::Binder::bind(\n-                                    ty::OutlivesPredicate(r1, r2)\n-                                )\n-                            ),\n-                            UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n-                                ty::Binder::bind(\n-                                    ty::OutlivesPredicate(t1, r2)\n-                                )\n-                            ),\n-                        }\n-                    )\n-                })\n-        ) as Box<dyn Iterator<Item = _>>\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'gcx> {\n+        unsubstituted_region_constraints\n+            .iter()\n+            .map(move |constraint| {\n+                let constraint = substitute_value(self.tcx, result_subst, constraint);\n+                let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+\n+                Obligation::new(\n+                    cause.clone(),\n+                    param_env,\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                            ty::Binder::bind(\n+                                ty::OutlivesPredicate(r1, r2)\n+                            )\n+                        ),\n+                        UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n+                            ty::Binder::bind(\n+                                ty::OutlivesPredicate(t1, r2)\n+                            )\n+                        ),\n+                    }\n+                )\n+            })\n     }\n \n     /// Given two sets of values for the same set of canonical variables, unify them."}, {"sha": "833da67d3f1750a89e1d73613a52b488d0bfc1dd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -347,6 +347,10 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.infcx.trait_object_mode()\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"Generalizer\"\n     }\n@@ -371,7 +375,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         if self.ambient_variance == ty::Variance::Invariant {\n             // Avoid fetching the variance if we are in an invariant\n             // context; no need, and it can induce dependency cycles\n-            // (e.g. #41849).\n+            // (e.g., #41849).\n             relate::relate_substs(self, None, a_subst, b_subst)\n         } else {\n             let opt_variances = self.tcx().variances_of(item_def_id);"}, {"sha": "caa120fa267023b9c6f64f61b372dfec88a6c9b1", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -39,6 +39,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn relate_item_substs(&mut self,\n@@ -47,9 +51,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                           b_subst: &'tcx Substs<'tcx>)\n                           -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     {\n-        // NB: Once we are equating types, we don't care about\n+        // N.B., once we are equating types, we don't care about\n         // variance, so don't try to lookup the variance here. This\n-        // also avoids some cycles (e.g. #41849) since looking up\n+        // also avoids some cycles (e.g., #41849) since looking up\n         // variance requires computing types which can require\n         // performing trait matching (which then performs equality\n         // unification)."}, {"sha": "d213a5c56187141f6f169ca93affa41617bacfbf", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n+                let tag = match self.hir().find(scope.node_id(self, region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n                     Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n@@ -190,8 +190,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let cm = self.sess.source_map();\n \n         let scope = region.free_region_binding_scope(self);\n-        let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n-        let tag = match self.hir.find(node) {\n+        let node = self.hir().as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n+        let tag = match self.hir().find(node) {\n             Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n             Some(Node::Item(it)) => Self::item_scope_tag(&it),\n             Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n@@ -200,8 +200,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir\n+                let mut sp = cm.def_span(self.hir().span(node));\n+                if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&br.name))\n                 {\n@@ -213,8 +213,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, ref name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir.span(node));\n-                if let Some(param) = self.hir\n+                let mut sp = cm.def_span(self.hir().span(node));\n+                if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(&name))\n                 {\n@@ -225,15 +225,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir.span(node),\n+                    self.hir().span(node),\n                 ),\n                 ty::BrFresh(_) => (\n                     \"an anonymous lifetime defined on\".to_owned(),\n-                    self.hir.span(node),\n+                    self.hir().span(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", fr.bound_region),\n-                    cm.def_span(self.hir.span(node)),\n+                    cm.def_span(self.hir().span(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -1083,7 +1083,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // the expected type argument.\n                     if !param.is_self() {\n                         let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir;\n+                        let hir = &self.tcx.hir();\n                         hir.as_local_node_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n@@ -1095,15 +1095,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             let sp = hir.span(id);\n                             // `sp` only covers `T`, change it so that it covers\n                             // `T:` when appropriate\n-                            let sp = if has_bounds {\n+                            let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n+                            let sp = if has_bounds && !is_impl_trait {\n                                 sp.to(self.tcx\n                                     .sess\n                                     .source_map()\n                                     .next_point(self.tcx.sess.source_map().next_point(sp)))\n                             } else {\n                                 sp\n                             };\n-                            (sp, has_bounds)\n+                            (sp, has_bounds, is_impl_trait)\n                         })\n                     } else {\n                         None\n@@ -1136,25 +1137,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         fn binding_suggestion<'tcx, S: fmt::Display>(\n             err: &mut DiagnosticBuilder<'tcx>,\n-            type_param_span: Option<(Span, bool)>,\n+            type_param_span: Option<(Span, bool, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n         ) {\n-            let consider = &format!(\n-                \"consider adding an explicit lifetime bound `{}: {}`...\",\n-                bound_kind, sub\n+            let consider = format!(\n+                \"consider adding an explicit lifetime bound {}\",\n+                if type_param_span.map(|(_, _, is_impl_trait)| is_impl_trait).unwrap_or(false) {\n+                    format!(\" `{}` to `{}`...\", sub, bound_kind)\n+                } else {\n+                    format!(\"`{}: {}`...\", bound_kind, sub)\n+                },\n             );\n-            if let Some((sp, has_lifetimes)) = type_param_span {\n-                let tail = if has_lifetimes { \" + \" } else { \"\" };\n-                let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n+            if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n+                let suggestion = if is_impl_trait {\n+                    format!(\"{} + {}\", bound_kind, sub)\n+                } else {\n+                    let tail = if has_lifetimes { \" + \" } else { \"\" };\n+                    format!(\"{}: {}{}\", bound_kind, sub, tail)\n+                };\n                 err.span_suggestion_short_with_applicability(\n                     sp,\n-                    consider,\n+                    &consider,\n                     suggestion,\n                     Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n-                err.help(consider);\n+                err.help(&consider);\n             }\n         }\n \n@@ -1315,8 +1324,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter `{}` in coherence check\", name)\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n             infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),"}, {"sha": "4064df0a09d7ff13cf5b1bd46330b7d18f4cf28d", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -109,13 +109,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut local_visitor = FindLocalByTypeVisitor {\n             infcx: &self,\n             target_ty: &ty,\n-            hir_map: &self.tcx.hir,\n+            hir_map: &self.tcx.hir(),\n             found_local_pattern: None,\n             found_arg_pattern: None,\n         };\n \n         if let Some(body_id) = body_id {\n-            let expr = self.tcx.hir.expect_expr(body_id.node_id);\n+            let expr = self.tcx.hir().expect_expr(body_id.node_id);\n             local_visitor.visit_expr(expr);\n         }\n "}, {"sha": "df0dcbed30afa1ce361d1495bd0140550dcc1f39", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -30,16 +30,16 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///    { x.push(y); }\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n-    /// for e.g. `&u8` and Vec<`&u8`.\n+    /// for e.g., `&u8` and Vec<`&u8`.\n     pub(super) fn find_anon_type(\n         &self,\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.tcx.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let fndecl = match self.tcx.hir.get(node_id) {\n+            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n+                let fndecl = match self.tcx.hir().get(node_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n@@ -97,14 +97,14 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n     // The type where the anonymous lifetime appears\n-    // for e.g. Vec<`&u8`> and <`&u8`>\n+    // for e.g., Vec<`&u8`> and <`&u8`>\n     found_type: Option<&'gcx hir::Ty>,\n     current_index: ty::DebruijnIndex,\n }\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_ty(&mut self, arg: &'gcx hir::Ty) {\n@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n \n             hir::TyKind::Rptr(ref lifetime, _) => {\n                 // the lifetime of the TyRptr\n-                let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n                 match (self.tcx.named_region(hir_id), self.bound_region) {\n                     // Find the index of the anonymous region that was part of the\n                     // error. We will then search the function parameters for a bound\n@@ -150,7 +150,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     // region at the right depth with the same index\n                     (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                         debug!(\n-                            \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                            \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n                              def_id={:?}\",\n                             id,\n                             def_id\n@@ -172,7 +172,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                             \"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                             debruijn_index\n                         );\n-                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n+                        debug!(\"self.infcx.tcx.hir().local_def_id(id)={:?}\", id);\n                         debug!(\"def_id={:?}\", def_id);\n                         if debruijn_index == self.current_index && id == def_id {\n                             self.found_type = Some(arg);\n@@ -227,11 +227,11 @@ struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        let hir_id = self.tcx.hir.node_to_hir_id(lifetime.id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(lifetime.id);\n         match (self.tcx.named_region(hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n             (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n@@ -243,7 +243,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n \n             (Some(rl::Region::EarlyBound(_, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\n-                    \"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n+                    \"EarlyBound self.infcx.tcx.hir().local_def_id(id)={:?} \\\n                      def_id={:?}\",\n                     id,\n                     def_id"}, {"sha": "4c3fbc79646592b4767797273d92bf18ed188302", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             // closure, provide a specific message pointing this out.\n             if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n-                let hir = &self.tcx.hir;\n+                let hir = &self.tcx.hir();\n                 if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),"}, {"sha": "e5c2c75a3f3843c553fc64451a28cd3060d7a31d", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir = &self.tcx.hir;\n+        let hir = &self.tcx.hir();\n         if let Some(node_id) = hir.as_local_node_id(id) {\n             if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n                 let body = hir.body(body_id);"}, {"sha": "f5ac39ae838f6f0d23d1ae2f3c2ca580dd415640", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\", var_name));\n             }\n@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that captured variable `{}` does not outlive the \\\n                                         enclosing closure\",\n-                                       self.tcx.hir.name(id)));\n+                                       self.tcx.hir().name(id)));\n             }\n             infer::IndexSlice(span) => {\n                 err.span_note(span, \"...so that slice is not indexed outside the lifetime\");\n@@ -174,8 +174,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                let var_node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                let var_name = self.tcx.hir.name(var_node_id);\n+                let var_node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                let var_name = self.tcx.hir().name(var_node_id);\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0313,\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0474,\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n-                                               self.tcx.hir.name(id));\n+                                               self.tcx.hir().name(id));\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,\n                     \"captured variable is valid for \", sup, \"\");\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err,"}, {"sha": "ba21ebb49eb95a99db0d40b17e0301c5722c2c49", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,7 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -36,6 +36,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "c8cd11c8198772cfc3646d58a57aedaaa75c6402", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Pops the placeholder regions found in `placeholder_map` from the region\n     /// inference context. Whenever you create placeholder regions via\n     /// `replace_bound_vars_with_placeholders`, they must be popped before you\n-    /// commit the enclosing snapshot (if you do not commit, e.g. within a\n+    /// commit the enclosing snapshot (if you do not commit, e.g., within a\n     /// probe or as a result of an error, then this is not necessary, as\n     /// popping happens as part of the rollback).\n     ///"}, {"sha": "512e57d810aa43b783e896fe6c0818b519be5da4", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -31,9 +31,8 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry::Vacant;\n use std::collections::btree_map::BTreeMap;\n use std::env;\n-use std::fs::File;\n+use std::fs;\n use std::io;\n-use std::io::prelude::*;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n fn print_help_message() {\n@@ -268,5 +267,5 @@ fn dump_region_data_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, '\n     debug!(\"dump_region_data calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();\n-    File::create(path).and_then(|mut f| f.write_all(&v))\n+    fs::write(path, &v)\n }"}, {"sha": "80fad447b46e30e75dd506ad3499d84cc3d3bb2b", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,7 +15,7 @@ use super::Subtype;\n \n use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -36,6 +36,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }"}, {"sha": "7ce59b1d9d765e59c0f8c99844731e9f7cf4339a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -35,9 +35,9 @@ use syntax_pos::{self, Span};\n use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n+use ty::relate::{RelateResult, TraitObjectMode};\n use ty::subst::{Kind, Substs};\n-use ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n \n@@ -182,6 +182,9 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     // This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n+    // The TraitObjectMode used here,\n+    trait_object_mode: TraitObjectMode,\n+\n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n     // outlive the lifetime 'a\". These constraints derive from\n@@ -219,7 +222,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// `UniverseIndex::root()` but grows from there as we enter\n     /// universal quantifiers.\n     ///\n-    /// NB: At present, we exclude the universal quantifiers on the\n+    /// N.B., at present, we exclude the universal quantifiers on the\n     /// item we are type-checking, and just consider those names as\n     /// part of the root universe. So this would only get incremented\n     /// when we enter into a higher-ranked (`for<..>`) type or trait\n@@ -471,15 +474,19 @@ impl fmt::Display for FixupError {\n pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n+    interners: Option<CtxtInterners<'tcx>>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n+    trait_object_mode: TraitObjectMode,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     pub fn infer_ctxt(self) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: SyncDroplessArena::default(),\n+            interners: None,\n             fresh_tables: None,\n+            trait_object_mode: TraitObjectMode::NoSquash,\n         }\n     }\n }\n@@ -492,6 +499,12 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         self\n     }\n \n+    pub fn with_trait_object_mode(mut self, mode: TraitObjectMode) -> Self {\n+        debug!(\"with_trait_object_mode: setting mode to {:?}\", mode);\n+        self.trait_object_mode = mode;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -518,14 +531,19 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n+            trait_object_mode,\n             ref arena,\n+            ref mut interners,\n             ref fresh_tables,\n         } = *self;\n         let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(arena, |tcx| {\n+        // Check that we haven't entered before\n+        assert!(interners.is_none());\n+        global_tcx.enter_local(arena, interners, |tcx| {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n+                trait_object_mode,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n@@ -607,6 +625,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n+    pub fn trait_object_mode(&self) -> TraitObjectMode {\n+        self.trait_object_mode\n+    }\n+\n     pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n@@ -732,7 +754,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n-            // Borrow tables \"in progress\" (i.e. during typeck)\n+            // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n         }\n@@ -1047,7 +1069,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // type parameter definition. The substitutions are\n                 // for actual parameters that may be referred to by\n                 // the default of this type parameter, if it exists.\n-                // E.g. `struct Foo<A, B, C = (A, B)>(...);` when\n+                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n@@ -1253,6 +1275,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }\n \n+    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n+        self.type_variables.borrow_mut().root_var(var)\n+    }\n+\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1261,7 +1287,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * Where possible, replaces type/int/float variables in\n          * `value` with their final value. Note that region variables\n          * are unaffected. If a type variable has not been unified, it\n-         * is left as is.  This is an idempotent operation that does\n+         * is left as is. This is an idempotent operation that does\n          * not affect inference state in any way and so you can do it\n          * at will.\n          */\n@@ -1298,7 +1324,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n-         * by calling `resolve_regions_and_report_errors`).  If some\n+         * by calling `resolve_regions_and_report_errors`). If some\n          * variable was never unified, an `Err` results.\n          *\n          * This method is idempotent, but it not typically not invoked\n@@ -1331,7 +1357,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n-        // Don't report an error if actual type is Error.\n+        // Don't report an error if actual type is `Error`.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }"}, {"sha": "0ce0eb9a1abae169804d5c249a8e91888e3bd40e", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,7 +15,7 @@\n //!\n //! Here are the key differences:\n //!\n-//! - This code may choose to bypass some checks (e.g. the occurs check)\n+//! - This code may choose to bypass some checks (e.g., the occurs check)\n //!   in the case where we know that there are no unbound type inference\n //!   variables. This is the case for NLL, because at NLL time types are fully\n //!   inferred up-to regions.\n@@ -97,7 +97,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// region that is instantiated existentially. This creates an\n     /// inference variable, typically.\n     ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// So e.g., if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n@@ -107,7 +107,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// higher-ranked region that is instantiated universally.\n     /// This creates a new region placeholder, typically.\n     ///\n-    /// So e.g. if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n+    /// So e.g., if you have `for<'a> fn(..) <: for<'b> fn(..)`, then\n     /// we will invoke this method to instantiate `'b` with a\n     /// placeholder region.\n     fn next_placeholder_region(&mut self, placeholder: ty::PlaceholderRegion) -> ty::Region<'tcx>;\n@@ -382,6 +382,13 @@ where\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        // squashing should only be done in coherence, not NLL\n+        assert_eq!(self.infcx.trait_object_mode(),\n+                   relate::TraitObjectMode::NoSquash);\n+        relate::TraitObjectMode::NoSquash\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::subtype\"\n     }\n@@ -696,6 +703,13 @@ where\n         self.infcx.tcx\n     }\n \n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        // squashing should only be done in coherence, not NLL\n+        assert_eq!(self.infcx.trait_object_mode(),\n+                   relate::TraitObjectMode::NoSquash);\n+        relate::TraitObjectMode::NoSquash\n+    }\n+\n     fn tag(&self) -> &'static str {\n         \"nll::generalizer\"\n     }"}, {"sha": "44c5fe5acaa2b1407aeff4a53af31e56fb0aaa94", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -691,13 +691,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_node_id) = tcx.hir.as_local_node_id(def_id) {\n+                    if let Some(opaque_node_id) = tcx.hir().as_local_node_id(def_id) {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n-                            let opaque_parent_node_id = tcx.hir.get_parent(opaque_node_id);\n-                            parent_def_id == tcx.hir.local_def_id(opaque_parent_node_id)\n+                            let opaque_parent_node_id = tcx.hir().get_parent(opaque_node_id);\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_node_id)\n                         };\n-                        let in_definition_scope = match tcx.hir.find(opaque_node_id) {\n+                        let in_definition_scope = match tcx.hir().find(opaque_node_id) {\n                             Some(Node::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n@@ -725,7 +725,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir.node_to_string(opaque_node_id),\n+                                tcx.hir().node_to_string(opaque_node_id),\n                             ),\n                         };\n                         if in_definition_scope {\n@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n \n         // Use the same type variable if the exact same Opaque appears more\n-        // than once in the return type (e.g. if it's passed to a type alias).\n+        // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n             return opaque_defn.concrete_ty;\n         }\n@@ -783,7 +783,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         );\n \n         // make sure that we are in fact defining the *entire* type\n-        // e.g. `existential type Foo<T: Bound>: Bar;` needs to be\n+        // e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`.\n         debug!(\n             \"instantiate_opaque_types: param_env: {:#?}\",\n@@ -848,16 +848,16 @@ pub fn may_define_existential_type(\n     opaque_node_id: ast::NodeId,\n ) -> bool {\n     let mut node_id = tcx\n-        .hir\n+        .hir()\n         .as_local_node_id(def_id)\n         .unwrap();\n     // named existential types can be defined by any siblings or\n     // children of siblings\n-    let mod_id = tcx.hir.get_parent(opaque_node_id);\n+    let mod_id = tcx.hir().get_parent(opaque_node_id);\n     // so we walk up the node tree until we hit the root or the parent\n     // of the opaque type\n     while node_id != mod_id && node_id != ast::CRATE_NODE_ID {\n-        node_id = tcx.hir.get_parent(node_id);\n+        node_id = tcx.hir().get_parent(node_id);\n     }\n     // syntactically we are allowed to define the concrete type\n     node_id == mod_id"}, {"sha": "7b21a6992a70ebe6cab6d14e2ee268fbe6690328", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -408,7 +408,7 @@ where\n \n         // Remove outlives bounds that we get from the environment but\n         // which are also deducable from the trait. This arises (cc\n-        // #55756) in cases where you have e.g. `<T as Foo<'a>>::Item:\n+        // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n         approx_env_bounds.retain(|bound| {"}, {"sha": "9cac73dfab080b13dde0d71901108338c1a1d253", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -60,7 +60,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// which can never be rolled back.\n     undo_log: Vec<UndoLog<'tcx>>,\n \n-    /// The number of open snapshots, i.e. those that haven't been committed or\n+    /// The number of open snapshots, i.e., those that haven't been committed or\n     /// rolled back.\n     num_open_snapshots: usize,\n \n@@ -607,7 +607,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n-        // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n+        // replaced with \"less informative\" origins e.g., during calls to `can_eq`\n         let in_snapshot = self.in_snapshot();\n         let undo_log = &mut self.undo_log;\n         self.data.constraints.entry(constraint).or_insert_with(|| {"}, {"sha": "ef2ef3f8a86014ca847f2a6f9f403d7dfc8b8890", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,7 +15,7 @@ use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::fold::TypeFoldable;\n-use ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use ty::relate::{self, Cause, Relate, RelateResult, TypeRelation};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -43,6 +43,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n     for Sub<'combine, 'infcx, 'gcx, 'tcx>\n {\n     fn tag(&self) -> &'static str { \"Sub\" }\n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.fields.infcx.trait_object_mode()\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "b7aac23b955c6a1e03805e72967d4b5d649a43f7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// Creates a new type variable.\n     ///\n     /// - `diverging`: indicates if this is a \"diverging\" type\n-    ///   variable, e.g.  one created as the type of a `return`\n+    ///   variable, e.g.,  one created as the type of a `return`\n     ///   expression. The code in this module doesn't care if a\n     ///   variable is diverging, but the main Rust type-checker will\n     ///   sometimes \"unify\" such variables with the `!` or `()` types."}, {"sha": "b76fb0ed08c992e084d04de9b886babbb9deadec", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -60,10 +60,12 @@\n #![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n+#![feature(thread_local)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(step_trait)]\n+#![feature(stmt_expr_attributes)]\n #![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n@@ -119,7 +121,7 @@ extern crate test;\n #[macro_use]\n mod macros;\n \n-// NB: This module needs to be declared first so diagnostics are\n+// N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n "}, {"sha": "0cde9ebf65486dbb29509522970f1b0e028af6a0", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -174,7 +174,7 @@ declare_lint! {\n declare_lint! {\n     pub LEGACY_DIRECTORY_OWNERSHIP,\n     Deny,\n-    \"non-inline, non-`#[path]` modules (e.g. `mod foo;`) were erroneously allowed in some files \\\n+    \"non-inline, non-`#[path]` modules (e.g., `mod foo;`) were erroneously allowed in some files \\\n      not named `mod.rs`\"\n }\n \n@@ -208,6 +208,12 @@ declare_lint! {\n     \"potentially-conflicting impls were erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n+    Deny,\n+    \"trait-object types were treated as different depending on marker-trait order\"\n+}\n+\n declare_lint! {\n     pub BAD_REPR,\n     Warn,\n@@ -309,19 +315,19 @@ declare_lint! {\n declare_lint! {\n     pub INTRA_DOC_LINK_RESOLUTION_FAILURE,\n     Warn,\n-    \"warn about documentation intra links resolution failure\"\n+    \"failures in resolving intra-doc link targets\"\n }\n \n declare_lint! {\n     pub MISSING_DOC_CODE_EXAMPLES,\n     Allow,\n-    \"warn about missing code example in an item's documentation\"\n+    \"detects publicly-exported items without code samples in their documentation\"\n }\n \n declare_lint! {\n     pub PRIVATE_DOC_TESTS,\n     Allow,\n-    \"warn about doc test in private item\"\n+    \"detects code samples in docs of private items not documented by rustdoc\"\n }\n \n declare_lint! {\n@@ -365,8 +371,15 @@ pub mod parser {\n     }\n }\n \n+declare_lint! {\n+    pub DEPRECATED_IN_FUTURE,\n+    Allow,\n+    \"detects use of items that will be deprecated in a future version\",\n+    report_in_external_macro: true\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n-/// which are used by other parts of the compiler.\n+/// that are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n pub struct HardwiredLints;\n \n@@ -405,6 +418,7 @@ impl LintPass for HardwiredLints {\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n             INCOHERENT_FUNDAMENTAL_IMPLS,\n+            ORDER_DEPENDENT_TRAIT_OBJECTS,\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,\n@@ -427,6 +441,7 @@ impl LintPass for HardwiredLints {\n             MACRO_USE_EXTERN_CRATE,\n             MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n             parser::QUESTION_MARK_MACRO_SEP,\n+            DEPRECATED_IN_FUTURE,\n         )\n     }\n }\n@@ -463,7 +478,7 @@ impl BuiltinLintDiagnostics {\n                     Ok(ref s) => {\n                         // FIXME(Manishearth) ideally the emitting code\n                         // can tell us whether or not this is global\n-                        let opt_colon = if s.trim_left().starts_with(\"::\") {\n+                        let opt_colon = if s.trim_start().starts_with(\"::\") {\n                             \"\"\n                         } else {\n                             \"::\""}, {"sha": "131dedb9888326bbc273c581dacd2fca86010c06", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -42,11 +42,12 @@ use util::nodemap::FxHashMap;\n use std::default::Default as StdDefault;\n use syntax::ast;\n use syntax::edition;\n-use syntax_pos::{MultiSpan, Span, symbol::LocalInternedString};\n+use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n use errors::DiagnosticBuilder;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n+use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n \n /// Information about the registered lints.\n@@ -139,8 +140,8 @@ struct LintGroup {\n \n pub enum CheckLintNameResult<'a> {\n     Ok(&'a [LintId]),\n-    /// Lint doesn't exist\n-    NoLint,\n+    /// Lint doesn't exist. Potentially contains a suggestion for a correct lint name.\n+    NoLint(Option<Symbol>),\n     /// The lint is either renamed or removed. This is the warning\n     /// message, and an optional new name (`None` if removed).\n     Warning(String, Option<String>),\n@@ -359,8 +360,14 @@ impl LintStore {\n             CheckLintNameResult::Warning(ref msg, _) => {\n                 Some(sess.struct_warn(msg))\n             },\n-            CheckLintNameResult::NoLint => {\n-                Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n+            CheckLintNameResult::NoLint(suggestion) => {\n+                let mut err = struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name);\n+\n+                if let Some(suggestion) = suggestion {\n+                    err.help(&format!(\"did you mean: `{}`\", suggestion));\n+                }\n+\n+                Some(err)\n             }\n             CheckLintNameResult::Tool(result) => match result {\n                 Err((Some(_), new_name)) => Some(sess.struct_warn(&format!(\n@@ -464,7 +471,16 @@ impl LintStore {\n         match self.by_name.get(&complete_name) {\n             None => match self.lint_groups.get(&*complete_name) {\n                 // Now we are sure, that this lint exists nowhere\n-                None => CheckLintNameResult::NoLint,\n+                None => {\n+                    let symbols = self.by_name.keys()\n+                        .map(|name| Symbol::intern(&name))\n+                        .collect::<Vec<_>>();\n+\n+                    let suggestion =\n+                        find_best_match_for_name(symbols.iter(), &lint_name.to_lowercase(), None);\n+\n+                    CheckLintNameResult::NoLint(suggestion)\n+                }\n                 Some(LintGroup { lint_ids, depr, .. }) => {\n                     // Reaching this would be weird, but let's cover this case anyway\n                     if let Some(LintAlias { name, silent }) = depr {\n@@ -484,7 +500,7 @@ impl LintStore {\n             Some(&Id(ref id)) => {\n                 CheckLintNameResult::Tool(Err((Some(slice::from_ref(id)), complete_name)))\n             }\n-            _ => CheckLintNameResult::NoLint,\n+            _ => CheckLintNameResult::NoLint(None),\n         }\n     }\n }\n@@ -774,7 +790,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         where F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir.local_def_id(id));\n+        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id(id));\n         f(self);\n         self.param_env = old_param_env;\n     }\n@@ -797,13 +813,13 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.hir)\n+        hir_visit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -866,7 +882,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // in order for `check_fn` to be able to use them.\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.hir.body(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         run_lints!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, fk, decl, body, span, id);\n@@ -1191,7 +1207,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let passes = tcx.sess.lint_store.borrow_mut().late_passes.take();\n \n     let passes = {\n@@ -1270,7 +1286,7 @@ pub fn check_ast_crate(\n     //\n     // Rustdoc runs everybody-loops before the early lints and removes\n     // function bodies, so it's totally possible for linted\n-    // node ids to not exist (e.g. macros defined within functions for the\n+    // node ids to not exist (e.g., macros defined within functions for the\n     // unused_macro lint) anymore. So we only run this check\n     // when we're not in rustdoc mode. (see issue #47639)\n     if !sess.opts.actually_rustdoc {"}, {"sha": "9ab8e89df72e6db01a75ffa117e777d938664fc0", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -66,7 +66,7 @@ impl LintLevelSets {\n         for &(ref lint_name, level) in &sess.opts.lint_opts {\n             store.check_lint_name_cmdline(sess, &lint_name, level);\n \n-            // If the cap is less than this specified level, e.g. if we've got\n+            // If the cap is less than this specified level, e.g., if we've got\n             // `--cap-lints allow` but we've also got `-D foo` then we ignore\n             // this specification as the lint cap will set it to allow anyway.\n             let level = cmp::min(level, self.lint_cap);\n@@ -191,7 +191,7 @@ impl<'a> LintLevelsBuilder<'a> {\n     /// * It'll validate all lint-related attributes in `attrs`\n     /// * It'll mark all lint-related attributes as used\n     /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g. a #[forbid] can't be switched to\n+    /// * Lint attributes are validated, e.g., a #[forbid] can't be switched to\n     ///   #[allow]\n     ///\n     /// Don't forget to call `pop`!\n@@ -385,7 +385,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         }\n                         err.emit();\n                     }\n-                    CheckLintNameResult::NoLint => {\n+                    CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) = self.sets.get_lint_level(lint,\n                                                                     self.cur,\n@@ -398,22 +398,17 @@ impl<'a> LintLevelsBuilder<'a> {\n                                                 src,\n                                                 Some(li.span.into()),\n                                                 &msg);\n-                        if name.as_str().chars().any(|c| c.is_uppercase()) {\n-                            let name_lower = name.as_str().to_lowercase().to_string();\n-                            if let CheckLintNameResult::NoLint =\n-                                    store.check_lint_name(&name_lower, tool_name) {\n-                                db.emit();\n-                            } else {\n-                                db.span_suggestion_with_applicability(\n-                                    li.span,\n-                                    \"lowercase the lint name\",\n-                                    name_lower,\n-                                    Applicability::MachineApplicable\n-                                ).emit();\n-                            }\n-                        } else {\n-                            db.emit();\n+\n+                        if let Some(suggestion) = suggestion {\n+                            db.span_suggestion_with_applicability(\n+                                li.span,\n+                                \"did you mean\",\n+                                suggestion.to_string(),\n+                                Applicability::MachineApplicable,\n+                            );\n                         }\n+\n+                        db.emit();\n                     }\n                 }\n             }"}, {"sha": "7a8aa7e362abbb0339974f986383b4c7a2db33e7", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -67,7 +67,7 @@ pub struct Lint {\n     /// `declare_lint!()` invocations to follow the convention of upper-case\n     /// statics without repeating the name.\n     ///\n-    /// The name is written with underscores, e.g. \"unused_imports\".\n+    /// The name is written with underscores, e.g., \"unused_imports\".\n     /// On the command line, underscores become dashes.\n     pub name: &'static str,\n \n@@ -76,7 +76,7 @@ pub struct Lint {\n \n     /// Description of the lint or the issue it detects.\n     ///\n-    /// e.g. \"imports that are never used\"\n+    /// e.g., \"imports that are never used\"\n     pub desc: &'static str,\n \n     /// Starting at the given edition, default to the given lint level. If this is `None`, then use\n@@ -173,7 +173,7 @@ pub type LintArray = Vec<&'static Lint>;\n pub trait LintPass {\n     /// Get descriptions of the lints this `LintPass` object can emit.\n     ///\n-    /// NB: there is no enforcement that the object only emits lints it registered.\n+    /// N.B., there is no enforcement that the object only emits lints it registered.\n     /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n     /// parts of the compiler. If you want enforced access restrictions for your\n     /// `Lint`, make it a private `static` item in its own module.\n@@ -643,7 +643,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n         levels: LintLevelSets::builder(tcx.sess),\n         tcx: tcx,\n     };\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n \n     builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n         intravisit::walk_crate(builder, krate);\n@@ -665,15 +665,15 @@ impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(self.tcx.hir.definitions().node_to_hir_id(id));\n+        self.levels.register_id(self.tcx.hir().definitions().node_to_hir_id(id));\n         f(self);\n         self.levels.pop(push);\n     }\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {"}, {"sha": "c7f93512cd89bf497480943b36e5247093ee77e9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -59,7 +59,7 @@ pub enum DepKind {\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n-    /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n+    /// doesn't need to be linked to an rlib, e.g., the injected allocator.\n     Implicit,\n     /// A dependency that is required by an rlib version of this crate.\n     /// Ordinary `extern crate`s result in `Explicit` dependencies."}, {"sha": "934d7c12be552883565e14c9b6f7dc593e34f04a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -35,7 +35,7 @@ use syntax_pos;\n // may need to be marked as live.\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n-    match tcx.hir.find(node_id) {\n+    match tcx.hir().find(node_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n@@ -59,7 +59,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n             if should_explore(self.tcx, node_id) {\n                 self.worklist.push(node_id);\n             }\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+        if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n             debug_assert!(!should_explore(self.tcx, node_id));\n             self.live_symbols.insert(node_id);\n         }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref node) = self.tcx.hir.find(id) {\n+            if let Some(ref node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id(item.id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n@@ -166,6 +166,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     hir::ItemKind::Fn(..)\n                     | hir::ItemKind::Ty(..)\n                     | hir::ItemKind::Static(..)\n+                    | hir::ItemKind::Existential(..)\n                     | hir::ItemKind::Const(..) => {\n                         intravisit::walk_item(self, &item);\n                     }\n@@ -205,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -306,11 +307,11 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n         return true;\n     }\n \n-    let def_id = tcx.hir.local_def_id(id);\n+    let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n \n     // #[used], #[no_mangle], #[export_name], etc also keeps the item alive\n-    // forcefully, e.g. for placing it in a specific section.\n+    // forcefully, e.g., for placing it in a specific section.\n     if cg_attrs.contains_extern_indicator() ||\n         cg_attrs.flags.contains(CodegenFnAttrFlags::USED) {\n         return true;\n@@ -468,7 +469,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n+        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n             && !self.symbol_is_live(field.id, None)\n             && !field_type.is_phantom_data()\n@@ -509,11 +510,11 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir.local_def_id(id);\n+        let def_id = self.tcx.hir().local_def_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_node_id) = self.tcx.hir.as_local_node_id(item_did) {\n+                if let Some(item_node_id) = self.tcx.hir().as_local_node_id(item_did) {\n                     if self.live_symbols.contains(&item_node_id) {\n                         return true;\n                     }\n@@ -546,7 +547,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -647,7 +648,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor {\n         tcx,"}, {"sha": "5e75f119aef9c274f31944dfe2275164ff7c958a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -201,7 +201,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // static libraries.\n     //\n     // If the crate hasn't been included yet and it's not actually required\n-    // (e.g. it's an allocator) then we skip it here as well.\n+    // (e.g., it's an allocator) then we skip it here as well.\n     for &cnum in tcx.crates().iter() {\n         let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n@@ -306,7 +306,7 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n \n // Given a list of how to link upstream dependencies so far, ensure that an\n // injected dependency is activated. This will not do anything if one was\n-// transitively included already (e.g. via a dylib or explicitly so).\n+// transitively included already (e.g., via a dylib or explicitly so).\n //\n // If an injected dependency was not found then we're guaranteed the\n // metadata::creader module has injected that dependency (not listed as"}, {"sha": "60ddf60cde2cf766ae196ff33424b0bb1fbd4e73", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -87,7 +87,7 @@ pub fn find_entry_point(session: &Session,\n     configure_main(&mut ctxt, crate_name);\n }\n \n-// Beware, this is duplicated in libsyntax/entry.rs, make sure to keep\n+// Beware, this is duplicated in `libsyntax/entry.rs`, so make sure to keep\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n@@ -98,7 +98,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::MainAttr\n             } else if item.name == \"main\" {\n                 if at_root {\n-                    // This is a top-level function so can be 'main'\n+                    // This is a top-level function so can be 'main'.\n                     EntryPointType::MainNamed\n                 } else {\n                     EntryPointType::OtherMain"}, {"sha": "f1bc37d03e5a1fbaef36ec34b58c6ea998f202c2", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -622,7 +622,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 local.pat.each_binding(|_, hir_id, span, _| {\n-                    let node_id = self.mc.tcx.hir.hir_to_node_id(hir_id);\n+                    let node_id = self.mc.tcx.hir().hir_to_node_id(hir_id);\n                     self.delegate.decl_without_init(node_id, span);\n                 })\n             }\n@@ -813,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&arm.body);\n     }\n \n-    /// Walks a pat that occurs in isolation (i.e. top-level of fn\n+    /// Walks a pat that occurs in isolation (i.e., top-level of fn\n     /// arg or let binding.  *Not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n@@ -851,7 +851,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     /// The core driver for walking a pattern; `match_mode` must be\n-    /// established up front, e.g. via `determine_pat_move_mode` (see\n+    /// established up front, e.g., via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat(cmt_discr={:?}, pat={:?})\", cmt_discr, pat);\n@@ -935,8 +935,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let var_hir_id = self.tcx().hir.node_to_hir_id(freevar.var_id());\n-                let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n+                let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n+                let closure_def_id = self.tcx().hir().local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -973,7 +973,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_hir_id = self.tcx().hir.node_to_hir_id(upvar.var_id());\n+        let var_hir_id = self.tcx().hir().node_to_hir_id(upvar.var_id());\n         let var_ty = self.mc.node_ty(var_hir_id)?;\n         self.mc.cat_def(closure_hir_id, closure_span, var_ty, upvar.def)\n     }"}, {"sha": "fa34c2e63daa903997bfcdeb226147c53658c3e9", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -23,7 +23,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx,\n     };\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n@@ -134,8 +134,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n-        let body = self.tcx.hir.body(body_id);\n+        let owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n+        let body = self.tcx.hir().body(body_id);\n         let param_env = self.tcx.param_env(owner_def_id);\n         let tables = self.tcx.typeck_tables_of(owner_def_id);\n         ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);"}, {"sha": "cfcc7c8371976b3e182f5cf2fe1e6046f765a77f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,9 +13,9 @@\n // Language items are items that represent concepts intrinsic to the language\n // itself. Examples are:\n //\n-// * Traits that specify \"kinds\"; e.g. \"Sync\", \"Send\".\n+// * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n //\n-// * Traits that represent operators; e.g. \"Add\", \"Sub\", \"Index\".\n+// * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n //\n // * Functions called by the compiler itself.\n \n@@ -108,7 +108,7 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             match self.item_refs.get(&*value.as_str()).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir.local_def_id(item.id);\n+                    let def_id = self.tcx.hir().local_def_id(item.id);\n                     self.collect_item(item_index, def_id);\n                 },\n                 // Known lang item with attribute on incorrect target.\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         if let Some(original_def_id) = self.items.items[item_index] {\n             if original_def_id != item_def_id {\n                 let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir.span_if_local(item_def_id) {\n+                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n                     Some(span) => struct_span_err!(\n                         self.tcx.sess,\n                         span,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n                             self.tcx.crate_name(item_def_id.krate),\n                             name)),\n                 };\n-                if let Some(span) = self.tcx.hir.span_if_local(original_def_id) {\n+                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n                     span_note!(&mut err, span, \"first defined here.\");\n                 } else {\n                     err.note(&format!(\"first defined in crate `{}`.\",\n@@ -221,7 +221,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n             collector.collect_item(item_index, def_id);\n         }\n     }\n-    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n     let LanguageItemCollector { mut items, .. } = collector;\n     weak_lang_items::check_crate(tcx, &mut items);\n     items\n@@ -301,6 +301,7 @@ language_item_table! {\n \n     DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n     DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n+    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n \n     FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n     FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;"}, {"sha": "8934c7ebb2a6f2e0314f0435fbd857cb992951e7", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Detecting lib features (i.e. features that are not lang features).\n+// Detecting lib features (i.e., features that are not lang features).\n //\n-// These are declared using stability attributes (e.g. `#[stable (..)]`\n+// These are declared using stability attributes (e.g., `#[stable (..)]`\n // and `#[unstable (..)]`), but are not declared in one single location\n // (unlike lang features), which means we need to collect them instead.\n \n@@ -61,7 +61,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n         let stab_attrs = vec![\"stable\", \"unstable\", \"rustc_const_unstable\"];\n \n-        // Find a stability attribute (i.e. `#[stable (..)]`, `#[unstable (..)]`,\n+        // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| {\n             attr.check_name(stab_attr)\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx Attribute) {\n@@ -152,6 +152,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n \n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n-    intravisit::walk_crate(&mut collector, tcx.hir.krate());\n+    intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features\n }"}, {"sha": "d1d2fa298a6ca13de98475637deb117528efb00f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -176,7 +176,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n \n impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.hir.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -362,8 +362,8 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n-        let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(Node::Item(i)) = ir.tcx.hir.find(parent) {\n+        let parent = ir.tcx.hir().get_parent(id);\n+        if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }\n@@ -372,7 +372,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps<'_, '_>);\n \n-    let body = ir.tcx.hir.body(body_id);\n+    let body = ir.tcx.hir().body(body_id);\n \n     for arg in &body.arguments {\n         arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n@@ -476,7 +476,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                    let var_hid = ir.tcx.hir.node_to_hir_id(rv);\n+                    let var_hid = ir.tcx.hir().node_to_hir_id(rv);\n                     Some(CaptureInfo { ln: fv_ln, var_hid })\n                 } else {\n                     None\n@@ -554,7 +554,7 @@ struct RWUTable {\n     /// 65 bits of data into 32; in the uncommon cases, it expands the 65 bits\n     /// in 96.\n     ///\n-    /// More compact representations are possible -- e.g. use only 2 bits per\n+    /// More compact representations are possible -- e.g., use only 2 bits per\n     /// packed `RWU` and make the secondary table a HashMap that maps from\n     /// indices to `RWU`s -- but this one strikes a good balance between size\n     /// and speed.\n@@ -924,7 +924,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir.node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir().node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n \n@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().node_to_pretty_string(expr.id));\n \n         match expr.node {\n             // Interesting cases with control flow or which gen/kill\n@@ -1035,7 +1035,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Closure(.., blk_id, _, _) => {\n                 debug!(\"{} is an ExprKind::Closure\",\n-                       self.ir.tcx.hir.node_to_pretty_string(expr.id));\n+                       self.ir.tcx.hir().node_to_pretty_string(expr.id));\n \n                 // The next-node for a break is the successor of the entire\n                 // loop. The next-node for a continue is the top of this loop.\n@@ -1197,8 +1197,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                // FIXME(canndrew): This is_never should really be an is_uninhabited\n-                let succ = if self.tables.expr_ty(expr).is_never() {\n+                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n                     succ\n@@ -1208,8 +1208,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                // FIXME(canndrew): This is_never should really be an is_uninhabited\n-                let succ = if self.tables.expr_ty(expr).is_never() {\n+                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n                     succ\n@@ -1356,7 +1356,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let ln = self.live_node(hir_id, span);\n         if acc != 0 {\n             self.init_from_succ(ln, succ);\n-            let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+            let var_hid = self.ir.tcx.hir().node_to_hir_id(nid);\n             let var = self.variable(var_hid, span);\n             self.acc(ln, var, acc);\n         }\n@@ -1413,7 +1413,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir.node_to_pretty_string(body.id));\n+               expr.id, self.ir.tcx.hir().node_to_pretty_string(body.id));\n \n         let break_ln = succ;\n         let cont_ln = ln;\n@@ -1547,7 +1547,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n                     let ln = self.live_node(expr.hir_id, expr.span);\n-                    let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+                    let var_hid = self.ir.tcx.hir().node_to_hir_id(nid);\n                     let var = self.variable(var_hid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n                 }\n@@ -1575,7 +1575,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                if ident.name != keywords::SelfValue.name() {\n+                if ident.name != keywords::SelfLower.name() {\n                     if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);\n@@ -1657,11 +1657,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n-                    &format!(\"value passed to `{}` is never read\", name));\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                &format!(\"value passed to `{}` is never read\", name))\n+                .help(\"maybe it is overwritten before being read?\")\n+                .emit();\n             } else {\n-                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n-                    &format!(\"value assigned to `{}` is never read\", name));\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                &format!(\"value assigned to `{}` is never read\", name))\n+                .help(\"maybe it is overwritten before being read?\")\n+                .emit();\n             }\n         }\n     }"}, {"sha": "a04914e9774935f686596764a1046b72e0c7f249", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -127,7 +127,7 @@ pub enum PointerKind<'tcx> {\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n-// base without a pointer dereference\", e.g. a field\n+// base without a pointer dereference\", e.g., a field\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldIndex),\n@@ -153,8 +153,8 @@ impl Hash for FieldIndex {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorOffsetKind {\n-    Index,   // e.g. `array_expr[index_expr]`\n-    Pattern, // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n+    Index,   // e.g., `array_expr[index_expr]`\n+    Pattern, // e.g., `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -348,7 +348,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>,\n                   id: ast::NodeId) -> MutabilityCategory {\n-        let ret = match tcx.hir.get(id) {\n+        let ret = match tcx.hir().get(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n@@ -362,7 +362,7 @@ impl MutabilityCategory {\n                 }\n                 _ => span_bug!(p.span, \"expected identifier pattern\")\n             },\n-            _ => span_bug!(tcx.hir.span(id), \"expected identifier pattern\")\n+            _ => span_bug!(tcx.hir().span(id), \"expected identifier pattern\")\n         };\n         debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n                \"from_local\", id, ret);\n@@ -495,9 +495,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n-                let id = self.tcx.hir.hir_to_node_id(id);\n+                let id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n-                     id, self.tcx.hir.node_to_string(id));\n+                     id, self.tcx.hir().node_to_string(id));\n             }\n         }\n     }\n@@ -770,7 +770,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  fn_node_id: ast::NodeId)\n                  -> McResult<cmt_<'tcx>>\n     {\n-        let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n+        let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_node_id);\n \n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n@@ -815,8 +815,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n         };\n \n-        let closure_expr_def_id = self.tcx.hir.local_def_id(fn_node_id);\n-        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+        let closure_expr_def_id = self.tcx.hir().local_def_id(fn_node_id);\n+        let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_hir_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n@@ -961,7 +961,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"cat_rvalue_node: promotable = {:?}\", promotable);\n \n-        // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n+        // Always promote `[T; 0]` (even when e.g., borrowed mutably).\n         let promotable = match expr_ty.sty {\n             ty::Array(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,\n@@ -1504,7 +1504,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"non-place\".into()\n             }\n             Categorization::Local(vid) => {\n-                if tcx.hir.is_argument(vid) {\n+                if tcx.hir().is_argument(vid) {\n                     \"argument\"\n                 } else {\n                     \"local variable\""}, {"sha": "89814dde2623e6a2ca97b728f38638f74f8fef7c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -47,7 +47,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match item.node {\n         hir::ItemKind::Impl(..) |\n         hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n+            let generics = tcx.generics_of(tcx.hir().local_def_id(item.id));\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -58,12 +58,12 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n-    let generics = tcx.generics_of(tcx.hir.local_def_id(impl_item.id));\n+    let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true\n     }\n-    if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n-        match tcx.hir.find(impl_node_id) {\n+    if let Some(impl_node_id) = tcx.hir().as_local_node_id(impl_src) {\n+        match tcx.hir().find(impl_node_id) {\n             Some(Node::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = old_tables;\n     }\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             Some(def) => {\n                 if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir.as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                    self.tcx.hir().as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n                         self.worklist.push(node_id);\n@@ -151,12 +151,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let node_id = match self.tcx.hir.as_local_node_id(def_id) {\n+        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n             Some(node_id) => node_id,\n             None => { return false; }\n         };\n \n-        match self.tcx.hir.find(node_id) {\n+        match self.tcx.hir().find(node_id) {\n             Some(Node::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n@@ -182,13 +182,13 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n-                                               .hir\n+                                               .hir()\n                                                .get_parent_did(node_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n-                            match self.tcx.hir.expect_item(impl_node_id).node {\n+                            let impl_node_id = self.tcx.hir().as_local_node_id(impl_did).unwrap();\n+                            match self.tcx.hir().expect_item(impl_node_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir.find(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id(item.id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir.get_parent_did(search_item);\n+                        let did = self.tcx.hir().get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n-                     self.tcx.hir.node_to_string(search_item))\n+                     self.tcx.hir().node_to_string(search_item))\n             }\n         }\n     }\n@@ -351,7 +351,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         // Anything which has custom linkage gets thrown on the worklist no\n         // matter where it is in the crate, along with \"special std symbols\"\n         // which are currently akin to allocator symbols.\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let def_id = self.tcx.hir().local_def_id(item.id);\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n@@ -376,7 +376,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 self.worklist.reserve(provided_trait_methods.len());\n                 for default_method in provided_trait_methods {\n                     let node_id = self.tcx\n-                                      .hir\n+                                      .hir()\n                                       .as_local_node_id(default_method.def_id)\n                                       .unwrap();\n                     self.worklist.push(node_id);\n@@ -422,7 +422,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+            if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);\n             }\n         }\n@@ -433,7 +433,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n             access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n-        tcx.hir.krate().visit_all_item_likes(&mut collect_private_impl_items);\n+        tcx.hir().krate().visit_all_item_likes(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "9977faf5b2c9e161c35d22b0b31d73ccb959fb56", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -84,7 +84,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n ///  (D9.): DestructionScope for temporaries created during M8.\n /// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n /// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n-/// (D12.): DestructionScope for temporaries created during M1 (e.g. f()).\n+/// (D12.): DestructionScope for temporaries created during M1 (e.g., f()).\n /// ```\n ///\n /// Note that while the above picture shows the destruction scopes\n@@ -155,7 +155,7 @@ pub enum ScopeData {\n ///   everything after that first `let`. (If you want a scope that\n ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n ///   but instead another `Scope` that encompasses the whole block,\n-///   e.g. `Scope::Node`.\n+///   e.g., `Scope::Node`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -172,7 +172,7 @@ static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n-    /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n+    /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn item_local_id(&self) -> hir::ItemLocalId {\n         self.id\n@@ -181,7 +181,7 @@ impl Scope {\n     pub fn node_id(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> ast::NodeId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n-                tcx.hir.hir_to_node_id(hir::HirId {\n+                tcx.hir().hir_to_node_id(hir::HirId {\n                     owner: hir_id.owner,\n                     local_id: self.item_local_id()\n                 })\n@@ -198,9 +198,9 @@ impl Scope {\n         if node_id == ast::DUMMY_NODE_ID {\n             return DUMMY_SP;\n         }\n-        let span = tcx.hir.span(node_id);\n+        let span = tcx.hir().span(node_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir().get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -592,10 +592,7 @@ impl<'tcx> ScopeTree {\n                 return Some(scope.item_local_id());\n             }\n \n-            match self.opt_encl_scope(scope) {\n-                None => return None,\n-                Some(parent) => scope = parent,\n-            }\n+            scope = self.opt_encl_scope(scope)?;\n         }\n     }\n \n@@ -663,9 +660,9 @@ impl<'tcx> ScopeTree {\n                                       -> Scope {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let scope = tcx.hir.maybe_body_owned_by(param_owner_id).map(|body_id| {\n-            tcx.hir.body(body_id).value.hir_id.local_id\n+        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n+            tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n             // which in practice can only mean a trait or an impl, that\n@@ -674,7 +671,7 @@ impl<'tcx> ScopeTree {\n                        \"free_scope: {:?} not recognized by the \\\n                         region scope tree for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n+                       self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n                        self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n@@ -699,9 +696,9 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir.body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n+        let param_owner_id = tcx.hir().as_local_node_id(param_owner).unwrap();\n+        let body_id = tcx.hir().body_owned_by(param_owner_id);\n+        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n@@ -773,10 +770,10 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     //    }, other_argument());\n     //\n     // Each of the statements within the block is a terminating\n-    // scope, and thus a temporary (e.g. the result of calling\n+    // scope, and thus a temporary (e.g., the result of calling\n     // `bar()` in the initializer expression for `let inner = ...;`)\n     // will be cleaned up immediately after its corresponding\n-    // statement (i.e. `let inner = ...;`) executes.\n+    // statement (i.e., `let inner = ...;`) executes.\n     //\n     // On the other hand, temporaries associated with evaluating the\n     // tail expression for the block are assigned lifetimes so that\n@@ -848,7 +845,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = visitor.tcx.hir.node_to_hir_id(stmt.node.id()).local_id;\n+    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.node.id()).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -945,7 +942,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n-            let body = visitor.tcx.hir.body(body);\n+            let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n         }\n \n@@ -987,7 +984,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n \n     // As an exception to the normal rules governing temporary\n     // lifetimes, initializers in a let have a temporary lifetime\n-    // of the enclosing block. This means that e.g. a program\n+    // of the enclosing block. This means that e.g., a program\n     // like the following is legal:\n     //\n     //     let ref x = HashMap::new();\n@@ -1186,7 +1183,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         loop {\n             // Note: give all the expressions matching `ET` with the\n             // extended temporary lifetime, not just the innermost rvalue,\n-            // because in codegen if we must compile e.g. `*rvalue()`\n+            // because in codegen if we must compile e.g., `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n@@ -1247,7 +1244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         let body_id = body.id();\n-        let owner_id = self.tcx.hir.body_owner(body_id);\n+        let owner_id = self.tcx.hir().body_owner(body_id);\n \n         debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n                owner_id,\n@@ -1276,15 +1273,15 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n         // The body of the every fn is a root scope.\n         self.cx.parent = self.cx.var_parent;\n-        if let hir::BodyOwnerKind::Fn = self.tcx.hir.body_owner_kind(owner_id) {\n+        if let hir::BodyOwnerKind::Fn = self.tcx.hir().body_owner_kind(owner_id) {\n             self.visit_expr(&body.value);\n         } else {\n             // Only functions have an outer terminating (drop) scope, while\n             // temporaries in constant initializers may be 'static, but only\n             // according to rvalue lifetime semantics, using the same\n             // syntactical rules used for let initializers.\n             //\n-            // E.g. in `let x = &f();`, the temporary holding the result from\n+            // e.g., in `let x = &f();`, the temporary holding the result from\n             // the `f()` call lives for the entirety of the surrounding block.\n             //\n             // Similarly, `const X: ... = &f();` would have the result of `f()`\n@@ -1295,7 +1292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n             //\n             // However, `const Y: ... = g(&f());`, like `let y = g(&f());`,\n             // would *not* let the `f()` temporary escape into an outer scope\n-            // (i.e. `'static`), which means that after `g` returns, it drops,\n+            // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n             resolve_local(self, None, Some(&body.value));\n@@ -1336,8 +1333,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),\n@@ -1350,16 +1347,16 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             terminating_scopes: Default::default(),\n         };\n \n-        let body = tcx.hir.body(body_id);\n+        let body = tcx.hir().body(body_id);\n         visitor.scope_tree.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n-        match tcx.hir.get(id) {\n+        match tcx.hir().get(id) {\n             Node::ImplItem(_) |\n             Node::TraitItem(_) => {\n-                visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n+                visitor.scope_tree.root_parent = Some(tcx.hir().get_parent(id));\n             }\n             _ => {}\n         }"}, {"sha": "571f718f905f4b881d7b5729a43745725030f3a8", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -303,14 +303,14 @@ enum Scope<'a> {\n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n     /// if this is a fn body, otherwise the original definitions are used.\n     /// Unspecified lifetimes are inferred, unless an elision scope is nested,\n-    /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n+    /// e.g., `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n     Body {\n         id: hir::BodyId,\n         s: ScopeRef<'a>,\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n-    /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n+    /// on them (e.g., due to ambiguity). For more details, see `Elide`.\n     Elision {\n         elide: Elide,\n         s: ScopeRef<'a>,\n@@ -398,19 +398,19 @@ fn resolve_lifetimes<'tcx>(\n     let mut rl = ResolveLifetimes::default();\n \n     for (k, v) in named_region_map.defs {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n     }\n     for k in named_region_map.late_bound {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.late_bound\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n     for (k, v) in named_region_map.object_lifetime_defaults {\n-        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let hir_id = tcx.hir().node_to_hir_id(k);\n         let map = rl.object_lifetime_defaults\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n@@ -423,7 +423,7 @@ fn resolve_lifetimes<'tcx>(\n }\n \n fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n-    let krate = tcx.hir.krate();\n+    let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n         late_bound: Default::default(),\n@@ -460,7 +460,7 @@ fn sub_items_have_self_param(node: &hir::ItemKind) -> bool {\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     // We want to nest trait/impl items in their parent, but nothing else.\n@@ -469,7 +469,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n-        let body = self.tcx.hir.body(body);\n+        let body = self.tcx.hir().body(body);\n         extract_labels(self, body);\n         self.with(\n             Scope::Body {\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             type_count += 1;\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir, param))\n+                                Some(Region::late(&self.tcx.hir(), param))\n                             }\n                             _ => None,\n                         })\n@@ -622,13 +622,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     LifetimeName::Implicit => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n-                        // rules. So e.g. `Box<dyn Debug>` becomes\n+                        // rules. So e.g., `Box<dyn Debug>` becomes\n                         // `Box<dyn Debug + 'static>`.\n                         self.resolve_object_lifetime_default(lifetime)\n                     }\n                     LifetimeName::Underscore => {\n                         // If the user writes `'_`, we use the *ordinary* elision\n-                        // rules. So the `'_` in e.g. `Box<dyn Debug + '_>` will be\n+                        // rules. So the `'_` in e.g., `Box<dyn Debug + '_>` will be\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n@@ -655,7 +655,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n                     hir::ItemKind::Existential(hir::ExistTy {\n@@ -689,12 +689,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n-                                let parent_id = self.tcx.hir.get_parent_node(node_id);\n+                                let parent_id = self.tcx.hir().get_parent_node(node_id);\n                                 let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                                let krate = self.tcx.hir.forest.krate();\n+                                let krate = self.tcx.hir().forest.krate();\n                                 if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n@@ -724,7 +724,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in &generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                            let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(param_name) = name {\n                                 if param_name.name == keywords::UnderscoreLifetime.name() {\n                                     // Pick the elided lifetime \"definition\" if one exists\n@@ -790,7 +790,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir.get_parent(trait_item.id)),\n+                    Some(tcx.hir().get_parent(trait_item.id)),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -806,7 +806,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             type_count += 1;\n@@ -845,7 +845,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Method(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir.get_parent(impl_item.id)),\n+                    Some(tcx.hir().get_parent(impl_item.id)),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             next_early_index += 1;\n@@ -891,7 +891,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } => {\n                             next_early_index += 1;\n@@ -976,7 +976,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir, param))\n+                                Some(Region::late(&self.tcx.hir(), param))\n                             }\n                             _ => None,\n                         })\n@@ -1051,7 +1051,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(&self.tcx.hir, param))\n+                            Some(Region::late(&self.tcx.hir(), param))\n                         }\n                         _ => None,\n                     })\n@@ -1258,12 +1258,12 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n-                        let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir.span(node_id)),\n+                            original_lifetime(tcx.hir().span(node_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1279,7 +1279,7 @@ fn compute_object_lifetime_defaults(\n     tcx: TyCtxt<'_, '_, '_>,\n ) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = NodeMap::default();\n-    for item in tcx.hir.krate().items.values() {\n+    for item in tcx.hir().krate().items.values() {\n         match item.node {\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -1355,7 +1355,7 @@ fn object_lifetime_defaults_for_item(\n \n                 add_bounds(&mut set, &param.bounds);\n \n-                let param_def_id = tcx.hir.local_def_id(param.id);\n+                let param_def_id = tcx.hir().local_def_id(param.id);\n                 for predicate in &generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n@@ -1399,7 +1399,7 @@ fn object_lifetime_defaults_for_item(\n                                 .enumerate()\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir.local_def_id(id);\n+                                    let def_id = tcx.hir().local_def_id(id);\n                                     Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                                 })\n                         }\n@@ -1492,7 +1492,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let name = lifetime.name.ident();\n         let mut remove_decl = None;\n         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-            if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n+            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n                 remove_decl = self.lifetime_deletion_span(name, generics);\n             }\n         }\n@@ -1513,8 +1513,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir.get(lifetime.id) {\n-            if let Some(parent) = self.tcx.hir.find(self.tcx.hir.get_parent(hir_lifetime.id)) {\n+        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.id) {\n+            if let Some(parent) = self.tcx.hir().find(self.tcx.hir().get_parent(hir_lifetime.id)) {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n@@ -1590,9 +1590,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.id,\n                             hir_lifetime.span,\n@@ -1631,8 +1631,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"Not one use lifetime\");\n                 }\n                 None => {\n-                    let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                    if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n+                    let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n+                    if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.id,\n                             hir_lifetime.span,\n@@ -1651,7 +1651,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             &format!(\"lifetime parameter `{}` never used\", name),\n                         );\n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n+                            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n                                 let unused_lt_span = self.lifetime_deletion_span(name, generics);\n                                 if let Some(span) = unused_lt_span {\n                                     err.span_suggestion_with_applicability(\n@@ -1699,10 +1699,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n \n-        // Find the start of nested early scopes, e.g. in methods.\n+        // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir.expect_item(parent_id);\n+            let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }\n@@ -1722,9 +1722,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.map.late_bound.contains(&param.id) {\n-                        Some(Region::late(&self.tcx.hir, param))\n+                        Some(Region::late(&self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } => {\n@@ -1837,8 +1837,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let Region::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n-                let fn_id = self.tcx.hir.body_owner(body_id);\n-                match self.tcx.hir.get(fn_id) {\n+                let fn_id = self.tcx.hir().body_owner(body_id);\n+                match self.tcx.hir().get(fn_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n@@ -1851,7 +1851,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.tcx.hir.local_def_id(fn_id);\n+                        let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -1967,7 +1967,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2061,8 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.tcx.hir.get_parent_node(output.id);\n-        let body = match self.tcx.hir.get(parent) {\n+        let parent = self.tcx.hir().get_parent_node(output.id);\n+        let body = match self.tcx.hir().get(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n@@ -2074,8 +2074,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 ..\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n-                    .hir\n-                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .hir()\n+                    .expect_item(self.tcx.hir().get_parent(parent))\n                     .node\n                 {\n                     assoc_item_kind = trait_items\n@@ -2094,8 +2094,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 ..\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n-                    .hir\n-                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .hir()\n+                    .expect_item(self.tcx.hir().get_parent(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n@@ -2396,8 +2396,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(body) = parent {\n-                let arg = &self.tcx.hir.body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir.node_to_pretty_string(arg.pat.id))\n+                let arg = &self.tcx.hir().body(body).arguments[index];\n+                format!(\"`{}`\", self.tcx.hir().node_to_pretty_string(arg.pat.id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };\n@@ -2603,12 +2603,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     ref lifetimes, s, ..\n                 } => {\n                     if let Some(&def) = lifetimes.get(&param.name.modern()) {\n-                        let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n+                        let node_id = self.tcx.hir().as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir.span(node_id)),\n+                            original_lifetime(self.tcx.hir().span(node_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2675,7 +2675,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir.node_to_string(lifetime_ref.id),\n+            self.tcx.hir().node_to_string(lifetime_ref.id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );"}, {"sha": "61341cbc30ce45ca3ef5f17c4676bf67dd482d70", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 86, "deletions": 48, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -13,10 +13,11 @@\n \n pub use self::StabilityLevel::*;\n \n-use lint;\n+use lint::{self, Lint};\n+use hir::{self, Item, Generics, StructField, Variant, HirId};\n use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n-use ty::{self, TyCtxt};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use middle::privacy::AccessLevels;\n use session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n@@ -25,12 +26,9 @@ use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n+use ty::{self, TyCtxt};\n use util::nodemap::{FxHashSet, FxHashMap};\n \n-use hir;\n-use hir::{Item, Generics, StructField, Variant, HirId};\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n-\n use std::mem::replace;\n use std::cmp::Ordering;\n \n@@ -188,7 +186,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n@@ -198,7 +196,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n                         self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n@@ -219,7 +217,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n                     self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n@@ -230,7 +228,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 let depr_entry = DeprecationEntry::local(depr, hir_id);\n                 self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n@@ -239,7 +237,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n             } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n@@ -254,7 +252,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.tcx.hir)\n+        NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -333,7 +331,7 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n@@ -346,7 +344,7 @@ impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -369,7 +367,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let impl_def_id = self.tcx.hir.local_def_id(self.tcx.hir.get_parent(ii.id));\n+        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.id, ii.span);\n         }\n@@ -416,7 +414,7 @@ impl<'a, 'tcx> Index<'tcx> {\n         index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n \n         {\n-            let krate = tcx.hir.krate();\n+            let krate = tcx.hir().krate();\n             let mut annotator = Annotator {\n                 tcx,\n                 index: &mut index,\n@@ -470,14 +468,14 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut checker = Checker { tcx };\n-    tcx.hir.krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n+    tcx.hir().krate().visit_all_item_likes(&mut checker.as_deep_visitor());\n }\n \n /// Check whether an item marked with `deprecated(since=\"X\")` is currently\n-/// deprecated (i.e. whether X is not greater than the current rustc version).\n+/// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(since: &str) -> bool {\n     fn parse_version(ver: &str) -> Vec<u32> {\n-        // We ignore non-integer components of the version (e.g. \"nightly\").\n+        // We ignore non-integer components of the version (e.g., \"nightly\").\n         ver.split(|c| c == '.' || c == '-').flat_map(|s| s.parse()).collect()\n     }\n \n@@ -518,7 +516,7 @@ pub enum EvalResult {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    // (See issue #38412)\n+    // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n         match self.describe_def(def_id) {\n@@ -528,8 +526,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n                     // Trait methods do not declare visibility (even\n                     // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of pub traits are\n-                    // themselves considered pub.\n+                    // trait instead, so methods of `pub` traits are\n+                    // themselves considered `pub`.\n                     def_id = trait_def_id;\n                 }\n             }\n@@ -539,10 +537,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let visibility = self.visibility(def_id);\n \n         match visibility {\n-            // must check stability for pub items.\n+            // Must check stability for `pub` items.\n             ty::Visibility::Public => false,\n \n-            // these are not visible outside crate; therefore\n+            // These are not visible outside crate; therefore\n             // stability markers are irrelevant, if even present.\n             ty::Visibility::Restricted(..) |\n             ty::Visibility::Invisible => true,\n@@ -564,18 +562,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return EvalResult::Allow;\n         }\n \n-        let lint_deprecated = |def_id: DefId, id: NodeId, note: Option<Symbol>| {\n-            let path = self.item_path_str(def_id);\n-\n+        let lint_deprecated = |def_id: DefId,\n+                               id: NodeId,\n+                               note: Option<Symbol>,\n+                               message: &str,\n+                               lint: &'static Lint| {\n             let msg = if let Some(note) = note {\n-                format!(\"use of deprecated item '{}': {}\", path, note)\n+                format!(\"{}: {}\", message, note)\n             } else {\n-                format!(\"use of deprecated item '{}'\", path)\n+                format!(\"{}\", message)\n             };\n \n-            self.lint_node(lint::builtin::DEPRECATED, id, span, &msg);\n+            self.lint_node(lint, id, span, &msg);\n             if id == ast::DUMMY_NODE_ID {\n-                span_bug!(span, \"emitted a deprecated lint with dummy node id: {:?}\", def_id);\n+                span_bug!(span, \"emitted a {} lint with dummy node id: {:?}\", lint.name, def_id);\n             }\n         };\n \n@@ -586,17 +586,39 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // version, then we should display no warning message.\n                 let deprecated_in_future_version = if let Some(sym) = depr_entry.attr.since {\n                     let since = sym.as_str();\n-                    !deprecation_in_effect(&since)\n+                    if !deprecation_in_effect(&since) {\n+                        Some(since)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n-                    false\n+                    None\n                 };\n \n-                let parent_def_id = self.hir.local_def_id(self.hir.get_parent(id));\n-                let skip = deprecated_in_future_version ||\n-                           self.lookup_deprecation_entry(parent_def_id)\n+                let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n+                let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n-                if !skip {\n-                    lint_deprecated(def_id, id, depr_entry.attr.note);\n+\n+                if let Some(since) = deprecated_in_future_version {\n+                    let path = self.item_path_str(def_id);\n+                    let message = format!(\"use of item '{}' \\\n+                                           that will be deprecated in future version {}\",\n+                                          path,\n+                                          since);\n+\n+                    lint_deprecated(def_id,\n+                                    id,\n+                                    depr_entry.attr.note,\n+                                    &message,\n+                                    lint::builtin::DEPRECATED_IN_FUTURE);\n+                } else if !skip {\n+                    let path = self.item_path_str(def_id);\n+                    let message = format!(\"use of deprecated item '{}'\", path);\n+                    lint_deprecated(def_id,\n+                                    id,\n+                                    depr_entry.attr.note,\n+                                    &message,\n+                                    lint::builtin::DEPRECATED);\n                 }\n             };\n         }\n@@ -616,8 +638,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(&Stability{rustc_depr: Some(attr::RustcDeprecation { reason, since }), ..})\n                 = stability {\n             if let Some(id) = id {\n+                let path = self.item_path_str(def_id);\n                 if deprecation_in_effect(&since.as_str()) {\n-                    lint_deprecated(def_id, id, Some(reason));\n+                    let message = format!(\"use of deprecated item '{}'\", path);\n+                    lint_deprecated(def_id,\n+                                    id,\n+                                    Some(reason),\n+                                    &message,\n+                                    lint::builtin::DEPRECATED);\n+                } else {\n+                    let message = format!(\"use of item '{}' \\\n+                                           that will be deprecated in future version {}\",\n+                                          path,\n+                                          since);\n+                    lint_deprecated(def_id,\n+                                    id,\n+                                    Some(reason),\n+                                    &message,\n+                                    lint::builtin::DEPRECATED_IN_FUTURE);\n                 }\n             }\n         }\n@@ -628,7 +666,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return EvalResult::Allow;\n         }\n \n-        // Issue 38412: private items lack stability markers.\n+        // Issue #38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n             return EvalResult::Allow;\n         }\n@@ -644,7 +682,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // crates also pulled in from crates.io. We want to ideally be\n                 // able to compile everything without requiring upstream\n                 // modifications, so in the case that this looks like a\n-                // rustc_private crate (e.g. a compiler crate) and we also have\n+                // `rustc_private` crate (e.g., a compiler crate) and we also have\n                 // the `-Z force-unstable-if-unmarked` flag present (we're\n                 // compiling a compiler crate), then let this missing feature\n                 // annotation slide.\n@@ -717,7 +755,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -726,7 +764,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let cnum = match self.tcx.extern_mod_stmt_cnum(def_id) {\n                     Some(cnum) => cnum,\n                     None => return,\n@@ -741,7 +779,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n                 if let Def::Trait(trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n+                        let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n                             .find(|item| item.ident.name == impl_item.ident.name)\n                             .map(|item| item.def_id);\n@@ -756,7 +794,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n-                let def_id = self.tcx.hir.local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n \n@@ -780,7 +818,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        let id = self.tcx.hir.hir_to_node_id(id);\n+        let id = self.tcx.hir().hir_to_node_id(id);\n         if let Some(def_id) = path.def.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n@@ -794,14 +832,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Given the list of enabled features that were not language features (i.e. that\n+/// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n-        let krate = tcx.hir.krate();\n+        let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx,\n             access_levels,"}, {"sha": "824ccda3dbd1af4431f8a2d81b545fef53dffd29", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -49,7 +49,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     {\n         let mut cx = Context { tcx, items };\n-        tcx.hir.krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n+        tcx.hir().krate().visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n     verify(tcx, items);\n }"}, {"sha": "8b16aafd314d7d0d53a20c652d85c2214a54a875", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -183,50 +183,14 @@ pub struct EvalError<'tcx> {\n impl<'tcx> EvalError<'tcx> {\n     pub fn print_backtrace(&mut self) {\n         if let Some(ref mut backtrace) = self.backtrace {\n-            eprintln!(\"{}\", print_backtrace(&mut *backtrace));\n+            print_backtrace(&mut *backtrace);\n         }\n     }\n }\n \n-fn print_backtrace(backtrace: &mut Backtrace) -> String {\n-    use std::fmt::Write;\n-\n+fn print_backtrace(backtrace: &mut Backtrace) {\n     backtrace.resolve();\n-\n-    let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n-    write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n-    'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n-        if frame.symbols().is_empty() {\n-            write!(trace_text, \"  {}: no symbols\\n\", i).unwrap();\n-        }\n-        let mut first = true;\n-        for symbol in frame.symbols() {\n-            if first {\n-                write!(trace_text, \"  {}: \", i).unwrap();\n-                first = false;\n-            } else {\n-                let len = i.to_string().len();\n-                write!(trace_text, \"  {}  \", \" \".repeat(len)).unwrap();\n-            }\n-            if let Some(name) = symbol.name() {\n-                write!(trace_text, \"{}\\n\", name).unwrap();\n-            } else {\n-                write!(trace_text, \"<unknown>\\n\").unwrap();\n-            }\n-            write!(trace_text, \"           at \").unwrap();\n-            if let Some(file_path) = symbol.filename() {\n-                write!(trace_text, \"{}\", file_path.display()).unwrap();\n-            } else {\n-                write!(trace_text, \"<unknown_file>\").unwrap();\n-            }\n-            if let Some(line) = symbol.lineno() {\n-                write!(trace_text, \":{}\\n\", line).unwrap();\n-            } else {\n-                write!(trace_text, \"\\n\").unwrap();\n-            }\n-        }\n-    }\n-    trace_text\n+    eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n@@ -238,7 +202,7 @@ impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n \n                 if val == \"immediate\" {\n                     // Print it now\n-                    eprintln!(\"{}\", print_backtrace(&mut backtrace));\n+                    print_backtrace(&mut backtrace);\n                     None\n                 } else {\n                     Some(Box::new(backtrace))\n@@ -378,7 +342,7 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"tried to read from foreign (extern) static\",\n             InvalidPointerMath =>\n                 \"attempted to do invalid arithmetic on pointers that would leak base addresses, \\\n-                e.g. comparing pointers into different allocations\",\n+                e.g., comparing pointers into different allocations\",\n             ReadUndefBytes(_) =>\n                 \"attempted to read undefined bytes\",\n             DeadLocal =>"}, {"sha": "d54a1c9bb82f79a65e9e34681db57d6e3dbd3884", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 69, "deletions": 47, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -41,7 +41,6 @@ use ty::{self, TyCtxt, Instance};\n use ty::layout::{self, Size};\n use middle::region;\n use std::io;\n-use std::hash::Hash;\n use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n@@ -90,7 +89,7 @@ impl ::rustc_serialize::UseSpecializedEncodable for AllocId {}\n impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n \n #[derive(RustcDecodable, RustcEncodable)]\n-enum AllocKind {\n+enum AllocDiscriminant {\n     Alloc,\n     Fn,\n     Static,\n@@ -104,23 +103,23 @@ pub fn specialized_encode_alloc_id<\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc_type: AllocType<'tcx, &'tcx Allocation> =\n+    let alloc_kind: AllocKind<'tcx> =\n         tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n-    match alloc_type {\n-        AllocType::Memory(alloc) => {\n+    match alloc_kind {\n+        AllocKind::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n-            AllocKind::Alloc.encode(encoder)?;\n+            AllocDiscriminant::Alloc.encode(encoder)?;\n             alloc.encode(encoder)?;\n         }\n-        AllocType::Function(fn_instance) => {\n+        AllocKind::Function(fn_instance) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n-            AllocKind::Fn.encode(encoder)?;\n+            AllocDiscriminant::Fn.encode(encoder)?;\n             fn_instance.encode(encoder)?;\n         }\n-        AllocType::Static(did) => {\n+        AllocKind::Static(did) => {\n             // referring to statics doesn't need to know about their allocations,\n             // just about its DefId\n-            AllocKind::Static.encode(encoder)?;\n+            AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n     }\n@@ -189,10 +188,10 @@ impl<'s> AllocDecodingSession<'s> {\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocKind now so that we know if we have to reserve an\n+        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n         // AllocId.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n-            let alloc_kind = AllocKind::decode(decoder)?;\n+            let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n@@ -208,7 +207,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 ref mut entry @ State::Empty => {\n                     // We are allowed to decode\n                     match alloc_kind {\n-                        AllocKind::Alloc => {\n+                        AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // AllocId so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n@@ -217,7 +216,7 @@ impl<'s> AllocDecodingSession<'s> {\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n-                        AllocKind::Fn | AllocKind::Static => {\n+                        AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n                             // Fns and statics cannot be cyclic and their AllocId\n                             // is determined later by interning\n                             *entry = State::InProgressNonAlloc(\n@@ -251,23 +250,23 @@ impl<'s> AllocDecodingSession<'s> {\n         // Now decode the actual data\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n-                AllocKind::Alloc => {\n+                AllocDiscriminant::Alloc => {\n                     let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n                     // We already have a reserved AllocId.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                    decoder.tcx().alloc_map.lock().set_id_same_memory(alloc_id, allocation);\n+                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, allocation);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Fn => {\n+                AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc id\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n-                AllocKind::Static => {\n+                AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc id at\");\n                     let did = DefId::decode(decoder)?;\n@@ -292,39 +291,42 @@ impl fmt::Display for AllocId {\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n-pub enum AllocType<'tcx, M> {\n+pub enum AllocKind<'tcx> {\n     /// The alloc id is used as a function pointer\n     Function(Instance<'tcx>),\n     /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n     /// The alloc id points to memory\n-    Memory(M)\n+    Memory(&'tcx Allocation),\n }\n \n-pub struct AllocMap<'tcx, M> {\n+pub struct AllocMap<'tcx> {\n     /// Lets you know what an AllocId refers to\n-    id_to_type: FxHashMap<AllocId, AllocType<'tcx, M>>,\n+    id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n-    /// Used to ensure that functions and statics only get one associated AllocId\n-    type_interner: FxHashMap<AllocType<'tcx, M>, AllocId>,\n+    /// Used to ensure that statics only get one associated AllocId\n+    type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n     /// The AllocId to assign to the next requested id.\n     /// Always incremented, never gets smaller.\n     next_id: AllocId,\n }\n \n-impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n+impl<'tcx> AllocMap<'tcx> {\n     pub fn new() -> Self {\n         AllocMap {\n-            id_to_type: Default::default(),\n+            id_to_kind: Default::default(),\n             type_interner: Default::default(),\n             next_id: AllocId(0),\n         }\n     }\n \n-    /// obtains a new allocation ID that can be referenced but does not\n+    /// Obtains a new allocation ID that can be referenced but does not\n     /// yet have an allocation backing it.\n+    ///\n+    /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n+    /// an `AllocId` from a query.\n     pub fn reserve(\n         &mut self,\n     ) -> AllocId {\n@@ -337,53 +339,73 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n         next\n     }\n \n-    fn intern(&mut self, alloc_type: AllocType<'tcx, M>) -> AllocId {\n-        if let Some(&alloc_id) = self.type_interner.get(&alloc_type) {\n+    fn intern(&mut self, alloc_kind: AllocKind<'tcx>) -> AllocId {\n+        if let Some(&alloc_id) = self.type_interner.get(&alloc_kind) {\n             return alloc_id;\n         }\n         let id = self.reserve();\n-        debug!(\"creating alloc_type {:?} with id {}\", alloc_type, id);\n-        self.id_to_type.insert(id, alloc_type.clone());\n-        self.type_interner.insert(alloc_type, id);\n+        debug!(\"creating alloc_kind {:?} with id {}\", alloc_kind, id);\n+        self.id_to_kind.insert(id, alloc_kind.clone());\n+        self.type_interner.insert(alloc_kind, id);\n         id\n     }\n \n-    // FIXME: Check if functions have identity. If not, we should not intern these,\n-    // but instead create a new id per use.\n-    // Alternatively we could just make comparing function pointers an error.\n+    /// Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n+    /// by the linker and functions can be duplicated across crates.\n+    /// We thus generate a new `AllocId` for every mention of a function. This means that\n+    /// `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> AllocId {\n-        self.intern(AllocType::Function(instance))\n+        let id = self.reserve();\n+        self.id_to_kind.insert(id, AllocKind::Function(instance));\n+        id\n     }\n \n-    pub fn get(&self, id: AllocId) -> Option<AllocType<'tcx, M>> {\n-        self.id_to_type.get(&id).cloned()\n+    /// Returns `None` in case the `AllocId` is dangling. An `EvalContext` can still have a\n+    /// local `Allocation` for that `AllocId`, but having such an `AllocId` in a constant is\n+    /// illegal and will likely ICE.\n+    /// This function exists to allow const eval to detect the difference between evaluation-\n+    /// local dangling pointers and allocations in constants/statics.\n+    pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n+        self.id_to_kind.get(&id).cloned()\n     }\n \n-    pub fn unwrap_memory(&self, id: AllocId) -> M {\n+    /// Panics if the `AllocId` does not refer to an `Allocation`\n+    pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n-            Some(AllocType::Memory(mem)) => mem,\n+            Some(AllocKind::Memory(mem)) => mem,\n             _ => bug!(\"expected allocation id {} to point to memory\", id),\n         }\n     }\n \n+    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n-        self.intern(AllocType::Static(static_id))\n+        self.intern(AllocKind::Static(static_id))\n     }\n \n-    pub fn allocate(&mut self, mem: M) -> AllocId {\n+    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// `Allocation` with a different `AllocId`.\n+    // FIXME: is this really necessary? Can we ensure `FOO` and `BAR` being different after codegen\n+    // in `static FOO: u32 = 42; static BAR: u32 = 42;` even if they reuse the same allocation\n+    // inside rustc?\n+    pub fn allocate(&mut self, mem: &'tcx Allocation) -> AllocId {\n         let id = self.reserve();\n-        self.set_id_memory(id, mem);\n+        self.set_alloc_id_memory(id, mem);\n         id\n     }\n \n-    pub fn set_id_memory(&mut self, id: AllocId, mem: M) {\n-        if let Some(old) = self.id_to_type.insert(id, AllocType::Memory(mem)) {\n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// call this function twice, even with the same `Allocation` will ICE the compiler.\n+    pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n+        if let Some(old) = self.id_to_kind.insert(id, AllocKind::Memory(mem)) {\n             bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n-    pub fn set_id_same_memory(&mut self, id: AllocId, mem: M) {\n-       self.id_to_type.insert_same(id, AllocType::Memory(mem));\n+    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// twice for the same `(AllocId, Allocation)` pair.\n+    fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n+        self.id_to_kind.insert_same(id, AllocKind::Memory(mem));\n     }\n }\n "}, {"sha": "b8d4c5a37511a4947ee86eb18084d05f701f6c8c", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,7 +18,7 @@ use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_ex\n /// Represents the result of a raw const operation, pre-validation.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n pub struct RawConst<'tcx> {\n-    // the value lives here, at offset 0, and that allocation definitely is a `AllocType::Memory`\n+    // the value lives here, at offset 0, and that allocation definitely is a `AllocKind::Memory`\n     // (so you can use `AllocMap::unwrap_memory`).\n     pub alloc_id: AllocId,\n     pub ty: Ty<'tcx>,\n@@ -138,6 +138,14 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline]\n+    pub fn with_tag(self, new_tag: Tag) -> Self {\n+        match self {\n+            Scalar::Ptr(ptr) => Scalar::Ptr(Pointer { tag: new_tag, ..ptr }),\n+            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+        }\n+    }\n+\n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n         Scalar::Bits {"}, {"sha": "dc14450e8d22d88f4e979745412558529a9a18d7", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n-use rustc_serialize as serialize;\n+use rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -149,6 +149,14 @@ pub struct Mir<'tcx> {\n     /// This is used for the \"rust-call\" ABI.\n     pub spread_arg: Option<Local>,\n \n+    /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n+    /// `||` expression into `&` or `|` respectively. This is problematic because if we ever stop\n+    /// this conversion from happening and use short circuiting, we will cause the following code\n+    /// to change the value of `x`: `let mut x = 42; false && { x = 55; true };`\n+    ///\n+    /// List of places where control flow was destroyed. Used for error reporting.\n+    pub control_flow_destroyed: Vec<(Span, String)>,\n+\n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n \n@@ -167,6 +175,7 @@ impl<'tcx> Mir<'tcx> {\n         arg_count: usize,\n         upvar_decls: Vec<UpvarDecl>,\n         span: Span,\n+        control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n         // We need `arg_count` locals, and one for the return place\n         assert!(\n@@ -191,6 +200,7 @@ impl<'tcx> Mir<'tcx> {\n             spread_arg: None,\n             span,\n             cache: cache::Cache::new(),\n+            control_flow_destroyed,\n         }\n     }\n \n@@ -339,7 +349,7 @@ impl<'tcx> Mir<'tcx> {\n     #[inline]\n     pub fn args_iter(&self) -> impl Iterator<Item = Local> {\n         let arg_count = self.arg_count;\n-        (1..arg_count + 1).map(Local::new)\n+        (1..=arg_count).map(Local::new)\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n@@ -421,6 +431,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     arg_count,\n     upvar_decls,\n     spread_arg,\n+    control_flow_destroyed,\n     span,\n     cache\n });\n@@ -556,7 +567,7 @@ pub enum BorrowKind {\n     /// Data is mutable and not aliasable.\n     Mut {\n         /// True if this borrow arose from method-call auto-ref\n-        /// (i.e. `adjustment::Adjust::Borrow`)\n+        /// (i.e., `adjustment::Adjust::Borrow`)\n         allow_two_phase_borrow: bool,\n     },\n }\n@@ -692,7 +703,7 @@ mod binding_form_impl {\n /// expression; that is, a block like `{ STMT_1; STMT_2; EXPR }`.\n ///\n /// It is used to improve diagnostics when such temporaries are\n-/// involved in borrow_check errors, e.g. explanations of where the\n+/// involved in borrow_check errors, e.g., explanations of where the\n /// temporaries come from, when their destructors are run, and/or how\n /// one might revise the code to satisfy the borrow checker's rules.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n@@ -701,7 +712,7 @@ pub struct BlockTailInfo {\n     /// expression is ignored by the block's expression context.\n     ///\n     /// Examples include `{ ...; tail };` and `let _ = { ...; tail };`\n-    /// but not e.g. `let _x = { ...; tail };`\n+    /// but not e.g., `let _x = { ...; tail };`\n     pub tail_result_is_ignored: bool,\n }\n \n@@ -756,7 +767,7 @@ pub struct LocalDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n \n     /// If the user manually ascribed a type to this variable,\n-    /// e.g. via `let x: T`, then we carry that type here. The MIR\n+    /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n     pub user_ty: UserTypeProjections<'tcx>,\n@@ -767,7 +778,7 @@ pub struct LocalDecl<'tcx> {\n     /// to generate better debuginfo.\n     pub name: Option<Name>,\n \n-    /// The *syntactic* (i.e. not visibility) source scope the local is defined\n+    /// The *syntactic* (i.e., not visibility) source scope the local is defined\n     /// in. If the local was defined in a let-statement, this\n     /// is *within* the let-statement, rather than outside\n     /// of it.\n@@ -1745,9 +1756,12 @@ pub enum StatementKind<'tcx> {\n     Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n \n     /// This represents all the reading that a pattern match may do\n-    /// (e.g. inspecting constants and discriminant values), and the\n+    /// (e.g., inspecting constants and discriminant values), and the\n     /// kind of pattern it comes from. This is in order to adapt potential\n     /// error messages to these specific patterns.\n+    ///\n+    /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n+    /// never accessed still get some sanity checks for e.g. `let x: ! = ..;`\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1774,19 +1788,7 @@ pub enum StatementKind<'tcx> {\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n     /// for more details.\n-    Retag {\n-        /// `fn_entry` indicates whether this is the initial retag that happens in the\n-        /// function prolog.\n-        fn_entry: bool,\n-        place: Place<'tcx>,\n-    },\n-\n-    /// Escape the given reference to a raw pointer, so that it can be accessed\n-    /// without precise provenance tracking. These statements are currently only interpreted\n-    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n-    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n-    /// for more details.\n-    EscapeToRaw(Operand<'tcx>),\n+    Retag(RetagKind, Place<'tcx>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n@@ -1806,6 +1808,19 @@ pub enum StatementKind<'tcx> {\n     Nop,\n }\n \n+/// `RetagKind` describes what kind of retag is to be performed.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n+pub enum RetagKind {\n+    /// The initial retag when entering a function\n+    FnEntry,\n+    /// Retag preparing for a two-phase borrow\n+    TwoPhase,\n+    /// Retagging raw pointers\n+    Raw,\n+    /// A \"normal\" retag\n+    Default,\n+}\n+\n /// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum FakeReadCause {\n@@ -1841,9 +1856,16 @@ impl<'tcx> Debug for Statement<'tcx> {\n         match self.kind {\n             Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n-            Retag { fn_entry, ref place } =>\n-                write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry] \" } else { \"\" }, place),\n-            EscapeToRaw(ref place) => write!(fmt, \"EscapeToRaw({:?})\", place),\n+            Retag(ref kind, ref place) =>\n+                write!(fmt, \"Retag({}{:?})\",\n+                    match kind {\n+                        RetagKind::FnEntry => \"[fn entry] \",\n+                        RetagKind::TwoPhase => \"[2phase] \",\n+                        RetagKind::Raw => \"[raw] \",\n+                        RetagKind::Default => \"\",\n+                    },\n+                    place,\n+                ),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n             SetDiscriminant {\n@@ -2172,7 +2194,7 @@ pub enum Rvalue<'tcx> {\n \n     /// Read the discriminant of an ADT.\n     ///\n-    /// Undefined (i.e. no effort is made to make it defined, but there\u2019s no reason why it cannot\n+    /// Undefined (i.e., no effort is made to make it defined, but there\u2019s no reason why it cannot\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Place<'tcx>),\n \n@@ -2214,7 +2236,7 @@ pub enum AggregateKind<'tcx> {\n     /// The second field is the variant index. It's equal to 0 for struct\n     /// and union expressions. The fourth field is\n     /// active field number and is present only for union expressions\n-    /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n+    /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n     Adt(\n         &'tcx AdtDef,\n@@ -2368,17 +2390,17 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 format!(\"[closure@{:?}]\", node_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir.span(node_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span(node_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                             });\n@@ -2390,13 +2412,13 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir.span(node_id));\n+                        if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(node_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             tcx.with_freevars(node_id, |freevars| {\n                                 for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir.name(freevar.var_id());\n+                                    let var_name = tcx.hir().name(freevar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n                                 struct_fmt.field(\"$state\", &places[freevars.len()]);\n@@ -2629,7 +2651,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const<'_>) -> fmt::Resu\n                 if let Ref(_, &ty::TyS { sty: Str, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {\n                         let alloc = tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(interpret::AllocType::Memory(alloc)) = alloc {\n+                        if let Some(interpret::AllocKind::Memory(alloc)) = alloc {\n                             assert_eq!(len as usize as u128, len);\n                             let slice =\n                                 &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n@@ -2770,8 +2792,11 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// unsafety is not allowed at all in min const fn\n-    MinConstFn,\n+    /// Right now function calls to `const unsafe fn` are only permitted behind a feature gate\n+    /// Also, even `const unsafe fn` need an `unsafe` block to do the allowed operations.\n+    GatedConstFnCall,\n+    /// Permitted in const fn and regular fns\n+    GeneralAndConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n }\n@@ -2894,6 +2919,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum ConstraintCategory {\n     Return,\n+    Yield,\n     UseAsConst,\n     UseAsStatic,\n     TypeAnnotation,\n@@ -2953,6 +2979,7 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceInfo,\n     UpvarDecl,\n     FakeReadCause,\n+    RetagKind,\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n@@ -2972,6 +2999,7 @@ BraceStructTypeFoldableImpl! {\n         arg_count,\n         upvar_decls,\n         spread_arg,\n+        control_flow_destroyed,\n         span,\n         cache,\n     }\n@@ -3019,8 +3047,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n-        (StatementKind::Retag) { fn_entry, place },\n-        (StatementKind::EscapeToRaw)(place),\n+        (StatementKind::Retag)(kind, place),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),\n     }"}, {"sha": "c96cbd40efaf817f9013d3d776a4e36d2abd9410", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n     ///\n     /// The '.' before `<special-suffix>` makes sure that names with a special\n     /// suffix can never collide with a name built out of regular Rust\n-    /// identifiers (e.g. module paths).\n+    /// identifiers (e.g., module paths).\n     pub fn build_cgu_name<I, C, S>(&mut self,\n                                    cnum: CrateNum,\n                                    components: I,"}, {"sha": "4424ba0a4f7a109d2715245241266450f0f631f4", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n /// ```\n ///\n /// A reverse postorder traversal of this graph is either `A B C D` or `A C B D`\n-/// Note that for a graph containing no loops (i.e. A DAG), this is equivalent to\n+/// Note that for a graph containing no loops (i.e., A DAG), this is equivalent to\n /// a topological sort.\n ///\n /// Construction of a `ReversePostorder` traversal requires doing a full"}, {"sha": "278a4dc1d873aceafd5a672c4721a57a946f4d1c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n // in that circumstance.\n //\n // For the most part, we do not destructure things external to the\n-// MIR, e.g. types, spans, etc, but simply visit them and stop. This\n+// MIR, e.g., types, spans, etc, but simply visit them and stop. This\n // avoids duplication with other visitors like `TypeFoldable`.\n //\n // ## Updating\n@@ -153,10 +153,10 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_retag(&mut self,\n-                           fn_entry: & $($mutability)* bool,\n+                           kind: & $($mutability)* RetagKind,\n                            place: & $($mutability)* Place<'tcx>,\n                            location: Location) {\n-                self.super_retag(fn_entry, place, location);\n+                self.super_retag(kind, place, location);\n             }\n \n             fn visit_place(&mut self,\n@@ -384,9 +384,6 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n-                    StatementKind::EscapeToRaw(ref $($mutability)* op) => {\n-                        self.visit_operand(op, location);\n-                    }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n                         self.visit_local(\n                             local,\n@@ -416,9 +413,9 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::Retag { ref $($mutability)* fn_entry,\n-                                           ref $($mutability)* place } => {\n-                        self.visit_retag(fn_entry, place, location);\n+                    StatementKind::Retag ( ref $($mutability)* kind,\n+                                           ref $($mutability)* place ) => {\n+                        self.visit_retag(kind, place, location);\n                     }\n                     StatementKind::AscribeUserType(\n                         ref $($mutability)* place,\n@@ -723,7 +720,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_retag(&mut self,\n-                           _fn_entry: & $($mutability)* bool,\n+                           _kind: & $($mutability)* RetagKind,\n                            place: & $($mutability)* Place<'tcx>,\n                            location: Location) {\n                 self.visit_place(\n@@ -994,7 +991,7 @@ pub enum NonMutatingUseContext<'tcx> {\n     ShallowBorrow(Region<'tcx>),\n     /// Unique borrow.\n     UniqueBorrow(Region<'tcx>),\n-    /// Used as base for another place, e.g. `x` in `x.y`. Will not mutate the place.\n+    /// Used as base for another place, e.g., `x` in `x.y`. Will not mutate the place.\n     /// For example, the projection `x.y` is not marked as a mutation in these cases:\n     ///\n     ///     z = x.y;\n@@ -1017,7 +1014,7 @@ pub enum MutatingUseContext<'tcx> {\n     Drop,\n     /// Mutable borrow.\n     Borrow(Region<'tcx>),\n-    /// Used as base for another place, e.g. `x` in `x.y`. Could potentially mutate the place.\n+    /// Used as base for another place, e.g., `x` in `x.y`. Could potentially mutate the place.\n     /// For example, the projection `x.y` is marked as a mutation in these cases:\n     ///\n     ///     x.y = ...;"}, {"sha": "b58d80e24857d1e4c2decb62b8b4376f6fb99776", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -14,7 +14,7 @@\n use std::str::FromStr;\n \n use session::{early_error, early_warn, Session};\n-use session::search_paths::SearchPaths;\n+use session::search_paths::SearchPath;\n \n use rustc_target::spec::{LinkerFlavor, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n@@ -374,7 +374,7 @@ top_level_options!(\n         lint_cap: Option<lint::Level> [TRACKED],\n         describe_lints: bool [UNTRACKED],\n         output_types: OutputTypes [TRACKED],\n-        search_paths: SearchPaths [UNTRACKED],\n+        search_paths: Vec<SearchPath> [UNTRACKED],\n         libs: Vec<(String, Option<String>, Option<cstore::NativeLibraryKind>)> [TRACKED],\n         maybe_sysroot: Option<PathBuf> [TRACKED],\n \n@@ -593,7 +593,7 @@ impl Default for Options {\n             lint_cap: None,\n             describe_lints: false,\n             output_types: OutputTypes(BTreeMap::new()),\n-            search_paths: SearchPaths::new(),\n+            search_paths: vec![],\n             maybe_sysroot: None,\n             target_triple: TargetTriple::from_triple(host_triple()),\n             test: false,\n@@ -780,43 +780,42 @@ macro_rules! options {\n     }\n \n     pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n-    pub const $stat: &'static [(&'static str, $setter_name,\n-                                Option<&'static str>, &'static str)] =\n+    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n         &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n \n     #[allow(non_upper_case_globals, dead_code)]\n     mod $mod_desc {\n-        pub const parse_bool: Option<&'static str> = None;\n-        pub const parse_opt_bool: Option<&'static str> =\n+        pub const parse_bool: Option<&str> = None;\n+        pub const parse_opt_bool: Option<&str> =\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n-        pub const parse_string: Option<&'static str> = Some(\"a string\");\n-        pub const parse_string_push: Option<&'static str> = Some(\"a string\");\n-        pub const parse_pathbuf_push: Option<&'static str> = Some(\"a path\");\n-        pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n-        pub const parse_opt_pathbuf: Option<&'static str> = Some(\"a path\");\n-        pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n-        pub const parse_uint: Option<&'static str> = Some(\"a number\");\n-        pub const parse_passes: Option<&'static str> =\n+        pub const parse_string: Option<&str> = Some(\"a string\");\n+        pub const parse_string_push: Option<&str> = Some(\"a string\");\n+        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n+        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n+        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n+        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_uint: Option<&str> = Some(\"a number\");\n+        pub const parse_passes: Option<&str> =\n             Some(\"a space-separated list of passes, or `all`\");\n-        pub const parse_opt_uint: Option<&'static str> =\n+        pub const parse_opt_uint: Option<&str> =\n             Some(\"a number\");\n-        pub const parse_panic_strategy: Option<&'static str> =\n+        pub const parse_panic_strategy: Option<&str> =\n             Some(\"either `unwind` or `abort`\");\n-        pub const parse_relro_level: Option<&'static str> =\n+        pub const parse_relro_level: Option<&str> =\n             Some(\"one of: `full`, `partial`, or `off`\");\n-        pub const parse_sanitizer: Option<&'static str> =\n+        pub const parse_sanitizer: Option<&str> =\n             Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n-        pub const parse_linker_flavor: Option<&'static str> =\n+        pub const parse_linker_flavor: Option<&str> =\n             Some(::rustc_target::spec::LinkerFlavor::one_of());\n-        pub const parse_optimization_fuel: Option<&'static str> =\n+        pub const parse_optimization_fuel: Option<&str> =\n             Some(\"crate=integer\");\n-        pub const parse_unpretty: Option<&'static str> =\n+        pub const parse_unpretty: Option<&str> =\n             Some(\"`string` or `string=string`\");\n-        pub const parse_lto: Option<&'static str> =\n+        pub const parse_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n                   `fat`, or omitted\");\n-        pub const parse_cross_lang_lto: Option<&'static str> =\n+        pub const parse_cross_lang_lto: Option<&str> =\n             Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n                   or the path to the linker plugin\");\n     }\n@@ -1136,6 +1135,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"enable incremental compilation\"),\n     default_linker_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n         \"allow the linker to link its default libraries\"),\n+    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n+                                           \"Linker flavor\"),\n }\n \n options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n@@ -1273,15 +1274,21 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     arg_align_attributes: bool = (false, parse_bool, [TRACKED],\n         \"emit align metadata for reference arguments\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"dump MIR state at various points in transforms\"),\n+        \"dump MIR state to file.\n+        `val` is used to select which passes and functions to dump. For example:\n+        `all` matches all passes and functions,\n+        `foo` matches all passes for functions whose name contains 'foo',\n+        `foo & ConstProp` only the 'ConstProp' pass for function names containing 'foo',\n+        `foo | bar` all passes for function names containing 'foo' or 'bar'.\"),\n+\n     dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n         \"the directory the MIR is dumped into\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n         \"in addition to `.mir` files, create graphviz `.dot` files\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n         \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n     mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n-        \"emit Retagging MIR statements, interpreted e.g. by miri; implies -Zmir-opt-level=0\"),\n+        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n@@ -1292,8 +1299,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n                                     \"Use a sanitizer\"),\n-    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n-                                           \"Linker flavor\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n@@ -1533,7 +1538,7 @@ impl RustcOptGroup {\n // adds extra rustc-specific metadata to each option; such metadata\n // is exposed by .  The public\n // functions below ending with `_u` are the functions that return\n-// *unstable* options, i.e. options that are only enabled when the\n+// *unstable* options, i.e., options that are only enabled when the\n // user also passes the `-Z unstable-options` debugging flag.\n mod opt {\n     // The `fn opt_u` etc below are written so that we can use them\n@@ -1756,8 +1761,8 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n         .into_iter()\n         .map(|s| {\n             let sess = parse::ParseSess::new(FilePathMapping::empty());\n-            let mut parser =\n-                parse::new_parser_from_source_str(&sess, FileName::CfgSpec, s.to_string());\n+            let filename = FileName::cfg_spec_source_code(&s);\n+            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n \n             macro_rules! error {($reason: expr) => {\n                 early_error(ErrorOutputType::default(),\n@@ -2110,9 +2115,9 @@ pub fn build_session_options_and_crate_config(\n         }\n     };\n \n-    let mut search_paths = SearchPaths::new();\n+    let mut search_paths = vec![];\n     for s in &matches.opt_strs(\"L\") {\n-        search_paths.add_path(&s[..], error_format);\n+        search_paths.push(SearchPath::from_cli_opt(&s[..], error_format));\n     }\n \n     let libs = matches\n@@ -2381,7 +2386,7 @@ impl fmt::Display for CrateType {\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n /// via the DepTrackingHash trait defined below, since the standard Hash\n-/// implementation might not be suitable (e.g. arguments are stored in a Vec,\n+/// implementation might not be suitable (e.g., arguments are stored in a Vec,\n /// the hash of which is order dependent, but we might not want the order of\n /// arguments to make a difference for the hash).\n ///\n@@ -2530,6 +2535,7 @@ mod tests {\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n     use session::config::{LtoCli, CrossLangLto};\n     use session::build_session;\n+    use session::search_paths::SearchPath;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n@@ -2785,48 +2791,48 @@ mod tests {\n \n         // Reference\n         v1.search_paths\n-            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n         v1.search_paths\n-            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n         v1.search_paths\n-            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n         v1.search_paths\n-            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n         v1.search_paths\n-            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n \n         v2.search_paths\n-            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n         v2.search_paths\n-            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n         v2.search_paths\n-            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n         v2.search_paths\n-            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n         v2.search_paths\n-            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n \n         v3.search_paths\n-            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n         v3.search_paths\n-            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n         v3.search_paths\n-            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n         v3.search_paths\n-            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n         v3.search_paths\n-            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n \n         v4.search_paths\n-            .add_path(\"all=mno\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n         v4.search_paths\n-            .add_path(\"native=abc\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n         v4.search_paths\n-            .add_path(\"crate=def\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n         v4.search_paths\n-            .add_path(\"dependency=ghi\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n         v4.search_paths\n-            .add_path(\"framework=jkl\", super::ErrorOutputType::Json(false));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());"}, {"sha": "c204556d517a818717458504633c9fc68f6e2c75", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 34, "deletions": 53, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -12,13 +12,12 @@\n \n pub use self::FileMatch::*;\n \n-use rustc_data_structures::fx::FxHashSet;\n use std::borrow::Cow;\n use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n \n-use session::search_paths::{SearchPaths, PathKind};\n+use session::search_paths::{SearchPath, PathKind};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n \n #[derive(Copy, Clone)]\n@@ -30,31 +29,19 @@ pub enum FileMatch {\n // A module for searching for libraries\n \n pub struct FileSearch<'a> {\n-    pub sysroot: &'a Path,\n-    pub search_paths: &'a SearchPaths,\n-    pub triple: &'a str,\n-    pub kind: PathKind,\n+    sysroot: &'a Path,\n+    triple: &'a str,\n+    search_paths: &'a [SearchPath],\n+    tlib_path: &'a SearchPath,\n+    kind: PathKind,\n }\n \n impl<'a> FileSearch<'a> {\n-    pub fn for_each_lib_search_path<F>(&self, mut f: F) where\n-        F: FnMut(&Path, PathKind)\n-    {\n-        let mut visited_dirs = FxHashSet::default();\n-        visited_dirs.reserve(self.search_paths.paths.len() + 1);\n-        for (path, kind) in self.search_paths.iter(self.kind) {\n-            f(path, kind);\n-            visited_dirs.insert(path.to_path_buf());\n-        }\n-\n-        debug!(\"filesearch: searching lib path\");\n-        let tlib_path = make_target_lib_path(self.sysroot,\n-                                             self.triple);\n-        if !visited_dirs.contains(&tlib_path) {\n-            f(&tlib_path, PathKind::All);\n-        }\n-\n-        visited_dirs.insert(tlib_path);\n+    pub fn search_paths(&self) -> impl Iterator<Item = &'a SearchPath> {\n+        let kind = self.kind;\n+        self.search_paths.iter()\n+            .filter(move |sp| sp.kind.matches(kind))\n+            .chain(std::iter::once(self.tlib_path))\n     }\n \n     pub fn get_lib_path(&self) -> PathBuf {\n@@ -64,26 +51,20 @@ impl<'a> FileSearch<'a> {\n     pub fn search<F>(&self, mut pick: F)\n         where F: FnMut(&Path, PathKind) -> FileMatch\n     {\n-        self.for_each_lib_search_path(|lib_search_path, kind| {\n-            debug!(\"searching {}\", lib_search_path.display());\n-            let files = match fs::read_dir(lib_search_path) {\n-                Ok(files) => files,\n-                Err(..) => return,\n-            };\n-            let files = files.filter_map(|p| p.ok().map(|s| s.path()))\n-                             .collect::<Vec<_>>();\n+        for search_path in self.search_paths() {\n+            debug!(\"searching {}\", search_path.dir.display());\n             fn is_rlib(p: &Path) -> bool {\n                 p.extension() == Some(\"rlib\".as_ref())\n             }\n             // Reading metadata out of rlibs is faster, and if we find both\n             // an rlib and a dylib we only read one of the files of\n             // metadata, so in the name of speed, bring all rlib files to\n             // the front of the search list.\n-            let files1 = files.iter().filter(|p| is_rlib(p));\n-            let files2 = files.iter().filter(|p| !is_rlib(p));\n+            let files1 = search_path.files.iter().filter(|p| is_rlib(p));\n+            let files2 = search_path.files.iter().filter(|p| !is_rlib(p));\n             for path in files1.chain(files2) {\n                 debug!(\"testing {}\", path.display());\n-                let maybe_picked = pick(path, kind);\n+                let maybe_picked = pick(path, search_path.kind);\n                 match maybe_picked {\n                     FileMatches => {\n                         debug!(\"picked {}\", path.display());\n@@ -93,29 +74,30 @@ impl<'a> FileSearch<'a> {\n                     }\n                 }\n             }\n-        });\n+        }\n     }\n \n     pub fn new(sysroot: &'a Path,\n                triple: &'a str,\n-               search_paths: &'a SearchPaths,\n-               kind: PathKind) -> FileSearch<'a> {\n+               search_paths: &'a Vec<SearchPath>,\n+               tlib_path: &'a SearchPath,\n+               kind: PathKind)\n+               -> FileSearch<'a> {\n         debug!(\"using sysroot = {}, triple = {}\", sysroot.display(), triple);\n         FileSearch {\n             sysroot,\n-            search_paths,\n             triple,\n+            search_paths,\n+            tlib_path,\n             kind,\n         }\n     }\n \n-    // Returns a list of directories where target-specific dylibs might be located.\n-    pub fn get_dylib_search_paths(&self) -> Vec<PathBuf> {\n-        let mut paths = Vec::new();\n-        self.for_each_lib_search_path(|lib_search_path, _| {\n-            paths.push(lib_search_path.to_path_buf());\n-        });\n-        paths\n+    // Returns just the directories within the search paths.\n+    pub fn search_path_dirs(&self) -> Vec<PathBuf> {\n+        self.search_paths()\n+            .map(|sp| sp.dir.to_path_buf())\n+            .collect()\n     }\n \n     // Returns a list of directories where target-specific tool binaries are located.\n@@ -138,8 +120,7 @@ pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf\n     p\n }\n \n-fn make_target_lib_path(sysroot: &Path,\n-                        target_triple: &str) -> PathBuf {\n+pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n     sysroot.join(&relative_target_lib_path(sysroot, target_triple))\n }\n \n@@ -176,15 +157,15 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     // of the directory where librustc is located, rather than where the rustc\n     // binary is.\n     // If --libdir is set during configuration to the value other than\n-    // \"lib\" (i.e. non-default), this value is used (see issue #16552).\n+    // \"lib\" (i.e., non-default), this value is used (see issue #16552).\n \n     #[cfg(target_pointer_width = \"64\")]\n-    const PRIMARY_LIB_DIR: &'static str = \"lib64\";\n+    const PRIMARY_LIB_DIR: &str = \"lib64\";\n \n     #[cfg(target_pointer_width = \"32\")]\n-    const PRIMARY_LIB_DIR: &'static str = \"lib32\";\n+    const PRIMARY_LIB_DIR: &str = \"lib32\";\n \n-    const SECONDARY_LIB_DIR: &'static str = \"lib\";\n+    const SECONDARY_LIB_DIR: &str = \"lib\";\n \n     match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n         Some(libdir) if libdir != \"lib\" => libdir.into(),\n@@ -198,4 +179,4 @@ fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n-const RUST_LIB_DIR: &'static str = \"rustlib\";\n+const RUST_LIB_DIR: &str = \"rustlib\";"}, {"sha": "180019ac3875117294aae733a7f416c417ff1537", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,8 +19,8 @@ use lint;\n use lint::builtin::BuiltinLintDiagnostics;\n use middle::allocator::AllocatorKind;\n use middle::dependency_format;\n-use session::search_paths::PathKind;\n use session::config::{OutputType, Lto};\n+use session::search_paths::{PathKind, SearchPath};\n use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n@@ -48,7 +48,7 @@ use std::cell::{self, Cell, RefCell};\n use std::env;\n use std::fmt;\n use std::io::Write;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::time::Duration;\n use std::sync::mpsc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -64,12 +64,15 @@ pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n+    pub host_tlib_path: SearchPath,\n+    /// This is `None` if the host and target are the same.\n+    pub target_tlib_path: Option<SearchPath>,\n     pub parse_sess: ParseSess,\n     /// For a library crate, this is always none\n     pub entry_fn: Once<Option<(NodeId, Span, config::EntryFnType)>>,\n     pub plugin_registrar_fn: Once<Option<ast::NodeId>>,\n     pub proc_macro_decls_static: Once<Option<ast::NodeId>>,\n-    pub default_sysroot: Option<PathBuf>,\n+    pub sysroot: PathBuf,\n     /// The name of the root source file of the crate, in the local file system.\n     /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<PathBuf>,\n@@ -128,6 +131,9 @@ pub struct Session {\n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n+    /// Used by -Z self-profile\n+    pub self_profiling_active: bool,\n+\n     /// Used by -Z self-profile\n     pub self_profiling: Lock<SelfProfiler>,\n \n@@ -586,7 +592,7 @@ impl Session {\n         // either return `No` or `ThinLocal`.\n \n         // If processing command line options determined that we're incompatible\n-        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n+        // with ThinLTO (e.g., `-C lto --emit llvm-ir`) then return that option.\n         if self.opts.cli_forced_thinlto_off {\n             return config::Lto::No;\n         }\n@@ -694,27 +700,22 @@ impl Session {\n         )\n     }\n \n-    pub fn sysroot<'a>(&'a self) -> &'a Path {\n-        match self.opts.maybe_sysroot {\n-            Some(ref sysroot) => sysroot,\n-            None => self.default_sysroot\n-                        .as_ref()\n-                        .expect(\"missing sysroot and default_sysroot in Session\"),\n-        }\n-    }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n         filesearch::FileSearch::new(\n-            self.sysroot(),\n+            &self.sysroot,\n             self.opts.target_triple.triple(),\n             &self.opts.search_paths,\n+            // target_tlib_path==None means it's the same as host_tlib_path.\n+            self.target_tlib_path.as_ref().unwrap_or(&self.host_tlib_path),\n             kind,\n         )\n     }\n     pub fn host_filesearch(&self, kind: PathKind) -> filesearch::FileSearch<'_> {\n         filesearch::FileSearch::new(\n-            self.sysroot(),\n+            &self.sysroot,\n             config::host_triple(),\n             &self.opts.search_paths,\n+            &self.host_tlib_path,\n             kind,\n         )\n     }\n@@ -825,10 +826,17 @@ impl Session {\n         }\n     }\n \n+    #[inline(never)]\n+    #[cold]\n+    fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        f(&mut profiler);\n+    }\n+\n+    #[inline(always)]\n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        if self.opts.debugging_opts.self_profile {\n-            let mut profiler = self.self_profiling.borrow_mut();\n-            f(&mut profiler);\n+        if unlikely!(self.self_profiling_active) {\n+            self.profiler_active(f)\n         }\n     }\n \n@@ -1109,9 +1117,18 @@ pub fn build_session_(\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, source_map);\n-    let default_sysroot = match sopts.maybe_sysroot {\n-        Some(_) => None,\n-        None => Some(filesearch::get_or_default_sysroot()),\n+    let sysroot = match &sopts.maybe_sysroot {\n+        Some(sysroot) => sysroot.clone(),\n+        None => filesearch::get_or_default_sysroot(),\n+    };\n+\n+    let host_triple = config::host_triple();\n+    let target_triple = sopts.target_triple.triple();\n+    let host_tlib_path = SearchPath::from_sysroot_and_triple(&sysroot, host_triple);\n+    let target_tlib_path = if host_triple == target_triple {\n+        None\n+    } else {\n+        Some(SearchPath::from_sysroot_and_triple(&sysroot, target_triple))\n     };\n \n     let file_path_mapping = sopts.file_path_mapping();\n@@ -1138,16 +1155,21 @@ pub fn build_session_(\n         CguReuseTracker::new_disabled()\n     };\n \n+    let self_profiling_active = sopts.debugging_opts.self_profile ||\n+                                sopts.debugging_opts.profile_json;\n+\n     let sess = Session {\n         target: target_cfg,\n         host,\n         opts: sopts,\n+        host_tlib_path,\n+        target_tlib_path,\n         parse_sess: p_s,\n         // For a library crate, this is always none\n         entry_fn: Once::new(),\n         plugin_registrar_fn: Once::new(),\n         proc_macro_decls_static: Once::new(),\n-        default_sysroot,\n+        sysroot,\n         local_crate_source_file,\n         working_dir,\n         lint_store: RwLock::new(lint::LintStore::new()),\n@@ -1168,6 +1190,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n+        self_profiling_active,\n         self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {"}, {"sha": "5c44a07f84341467066fbd2a6079fdb899ef40bb", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,18 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice;\n use std::path::{Path, PathBuf};\n use session::{early_error, config};\n+use session::filesearch::make_target_lib_path;\n \n #[derive(Clone, Debug)]\n-pub struct SearchPaths {\n-    crate paths: Vec<(PathKind, PathBuf)>,\n-}\n-\n-pub struct Iter<'a> {\n-    kind: PathKind,\n-    iter: slice::Iter<'a, (PathKind, PathBuf)>,\n+pub struct SearchPath {\n+    pub kind: PathKind,\n+    pub dir: PathBuf,\n+    pub files: Vec<PathBuf>,\n }\n \n #[derive(Eq, PartialEq, Clone, Copy, Debug, PartialOrd, Ord, Hash)]\n@@ -32,12 +29,17 @@ pub enum PathKind {\n     All,\n }\n \n-impl SearchPaths {\n-    pub fn new() -> SearchPaths {\n-        SearchPaths { paths: Vec::new() }\n+impl PathKind {\n+    pub fn matches(&self, kind: PathKind) -> bool {\n+        match (self, kind) {\n+            (PathKind::All, _) | (_, PathKind::All) => true,\n+            _ => *self == kind,\n+        }\n     }\n+}\n \n-    pub fn add_path(&mut self, path: &str, output: config::ErrorOutputType) {\n+impl SearchPath {\n+    pub fn from_cli_opt(path: &str, output: config::ErrorOutputType) -> Self {\n         let (kind, path) = if path.starts_with(\"native=\") {\n             (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {\n@@ -54,35 +56,28 @@ impl SearchPaths {\n         if path.is_empty() {\n             early_error(output, \"empty search path given via `-L`\");\n         }\n-        self.paths.push((kind, PathBuf::from(path)));\n-    }\n \n-    pub fn iter(&self, kind: PathKind) -> Iter<'_> {\n-        Iter { kind: kind, iter: self.paths.iter() }\n+        let dir = PathBuf::from(path);\n+        Self::new(kind, dir)\n     }\n-}\n \n-impl<'a> Iterator for Iter<'a> {\n-    type Item = (&'a Path, PathKind);\n+    pub fn from_sysroot_and_triple(sysroot: &Path, triple: &str) -> Self {\n+        Self::new(PathKind::All, make_target_lib_path(sysroot, triple))\n+    }\n \n-    fn next(&mut self) -> Option<(&'a Path, PathKind)> {\n-        loop {\n-            match self.iter.next() {\n-                Some(&(kind, ref p)) if self.kind == PathKind::All ||\n-                                        kind == PathKind::All ||\n-                                        kind == self.kind => {\n-                    return Some((p, kind))\n-                }\n-                Some(..) => {}\n-                None => return None,\n+    fn new(kind: PathKind, dir: PathBuf) -> Self {\n+        // Get the files within the directory.\n+        let files = match std::fs::read_dir(&dir) {\n+            Ok(files) => {\n+                files.filter_map(|p| {\n+                    p.ok().map(|s| s.path())\n+                })\n+                .collect::<Vec<_>>()\n             }\n-        }\n-    }\n+            Err(..) => vec![],\n+        };\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // This iterator will never return more elements than the base iterator;\n-        // but it can ignore all the remaining elements.\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n+        SearchPath { kind, dir, files }\n     }\n }\n+"}, {"sha": "fff77816e7535d93727c93a59f2e716002136be3", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             // the first evaluate_predicates call.\n             //\n             // The problem is this: most of rustc, including SelectionContext and traits::project,\n-            // are designed to work with a concrete usage of a type (e.g. Vec<u8>\n+            // are designed to work with a concrete usage of a type (e.g., Vec<u8>\n             // fn<T>() { Vec<T> }. This information will generally never change - given\n             // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n             // If we're unable to prove that 'T' implements a particular trait, we're done -\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     //\n     // One additional consideration is supertrait bounds. Normally, a ParamEnv is only ever\n     // constructed once for a given type. As part of the construction process, the ParamEnv will\n-    // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n+    // have any supertrait bounds normalized - e.g., if we have a type 'struct Foo<T: Copy>', the\n     // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n     // own ParamEnv, we need to do this ourselves, through traits::elaborate_predicates, or else\n     // SelectionContext will choke on the missing predicates. However, this should never show up in\n@@ -334,11 +334,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let result = select.select(&Obligation::new(dummy_cause.clone(), new_env, pred));\n+            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // get rid of any inference variables.\n+            let obligation = infcx.resolve_type_vars_if_possible(\n+                &Obligation::new(dummy_cause.clone(), new_env, pred)\n+            );\n+            let result = select.select(&obligation);\n \n             match &result {\n                 &Ok(Some(ref vtable)) => {\n-                    // If we see an explicit negative impl (e.g. 'impl !Send for MyStruct'),\n+                    // If we see an explicit negative impl (e.g., 'impl !Send for MyStruct'),\n                     // we immediately bail out, since it's impossible for us to continue.\n                     match vtable {\n                         Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) => {\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &Ok(None) => {}\n                 &Err(SelectionError::Unimplemented) => {\n-                    if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n+                    if self.is_param_no_infer(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n@@ -427,11 +432,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // If we put both of these predicates in our computed ParamEnv, we'll\n     // confuse SelectionContext, since it will (correctly) view both as being applicable.\n     //\n-    // To solve this, we pick the 'more strict' lifetime bound - i.e. the HRTB\n+    // To solve this, we pick the 'more strict' lifetime bound - i.e., the HRTB\n     // Our end goal is to generate a user-visible description of the conditions\n     // under which a type implements an auto trait. A trait predicate involving\n     // a HRTB means that the type needs to work with any choice of lifetime,\n-    // not just one specific lifetime (e.g. 'static).\n+    // not just one specific lifetime (e.g., 'static).\n     fn add_user_pred<'c>(\n         &self,\n         user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n@@ -631,18 +636,28 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         finished_map\n     }\n \n-    pub fn is_of_param(&self, substs: &Substs<'_>) -> bool {\n-        if substs.is_noop() {\n-            return false;\n-        }\n+    fn is_param_no_infer(&self, substs: &Substs<'_>) -> bool {\n+        return self.is_of_param(substs.type_at(0)) &&\n+            !substs.types().any(|t| t.has_infer_types());\n+    }\n \n-        return match substs.type_at(0).sty {\n+    pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n+        return match ty.sty {\n             ty::Param(_) => true,\n-            ty::Projection(p) => self.is_of_param(p.substs),\n+            ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         };\n     }\n \n+    fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n+        match p.ty().skip_binder().sty {\n+            ty::Projection(proj) if proj == p.skip_binder().projection_ty => {\n+                true\n+            },\n+            _ => false\n+        }\n+    }\n+\n     pub fn evaluate_nested_obligations<\n         'b,\n         'c,\n@@ -661,28 +676,77 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     ) -> bool {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n \n-        for (obligation, predicate) in nested\n-            .filter(|o| o.recursion_depth == 1)\n+        for (obligation, mut predicate) in nested\n             .map(|o| (o.clone(), o.predicate.clone()))\n         {\n             let is_new_pred =\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n \n+            // Resolve any inference variables that we can, to help selection succeed\n+            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+\n+            // We only add a predicate as a user-displayable bound if\n+            // it involves a generic parameter, and doesn't contain\n+            // any inference variables.\n+            //\n+            // Displaying a bound involving a concrete type (instead of a generic\n+            // parameter) would be pointless, since it's always true\n+            // (e.g. u8: Copy)\n+            // Displaying an inference variable is impossible, since they're\n+            // an internal compiler detail without a defined visual representation\n+            //\n+            // We check this by calling is_of_param on the relevant types\n+            // from the various possible predicates\n             match &predicate {\n                 &ty::Predicate::Trait(ref p) => {\n-                    let substs = &p.skip_binder().trait_ref.substs;\n+                    if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n+                        && !only_projections\n+                        && is_new_pred {\n \n-                    if self.is_of_param(substs) && !only_projections && is_new_pred {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n                     predicates.push_back(p.clone());\n                 }\n                 &ty::Predicate::Projection(p) => {\n-                    // If the projection isn't all type vars, then\n-                    // we don't want to add it as a bound\n-                    if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n-                        self.add_user_pred(computed_preds, predicate);\n-                    } else {\n+                    debug!(\"evaluate_nested_obligations: examining projection predicate {:?}\",\n+                           predicate);\n+\n+                    // As described above, we only want to display\n+                    // bounds which include a generic parameter but don't include\n+                    // an inference variable.\n+                    // Additionally, we check if we've seen this predicate before,\n+                    // to avoid rendering duplicate bounds to the user.\n+                    if self.is_param_no_infer(p.skip_binder().projection_ty.substs)\n+                        && !p.ty().skip_binder().is_ty_infer()\n+                        && is_new_pred {\n+                            debug!(\"evaluate_nested_obligations: adding projection predicate\\\n+                            to computed_preds: {:?}\", predicate);\n+\n+                            // Under unusual circumstances, we can end up with a self-refeential\n+                            // projection predicate. For example:\n+                            // <T as MyType>::Value == <T as MyType>::Value\n+                            // Not only is displaying this to the user pointless,\n+                            // having it in the ParamEnv will cause an issue if we try to call\n+                            // poly_project_and_unify_type on the predicate, since this kind of\n+                            // predicate will normally never end up in a ParamEnv.\n+                            //\n+                            // For these reasons, we ignore these weird predicates,\n+                            // ensuring that we're able to properly synthesize an auto trait impl\n+                            if self.is_self_referential_projection(p) {\n+                                debug!(\"evaluate_nested_obligations: encountered a projection\n+                                 predicate equating a type with itself! Skipping\");\n+\n+                            } else {\n+                                self.add_user_pred(computed_preds, predicate);\n+                            }\n+                    }\n+\n+                    // We can only call poly_project_and_unify_type when our predicate's\n+                    // Ty is an inference variable - otherwise, there won't be anything to\n+                    // unify\n+                    if p.ty().skip_binder().is_ty_infer() {\n+                        debug!(\"Projecting and unifying projection predicate {:?}\",\n+                               predicate);\n                         match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n                             Err(e) => {\n                                 debug!("}, {"sha": "853b54df2b92ff9f705c9a1474842e75db90692a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -20,6 +20,7 @@ use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause};\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::relate::TraitObjectMode;\n use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n@@ -52,6 +53,7 @@ pub fn overlapping_impls<'gcx, F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n+    trait_object_mode: TraitObjectMode,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -62,12 +64,14 @@ where\n     debug!(\"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n            impl2_def_id={:?},\n-           intercrate_mode={:?})\",\n+           intercrate_mode={:?},\n+           trait_object_mode={:?})\",\n            impl1_def_id,\n            impl2_def_id,\n-           intercrate_mode);\n+           intercrate_mode,\n+           trait_object_mode);\n \n-    let overlaps = tcx.infer_ctxt().enter(|infcx| {\n+    let overlaps = tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n     });\n@@ -79,7 +83,7 @@ where\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    tcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().with_trait_object_mode(trait_object_mode).enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())\n@@ -256,28 +260,28 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// The current rule is that a trait-ref orphan checks in a crate C:\n ///\n /// 1. Order the parameters in the trait-ref in subst order - Self first,\n-///    others linearly (e.g. `<U as Foo<V, W>>` is U < V < W).\n+///    others linearly (e.g., `<U as Foo<V, W>>` is U < V < W).\n /// 2. Of these type parameters, there is at least one type parameter\n ///    in which, walking the type as a tree, you can reach a type local\n ///    to C where all types in-between are fundamental types. Call the\n ///    first such parameter the \"local key parameter\".\n-///     - e.g. `Box<LocalType>` is OK, because you can visit LocalType\n+///     - e.g., `Box<LocalType>` is OK, because you can visit LocalType\n ///       going through `Box`, which is fundamental.\n ///     - similarly, `FundamentalPair<Vec<()>, Box<LocalType>>` is OK for\n ///       the same reason.\n ///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n ///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n ///       the local type and the type parameter.\n /// 3. Every type parameter before the local key parameter is fully known in C.\n-///     - e.g. `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n+///     - e.g., `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n ///       an unknown type.\n ///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n ///       occurs before `T`.\n /// 4. Every type in the local key parameter not known in C, going\n ///    through the parameter's type tree, must appear only as a subtree of\n ///    a type local to C, with only fundamental types between the type\n ///    local to C and the local key parameter.\n-///     - e.g. `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n+///     - e.g., `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n ///     is bad, because the only local type with `T` as a subtree is\n ///     `LocalType<T>`, and `Vec<->` is between it and the type parameter.\n ///     - similarly, `FundamentalPair<LocalType<T>, T>` is bad, because\n@@ -288,7 +292,7 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///\n /// The orphan rules actually serve several different purposes:\n ///\n-/// 1. They enable link-safety - i.e. 2 mutually-unknowing crates (where\n+/// 1. They enable link-safety - i.e., 2 mutually-unknowing crates (where\n ///    every type local to one crate is unknown in the other) can't implement\n ///    the same trait-ref. This follows because it can be seen that no such\n ///    type can orphan-check in 2 such crates.\n@@ -393,7 +397,7 @@ fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>, in_crate: InCrate)\n                        -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n-    } else if fundamental_ty(tcx, ty) {\n+    } else if fundamental_ty(ty) {\n         ty.walk_shallow()\n           .flat_map(|t| uncovered_tys(tcx, t, in_crate))\n           .collect()\n@@ -411,14 +415,13 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n \n fn ty_is_local(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     ty_is_local_constructor(ty, in_crate) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n+        fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n-fn fundamental_ty(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n+fn fundamental_ty(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::Ref(..) => true,\n         ty::Adt(def, _) => def.is_fundamental(),\n-        ty::Dynamic(ref data, ..) => tcx.has_attr(data.principal().def_id(), \"fundamental\"),\n         _ => false\n     }\n }"}, {"sha": "373d6652b9e6abc7935770252e15497669714acb", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // returns if `cond` not occurring implies that `error` does not occur - i.e. that\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self,\n                      cond: &ty::Predicate<'tcx>,\n@@ -459,7 +459,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let simp = fast_reject::simplify_type(self.tcx,\n                                               trait_ref.skip_binder().self_ty(),\n-                                              true);\n+                                              true,);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n@@ -580,7 +580,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n \n-        if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.source_map().def_span(trait_item_span);\n             err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n         }\n@@ -765,8 +765,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n                         let closure_span = self.tcx.sess.source_map()\n-                            .def_span(self.tcx.hir.span_if_local(closure_def_id).unwrap());\n-                        let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let node_id = self.tcx.hir().as_local_node_id(closure_def_id).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, \\\n@@ -785,7 +785,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n                             let tables = tables.borrow();\n-                            let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                            let closure_hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                             match (found_kind, tables.closure_kind_origins().get(closure_hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, name))) => {\n                                     err.span_label(*span, format!(\n@@ -841,7 +841,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 let found_span = found_did.and_then(|did|\n-                    self.tcx.hir.span_if_local(did)\n+                    self.tcx.hir().span_if_local(did)\n                 ).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n@@ -862,7 +862,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                      expected_trait_ref)\n                 } else {\n                     let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir.get_if_local(did))\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n                         .map(|node| {\n                             let (found_span, found) = self.get_fn_like_arguments(node);\n                             (Some(found_span), found)\n@@ -901,8 +901,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        code: &ObligationCauseCode<'tcx>,\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n-            let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(Node::Local(ref local)) = self.tcx.hir.find(parent_node) {\n+            let parent_node = self.tcx.hir().get_parent_node(node_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(args, _),\n@@ -1037,7 +1037,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                  ).collect::<Vec<_>>())\n             }\n             Node::StructCtor(ref variant_data) => {\n-                (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n+                (self.tcx.sess.source_map().def_span(self.tcx.hir().span(variant_data.id())),\n                  vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n@@ -1236,7 +1236,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                    -> DiagnosticBuilder<'tcx>\n     {\n         assert!(type_def_id.is_local());\n-        let span = self.hir.span_if_local(type_def_id).unwrap();\n+        let span = self.hir().span_if_local(type_def_id).unwrap();\n         let span = self.sess.source_map().def_span(span);\n         let mut err = struct_span_err!(self.sess, span, E0072,\n                                        \"recursive type `{}` has infinite size\",\n@@ -1482,7 +1482,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n-                if let Some(sp) = tcx.hir.span_if_local(item_def_id) {\n+                if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n                     err.span_note(sp, &msg);\n                 } else {"}, {"sha": "09c7bd679705a8c3e27e2c270677e90698ceb548", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -61,6 +61,16 @@ pub struct FulfillmentContext<'tcx> {\n     // type-lives-for-region constraints, and because the type\n     // is well-formed, the constraints should hold.\n     register_region_obligations: bool,\n+    // Is it OK to register obligations into this infcx inside\n+    // an infcx snapshot?\n+    //\n+    // The \"primary fulfillment\" in many cases in typeck lives\n+    // outside of any snapshot, so any use of it inside a snapshot\n+    // will lead to trouble and therefore is checked against, but\n+    // other fulfillment contexts sometimes do live inside of\n+    // a snapshot (they don't *straddle* a snapshot, so there\n+    // is no trouble there).\n+    usable_in_snapshot: bool\n }\n \n #[derive(Clone, Debug)]\n@@ -74,14 +84,24 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            register_region_obligations: true\n+            register_region_obligations: true,\n+            usable_in_snapshot: false,\n+        }\n+    }\n+\n+    pub fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: true,\n+            usable_in_snapshot: true,\n         }\n     }\n \n     pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n-            register_region_obligations: false\n+            register_region_obligations: false,\n+            usable_in_snapshot: false\n         }\n     }\n \n@@ -195,7 +215,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n-        assert!(!infcx.is_in_snapshot());\n+        assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n         self.predicates.register_obligation(PendingPredicateObligation {\n             obligation,"}, {"sha": "cf37c3fceba8f2b8a3bb8fb50ef95dcb5591afcc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,34 +8,49 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Trait Resolution. See [rustc guide] for more info on how this works.\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n-pub use self::SelectionError::*;\n-pub use self::FulfillmentErrorCode::*;\n-pub use self::Vtable::*;\n-pub use self::ObligationCauseCode::*;\n+#[allow(dead_code)]\n+pub mod auto_trait;\n+mod coherence;\n+pub mod error_reporting;\n+mod engine;\n+mod fulfill;\n+mod project;\n+mod object_safety;\n+mod on_unimplemented;\n+mod select;\n+mod specialize;\n+mod structural_impls;\n+pub mod codegen;\n+mod util;\n+pub mod query;\n \n use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n-use infer::SuppressRegionErrors;\n+use infer::{InferCtxt, SuppressRegionErrors};\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use mir::interpret::ErrorHandled;\n+use rustc_data_structures::sync::Lrc;\n+use syntax::ast;\n+use syntax_pos::{Span, DUMMY_SP};\n use ty::subst::Substs;\n use ty::{self, AdtKind, List, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use infer::{InferCtxt};\n use util::common::ErrorReported;\n \n-use rustc_data_structures::sync::Lrc;\n use std::fmt::Debug;\n use std::rc::Rc;\n-use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+\n+pub use self::SelectionError::*;\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::Vtable::*;\n+pub use self::ObligationCauseCode::*;\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n@@ -49,27 +64,17 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n-pub use self::util::transitive_bounds;\n+pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n+                     Supertraits, SupertraitDefIds};\n \n-#[allow(dead_code)]\n-pub mod auto_trait;\n-mod coherence;\n-pub mod error_reporting;\n-mod engine;\n-mod fulfill;\n-mod project;\n-mod object_safety;\n-mod on_unimplemented;\n-mod select;\n-mod specialize;\n-mod structural_impls;\n-pub mod codegen;\n-mod util;\n-\n-pub mod query;\n+pub use self::ObligationCauseCode::*;\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n \n // Whether to enable bug compatibility with issue #43355\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -91,7 +96,7 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n+/// An `Obligation` represents some trait reference (e.g., `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n@@ -955,7 +960,7 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n \n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n-#[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n fn vtable_methods<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)"}, {"sha": "fe40141a5e12352ed43dbda110f5e9dd15f42a28", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -36,7 +36,7 @@ pub enum ObjectSafetyViolation {\n     SizedSelf,\n \n     /// Supertrait reference references `Self` an in illegal location\n-    /// (e.g. `trait Foo : Bar<Self>`)\n+    /// (e.g., `trait Foo : Bar<Self>`)\n     SupertraitSelf,\n \n     /// Method has something illegal\n@@ -81,7 +81,7 @@ pub enum MethodViolationCode {\n     /// e.g., `fn foo(&self, x: Self)` or `fn foo(&self) -> Self`\n     ReferencesSelf,\n \n-    /// e.g. `fn foo(&self) where Self: Clone`\n+    /// e.g., `fn foo(&self) where Self: Clone`\n     WhereClauseReferencesSelf(Span),\n \n     /// e.g., `fn foo<A>()`\n@@ -190,7 +190,26 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n                         data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n                     }\n-                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::Projection(ref data) => {\n+                        // And similarly for projections. This should be redundant with\n+                        // the previous check because any projection should have a\n+                        // matching `Trait` predicate with the same inputs, but we do\n+                        // the check to be safe.\n+                        //\n+                        // Note that we *do* allow projection *outputs* to contain\n+                        // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n+                        // we just require the user to specify *both* outputs\n+                        // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n+                        //\n+                        // This is ALT2 in issue #56288, see that for discussion of the\n+                        // possible alternatives.\n+                        data.skip_binder()\n+                            .projection_ty\n+                            .trait_ref(self)\n+                            .input_types()\n+                            .skip(1)\n+                            .any(|t| t.has_self_ty())\n+                    }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::TypeOutlives(..) |\n@@ -343,7 +362,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     }\n                 };\n \n-                // e.g. Rc<()>\n+                // e.g., Rc<()>\n                 let unit_receiver_ty = self.receiver_for_self_ty(\n                     receiver_ty, self.mk_unit(), method.def_id\n                 );\n@@ -357,7 +376,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     trait_def_id, self.mk_region(ty::ReStatic)\n                 );\n \n-                // e.g. Rc<dyn Trait>\n+                // e.g., Rc<dyn Trait>\n                 let trait_object_receiver = self.receiver_for_self_ty(\n                     receiver_ty, trait_object_ty, method.def_id\n                 );\n@@ -376,7 +395,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g. for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n     fn receiver_for_self_ty(\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n@@ -451,7 +470,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// e.g. `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// e.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n     /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n     /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n     /// contained by the trait object, because the object that needs to be coerced is behind"}, {"sha": "5717a76f1cf0f149fd8339502351f60fa96a2d63", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -70,7 +70,7 @@ pub enum Reveal {\n     /// be observable directly by the user, `Reveal::All`\n     /// should not be used by checks which may expose\n     /// type equality or type contents to the user.\n-    /// There are some exceptions, e.g. around OIBITS and\n+    /// There are some exceptions, e.g., around OIBITS and\n     /// transmute-checking, which expose some details, but\n     /// not the whole concrete type of the `impl Trait`.\n     All,\n@@ -608,7 +608,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // created (and hence the new ones will quickly be\n             // discarded as duplicated). But when doing trait\n             // evaluation this is not the case, and dropping the trait\n-            // evaluations can causes ICEs (e.g. #43132).\n+            // evaluations can causes ICEs (e.g., #43132).\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n@@ -1589,7 +1589,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// When working with a fulfillment context, the derived obligations of each\n /// projection cache entry will be registered on the fulfillcx, so any users\n /// that can wait for a fulfillcx fixed point need not care about this. However,\n-/// users that don't wait for a fixed point (e.g. trait evaluation) have to\n+/// users that don't wait for a fixed point (e.g., trait evaluation) have to\n /// resolve the obligations themselves to make sure the projected result is\n /// ok and avoid issues like #43132.\n ///\n@@ -1637,7 +1637,7 @@ enum ProjectionCacheEntry<'tcx> {\n     NormalizedTy(NormalizedTy<'tcx>),\n }\n \n-// NB: intentionally not Clone\n+// N.B., intentionally not Clone\n pub struct ProjectionCacheSnapshot {\n     snapshot: Snapshot,\n }"}, {"sha": "f506c47371c928abe46059645ed6f5c5316ed861", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -55,8 +55,8 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         let c_ty = self.infcx.canonicalize_query(&self.param_env.and(ty), &mut orig_values);\n         let span = self.cause.span;\n         debug!(\"c_ty = {:?}\", c_ty);\n-        match &gcx.dropck_outlives(c_ty) {\n-            Ok(result) if result.is_proven() => {\n+        if let Ok(result) = &gcx.dropck_outlives(c_ty) {\n+            if result.is_proven() {\n                 if let Ok(InferOk { value, obligations }) =\n                     self.infcx.instantiate_query_response_and_region_obligations(\n                     self.cause,\n@@ -72,8 +72,6 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n                     };\n                 }\n             }\n-\n-            _ => { /* fallthrough to error-handling code below */ }\n         }\n \n         // Errors and ambiuity in dropck occur in two cases:\n@@ -82,10 +80,11 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         // Either of these should have created an error before.\n         tcx.sess\n             .delay_span_bug(span, \"dtorck encountered internal error\");\n-        return InferOk {\n+\n+        InferOk {\n             value: vec![],\n             obligations: vec![],\n-        };\n+        }\n     }\n }\n \n@@ -102,7 +101,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n         span: Span,\n         ty: Ty<'tcx>,\n     ) {\n-        for overflow_ty in self.overflows.iter().take(1) {\n+        if let Some(overflow_ty) = self.overflows.iter().next() {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 span,\n@@ -228,7 +227,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().cloned().all(|t| trivial_dropck_outlives(tcx, t)),\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t)),\n         ty::Closure(def_id, ref substs) => substs\n             .upvar_tys(def_id, tcx)\n             .all(|t| trivial_dropck_outlives(tcx, t)),"}, {"sha": "175883eb2a73458febddcd9faab1b8d7cf415353", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::sync::Lrc;\n+use infer::canonical::{Canonical, QueryResponse};\n+use ty::Ty;\n+\n+#[derive(Debug)]\n+pub struct CandidateStep<'tcx> {\n+    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    pub autoderefs: usize,\n+    // true if the type results from a dereference of a raw pointer.\n+    // when assembling candidates, we include these steps, but not when\n+    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    pub from_unsafe_deref: bool,\n+    pub unsize: bool,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct MethodAutoderefStepsResult<'tcx> {\n+    /// The valid autoderef steps that could be find.\n+    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    /// If Some(T), a type autoderef reported an error on.\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    /// If `true`, `steps` has been truncated due to reaching the\n+    /// recursion limit.\n+    pub reached_recursion_limit: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct MethodAutoderefBadTy<'tcx> {\n+    pub reached_raw_pointer: bool,\n+    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+}\n+\n+impl_stable_hash_for!(struct MethodAutoderefBadTy<'tcx> {\n+    reached_raw_pointer, ty\n+});\n+\n+impl_stable_hash_for!(struct MethodAutoderefStepsResult<'tcx> {\n+    reached_recursion_limit, steps, opt_bad_ty\n+});\n+\n+impl_stable_hash_for!(struct CandidateStep<'tcx> {\n+    self_ty, autoderefs, from_unsafe_deref, unsize\n+});"}, {"sha": "b11cb7377645c3a5344e21c60dce6526998e52f2", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,6 +21,7 @@ use ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n+pub mod method_autoderef;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n pub mod outlives_bounds;"}, {"sha": "d46389b0ee226139a50b61ce82383e3bc2e5dc78", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See [rustc guide] for more info on how this works.\n+//! Candidate selection. See the [rustc guide] for more information on how this works.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n \n@@ -44,7 +44,7 @@ use infer::{InferCtxt, InferOk, TypeFreshener};\n use middle::lang_items;\n use mir::interpret::GlobalId;\n use ty::fast_reject;\n-use ty::relate::TypeRelation;\n+use ty::relate::{TypeRelation, TraitObjectMode};\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n@@ -69,18 +69,18 @@ pub struct SelectionContext<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n \n-    /// If true, indicates that the evaluation should be conservative\n+    /// If `true`, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n     /// This comes up primarily when resolving ambiguity. Imagine\n-    /// there is some trait reference `$0 : Bar` where `$0` is an\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n     /// inference variable. If `intercrate` is true, then we can never\n     /// say for sure that this reference is not implemented, even if\n     /// there are *no impls at all for `Bar`*, because `$0` could be\n     /// bound to some type that in a downstream crate that implements\n     /// `Bar`. This is the suitable mode for coherence. Elsewhere,\n     /// though, we set this to false, because we are only interested\n     /// in types that the user could actually have written --- in\n-    /// other words, we consider `$0 : Bar` to be unimplemented if\n+    /// other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: Option<IntercrateMode>,\n@@ -1170,7 +1170,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See [rustc guide] for more details.\n+    // candidates. See the [rustc guide] for more details.\n     //\n     // [rustc guide]:\n     // https://rust-lang.github.io/rustc-guide/traits/resolution.html#candidate-assembly\n@@ -1501,6 +1501,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return false;\n         }\n \n+        // Same idea as the above, but for alt trait object modes. These\n+        // should only be used in intercrate mode - better safe than sorry.\n+        if self.infcx.trait_object_mode() != TraitObjectMode::NoSquash {\n+            bug!(\"using squashing TraitObjectMode outside of intercrate mode? param_env={:?}\",\n+                 param_env);\n+        }\n+\n         // Otherwise, we can use the global cache.\n         true\n     }\n@@ -1615,7 +1622,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n-            // Self is a type variable (e.g. `_: AsRef<str>`).\n+            // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really\n             // handle it turning to be a projection. This does end up as truly\n@@ -1664,7 +1671,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n         } else {\n             if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n                 // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n                 // types have builtin support for `Clone`.\n                 let clone_conditions = self.copy_clone_conditions(obligation);\n@@ -2023,7 +2030,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n \n-                        // NB: we can safely drop the placeholder map\n+                        // N.B., we can safely drop the placeholder map\n                         // since we are in a probe.\n                         mem::drop(placeholder_map);\n                     }\n@@ -2069,7 +2076,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     // that this obligation holds. That could be a\n                     // where-clause or, in the case of an object type,\n                     // it could be that the object type lists the\n-                    // trait (e.g. `Foo+Send : Send`). See\n+                    // trait (e.g., `Foo+Send : Send`). See\n                     // `compile-fail/typeck-default-trait-impl-send-param.rs`\n                     // for an example of a test case that exercises\n                     // this path.\n@@ -2097,7 +2104,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         );\n \n         self.probe(|this, _snapshot| {\n-            // the code below doesn't care about regions, and the\n+            // The code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n@@ -2145,7 +2152,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 .count();\n \n             if upcast_trait_refs > 1 {\n-                // can be upcast in many ways; need more type information\n+                // Can be upcast in many ways; need more type information.\n                 candidates.ambiguous = true;\n             } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n@@ -2197,8 +2204,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n-                // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                // 1. Dropping builtin bounds, e.g., `Foo+Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo+'a` to `Foo+'b` if `'a : 'b`\n                 //\n                 // Note that neither of these changes requires any\n                 // change at runtime.  Eventually this will be\n@@ -2354,7 +2361,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ImplCandidate(other_def) => {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n-                // i.e. EvaluatedToOk:\n+                // i.e., EvaluatedToOk:\n                 if other.evaluation == EvaluatedToOk {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n@@ -2717,7 +2724,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See [rustc guide] for more details.\n+    // type error.  See the [rustc guide] for more details.\n     //\n     // [rustc guide]:\n     // https://rust-lang.github.io/rustc-guide/traits/resolution.html#confirmation\n@@ -3003,7 +3010,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // are sufficient to determine the impl substs, without\n         // relying on projections in the impl-trait-ref.\n         //\n-        // e.g. `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n+        // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData {\n@@ -3699,7 +3706,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         previous: &ty::PolyTraitRef<'tcx>,\n         current: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let mut matcher = ty::_match::Match::new(self.tcx());\n+        let mut matcher = ty::_match::Match::new(\n+            self.tcx(), self.infcx.trait_object_mode());\n         matcher.relate(previous, current).is_ok()\n     }\n "}, {"sha": "70d36e9afe192d76e93afbfd04a20e1755f72cba", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,24 +19,24 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use super::{SelectionContext, FulfillmentContext};\n-use super::util::impl_trait_ref_and_oblig;\n+pub mod specialization_graph;\n \n-use rustc_data_structures::fx::FxHashSet;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n-use ty::subst::{Subst, Substs};\n-use traits::{self, ObligationCause, TraitEngine};\n+use lint;\n+use traits::{self, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::DUMMY_SP;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n-use syntax_pos::DUMMY_SP;\n-use rustc_data_structures::sync::Lrc;\n-\n-use lint;\n+use ty::subst::{Subst, Substs};\n \n-pub mod specialization_graph;\n+use super::{SelectionContext, FulfillmentContext};\n+use super::util::impl_trait_ref_and_oblig;\n \n /// Information pertinent to an overlapping impl error.\n+#[derive(Debug)]\n pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n@@ -85,6 +85,8 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                         source_substs: &'tcx Substs<'tcx>,\n                                         target_node: specialization_graph::Node)\n                                         -> &'tcx Substs<'tcx> {\n+    debug!(\"translate_substs({:?}, {:?}, {:?}, {:?})\",\n+           param_env, source_impl, source_substs, target_node);\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -119,10 +121,13 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// whichever applies.\n pub fn find_associated_item<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssociatedItem,\n     substs: &'tcx Substs<'tcx>,\n     impl_data: &super::VtableImplData<'tcx, ()>,\n ) -> (DefId, &'tcx Substs<'tcx>) {\n+    debug!(\"find_associated_item({:?}, {:?}, {:?}, {:?})\",\n+           param_env, item, substs, impl_data);\n     assert!(!substs.needs_infer());\n \n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n@@ -132,7 +137,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     match ancestors.defs(tcx, item.ident, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = ty::ParamEnv::reveal_all();\n+                let param_env = param_env.with_reveal_all();\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n@@ -179,7 +184,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     //\n     // See RFC 1210 for more details and justification.\n \n-    // Currently we do not allow e.g. a negative impl to specialize a positive one\n+    // Currently we do not allow e.g., a negative impl to specialize a positive one\n     if tcx.impl_polarity(impl1_def_id) != tcx.impl_polarity(impl2_def_id) {\n         return false;\n     }\n@@ -219,12 +224,17 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n+    debug!(\"fulfill_implication({:?}, trait_ref={:?} |- {:?} applies)\",\n+           param_env, source_trait_ref, target_impl);\n+\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,\n                                                                        target_substs);\n+    debug!(\"fulfill_implication: target_trait_ref={:?}, obligations={:?}\",\n+           target_trait_ref, obligations);\n \n     // do the impls unify? If not, no specialization.\n     match infcx.at(&ObligationCause::dummy(), param_env)\n@@ -285,17 +295,18 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n // Query provider for `specialization_graph_of`.\n-pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      trait_id: DefId)\n-                                                      -> Lrc<specialization_graph::Graph> {\n+pub(super) fn specialization_graph_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_id: DefId,\n+) -> Lrc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n     let mut trait_impls = tcx.all_impls(trait_id);\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by\n-    // negated CrateNum (so remote definitions are visited first) and then\n-    // by a flattened version of the DefIndex.\n+    // negated `CrateNum` (so remote definitions are visited first) and then\n+    // by a flattened version of the `DefIndex`.\n     trait_impls.sort_unstable_by_key(|def_id| {\n         (-(def_id.krate.as_u32() as i64),\n          def_id.index.address_space().index(),\n@@ -308,8 +319,9 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n-                Err(overlap) => (Some(overlap), false),\n-                Ok(opt_overlap) => (opt_overlap, true)\n+                Err(overlap) => (Some(overlap), None),\n+                Ok(Some(overlap)) => (Some(overlap.error), Some(overlap.kind)),\n+                Ok(None) => (None, None)\n             };\n \n             if let Some(overlap) = overlap {\n@@ -319,15 +331,21 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                         String::new(), |ty| {\n                             format!(\" for type `{}`\", ty)\n                         }),\n-                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n+                    if used_to_be_allowed.is_some() { \" (E0119)\" } else { \"\" }\n                 );\n                 let impl_span = tcx.sess.source_map().def_span(\n                     tcx.span_of_impl(impl_def_id).unwrap()\n                 );\n-                let mut err = if used_to_be_allowed {\n+                let mut err = if let Some(kind) = used_to_be_allowed {\n+                    let lint = match kind {\n+                        FutureCompatOverlapErrorKind::Issue43355 =>\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        FutureCompatOverlapErrorKind::Issue33140 =>\n+                            lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS,\n+                    };\n                     tcx.struct_span_lint_node(\n-                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n-                        tcx.hir.as_local_node_id(impl_def_id).unwrap(),\n+                        lint,\n+                        tcx.hir().as_local_node_id(impl_def_id).unwrap(),\n                         impl_span,\n                         &msg)\n                 } else {"}, {"sha": "1a228660306418a5aaf10f9d65c5b4d27e576d7d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -17,6 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n+use ty::relate::TraitObjectMode;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::Ident;\n use util::captures::Captures;\n@@ -29,7 +30,7 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///\n /// The graph provides two key services:\n ///\n-/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n+/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n ///   that overlap but where neither specializes the other -- an artifact of the\n ///   simple \"chain\" rule.\n ///\n@@ -39,11 +40,11 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///   has at most one parent.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Graph {\n-    // all impls have a parent; the \"root\" impls have as their parent the def_id\n-    // of the trait\n+    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    // of the trait.\n     parent: DefIdMap<DefId>,\n \n-    // the \"root\" impls are found by looking up the trait's def_id.\n+    // The \"root\" impls are found by looking up the trait's def_id.\n     children: DefIdMap<Children>,\n }\n \n@@ -68,10 +69,22 @@ struct Children {\n     blanket_impls: Vec<DefId>,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum FutureCompatOverlapErrorKind {\n+    Issue43355,\n+    Issue33140,\n+}\n+\n+#[derive(Debug)]\n+pub struct FutureCompatOverlapError {\n+    pub error: OverlapError,\n+    pub kind: FutureCompatOverlapErrorKind\n+}\n+\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling(Option<OverlapError>),\n+    BecameNewSibling(Option<FutureCompatOverlapError>),\n \n     /// The impl should replace existing impls [X1, ..], because the impl specializes X1, X2, etc.\n     ReplaceChildren(Vec<DefId>),\n@@ -81,7 +94,7 @@ enum Inserted {\n }\n \n impl<'a, 'gcx, 'tcx> Children {\n-    /// Insert an impl into this set of children without comparing to any existing impls\n+    /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self,\n                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                       impl_def_id: DefId) {\n@@ -132,10 +145,12 @@ impl<'a, 'gcx, 'tcx> Children {\n             simplified_self,\n         );\n \n-        for possible_sibling in match simplified_self {\n-            Some(sty) => self.filtered(sty),\n-            None => self.iter(),\n-        } {\n+        let possible_siblings = match simplified_self {\n+            Some(sty) => PotentialSiblings::Filtered(self.filtered(sty)),\n+            None => PotentialSiblings::Unfiltered(self.iter()),\n+        };\n+\n+        for possible_sibling in possible_siblings {\n             debug!(\n                 \"insert: impl_def_id={:?}, simplified_self={:?}, possible_sibling={:?}\",\n                 impl_def_id,\n@@ -144,13 +159,13 @@ impl<'a, 'gcx, 'tcx> Children {\n             );\n \n             let overlap_error = |overlap: traits::coherence::OverlapResult<'_>| {\n-                // overlap, but no specialization; error out\n+                // Found overlap, but no specialization; error out.\n                 let trait_ref = overlap.impl_header.trait_ref.unwrap();\n                 let self_ty = trait_ref.self_ty();\n                 OverlapError {\n                     with_impl: possible_sibling,\n                     trait_desc: trait_ref.to_string(),\n-                    // only report the Self type if it has at least\n+                    // Only report the `Self` type if it has at least\n                     // some outer concrete shell; otherwise, it's\n                     // not adding much information.\n                     self_desc: if self_ty.has_concrete_skeleton() {\n@@ -168,6 +183,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n+                TraitObjectMode::NoSquash,\n                 |overlap| {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -189,7 +205,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 debug!(\"descending as child of TraitRef {:?}\",\n                        tcx.impl_trait_ref(possible_sibling).unwrap());\n \n-                // the impl specializes possible_sibling\n+                // The impl specializes `possible_sibling`.\n                 return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n             } else if ge && !le {\n                 debug!(\"placing as parent of TraitRef {:?}\",\n@@ -198,12 +214,36 @@ impl<'a, 'gcx, 'tcx> Children {\n                 replace_children.push(possible_sibling);\n             } else {\n                 if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    // do future-compat checks for overlap. Have issue #43355\n+                    // errors overwrite issue #33140 errors when both are present.\n+\n+                    traits::overlapping_impls(\n+                        tcx,\n+                        possible_sibling,\n+                        impl_def_id,\n+                        traits::IntercrateMode::Fixed,\n+                        TraitObjectMode::SquashAutoTraitsIssue33140,\n+                        |overlap| {\n+                            last_lint = Some(FutureCompatOverlapError {\n+                                error: overlap_error(overlap),\n+                                kind: FutureCompatOverlapErrorKind::Issue33140\n+                            });\n+                        },\n+                        || (),\n+                    );\n+\n                     traits::overlapping_impls(\n                         tcx,\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n-                        |overlap| last_lint = Some(overlap_error(overlap)),\n+                        TraitObjectMode::NoSquash,\n+                        |overlap| {\n+                            last_lint = Some(FutureCompatOverlapError {\n+                                error: overlap_error(overlap),\n+                                kind: FutureCompatOverlapErrorKind::Issue43355\n+                            });\n+                        },\n                         || (),\n                     );\n                 }\n@@ -216,20 +256,43 @@ impl<'a, 'gcx, 'tcx> Children {\n             return Ok(Inserted::ReplaceChildren(replace_children));\n         }\n \n-        // no overlap with any potential siblings, so add as a new sibling\n+        // No overlap with any potential siblings, so add as a new sibling.\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n         Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n-    fn iter(&mut self) -> Box<dyn Iterator<Item = DefId> + '_> {\n+    fn iter(&mut self) -> impl Iterator<Item = DefId> + '_ {\n         let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter());\n-        Box::new(self.blanket_impls.iter().chain(nonblanket).cloned())\n+        self.blanket_impls.iter().chain(nonblanket).cloned()\n     }\n \n-    fn filtered(&mut self, sty: SimplifiedType) -> Box<dyn Iterator<Item = DefId> + '_> {\n+    fn filtered(&mut self, sty: SimplifiedType) -> impl Iterator<Item = DefId> + '_ {\n         let nonblanket = self.nonblanket_impls.entry(sty).or_default().iter();\n-        Box::new(self.blanket_impls.iter().chain(nonblanket).cloned())\n+        self.blanket_impls.iter().chain(nonblanket).cloned()\n+    }\n+}\n+\n+// A custom iterator used by Children::insert\n+enum PotentialSiblings<I, J>\n+    where I: Iterator<Item = DefId>,\n+          J: Iterator<Item = DefId>\n+{\n+    Unfiltered(I),\n+    Filtered(J)\n+}\n+\n+impl<I, J> Iterator for PotentialSiblings<I, J>\n+    where I: Iterator<Item = DefId>,\n+          J: Iterator<Item = DefId>\n+{\n+    type Item = DefId;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match *self {\n+            PotentialSiblings::Unfiltered(ref mut iter) => iter.next(),\n+            PotentialSiblings::Filtered(ref mut iter) => iter.next()\n+        }\n     }\n }\n \n@@ -247,7 +310,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<Option<OverlapError>, OverlapError> {\n+                  -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -256,7 +319,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         debug!(\"insert({:?}): inserting TraitRef {:?} into specialization graph\",\n                impl_def_id, trait_ref);\n \n-        // if the reference itself contains an earlier error (e.g., due to a\n+        // If the reference itself contains an earlier error (e.g., due to a\n         // resolution failure), then we just insert the impl at the top level of\n         // the graph and claim that there's no overlap (in order to suppress\n         // bogus errors).\n@@ -275,7 +338,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         let mut last_lint = None;\n         let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n-        // Descend the specialization tree, where `parent` is the current parent node\n+        // Descend the specialization tree, where `parent` is the current parent node.\n         loop {\n             use self::Inserted::*;\n \n@@ -313,7 +376,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n                         siblings.insert_blindly(tcx, impl_def_id);\n                     }\n \n-                    // Set G's parent to N and N's parent to P\n+                    // Set G's parent to N and N's parent to P.\n                     for &grand_child_to_be in &grand_children_to_be {\n                         self.parent.insert(grand_child_to_be, impl_def_id);\n                     }\n@@ -429,7 +492,8 @@ impl<T> NodeItem<T> {\n impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n-    #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+    // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n+    #[inline]\n     pub fn defs(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "36e93cc7740894fa522cd1a8cde196cff3f7f324", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -33,8 +33,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n             write!(\n                 f,\n-                \"Obligation(predicate={:?},cause={:?},depth={})\",\n-                self.predicate, self.cause, self.recursion_depth\n+                \"Obligation(predicate={:?},cause={:?},param_env={:?},depth={})\",\n+                self.predicate, self.cause, self.param_env, self.recursion_depth\n             )\n         } else {\n             write!("}, {"sha": "48db72c1f5615bc73dd13383997ed2ef64ea852c", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir;\n use hir::def_id::DefId;\n-use ty::subst::{Kind, Subst, Substs};\n+use traits::specialize::specialization_graph::NodeItem;\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n+use ty::subst::{Kind, Subst, Substs};\n use util::nodemap::FxHashSet;\n-use hir::{self};\n-use traits::specialize::specialization_graph::NodeItem;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n@@ -535,9 +535,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n-        match self.hir.as_local_node_id(node_item_def_id) {\n+        match self.hir().as_local_node_id(node_item_def_id) {\n             Some(node_id) => {\n-                let item = self.hir.expect_item(node_id);\n+                let item = self.hir().expect_item(node_id);\n                 if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {"}, {"sha": "29067bf518da02201de197b28921af2fbaf4a4eb", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -29,17 +29,24 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    trait_object_mode: relate::TraitObjectMode\n }\n \n impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n-        Match { tcx }\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               trait_object_mode: relate::TraitObjectMode)\n+               -> Match<'a, 'gcx, 'tcx> {\n+        Match { tcx, trait_object_mode }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n+    fn trait_object_mode(&self) -> relate::TraitObjectMode {\n+        self.trait_object_mode\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n "}, {"sha": "d91ae7e120f6604ffe2417f547d02977b7fbfd11", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -83,7 +83,7 @@ pub enum Adjust<'tcx> {\n     /// Take the address and produce either a `&` or `*` pointer.\n     Borrow(AutoBorrow<'tcx>),\n \n-    /// Unsize a pointer/reference value, e.g. `&[T; n]` to\n+    /// Unsize a pointer/reference value, e.g., `&[T; n]` to\n     /// `&[T]`. Note that the source could be a thin or fat pointer.\n     /// This will do things like convert thin pointers to fat\n     /// pointers, or convert structs containing thin pointers to"}, {"sha": "5ad7d247fe4594b9d59e25431926246cde8510ea", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -92,7 +92,7 @@ pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n     let leb128_bits = len * 7;\n \n     // Check that the shorthand is a not longer than the\n-    // full encoding itself, i.e. it's an obvious win.\n+    // full encoding itself, i.e., it's an obvious win.\n     if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n         cache(encoder).insert(value.clone(), shorthand);\n     }"}, {"sha": "3741f4051b896b2df72bed995c3359d3a297ddbc", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -5,7 +5,6 @@ use ty::TyCtxt;\n use syntax_pos::symbol::Symbol;\n use hir::map::blocks::FnLikeNode;\n use syntax::attr;\n-use rustc_target::spec::abi;\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n@@ -40,19 +39,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns true if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n+        // Bail out if the signature doesn't contain `const`\n+        if !self.is_const_fn_raw(def_id) {\n+            return false;\n+        }\n+\n         if self.features().staged_api {\n-            // some intrinsics are waved through if called inside the\n-            // standard library. Users never need to call them directly\n-            if let abi::Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n-                assert!(!self.is_const_fn(def_id));\n-                match &self.item_name(def_id).as_str()[..] {\n-                    | \"size_of\"\n-                    | \"min_align_of\"\n-                    | \"needs_drop\"\n-                    => return true,\n-                    _ => {},\n-                }\n-            }\n             // in order for a libstd function to be considered min_const_fn\n             // it needs to be stable and have no `rustc_const_unstable` attribute\n             match self.lookup_stability(def_id) {\n@@ -75,10 +67,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n     fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n-        let node_id = tcx.hir.as_local_node_id(def_id)\n+        let node_id = tcx.hir().as_local_node_id(def_id)\n                              .expect(\"Non-local call to local provider is_const_fn\");\n \n-        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+        if let Some(fn_like) = FnLikeNode::from_node(tcx.hir().get(node_id)) {\n             fn_like.constness() == hir::Constness::Const\n         } else {\n             false"}, {"sha": "9883752da0b69beec0010d4950752a8b014e689e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 94, "deletions": 65, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -72,6 +72,7 @@ use std::ops::{Deref, Bound};\n use std::iter;\n use std::sync::mpsc;\n use std::sync::Arc;\n+use std::marker::PhantomData;\n use rustc_target::spec::abi;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n@@ -86,13 +87,15 @@ use hir;\n pub struct AllArenas<'tcx> {\n     pub global: WorkerLocal<GlobalArenas<'tcx>>,\n     pub interner: SyncDroplessArena,\n+    global_ctxt: Option<GlobalCtxt<'tcx>>,\n }\n \n impl<'tcx> AllArenas<'tcx> {\n     pub fn new() -> Self {\n         AllArenas {\n             global: WorkerLocal::new(|_| GlobalArenas::default()),\n             interner: SyncDroplessArena::default(),\n+            global_ctxt: None,\n         }\n     }\n }\n@@ -250,11 +253,11 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n         if let Some(local_id_root) = local_id_root {\n             if hir_id.owner != local_id_root.index {\n                 ty::tls::with(|tcx| {\n-                    let node_id = tcx.hir.hir_to_node_id(hir_id);\n+                    let node_id = tcx.hir().hir_to_node_id(hir_id);\n \n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                         tcx.hir.node_to_string(node_id),\n+                         tcx.hir().node_to_string(node_id),\n                          DefId::local(hir_id.owner),\n                          local_id_root)\n                 });\n@@ -530,8 +533,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_id_to_type_opt(id).unwrap_or_else(||\n             bug!(\"node_id_to_type: no type for node `{}`\",\n                  tls::with(|tcx| {\n-                     let id = tcx.hir.hir_to_node_id(id);\n-                     tcx.hir.node_to_string(id)\n+                     let id = tcx.hir().hir_to_node_id(id);\n+                     tcx.hir().node_to_string(id)\n                  }))\n         )\n     }\n@@ -587,7 +590,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     // auto-ref.  The type returned by this function does not consider such\n     // adjustments.  See `expr_ty_adjusted()` instead.\n     //\n-    // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n+    // NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n     pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n@@ -869,12 +872,13 @@ pub struct FreeRegionInfo {\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    gcx: &'a GlobalCtxt<'gcx>,\n-    interners: &'a CtxtInterners<'tcx>\n+    gcx: &'gcx GlobalCtxt<'gcx>,\n+    interners: &'tcx CtxtInterners<'tcx>,\n+    dummy: PhantomData<&'a ()>,\n }\n \n-impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n-    type Target = &'a GlobalCtxt<'gcx>;\n+impl<'gcx> Deref for TyCtxt<'_, 'gcx, '_> {\n+    type Target = &'gcx GlobalCtxt<'gcx>;\n     #[inline(always)]\n     fn deref(&self) -> &Self::Target {\n         &self.gcx\n@@ -903,7 +907,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Lrc<Vec<Export>>>,\n \n-    pub hir: hir_map::Map<'tcx>,\n+    hir_map: hir_map::Map<'tcx>,\n \n     /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n@@ -946,7 +950,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores the value of constants (and deduplicates the actual memory)\n     allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n \n-    pub alloc_map: Lock<interpret::AllocMap<'tcx, &'tcx Allocation>>,\n+    pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n     layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n \n@@ -964,13 +968,19 @@ pub struct GlobalCtxt<'tcx> {\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Get the global TyCtxt.\n     #[inline]\n-    pub fn global_tcx(self) -> TyCtxt<'a, 'gcx, 'gcx> {\n+    pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n         TyCtxt {\n             gcx: self.gcx,\n             interners: &self.gcx.global_interners,\n+            dummy: PhantomData,\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn hir(self) -> &'a hir_map::Map<'gcx> {\n+        &self.hir_map\n+    }\n+\n     pub fn alloc_generics(self, generics: ty::Generics) -> &'gcx ty::Generics {\n         self.global_arenas.generics.alloc(generics)\n     }\n@@ -1100,7 +1110,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   cstore: &'tcx CrateStoreDyn,\n                                   local_providers: ty::query::Providers<'tcx>,\n                                   extern_providers: ty::query::Providers<'tcx>,\n-                                  arenas: &'tcx AllArenas<'tcx>,\n+                                  arenas: &'tcx mut AllArenas<'tcx>,\n                                   resolutions: ty::Resolutions,\n                                   hir: hir_map::Map<'tcx>,\n                                   on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n@@ -1161,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                      Lrc::new(StableVec::new(v)));\n         }\n \n-        let gcx = &GlobalCtxt {\n+        arenas.global_ctxt = Some(GlobalCtxt {\n             sess: s,\n             cstore,\n             global_arenas: &arenas.global,\n@@ -1186,7 +1196,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     .map(|(id, sp)| (hir.local_def_id(id), sp))\n                     .collect(),\n             extern_prelude: resolutions.extern_prelude,\n-            hir,\n+            hir_map: hir,\n             def_path_hash_to_def_id,\n             queries: query::Queries::new(\n                 providers,\n@@ -1204,7 +1214,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n-        };\n+        });\n+\n+        let gcx = arenas.global_ctxt.as_ref().unwrap();\n \n         sync::assert_send_val(&gcx);\n \n@@ -1272,7 +1284,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n         if id.is_local() {\n-            self.hir.def_key(id)\n+            self.hir().def_key(id)\n         } else {\n             self.cstore.def_key(id)\n         }\n@@ -1285,7 +1297,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n         if id.is_local() {\n-            self.hir.def_path(id)\n+            self.hir().def_path(id)\n         } else {\n             self.cstore.def_path(id)\n         }\n@@ -1294,7 +1306,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if def_id.is_local() {\n-            self.hir.definitions().def_path_hash(def_id.index)\n+            self.hir().definitions().def_path_hash(def_id.index)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -1331,12 +1343,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n+    #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n-        let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n+        let krate = self.gcx.hir_map.forest.untracked_krate();\n \n         StableHashingContext::new(self.sess,\n                                   krate,\n-                                  self.hir.definitions(),\n+                                  self.hir().definitions(),\n                                   self.cstore)\n     }\n \n@@ -1493,12 +1506,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             BorrowckMode::Ast => match self.sess.edition() {\n                 Edition::Edition2015 => BorrowckMode::Ast,\n                 Edition::Edition2018 => BorrowckMode::Migrate,\n-\n-                // For now, future editions mean Migrate. (But it\n-                // would make a lot of sense for it to be changed to\n-                // `BorrowckMode::Mir`, depending on how we plan to\n-                // time the forcing of full migration to NLL.)\n-                _ => BorrowckMode::Migrate,\n             },\n         }\n     }\n@@ -1530,10 +1537,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let node_id = self.hir\n+        let node_id = self.hir()\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n-        let is_impl_item = match self.hir.find(node_id) {\n+        let is_impl_item = match self.hir().find(node_id) {\n             Some(Node::Item(..)) | Some(Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1553,8 +1560,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n-        let node_id = self.hir.as_local_node_id(scope_def_id).unwrap();\n-        match self.hir.get(node_id) {\n+        let node_id = self.hir().as_local_node_id(scope_def_id).unwrap();\n+        match self.hir().get(node_id) {\n             Node::Item(item) => {\n                 match item.node {\n                     ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n@@ -1610,20 +1617,25 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n+impl<'gcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n-    pub fn enter_local<F, R>(\n-        &self,\n+    /// `interners` is a slot passed so we can create a CtxtInterners\n+    /// with the same lifetime as `arena`.\n+    pub fn enter_local<'tcx, F, R>(\n+        &'gcx self,\n         arena: &'tcx SyncDroplessArena,\n+        interners: &'tcx mut Option<CtxtInterners<'tcx>>,\n         f: F\n     ) -> R\n     where\n-        F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+        F: FnOnce(TyCtxt<'tcx, 'gcx, 'tcx>) -> R,\n+        'gcx: 'tcx,\n     {\n-        let interners = CtxtInterners::new(arena);\n+        *interners = Some(CtxtInterners::new(&arena));\n         let tcx = TyCtxt {\n             gcx: self,\n-            interners: &interners,\n+            interners: interners.as_ref().unwrap(),\n+            dummy: PhantomData,\n         };\n         ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n@@ -1632,8 +1644,8 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n                 layout_depth: icx.layout_depth,\n                 task: icx.task,\n             };\n-            ty::tls::enter_context(&new_icx, |new_icx| {\n-                f(new_icx.tcx)\n+            ty::tls::enter_context(&new_icx, |_| {\n+                f(tcx)\n             })\n         })\n     }\n@@ -1655,7 +1667,7 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n /// For Ty, None can be returned if either the type interner doesn't\n /// contain the TyKind key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n-/// e.g. `()` or `u8`, was interned in a different context.\n+/// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n@@ -1873,6 +1885,7 @@ pub mod tls {\n \n     use std::fmt;\n     use std::mem;\n+    use std::marker::PhantomData;\n     use syntax_pos;\n     use ty::query;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n@@ -1892,10 +1905,10 @@ pub mod tls {\n     /// you should also have access to an ImplicitCtxt through the functions\n     /// in this module.\n     #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub struct ImplicitCtxt<'a, 'gcx: 'tcx, 'tcx> {\n         /// The current TyCtxt. Initially created by `enter_global` and updated\n         /// by `enter_local` with a new local interner\n-        pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n         /// The current query job, if any. This is updated by start_job in\n         /// ty::query::plumbing when executing a query\n@@ -1913,13 +1926,15 @@ pub mod tls {\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n     #[cfg(parallel_queries)]\n+    #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n     /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n     /// This is used to get the pointer to the current ImplicitCtxt.\n     #[cfg(parallel_queries)]\n+    #[inline]\n     fn get_tlv() -> usize {\n         rayon_core::tlv::get()\n     }\n@@ -1932,6 +1947,7 @@ pub mod tls {\n     /// It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n     #[cfg(not(parallel_queries))]\n+    #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n         let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n@@ -1948,8 +1964,12 @@ pub mod tls {\n     /// This is a callback from libsyntax as it cannot access the implicit state\n     /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        with(|tcx| {\n-            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+        with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+            } else {\n+                syntax_pos::default_span_debug(span, f)\n+            }\n         })\n     }\n \n@@ -1992,6 +2012,7 @@ pub mod tls {\n     }\n \n     /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    #[inline]\n     pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n                                                      f: F) -> R\n         where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n@@ -2005,8 +2026,8 @@ pub mod tls {\n     /// creating a initial TyCtxt and ImplicitCtxt.\n     /// This happens once per rustc session and TyCtxts only exists\n     /// inside the `f` function.\n-    pub fn enter_global<'gcx, F, R>(gcx: &GlobalCtxt<'gcx>, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n+    pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n+        where F: FnOnce(TyCtxt<'gcx, 'gcx, 'gcx>) -> R\n     {\n         with_thread_locals(|| {\n             // Update GCX_PTR to indicate there's a GlobalCtxt available\n@@ -2021,6 +2042,7 @@ pub mod tls {\n             let tcx = TyCtxt {\n                 gcx,\n                 interners: &gcx.global_interners,\n+                dummy: PhantomData,\n             };\n             let icx = ImplicitCtxt {\n                 tcx,\n@@ -2050,6 +2072,7 @@ pub mod tls {\n         let tcx = TyCtxt {\n             gcx,\n             interners: &gcx.global_interners,\n+            dummy: PhantomData,\n         };\n         let icx = ImplicitCtxt {\n             query: None,\n@@ -2061,6 +2084,7 @@ pub mod tls {\n     }\n \n     /// Allows access to the current ImplicitCtxt in a closure if one is available\n+    #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n@@ -2078,6 +2102,7 @@ pub mod tls {\n \n     /// Allows access to the current ImplicitCtxt.\n     /// Panics if there is no ImplicitCtxt available\n+    #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n@@ -2089,6 +2114,7 @@ pub mod tls {\n     /// with the same 'gcx lifetime as the TyCtxt passed in.\n     /// This will panic if you pass it a TyCtxt which has a different global interner from\n     /// the current ImplicitCtxt's tcx field.\n+    #[inline]\n     pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n         where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n     {\n@@ -2107,6 +2133,7 @@ pub mod tls {\n     /// is given an ImplicitCtxt with the same 'tcx and 'gcx lifetimes as the TyCtxt passed in.\n     /// This will panic if you pass it a TyCtxt which has a different global interner or\n     /// a different local interner from the current ImplicitCtxt's tcx field.\n+    #[inline]\n     pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n         where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n@@ -2124,6 +2151,7 @@ pub mod tls {\n \n     /// Allows access to the TyCtxt in the current ImplicitCtxt.\n     /// Panics if there is no ImplicitCtxt available\n+    #[inline]\n     pub fn with<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n@@ -2132,6 +2160,7 @@ pub mod tls {\n \n     /// Allows access to the TyCtxt in the current ImplicitCtxt.\n     /// The closure is passed None if there is no ImplicitCtxt available\n+    #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n@@ -2229,7 +2258,7 @@ impl<'tcx, T: 'tcx+?Sized> Clone for Interned<'tcx, T> {\n }\n impl<'tcx, T: 'tcx+?Sized> Copy for Interned<'tcx, T> {}\n \n-// NB: An Interned<Ty> compares and hashes as a sty.\n+// N.B., an `Interned<Ty>` compares and hashes as a sty.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n         self.0.sty == other.0.sty\n@@ -2250,7 +2279,7 @@ impl<'tcx: 'lcx, 'lcx> Borrow<TyKind<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n     }\n }\n \n-// NB: An Interned<List<T>> compares and hashes as its elements.\n+// N.B., an `Interned<List<T>>` compares and hashes as its elements.\n impl<'tcx, T: PartialEq> PartialEq for Interned<'tcx, List<T>> {\n     fn eq(&self, other: &Interned<'tcx, List<T>>) -> bool {\n         self.0[..] == other.0[..]\n@@ -2461,7 +2490,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a closure signature `sig`, returns an equivalent `fn`\n     /// type with the same signature. Detuples and so forth -- so\n-    /// e.g. if we have a sig with `Fn<(u32, i32)>` then you would get\n+    /// e.g., if we have a sig with `Fn<(u32, i32)>` then you would get\n     /// a `fn(u32, i32)`.\n     pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         let converted_sig = sig.map_bound(|s| {\n@@ -2710,7 +2739,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, keywords::SelfType.name().as_interned_str())\n+        self.mk_ty_param(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n@@ -2866,11 +2895,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n-                                              lint: &'static Lint,\n-                                              hir_id: HirId,\n-                                              span: S,\n-                                              msg: &str,\n-                                              note: &str) {\n+                                             lint: &'static Lint,\n+                                             hir_id: HirId,\n+                                             span: S,\n+                                             msg: &str,\n+                                             note: &str) {\n         let mut err = self.struct_span_lint_hir(lint, hir_id, span.into(), msg);\n         err.note(note);\n         err.emit()\n@@ -2901,11 +2930,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.dep_graph.with_ignore(|| {\n             let sets = self.lint_levels(LOCAL_CRATE);\n             loop {\n-                let hir_id = self.hir.definitions().node_to_hir_id(id);\n+                let hir_id = self.hir().definitions().node_to_hir_id(id);\n                 if let Some(pair) = sets.level_and_source(lint, hir_id, self.sess) {\n                     return pair\n                 }\n-                let next = self.hir.get_parent_node(id);\n+                let next = self.hir().get_parent_node(id);\n                 if next == id {\n                     bug!(\"lint traversal reached the root of the crate\");\n                 }\n@@ -2921,7 +2950,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                     msg: &str)\n         -> DiagnosticBuilder<'tcx>\n     {\n-        let node_id = self.hir.hir_to_node_id(hir_id);\n+        let node_id = self.hir().hir_to_node_id(hir_id);\n         let (level, src) = self.lint_level_at_node(lint, node_id);\n         lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n     }\n@@ -3013,9 +3042,9 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // FIXME(#44234): almost all of these queries have no sub-queries and\n     // therefore no actual inputs, they're just reading tables calculated in\n-    // resolve! Does this work? Unsure! That's what the issue is about\n+    // resolve! Does this work? Unsure! That's what the issue is about.\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n     providers.crate_name = |tcx, id| {\n@@ -3045,16 +3074,16 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.lookup_stability = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n         tcx.stability().local_stability(id)\n     };\n     providers.lookup_deprecation_entry = |tcx, id| {\n         assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n         tcx.stability().local_deprecation_entry(id)\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {\n-        let id = tcx.hir.as_local_node_id(id).unwrap();\n+        let id = tcx.hir().as_local_node_id(id).unwrap();\n         tcx.cstore.extern_mod_stmt_cnum_untracked(id)\n     };\n     providers.all_crate_nums = |tcx, cnum| {\n@@ -3075,10 +3104,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir.krate_attrs(), \"panic_runtime\")\n+        attr::contains_name(tcx.hir().krate_attrs(), \"panic_runtime\")\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir.krate_attrs(), \"compiler_builtins\")\n+        attr::contains_name(tcx.hir().krate_attrs(), \"compiler_builtins\")\n     };\n }"}, {"sha": "a361ad057c74a0e8c730c4641fd2205b9f694e1f", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,7 +19,7 @@ pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n }\n \n fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    // NB: use `super_fold_with` here. If we used `fold_with`, it\n+    // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n     ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }"}, {"sha": "bd01dd8cb0ce64ecd3628dcdeab6dcd72ffe1cdd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -43,6 +43,9 @@ pub enum SimplifiedTypeGen<D>\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n+    /// A trait object, all of whose components are markers\n+    /// (e.g., `dyn Send + Sync`).\n+    MarkerTraitObjectSimplifiedType,\n     TraitSimplifiedType(D),\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n@@ -78,7 +81,12 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n         ty::RawPtr(_) => Some(PtrSimplifiedType),\n         ty::Dynamic(ref trait_info, ..) => {\n-            Some(TraitSimplifiedType(trait_info.principal().def_id()))\n+            let principal_def_id = trait_info.principal().def_id();\n+            if tcx.trait_is_auto(principal_def_id) {\n+                Some(MarkerTraitObjectSimplifiedType)\n+            } else {\n+                Some(TraitSimplifiedType(principal_def_id))\n+            }\n         }\n         ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we\n@@ -110,7 +118,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 // anything. when lazy normalization happens, this\n                 // will change. It would still be nice to have a way\n                 // to deal with known-not-to-unify-with-anything\n-                // projections (e.g. the likes of <__S as Encoder>::Error).\n+                // projections (e.g., the likes of <__S as Encoder>::Error).\n                 Some(ParameterSimplifiedType)\n             } else {\n                 None\n@@ -144,6 +152,7 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n             NeverSimplifiedType => NeverSimplifiedType,\n             TupleSimplifiedType(n) => TupleSimplifiedType(n),\n             TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n+            MarkerTraitObjectSimplifiedType => MarkerTraitObjectSimplifiedType,\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n@@ -170,7 +179,8 @@ impl<'a, 'gcx, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n             ArraySimplifiedType |\n             PtrSimplifiedType |\n             NeverSimplifiedType |\n-            ParameterSimplifiedType => {\n+            ParameterSimplifiedType |\n+            MarkerTraitObjectSimplifiedType => {\n                 // nothing to do\n             }\n             IntSimplifiedType(t) => t.hash_stable(hcx, hasher),"}, {"sha": "a40e1df14f8e829621517752ec9ef18479f0ab44", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -887,7 +887,7 @@ struct LateBoundRegionsCollector {\n \n     /// If true, we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n-    /// particular, if you have e.g. `&'a u32` and `&'b u32`, equating\n+    /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n     /// them constraints `'a == 'b`.  But if you have `<&'a u32 as\n     /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n     /// types may mean that `'a` and `'b` don't appear in the results,"}, {"sha": "af2185205a33df38c449fb0f838953c99c0ab9f3", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir.local_def_id(CRATE_NODE_ID);\n+        let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n \n@@ -74,10 +74,21 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n                            iter: I) -> DefIdForest\n             where I: IntoIterator<Item=DefIdForest>\n     {\n-        let mut ret = DefIdForest::full(tcx);\n+        let mut iter = iter.into_iter();\n+        let mut ret = if let Some(first) = iter.next() {\n+            first\n+        } else {\n+            return DefIdForest::full(tcx);\n+        };\n+\n         let mut next_ret = SmallVec::new();\n         let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n         for next_forest in iter {\n+            // No need to continue if the intersection is already empty.\n+            if ret.is_empty() {\n+                break;\n+            }\n+\n             for id in ret.root_ids.drain() {\n                 if next_forest.contains(tcx, id) {\n                     next_ret.push(id);"}, {"sha": "c64811e32f437b6cd9db9f9b65734078a0874694", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::{FxHashMap, FxHashSet};\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use ty::{DefId, Substs};\n@@ -113,7 +112,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n-        ty.uninhabited_from(&mut FxHashMap::default(), self)\n+        ty.uninhabited_from(self)\n     }\n \n     pub fn is_enum_variant_uninhabited_from(self,\n@@ -140,20 +139,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let adt_kind = self.adt_def(adt_def_id).adt_kind();\n \n         // Compute inhabitedness forest:\n-        variant.uninhabited_from(&mut FxHashMap::default(), self, substs, adt_kind)\n+        variant.uninhabited_from(self, substs, adt_kind)\n     }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+            v.uninhabited_from(tcx, substs, self.adt_kind())\n         }))\n     }\n }\n@@ -162,7 +160,6 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         adt_kind: AdtKind) -> DefIdForest\n@@ -175,7 +172,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             AdtKind::Struct => false,\n         };\n         DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-            f.uninhabited_from(visited, tcx, substs, is_enum)\n+            f.uninhabited_from(tcx, substs, is_enum)\n         }))\n     }\n }\n@@ -184,13 +181,12 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n-        let mut data_uninhabitedness = move || {\n-            self.ty(tcx, substs).uninhabited_from(visited, tcx)\n+        let data_uninhabitedness = move || {\n+            self.ty(tcx, substs).uninhabited_from(tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // Visibility::Invisible so we need to override self.vis if we're\n@@ -213,54 +209,24 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        visited: &mut FxHashMap<DefId, FxHashSet<&'tcx Substs<'tcx>>>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n+    fn uninhabited_from(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n-            Adt(def, substs) => {\n-                {\n-                    let substs_set = visited.entry(def.did).or_default();\n-                    if !substs_set.insert(substs) {\n-                        // We are already calculating the inhabitedness of this type.\n-                        // The type must contain a reference to itself. Break the\n-                        // infinite loop.\n-                        return DefIdForest::empty();\n-                    }\n-                    if substs_set.len() >= tcx.sess.recursion_limit.get() / 4 {\n-                        // We have gone very deep, reinstantiating this ADT inside\n-                        // itself with different type arguments. We are probably\n-                        // hitting an infinite loop. For example, it's possible to write:\n-                        //                a type Foo<T>\n-                        //      which contains a Foo<(T, T)>\n-                        //      which contains a Foo<((T, T), (T, T))>\n-                        //      which contains a Foo<(((T, T), (T, T)), ((T, T), (T, T)))>\n-                        //      etc.\n-                        let error = format!(\"reached recursion limit while checking \\\n-                                             inhabitedness of `{}`\", self);\n-                        tcx.sess.fatal(&error);\n-                    }\n-                }\n-                let ret = def.uninhabited_from(visited, tcx, substs);\n-                let substs_set = visited.get_mut(&def.did).unwrap();\n-                substs_set.remove(substs);\n-                ret\n-            }\n+            Adt(def, substs) => def.uninhabited_from(tcx, substs),\n \n             Never => DefIdForest::full(tcx),\n \n             Tuple(ref tys) => {\n                 DefIdForest::union(tcx, tys.iter().map(|ty| {\n-                    ty.uninhabited_from(visited, tcx)\n+                    ty.uninhabited_from(tcx)\n                 }))\n             }\n \n             Array(ty, len) => {\n                 match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n-                    Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),\n+                    Some(n) if n != 0 => ty.uninhabited_from(tcx),\n                     _ => DefIdForest::empty()\n                 }\n             }"}, {"sha": "a24920da158e2772f9b51c40785a2ce660c7fa34", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -347,9 +347,10 @@ fn resolve_associated_item<'a, 'tcx>(\n ) -> Option<Instance<'tcx>> {\n     let def_id = trait_item.def_id;\n     debug!(\"resolve_associated_item(trait_item={:?}, \\\n+            param_env={:?}, \\\n             trait_id={:?}, \\\n             rcvr_substs={:?})\",\n-           def_id, trait_id, rcvr_substs);\n+            def_id, param_env, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n     let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)));\n@@ -359,7 +360,7 @@ fn resolve_associated_item<'a, 'tcx>(\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n             let (def_id, substs) = traits::find_associated_item(\n-                tcx, trait_item, rcvr_substs, &impl_data);\n+                tcx, param_env, trait_item, rcvr_substs, &impl_data);\n             let substs = tcx.erase_regions(&substs);\n             Some(ty::Instance::new(def_id, substs))\n         }"}, {"sha": "a39eb004fd7864bd711cd998955921968616d35d", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns a string identifying this local node-id.\n     pub fn node_path_str(self, id: ast::NodeId) -> String {\n-        self.item_path_str(self.hir.local_def_id(id))\n+        self.item_path_str(self.hir().local_def_id(id))\n     }\n \n     /// Returns a string identifying this def-id. This string is\n@@ -317,7 +317,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // Unclear if there is any value in distinguishing these.\n             // Probably eventually (and maybe we would even want\n-            // finer-grained distinctions, e.g. between enum/struct).\n+            // finer-grained distinctions, e.g., between enum/struct).\n             data @ DefPathData::Misc |\n             data @ DefPathData::TypeNs(..) |\n             data @ DefPathData::Trait(..) |\n@@ -464,8 +464,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n         self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n-        let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n-        let item = self.hir.expect_item(node_id);\n+        let node_id = self.hir().as_local_node_id(impl_def_id).unwrap();\n+        let item = self.hir().expect_item(node_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }"}, {"sha": "f4506c8e8197661a3377f9400b5909c12a046586", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -191,7 +191,14 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::tls::enter_context(&icx, |_| {\n             let cx = LayoutCx { tcx, param_env };\n-            cx.layout_raw_uncached(ty)\n+            let layout = cx.layout_raw_uncached(ty);\n+            // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+            if let Ok(layout) = layout {\n+                if ty.conservative_is_privately_uninhabited(tcx) {\n+                    assert!(layout.abi.is_uninhabited());\n+                }\n+            }\n+            layout\n         })\n     })\n }\n@@ -205,12 +212,11 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n \n pub struct LayoutCx<'tcx, C> {\n     pub tcx: C,\n-    pub param_env: ty::ParamEnv<'tcx>\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n-    fn layout_raw_uncached(&self, ty: Ty<'tcx>)\n-                           -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+    fn layout_raw_uncached(&self, ty: Ty<'tcx>) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n         let tcx = self.tcx;\n         let param_env = self.param_env;\n         let dl = self.data_layout();\n@@ -248,7 +254,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             AlwaysSized,\n             /// A univariant, the last field of which may be coerced to unsized.\n             MaybeUnsized,\n-            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n+            /// A univariant, but with a prefix of an arbitrary size & alignment (e.g., enum tag).\n             Prefixed(Size, Align),\n         }\n \n@@ -551,13 +557,19 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n+                let abi = if count != 0 && ty.conservative_is_privately_uninhabited(tcx) {\n+                    Abi::Uninhabited\n+                } else {\n+                    Abi::Aggregate { sized: true }\n+                };\n+\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Aggregate { sized: true },\n+                    abi,\n                     align: element.align,\n                     size\n                 })\n@@ -748,7 +760,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 // A variant is absent if it's uninhabited and only has ZST fields.\n                 // Present uninhabited variants only require space for their fields,\n-                // but *not* an encoding of the discriminant (e.g. a tag value).\n+                // but *not* an encoding of the discriminant (e.g., a tag value).\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n                 let absent = |fields: &[TyLayout<'_>]| {\n@@ -1252,7 +1264,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }).collect();\n \n             session::VariantInfo {\n-                name: n.map(|n|n.to_string()),\n+                name: n.map(|n| n.to_string()),\n                 kind: if layout.is_unsized() {\n                     session::SizeKind::Min\n                 } else {\n@@ -1311,7 +1323,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     }\n }\n \n-/// Type size \"skeleton\", i.e. the only information determining a type's size.\n+/// Type size \"skeleton\", i.e., the only information determining a type's size.\n /// While this is conservative, (aside from constant sizes, only pointers,\n /// newtypes thereof and null pointer optimized enums are allowed), it is\n /// enough to statically check common use cases of transmute.\n@@ -1522,7 +1534,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             details\n         };\n \n-        // NB: This recording is normally disabled; when enabled, it\n+        // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n@@ -1549,7 +1561,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>>\n             details\n         };\n \n-        // NB: This recording is normally disabled; when enabled, it\n+        // N.B., this recording is normally disabled; when enabled, it\n         // can however trigger recursive invocations of `layout_of`.\n         // Therefore, we execute it *after* the main query has\n         // completed, to avoid problems around recursive structures\n@@ -1660,7 +1672,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 assert!(i < this.fields.count());\n \n                 // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n+                // This provides information about e.g., DST struct pointees\n                 // (which may have no non-DST form), and will work as long\n                 // as the `Abi` or `FieldPlacement` is checked by users.\n                 if i == 0 {"}, {"sha": "e1bf43c3782e86f0202fca7730feacc586687158", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 113, "deletions": 92, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -82,7 +82,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables};\n+pub use self::context::{Lift, TypeckTables, CtxtInterners};\n \n pub use self::instance::{Instance, InstanceDef};\n \n@@ -125,7 +125,7 @@ mod sty;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to codegen and later passes.\n ///\n-/// NB: These contents are being migrated into queries using the\n+/// N.B., these contents are being migrated into queries using the\n /// *on-demand* infrastructure.\n #[derive(Clone)]\n pub struct CrateAnalysis {\n@@ -289,7 +289,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir.get_module_parent(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent(id))\n             }\n         }\n     }\n@@ -505,15 +505,15 @@ pub struct TyS<'tcx> {\n     ///     by some sub-binder.\n     ///\n     /// So, for a type without any late-bound things, like `u32`, this\n-    /// will be INNERMOST, because that is the innermost binder that\n+    /// will be *innermost*, because that is the innermost binder that\n     /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with debruijn index D, this would be D+1 --\n-    /// the binder itself does not capture D, but D is captured by an\n-    /// inner binder.\n+    /// late-bound region with debruijn index `D`, this would be `D + 1`\n+    /// -- the binder itself does not capture `D`, but `D` is captured\n+    /// by an inner binder.\n     ///\n-    /// We call this concept an \"exclusive\" binder D (because all\n+    /// We call this concept an \"exclusive\" binder `D` because all\n     /// debruijn indices within the type are contained within `0..D`\n-    /// (exclusive)).\n+    /// (exclusive).\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n@@ -900,10 +900,10 @@ pub struct GenericParamCount {\n }\n \n /// Information about the formal type/lifetime parameters associated\n-/// with an item or method. Analogous to hir::Generics.\n+/// with an item or method. Analogous to `hir::Generics`.\n ///\n-/// The ordering of parameters is the same as in Subst (excluding child generics):\n-/// Self (optionally), Lifetime params..., Type params...\n+/// The ordering of parameters is the same as in `Subst` (excluding child generics):\n+/// `Self` (optionally), `Lifetime` params..., `Type` params...\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n@@ -1681,7 +1681,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// pair it with the empty environment. This improves caching and is generally\n     /// invisible.\n     ///\n-    /// NB: We preserve the environment when type-checking because it\n+    /// N.B., we preserve the environment when type-checking because it\n     /// is possible for the user to have wacky where-clauses like\n     /// `where Box<u32>: Copy`, which are clearly never\n     /// satisfiable. We generally want to behave as if they were true,\n@@ -1754,17 +1754,19 @@ bitflags! {\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n         const IS_ENUM             = 1 << 0;\n-        const IS_PHANTOM_DATA     = 1 << 1;\n-        const IS_FUNDAMENTAL      = 1 << 2;\n-        const IS_UNION            = 1 << 3;\n-        const IS_BOX              = 1 << 4;\n+        const IS_UNION            = 1 << 1;\n+        const IS_STRUCT           = 1 << 2;\n+        const HAS_CTOR            = 1 << 3;\n+        const IS_PHANTOM_DATA     = 1 << 4;\n+        const IS_FUNDAMENTAL      = 1 << 5;\n+        const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 5;\n+        const IS_ARC              = 1 << 7;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 6;\n+        const IS_RC               = 1 << 8;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE   = 1 << 7;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n     }\n }\n \n@@ -1778,8 +1780,8 @@ bitflags! {\n \n #[derive(Debug)]\n pub struct VariantDef {\n-    /// The variant's DefId. If this is a tuple-like struct,\n-    /// this is the DefId of the struct's ctor.\n+    /// The variant's `DefId`. If this is a tuple-like struct,\n+    /// this is the `DefId` of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub discr: VariantDiscr,\n@@ -1798,7 +1800,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     ///\n     /// Note that we *could* use the constructor DefId, because the constructor attributes\n     /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the AdtDefs for all the structs in the universe (e.g. coherence for any\n+    /// loading the AdtDefs for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n@@ -1847,7 +1849,7 @@ impl_stable_hash_for!(struct VariantDef {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum VariantDiscr {\n-    /// Explicit value for this variant, i.e. `X = 123`.\n+    /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n     Explicit(DefId),\n \n@@ -1865,9 +1867,9 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of an abstract data type - a struct or enum.\n+/// The definition of an abstract data type -- a struct or enum.\n ///\n-/// These are all interned (by intern_adt_def) into the adt_defs\n+/// These are all interned (by `intern_adt_def`) into the `adt_defs`\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n@@ -2059,9 +2061,10 @@ impl ReprOptions {\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n-    /// optimizations, such as with repr(C) or repr(packed(1)).\n+    /// optimizations, such as with repr(C), repr(packed(1)), or repr(<int>).\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n+            self.int.is_some()\n     }\n \n     /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n@@ -2079,31 +2082,43 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n            repr: ReprOptions) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n+\n+        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n+        }\n+        flags |= match kind {\n+            AdtKind::Enum => AdtFlags::IS_ENUM,\n+            AdtKind::Union => AdtFlags::IS_UNION,\n+            AdtKind::Struct => AdtFlags::IS_STRUCT,\n+        };\n+\n+        if let AdtKind::Struct = kind {\n+            let variant_def = &variants[VariantIdx::new(0)];\n+            let def_key = tcx.def_key(variant_def.did);\n+            match def_key.disambiguated_data.data {\n+                DefPathData::StructCtor => flags |= AdtFlags::HAS_CTOR,\n+                _ => (),\n+            }\n+        }\n+\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n-            flags = flags | AdtFlags::IS_FUNDAMENTAL;\n+            flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n-            flags = flags | AdtFlags::IS_PHANTOM_DATA;\n+            flags |= AdtFlags::IS_PHANTOM_DATA;\n         }\n         if Some(did) == tcx.lang_items().owned_box() {\n-            flags = flags | AdtFlags::IS_BOX;\n+            flags |= AdtFlags::IS_BOX;\n         }\n         if Some(did) == tcx.lang_items().arc() {\n-            flags = flags | AdtFlags::IS_ARC;\n+            flags |= AdtFlags::IS_ARC;\n         }\n         if Some(did) == tcx.lang_items().rc() {\n-            flags = flags | AdtFlags::IS_RC;\n-        }\n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n-            debug!(\"found non-exhaustive variant list for {:?}\", did);\n-            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n-        }\n-        match kind {\n-            AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n-            AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n-            AdtKind::Struct => {}\n+            flags |= AdtFlags::IS_RC;\n         }\n+\n         AdtDef {\n             did,\n             variants,\n@@ -2114,25 +2129,25 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn is_struct(&self) -> bool {\n-        !self.is_union() && !self.is_enum()\n+        self.flags.contains(AdtFlags::IS_STRUCT)\n     }\n \n     #[inline]\n     pub fn is_union(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_UNION)\n+        self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ENUM)\n+        self.flags.contains(AdtFlags::IS_ENUM)\n     }\n \n     #[inline]\n     pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n-    /// Returns the kind of the ADT - Struct or Enum.\n+    /// Returns the kind of the ADT.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n         if self.is_enum() {\n@@ -2161,33 +2176,39 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Returns whether this type is #[fundamental] for the purposes\n+    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n+    #[inline]\n+    pub fn has_ctor(&self) -> bool {\n+        self.flags.contains(AdtFlags::HAS_CTOR)\n+    }\n+\n+    /// Returns whether this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n+        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n+        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns `true` if this is `Arc<T>`.\n     pub fn is_arc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ARC)\n+        self.flags.contains(AdtFlags::IS_ARC)\n     }\n \n     /// Returns `true` if this is `Rc<T>`.\n     pub fn is_rc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_RC)\n+        self.flags.contains(AdtFlags::IS_RC)\n     }\n \n     /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_BOX)\n+        self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n     /// Returns whether this type has a destructor.\n@@ -2367,7 +2388,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Self would prevent its containing ADT from being Sized.\n     ///\n     /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer, e.g. issue #31299.\n+    /// the associated type is behind a pointer, e.g., issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match tcx.try_adt_sized_constraint(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n@@ -2619,29 +2640,29 @@ impl<'gcx> ::std::ops::Deref for Attributes<'gcx> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n-        self.typeck_tables_of(self.hir.body_owner_def_id(body))\n+        self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the def-ids for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n-    /// themselves, you can do `self.hir.krate().body_ids.iter()`.\n+    /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(\n         self,\n     ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n-        self.hir.krate()\n-                .body_ids\n-                .iter()\n-                .map(move |&body_id| self.hir.body_owner_def_id(body_id))\n+        self.hir().krate()\n+                  .body_ids\n+                  .iter()\n+                  .map(move |&body_id| self.hir().body_owner_def_id(body_id))\n     }\n \n     pub fn par_body_owners<F: Fn(DefId) + sync::Sync + sync::Send>(self, f: F) {\n-        par_iter(&self.hir.krate().body_ids).for_each(|&body_id| {\n-            f(self.hir.body_owner_def_id(body_id))\n+        par_iter(&self.hir().krate().body_ids).for_each(|&body_id| {\n+            f(self.hir().body_owner_def_id(body_id))\n         });\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n-        match self.hir.find(id) {\n+        match self.hir().find(id) {\n             Some(Node::Expr(e)) => {\n                 e.span\n             }\n@@ -2667,8 +2688,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n-        let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n-            match self.hir.get(node_id) {\n+        let is_associated_item = if let Some(node_id) = self.hir().as_local_node_id(def_id) {\n+            match self.hir().get(node_id) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2691,7 +2712,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            parent_vis: &hir::Visibility,\n                                            trait_item_ref: &hir::TraitItemRef)\n                                            -> AssociatedItem {\n-        let def_id = self.hir.local_def_id(trait_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id(trait_item_ref.id.node_id);\n         let (kind, has_self) = match trait_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2717,7 +2738,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           parent_def_id: DefId,\n                                           impl_item_ref: &hir::ImplItemRef)\n                                           -> AssociatedItem {\n-        let def_id = self.hir.local_def_id(impl_item_ref.id.node_id);\n+        let def_id = self.hir().local_def_id(impl_item_ref.id.node_id);\n         let (kind, has_self) = match impl_item_ref.kind {\n             hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n             hir::AssociatedItemKind::Method { has_self } => {\n@@ -2740,7 +2761,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn field_index(self, node_id: NodeId, tables: &TypeckTables<'_>) -> usize {\n-        let hir_id = self.hir.node_to_hir_id(node_id);\n+        let hir_id = self.hir().node_to_hir_id(node_id);\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n \n@@ -2878,8 +2899,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n-        if let Some(id) = self.hir.as_local_node_id(did) {\n-            Attributes::Borrowed(self.hir.attrs(id))\n+        if let Some(id) = self.hir().as_local_node_id(did) {\n+            Attributes::Borrowed(self.hir().attrs(id))\n         } else {\n             Attributes::Owned(self.item_attrs(did))\n         }\n@@ -2930,8 +2951,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n-            let node_id = self.hir.as_local_node_id(impl_did).unwrap();\n-            Ok(self.hir.span(node_id))\n+            let node_id = self.hir().as_local_node_id(impl_did).unwrap();\n+            Ok(self.hir().span(node_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -2947,14 +2968,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().expansion_that_defined(scope.index),\n+            LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n         let scope = match ident.span.adjust(target_expansion) {\n             Some(actual_expansion) =>\n-                self.hir.definitions().parent_module_of_macro_def(actual_expansion),\n+                self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId\n-            None => self.hir.get_module_parent(block),\n+            None => self.hir().get_module_parent(block),\n         };\n         (ident, scope)\n     }\n@@ -2980,7 +3001,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n-        let def_id = self.hir.local_def_id(fid);\n+        let def_id = self.hir().local_def_id(fid);\n         match self.freevars(def_id) {\n             None => f(&[]),\n             Some(d) => f(&d),\n@@ -2989,10 +3010,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let parent_id = tcx.hir.get_parent(id);\n-    let parent_def_id = tcx.hir.local_def_id(parent_id);\n-    let parent_item = tcx.hir.expect_item(parent_id);\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n@@ -3049,19 +3070,19 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Lrc<Vec<DefId>> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let item = tcx.hir.expect_item(id);\n+    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(id);\n     let vec: Vec<_> = match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n-                           .map(|id| tcx.hir.local_def_id(id.node_id))\n+                           .map(|id| tcx.hir().local_def_id(id.node_id))\n                            .collect()\n         }\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n-                          .map(|id| tcx.hir.local_def_id(id.node_id))\n+                          .map(|id| tcx.hir().local_def_id(id.node_id))\n                           .collect()\n         }\n         hir::ItemKind::TraitAlias(..) => vec![],\n@@ -3071,7 +3092,7 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n-    tcx.hir.span_if_local(def_id).unwrap()\n+    tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given def ID describes an item belonging to a trait,\n@@ -3089,8 +3110,8 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir.get(node_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }\n@@ -3101,8 +3122,8 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n \n /// Returns `true` if `def_id` is a trait alias.\n pub fn is_trait_alias(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir.get(node_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n+        if let Node::Item(item) = tcx.hir().get(node_id) {\n             if let hir::ItemKind::TraitAlias(..) = item.node {\n                 return true;\n             }\n@@ -3140,8 +3161,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n                                              traits::Reveal::UserFacing);\n \n-    let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n-        tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+    let body_id = tcx.hir().as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n@@ -3163,7 +3184,7 @@ fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         crate_num: CrateNum)\n                         -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.hir.crate_hash\n+    tcx.hir().crate_hash\n }\n \n fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "b320c29dfada5f10a1aad4301ab1bbab70eb06b9", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -227,9 +227,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n \n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let id = tcx.hir().as_local_node_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id)).into()\n+                tcx.hir().ty_param_name(id)).into()\n     }\n }\n \n@@ -827,6 +827,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_pre\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::method_autoderef_steps<'tcx> {\n+    fn describe(_tcx: TyCtxt<'_, '_, '_>, goal: CanonicalTyGoal<'tcx>) -> Cow<'static, str> {\n+        format!(\"computing autoderef types for `{:?}`\", goal).into()\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::target_features_whitelist<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"looking up the whitelist of target features\".into()"}, {"sha": "6e513d68f60f52fe9a372062aaa8314a497d75da", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 102, "deletions": 55, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -18,6 +18,11 @@ use syntax_pos::Span;\n use ty::tls;\n use ty::query::Query;\n use ty::query::plumbing::CycleError;\n+#[cfg(not(parallel_queries))]\n+use ty::query::{\n+    plumbing::TryGetJob,\n+    config::QueryDescription,\n+};\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n use std::process;\n@@ -83,41 +88,52 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n-    pub(super) fn await<'lcx>(\n+    #[cfg(not(parallel_queries))]\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn cycle_error<'lcx, 'a, D: QueryDescription<'tcx>>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n-        #[cfg(not(parallel_queries))]\n-        {\n-            self.find_cycle_in_stack(tcx, span)\n-        }\n-\n-        #[cfg(parallel_queries)]\n-        {\n-            tls::with_related_context(tcx, move |icx| {\n-                let mut waiter = Lrc::new(QueryWaiter {\n-                    query: icx.query.clone(),\n-                    span,\n-                    cycle: Lock::new(None),\n-                    condvar: Condvar::new(),\n-                });\n-                self.latch.await(&waiter);\n+    ) -> TryGetJob<'a, 'tcx, D> {\n+        TryGetJob::JobCompleted(Err(Box::new(self.find_cycle_in_stack(tcx, span))))\n+    }\n \n-                match Lrc::get_mut(&mut waiter).unwrap().cycle.get_mut().take() {\n-                    None => Ok(()),\n-                    Some(cycle) => Err(cycle)\n-                }\n-            })\n-        }\n+    /// Awaits for the query job to complete.\n+    ///\n+    /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n+    /// query that means that there is a query cycle, thus this always running a cycle error.\n+    #[cfg(parallel_queries)]\n+    pub(super) fn await<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n+    ) -> Result<(), Box<CycleError<'tcx>>> {\n+        tls::with_related_context(tcx, move |icx| {\n+            let mut waiter = Lrc::new(QueryWaiter {\n+                query: icx.query.clone(),\n+                span,\n+                cycle: Lock::new(None),\n+                condvar: Condvar::new(),\n+            });\n+            self.latch.await(&waiter);\n+            // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+            // although another thread may still have a Lrc reference so we cannot\n+            // use Lrc::get_mut\n+            let mut cycle = waiter.cycle.lock();\n+            match cycle.take() {\n+                None => Ok(()),\n+                Some(cycle) => Err(Box::new(cycle))\n+            }\n+        })\n     }\n \n     #[cfg(not(parallel_queries))]\n     fn find_cycle_in_stack<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n-    ) -> Result<(), CycleError<'tcx>> {\n+    ) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();\n@@ -137,7 +153,7 @@ impl<'tcx> QueryJob<'tcx> {\n                 let usage = job.parent.as_ref().map(|parent| {\n                     (job.info.span, parent.info.query.clone())\n                 });\n-                return Err(CycleError { usage, cycle });\n+                return CycleError { usage, cycle };\n             }\n \n             current_job = job.parent.clone();\n@@ -326,19 +342,17 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // This query is connected to the root (it has no query parent), return true\n-    if query.parent.is_none() {\n-        return true;\n-    }\n-\n     // We already visited this or we're deliberately ignoring it\n     if visited.contains(&query.as_ptr()) {\n         return false;\n     }\n \n-    visited.insert(query.as_ptr());\n+    // This query is connected to the root (it has no query parent), return true\n+    if query.parent.is_none() {\n+        return true;\n+    }\n \n-    let mut connected = false;\n+    visited.insert(query.as_ptr());\n \n     visit_waiters(query, |_, successor| {\n         if connected_to_root(successor, visited) {\n@@ -349,6 +363,28 @@ fn connected_to_root<'tcx>(\n     }).is_some()\n }\n \n+// Deterministically pick an query from a list\n+#[cfg(parallel_queries)]\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n+    tcx: TyCtxt<'_, 'tcx, '_>,\n+    queries: &'a [T],\n+    f: F\n+) -> &'a T {\n+    // Deterministically pick an entry point\n+    // FIXME: Sort this instead\n+    let mut hcx = tcx.create_stable_hashing_context();\n+    queries.iter().min_by_key(|v| {\n+        let (span, query) = f(v);\n+        let mut stable_hasher = StableHasher::<u64>::new();\n+        query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+        // Prefer entry points which have valid spans for nicer error messages\n+        // We add an integer to the tuple ensuring that entry points\n+        // with valid spans are picked first\n+        let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n+        (span_cmp, stable_hasher.finish())\n+    }).unwrap()\n+}\n+\n /// Looks for query cycles starting from the last query in `jobs`.\n /// If a cycle is found, all queries in the cycle is removed from `jobs` and\n /// the function return true.\n@@ -388,41 +424,52 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points = stack.iter().filter_map(|query| {\n-            // Mark all the other queries in the cycle as already visited\n-            let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n-                if q.1.as_ptr() != query.1.as_ptr() {\n-                    Some(q.1.as_ptr())\n-                } else {\n+        let entry_points: Vec<_> = stack.iter().filter_map(|(span, query)| {\n+            if query.parent.is_none() {\n+                // This query is connected to the root (it has no query parent)\n+                Some((*span, query.clone(), None))\n+            } else {\n+                let mut waiters = Vec::new();\n+                // Find all the direct waiters who lead to the root\n+                visit_waiters(query.clone(), |span, waiter| {\n+                    // Mark all the other queries in the cycle as already visited\n+                    let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1.as_ptr()));\n+\n+                    if connected_to_root(waiter.clone(), &mut visited) {\n+                        waiters.push((span, waiter));\n+                    }\n+\n                     None\n+                });\n+                if waiters.is_empty() {\n+                    None\n+                } else {\n+                    // Deterministically pick one of the waiters to show to the user\n+                    let waiter = pick_query(tcx, &waiters, |s| s.clone()).clone();\n+                    Some((*span, query.clone(), Some(waiter)))\n                 }\n-            }));\n-\n-            if connected_to_root(query.1.clone(), &mut visited) {\n-                Some(query.1.clone())\n-            } else {\n-                None\n             }\n-        });\n+        }).collect();\n+\n+        let entry_points: Vec<(Span, Lrc<QueryJob<'tcx>>, Option<(Span, Lrc<QueryJob<'tcx>>)>)>\n+         = entry_points;\n \n         // Deterministically pick an entry point\n-        // FIXME: Sort this instead\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.min_by_key(|q| {\n-            let mut stable_hasher = StableHasher::<u64>::new();\n-            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n-            stable_hasher.finish()\n-        }).unwrap().as_ptr();\n+        let (_, entry_point, usage) = pick_query(tcx, &entry_points, |e| (e.0, e.1.clone()));\n \n         // Shift the stack so that our entry point is first\n-        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        let entry_point_pos = stack.iter().position(|(_, query)| {\n+            query.as_ptr() == entry_point.as_ptr()\n+        });\n         if let Some(pos) = entry_point_pos {\n-            stack.rotate_right(pos);\n+            stack.rotate_left(pos);\n         }\n \n+        let usage = usage.as_ref().map(|(span, query)| (*span, query.info.query.clone()));\n+\n         // Create the cycle error\n         let mut error = CycleError {\n-            usage: None,\n+            usage,\n             cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n                 span: s,\n                 query: q.info.query.clone(),"}, {"sha": "c9ffab21b786ccfadf3beb718767cb64a7dc87ff", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -40,6 +40,7 @@ use traits::query::{\n     CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n+use traits::query::method_autoderef::MethodAutoderefStepsResult;\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::query::outlives_bounds::OutlivesBound;\n@@ -166,21 +167,21 @@ define_queries! { <'tcx>\n         ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n \n         /// True if this is a const fn, use the `is_const_fn` to know whether your crate actually\n-        /// sees it as const fn (e.g. the const-fn-ness might be unstable and you might not have\n+        /// sees it as const fn (e.g., the const-fn-ness might be unstable and you might not have\n         /// the feature gate active)\n         ///\n-        /// DO NOT CALL MANUALLY, it is only meant to cache the base data for the `is_const_fn`\n-        /// function\n+        /// **Do not call this function manually.** It is only meant to cache the base data for the\n+        /// `is_const_fn` function.\n         [] fn is_const_fn_raw: IsConstFn(DefId) -> bool,\n \n \n         /// Returns true if calls to the function may be promoted\n         ///\n-        /// This is either because the function is e.g. a tuple-struct or tuple-variant constructor,\n-        /// or because it has the `#[rustc_promotable]` attribute. The attribute should be removed\n-        /// in the future in favour of some form of check which figures out whether the function\n-        /// does not inspect the bits of any of its arguments (so is essentially just a constructor\n-        /// function)\n+        /// This is either because the function is e.g., a tuple-struct or tuple-variant\n+        /// constructor, or because it has the `#[rustc_promotable]` attribute. The attribute should\n+        /// be removed in the future in favour of some form of check which figures out whether the\n+        /// function does not inspect the bits of any of its arguments (so is essentially just a\n+        /// constructor function).\n         [] fn is_promotable_const_fn: IsPromotableConstFn(DefId) -> bool,\n \n         /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n@@ -539,7 +540,7 @@ define_queries! { <'tcx>\n         [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Lrc<Vec<CrateNum>>,\n \n         /// A vector of every trait accessible in the whole crate\n-        /// (i.e. including those from subcrates). This is used only for\n+        /// (i.e., including those from subcrates). This is used only for\n         /// error reporting.\n         [] fn all_traits: all_traits_node(CrateNum) -> Lrc<Vec<DefId>>,\n     },\n@@ -668,6 +669,10 @@ define_queries! { <'tcx>\n \n         [] fn substitute_normalize_and_test_predicates:\n             substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n+\n+        [] fn method_autoderef_steps: MethodAutoderefSteps(\n+            CanonicalTyGoal<'tcx>\n+        ) -> MethodAutoderefStepsResult<'tcx>,\n     },\n \n     Other {\n@@ -705,21 +710,21 @@ impl<'a, 'tcx, 'lcx> TyCtxt<'a, 'tcx, 'lcx> {\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx [Ty<'tcx>], DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx [Ty<'tcx>], Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::adt_sized_constraint<'_>>(span, key)\n     }\n     pub fn try_needs_drop_raw(\n         self,\n         span: Span,\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Result<bool, DiagnosticBuilder<'a>> {\n+    ) -> Result<bool, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::needs_drop_raw<'_>>(span, key)\n     }\n     pub fn try_optimized_mir(\n         self,\n         span: Span,\n         key: DefId,\n-    ) -> Result<&'tcx mir::Mir<'tcx>, DiagnosticBuilder<'a>> {\n+    ) -> Result<&'tcx mir::Mir<'tcx>, Box<DiagnosticBuilder<'a>>> {\n         self.try_get_query::<queries::optimized_mir<'_>>(span, key)\n     }\n }"}, {"sha": "04c880826fe79c16bba2e093f775d8a7c4550ea0", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -725,7 +725,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n         let hir_id = hir::HirId::decode(self)?;\n-        Ok(self.tcx().hir.hir_to_node_id(hir_id))\n+        Ok(self.tcx().hir().hir_to_node_id(hir_id))\n     }\n }\n \n@@ -926,7 +926,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a\n             local_id,\n         } = *id;\n \n-        let def_path_hash = self.tcx.hir.definitions().def_path_hash(owner);\n+        let def_path_hash = self.tcx.hir().definitions().def_path_hash(owner);\n \n         def_path_hash.encode(self)?;\n         local_id.encode(self)\n@@ -968,7 +968,7 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 't\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n-        let hir_id = self.tcx.hir.node_to_hir_id(*node_id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(*node_id);\n         hir_id.encode(self)\n     }\n }"}, {"sha": "0359890dd932780f1ca7f3d6e156bf4925ea585c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -136,11 +136,14 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                 Entry::Vacant(entry) => {\n                     // No job entry for this query. Return a new one to be started later\n                     return tls::with_related_context(tcx, |icx| {\n+                        // Create the `parent` variable before `info`. This allows LLVM\n+                        // to elide the move of `info`\n+                        let parent = icx.query.clone();\n                         let info = QueryInfo {\n                             span,\n                             query: Q::query(key.clone()),\n                         };\n-                        let job = Lrc::new(QueryJob::new(info, icx.query.clone()));\n+                        let job = Lrc::new(QueryJob::new(info, parent));\n                         let owner = JobOwner {\n                             cache,\n                             job: job.clone(),\n@@ -153,14 +156,25 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             };\n             mem::drop(lock);\n \n-            if let Err(cycle) = job.await(tcx, span) {\n-                return TryGetJob::JobCompleted(Err(cycle));\n+            // If we are single-threaded we know that we have cycle error,\n+            // so we just turn the errror\n+            #[cfg(not(parallel_queries))]\n+            return job.cycle_error(tcx, span);\n+\n+            // With parallel queries we might just have to wait on some other\n+            // thread\n+            #[cfg(parallel_queries)]\n+            {\n+                if let Err(cycle) = job.await(tcx, span) {\n+                    return TryGetJob::JobCompleted(Err(cycle));\n+                }\n             }\n         }\n     }\n \n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n+    #[inline(always)]\n     pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n@@ -197,7 +211,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         let r = tls::with_related_context(tcx, move |current_icx| {\n             // Update the ImplicitCtxt to point to our new query job\n             let new_icx = tls::ImplicitCtxt {\n-                tcx,\n+                tcx: tcx.global_tcx(),\n                 query: Some(self.job.clone()),\n                 layout_depth: current_icx.layout_depth,\n                 task: current_icx.task,\n@@ -217,6 +231,8 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+    #[inline(never)]\n+    #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic\n         self.cache.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n@@ -241,12 +257,16 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     /// The query was already completed.\n     /// Returns the result of the query and its dep node index\n     /// if it succeeded or a cycle error if it failed\n-    JobCompleted(Result<(D::Value, DepNodeIndex), CycleError<'tcx>>),\n+    JobCompleted(Result<(D::Value, DepNodeIndex), Box<CycleError<'tcx>>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub(super) fn report_cycle(self, CycleError { usage, cycle: stack }: CycleError<'gcx>)\n-        -> DiagnosticBuilder<'a>\n+    #[inline(never)]\n+    #[cold]\n+    pub(super) fn report_cycle(\n+        self,\n+        box CycleError { usage, cycle: stack }: Box<CycleError<'gcx>>\n+    ) -> Box<DiagnosticBuilder<'a>>\n     {\n         assert!(!stack.is_empty());\n \n@@ -280,7 +300,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                               &format!(\"cycle used when {}\", query.describe(self)));\n             }\n \n-            return err\n+            return Box::new(err)\n         })\n     }\n \n@@ -345,11 +365,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    #[inline(never)]\n     fn try_get_with<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key)\n-    -> Result<Q::Value, CycleError<'gcx>>\n+    -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n                Q::NAME,\n@@ -436,7 +457,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         job: JobOwner<'a, 'gcx, Q>,\n         dep_node_index: DepNodeIndex,\n         dep_node: &DepNode\n-    ) -> Result<Q::Value, CycleError<'gcx>>\n+    ) -> Result<Q::Value, Box<CycleError<'gcx>>>\n     {\n         // Note this function can be called concurrently from the same query\n         // We must ensure that this is handled correctly\n@@ -522,7 +543,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         job: JobOwner<'_, 'gcx, Q>,\n         dep_node: DepNode)\n-    -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    -> Result<(Q::Value, DepNodeIndex), Box<CycleError<'gcx>>> {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n         //    in DepGraph::try_mark_green()\n@@ -611,37 +632,55 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key,\n         span: Span,\n         dep_node: DepNode\n-    ) -> Result<(Q::Value, DepNodeIndex), CycleError<'gcx>> {\n+    ) {\n+        profq_msg!(\n+            self,\n+            ProfileQueriesMsg::QueryBegin(span.data(), profq_query_msg!(Q::NAME, self, key))\n+        );\n+\n         // We may be concurrently trying both execute and force a query\n         // Ensure that only one of them runs the query\n         let job = match JobOwner::try_get(self, span, &key) {\n             TryGetJob::NotYetStarted(job) => job,\n-            TryGetJob::JobCompleted(result) => return result,\n+            TryGetJob::JobCompleted(_) => return,\n         };\n-        self.force_query_with_job::<Q>(key, job, dep_node)\n+        if let Err(e) = self.force_query_with_job::<Q>(key, job, dep_node) {\n+            self.report_cycle(e).emit();\n+        }\n     }\n \n     pub(super) fn try_get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n-    ) -> Result<Q::Value, DiagnosticBuilder<'a>> {\n+    ) -> Result<Q::Value, Box<DiagnosticBuilder<'a>>> {\n         match self.try_get_with::<Q>(span, key) {\n             Ok(e) => Ok(e),\n             Err(e) => Err(self.report_cycle(e)),\n         }\n     }\n \n+    // FIXME: Try uninlining this\n+    #[inline(always)]\n     pub(super) fn get_query<Q: QueryDescription<'gcx>>(\n         self,\n         span: Span,\n         key: Q::Key,\n     ) -> Q::Value {\n-        self.try_get_query::<Q>(span, key).unwrap_or_else(|mut e| {\n-            e.emit();\n-            Q::handle_cycle_error(self)\n+        self.try_get_with::<Q>(span, key).unwrap_or_else(|e| {\n+            self.emit_error::<Q>(e)\n         })\n     }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn emit_error<Q: QueryDescription<'gcx>>(\n+        self,\n+        e: Box<CycleError<'gcx>>,\n+    ) -> Q::Value {\n+        self.report_cycle(e).emit();\n+        Q::handle_cycle_error(self)\n+    }\n }\n \n macro_rules! handle_cycle_error {\n@@ -806,15 +845,18 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {\n+            #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n+            #[inline(always)]\n             fn query_cache<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n+            #[inline(always)]\n             fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n                 use dep_graph::DepConstructor::*;\n \n@@ -861,6 +903,7 @@ macro_rules! define_queries_inner {\n \n         impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n             type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n@@ -869,6 +912,7 @@ macro_rules! define_queries_inner {\n         impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n             /// Return a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n+            #[inline(always)]\n             pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n                 TyCtxtAt {\n                     tcx: self,\n@@ -877,13 +921,15 @@ macro_rules! define_queries_inner {\n             }\n \n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.at(DUMMY_SP).$name(key)\n             })*\n         }\n \n         impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n             $($(#[$attr])*\n+            #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n                 self.tcx.get_query::<queries::$name<'_>>(self.span, key)\n             })*\n@@ -1023,20 +1069,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n     macro_rules! force {\n         ($query:ident, $key:expr) => {\n             {\n-                use $crate::util::common::{ProfileQueriesMsg, profq_msg};\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        DUMMY_SP.data(),\n-                        profq_query_msg!(::ty::query::queries::$query::NAME, tcx, $key),\n-                    )\n-                );\n-\n-                if let Err(e) = tcx.force_query::<::ty::query::queries::$query<'_>>(\n-                    $key, DUMMY_SP, *dep_node\n-                ) {\n-                    tcx.report_cycle(e).emit();\n-                }\n+                tcx.force_query::<::ty::query::queries::$query<'_>>($key, DUMMY_SP, *dep_node);\n             }\n         }\n     };\n@@ -1089,6 +1122,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::TypeOpNormalizePolyFnSig |\n         DepKind::TypeOpNormalizeFnSig |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n+        DepKind::MethodAutoderefSteps |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |\n "}, {"sha": "88c3e5c8715668fd5423de2ae386418ffcc471b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Generalized type relating mechanism. A type relation R relates a\n-//! pair of values (A, B). A and B are usually types or regions but\n-//! can be other things. Examples of type relations are subtyping,\n-//! type equality, etc.\n+//! Generalized type relating mechanism.\n+//!\n+//! A type relation `R` relates a pair of values `(A, B)`. `A and B` are usually\n+//! types or regions but can be other things. Examples of type relations are\n+//! subtyping, type equality, etc.\n \n use hir::def_id::DefId;\n use mir::interpret::ConstValue;\n@@ -34,9 +35,20 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum TraitObjectMode {\n+    NoSquash,\n+    /// A temporary mode to treat `Send + Sync = Sync + Send`, should be\n+    /// used only in coherence.\n+    SquashAutoTraitsIssue33140\n+}\n+\n pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n+    /// Return the trait object mode to be used.\n+    fn trait_object_mode(&self) -> TraitObjectMode;\n+\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n@@ -595,14 +607,44 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n                            a: &Self,\n                            b: &Self)\n         -> RelateResult<'tcx, Self>\n-            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+        use ty::ExistentialPredicate::*;\n \n-        if a.len() != b.len() {\n+        let tcx = relation.tcx();\n+        let (a_buf, b_buf);\n+        let (a_norm, b_norm): (&[_], &[_]) = match relation.trait_object_mode() {\n+            TraitObjectMode::NoSquash => {\n+                (a, b)\n+            }\n+            TraitObjectMode::SquashAutoTraitsIssue33140 => {\n+                // Treat auto-trait \"principal\" components as equal\n+                // to the non-principal components, to make\n+                // `dyn Send+Sync = dyn Sync+Send`.\n+                let normalize = |d: &[ty::ExistentialPredicate<'tcx>]| {\n+                    let mut result: Vec<_> = d.iter().map(|pi| match pi {\n+                        Trait(ref a) if tcx.trait_is_auto(a.def_id) => {\n+                            AutoTrait(a.def_id)\n+                        },\n+                        other => *other\n+                    }).collect();\n+\n+                    result.sort_by(|a, b| a.stable_cmp(tcx, b));\n+                    result.dedup();\n+                    result\n+                };\n+\n+                a_buf = normalize(a);\n+                b_buf = normalize(b);\n+\n+                (&a_buf, &b_buf)\n+            }\n+        };\n+\n+        if a_norm.len() != b_norm.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n \n-        let tcx = relation.tcx();\n-        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n+        let v = a_norm.iter().zip(b_norm.iter()).map(|(ep_a, ep_b)| {\n             use ty::ExistentialPredicate::*;\n             match (*ep_a, *ep_b) {\n                 (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),"}, {"sha": "1d28c4fa114ef2fbc8d29b839d41f80d8317df10", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -35,6 +35,7 @@ CloneTypeFoldableAndLiftImpls! {\n     usize,\n     ::ty::layout::VariantIdx,\n     u64,\n+    String,\n     ::middle::region::Scope,\n     ::syntax::ast::FloatTy,\n     ::syntax::ast::NodeId,"}, {"sha": "2189267cb0b05e130438fb1feaa9ce2e8febe713", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module contains TyKind and its major components\n+//! This module contains `TyKind` and its major components.\n \n+use hir;\n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n use mir::interpret::ConstValue;\n@@ -30,9 +31,6 @@ use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n-\n-use hir;\n-\n use self::InferTy::*;\n use self::TyKind::*;\n \n@@ -91,7 +89,7 @@ impl BoundRegion {\n     }\n }\n \n-/// N.B., If you change this, you'll probably want to change the corresponding\n+/// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TyKind<'tcx> {\n@@ -531,11 +529,11 @@ impl<'tcx> UpvarSubsts<'tcx> {\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n-    /// e.g. Iterator\n+    /// e.g., Iterator\n     Trait(ExistentialTraitRef<'tcx>),\n-    /// e.g. Iterator::Item = T\n+    /// e.g., Iterator::Item = T\n     Projection(ExistentialProjection<'tcx>),\n-    /// e.g. Send\n+    /// e.g., Send\n     AutoTrait(DefId),\n }\n \n@@ -784,7 +782,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// Binder<TraitRef>`). Note that when we instantiate,\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n-/// e.g. `liberate_late_bound_regions`).\n+/// e.g., `liberate_late_bound_regions`).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(T);\n \n@@ -1020,7 +1018,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n     }\n \n     pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, keywords::SelfType.name().as_interned_str())\n+        ParamTy::new(0, keywords::SelfUpper.name().as_interned_str())\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n@@ -1035,7 +1033,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         // FIXME(#50125): Ignoring `Self` with `idx != 0` might lead to weird behavior elsewhere,\n         // but this should only be possible when using `-Z continue-parse-after-error` like\n         // `compile-fail/issue-36638.rs`.\n-        self.name == keywords::SelfType.name().as_str() && self.idx == 0\n+        self.name == keywords::SelfUpper.name().as_str() && self.idx == 0\n     }\n }\n \n@@ -1099,12 +1097,12 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// with some concrete region before being used. There are 2 kind of\n /// bound regions: early-bound, which are bound in an item's Generics,\n /// and are substituted by a Substs,  and late-bound, which are part of\n-/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// higher-ranked types (e.g., `for<'a> fn(&'a ())`) and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n ///\n /// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n-/// outside their binder, e.g. in types passed to type inference, and\n+/// outside their binder, e.g., in types passed to type inference, and\n /// should first be substituted (by placeholder regions, free regions,\n /// or region variables).\n ///\n@@ -1160,7 +1158,7 @@ pub enum RegionKind {\n     ReFree(FreeRegion),\n \n     /// A concrete region naming some statically determined scope\n-    /// (e.g. an expression or sequence of statements) within the\n+    /// (e.g., an expression or sequence of statements) within the\n     /// current function.\n     ReScope(region::Scope),\n \n@@ -1324,15 +1322,15 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n \n impl DebruijnIndex {\n     /// Returns the resulting index when this value is moved into\n-    /// `amount` number of new binders. So e.g. if you had\n+    /// `amount` number of new binders. So e.g., if you had\n     ///\n     ///    for<'a> fn(&'a x)\n     ///\n     /// and you wanted to change to\n     ///\n     ///    for<'a> fn(for<'b> fn(&'a x))\n     ///\n-    /// you would need to shift the index for `'a` into 1 new binder.\n+    /// you would need to shift the index for `'a` into a new binder.\n     #[must_use]\n     pub fn shifted_in(self, amount: u32) -> DebruijnIndex {\n         DebruijnIndex::from_u32(self.as_u32() + amount)\n@@ -1545,6 +1543,51 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Checks whether a type is definitely uninhabited. This is\n+    /// conservative: for some types that are uninhabited we return `false`,\n+    /// but we only return `true` for types that are definitely uninhabited.\n+    /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n+    /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n+    /// size, to account for partial initialisation. See #49298 for details.)\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        // FIXME(varkor): we can make this less conversative by substituting concrete\n+        // type arguments.\n+        match self.sty {\n+            ty::Never => true,\n+            ty::Adt(def, _) if def.is_union() => {\n+                // For now, `union`s are never considered uninhabited.\n+                false\n+            }\n+            ty::Adt(def, _) => {\n+                // Any ADT is uninhabited if either:\n+                // (a) It has no variants (i.e. an empty `enum`);\n+                // (b) Each of its variants (a single one in the case of a `struct`) has at least\n+                //     one uninhabited field.\n+                def.variants.iter().all(|var| {\n+                    var.fields.iter().any(|field| {\n+                        tcx.type_of(field.did).conservative_is_privately_uninhabited(tcx)\n+                    })\n+                })\n+            }\n+            ty::Tuple(tys) => tys.iter().any(|ty| ty.conservative_is_privately_uninhabited(tcx)),\n+            ty::Array(ty, len) => {\n+                match len.assert_usize(tcx) {\n+                    // If the array is definitely non-empty, it's uninhabited if\n+                    // the type of its elements is uninhabited.\n+                    Some(n) if n != 0 => ty.conservative_is_privately_uninhabited(tcx),\n+                    _ => false\n+                }\n+            }\n+            ty::Ref(..) => {\n+                // References to uninitialised memory is valid for any type, including\n+                // uninhabited types, in unsafe code, so we treat all references as\n+                // inhabited.\n+                false\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_primitive(&self) -> bool {\n         match self.sty {\n             Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n@@ -1787,6 +1830,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_pointer_sized(&self) -> bool {\n+        match self.sty {\n+            Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_machine(&self) -> bool {\n         match self.sty {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => false,\n@@ -1802,10 +1852,10 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Returns the type and mutability of *ty.\n+    /// Returns the type and mutability of `*ty`.\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n-    /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.sty {\n             Adt(def, _) if def.is_box() => {"}, {"sha": "cda281e053a3453013ee90e21b986fa12b9b7ff4", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -316,10 +316,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     /// Transform from substitutions for a child of `source_ancestor`\n-    /// (e.g. a trait or impl) to substitutions for the same child\n+    /// (e.g., a trait or impl) to substitutions for the same child\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n-    /// parameters (e.g. method parameters) on top of that base.\n+    /// parameters (e.g., method parameters) on top of that base.\n     pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        source_ancestor: DefId,\n                        target_substs: &Substs<'tcx>)"}, {"sha": "fadb1a1cf6ee6b2c403647c93fe68e0e6dfd0054", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -189,8 +189,8 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n \n-        for &node_id in tcx.hir.trait_impls(trait_id) {\n-            add_impl(tcx.hir.local_def_id(node_id));\n+        for &node_id in tcx.hir().trait_impls(trait_id) {\n+            add_impl(tcx.hir().local_def_id(node_id));\n         }\n     }\n "}, {"sha": "f9ce228a30c2311150aeeb417d8bbb379e90151c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// themselves. This should really be a unique type; `FreshTy(0)` is a\n     /// popular choice.\n     ///\n-    /// NB: in some cases, particularly around higher-ranked bounds,\n+    /// N.B., in some cases, particularly around higher-ranked bounds,\n     /// this function returns a kind of conservative approximation.\n     /// That is, all regions returned by this function are definitely\n     /// required, but there may be other region bounds that are not\n@@ -451,9 +451,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // destructor will not access borrowed data,\n         // even if such data is otherwise reachable.\n         //\n-        // Such access can be in plain sight (e.g. dereferencing\n+        // Such access can be in plain sight (e.g., dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n-        // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n+        // (e.g., calling `foo.0.clone()` of `Foo<T:Clone>`).\n         if self.has_attr(dtor, \"unsafe_destructor_blind_to_params\") {\n             debug!(\"destructor_constraint({:?}) - blind\", def.did);\n             return vec![];\n@@ -601,7 +601,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Return whether the node pointed to by def_id is a static item, and its mutability\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n-        if let Some(node) = self.hir.get_if_local(def_id) {\n+        if let Some(node) = self.hir().get_if_local(def_id) {\n             match node {\n                 Node::Item(&hir::Item {\n                     node: hir::ItemKind::Static(_, mutbl, _), ..\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely\n     /// non-copy and *might* have a destructor attached; if it returns\n-    /// `false`, then `ty` definitely has no destructor (i.e. no drop glue).\n+    /// `false`, then `ty` definitely has no destructor (i.e., no drop glue).\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n@@ -711,7 +711,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     // Find non representable fields with their spans\n                     fold_repr(def.all_fields().map(|field| {\n                         let ty = field.ty(tcx, substs);\n-                        let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n+                        let span = tcx.hir().span_if_local(field.did).unwrap_or(sp);\n                         match is_type_structurally_recursive(tcx, span, seen,\n                                                              representable_cache, ty)\n                         {"}, {"sha": "68e197849b03e701deaed92afd13465b5c58d6d3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -28,7 +28,7 @@ use lazy_static;\n use session::Session;\n \n // The name of the associated type for `Fn` return types\n-pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n+pub const FN_OUTPUT_NAME: &str = \"Output\";\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n@@ -342,7 +342,7 @@ pub trait MemoizationMap {\n     /// If `key` is present in the map, return the value,\n     /// otherwise invoke `op` and store the value in the map.\n     ///\n-    /// NB: if the receiver is a `DepTrackingMap`, special care is\n+    /// N.B., if the receiver is a `DepTrackingMap`, special care is\n     /// needed in the `op` to ensure that the correct edges are\n     /// added into the dep graph. See the `DepTrackingMap` impl for\n     /// more details!"}, {"sha": "e248f6b42bea247e0dd3fa4ca88e1baf16e536bf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -523,7 +523,7 @@ impl PrintContext {\n                         }\n                     };\n                     let _ = write!(f, \"{}\", name);\n-                    ty::BrNamed(tcx.hir.local_def_id(CRATE_NODE_ID), name)\n+                    ty::BrNamed(tcx.hir().local_def_id(CRATE_NODE_ID), name)\n                 }\n             };\n             tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))\n@@ -679,7 +679,7 @@ impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_path.hir_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_path.hir_id))),\n+               ty::tls::with(|tcx| tcx.hir().name(tcx.hir().hir_to_node_id(self.var_path.hir_id))),\n                self.closure_expr_id)\n     }\n }\n@@ -1208,15 +1208,15 @@ define_print! {\n                         write!(f, \"[static generator\")?;\n                     }\n \n-                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                        write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n+                        write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n                         let mut sep = \" \";\n                         tcx.with_freevars(node_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir.name(freevar.var_id())),\n+                                             tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }\n@@ -1244,19 +1244,19 @@ define_print! {\n                     let upvar_tys = substs.upvar_tys(did, tcx);\n                     write!(f, \"[closure\")?;\n \n-                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                    if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n                         if tcx.sess.opts.debugging_opts.span_free_formats {\n                             write!(f, \"@{:?}\", node_id)?;\n                         } else {\n-                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                            write!(f, \"@{:?}\", tcx.hir().span(node_id))?;\n                         }\n                         let mut sep = \" \";\n                         tcx.with_freevars(node_id, |freevars| {\n                             for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n                                 print!(f, cx,\n                                        write(\"{}{}:\",\n                                              sep,\n-                                             tcx.hir.name(freevar.var_id())),\n+                                             tcx.hir().name(freevar.var_id())),\n                                        print(upvar_ty))?;\n                                 sep = \", \";\n                             }"}, {"sha": "c2bfa62cf9d068737c6a5ea694fdb40778cc1d6a", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -11,7 +11,7 @@\n use session::config::Options;\n \n use std::fs;\n-use std::io::{self, StdoutLock, Write};\n+use std::io::{self, StderrLock, Write};\n use std::time::{Duration, Instant};\n \n macro_rules! define_categories {\n@@ -61,12 +61,16 @@ macro_rules! define_categories {\n                 }\n             }\n \n-            fn print(&self, lock: &mut StdoutLock<'_>) {\n-                writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n+            fn print(&self, lock: &mut StderrLock<'_>) {\n+                writeln!(lock, \"| Phase            | Time (ms)      \\\n+                                | Time (%) | Queries        | Hits (%)\")\n                     .unwrap();\n-                writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n+                writeln!(lock, \"| ---------------- | -------------- \\\n+                                | -------- | -------------- | --------\")\n                     .unwrap();\n \n+                let total_time = ($(self.times.$name + )* 0) as f32;\n+\n                 $(\n                     let (hits, total) = self.query_counts.$name;\n                     let (hits, total) = if total > 0 {\n@@ -78,11 +82,12 @@ macro_rules! define_categories {\n \n                     writeln!(\n                         lock,\n-                        \"| {0: <16} | {1: <14} | {2: <14} | {3: <8} |\",\n+                        \"| {0: <16} | {1: <14} | {2: <8.2} | {3: <14} | {4: <8}\",\n                         stringify!($name),\n                         self.times.$name / 1_000_000,\n+                        ((self.times.$name as f32) / total_time) * 100.0,\n                         total,\n-                        hits\n+                        hits,\n                     ).unwrap();\n                 )*\n             }\n@@ -235,7 +240,7 @@ impl SelfProfiler {\n             self.timer_stack.is_empty(),\n             \"there were timers running when print_results() was called\");\n \n-        let out = io::stdout();\n+        let out = io::stderr();\n         let mut lock = out.lock();\n \n         let crate_name ="}, {"sha": "03d33f413c807e92aee7eb7aeea69d4f0dd1f1c5", "filename": "src/librustc_allocator/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_allocator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_allocator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,4 +16,4 @@ rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n log = \"0.4\"\n-smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "248f2d71f41e58d47454ad79716b695b1b43c832", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,4 +10,4 @@ path = \"lib.rs\"\n [dependencies]\n bitflags = \"1.0\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n-smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "60ddac1abfd46f10c2efda39c983c1571c772092", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -571,7 +571,7 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n             }\n             // Fill with zeros up to precision.\n             if !truncate_zero && precision > digits - 1 {\n-                for _ in 0..precision - digits + 1 {\n+                for _ in 0..=precision - digits {\n                     f.write_char('0')?;\n                 }\n             }\n@@ -926,7 +926,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n \n         // In case MSB resides at the left-hand side of radix point, shift the\n         // mantissa right by some amount to make sure the MSB reside right before\n-        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        // the radix point (i.e., \"MSB . rest-significant-bits\").\n         if omsb > S::PRECISION {\n             let bits = omsb - S::PRECISION;\n             loss = sig::shift_right(&mut wide_sig, &mut self.exp, bits).combine(loss);\n@@ -1969,7 +1969,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         // in a Limb. When this would overflow do we do a single\n         // bignum multiplication, and then revert again to multiplication\n         // in a Limb.\n-        let mut chars = s[first_sig_digit..last_sig_digit + 1].chars();\n+        let mut chars = s[first_sig_digit..=last_sig_digit].chars();\n         loop {\n             let mut val = 0;\n             let mut multiplier = 1;\n@@ -2674,7 +2674,7 @@ mod sig {\n \n         // In case MSB resides at the left-hand side of radix point, shift the\n         // mantissa right by some amount to make sure the MSB reside right before\n-        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        // the radix point (i.e., \"MSB . rest-significant-bits\").\n         //\n         // Note that the result is not normalized when \"omsb < precision\". So, the\n         // caller needs to call IeeeFloat::normalize() if normalized value is"}, {"sha": "c90191716010b7d59784b10ef3ff7db2e54941fb", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -26,8 +26,8 @@\n //! Comments have been preserved where possible, only slightly adapted.\n //!\n //! Instead of keeping a pointer to a configuration struct and inspecting it\n-//! dynamically on every operation, types (e.g. `ieee::Double`), traits\n-//! (e.g. `ieee::Semantics`) and associated constants are employed for\n+//! dynamically on every operation, types (e.g., `ieee::Double`), traits\n+//! (e.g., `ieee::Semantics`) and associated constants are employed for\n //! increased type safety and performance.\n //!\n //! On-heap bigints are replaced everywhere (except in decimal conversion),\n@@ -179,7 +179,7 @@ pub struct ParseError(pub &'static str);\n /// implemented operations. Currently implemented operations are add, subtract,\n /// multiply, divide, fused-multiply-add, conversion-to-float,\n /// conversion-to-integer and conversion-from-integer. New rounding modes\n-/// (e.g. away from zero) can be added with three or four lines of code.\n+/// (e.g., away from zero) can be added with three or four lines of code.\n ///\n /// Four formats are built-in: IEEE single precision, double precision,\n /// quadruple precision, and x87 80-bit extended double (when operating with\n@@ -589,7 +589,7 @@ pub trait Float\n pub trait FloatConvert<T: Float>: Float {\n     /// Convert a value of one floating point type to another.\n     /// The return value corresponds to the IEEE754 exceptions. *loses_info\n-    /// records whether the transformation lost information, i.e. whether\n+    /// records whether the transformation lost information, i.e., whether\n     /// converting the result back to the original type will produce the\n     /// original value (this is almost the same as return value==Status::OK,\n     /// but there are edge cases where this is not so)."}, {"sha": "aaf6b29a99e8cb23b4c6485b18423bc1607be7c0", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -288,7 +288,7 @@ where\n         //   \\   /\n         //   Normal\n         //\n-        // e.g. NaN * NaN = NaN\n+        // e.g., NaN * NaN = NaN\n         //      Zero * Inf = NaN\n         //      Normal * Zero = Zero\n         //      Normal * Inf = Inf"}, {"sha": "836caf22abfa5d09484b2a4db1b28f809c683968", "filename": "src/librustc_asan/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_asan%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_asan%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,4 +16,4 @@ cmake = \"0.1.18\"\n [dependencies]\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+compiler_builtins = \"0.1.0\""}, {"sha": "51afb43d973b724a2f4a32abc5f16cc5e25b7ab5", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        let hir_id = self.tcx().hir.node_to_hir_id(consume_id);\n+        let hir_id = self.tcx().hir().node_to_hir_id(consume_id);\n         self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n     }\n \n@@ -139,7 +139,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n+        let hir_id = self.tcx().hir().node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        self.check_assignment(self.tcx().hir.node_to_hir_id(assignment_id).local_id,\n+        self.check_assignment(self.tcx().hir().node_to_hir_id(assignment_id).local_id,\n                               assignment_span, assignee_cmt);\n     }\n \n@@ -199,10 +199,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n-    let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n+    let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n \n-    let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir.get(node_id) {\n+    let node_id = bccx.tcx.hir().as_local_node_id(def_id).unwrap();\n+    let movable_generator = !match bccx.tcx.hir().get(node_id) {\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     let new_loan_str = &new_loan.kind.to_user_str();\n                     self.bccx.cannot_reborrow_already_uniquely_borrowed(\n                         new_loan.span, \"closure\", &nl, &new_loan_msg, new_loan_str,\n-                        old_loan.span, &old_loan_msg, previous_end_span, Origin::Ast)\n+                        old_loan.span, &old_loan_msg, previous_end_span, \"\", Origin::Ast)\n                 }\n                 (..) =>\n                     self.bccx.cannot_reborrow_already_borrowed(\n@@ -907,7 +907,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             let lp = opt_loan_path(assignee_cmt).unwrap();\n             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n                 if assignee_cmt.mutbl.is_mutable() {\n-                    let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                    let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                     self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable("}, {"sha": "9fa541cdd07b4f67b006f42196d5bf06f4a2380f", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -57,9 +57,9 @@ pub enum PatternSource<'tcx> {\n /// with a reference to the let\n fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n-    let parent = tcx.hir.get_parent_node(pat.id);\n+    let parent = tcx.hir().get_parent_node(pat.id);\n \n-    match tcx.hir.get(parent) {\n+    match tcx.hir().get(parent) {\n         Node::Expr(ref e) => {\n             // the enclosing expression must be a `match` or something else\n             assert!(match e.node {\n@@ -79,7 +79,7 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              var_id: ast::NodeId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    let hir_id = bccx.tcx.hir.node_to_hir_id(var_id);\n+    let hir_id = bccx.tcx.hir().node_to_hir_id(var_id);\n     move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n }\n "}, {"sha": "ccc091a6a1ce6e68860bc9432a98c535b62dc097", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n-                let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n                     self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n             }"}, {"sha": "7ed4d4910d71d8d130e2a6adc6ee3fa2a0d0c234", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -38,13 +38,13 @@ mod move_error;\n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n-    let def_id = bccx.tcx.hir.body_owner_def_id(body);\n+    let def_id = bccx.tcx.hir().body_owner_def_id(body);\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n         item_ub: region::Scope {\n-            id: bccx.tcx.hir.body(body).value.hir_id.local_id,\n+            id: bccx.tcx.hir().body(body).value.hir_id.local_id,\n             data: region::ScopeData::Node\n         },\n         move_data: MoveData::default(),\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    self.bccx.tcx.hir.node_to_hir_id(consume_id).local_id, cmt, move_reason);\n+                    self.bccx.tcx.hir().node_to_hir_id(consume_id).local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        let hir_id = self.bccx.tcx.hir.node_to_hir_id(borrow_id);\n+        let hir_id = self.bccx.tcx.hir().node_to_hir_id(borrow_id);\n         self.guarantee_valid(hir_id.local_id,\n                              borrow_span,\n                              cmt,\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n         let ty = self.bccx\n                      .tables\n-                     .node_id_to_type(self.bccx.tcx.hir.node_to_hir_id(id));\n+                     .node_id_to_type(self.bccx.tcx.hir().node_to_hir_id(id));\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -280,13 +280,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     self.mark_loan_path_as_mutated(&lp);\n                 }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                self.bccx.tcx.hir.node_to_hir_id(assignment_id)\n+                                                self.bccx.tcx.hir().node_to_hir_id(assignment_id)\n                                                     .local_id,\n                                                 assignment_span,\n                                                 lp);\n             }\n             None => {\n-                // This can occur with e.g. `*foo() = 5`.  In such\n+                // This can occur with e.g., `*foo() = 5`.  In such\n                 // cases, there is no need to check for conflicts\n                 // with moves etc, just ignore.\n             }\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             wrapped_path = match current_path.kind {\n                 LpVar(local_id) => {\n                     if !through_borrow {\n-                        let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n+                        let hir_id = self.bccx.tcx.hir().node_to_hir_id(local_id);\n                         self.bccx.used_mut_nodes.borrow_mut().insert(hir_id);\n                     }\n                     None"}, {"sha": "08c5b247b2f65d74afb00ea75c6e01618c3a65e4", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -97,8 +97,8 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            let var_node_id = bccx.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-            err.span_label(bccx.tcx.hir.span(var_node_id),\n+            let var_node_id = bccx.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+            err.span_label(bccx.tcx.hir().span(var_node_id),\n                            \"captured outer variable\");\n         }\n         err.emit();"}, {"sha": "cb1200f462fb635c894b72a004f63cc2c5872ae3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -93,9 +93,9 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n-    let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n+    let owner_id = tcx.hir().as_local_node_id(owner_def_id).unwrap();\n \n-    match tcx.hir.get(owner_id) {\n+    match tcx.hir().get(owner_id) {\n         Node::StructCtor(_) |\n         Node::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n@@ -110,10 +110,10 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n         _ => { }\n     }\n \n-    let body_id = tcx.hir.body_owned_by(owner_id);\n+    let body_id = tcx.hir().body_owned_by(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     let mut bccx = BorrowckCtxt {\n         tcx,\n         tables,\n@@ -169,7 +169,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n     // Check the body of fn items.\n     let tcx = this.tcx;\n     let id_range = {\n-        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir);\n+        let mut visitor = intravisit::IdRangeComputingVisitor::new(&tcx.hir());\n         visitor.visit_body(this.body);\n         visitor.result()\n     };\n@@ -217,18 +217,18 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n }\n \n /// Accessor for introspective clients inspecting `AnalysisData` and\n-/// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n+/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body_id: hir::BodyId,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n-    let owner_id = tcx.hir.body_owner(body_id);\n-    let owner_def_id = tcx.hir.local_def_id(owner_id);\n+    let owner_id = tcx.hir().body_owner(body_id);\n+    let owner_def_id = tcx.hir().local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir.body(body_id);\n+    let body = tcx.hir().body(body_id);\n     let mut bccx = BorrowckCtxt {\n         tcx,\n         tables,\n@@ -418,8 +418,8 @@ pub enum LoanPathElem<'tcx> {\n \n fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n-    let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n-    match tcx.hir.get(closure_id) {\n+    let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n+    match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n@@ -436,12 +436,12 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n         match self.kind {\n             LpVar(local_id) => {\n-                let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n+                let hir_id = bccx.tcx.hir().node_to_hir_id(local_id);\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n             }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n+                let hir_id = bccx.tcx.hir().node_to_hir_id(block_id);\n                 region::Scope { id: hir_id.local_id, data: region::ScopeData::Node }\n             }\n             LpDowncast(ref base, _) |\n@@ -700,8 +700,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                              Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::Closure(id, _) => {\n-                        let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n-                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                        let node_id = self.tcx.hir().as_local_node_id(id).unwrap();\n+                        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                         if let Some((span, name)) = self.tables.closure_kind_origins().get(hir_id) {\n                             err.span_note(*span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n-        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n             owner: self.body.value.hir_id.owner,\n             local_id: the_move.id\n         });\n@@ -731,10 +731,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir.span(node_id), \"\"),\n+            move_data::MovePat => (self.tcx.hir().span(node_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir.expect_expr(node_id).node {\n+                (match self.tcx.hir().expect_expr(node_id).node {\n                     hir::ExprKind::Closure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n@@ -846,8 +846,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     MutabilityViolation => {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n-                            let node_id = self.tcx.hir.hir_to_node_id(upvar_id.var_path.hir_id);\n-                            let sp = self.tcx.hir.span(node_id);\n+                            let node_id = self.tcx.hir().hir_to_node_id(upvar_id.var_path.hir_id);\n+                            let sp = self.tcx.hir().span(node_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n                             match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n@@ -916,8 +916,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 // to implement two traits for \"one operator\" is not very intuitive for\n                 // many programmers.\n                 if err.cmt.note == mc::NoteIndex {\n-                    let node_id = self.tcx.hir.hir_to_node_id(err.cmt.hir_id);\n-                    let node =  self.tcx.hir.get(node_id);\n+                    let node_id = self.tcx.hir().hir_to_node_id(err.cmt.hir_id);\n+                    let node =  self.tcx.hir().get(node_id);\n \n                     // This pattern probably always matches.\n                     if let Node::Expr(\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.note_immutability_blame(\n                     &mut db,\n                     err.cmt.immutability_blame(),\n-                    self.tcx.hir.hir_to_node_id(err.cmt.hir_id)\n+                    self.tcx.hir().hir_to_node_id(err.cmt.hir_id)\n                 );\n                 db.emit();\n                 self.signal_error();\n@@ -1043,7 +1043,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n-                    match self.tcx.hir.find(node_id) {\n+                    match self.tcx.hir().find(node_id) {\n                         Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -1138,8 +1138,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                let node_id = self.tcx.hir.local_def_id_to_node_id(id);\n-                let help_span = self.tcx.hir.span(node_id);\n+                let node_id = self.tcx.hir().local_def_id_to_node_id(id);\n+                let help_span = self.tcx.hir().span(node_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n                                                           (help_span, help_msg),\n@@ -1153,7 +1153,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.note_immutability_blame(\n             &mut err,\n             blame,\n-            self.tcx.hir.hir_to_node_id(cmt.hir_id)\n+            self.tcx.hir().hir_to_node_id(cmt.hir_id)\n         );\n \n         if is_closure {\n@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n-        let pat = match self.tcx.hir.get(node_id) {\n+        let pat = match self.tcx.hir().get(node_id) {\n             Node::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n@@ -1211,13 +1211,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n-        let parent = self.tcx.hir.get_parent_node(node_id);\n-        let parent_node = self.tcx.hir.get(parent);\n+        let parent = self.tcx.hir().get_parent_node(node_id);\n+        let parent_node = self.tcx.hir().get(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n-            let fn_body = self.tcx.hir.body(fn_like.body());\n+            let fn_body = self.tcx.hir().body(fn_like.body());\n             // Get the position of `node_id` in the arguments list\n             let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n             if let Some(i) = arg_pos {\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n                 match self.local_binding_mode(node_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir.span(node_id);\n+                        let let_span = self.tcx.hir().span(node_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion_with_applicability(\n@@ -1272,12 +1272,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n-                let node_id = match self.tcx.hir.as_local_node_id(field.did) {\n+                let node_id = match self.tcx.hir().as_local_node_id(field.did) {\n                     Some(node_id) => node_id,\n                     None => return\n                 };\n \n-                if let Node::Field(ref field) = self.tcx.hir.get(node_id) {\n+                if let Node::Field(ref field) = self.tcx.hir().get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }\n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             db: &mut DiagnosticBuilder,\n                             borrowed_node_id: ast::NodeId,\n                             binding_node_id: ast::NodeId) {\n-        let let_span = self.tcx.hir.span(binding_node_id);\n+        let let_span = self.tcx.hir().span(binding_node_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_node_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_node_id);\n@@ -1309,9 +1309,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     },\n                 )) = ty.map(|t| &t.node)\n                 {\n-                    let borrow_expr_id = self.tcx.hir.get_parent_node(borrowed_node_id);\n+                    let borrow_expr_id = self.tcx.hir().get_parent_node(borrowed_node_id);\n                     db.span_suggestion_with_applicability(\n-                        self.tcx.hir.span(borrow_expr_id),\n+                        self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1381,8 +1381,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 if *kind == ty::ClosureKind::Fn {\n                     let closure_node_id =\n-                        self.tcx.hir.local_def_id_to_node_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir.span(closure_node_id),\n+                        self.tcx.hir().local_def_id_to_node_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir().span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1391,7 +1391,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir.span(local_id);\n+                    let span = self.tcx.hir().span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1416,10 +1416,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       out: &mut String) {\n         match loan_path.kind {\n             LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id}, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir.name(self.tcx.hir.hir_to_node_id(id)).as_str());\n+                out.push_str(&self.tcx.hir().name(self.tcx.hir().hir_to_node_id(id)).as_str());\n             }\n             LpVar(id) => {\n-                out.push_str(&self.tcx.hir.name(id).as_str());\n+                out.push_str(&self.tcx.hir().name(id).as_str());\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n@@ -1530,13 +1530,13 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.hir_to_node_id(var_id);\n-                    tcx.hir.node_to_string(var_node_id)\n+                    let var_node_id = tcx.hir().hir_to_node_id(var_id);\n+                    tcx.hir().node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n@@ -1565,13 +1565,13 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir.node_to_user_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_user_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir.hir_to_node_id(hir_id);\n-                    tcx.hir.node_to_string(var_node_id)\n+                    let var_node_id = tcx.hir().hir_to_node_id(hir_id);\n+                    tcx.hir().node_to_string(var_node_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)\n             }"}, {"sha": "a9a33f35842ce43b0276d6f9e1006a61123a811f", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n     }\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n@@ -114,12 +114,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnusedMutCx<'a, 'tcx> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UsedMutFinder<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir)\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, id: hir::BodyId) {\n-        let def_id = self.bccx.tcx.hir.body_owner_def_id(id);\n+        let def_id = self.bccx.tcx.hir().body_owner_def_id(id);\n         self.set.extend(self.bccx.tcx.borrowck(def_id).used_mut_nodes.iter().cloned());\n-        self.visit_body(self.bccx.tcx.hir.body(id));\n+        self.visit_body(self.bccx.tcx.hir().body(id));\n     }\n }"}, {"sha": "d12c22109c681d3321faaf2fb474af083b0ced9a", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -71,7 +71,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     scope_kills: Vec<usize>,\n \n     /// bits killed as we exit the cfg node directly; if it is jumped\n-    /// over, e.g. via `break`, the kills are not reflected in the\n+    /// over, e.g., via `break`, the kills are not reflected in the\n     /// jump's effects. Updated by `add_kill(KillFrom::Execution)`.\n     action_kills: Vec<usize>,\n \n@@ -111,7 +111,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn nested(&self, state: &mut pprust::State, nested: pprust::Nested) -> io::Result<()> {\n-        pprust::PpAnn::nested(&self.tcx.hir, state, nested)\n+        pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n     fn pre(&self,\n            ps: &mut pprust::State,\n@@ -172,7 +172,7 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n     let mut index = FxHashMap::default();\n \n     // FIXME(#15020) Would it be better to fold formals from decl\n-    // into cfg itself?  i.e. introduce a fn-based flow-graph in\n+    // into cfg itself?  i.e., introduce a fn-based flow-graph in\n     // addition to the current block-based flow-graph, rather than\n     // have to put traversals like this here?\n     if let Some(body) = body {\n@@ -430,7 +430,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 for offset in 0..usize_bits {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n+                        // N.B., we round up the total number of bits\n                         // that we store in any given bit set so that\n                         // it is an even multiple of usize::BITS.  This\n                         // means that there may be some stray bits at"}, {"sha": "b8954dee794f7bba2bdcbc60423d0763c44ba6b1", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -185,7 +185,7 @@ pub trait ArgTypeExt<'ll, 'tcx> {\n \n impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n     /// Get the LLVM type for a place of the original Rust type of\n-    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }"}, {"sha": "48e0a3a12c963ced9a96469b8cca8c694c3fb4da", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,14 +15,16 @@ use rustc::hir::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::Session;\n use rustc::session::config::Sanitizer;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt, PolyFnSig};\n use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::query::Providers;\n+use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_target::spec::PanicStrategy;\n use rustc_codegen_ssa::traits::*;\n \n+use abi::Abi;\n use attributes;\n use llvm::{self, Attribute};\n use llvm::AttributePlace::Function;\n@@ -60,7 +62,7 @@ pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n \n /// Tell LLVM whether the function can or cannot unwind.\n #[inline]\n-pub fn unwind(val: &'ll Value, can_unwind: bool) {\n+fn unwind(val: &'ll Value, can_unwind: bool) {\n     Attribute::NoUnwind.toggle_llfn(Function, val, !can_unwind);\n }\n \n@@ -71,7 +73,7 @@ pub fn set_optimize_for_size(val: &'ll Value, optimize: bool) {\n     Attribute::OptimizeForSize.toggle_llfn(Function, val, optimize);\n }\n \n-/// Tell LLVM if this function should be 'naked', i.e. skip the epilogue and prologue.\n+/// Tell LLVM if this function should be 'naked', i.e., skip the epilogue and prologue.\n #[inline]\n pub fn naked(val: &'ll Value, is_naked: bool) {\n     Attribute::Naked.toggle_llfn(Function, val, is_naked);\n@@ -129,8 +131,7 @@ pub fn llvm_target_features(sess: &Session) -> impl Iterator<Item = &str> {\n }\n \n pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n-    let cpu = llvm_util::target_cpu(cx.tcx.sess);\n-    let target_cpu = CString::new(cpu).unwrap();\n+    let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n     llvm::AddFunctionAttrStringValue(\n             llfn,\n             llvm::AttributePlace::Function,\n@@ -147,12 +148,13 @@ pub fn non_lazy_bind(sess: &Session, llfn: &'ll Value) {\n     }\n }\n \n-/// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n+/// Composite function which sets LLVM attributes for function depending on its AST (`#[attribute]`)\n /// attributes.\n pub fn from_fn_attrs(\n-    cx: &CodegenCx<'ll, '_>,\n+    cx: &CodegenCx<'ll, 'tcx>,\n     llfn: &'ll Value,\n     id: Option<DefId>,\n+    sig: PolyFnSig<'tcx>,\n ) {\n     let codegen_fn_attrs = id.map(|id| cx.tcx.codegen_fn_attrs(id))\n         .unwrap_or_else(|| CodegenFnAttrs::new());\n@@ -194,37 +196,42 @@ pub fn from_fn_attrs(\n             llvm::AttributePlace::ReturnValue, llfn);\n     }\n \n-    let can_unwind = if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n-        Some(true)\n+    unwind(llfn, if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n+        // In panic=abort mode we assume nothing can unwind anywhere, so\n+        // optimize based on this!\n+        false\n+    } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::UNWIND) {\n+        // If a specific #[unwind] attribute is present, use that\n+        true\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n-        Some(false)\n-\n-    // Perhaps questionable, but we assume that anything defined\n-    // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n-    // fn foo(); }` are assumed not to unwind **unless** they have\n-    // a `#[unwind]` attribute.\n-    } else if id.map(|id| !cx.tcx.is_foreign_item(id)).unwrap_or(false) {\n-        Some(true)\n-    } else {\n-        None\n-    };\n-\n-    match can_unwind {\n-        Some(false) => attributes::unwind(llfn, false),\n-        Some(true) if cx.tcx.sess.panic_strategy() == PanicStrategy::Unwind => {\n-            attributes::unwind(llfn, true);\n+        // Special attribute for allocator functions, which can't unwind\n+        false\n+    } else if let Some(id) = id {\n+        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        if cx.tcx.is_foreign_item(id) {\n+            // Foreign items like `extern \"C\" { fn foo(); }` are assumed not to\n+            // unwind\n+            false\n+        } else if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n+            // Any items defined in Rust that *don't* have the `extern` ABI are\n+            // defined to not unwind. We insert shims to abort if an unwind\n+            // happens to enforce this.\n+            false\n+        } else {\n+            // Anything else defined in Rust is assumed that it can possibly\n+            // unwind\n+            true\n         }\n-        Some(true) | None => {}\n-    }\n+    } else {\n+        // assume this can possibly unwind, avoiding the application of a\n+        // `nounwind` attribute below.\n+        true\n+    });\n \n     // Always annotate functions with the target-cpu they are compiled for.\n     // Without this, ThinLTO won't inline Rust functions into Clang generated\n     // functions (because Clang annotates functions this way too).\n-    // NOTE: For now we just apply this if -Zcross-lang-lto is specified, since\n-    //       it introduce a little overhead and isn't really necessary otherwise.\n-    if cx.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled() {\n-        apply_target_cpu_attr(cx, llfn);\n-    }\n+    apply_target_cpu_attr(cx, llfn);\n \n     let features = llvm_target_features(cx.tcx.sess)\n         .map(|s| s.to_string())"}, {"sha": "55ab0724e94b4947adcc6376e1b73b593e3ae70b", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -212,12 +212,7 @@ fn link_binary_output(sess: &Session,\n }\n \n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n-    let mut search = Vec::new();\n-    sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n-        search.push(path.to_path_buf());\n-    });\n-\n-    search\n+    sess.target_filesearch(PathKind::Native).search_path_dirs()\n }\n \n fn archive_config<'a>(sess: &'a Session,\n@@ -462,6 +457,21 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     }\n }\n \n+fn get_file_path(sess: &Session, name: &str) -> PathBuf {\n+    let fs = sess.target_filesearch(PathKind::Native);\n+    let file_path = fs.get_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path\n+    }\n+    for search_path in fs.search_paths() {\n+        let file_path = search_path.dir.join(name);\n+        if file_path.exists() {\n+            return file_path\n+        }\n+    }\n+    PathBuf::from(name)\n+}\n+\n // Create a dynamic library or executable\n //\n // This will invoke the system linker/cc to create the resulting file. This\n@@ -477,7 +487,6 @@ fn link_natively(sess: &Session,\n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n \n-    let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n@@ -505,12 +514,12 @@ fn link_natively(sess: &Session,\n         &sess.target.target.options.pre_link_objects_dll\n     };\n     for obj in pre_link_objects {\n-        cmd.arg(root.join(obj));\n+        cmd.arg(get_file_path(sess, obj));\n     }\n \n     if crate_type == config::CrateType::Executable && sess.crt_static() {\n         for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.arg(root.join(obj));\n+            cmd.arg(get_file_path(sess, obj));\n         }\n     }\n \n@@ -534,11 +543,11 @@ fn link_natively(sess: &Session,\n         cmd.args(args);\n     }\n     for obj in &sess.target.target.options.post_link_objects {\n-        cmd.arg(root.join(obj));\n+        cmd.arg(get_file_path(sess, obj));\n     }\n     if sess.crt_static() {\n         for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.arg(root.join(obj));\n+            cmd.arg(get_file_path(sess, obj));\n         }\n     }\n     if let Some(args) = sess.target.target.options.post_link_args.get(&flavor) {\n@@ -994,7 +1003,7 @@ fn link_args(cmd: &mut dyn Linker,\n     //\n     // The rationale behind this ordering is that those items lower down in the\n     // list can't depend on items higher up in the list. For example nothing can\n-    // depend on what we just generated (e.g. that'd be a circular dependency).\n+    // depend on what we just generated (e.g., that'd be a circular dependency).\n     // Upstream rust libraries are not allowed to depend on our local native\n     // libraries as that would violate the structure of the DAG, in that\n     // scenario they are required to link to them as well in a shared fashion.\n@@ -1003,7 +1012,7 @@ fn link_args(cmd: &mut dyn Linker,\n     // well, but they also can't depend on what we just started to add to the\n     // link line. And finally upstream native libraries can't depend on anything\n     // in this DAG so far because they're only dylibs and dylibs can only depend\n-    // on other dylibs (e.g. other native deps).\n+    // on other dylibs (e.g., other native deps).\n     add_local_native_libraries(cmd, sess, codegen_results);\n     add_upstream_rust_crates(cmd, sess, codegen_results, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess, codegen_results, crate_type);\n@@ -1024,11 +1033,10 @@ fn link_args(cmd: &mut dyn Linker,\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n-        let sysroot = sess.sysroot();\n         let target_triple = sess.opts.target_triple.triple();\n         let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-            let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n+            let tlib = filesearch::relative_target_lib_path(&sess.sysroot, target_triple);\n             let mut path = PathBuf::from(install_prefix);\n             path.push(&tlib);\n \n@@ -1068,12 +1076,13 @@ fn link_args(cmd: &mut dyn Linker,\n fn add_local_native_libraries(cmd: &mut dyn Linker,\n                               sess: &Session,\n                               codegen_results: &CodegenResults) {\n-    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n-        match k {\n-            PathKind::Framework => { cmd.framework_path(path); }\n-            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n+    let filesearch = sess.target_filesearch(PathKind::All);\n+    for search_path in filesearch.search_paths() {\n+        match search_path.kind {\n+            PathKind::Framework => { cmd.framework_path(&search_path.dir); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)); }\n         }\n-    });\n+    }\n \n     let relevant_libs = codegen_results.crate_info.used_libraries.iter().filter(|l| {\n         relevant_lib(sess, l)\n@@ -1205,7 +1214,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n     // compiler-builtins are always placed last to ensure that they're\n     // linked correctly.\n     // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g. `libstd` when `-C prefer-dynamic`\n+    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n         add_static_crate(cmd, sess, codegen_results, tmpdir, crate_type, cnum);\n@@ -1385,7 +1394,7 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n             // because a `dylib` can be reused as an intermediate artifact.\n             //\n             // Note, though, that we don't want to include the whole of a\n-            // compiler-builtins crate (e.g. compiler-rt) because it'll get\n+            // compiler-builtins crate (e.g., compiler-rt) because it'll get\n             // repeatedly linked anyway.\n             if crate_type == config::CrateType::Dylib &&\n                 codegen_results.crate_info.compiler_builtins != Some(cnum) {"}, {"sha": "bddb45da10b004c914169a4f550877552e93b09b", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -48,18 +48,11 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-/// Performs LTO, which in the case of full LTO means merging all modules into\n-/// a single one and returning it for further optimizing. For ThinLTO, it will\n-/// do the global analysis necessary and return two lists, one of the modules\n-/// the need optimization and another for modules that can simply be copied over\n-/// from the incr. comp. cache.\n-pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                  modules: Vec<ModuleCodegen<ModuleLlvm>>,\n-                  cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-                  timeline: &mut Timeline)\n-    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+               timeline: &mut Timeline,\n+               diag_handler: &Handler)\n+    -> Result<(Vec<CString>, Vec<(SerializedModule<ModuleBuffer>, CString)>), FatalError>\n {\n-    let diag_handler = cgcx.create_diag_handler();\n     let export_threshold = match cgcx.lto {\n         // We're just doing LTO for our one crate\n         Lto::ThinLocal => SymbolExportLevel::Rust,\n@@ -144,36 +137,74 @@ pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n     }\n \n+    Ok((symbol_white_list, upstream_modules))\n+}\n+\n+/// Performs fat LTO by merging all modules into a single one and returning it\n+/// for further optimization.\n+pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                      modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                      timeline: &mut Timeline)\n+    -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    match cgcx.lto {\n-        Lto::Fat => {\n-            assert!(cached_modules.is_empty());\n-            let opt_jobs = fat_lto(cgcx,\n-                                   &diag_handler,\n-                                   modules,\n-                                   upstream_modules,\n-                                   &symbol_white_list,\n-                                   timeline);\n-            opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n-        }\n-        Lto::Thin |\n-        Lto::ThinLocal => {\n-            if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n-                unreachable!(\"We should never reach this case if the LTO step \\\n-                              is deferred to the linker\");\n-            }\n-            thin_lto(cgcx,\n-                     &diag_handler,\n-                     modules,\n-                     upstream_modules,\n-                     cached_modules,\n-                     &symbol_white_list,\n-                     timeline)\n+    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &symbol_white_list, timeline)\n+}\n+\n+/// Performs thin LTO by performing necessary global analysis and returning two\n+/// lists, one of the modules that need optimization and another for modules that\n+/// can simply be copied over from the incr. comp. cache.\n+pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                       modules: Vec<(String, ThinBuffer)>,\n+                       cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n+                       timeline: &mut Timeline)\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n+    let symbol_white_list = symbol_white_list.iter()\n+                                             .map(|c| c.as_ptr())\n+                                             .collect::<Vec<_>>();\n+    if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n+        unreachable!(\"We should never reach this case if the LTO step \\\n+                      is deferred to the linker\");\n+    }\n+    thin_lto(cgcx,\n+             &diag_handler,\n+             modules,\n+             upstream_modules,\n+             cached_modules,\n+             &symbol_white_list,\n+             timeline)\n+}\n+\n+pub(crate) fn prepare_thin(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: ModuleCodegen<ModuleLlvm>\n+) -> (String, ThinBuffer) {\n+    let name = module.name.clone();\n+    let buffer = ThinBuffer::new(module.module_llvm.llmod());\n+\n+    // We emit the module after having serialized it into a ThinBuffer\n+    // because only then it will contain the ThinLTO module summary.\n+    if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n+        if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n+            let path = incr_comp_session_dir\n+                .join(pre_lto_bitcode_filename(&name));\n+\n+            fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n+                panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                       path.display(),\n+                       e);\n+            });\n         }\n-        Lto::No => unreachable!(),\n     }\n+\n+    (name, buffer)\n }\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n@@ -182,7 +213,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n-    -> Result<Vec<LtoModuleCodegen<LlvmCodegenBackend>>, FatalError>\n+    -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n@@ -271,10 +302,10 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         timeline.record(\"passes\");\n     }\n \n-    Ok(vec![LtoModuleCodegen::Fat {\n+    Ok(LtoModuleCodegen::Fat {\n         module: Some(module),\n         _serialized_bitcode: serialized_bitcode,\n-    }])\n+    })\n }\n \n struct Linker<'a>(&'a mut llvm::Linker<'a>);\n@@ -335,7 +366,7 @@ impl Drop for Linker<'a> {\n /// they all go out of scope.\n fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             diag_handler: &Handler,\n-            modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+            modules: Vec<(String, ThinBuffer)>,\n             serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n             cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n             symbol_white_list: &[*const libc::c_char],\n@@ -355,41 +386,17 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         let mut module_names = Vec::with_capacity(full_scope_len);\n         let mut thin_modules = Vec::with_capacity(full_scope_len);\n \n-        // FIXME: right now, like with fat LTO, we serialize all in-memory\n-        //        modules before working with them and ThinLTO. We really\n-        //        shouldn't do this, however, and instead figure out how to\n-        //        extract a summary from an in-memory module and then merge that\n-        //        into the global index. It turns out that this loop is by far\n-        //        the most expensive portion of this small bit of global\n-        //        analysis!\n-        for (i, module) in modules.into_iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.name);\n-            let name = CString::new(module.name.clone()).unwrap();\n-            let buffer = ThinBuffer::new(module.module_llvm.llmod());\n-\n-            // We emit the module after having serialized it into a ThinBuffer\n-            // because only then it will contain the ThinLTO module summary.\n-            if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-                if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n-                    let path = incr_comp_session_dir\n-                        .join(pre_lto_bitcode_filename(&module.name));\n-\n-                    fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n-                        panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n-                               path.display(),\n-                               e);\n-                    });\n-                }\n-            }\n-\n+        for (i, (name, buffer)) in modules.into_iter().enumerate() {\n+            info!(\"local module: {} - {}\", i, name);\n+            let cname = CString::new(name.clone()).unwrap();\n             thin_modules.push(llvm::ThinLTOModule {\n-                identifier: name.as_ptr(),\n+                identifier: cname.as_ptr(),\n                 data: buffer.data().as_ptr(),\n                 len: buffer.data().len(),\n             });\n             thin_buffers.push(buffer);\n-            module_names.push(name);\n-            timeline.record(&module.name);\n+            module_names.push(cname);\n+            timeline.record(&name);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the"}, {"sha": "78a3b6907a63d3ac9c06c25066c3feb8976a2272", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -782,7 +782,7 @@ fn create_msvc_imps(\n     }\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n-    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n+    // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n     // underscores added in front).\n     let prefix = if cgcx.target_pointer_width == \"32\" {\n         \"\\x01__imp__\""}, {"sha": "01b1387d9cc2f50dc5284c844541c588ac93716b", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1024,17 +1024,11 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs);\n-            instr.expect(\"LLVMRustBuildMinNum is not available in LLVM version < 6.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n     }\n     fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"maxnum\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs);\n-            instr.expect(\"LLVMRustBuildMaxNum is not available in LLVM version < 6.0\")\n-        }\n+        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n     }\n \n     fn select("}, {"sha": "87185a20c50913ceb3dcc895ffaa38fd5dbb043f", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -94,7 +94,7 @@ pub fn get_fn(\n         if instance.def.is_inline(tcx) {\n             attributes::inline(cx, llfn, attributes::InlineAttr::Hint);\n         }\n-        attributes::from_fn_attrs(cx, llfn, Some(instance.def.def_id()));\n+        attributes::from_fn_attrs(cx, llfn, Some(instance.def.def_id()), sig);\n \n         let instance_def_id = instance.def_id();\n "}, {"sha": "ad14ca7caf60a8683dfaf8c4696a44b79e471e60", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -21,7 +21,7 @@ use value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n-use rustc::mir::interpret::{Scalar, AllocType, Allocation};\n+use rustc::mir::interpret::{Scalar, AllocKind, Allocation};\n use consts::const_alloc_to_llvm;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -63,7 +63,7 @@ pub use context::CodegenCx;\n ///\n /// Each `Block` may contain an instance of this, indicating whether the block\n /// is part of a landing pad or not. This is used to make decision about whether\n-/// to emit `invoke` instructions (e.g. in a landing pad we don't continue to\n+/// to emit `invoke` instructions (e.g., in a landing pad we don't continue to\n /// use `invoke`) and also about various function call metadata.\n ///\n /// For GNU exceptions (`landingpad` + `resume` instructions) this structure is\n@@ -316,20 +316,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             },\n             Scalar::Ptr(ptr) => {\n-                let alloc_type = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                let base_addr = match alloc_type {\n-                    Some(AllocType::Memory(alloc)) => {\n+                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                let base_addr = match alloc_kind {\n+                    Some(AllocKind::Memory(alloc)) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         if alloc.mutability == Mutability::Mutable {\n                             self.static_addr_of_mut(init, alloc.align, None)\n                         } else {\n                             self.static_addr_of(init, alloc.align, None)\n                         }\n                     }\n-                    Some(AllocType::Function(fn_instance)) => {\n+                    Some(AllocKind::Function(fn_instance)) => {\n                         self.get_fn(fn_instance)\n                     }\n-                    Some(AllocType::Static(def_id)) => {\n+                    Some(AllocKind::Static(def_id)) => {\n                         assert!(self.tcx.is_static(def_id).is_some());\n                         self.get_static(def_id)\n                     }"}, {"sha": "086fb1f5a93ccc9f2407e63247d6c8f10e25426e", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -223,10 +223,10 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+        let g = if let Some(id) = self.tcx.hir().as_local_node_id(def_id) {\n \n             let llty = self.layout_of(ty).llvm_type(self);\n-            let (g, attrs) = match self.tcx.hir.get(id) {\n+            let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {\n@@ -295,7 +295,7 @@ impl CodegenCx<'ll, 'tcx> {\n                             self.tcx.sess.opts.cg.prefer_dynamic));\n \n             if needs_dll_storage_attr {\n-                // This item is external but not foreign, i.e. it originates from an external Rust\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n                 // crate. Since we don't know whether this crate will be linked dynamically or\n                 // statically in the final application, we always mark such symbols as 'dllimport'.\n                 // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n@@ -426,7 +426,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // By default a global's alignment can be freely increased.\n                 // This allows LLVM to generate more performant instructions\n-                // e.g. using load-aligned into a SIMD register.\n+                // e.g., using load-aligned into a SIMD register.\n                 //\n                 // However, on macOS 10.10 or below, the dynamic linker does not\n                 // respect any alignment given on the TLS (radar 24221680)."}, {"sha": "b75cd8f68b368070fadbee4c90814dfefaddd51a", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -10,7 +10,6 @@\n \n use attributes;\n use llvm;\n-use llvm_util;\n use rustc::dep_graph::DepGraphSafe;\n use rustc::hir;\n use debuginfo;\n@@ -233,7 +232,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // they're not available to be linked against. This poses a few problems\n         // for the compiler, some of which are somewhat fundamental, but we use\n         // the `use_dll_storage_attrs` variable below to attach the `dllexport`\n-        // attribute to all LLVM functions that are exported e.g. they're\n+        // attribute to all LLVM functions that are exported e.g., they're\n         // already tagged with external linkage). This is suboptimal for a few\n         // reasons:\n         //\n@@ -409,7 +408,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         ));\n \n         let llfn = self.declare_fn(\"rust_eh_unwind_resume\", sig);\n-        attributes::unwind(llfn, true);\n         attributes::apply_target_cpu_attr(self, llfn);\n         unwresume.set(Some(llfn));\n         llfn\n@@ -447,10 +445,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         attributes::apply_target_cpu_attr(self, llfn)\n     }\n \n-    fn closure_env_needs_indirect_debuginfo(&self) -> bool {\n-        llvm_util::get_major_version() < 6\n-    }\n-\n     fn create_used_variable(&self) {\n         let name = const_cstr!(\"llvm.used\");\n         let section = const_cstr!(\"llvm.metadata\");"}, {"sha": "5e2476e0918ffaf9a8c474971970ad686ca4e593", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -166,7 +166,7 @@\n //!\n //! (3) Tuple-, pointer and function types are structurally identified, which\n //!     means that they are equivalent if their component types are equivalent\n-//!     (i.e. (i32, i32) is the same regardless in which crate it is used).\n+//!     (i.e., (i32, i32) is the same regardless in which crate it is used).\n //!\n //! This algorithm also provides a stable ID for types that are defined in one\n //! crate but instantiated from metadata within another crate. We just have to"}, {"sha": "ff5ec20254ea197162b597fc7d429e523c37be23", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -76,7 +76,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir.krate_attrs(),\n+        attr::contains_name(&cx.tcx.hir().krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");\n \n     !omit_gdb_pretty_printer_section &&"}, {"sha": "d263b4e1237808e6ebd59e2288b721cd49dd3f77", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -509,7 +509,7 @@ pub fn type_metadata(\n             },\n             None => {\n                 // The Ty is not in the TypeMap but maybe we have already seen\n-                // an equivalent type (e.g. only differing in region arguments).\n+                // an equivalent type (e.g., only differing in region arguments).\n                 // In order to find out, generate the unique type id and look\n                 // that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);"}, {"sha": "5b65b1fdda64eaa6fa747833d742d2b94941a812", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -300,7 +300,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let mut flags = DIFlags::FlagPrototyped;\n \n-        let local_id = self.tcx().hir.as_local_node_id(def_id);\n+        let local_id = self.tcx().hir().as_local_node_id(def_id);\n         if let Some((id, _, _)) = *self.sess().entry_fn.borrow() {\n             if local_id == Some(id) {\n                 flags |= DIFlags::FlagMainSubprogram;\n@@ -488,7 +488,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     );\n \n                     // Only \"class\" methods are generally understood by LLVM,\n-                    // so avoid methods on other types (e.g. `<*mut T>::null`).\n+                    // so avoid methods on other types (e.g., `<*mut T>::null`).\n                     match impl_self_ty.sty {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))"}, {"sha": "2e827cc6d0601f6e81b3a2aaee94e15dbae26442", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -19,9 +19,9 @@ use rustc_codegen_ssa::traits::*;\n use rustc::hir;\n \n // Compute the name of the type as it should be stored in debuginfo. Does not do\n-// any caching, i.e. calling the function twice with the same type will also do\n+// any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n-// type name, further levels (i.e. type parameters) are always fully qualified.\n+// type name, further levels (i.e., type parameters) are always fully qualified.\n pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                                              t: Ty<'tcx>,\n                                              qualified: bool)"}, {"sha": "4b6ef30b1385c6261546d72ba117ccec77b7a9f4", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::{self, Span};\n pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n-    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // current compilation unit (i.e., if it is *static* in the C-sense). The\n     // *reachable* set should provide a good approximation of this, as it\n     // contains everything that might leak out of the current crate (by being\n     // externally visible or by being inlined into something externally"}, {"sha": "2964f2e58470f00497fc84320e50af16be22d852", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -26,8 +26,7 @@ use rustc::ty::{self, PolyFnSig};\n use rustc::ty::layout::LayoutOf;\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc_target::spec::PanicStrategy;\n-use abi::{Abi, FnType, FnTypeExt};\n+use abi::{FnType, FnTypeExt};\n use attributes;\n use context::CodegenCx;\n use type_::Type;\n@@ -86,10 +85,6 @@ fn declare_raw_fn(\n         _ => {},\n     }\n \n-    if cx.tcx.sess.panic_strategy() != PanicStrategy::Unwind {\n-        attributes::unwind(llfn, false);\n-    }\n-\n     attributes::non_lazy_bind(cx.sess(), llfn);\n \n     llfn\n@@ -132,10 +127,6 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n         }\n \n-        if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n-            attributes::unwind(llfn, false);\n-        }\n-\n         fty.apply_attrs_llfn(llfn);\n \n         llfn"}, {"sha": "e229f8d95cd5b566d09c8ef47cc9f6e445fa8cc3", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -732,7 +732,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             // We found a tuple that needs squishing! So\n                             // run over the tuple and load each field.\n                             //\n-                            // This assumes the type is \"simple\", i.e. no\n+                            // This assumes the type is \"simple\", i.e., no\n                             // destructors, and the contents are SIMD\n                             // etc.\n                             assert!(!bx.type_needs_drop(arg.layout.ty));\n@@ -997,7 +997,7 @@ fn codegen_msvc_try(\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n-// of exceptions (e.g. the normal semantics of LLVM's landingpad and invoke\n+// of exceptions (e.g., the normal semantics of LLVM's landingpad and invoke\n // instructions).\n //\n // This codegen is a little surprising because we always call a shim\n@@ -1081,7 +1081,7 @@ fn gen_fn<'ll, 'tcx>(\n         Abi::Rust\n     ));\n     let llfn = cx.define_internal_fn(name, rust_fn_sig);\n-    attributes::from_fn_attrs(cx, llfn, None);\n+    attributes::from_fn_attrs(cx, llfn, None, rust_fn_sig);\n     let bx = Builder::new_block(cx, llfn, \"entry-block\");\n     codegen(bx);\n     llfn\n@@ -1171,7 +1171,28 @@ fn generic_simd_intrinsic(\n     );\n     let arg_tys = sig.inputs();\n \n-    // every intrinsic takes a SIMD vector as its first argument\n+    if name == \"simd_select_bitmask\" {\n+        let in_ty = arg_tys[0];\n+        let m_len = match in_ty.sty {\n+            // Note that this `.unwrap()` crashes for isize/usize, that's sort\n+            // of intentional as there's not currently a use case for that.\n+            ty::Int(i) => i.bit_width().unwrap(),\n+            ty::Uint(i) => i.bit_width().unwrap(),\n+            _ => return_error!(\"`{}` is not an integral type\", in_ty),\n+        };\n+        require_simd!(arg_tys[1], \"argument\");\n+        let v_len = arg_tys[1].simd_size(tcx);\n+        require!(m_len == v_len,\n+                 \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n+                 m_len, v_len\n+        );\n+        let i1 = bx.type_i1();\n+        let i1xn = bx.type_vector(i1, m_len as u64);\n+        let m_i1s = bx.bitcast(args[0].immediate(), i1xn);\n+        return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n+    }\n+\n+    // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n     let in_ty = arg_tys[0];\n     let in_elem = arg_tys[0].simd_type(tcx);\n@@ -1275,6 +1296,7 @@ fn generic_simd_intrinsic(\n     if name == \"simd_select\" {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n+        require_simd!(arg_tys[1], \"argument\");\n         let v_len = arg_tys[1].simd_size(tcx);\n         require!(m_len == v_len,\n                  \"mismatched lengths: mask length `{}` != other vector length `{}`\","}, {"sha": "ff06d3759bd940e86bc98b2f039510a374f20a75", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -176,13 +176,20 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     fn print_pass_timings(&self) {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n     }\n-    fn run_lto(\n+    fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<ModuleCodegen<Self::Module>>,\n+        timeline: &mut Timeline\n+    ) -> Result<LtoModuleCodegen<Self>, FatalError> {\n+        back::lto::run_fat(cgcx, modules, timeline)\n+    }\n+    fn run_thin_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<(String, Self::ThinBuffer)>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n-        back::lto::run(cgcx, modules, cached_modules, timeline)\n+        back::lto::run_thin(cgcx, modules, cached_modules, timeline)\n     }\n     unsafe fn optimize(\n         cgcx: &CodegenContext<Self>,\n@@ -209,6 +216,12 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     ) -> Result<CompiledModule, FatalError> {\n         back::write::codegen(cgcx, diag_handler, module, config, timeline)\n     }\n+    fn prepare_thin(\n+        cgcx: &CodegenContext<Self>,\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ThinBuffer) {\n+        back::lto::prepare_thin(cgcx, module)\n+    }\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         module: &ModuleCodegen<Self::Module>,"}, {"sha": "4732db88ec1cb60535213affef54373fc772a998", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -1222,12 +1222,12 @@ extern \"C\" {\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         LHS: &'a Value,\n-    ) -> Option<&'a Value>;\n+    ) -> &'a Value;\n     pub fn LLVMRustBuildMaxNum(\n         B: &Builder<'a>,\n         LHS: &'a Value,\n         LHS: &'a Value,\n-    ) -> Option<&'a Value>;\n+    ) -> &'a Value;\n \n     // Atomic Operations\n     pub fn LLVMRustBuildAtomicLoad(B: &Builder<'a>,"}, {"sha": "3764c122dea29343083bfe9a125063c7da05ff60", "filename": "src/librustc_codegen_llvm/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fmod.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -125,7 +125,7 @@ pub fn SetFunctionCallConv(fn_: &'a Value, cc: CallConv) {\n // example happen for generics when using multiple codegen units. This function simply uses the\n // value's name as the comdat value to make sure that it is in a 1-to-1 relationship to the\n // function.\n-// For more details on COMDAT sections see e.g. http://www.airs.com/blog/archives/52\n+// For more details on COMDAT sections see e.g., http://www.airs.com/blog/archives/52\n pub fn SetUniqueComdat(llmod: &Module, val: &'a Value) {\n     unsafe {\n         LLVMRustSetComdat(llmod, val, LLVMGetValueName(val));"}, {"sha": "82b1d7e8b40e4554adb485776992b7aa04924d64", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -124,6 +124,7 @@ const AARCH64_WHITELIST: &[(&str, Option<&str>)] = &[\n ];\n \n const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n+    (\"adx\", Some(\"adx_target_feature\")),\n     (\"aes\", None),\n     (\"avx\", None),\n     (\"avx2\", None),\n@@ -139,6 +140,7 @@ const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n+    (\"cmpxchg16b\", Some(\"cmpxchg16b_target_feature\")),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n@@ -211,6 +213,7 @@ pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n         (\"x86\", \"pclmulqdq\") => \"pclmul\",\n         (\"x86\", \"rdrand\") => \"rdrnd\",\n         (\"x86\", \"bmi1\") => \"bmi\",\n+        (\"x86\", \"cmpxchg16b\") => \"cx16\",\n         (\"aarch64\", \"fp\") => \"fp-armv8\",\n         (\"aarch64\", \"fp16\") => \"fullfp16\",\n         (_, s) => s,"}, {"sha": "9c69d7d8cf4ffa1731930a02381997a486ee0919", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -63,7 +63,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             llvm::SetUniqueComdat(self.llmod, lldecl);\n         }\n \n-        // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n         // compiler-rt, then we want to implicitly compile everything with hidden\n         // visibility as we're going to link this object all over the place but\n         // don't want the symbols to get exported.\n@@ -82,7 +82,12 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         if instance.def.is_inline(self.tcx) {\n             attributes::inline(self, lldecl, attributes::InlineAttr::Hint);\n         }\n-        attributes::from_fn_attrs(self, lldecl, Some(instance.def.def_id()));\n+        attributes::from_fn_attrs(\n+            self,\n+            lldecl,\n+            Some(instance.def.def_id()),\n+            mono_sig,\n+        );\n \n         self.instances.borrow_mut().insert(instance, lldecl);\n     }"}, {"sha": "313ab1f974fdebff30c357620707ce8a33b05b3b", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -255,7 +255,7 @@ impl Type {\n         }\n     }\n \n-    // Creates an integer type with the given number of bits, e.g. i24\n+    // Creates an integer type with the given number of bits, e.g., i24\n     pub fn ix_llcx(\n         llcx: &llvm::Context,\n         num_bits: u64"}, {"sha": "52b560c6625405f3dab9d3af5af57a659f3adea2", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -15,8 +15,8 @@ use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc_target::abi::FloatTy;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use type_::Type;\n use rustc_codegen_ssa::traits::*;\n+use type_::Type;\n \n use std::fmt::Write;\n \n@@ -84,10 +84,10 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let packed = false;\n             match name {\n                 None => {\n-                    cx.type_struct( &[fill], packed)\n+                    cx.type_struct(&[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = cx.type_named_struct( name);\n+                    let llty = cx.type_named_struct(name);\n                     cx.set_struct_body(llty, &[fill], packed);\n                     llty\n                 }\n@@ -236,7 +236,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n+    /// Get the LLVM type corresponding to a Rust type, i.e., `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `PlaceRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n     /// containing a value of that type, and most immediates (except `bool`).\n@@ -470,9 +470,9 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         // (according to its type), or null (which the\n                         // niche field's scalar validity range encodes).\n                         // This allows using `dereferenceable_or_null`\n-                        // for e.g. `Option<&T>`, and this will continue\n+                        // for e.g., `Option<&T>`, and this will continue\n                         // to work as long as we don't start using more\n-                        // niches than just null (e.g. the first page\n+                        // niches than just null (e.g., the first page\n                         // of the address space, or unaligned pointers).\n                         if self.fields.offset(0) == offset {\n                             Some(self.for_variant(cx, dataful_variant))"}, {"sha": "1e5bb03ddb12b9387622a1ac32ba2bc4e314b9fe", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -105,13 +105,30 @@ pub(super) fn emit_va_arg(\n ) -> &'ll Value {\n     // Determine the va_arg implementation to use. The LLVM va_arg instruction\n     // is lacking in some instances, so we should only use it as a fallback.\n+    let target = &bx.cx.tcx.sess.target.target;\n     let arch = &bx.cx.tcx.sess.target.target.arch;\n-    match (&**arch,\n-           bx.cx.tcx.sess.target.target.options.is_like_windows) {\n+    match (&**arch, target.options.is_like_windows) {\n+        // Windows x86\n         (\"x86\", true) => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(4).unwrap(), false)\n         }\n+        // Generic x86\n+        (\"x86\", _) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(4).unwrap(), true)\n+        }\n+        // Windows Aarch64\n+        (\"aarch4\", true) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(8).unwrap(), false)\n+        }\n+        // iOS Aarch64\n+        (\"aarch4\", _) if target.target_os == \"ios\" => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(8).unwrap(), true)\n+        }\n+        // Windows x86_64\n         (\"x86_64\", true) => {\n             let target_ty_size = bx.cx.size_of(target_ty).bytes();\n             let indirect = if target_ty_size > 8 || !target_ty_size.is_power_of_two() {\n@@ -122,15 +139,14 @@ pub(super) fn emit_va_arg(\n             emit_ptr_va_arg(bx, addr, target_ty, indirect,\n                             Align::from_bytes(8).unwrap(), false)\n         }\n-        (\"x86\", false) => {\n-            emit_ptr_va_arg(bx, addr, target_ty, false,\n-                            Align::from_bytes(4).unwrap(), true)\n-        }\n+        // For all other architecture/OS combinations fall back to using\n+        // the LLVM va_arg instruction.\n+        // https://llvm.org/docs/LangRef.html#va-arg-instruction\n         _ => {\n-            let va_list = if (bx.tcx().sess.target.target.arch == \"aarch64\" ||\n-                              bx.tcx().sess.target.target.arch == \"x86_64\" ||\n-                              bx.tcx().sess.target.target.arch == \"powerpc\") &&\n-                             !bx.tcx().sess.target.target.options.is_like_windows {\n+            let va_list = if (target.arch == \"aarch64\" ||\n+                              target.arch == \"x86_64\" ||\n+                              target.arch == \"powerpc\") &&\n+                             !target.options.is_like_windows {\n                 bx.load(addr.immediate(), bx.tcx().data_layout.pointer_align.abi)\n             } else {\n                 addr.immediate()"}, {"sha": "50994497c2843e62b32bbf3475e1f1702687773e", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -16,7 +16,7 @@ num_cpus = \"1.0\"\n rustc-demangle = \"0.1.4\"\n memmap = \"0.6\"\n log = \"0.4.5\"\n-libc = \"0.2.43\"\n+libc = \"0.2.44\"\n jobserver = \"0.1.11\"\n \n serialize = { path = \"../libserialize\" }"}, {"sha": "59102e09d4cbcc29696ffd956f42dea6dc58c0cf", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -192,11 +192,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    if let Some(ret) = infer_from(\n-        sess,\n-        sess.opts.cg.linker.clone(),\n-        sess.opts.debugging_opts.linker_flavor,\n-    ) {\n+    if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), sess.opts.cg.linker_flavor) {\n         return ret;\n     }\n "}, {"sha": "4960c8922b9f98c879a687d033ddf929761d1b9b", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -107,7 +107,7 @@ impl LinkerInfo {\n /// This trait is the total list of requirements needed by `back::link` and\n /// represents the meaning of each option being passed down. This trait is then\n /// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n-/// MSVC linker (e.g. `link.exe`) is being used.\n+/// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn link_dylib(&mut self, lib: &str);\n     fn link_rust_dylib(&mut self, lib: &str, path: &Path);\n@@ -606,8 +606,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(\"/DEBUG\");\n \n         // This will cause the Microsoft linker to embed .natvis info into the PDB file\n-        let sysroot = self.sess.sysroot();\n-        let natvis_dir_path = sysroot.join(\"lib\\\\rustlib\\\\etc\");\n+        let natvis_dir_path = self.sess.sysroot.join(\"lib\\\\rustlib\\\\etc\");\n         if let Ok(natvis_dir) = fs::read_dir(&natvis_dir_path) {\n             // LLVM 5.0.0's lld-link frontend doesn't yet recognize, and chokes\n             // on, the /NATVIS:... flags.  LLVM 6 (or earlier) should at worst ignore"}, {"sha": "a17a00ddb29ff7470aeb755a0133b6328e293303", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5380ea0204dbdcbc8108d259928b67d5f8ebb/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=8ac5380ea0204dbdcbc8108d259928b67d5f8ebb", "patch": "@@ -85,17 +85,17 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // categories:\n             //\n             // 1. Those that are included statically via a static library\n-            // 2. Those included otherwise (e.g. dynamically or via a framework)\n+            // 2. Those included otherwise (e.g., dynamically or via a framework)\n             //\n             // Although our LLVM module is not literally emitting code for the\n             // statically included symbols, it's an export of our library which\n             // needs to be passed on to the linker and encoded in the metadata.\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir.get(node_id) {\n+            match tcx.hir().get(node_id) {\n                 Node::ForeignItem(..) => {\n-                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n                     } else {\n@@ -115,7 +115,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {\n-                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let def_id = tcx.hir().local_def_id(node_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&\n                         // Functions marked with #[inline] are only ever codegened\n@@ -158,12 +158,12 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .collect();\n \n     if let Some(id) = *tcx.sess.proc_macro_decls_static.get() {\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n     if let Some(id) = *tcx.sess.plugin_registrar_fn.get() {\n-        let def_id = tcx.hir.local_def_id(id);\n+        let def_id = tcx.hir().local_def_id(id);\n         reachable_non_generics.insert(def_id, SymbolExportLevel::C);\n     }\n \n@@ -225,7 +225,7 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them.\n-        const PROFILER_WEAK_SYMBOLS: [&'static str; 2] = [\n+        const PROFILER_WEAK_SYMBOLS: [&str; 2] = [\n             \"__llvm_profile_raw_version\",\n             \"__llvm_profile_filename\",\n         ];\n@@ -355,7 +355,7 @@ fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n@@ -393,7 +393,7 @@ fn symbol_export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n             if let Some(Node::Item(&hir::Item {\n                 node: hir::ItemKind::Static(..),\n                 ..\n-            })) = tcx.hir.get_if_local(sym_def_id) {\n+            })) = tcx.hir().get_if_local(sym_def_id) {\n                 return SymbolExportLevel::Rust;\n             }\n         }"}]}