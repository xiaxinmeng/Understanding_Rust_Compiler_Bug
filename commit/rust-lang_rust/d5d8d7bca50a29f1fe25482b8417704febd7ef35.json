{"sha": "d5d8d7bca50a29f1fe25482b8417704febd7ef35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZDhkN2JjYTUwYTI5ZjFmZTI1NDgyYjg0MTc3MDRmZWJkN2VmMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-20T09:21:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-20T09:21:18Z"}, "message": "Auto merge of #3779 - mikerite:fix-3704, r=phansch\n\nImprove `iter_cloned_collect` suggestions\n\nFixes #3704", "tree": {"sha": "86074856af29f02e963f87fbe8f8e8de24042175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86074856af29f02e963f87fbe8f8e8de24042175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d8d7bca50a29f1fe25482b8417704febd7ef35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d8d7bca50a29f1fe25482b8417704febd7ef35", "html_url": "https://github.com/rust-lang/rust/commit/d5d8d7bca50a29f1fe25482b8417704febd7ef35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d8d7bca50a29f1fe25482b8417704febd7ef35/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "075c212849ad2207c0b0ccbd0ec6cc5b1f392275", "url": "https://api.github.com/repos/rust-lang/rust/commits/075c212849ad2207c0b0ccbd0ec6cc5b1f392275", "html_url": "https://github.com/rust-lang/rust/commit/075c212849ad2207c0b0ccbd0ec6cc5b1f392275"}, {"sha": "bef7c76025b0373b9e4c6b74620467810646afc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bef7c76025b0373b9e4c6b74620467810646afc3", "html_url": "https://github.com/rust-lang/rust/commit/bef7c76025b0373b9e4c6b74620467810646afc3"}], "stats": {"total": 83, "additions": 60, "deletions": 23}, "files": [{"sha": "739f6e3990a340fea2abcf0e6ec84f8c610a48cb", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d5d8d7bca50a29f1fe25482b8417704febd7ef35/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d8d7bca50a29f1fe25482b8417704febd7ef35/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d5d8d7bca50a29f1fe25482b8417704febd7ef35", "patch": "@@ -1477,17 +1477,22 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Ex\n     }\n }\n \n-fn lint_iter_cloned_collect(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n-        && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n-    {\n-        span_lint(\n-            cx,\n-            ITER_CLONED_COLLECT,\n-            expr.span,\n-            \"called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-             more readable\",\n-        );\n+fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr]) {\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) {\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])) {\n+            if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite()) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_CLONED_COLLECT,\n+                    to_replace,\n+                    \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                     more readable\",\n+                    \"try\",\n+                    \".to_vec()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n     }\n }\n \n@@ -1573,7 +1578,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     };\n }\n \n-fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+fn lint_iter_nth<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -1596,7 +1601,7 @@ fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::E\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_args: &'tcx [hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n@@ -1681,7 +1686,11 @@ fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n+fn derefs_to_slice<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    ty: Ty<'tcx>,\n+) -> Option<&'tcx hir::Expr> {\n     fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n             ty::Slice(_) => true,\n@@ -1695,17 +1704,17 @@ fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Op\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &args[0]).map(sugg::Sugg::addr)\n+            Some(&args[0])\n         } else {\n             None\n         }\n     } else {\n         match ty.sty {\n-            ty::Slice(_) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n+            ty::Slice(_) => Some(expr),\n+            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n                 if may_slice(cx, inner) {\n-                    sugg::Sugg::hir_opt(cx, expr)\n+                    Some(expr)\n                 } else {\n                     None\n                 }"}, {"sha": "570536d0a56f5cee0a544dcbb181f369151ccfe5", "filename": "tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5d8d7bca50a29f1fe25482b8417704febd7ef35/tests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d8d7bca50a29f1fe25482b8417704febd7ef35/tests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.rs?ref=d5d8d7bca50a29f1fe25482b8417704febd7ef35", "patch": "@@ -66,6 +66,18 @@ fn iter_clone_collect() {\n     let v2: Vec<isize> = v.iter().cloned().collect();\n     let v3: HashSet<isize> = v.iter().cloned().collect();\n     let v4: VecDeque<isize> = v.iter().cloned().collect();\n+\n+    // Handle macro expansion in suggestion\n+    let _: Vec<isize> = vec![1, 2, 3].iter().cloned().collect();\n+\n+    // Issue #3704\n+    unsafe {\n+        let _: Vec<u8> = std::ffi::CStr::from_ptr(std::ptr::null())\n+            .to_bytes()\n+            .iter()\n+            .cloned()\n+            .collect();\n+    }\n }\n \n mod many_derefs {"}, {"sha": "a014478597fc3406fed86b6d30ac5e3c8909457d", "filename": "tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d5d8d7bca50a29f1fe25482b8417704febd7ef35/tests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5d8d7bca50a29f1fe25482b8417704febd7ef35/tests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.stderr?ref=d5d8d7bca50a29f1fe25482b8417704febd7ef35", "patch": "@@ -78,19 +78,35 @@ help: or try being explicit about what type to clone\n LL |     let z: &Vec<_> = &std::vec::Vec<i32>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n-  --> $DIR/unnecessary_clone.rs:66:26\n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:66:27\n    |\n LL |     let v2: Vec<isize> = v.iter().cloned().collect();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.to_vec()`\n    |\n    = note: `-D clippy::iter-cloned-collect` implied by `-D warnings`\n \n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:71:38\n+   |\n+LL |     let _: Vec<isize> = vec![1, 2, 3].iter().cloned().collect();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.to_vec()`\n+\n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:76:24\n+   |\n+LL |               .to_bytes()\n+   |  ________________________^\n+LL | |             .iter()\n+LL | |             .cloned()\n+LL | |             .collect();\n+   | |______________________^ help: try: `.to_vec()`\n+\n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:102:20\n+  --> $DIR/unnecessary_clone.rs:114:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n "}]}